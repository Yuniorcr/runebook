<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">SQLite 웹 사이트의 동적 웹 페이지는 대부분 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템에&lt;/a&gt; 의해 생성됩니다 . 일반적인 동적 페이지는 &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt; 과 같은 타임 라인 입니다. 타임 라인에서 사용하는 모든 SQL의 로그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep 인수는 조합 함수 콜백 xCallback에 전달 된 문자열의 인코딩을 결정합니다. &lt;a href=&quot;#SQLITE_ANY&quot;&gt;eTextRep에&lt;/a&gt; 대한 SQLITE_UTF16 및 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; 값은 문자열을 기본 바이트 순서로 UTF16으로 만듭니다. &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRep 힘 문자열에 대한 값은 더 바이트 주소에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep 인수는 조합 함수 콜백 xCallback에 전달 된 문자열의 인코딩을 결정합니다. &lt;a href=&quot;c_any&quot;&gt;eTextRep에&lt;/a&gt; 대한 SQLITE_UTF16 및 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; 값은 문자열을 기본 바이트 순서로 UTF16으로 만듭니다. &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRep 힘 문자열에 대한 값은 더 바이트 주소에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">편집 거리 계수는 일반적으로 APPCOST 테이블에서 한 번 읽은 다음 메모리에 저장된 후에 읽습니다. 따라서 APPCOST 테이블의 런타임 변경 사항은 일반적으로 편집 거리 결과에 영향을 미치지 않습니다. 그러나 특수 문자열 'reset'을 가상 테이블의 &quot;command&quot;열에 삽입하면 편집 거리 계수가 APPCOST 테이블을 다시 읽습니다. 따라서 애플리케이션은 APPCOST 테이블이 변경 될 때 다음과 유사한 SQL 문을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">편집 프로그램은 단순히 반환 값을 무시하여 뷰어로 사용할 수도 있습니다. 예를 들어, 위의 이미지 만 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">edit () 함수를 사용하여 큰 텍스트 값을 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">editdist3 알고리즘은 두 입력 문자열 사이의 최소 편집 거리 (일명 Levenshtein 거리)를 계산하는 함수입니다. editdist3 알고리즘은 spellfix1의 기본 편집 거리 기능에 대한 구성 가능한 대안입니다. editdist3의 특징은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">&lt;b&gt;파일 자르기&lt;/b&gt; 조작 의 영향은 해당 파일이 완료 될 때까지 지속되는 것으로 가정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">empty-result-callbacks 플래그는 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; API에만 영향을줍니다 . 일반적으로 empty-result-callbacks 플래그가 지워지면, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()에&lt;/a&gt; 제공된 콜백 함수 는 0 행의 데이터를 리턴하는 명령에 대해 호출되지 않습니다. 이 상황에서 빈 결과 콜백이 설정되면 세 번째 매개 변수가 0 (NULL)으로 설정된 콜백 함수가 정확히 한 번 호출됩니다. 이는 쿼리가 데이터를 반환하지 않더라도 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; API를 사용하는 프로그램이 열 이름을 검색 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">최종 사용자는 데이터베이스 파일의 데이터베이스 파일 구조를 수정해야하는 DML 또는 DDL SQL 문을 실행합니다. 이러한 수정은 작업의 조합 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">종료 프레임 경계는 생략 할 수 있습니다 (시작 프레임 경계를 둘러싼 BETWEEN 및 AND 키워드도 생략 된 경우). 종료 프레임 경계의 기본값은 CURRENT ROW입니다.</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">끝 프레임 경계는 시작 프레임 경계보다 위 목록에서 더 높은 형태로 나타나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">인덱스에서 필요한 모든 정보를 얻을 수 있으면 엔진은 더 이상 기본 테이블을 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">향상된 쿼리 구문은 AND, OR 및 NOT 이진 집합 연산자를 지원합니다. 연산자에 대한 두 피연산자 각각은 기본 FTS 쿼리이거나 다른 AND, OR 또는 NOT 설정 연산의 결과 일 수 있습니다. 연산자는 대문자를 사용하여 입력해야합니다. 그렇지 않으면, 세트 연산자 대신 기본 용어 쿼리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">위의 항목은 (예를 들어) SQLite.org 본사 주변의 경계 상자와 SQLite.org가 위치한 노스 캐롤라이나 12 차 의회 지구 (2011 재 구획 이전)의 경계 상자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">진입 점은 zProc입니다. zProc는 0 일 수 있으며,이 경우 SQLite는 자체적으로 진입 점 이름을 표시하려고 시도합니다. 먼저 &quot;sqlite3_extension_init&quot;를 시도합니다. 그래도 작동하지 않으면 &quot;sqlite3_X_init&quot;라는 이름을 구성합니다. 여기서 X는 파일 이름의 마지막 &quot;/&quot;에서 첫 번째 &quot;&quot;까지의 모든 ASCII 알파벳 문자에 해당하는 소문자로 구성됩니다. 초기 &quot;lib&quot;를 생략합니다. sqlite3_load_extension () 인터페이스는 성공 하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; , 무언가 잘못되면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환합니다 . 오류가 발생하고 pzErrMsg가 0이 아닌 경우 &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 저장된 오류 메시지 텍스트로 * pzErrMsg를 채우려 고 시도합니다.. 호출 함수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출하여이 메모리를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">진입 점은 zProc입니다. zProc는 0 일 수 있으며,이 경우 SQLite는 자체적으로 진입 점 이름을 표시하려고 시도합니다. 먼저 &quot;sqlite3_extension_init&quot;를 시도합니다. 그래도 작동하지 않으면 &quot;sqlite3_X_init&quot;라는 이름을 구성합니다. 여기서 X는 파일 이름의 마지막 &quot;/&quot;에서 첫 번째 &quot;&quot;까지의 모든 ASCII 알파벳 문자에 해당하는 소문자로 구성됩니다. 초기 &quot;lib&quot;를 생략합니다. sqlite3_load_extension () 인터페이스는 성공 하면 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_OK를&lt;/a&gt; , 무언가 잘못되면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환합니다 . 오류가 발생하고 pzErrMsg가 0이 아닌 경우 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 저장된 오류 메시지 텍스트로 * pzErrMsg를 채우려 고 시도합니다.. 호출 함수는 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출하여이 메모리를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">하나 이상의 쿼리가 여전히 보류중인 동안 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 을 시도하면 오류 코드가 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 대신 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">SQLite 버전 3의 오류 코드는 버전 2에서 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">오류 로거 콜백 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">에러 로거 콜백은 시그널 핸들러처럼 취급되어야합니다. 응용 프로그램은 오류를 저장하거나 처리 한 다음 가능한 빨리 반환해야합니다. 오류 로거에서 다른 SQLite API를 직접 또는 간접적으로 호출해서는 안됩니다. 오류 로거 콜백을 통해 SQLite를 다시 입력 할 수 &lt;u&gt;없습니다&lt;/u&gt; . 특히, 메모리 할당이 실패하면 오류 로거 콜백이 호출되므로 일반적으로 오류 로거 내부에 메모리를 할당하려고 시도하는 것은 좋지 않습니다. 다른 SQLite 데이터베이스에 오류 메시지를 저장하려고 시도조차하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">오류 로거로 전송 될 수있는 오류 메시지 및 정확한 형식은 릴리스마다 변경 될 수 있습니다. 따라서 응용 프로그램은 특정 오류 메시지 텍스트 형식이나 오류 코드에 의존해서는 안됩니다. 변덕스럽게 변하지는 않지만 때로는 변하기도합니다.</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">추정 비용 필드는 가상 테이블에 대해이 쿼리를 실행하는 데 필요한 예상 디스크 액세스 조작 수로 설정해야합니다. SQLite 코어는 종종 서로 다른 제약 조건으로 xBestIndex를 여러 번 호출하고 여러 비용 견적을 얻은 다음 가장 낮은 견적을 제공하는 쿼리 계획을 선택합니다. SQLite 코어는 xBestIndex를 호출하기 전에 추정 된 비용을 매우 큰 값으로 초기화하므로, xBestIndex가 현재 매개 변수 조합이 바람직하지 않다고 판단하면 추정 된 비용 필드를 변경하지 않고 사용하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">추정 비용 값은 특정 전략 비용의 추정치입니다. N 비용은 전략 비용이 N 개의 행이있는 SQLite 테이블의 선형 스캔과 유사 함을 나타냅니다. log (N)의 비용은 연산 비용이 N 개의 행이있는 SQLite 테이블의 고유 인덱스 필드에 대한 이진 검색의 비용과 유사 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">추정 행 값은 전략에 의해 리턴 될 행 수의 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">여부를 결정하는 데 사용되는 정확한 논리</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">정확히 동일한 소스 코드를 런타임로드 가능 공유 라이브러리 또는 DLL 및 응용 프로그램과 정적으로 연결된 모듈로 사용할 수 있습니다. 이는 유연성을 제공하며 동일한 코드를 다른 방식으로 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">위의 예제는 &quot;ex1.db&quot;라는 데이터베이스 파일을 열고 사용합니다. &quot;ex1.db&quot;파일이 이전에 없으면 작성됩니다. 파일이 생각한 디렉토리에 파일이 있는지 확인하기 위해 전체 경로 이름을 사용할 수 있습니다. 디렉토리 분리 문자로 슬래시를 사용하십시오. 즉, &quot;c : \ work \ ex1.db&quot;가 아닌 &quot;c : /work/ex1.db&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">위의 예에는 두 개의 &quot;SCALAR&quot;하위 쿼리가 포함되어 있습니다. 서브 쿼리는 단일 행, 하나의 컬럼 테이블 인 단일 값을 리턴한다는 점에서 SCALAR입니다. 실제 쿼리가 그 이상을 반환하면 첫 번째 행의 첫 번째 열만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">위의 예는 오류 로거 콜백의 서명을 보여줍니다. 그러나 임베디드 응용 프로그램에서는 보통 stderr에 메시지를 인쇄하지 않습니다. 대신, 사전 할당 된 순환 버퍼에 메시지를 저장하여 디버깅 중에 진단 정보가 필요할 때 액세스 할 수 있습니다. 또는 메시지가 &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt; 로 전송 될 수 있습니다 . 어떻게 든 메시지는 최종 사용자에게는 표시되지 않고 개발자가 액세스 할 수있는 곳에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">위의 예 는 CSV 가상 테이블에 대한 단일 &lt;b&gt;filename = 'thefile.csv'&lt;/b&gt; 인수를 보여줍니다. 그러나 다른 주장도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">위의 예는 SQLite 피킹 전체 테이블 스캔이 테이블의 모든 행을 방문 함을 보여줍니다. 쿼리가 인덱스를 사용할 수있는 경우 SCAN / SEARCH 레코드는 인덱스의 이름과 SEARCH 레코드의 경우 방문한 행의 서브 세트가 식별되는 방법을 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">아래 예제는 ntile ()을 사용하여 6 개의 행을 두 그룹 (ntile (2) 호출)과 4 개의 그룹 (ntile (4) 호출)으로 나눕니다. ntile (2)의 경우 각 그룹에 3 개의 행이 할당됩니다. ntile (4)의 경우 두 그룹의 두 그룹과 하나의 그룹이 있습니다. 두 그룹 중 더 큰 그룹이 먼저 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">아래의 예제 코드는 SQL 명령을 실행하는 동안 변경 세트를 캡처하는 단계를 보여줍니다. 요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">아래 예제 코드는 변경 세트의 모든 변경과 관련된 데이터를 반복하고 추출하는 데 사용되는 기술을 보여줍니다. 요약:</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">아래 예제 코드는 위에 열거 된 두 번째 방법을 사용합니다. 모든 데이터베이스 테이블의 변경 사항을 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">위의 예제는 모두 집합 연산의 두 피연산자가 모두 설명했듯이 기본 전체 텍스트 용어 쿼리를 사용합니다. 다른 세트 연산의 결과와 마찬가지로 구문 및 NEAR 쿼리도 사용할 수 있습니다. FTS 쿼리에 둘 이상의 설정 작업이있는 경우 연산자의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">아래 예는 다양한 SQL 문으로 수행 될 수있는 텍스트 비교 결과를 판별하는 데 사용되는 조합 순서를 식별합니다. 숫자, blob 또는 NULL 값의 경우 텍스트 비교가 필요하지 않고 조합 순서가 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">이 섹션의 예제는 모두 데이터베이스가 다음과 같이 채워져 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">이 섹션의 예제는 모두 다음 데이터를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">위에서 언급 한 예외는 선언 된 유형이 &quot;INTEGER&quot;인 컬럼의 선언에 &quot;PRIMARY KEY DESC&quot;절이 포함 된 경우 rowid의 별명이되지 않으며 정수 기본 키로 분류되지 않는다는 것입니다. 이 문제는 의도적으로 설계된 것이 아닙니다. SQLite 초기 버전의 버그 때문입니다. 그러나 버그를 수정하면 이전 버전과의 비 호환성이 발생할 수 있습니다. 따라서 모퉁이의 경우 이상한 동작이 호환성 중단보다 훨씬 우수하기 때문에 원래 동작이 유지되고 문서화되었습니다. 이것은 다음 3 개의 테이블 선언으로 인해 &quot;x&quot;열이 rowid (정수 1 차 키)의 별명이되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">트랜잭션의 존재는 롤백 저널 파일이 존재하는지 여부에 따라 다르며 파일 삭제는 사용자 공간 프로세스의 관점에서 원자적인 조작으로 보입니다. 따라서 트랜잭션은 원 자성 작업 인 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">기존 INSERT가 변경 그룹에서 제거됩니다. DELETE가 추가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">기존 UPDATE는 변경 그룹 내의 새로운 DELETE로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">기존 UPDATE는 변경 그룹 내에 남아 있습니다. 행이 기존 변경 사항에 의해 한 번 갱신 된 후 새 변경 사항에 의해 다시 갱신 된 것처럼 수반되는 값이 수정되도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">보류중인 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문 이 있어도 명시 적 COMMIT 명령은 즉시 실행됩니다 . 그러나 보류중인 쓰기 조작이 있으면 COMMIT 명령이 오류 코드 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 와 함께 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">식 &quot;+ 컬럼&quot;은 식에서 사용할 배열 순서를 계산할 때 &quot;컬럼&quot;과 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">표현 &quot;a BETWEEN b AND c&quot;는 각각의 비교에서 상이한 친 화성이 'a'에 적용된다는 것을 의미하더라도, 2 개의 개별 이진 비교 &quot;a&amp;gt; = b AND a &amp;lt;= c&quot;로 취급된다. &quot;x IN (SELECT y ...)&quot;형식의 비교에서 데이터 유형 변환은 비교가 실제로 &quot;x = y&quot;인 경우 처리됩니다. &quot;a IN (x, y, z, ...)&quot;표현은 &quot;a = + x OR a = + y OR a = + z OR ...&quot;와 같습니다. 즉, IN 연산자의 오른쪽에있는 값 (이 예에서 &quot;x&quot;, &quot;y&quot;및 &quot;z&quot;값)은 열 값 또는 CAST 표현식이더라도 친 화성이없는 것으로 간주됩니다. .</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">표현 &quot;x BETWEEN y 및 z&quot;는 논리적으로 두 비교 &quot;x&amp;gt; = y AND x &amp;lt;= z&quot;와 동일하며 두 개의 개별 비교 인 것처럼 배열 함수와 관련하여 작동합니다. &quot;x IN (SELECT y ...)&quot;표현은 조합 순서를 결정하기 위해 &quot;x = y&quot;표현과 같은 방식으로 처리됩니다. &quot;x IN (y, z, ...)&quot;형식의 표현식에 사용되는 조합 순서는 x의 조합 순서입니다.</target>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">LIMIT 절 뒤에 올 수있는 선택적 OFFSET 절에 첨부 된 표현식은 정수 또는 무손실 정수로 변환 될 수있는 값으로 평가되어야합니다. 식에 OFFSET 절이 있으면 SELECT 문에서 반환 한 결과 집합에서 첫 번째 M 행이 생략되고 다음 N 행이 반환됩니다. 여기서 M 및 N은 각각 OFFSET 및 LIMIT 절이 평가하는 값입니다. 또는 LIMIT 절이없는 경우 SELECT가 M + N 미만의 행을 리턴하면 첫 번째 M 행을 건너 뛰고 나머지 행 (있는 경우)이 리턴됩니다. OFFSET 절이 음수 값으로 평가되면 결과는 0으로 평가 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">WHERE 절 다음의 표현식에는 인덱싱되는 테이블의 연산자, 리터럴 값 및 열 이름이 포함될 수 있습니다. WHERE 절은 할 수 &lt;em&gt;없습니다&lt;/em&gt; 하위 쿼리, 다른 테이블에 대한 참조 포함 &lt;a href=&quot;deterministic&quot;&gt;비 결정적 기능을&lt;/a&gt; , 또는&lt;a href=&quot;lang_expr#varparam&quot;&gt; 바인딩 된 매개 변수가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">SQLite의 확장 로딩 메커니즘 ( &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수를 사용하여 액세스 )은 기본적으로 해제되어 있습니다. 이것은 보안 예방 조치입니다. 애플리케이션이 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()을&lt;/a&gt; 사용하려는 경우 함수를 메소드를 사용하여 기능을 켜야합니다.</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">추가 쓰기 오버 헤드로 인해 전력 안전 덮어 쓰기에 대한 가정을 다시 검토했습니다. 최신 디스크 드라이브를 사용하면 용량이 너무 커지고 데이터 밀도가 너무 높아서 단일 섹터가 매우 작고 단일 섹터를 작성하는 데 시간이 거의 걸리지 않습니다. 우리는 디스크 드라이브가 임박한 전력 손실을 감지하고 잔류 에너지에 대해 약간의 시간 동안 계속 작동 할 수 있다는 것을 알고 있습니다. 드라이브는 회전하기 전에 헤드를 파킹 할 수 있기 때문입니다. 따라서 디스크 컨트롤러가 임박한 전원 손실을 감지 할 수있는 경우, 헤드를 파킹하기 전에 임박한 전원 손실이 처음 감지 될 때 컨트롤러가 현재 작동중인 섹터를 모두 기록하는 것이 합리적입니다. 너무 오래 걸리지 않아서 작고 밀도가 높은 섹터에서는 안됩니다.따라서 최신 디스크의 전원 안전 덮어 쓰기를 가정하는 것이 합리적입니다. 실제로 BerkeleyDB는 수십 년 동안 이러한 가정을 해왔다고 우리는 들었습니다. 그래도주의를 기울여야합니다. 로저 빈스 (Roger Binns)는 SQLite 개발자 메일 링리스트에서 &quot;드라이브 펌웨어에 대한 주된 가정은&quot;잘못 작성되었다 &quot;고 언급했다.</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">NULL은 UNIQUE 열에서는 고유하지만 SELECT DISTINCT 및 UNION에서는 명확하지 않다는 사실은 계속해서 수수께끼입니다. NULL은 어디에서나 다른 곳에서 구별되어야합니다. 그리고 SQL 표준 문서는 NULL이 어디에서나 구별되어야한다고 제안합니다. 그러나이 글을 쓰는 시점에, 테스트 된 SQL 엔진은 SELECT DISTINCT 문이나 UNION에서 NULL을 고유 한 것으로 취급하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">SQLite가 클라이언트 / 서버가 아닌 임베디드 및 &lt;a href=&quot;serverless&quot;&gt;서버리스&lt;/a&gt; 라는 사실 은 버그가 아닌 기능입니다.</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB 및 문자열 바인딩 인터페이스에 대한 다섯 번째 인수는 SQLite가 완료된 후 BLOB 또는 문자열을 처리하는 데 사용되는 소멸자입니다. 세 번째 매개 변수가 NULL 포인터이거나 네 번째 매개 변수가 음수 인 경우 소멸자가 호출되지 않는 한, 바인드 API에 대한 호출이 실패하더라도 BLOB 또는 문자열을 처리하기 위해 소멸자가 호출됩니다. 다섯 번째 인수가 특수 값 &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt; 인 경우 SQLite는 정보가 관리되지 않는 정적 공간에 있다고 가정하고 해제 할 필요가 없습니다. 다섯 번째 인수의 값이 &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT 인 경우&lt;/a&gt; 인 경우 SQLite는 sqlite3_bind _ * () 루틴이 리턴하기 전에 즉시 자체 데이터 사본을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB 및 문자열 바인딩 인터페이스에 대한 다섯 번째 인수는 SQLite가 완료된 후 BLOB 또는 문자열을 처리하는 데 사용되는 소멸자입니다. 세 번째 매개 변수가 NULL 포인터이거나 네 번째 매개 변수가 음수 인 경우 소멸자가 호출되지 않는 한, 바인드 API에 대한 호출이 실패하더라도 BLOB 또는 문자열을 처리하기 위해 소멸자가 호출됩니다. 다섯 번째 인수가 특수 값 &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt; 인 경우 SQLite는 정보가 관리되지 않는 정적 공간에 있다고 가정하고 해제 할 필요가 없습니다. 다섯 번째 인수의 값이 &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT 인 경우&lt;/a&gt; 인 경우 SQLite는 sqlite3_bind _ * () 루틴이 리턴하기 전에 즉시 자체 데이터 사본을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">다섯 번째 인수 xCallback은 배열 함수에 대한 포인터입니다. 동일한 이름을 사용하지만 eTextRep 매개 변수가 다른 여러 조합 함수를 등록 할 수 있으며 SQLite는 가장 적은 양의 데이터 변환이 필요한 함수를 사용합니다. xCallback 인수가 NULL이면 데이터 정렬 기능이 삭제됩니다. 이름이 같은 모든 데이터 정렬 기능이 삭제되면 해당 데이터 정렬을 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">다섯 번째 매개 변수는 임의의 포인터입니다. 함수의 구현은 &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()를&lt;/a&gt; 사용하여이 포인터에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">다섯 번째 매개 변수는 임의의 포인터입니다. 함수의 구현은 &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()를&lt;/a&gt; 사용하여이 포인터에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">파일 I / O 구현은 오브젝트 유형 플래그를 사용하여 파일 처리 방식을 변경할 수 있습니다. 예를 들어 응급 복구 또는 롤백을 신경 쓰지 않는 응용 프로그램은 저널 파일을 열지 않은 상태로 만들 수 있습니다. 이 저널에 대한 쓰기도 작동하지 않으며 저널을 읽으려고하면 SQLITE_IOERR이 리턴됩니다. 또는 구현시 데이터베이스 파일이 임의의 순서로 페이지 정렬 섹터 읽기 및 쓰기를 수행하고 이에 따라 I / O 하위 시스템을 설정한다는 것을 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">파일 I / O 구현은 오브젝트 유형 플래그를 사용하여 파일 처리 방식을 변경할 수 있습니다. 예를 들어 응급 복구 또는 롤백을 신경 쓰지 않는 응용 프로그램은 저널 파일을 열지 않은 것으로 만들 수 있습니다. 이 저널에 글을 쓰는 것도 실패입니다. 저널을 읽으려고하면 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR이&lt;/a&gt; 리턴 됩니다. . 또는 구현시 데이터베이스 파일이 임의의 순서로 페이지 정렬 섹터 읽기 및 쓰기를 수행하고 그에 따라 I / O 하위 시스템을 설정한다는 것을 인식 할 수 있습니다. SQLite는 xOpen 메소드에 다음 플래그 중 하나를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">파일 변경 카운터는 오프셋 24의 4 바이트 빅 엔디안 정수이며 데이터베이스 파일이 수정 된 후 잠금 해제 될 때마다 증가합니다. 둘 이상의 프로세스가 동일한 데이터베이스 파일을 읽고있는 경우 각 프로세스는 변경 카운터를 모니터링하여 다른 프로세스에서 데이터베이스 변경을 감지 할 수 있습니다. 캐시가 오래되어 다른 프로세스가 데이터베이스를 수정하면 프로세스는 일반적으로 데이터베이스 페이지 캐시를 플러시하려고합니다. 파일 변경 카운터가이를 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">파일 형식은 이전 버전과의 호환성을 유지하면서 새 테이블 및 / 또는 열을 추가하여 향후 릴리스에서 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">동일한 키를 가진 많은 항목이있는 색인이 큰 경우 GDBM에서 때때로 발생할 수있는 비 효율성을 해결하기 위해 색인의 파일 형식이 약간 변경되었습니다. ** 호환되지 않는 변경 **</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">오프셋 18 및 19의 파일 형식 쓰기 버전 및 파일 형식 읽기 버전은 이후 버전의 SQLite에서 파일 형식을 향상시킬 수 있도록 고안되었습니다. 현재 버전의 SQLite에서이 값은 롤백 저널링 모드의 경우 1이고 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 저널링 모드의 경우 2입니다 . 현재 파일 형식 스펙으로 코딩 된 SQLite 버전에서 읽기 버전이 1 또는 2이지만 쓰기 버전이 2보다 큰 데이터베이스 파일을 발견하면 데이터베이스 파일을 읽기 전용으로 처리해야합니다. 읽기 버전이 2보다 큰 데이터베이스 파일이 있으면 해당 데이터베이스를 읽거나 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">파일 핸들이</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">파일 시스템</target>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">첨부 할 데이터베이스의 파일 이름은 AS 키워드 앞에 나오는 표현식의 값입니다. 데이터베이스의 파일 이름은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 의 파일 이름 인수와 동일한 의미를 따릅니다 . 특수 이름 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;: memory :&lt;/a&gt; &quot; &lt;a href=&quot;inmemorydb&quot;&gt;는 인 메모리 데이터베이스가&lt;/a&gt; 되고 빈 문자열은 새로운 임시 데이터베이스가됩니다. 데이터베이스 연결에서 URI 파일 이름 처리를 사용하는 경우 filename 인수는 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 일 수 있습니다 . 기본 동작은 URI 파일 이름을 비활성화하는 것이지만 향후 SQLite 릴리스에서 변경 될 수 있으므로 응용 프로그램 개발자는 그에 따라 계획을 세우는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">INTO 절의 파일 이름은 문자열로 평가되는 임의의 SQL 표현식 일 수 있습니다. INTO 절로 이름 지정된 파일이 이전에 존재하지 않아야합니다. 그렇지 않으면 비어있는 파일이어야합니다. 그렇지 않으면 VACUUM INTO 명령이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">이 함수가 반환 한 파일 이름은 &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; 의 xFullPathname 메서드 출력입니다 . 즉, 데이터베이스를 여는 데 사용 된 파일 이름이 원래 URI 또는 ​​상대 경로 이름 인 경우에도 파일 이름은 절대 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">이 함수가 반환 한 파일 이름은 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xFullPathname 메서드 출력입니다 . 즉, 데이터베이스를 여는 데 사용 된 파일 이름이 원래 URI 또는 ​​상대 경로 이름 인 경우에도 파일 이름은 절대 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">최종 답변은 ind == 0 인 문자열을 찾아서 찾을 수 있습니다. 원래 스도쿠 문제에 고유 한 솔루션이없는 경우 쿼리는 가능한 모든 솔루션을 반환합니다. 원래 문제점을 해결할 수없는 경우 행이 리턴되지 않습니다. 이 경우 고유 한 대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">마지막 인수는 출력 변수입니다. 성공하면 새 토크 나이저 핸들을 가리 키도록 (* ppOut)을 설정하고 SQLITE_OK가 리턴됩니다. 오류가 발생하면 SQLITE_OK 이외의 값이 리턴되어야합니다. 이 경우, fts5는 * ppOut의 최종 값이 정의되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">인코딩 된 FTS varint의 마지막 바이트는 최상위 비트가 지워집니다. 모든 선행 바이트는 최상위 비트 세트를 갖습니다. 데이터는 각 바이트의 나머지 7 개의 최하위 비트에 저장됩니다. 인코딩 된 표현의 첫 번째 바이트는 인코딩 된 정수 값의 최하위 7 비트를 포함합니다. 인코딩 된 표현의 두 번째 바이트 (있는 경우)에는 정수 값의 다음으로 최하위 7 개의 비트가 포함됩니다. 다음 표에는 인코딩 된 정수 값의 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">예제의 마지막 줄 ( &quot;.system c : /work/dataout.csv&quot;)은 Windows에서 c : /work/dataout.csv 파일을 두 번 클릭하는 것과 동일한 효과를 갖습니다. 일반적으로 CSV 파일을 표시하는 스프레드 시트 프로그램이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">위 블록의 최종 쿼리가 예상대로 작동하지 않을 수 있습니다. &quot;*&quot;문자는 큰 따옴표 안에 있기 때문에 토크 나이저로 전달 될 것입니다. 토큰 화기는 인식하는 대신이를 버립니다 (또는 사용중인 특정 토크 나이저에 따라 최종 토큰의 일부로 포함). 특별한 FTS 캐릭터로서.</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">최종 복구 단계는 독점 잠금을 다시 공유 잠금으로 줄이는 것입니다. 이 문제가 발생하면 중단 된 트랜잭션이 시작되지 않았을 때의 상태로 데이터베이스가 다시 돌아옵니다. 이 복구 활동은 모두 자동으로 투명하게 이루어 지므로 중단 된 트랜잭션이 시작되지 않은 것처럼 SQLite를 사용하여 프로그램에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">대규모 메모리 할당의 최종 소스는 복잡한 SQL 연산을 컴파일하여 생성 된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 보유 할 공간 입니다. SQLite 개발자의 지속적인 작업으로 인해 여기에 필요한 공간이 줄어들고 있습니다. 그러나 크고 복잡한 쿼리에는 여전히 몇 킬로바이트 크기의 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 필요할 수 있습니다 . 현재 유일한 해결 방법은 응용 프로그램이 복잡한 SQL 작업을 별도의 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문에&lt;/a&gt; 포함 된 더 작고 간단한 두 개 이상의 작업으로 분리하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">다중 파일 커밋의 마지막 단계는 개별 롤백 저널을 삭제하고 데이터베이스 파일에 배타적 잠금을 삭제하여 다른 프로세스가 변경 내용을 볼 수 있도록하는 것입니다. 이것은 단일 파일 커밋 시퀀스의 &lt;a href=&quot;#section_3_12&quot;&gt;3.12 단계에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">보조 함수 콜백에 전달 된 마지막 3 개의 인수는 스칼라 SQL 함수 구현에 전달 된 3 개의 인수와 유사합니다. 보조 함수에 처음 전달 된 것을 제외한 모든 인수는 apVal [] 배열에서 구현할 수 있습니다. 구현은 컨텐츠 핸들 pCtx를 통해 결과 또는 오류를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">데이터베이스 파일의 처음 100 바이트는 데이터베이스 파일 헤더를 구성합니다. 데이터베이스 파일 헤더는 아래 표와 같이 필드로 나뉩니다. 데이터베이스 파일 헤더의 모든 멀티 바이트 필드는 최상위 바이트가 먼저 저장됩니다 (빅 엔디안).</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">shm 파일의 처음 136 바이트는 헤더입니다. shm 헤더에는 다음과 같은 세 가지 주요 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">의 첫 8 바이트</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">첫 번째 인수는 xBestIndex () 메소드의 첫 번째 매개 변수 인 sqlite3_index_info 오브젝트 여야합니다. 두 번째 인수는 xBestIndex에 전달 된 sqlite3_index_info 구조에 속하는 aConstraint [] 배열의 인덱스 여야합니다. 이 함수는 해당 제약 조건에 대한 데이터 정렬 시퀀스의 이름이 포함 된 버퍼에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">전달 된 첫 번째 인수는 확장을 등록 할 데이터베이스 핸들이어야합니다. 두 번째와 세 번째 인수는 모두 0으로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">보조 함수 콜백에 전달 된 첫 번째 인수는 현재 쿼리 또는 행에 대한 정보를 얻기 위해 호출 될 수있는 메소드를 포함하는 구조에 대한 포인터입니다. 두 번째 인수는 이러한 메소드 호출에 대한 첫 번째 인수로 전달되어야하는 불투명 한 핸들입니다. 예를 들어 다음 보조 함수 정의는 현재 행의 모든 ​​열에있는 총 토큰 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">이 함수에 전달 된 첫 번째 인수는 fts5_tokenizer 오브젝트가 FTS5 (xCreateTokenizer ()의 세 번째 인수)에 등록되었을 때 애플리케이션이 제공 한 (void *) 포인터의 사본입니다. 두 번째 및 세 번째 인수는 FTS5 테이블을 작성하는 데 사용 된 CREATE VIRTUAL TABLE 문의 일부로 토크 나이저 이름 뒤에 지정된 토크 나이저 인수 (있는 경우)를 포함하는 널 종료 문자열의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 의 첫 번째 인수 는이 메소드의 첫 번째 매개 변수 와 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터 여야합니다 . &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()에&lt;/a&gt; 대한 두 번째 인수 는 가상 테이블의 열 및 해당 데이터 유형을 정의하는 올바른 형식의 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문을 포함하는 0으로 끝나는 UTF-8 문자열이어야합니다 . 이 CREATE TABLE 문의 테이블 이름은 모든 제한 조건과 마찬가지로 무시됩니다. 열 이름과 데이터 유형 만 중요합니다. CREATE TABLE 문 문자열은 지속적 메모리에 보유 될 필요가 없습니다. &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 루틴이 리턴 되는 즉시 문자열을 할당 해제 및 / 또는 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">세 가지 특수 SQL 스칼라 함수 모두에 대한 첫 번째 인수 는 함수가 적용되는 FTS 테이블 의 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열&lt;/a&gt; 이어야합니다 . &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열은&lt;/a&gt; FTS의 테이블 자체와 동일한 이름을 가진 모든 FTS 테이블에서 발견되는 자동으로 생성 된 열입니다. 예를 들어 이름이 &quot;mail&quot;인 FTS 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config ()의 첫 번째 인수는 &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;구성 할&lt;/a&gt; SQLite의 속성을 결정 하는 정수 구성 옵션 입니다. 후속 인수 는 첫 번째 인수 의 &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;구성 옵션&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config ()의 첫 번째 인수는 &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;구성 할&lt;/a&gt; SQLite의 속성을 결정 하는 정수 구성 옵션 입니다. 후속 인수 는 첫 번째 인수 의 &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;구성 옵션&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">사용중인 핸들러의 첫 번째 인수는 sqlite3_busy_handler ()의 세 번째 인수 인 void * 포인터의 사본입니다. 사용중인 처리기 콜백에 대한 두 번째 인수는 사용중인 처리기가 동일한 잠금 이벤트에 대해 이전에 호출 된 횟수입니다. 사용 중 콜백이 0을 리턴하면 데이터베이스에 액세스하려는 추가 시도가 없으며 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 애플리케이션으로 리턴됩니다. 콜백이 0이 아닌 값을 반환하면 데이터베이스에 다시 액세스하려고 시도하고주기가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">사용중인 핸들러의 첫 번째 인수는 sqlite3_busy_handler ()의 세 번째 인수 인 void * 포인터의 사본입니다. 사용중인 처리기 콜백에 대한 두 번째 인수는 사용중인 처리기가 동일한 잠금 이벤트에 대해 이전에 호출 된 횟수입니다. 사용 중 콜백이 0을 리턴하면 데이터베이스에 액세스하려는 추가 시도가 없으며 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 애플리케이션으로 리턴됩니다. 콜백이 0이 아닌 값을 반환하면 데이터베이스에 다시 액세스하려고 시도하고주기가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">콜백에 대한 첫 번째 인수는 &lt;b&gt;sqlite_exec&lt;/b&gt; 에 대한 네 번째 인수의 사본입니다. 이 매개 변수는 클라이언트 코드에서 콜백 함수로 임의의 정보를 전달하는 데 사용할 수 있습니다. 두 번째 인수는 쿼리 결과의 열 수입니다. 세 번째 인수는 각 문자열이 해당 레코드에 대한 결과의 단일 열인 문자열에 대한 포인터 배열입니다. 콜백 함수는 데이터베이스에서 NULL 값을 NULL 포인터로보고하는데, 이는 빈 문자열과는 매우 다릅니다. i 번째 매개 변수가 빈 문자열이면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">스 니펫 함수에 대한 첫 번째 인수는 항상 쿼리중인 FTS 테이블 의 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열&lt;/a&gt; 이어야하며 스 니펫을 가져와야합니다. &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 컬럼&lt;/a&gt; FTS의 테이블 자체와 동일한 이름을 자동으로 생성 된 열이다.</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ * () 루틴에 대한 첫 번째 인수는 항상 포인터이다 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt의&lt;/a&gt; 에서 반환 된 개체 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 그 변종.</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ * () 루틴에 대한 첫 번째 인수는 항상 포인터이다 &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt의&lt;/a&gt; 에서 반환 된 개체 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 그 변종.</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">sqlite3session_config () 함수의 첫 번째 인수는 아래에 정의 된 SQLITE_SESSION_CONFIG_XXX 상수 중 하나 여야합니다. 두 번째 매개 변수로 전달 된 (void *) 값의 해석 및이 함수 호출의 효과는 첫 번째 매개 변수의 값에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">이러한 인터페이스에 대한 첫 번째 주장은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 진술&lt;/a&gt; 입니다. 이 함수는 명령문이 리턴 한 N 번째 결과 열에 대한 정보를 리턴합니다. 여기서 N은 두 번째 함수 인수입니다. 이 루틴의 가장 왼쪽 열은 0 열입니다.</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">이러한 인터페이스에 대한 첫 번째 주장은 &lt;a href=&quot;stmt&quot;&gt;준비된 진술&lt;/a&gt; 입니다. 이 함수는 명령문이 리턴 한 N 번째 결과 열에 대한 정보를 리턴합니다. 여기서 N은 두 번째 함수 인수입니다. 이 루틴의 가장 왼쪽 열은 0 열입니다.</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">첫 번째 인수 &quot;db&quot;는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 이전의 성공적인 호출에서 얻은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 연결이 닫히지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">첫 번째 인수 &quot;db&quot;는 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 이전의 성공적인 호출에서 얻은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 연결이 닫히지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">포인터 전달에서 보안 격차를 메우는 첫 번째 시도는 포인터 값이 위조되지 않도록하는 것입니다. 이는 발신자가 사용한 각각의 포인터에 부속을 부착함으로써 달성되었다 &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype ()를&lt;/a&gt; 수신기가 이용 아형 확인 갖는 &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype을 ()&lt;/a&gt; 과 잘못된 아형 있었다 포인터를 거부한다. 순수 SQL을 사용하여 하위 유형을 결과에 첨부 할 수있는 방법이 없으므로 SQL을 사용하여 포인터를 위조 할 수 없습니다. 포인터를 보내는 유일한 방법은 C 코드를 사용하는 것입니다. 공격자가 하위 유형을 설정할 수 있으면 SQLite의 도움 없이도 포인터를 위조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0의 첫 번째 베타 릴리스.</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">헤더의 첫 번째 바이트는 플래그 바이트입니다. 플래그 바이트의 최하위 비트는 헤더 뒤에 오는 좌표 쌍이 빅 엔디안 또는 리틀 엔디안으로 저장되는지 여부를 결정합니다. 최하위 비트에 대해 0 값은 빅 엔디안을 의미하고 1 값은 리틀 엔디안을 의미합니다. 헤더에서 첫 번째 바이트의 다른 비트는 향후 확장을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">반복자의 &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; 에 대한 첫 번째 호출 은 변경 세트의 첫 번째 변경 (또는 변경 세트가 완전히 비어있는 경우 EOF)을 가리 키도록 이동합니다. sqlite3changeset_next ()는 반복자가 유효한 항목을 가리 키도록 이동하는 경우 SQLITE_ROW를 리턴하고, 반복자를 EOF로 이동하면 SQLITE_DONE을, 오류가 발생하면 SQLite 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step ()에 대한 첫 번째 호출은 대상 파일에 대한 독점 잠금을 얻습니다. 독점 잠금은 sqlite3_backup_finish ()가 호출되거나 백업 조작이 완료되고 sqlite3_backup_step ()이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 할 때까지 해제되지 않습니다 . sqlite3_backup_step ()을 호출 할 때마다&lt;a href=&quot;lockingv3#shared_lock&quot;&gt; 공유 잠금을&lt;/a&gt;sqlite3_backup_step () 호출 기간 동안 지속되는 소스 데이터베이스. 소스 데이터베이스는 sqlite3_backup_step () 호출 사이에 잠겨 있지 않기 때문에 백업 프로세스 도중에 소스 데이터베이스가 수정 될 수 있습니다. 소스 데이터베이스가 외부 프로세스에 의해 또는 백업 조작에 의해 사용되는 것 이외의 데이터베이스 연결을 통해 수정되면, 다음에 sqlite3_backup_step ()을 호출하여 백업이 자동으로 재시작됩니다. 백업 작업에 사용 된 것과 동일한 데이터베이스 연결을 사용하여 소스 데이터베이스를 수정하면 백업 데이터베이스가 자동으로 동시에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step ()에 대한 첫 번째 호출은 대상 파일에 대한 독점 잠금을 얻습니다. 독점 잠금은 sqlite3_backup_finish ()가 호출되거나 백업 조작이 완료되고 sqlite3_backup_step ()이 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 할 때까지 해제되지 않습니다 . sqlite3_backup_step ()에 대한 모든 호출은&lt;a href=&quot;../lockingv3#shared_lock&quot;&gt; 공유 잠금을&lt;/a&gt; 얻습니다.sqlite3_backup_step () 호출 기간 동안 지속되는 소스 데이터베이스. 소스 데이터베이스는 sqlite3_backup_step () 호출 사이에 잠겨 있지 않기 때문에 백업 프로세스 도중에 소스 데이터베이스가 수정 될 수 있습니다. 소스 데이터베이스가 외부 프로세스에 의해 또는 백업 조작에 의해 사용되는 것 이외의 데이터베이스 연결을 통해 수정되면, 다음에 sqlite3_backup_step ()을 호출하여 백업이 자동으로 재시작됩니다. 백업 작업에 사용 된 것과 동일한 데이터베이스 연결을 사용하여 소스 데이터베이스를 수정하면 백업 데이터베이스가 자동으로 동시에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">TH3의 첫 번째 코드는 2008-09-25에 작성되었습니다. 향후 10 개월 동안의 노력으로 TH3는 2009-07-25에서 100 % MC / DC를 달성했습니다. TH3 코드는 계속 개선되고 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">첫 번째 열은 테이블이 포함 된 데이터베이스의 스키마 이름입니다. 예 : &quot;main&quot;, &quot;zone512&quot;</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">SQLite R * Tree의 첫 번째 열은 일반 SQLite 테이블의 정수 기본 키 열과 유사합니다. 부호있는 64 비트 정수 값만 저장할 수 있습니다. 이 열에 NULL 값을 삽입하면 SQLite가 새로운 고유 기본 키 값을 자동으로 생성합니다. 정수가 아닌 다른 값을이 열에 삽입하려고하면 r-tree 모듈은 데이터베이스에 기록하기 전에이를 정수로 자동 변환합니다.</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">첫 번째 조건은 모든 트렁크 체크인을 표시하고 두 번째 및 세 번째 원인은 트렁크에 병합되거나 트렁크에서 포크 인 체크인도 포함합니다. 세 가지 조건은 쿼리의 WHERE 절에있는 세 개의 OR 연결 EXISTS 문으로 구현됩니다. NGQP에서 발생한 속도 저하는 두 번째 및 세 번째 조건으로 인해 발생했습니다. 문제는 각각 동일하므로 두 번째 문제 만 살펴 보겠습니다. 두 번째 조건의 하위 쿼리는 다음과 같이 (작고 중요하지 않은 단순화로) 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">sqlite3_rtree_query_info 구조의 처음 5 개 필드는 sqlite3_rtree_geometry 구조와 동일하며 정확히 동일한 의미를 갖습니다. sqlite3_rtree_query_info 구조는 또한 xGeom 콜백에서 동일한 이름의 매개 변수와 동일한 의미를 갖는 nCoord 및 aCoord 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">첫 번째 양식 ( &quot;VALUES&quot;키워드 사용)은 기존 테이블에 하나 이상의 새 행을 작성합니다. table-name 뒤의 column-name 목록이 생략되면 각 행에 삽입 된 값의 수는 테이블의 열 수와 같아야합니다. 이 경우 VALUES 목록의 각 항에서 가장 왼쪽에있는 표현식을 평가 한 결과가 각 새 행의 가장 왼쪽에있는 열 등에 삽입됩니다. 열 이름 목록이 지정되면 VALUE 목록의 각 용어에있는 값의 수가 지정된 열의 수와 일치해야합니다. 새 행의 명명 된 각 열은 해당 VALUES 표현식을 평가 한 결과로 채워집니다. 열 목록에 나타나지 않는 테이블 열은 &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;기본 열 값으로&lt;/a&gt; 채워집니다.( &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 일부로 지정됨 ) 또는 &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;기본값&lt;/a&gt; 이 지정 되지 않은 경우 NULL을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">첫 번째 양식은 'TABLENAME'이라는 테이블에서 편집 거리 계수를로드합니다. 모든 이전 계수는 폐기됩니다. 따라서 가중치를 실험하고 가중치 테이블이 변경 될 때 editdist3 ()의 단일 인수 형식을 다시 실행하여 수정 된 계수를 다시로드하십시오. editdist3 () SQL 함수가 사용하는 편집 거리 가중치는 spellfix1 가상 테이블이 사용하는 가중치와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">lag () 함수의 첫 번째 형식은 표현식 평가 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">lead () 함수의 첫 번째 양식은 표현식 평가 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">이 pragma의 첫 번째 형식은 현재 저널링 모드를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">인덱스의 처음 네 열 a, b, c 및 d는 인덱스의 접두사를 형성하고 모두 등식 제약 조건에 의해 묶여 있기 때문에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">로그의 첫 번째 쿼리 그룹은 Fossil 데이터베이스의 &quot;config&quot;및 &quot;global_config&quot;테이블에서 표시 옵션을 추출하는 것입니다. 그런 다음 타임 라인에 표시 할 모든 요소 목록을 추출하는 단일 복합 쿼리가 있습니다. 이 &quot;타임 라인&quot;쿼리는 SQLite가 여러 테이블, 하위 쿼리 및 복잡한 WHERE 절 제약 조건을 포함하는 복잡한 관계형 데이터베이스 쿼리를 쉽게 처리 할 수 ​​있으며 최소의 디스크 I / O로 쿼리를 해결하기 위해 인덱스를 효과적으로 사용할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">첫 번째 호스트 매개 변수의 색인은 0이 아니라 1입니다.</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">관심의 첫번째 명령은 인 &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; 2 AggReset 명령에 공집합으로 버킷의 세트를 초기화 P2 각 버킷 가능한 메모리 슬롯들의 수를 지정한다. 이 예에서 각 버킷에는 3 개의 메모리 슬롯이 있습니다. 분명하지는 않지만 프로그램의 나머지 부분을 면밀히 살펴보면 각 슬롯의 용도를 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">P4 정수 배열의 첫 번째 정수는 배열의 길이이며 순열의 일부가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">위 스크립트의 첫 번째 행은 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 이 CSV에 대한 런타임로드 가능한 확장을 읽고 활성화하게합니다. 애플리케이션의 경우 동등한 C 언어 API는 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 입니다. 파일 이름 확장자 (예 : &quot;.dll&quot;또는 &quot;.so&quot;또는 &quot;.dylib&quot;)가 확장자 파일 이름에서 생략되었는지 확인하십시오. 파일 이름 확장자를 생략 할 필요는 없지만 스크립트를 크로스 플랫폼으로 만드는 데 도움이됩니다. SQLite는 자동으로 적절한 확장명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">존재하고 쓰기 및 실행 비트가 설정된 위의 첫 번째가 사용됩니다. 마지막 &quot;.&quot; 사용 가능한 표준 임시 파일 위치가없는 chroot jails에서 SQLite를 사용하는 일부 응용 프로그램의 경우 대체가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">셀 페이로드 오버 플로우 체인의 첫 페이지입니다. 페이지 번호는 내용이 넘친 셀을 포함하는 b- 트리 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">첫 번째 매개 변수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문장&lt;/a&gt; 입니다. 이 문이 경우 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문과 그 반환 된 결과 집합의 N 번째 열 &lt;a href=&quot;lang_select&quot;&gt;SELECT는&lt;/a&gt; 테이블 열 (안 식 또는 하위 쿼리)되어 다음 테이블 컬럼의 선언 된 유형이 반환됩니다. 결과 집합의 N 번째 열이 식 또는 하위 쿼리이면 NULL 포인터가 반환됩니다. 반환 된 문자열은 항상 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">첫 번째 매개 변수는 &lt;a href=&quot;stmt&quot;&gt;준비된 문장&lt;/a&gt; 입니다. 이 문이 경우 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문과 그 반환 된 결과 집합의 N 번째 열 &lt;a href=&quot;../lang_select&quot;&gt;SELECT는&lt;/a&gt; 테이블 열 (안 식 또는 하위 쿼리)되어 다음 테이블 컬럼의 선언 된 유형이 반환됩니다. 결과 집합의 N 번째 열이 식 또는 하위 쿼리이면 NULL 포인터가 반환됩니다. 반환 된 문자열은 항상 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">첫 번째 매개 변수는 SQL 함수가 추가 될 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 애플리케이션이 둘 이상의 데이터베이스 연결을 사용하는 경우 애플리케이션 정의 SQL 함수를 각 데이터베이스 연결에 별도로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">첫 번째 매개 변수는 SQL 함수가 추가 될 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 애플리케이션이 둘 이상의 데이터베이스 연결을 사용하는 경우 애플리케이션 정의 SQL 함수를 각 데이터베이스 연결에 별도로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">첫 번째 매개 변수는 집계 함수를 구현하는 xStep 또는 xFinal 콜백 루틴에 대한 첫 번째 매개 변수 인 &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL 함수 컨텍스트&lt;/a&gt; 의 사본이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">첫 번째 매개 변수는 집계 함수를 구현하는 xStep 또는 xFinal 콜백 루틴에 대한 첫 번째 매개 변수 인 &lt;a href=&quot;context&quot;&gt;SQL 함수 컨텍스트&lt;/a&gt; 의 사본이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">콜백 함수가 호출 될 때 콜백 함수에 전달 된 첫 번째 매개 변수는 콜백을 등록 할 때 sqlite3_wal_hook ()에 전달 된 세 번째 매개 변수의 사본입니다. 두 번째는 데이터베이스 핸들의 사본입니다. 세 번째 매개 변수는 &quot;main&quot;또는 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 데이터베이스 의 이름으로 작성된 데이터베이스의 이름입니다 . 네 번째 매개 변수는 방금 커밋 된 페이지를 포함하여 현재 미리 쓰기 로그 파일에있는 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">콜백 함수가 호출 될 때 콜백 함수에 전달 된 첫 번째 매개 변수는 콜백을 등록 할 때 sqlite3_wal_hook ()에 전달 된 세 번째 매개 변수의 사본입니다. 두 번째는 데이터베이스 핸들의 사본입니다. 세 번째 매개 변수는 &quot;main&quot;또는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 데이터베이스 의 이름으로 작성된 데이터베이스의 이름입니다 . 네 번째 매개 변수는 방금 커밋 된 페이지를 포함하여 현재 미리 쓰기 로그 파일에있는 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">권한 부 여자 콜백에 대한 첫 번째 매개 변수는 sqlite3_set_authorizer () 인터페이스에 대한 세 번째 매개 변수의 사본입니다. 콜백에 대한 두 번째 매개 변수는 권한을 부여 할 특정 조치를 지정 하는 정수 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;조치 코드&lt;/a&gt; 입니다. 콜백에 대한 세 번째에서 여섯 번째 매개 변수는 권한이 부여 된 조치에 대한 추가 세부 사항을 포함하는 NULL 포인터 또는 0으로 끝나는 문자열입니다. 권한 부여 콜백의 3 ~ 6 번째 매개 변수 중 하나에서 애플리케이션은 항상 NULL 포인터를 만나도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">권한 부 여자 콜백에 대한 첫 번째 매개 변수는 sqlite3_set_authorizer () 인터페이스에 대한 세 번째 매개 변수의 사본입니다. 콜백에 대한 두 번째 매개 변수는 권한을 부여 할 특정 조치를 지정 하는 정수 &lt;a href=&quot;c_alter_table&quot;&gt;조치 코드&lt;/a&gt; 입니다. 콜백에 대한 세 번째에서 여섯 번째 매개 변수는 권한이 부여 된 조치에 대한 추가 세부 사항을 포함하는 NULL 포인터 또는 0으로 끝나는 문자열입니다. 권한 부여 콜백의 3 ~ 6 번째 매개 변수 중 하나에서 애플리케이션은 항상 NULL 포인터를 만나도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">첫 번째 섹션에서는 SQL 외래 키 개념을 예로 들어 소개하고 문서의 나머지 부분에 사용되는 용어를 정의합니다. 섹션 2에서는 SQLite에서 외래 키 제약 조건을 활성화하기 위해 응용 프로그램이 수행해야하는 단계에 대해 설명합니다 (기본적으로 비활성화되어 있음). 다음 섹션 인 섹션 3에서는 외래 키 제약 조건을 사용하기 위해 사용자가 만들어야하는 인덱스와 외래 키 제약 조건을 효율적으로 사용하기 위해 만들어야하는 인덱스에 대해 설명합니다. 섹션 4는 SQLite가 지원하는 고급 외래 키 관련 기능을 설명하고 섹션 5는 외래 키 제약 조건을 지원 하도록 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; 및 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령이 향상 되는 방법을 설명합니다 . 마지막으로, 섹션 6은 현재 구현에서 누락 된 기능과 한계를 열거합니다.</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">세 값의 첫 번째 세트는 테이블의 가장 왼쪽 열 (0 열)과 쿼리에서 가장 왼쪽에 일치하는 구 (문구 0)에 해당합니다. 테이블에 둘 이상의 열이있는 경우 출력 배열에서 세 번째 값의 두 번째 세트는 구 0과 열 1에 해당합니다. 그 다음에 표의 모든 열에 대해 구 0, 열 2 등이옵니다. 문구 1, 열 0, 문구 1, 열 1 등에 대해서도 마찬가지입니다. 즉, 문구 발생에 대한 데이터</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">처음 6 개의 인터페이스 (_blob, _double, _int, _int64, _text 및 _text16)는 각각 특정 데이터 형식으로 결과 열의 값을 반환합니다. 결과 열이 처음에 요청 된 형식이 아닌 경우 (예를 들어, 쿼리가 정수를 리턴하지만 sqlite3_column_text () 인터페이스를 사용하여 값을 추출하는 경우) 자동 유형 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">처음 6 개의 수정 자 (1-6)는 단순히 이전 시간 문자열 및 수정 자에 의해 지정된 날짜 및 시간에 지정된 시간을 추가합니다. 수정 자 이름 끝에있는 's'문자는 선택 사항입니다. &quot;&amp;plusmn; NNN 개월&quot;은 원래 날짜를 YYYY-MM-DD 형식으로 렌더링하고 MM 월 값에 &amp;plusmn; NNN을 추가 한 다음 결과를 표준화하여 작동합니다. 따라서 예를 들어 '+1 개월'로 수정 된 2001-03-31 데이터는 처음에 2001-04-31을 생성하지만 4 월에는 30 일만 있으므로 날짜는 2001-05-01로 정규화됩니다. 원래 날짜가 윤년의 2 월 29 일이고 수정자가 &amp;plusmn; N 년 (여기서 N은 4의 배수가 아님) 인 경우에도 유사한 효과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">핫 저널을 처리하기위한 첫 번째 단계는 데이터베이스 파일에 대한 독점 잠금을 얻는 것입니다. 이로 인해 둘 이상의 프로세스가 동일한 핫 저널을 동시에 롤백하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">데이터베이스 파일에서 읽는 첫 번째 단계는 데이터베이스 파일에서 공유 잠금을 얻는 것입니다. &quot;공유&quot;잠금을 사용하면 데이터베이스 파일에서 두 개 이상의 데이터베이스 연결을 동시에 읽을 수 있습니다. 그러나 공유 잠금은 다른 데이터베이스 연결이 데이터베이스 파일을 읽는 동안 데이터베이스 파일에 쓰지 못하게합니다. 데이터베이스 파일에서 읽을 때 다른 데이터베이스 연결이 데이터베이스 파일에 쓰는 중이면 변경 전에 일부 데이터를 읽고 변경 후 다른 데이터를 읽을 수 있기 때문에이 작업이 필요합니다. 이것은 다른 프로세스에 의한 변경이 원자 적이 지 않은 것처럼 보이게합니다.</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">열 선언에서 첫 번째 문자열 또는 베어 워드는 열 이름입니다. fts5 테이블 열의 이름을 &quot;rowid&quot;또는 &quot;rank&quot;로 지정하거나 테이블 자체에서 사용하는 것과 동일한 이름을 열에 지정하는 것은 오류입니다. 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">위의 첫 번째 하위 쿼리는 외부 쿼리와 관련하여 일정합니다. 첫 번째 하위 쿼리의 값은 한 번 계산 된 다음 외부 SELECT의 각 행에 재사용 될 수 있습니다. 그러나 두 번째 하위 쿼리는 &quot;CORRELATED&quot;입니다. 두 번째 하위 쿼리 값은 외부 쿼리의 현재 행 값에 따라 달라집니다. 따라서 두 번째 서브 쿼리는 외부 SELECT의 각 출력 행마다 한 번씩 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">각 노드에 저장된 첫 번째 용어 (위 그림에서 &quot;Term 1&quot;)는 그대로 저장됩니다. 각 후속 용어는 이전 버전과 관련하여 접두사로 압축됩니다. 용어는 페이지 내에 정렬 된 (memcmp) 순서로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">가장 먼저 일어나는 일은 읽을 인덱스를 생성하는 테이블을 여는 것입니다. 테이블에 대한 인덱스를 구성하려면 해당 테이블에 무엇이 있는지 알아야합니다. 명령어 3과 4에서 커서 0을 사용하여 쓰기 위해 인덱스가 이미 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">SQLite 프로세스가 처음으로 데이터베이스 파일에 액세스를 시도하면 위의 &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;3.2 절에&lt;/a&gt; 설명 된대로 공유 잠금을 얻습니다 . 그러나 롤백 저널 파일이 있음을 알 수 있습니다. 그런 다음 SQLite는 롤백 저널이 &quot;핫 저널&quot;인지 확인합니다. 핫 저널은 데이터베이스를 정상 상태로 복원하기 위해 재생해야하는 롤백 저널입니다. 핫 저널은 이전 프로세스가 충돌 또는 전원 손실시 트랜잭션을 커밋하는 중일 때만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">sqlite3_aggregate_context (C, N) 루틴이 특정 집계 함수에 대해 처음 호출 될 때 SQLite는 N 개의 메모리를 할당하고 해당 메모리를 0으로 만들고 새 메모리에 대한 포인터를 리턴합니다. 동일한 집계 함수 인스턴스에 대한 sqlite3_aggregate_context ()에 대한 두 번째 및 후속 호출에서 동일한 버퍼가 리턴됩니다. Sqlite3_aggregate_context ()는 일반적으로 xStep 콜백이 호출 될 때마다 한 번 호출 된 다음 xFinal 콜백이 호출 될 때 마지막으로 호출됩니다. 집계 쿼리와 일치하는 행이 없으면 집계 함수 구현의 xStep () 콜백이 호출되지 않으며 xFinal ()이 정확히 한 번 호출됩니다. 이 경우, xFinal () 내에서 sqlite3_aggregate_context ()가 처음으로 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">처음 두 상수 (SQLITE_MUTEX_FAST 및 SQLITE_MUTEX_RECURSIVE)는 sqlite3_mutex_alloc ()이 새로운 뮤텍스를 생성하게합니다. 새로운 뮤텍스는 SQLITE_MUTEX_RECURSIVE가 사용될 때 재귀 적이지만 SQLITE_MUTEX_FAST가 사용될 때 반드시 그런 것은 아닙니다. 뮤텍스 구현은 원하지 않는 경우 SQLITE_MUTEX_RECURSIVE와 SQLITE_MUTEX_FAST를 구별 할 필요가 없습니다. SQLite는 재귀 뮤텍스가 실제로 필요한 경우에만 요청합니다. 호스트 플랫폼에서 더 빠른 비 재귀 뮤텍스 구현을 사용할 수있는 경우 뮤텍스 하위 시스템은 SQLITE_MUTEX_FAST에 대한 응답으로 이러한 뮤텍스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">위 목록에서 처음 두 요소는</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">우리의 쿼리에 대한 VDBE 프로그램에서 처음 두 지침에 대한 값을 설정에 관심을 &lt;b&gt;azColumn&lt;/b&gt; . &lt;a href=&quot;opcode#ColumnName&quot;&gt;의 ColumnName&lt;/a&gt; 설명은 각각의 요소를 입력 어떤 값들 VDBE 말해 &lt;b&gt;azColumnName []&lt;/b&gt; 배열. 모든 쿼리는 결과의 각 열에 대해 하나의 ColumnName 명령으로 시작하며 나중에 쿼리에서 각 열에 대해 일치하는 Column 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">처음 두 쿼리 예제는 모든 SELECT 프로그램이 따르는 일종의 템플릿을 보여줍니다. 기본적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">정수 값 배열의 첫 번째 값은 테이블의 가장 왼쪽 열 (열 0)과 쿼리의 첫 번째 구 (구문 0)에 해당합니다. 다른 열 / 구문 조합에 해당하는 값은 다음 공식을 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">첫 번째 또는 유일한 정수는이 세그먼트 b- 트리에 속하는 가장 큰 blockid를 가진 내부 노드에 해당하는 blockid입니다. 전체 세그먼트 b- 트리가 루트 노드에 맞는 경우 0입니다. 존재하는 경우이 노드는 항상 내부 노드입니다.</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">ORDER BY LIMIT 최적화와 연관된 바이트 코드의 무한 루프에 대한 3.25.0 릴리스의 수정 사항은 창 함수와 관련된 일부 조회에 대해 작동하지 않았습니다. 추가 수정이 필요합니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">이전 버그에 대한 수정으로 교착 상태가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Xservers를 행 플래그 인수 () 일 수있다 &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; ㄱ 파일의 존재 또는 테스트하기 위해 &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; 파일은 읽기 및 쓰기, 또는 수 있는지 여부를 테스트 &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; 파일 적어도 읽을 수 있는지 여부를 테스트한다. SQLITE_ACCESS_READ 플래그는 실제로 사용되지 않으며 SQLite의 내장 VFS에서 구현되지 않습니다. 파일은 두 번째 인수로 명명되며 디렉토리 일 수 있습니다. I / O 오류가 있거나 두 번째 인수에 지정된 파일 이름이 유효하지 않은 경우 xAccess 메소드는 성공시 또는 0이 아닌 오류 코드에서 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . SQLITE_OK가 리턴되면 파일에 액세스 할 수 있는지 여부를 표시하기 위해 0이 아닌 또는 0이 * pResOut에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Xservers를 행 플래그 인수 () 일 수있다 &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; ㄱ 파일의 존재 또는 테스트하기 위해 &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; 파일은 읽기 및 쓰기, 또는 수 있는지 여부를 테스트 &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; 파일 적어도 읽을 수 있는지 여부를 테스트한다. SQLITE_ACCESS_READ 플래그는 실제로 사용되지 않으며 SQLite의 내장 VFS에서 구현되지 않습니다. 파일은 두 번째 인수로 명명되며 디렉토리 일 수 있습니다. I / O 오류가 있거나 두 번째 인수에 지정된 파일 이름이 유효하지 않은 경우 xAccess 메소드는 성공시 또는 0이 아닌 오류 코드에서 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . SQLITE_OK가 리턴되면 파일에 액세스 할 수 있는지 여부를 표시하기 위해 0이 아닌 또는 0이 * pResOut에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen ()에 대한 flags 인자는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 에 대한 flags 인자에 설정된 모든 비트를 포함합니다 . 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 을 사용하는 경우 플래그에는 최소한 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . XOPEN ()가 열리면 파일은 읽기 전용 다음은 설정 * pOutFlags를 포함 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . * pOutFlags의 다른 비트가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen ()에 대한 flags 인자는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 에 대한 flags 인자에 설정된 모든 비트를 포함합니다 . 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 을 사용하는 경우 플래그에는 최소한 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . XOPEN ()가 열리면 파일은 읽기 전용 다음은 설정 * pOutFlags를 포함 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . * pOutFlags의 다른 비트가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync에 플래그 인수 중 하나가 될 수 있습니다 &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . 첫 번째 선택은 일반적인 fsync ()입니다. 두 번째 선택은 Mac OS X 스타일의 전체 동기화입니다. &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY의&lt;/a&gt; 플래그는 파일의 데이터 만 표시하기에 OR 연산 될 수 있으며하지의 아이 노드의 요구를 동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync에 플래그 인수 중 하나가 될 수 있습니다 &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; 또는 &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . 첫 번째 선택은 일반적인 fsync ()입니다. 두 번째 선택은 Mac OS X 스타일의 전체 동기화입니다. &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY의&lt;/a&gt; 플래그는 파일의 데이터 만 표시하기에 OR 연산 될 수 있으며하지의 아이 노드의 요구를 동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">내장 printf ()의 부동 소수점에서 텍스트로 변환 부속 함수는 정밀도가 16 자리 유효 숫자 또는 &quot;!&quot;이면 26 자리 유효 숫자로 제한됩니다. alternate-form-2 플래그가 사용됩니다. 모든 IEEE-754 double은 십진 부동 소수점 값으로 정확하게 표현 될 수 있지만 일부 double에는 16 또는 26 이상의 유효 숫자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">GetTempPath () 시스템 인터페이스가 돌려주는 폴더.</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 글로벌 변수에 의해 설정된 폴더</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">다음 &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; 만화는 과장이지만 집에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">다음과 같은 RBU 데이터베이스 스키마가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">다음 SQL은 값이 테이블에 삽입 될 때 SQLite가 열 선호도를 사용하여 유형 변환을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">다음 SQLite 명령 줄 세션은 외래 키 제약 조건이</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">모든 기능을 갖춘 명령 줄 셸을 제공하려면 다음과 같은 추가 컴파일 타임 옵션이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">다음 추가 구문 제한 사항은 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문의 본문에서 발생하는 UPDATE 문에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">다음은 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize (D, S, P, N, M, F)&lt;/a&gt; 인터페이스 에 6 번째 인수 (F 인수)에 허용되는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">다음은 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize (D, S, P, N, M, F)&lt;/a&gt; 인터페이스 에 6 번째 인수 (F 인수)에 허용되는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">다음은 SQLite의 내장 보호 메커니즘을 사용하지 않도록 설정하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">다음은 공개 SQLite 소스 트리에서 사용 가능한 다른 VFS 구현입니다.</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">사용 가능한 OMIT 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">다음 블록에는 BNF 형식의 FTS 쿼리 구문이 요약되어 있습니다. 자세한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">다음 블록에는 C 코드에서 fts3_tokenizer () 함수를 호출하는 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">다음 블록에는 오프셋 기능을 사용하는 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">다음 차트는 SQLite가 지원하는 대체 유형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">다음 컴파일 시간 옵션은 SQLite에서 사용하는 CPU주기 수와 메모리 바이트를 최소화하기 위해이를 사용할 수있는 응용 프로그램에 권장됩니다. 모든 컴파일 타임 옵션이 모든 응용 프로그램에서 사용 가능한 것은 아닙니다. 예를 들어, SQLITE_THREADSAFE = 0 옵션은 한 번에 둘 이상의 스레드에서 SQLite에 액세스하지 않는 응용 프로그램에서만 사용할 수 있습니다. 그리고 SQLITE_OMIT_PROGRESS_CALLBACK 옵션은 &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; 인터페이스를 사용하지 않는 응용 프로그램에서만 사용할 수 있습니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus (S, X, T, V)&lt;/a&gt; 인터페이스 에 대한 T 매개 변수에 다음 상수를 사용할 수 있습니다 . 각 상수는 sqlite3_stmt_scanstatus ()가 반환 할 다른 메트릭을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus (S, X, T, V)&lt;/a&gt; 인터페이스 에 대한 T 매개 변수에 다음 상수를 사용할 수 있습니다 . 각 상수는 sqlite3_stmt_scanstatus ()가 반환 할 다른 메트릭을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">다음 다이어그램은 세그먼트 b- 트리 내부 (비 리프) 노드의 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">다음 다이어그램은 세그먼트 b- 트리 리프 노드의 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">다음 예제 코드는 위에서 설명한 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">다음 예는 숫자 인수를 16 진수로 인코딩 된 문자열로 변환하는 &quot;hex&quot;라는 새 SQL 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">다음 예는 다양한 형태의 EXCLUDE 절의 효과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">다음 예제는 표준 쿼리 구문을 사용하는 연산자의 우선 순위를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">다음 예제는 위를 보여줍니다. &quot;docs&quot;, &quot;docs.docs&quot;및 &quot;main.docs.docs&quot;는 모두 &quot;docs&quot;열을 나타냅니다. 그러나 &quot;main.docs&quot;표현식은 열을 참조하지 않습니다. 테이블을 참조하는 데 사용할 수 있지만 아래에서 사용되는 컨텍스트에서는 테이블 이름이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">다음 예제는 5 개의 순위 함수 (row_number (), rank (), dense_rank (), percent_rank () 및 cume_dist ())의 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">다음 예제에서는 지연된 외래 키 제약 조건 사용의 효과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">다음 예제는 위 C 코드로 구현 된 sumint () 함수를 사용합니다. 각 행에 대해 창은 이전 행 (있는 경우), 현재 행 및 다음 행 (있는 경우)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">다음 예제는 SQLITE_CONSTRAINT를 xBestIndex의 반환 값으로 사용하는 방법을 더 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">다음 플래그는 4 번째 파라미터를 통해 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm으로&lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">다음 플래그는 4 번째 파라미터를 통해 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; 및 &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm으로&lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">다음 플래그는 9 번째 매개 변수를 통해 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm에&lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">다음 플래그는 9 번째 매개 변수를 통해 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; 및 &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm에&lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">다음 함수를 사용하여이 함수로 작성된 변경 세트 반복기를 진행 및 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">다음은 하나의 특정 타임 라인을 생성하는 데 사용 된 모든 SQL에 대한 로그입니다 (2016-09-16에 캡처).</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">다음은 오류 로거 콜백에 나타날 수있는 메시지 종류의 일부 목록입니다.</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">다음은 SQLite 개발자가 핵심 SQLite 라이브러리의 동작을 추적, 검사 및 이해하기 위해 사용하는 임의의 기술입니다.</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">다음은 Firefox에서 사용되는 places.sqlite 데이터베이스 예제에 대한 sqlite3_analyzer 출력입니다.</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">RBU 업데이트에는 다음과 같은 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">다음 매크로는 특정 종류의 SQLite 빌드에 대한 인터페이스 연결을 지정합니다. Makefile은 일반적으로 이러한 매크로 설정을 자동으로 처리합니다. 응용 프로그램 개발자는 이러한 매크로에 대해 걱정할 필요가 없습니다. 이러한 매크로에 대한 다음 문서는 완전성에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">이 기능이 성공하려면 다음 사항에 해당해야합니다. sqlite3_snapshot_get ()을 호출 할 때 다음 명령문 중 하나라도 거짓이면 SQLITE_ERROR가 리턴됩니다. 이 경우 * P의 최종 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">사용하지 않는 기능을 생략 &lt;a href=&quot;footprint&quot;&gt;하여 컴파일 된 라이브러리의 크기&lt;/a&gt; 를 줄이는 데 다음 옵션을 사용할 수 있습니다 . SQLite 라이브러리가 포함 된 모든 기능이 비교적 작기 때문에 공간이 특히 좁은 임베디드 시스템에서만 유용합니다. 컴파일러에게 바이너리 크기를 최적화하도록 지시하는 것을 잊지 마십시오! (GCC를 사용하는 경우 -Os 옵션). 컴파일러에게 크기 최적화를 지시하면 일반적으로 이러한 컴파일 타임 옵션을 사용하는 것보다 라이브러리 풋 프린트에 훨씬 큰 영향을 미칩니다. 또한 &lt;a href=&quot;#debugoptions&quot;&gt;디버깅 옵션&lt;/a&gt; 이 비활성화되어 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">다음 쿼리는 Mandelbrot 세트의 근사값을 계산하고 결과를 ASCII 아트로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">다음 쿼리 매개 변수는 SQLite에서 &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;버전 3.15.0&lt;/a&gt; (2016-10-14) 으로 인식됩니다 . 향후 새로운 쿼리 매개 변수가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">다음 쿼리는 1에서 1000000 사이의 모든 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">다음 요구 사항은 위 절차의 1 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">다음 요구 사항은 위 절차의 2 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">다음 요구 사항은 위 절차의 3 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">다음 요구 사항은 위 절차의 4 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">다음 요구 사항은 위에 열거 된 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문의 본문에서 발생하는 DELETE 문에 다음 제한 사항이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">다음 루틴은 사용자 정의 배열 순서를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">다음 규칙과주의 사항은 각 INSERT 문의 일부로 지정된 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">다음 규칙은 각 잠금이 사용되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">다음 시나리오는 SQLITE_BUSY_SNAPSHOT 오류가 발생하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">다음 스크립트는 위의 테이블에 대한 정보를 수집하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">다음 섹션에서는 보조 기능 구현에 제공되는 API에 대해 자세히 설명합니다. 다른 예제는 소스 코드의 &quot;fts5_aux.c&quot;파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">다음 섹션에서는 문제 해결 또는 성능 분석에 유용 할 수있는 R * Tree 구현에 대한 저수준 세부 정보를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">다음 섹션에서는 지원되는 매개 변수에 대해 설명합니다. 인식 할 수없는 매개 변수 이름을 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">다음 섹션은 json1 확장의 일부인 다양한 기능의 작동에 대한 추가 세부 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">다음 구문 문서 주제를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">다음 표는 이전 섹션의 5 가지 규칙에 의해보다 일반적인 SQL 구현의 공통 데이터 유형 이름이 유사성으로 변환되는 수를 보여줍니다. 이 테이블은 SQLite가 허용 할 데이터 유형 이름의 작은 서브 세트 만 표시합니다. 참고 괄호 안의 숫자 인수가 (예 : &quot;VARCHAR (255)&quot;) 형식 이름을 다음 SQLite는 무시 - SQLite는은 (큰 지구 이외의 길이 제한을 부과하지 않습니다 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH의&lt;/a&gt; 문자열의 길이에 제한을), BLOB를 또는 숫자 값.</target>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">다음 표는 NULL 처리 실험 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">다음 표는 버전 1.0.0 이후에 발생한 SQLite 파일 형식 변경 사항을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">다음 두 개체와 여덟 가지 방법은 SQLite 인터페이스의 필수 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">전술 한 내용은 SQLite를 효과적으로 사용하기 위해 알아야 할 모든 것입니다. 나머지는 모두 최적화와 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">위의 텍스트는 SQLite 파일 형식의 저수준 측면을 설명합니다. b- 트리 메커니즘은 대규모 데이터 세트에 액세스하는 강력하고 효율적인 수단을 제공합니다. 이 섹션에서는 저수준 b- 트리 계층을 사용하여 고수준 SQL 기능을 구현하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">외래 키 제약 조건은 자식 테이블의 각 행에 대해 하나 이상의 자식 키 열이 NULL이거나 부모 테이블에 각 부모 키 열의 값과 동일한 값을 포함하는 행이있는 경우 충족됩니다. 연관된 하위 키 열.</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">테이블의 일부로 생성 된 외래 키 제약 조건</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">foreign_key_check pragma는 데이터베이스 또는 &quot;</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">이 섹션의 공식 가정은</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">sqlite_stat2의 형식은 레거시 참조를 위해 여기에 기록됩니다. 최신 버전의 SQLite는 더 이상 sqlite_stat2를 지원하지 않으며 sqlite_stat2 테이블이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">셀의 형식은 셀이 나타나는 b- 트리 페이지 종류에 따라 다릅니다. 다음 표는 다양한 b- 트리 페이지 유형에 대한 셀 요소를 모양 순서대로 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">모듈에 대한 인수의 형식은 매우 일반적입니다. 각 모듈 인수에는 키워드, 문자열 리터럴, 식별자, 숫자 및 문장 부호가 포함될 수 있습니다. 각 모듈 인수는 가상 테이블이 작성되고 해당 생성자가 인수 구문 분석 및 해석을 담당 할 때 가상 테이블 구현 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;생성자 메소드&lt;/a&gt; 에 텍스트로 작성된대로 전달됩니다 . 인수 구문은 가상 테이블 구현이 원하는 경우 일반 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 인수를 &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;열 정의&lt;/a&gt; 로 해석 할 수있을 정도로 일반적입니다 . 구현은 또한 인수에 대한 다른 해석을 부과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">기본 데이터베이스 파일의 형식은 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 문서에 설명되어 있습니다. 데이터베이스가 WAL 모드에 있음을 나타 내기 위해 기본 데이터베이스에 대한 오프셋 18 및 19 의 &lt;a href=&quot;fileformat2#vnums&quot;&gt;파일 형식 버전 번호&lt;/a&gt; 는 2 여야합니다. 기본 데이터베이스는 기본 파일 시스템에서 허용하는 임의의 이름을 가질 수 있습니다. &quot;.db&quot;, &quot;.sqlite&quot;및 &quot;.sqlite3&quot;이 널리 사용되는 것처럼 보이지만 특수 파일 접미사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">printf ()의 형식 문자열은 생성 된 문자열의 템플리트입니다. &quot;%&quot;문자가 형식 문자열에 나타날 때마다 대체됩니다. &quot;%&quot;다음에는 대체를 설명하는 하나 이상의 추가 문자가옵니다. 각 대체의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">SQLite 데이터베이스 파일이 사용하는 형식이 완전히 개정되었습니다. 이전 버전 2.1 형식과 새 3.0 형식은 서로 호환되지 않습니다. SQLite 버전 2.8은 버전 3.0 데이터베이스 파일을 읽지 않으며 SQLite 버전 3.0은 버전 2.8 데이터베이스 파일을 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">화석 델타 형식은 BLOB 값을 업데이트하는 데만 사용할 수 있습니다. data_ % 테이블 내에 새로운 BLOB를 저장하는 대신, 화석 델타가 대신 저장됩니다. 업데이트 할 열에 대해 rbu_control 문자열의 일부로 'x'를 지정하는 대신 'f'문자가 저장됩니다. 'f'업데이트를 처리 할 때 RBU는 디스크에서 원본 BLOB 데이터를로드하고 화석 델타를 적용한 다음 결과를 데이터베이스 파일에 다시 저장합니다. &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu에&lt;/a&gt; 의해 생성 된 RBU 데이터베이스 는 화석 델타를 사용하므로 RBU 데이터베이스의 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite의 창립자와 모든 현재 개발자는 최대한의 규칙에 따라 The Rule의 정신을 따르겠다고 약속했습니다. 그들은이 규칙을 모든 SQLite 사용자에게 개발자가 커뮤니티에서 어떻게 행동해야하는지에 대한 약속이라고 생각합니다. 이것은 일방적 인 약속 또는 계약입니다. 다시 말해 개발자들은 &quot;우리는 당신이 우리를 어떻게 대우하든 이런 식으로 당신을 대할 것&quot;이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">SQLite의 창립자 및이 문서가 작성 될 당시의 모든 현재 개발자는 &quot;선한 작업의 수단에 따라 서로, 고객 및 더 큰 SQLite 사용자 커뮤니티와의 상호 작용을 관리하기로 약속했습니다. &quot; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;성 베네딕트의 규칙&lt;/a&gt; 제 4 장 (이하&quot;규칙 &quot;). 이 윤리 강령은 1,500 년 동안 수천 개의 다양한 지역 사회에서 그 장점을 입증 해 왔으며, 샤를 마뉴 시대 이후 많은 민법의 기준이되었습니다.</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">네 가지 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">오프셋 8의 4 바이트 페이지 번호가 가장 오른쪽 포인터입니다. 이 값은 내부 b- 트리 페이지의 머리글에만 표시되며 다른 모든 페이지에서는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">이 함수에 전달 된 네 번째 인수 (xFilter)는 &quot;필터 콜백&quot;입니다. NULL이 아닌 경우, 변경 세트에서 하나 이상의 변경에 의해 영향을받는 각 테이블에 대해, 필터 콜백이 테이블 이름을 두 번째 인수로 사용하고 컨텍스트 포인터의 사본이 첫 번째로 여섯 번째 인수로 전달됩니다. &quot;필터 콜백&quot;이 0을 반환하면 테이블에 변경 사항을 적용하지 않습니다. 그렇지 않으면, 리턴 값이 0이 아니거나 xFilter 인수가 NULL이면 테이블과 관련된 모든 변경이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">네 번째 인수 인 pArg는 배열 함수 콜백에 대한 첫 번째 인수로 전달되는 애플리케이션 데이터 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">네 번째 열은 테이블에있는 모든 rowid의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">네 번째 매개 변수는 선택적으로 &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그를 포함 할 수 있으며 , 존재하는 경우 VIEW 또는 TRIGGER 내에서 함수가 호출되지 않도록합니다. 보안상의 이유로 &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;부작용&lt;/a&gt; 이있는 응용 프로그램 정의 SQL 함수 에는 SQLITE_DIRECTONLY 플래그가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">네 번째 매개 변수는 선택적으로 &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그를 포함 할 수 있으며 , 존재하는 경우 VIEW 또는 TRIGGER 내에서 함수가 호출되지 않도록합니다. 보안상의 이유로 &lt;a href=&quot;c_deterministic&quot;&gt;부작용&lt;/a&gt; 이있는 응용 프로그램 정의 SQL 함수 에는 SQLITE_DIRECTONLY 플래그가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">네 번째 매개 변수는 선택적으로 &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 과 OR 하여 단일 SQL 문 내에서 동일한 입력이 제공 될 때 함수가 항상 동일한 결과를 리턴 함 을 신호합니다. 대부분의 SQL 함수는 결정적입니다. 내장 &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; SQL 함수는 결정적이지 않은 함수의 예입니다. SQLite 쿼리 플래너는 결정적 함수에 대한 추가 최적화를 수행 할 수 있으므로 가능한 경우 &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 플래그를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">네 번째 매개 변수는 선택적으로 &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 과 OR 하여 단일 SQL 문 내에서 동일한 입력이 제공 될 때 함수가 항상 동일한 결과를 리턴 함 을 신호합니다. 대부분의 SQL 함수는 결정적입니다. 내장 &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; SQL 함수는 결정적이지 않은 함수의 예입니다. SQLite 쿼리 플래너는 결정적 함수에 대한 추가 최적화를 수행 할 수 있으므로 가능한 경우 &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 플래그를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2 ()의 네 번째 매개 변수는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;&lt;/a&gt; 는 새 데이터베이스 연결이 사용해야하는 운영 체제 인터페이스를 정의하는 sqlite3_vfs 오브젝트 . 네 번째 매개 변수가 NULL 포인터이면 기본 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2 () 네 번째 매개 변수의 이름 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 는 새 데이터베이스 연결이 사용해야하는 운영 체제 인터페이스를 정의하는 오브젝트 . 네 번째 매개 변수가 NULL 포인터이면 기본 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">네 번째 매개 변수 인 eTextRep는 이 SQL 함수가 매개 변수에 대해 선호 하는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;텍스트 인코딩을&lt;/a&gt; 지정합니다 . 응용 프로그램은이 매개 변수를 설정한다 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 기능 구현이 원용하는 경우 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;() sqlite3_value_text16le&lt;/a&gt; 입력에 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 구현 원용 경우 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; 의 입력에서, 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; 경우 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()가&lt;/a&gt; 사용되거나 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;그렇지 않으면. 동일한 SQL 함수는 각기 다른 인코딩으로 다른 선호 텍스트 인코딩을 사용하여 여러 번 등록 될 수 있습니다. 동일한 함수의 여러 구현을 사용할 수있는 경우 SQLite는 가장 적은 양의 데이터 변환을 포함하는 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">네 번째 매개 변수 인 eTextRep는 이 SQL 함수가 매개 변수에 대해 선호 하는 &lt;a href=&quot;c_any&quot;&gt;텍스트 인코딩을&lt;/a&gt; 지정합니다 . 응용 프로그램은이 매개 변수를 설정한다 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 기능 구현 원용이 경우 &lt;a href=&quot;value_blob&quot;&gt;() sqlite3_value_text16le&lt;/a&gt; 입력에 또는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 구현 원용 경우 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; 입력, 또는에 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16이&lt;/a&gt; 경우 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()가&lt;/a&gt; 사용되거나 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;그렇지 않으면. 동일한 SQL 함수는 각기 다른 인코딩으로 다른 선호 텍스트 인코딩을 사용하여 여러 번 등록 될 수 있습니다. 동일한 함수의 여러 구현을 사용할 수있는 경우 SQLite는 가장 적은 양의 데이터 변환을 포함하는 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">조각은 선택 사항입니다. 있는 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">프레임 경계는 &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;파티션&lt;/a&gt; 의 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">프레임 경계는 &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;파티션&lt;/a&gt; 의 마지막 행입니다 .</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">frame-spec은 집계 창 함수가 읽을 출력 행을 결정합니다. 프레임 사양은 네 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">프리리스트는 0 개 이상의 프리리스트 리프 페이지에 대한 페이지 번호를 포함하는 각 트렁크 페이지와 함께 프리리스트 트렁크 페이지의 링크 된 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">fts3tokenize 가상 테이블은 해당 토크 나이저를 실제로 사용하는 FTS3 또는 FTS4 테이블이 있는지 여부에 관계없이 모든 토크 나이저에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">fts5 unicode61 토크 나이 저는 fts3 / 4 unicode61 토크 나이저와 바이트 단위 호환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">fts5_api 구조는 다음과 같이 정의됩니다. 새로운 보조 기능 및 토크 나이저를 등록하기위한 방법과 기존 토크 나이저를 검색하기위한 방법의 세 가지 방법을 제공합니다. 후자는 내장 포터 토크 나이저와 유사한 &quot;토큰 라이저 래퍼&quot;의 구현을 용이하게하기위한 것이다.</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">fts5_api 구조 메소드는 다음 섹션에서 개별적으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">fts5vocab 가상 테이블 모듈을 사용하면 FTS5 전체 텍스트 인덱스에서 직접 정보를 추출 할 수 있습니다. fts5vocab 모듈은 FTS5의 일부입니다. FTS5가있을 때마다 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">상대 경로가 sqlite_open ()으로 전달 되더라도 데이터베이스 파일의 전체 경로 이름이 기억됩니다. 이를 통해 chdir () 후에 라이브러리가 계속 올바르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">외래 키 제약 조건을 지정하기위한 전체 구문은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 설명서의 일부로 제공됩니다 . 위 구문을 다음 중 하나로 바꾸면 즉각적인 외래 키 제약 조건이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">FTS5가 유지 관리하는 전체 텍스트 인덱스는 데이터베이스 테이블에 일련의 고정 크기 Blob으로 저장됩니다. 전체 텍스트 인덱스를 구성하는 모든 얼룩이 반드시 같은 크기 일 필요는 없습니다. pgsz 옵션은 후속 인덱스 작성자가 생성 한 모든 Blob의 크기를 결정합니다. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">함수 이름은 UTF-8로 지정됩니다. 별도의 sqlite3_create_function16 () API는 함수 이름이 UTF-16 호스트 바이트 순서로 지정된다는 점을 제외하고 sqlite_create_function ()과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">이 루틴이 리턴 한 함수 포인터 는 첫 번째 매개 변수에 제공된 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 오브젝트 의 수명 동안 유효해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">이전 예에서 제시된 함수는 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 을 한 번의 호출로 전체 소스 데이터베이스를 복사합니다. . 이를 위해서는 작업 중에 소스 데이터베이스 파일에 대한 읽기 잠금을 유지해야하므로 다른 데이터베이스 사용자가 데이터베이스에 쓸 수 없습니다. 또한 사본 전체에서 데이터베이스 pInMemory와 연관된 뮤텍스를 보유하여 다른 스레드가이를 사용하지 못하게합니다. 온라인 데이터베이스의 백업을 작성하기 위해 백그라운드 스레드 또는 프로세스에서 호출하도록 설계된이 섹션의 C 함수는 다음 방법을 사용하여 이러한 문제점을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts4aux 모듈에서 제공하는 기능은 이제 &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab에서&lt;/a&gt; 제공합니다 . 이 두 테이블의 스키마는 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">위의 각 기능에 필요한 기능은 sqlite3async.c의 주석에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">범용 메모리 할당자는 다양한 크기의 할당을 지원하므로 관리하기 가장 어려운 메모리 풀입니다. 이후 &lt;b&gt;, n은&lt;/b&gt; 에 승수 &lt;b&gt;M은&lt;/b&gt; 우리가 유지하려면 &lt;b&gt;n은&lt;/b&gt; 가능한 한 작게. 이것은 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 의 최소 ​​할당 크기를 가능한 크게 유지해야한다고 주장 합니다. 대부분의 응용 프로그램에서 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당자는&lt;/a&gt; 작은 할당을 처리 할 수 ​​있습니다. 따라서 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 의 최소 ​​할당 크기를 lookaside 할당의 최대 크기의 2, 4 또는 8 배로 설정하는 것이 합리적 입니다. 512의 최소 할당 크기는 적절한 설정입니다.</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">일반적으로 인덱스는 인덱스의 가장 왼쪽 열에 WHERE 절 제약 조건이있는 경우에만 유용합니다. 그러나 경우에 따라 SQLite는 인덱스의 처음 몇 열이 WHERE 절에서 생략되었지만 이후 열이 포함 된 경우에도 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">범용 메모리 할당 자 ( &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">generate_series 테이블은 &lt;a href=&quot;lang_with#recursivecte&quot;&gt;재귀 공통 테이블 표현식을&lt;/a&gt; 사용하여 시뮬레이션 할 수 있습니다 . 세 개의 매개 변수가 $ start, $ end 및 $ step 인 경우 동등한 공통 테이블 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series (START, END, STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 SQLite 소스 트리에 포함 된 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 이며 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸로&lt;/a&gt; 컴파일됩니다 . generate_series () 테이블에는 정수 값과 START, END 및 STEP 매개 변수에 의해 결정된 여러 행을 보유하는 &quot;value&quot;라는 단일 결과 열이 있습니다. 테이블의 첫 번째 행의 값은 START입니다. 후속 행은 STEP까지 END까지 증가합니다.</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopoly 모듈은 다각형 처리에 유용한 몇 가지 새로운 SQL 함수를 정의합니다. 이 함수에 대한 모든 다각형 인수는 GeoJSON 형식이거나 내부 이진 형식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">지오 폴리 모듈은 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장의 확장&lt;/a&gt; 입니다. Geopoly는 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 과 동일한 기본 논리 및 새도우 테이블을 사용합니다 . Geopoly는 단순히 다른 인터페이스를 제공하며 다각형 디코딩, 겹침 및 포함을 계산하기위한 추가 논리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">지오 폴리 모듈은 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 위에 구축되며 동일한 기본 새도우 테이블 및 알고리즘을 사용합니다. 인덱싱을 위해 각 다각형은 그림자 테이블에 직사각형 경계 상자로 표시됩니다. 기본 R-Tree 구현은 경계 상자를 사용하여 검색 공간을 제한합니다. 그런 다음 geoploy_overlap () 및 / 또는 geopoly_within () 루틴은 정확한 답으로 검색을 세분화합니다.</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw (J) 함수는 시계 반대 방향 (CCW) 회전으로 다각형 J를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox (P) 함수는 geopoly_bbox (P)의 집계 버전입니다. geopoly_group_bbox (P) 함수는 집계 중에 표시되는 모든 P 값을 묶는 가장 작은 사각형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap (P1, P2) 함수는 geopoly 가상 테이블이 R * Tree 인덱스를 사용하여 WHERE 절이 geopoly_overlap ()을 부울 함수로 사용하는 쿼리를 최적화하는 방법을 알고 있다는 점에서 특별합니다. geopoly_overlap (P1, P2) 및 geopoly_within (P1, P2) 함수 만이 기능을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular (X, Y, R, N) 함수는 N면, X, Y 중심 및 R의 원주를 가진 볼록하고 단순하고 규칙적인 정삼각형 다각형을 반환합니다. 또는 R이 음수이거나 N 인 경우 3보다 작 으면 함수는 NULL을 리턴합니다. N 값이 1000보다 큰 경우에도 루틴은 1000 이상의 변을 가진 다각형을 렌더링하지 않도록 1000으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within (P1, P2) 함수는 geopoly 가상 테이블이 R * Tree 색인을 사용하여 WHERE 절이 geopoly_within ()을 부울 함수로 사용하는 쿼리를 최적화하는 방법을 알고 있다는 점에서 특별합니다. geopoly_within (P1, P2) 및 geopoly_overlap (P1, P2) 함수 만이 기능을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform (P, A, B, C, D, E, F) 함수는 다각형 P의 아핀 변환이고 변환이 값 A, B, C, D, E, F 인 새 다각형을 반환합니다. . P가 유효한 다각형이 아닌 경우이 루틴은 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob (X, Y) 함수는 &quot; &lt;b&gt;Y GLOB X&lt;/b&gt; &quot; 표현식과 같습니다 . glob () 함수에서 X 및 Y 인수는 삽입 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자를 기준으로 반전됩니다 . Y는 문자열이고 X는 패턴입니다. 예를 들어 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">목표는 SQLite가 표준 호환 방식으로 NULL을 처리하도록하는 것입니다. 그러나 NULL을 처리하는 방법에 대한 SQL 표준의 설명은 모호해 보입니다. 표준 문서에서 모든 상황에서 NULL을 어떻게 처리해야하는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">이 쿼리의 목표는 테이블에서 가장 최근 5 개의 항목에 대한 값을 계산하는 것입니다. 그러나 위 쿼리에서 &quot;expensive_function ()&quot;은 정렬 전에 호출되므로 테이블의 모든 행에서 호출됩니다. 심지어 LIMIT 절로 인해 생략 된 행까지도 마찬가지입니다. 이 문제를 해결하기 위해 공동 루틴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">문법 구문은 오류가 덜 발생합니다. Yacc의 &quot;$ 1&quot;스타일 위치 표기법보다는 의미 값에 기호 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">아래 그래프는 약 10 년 전의 SQLite 버전에 대해 표준 워크로드에서 SQLite가 사용한 CPU주기 수를 보여줍니다. 최신 버전의 SQLite는 이전 버전에 비해 약 3 분의 1의 CPU주기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">group_concat () 함수는 NULL이 아닌 모든 값을 연결 한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">모든 입력이 빈 문자열이면 group_concat (x, '') SQL 함수는 빈 문자열 대신 NULL을 반환합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">오른쪽 표현식에 NULL을 포함하는 IN 및 NOT IN 연산자 처리는 SQL 표준 및 기타 SQL 데이터베이스 엔진을 준수합니다. 이것은 버그 수정이지만 이전 버그가있는 동작에 의존하는 레거시 응용 프로그램을 중단 할 가능성이 있으므로 *** 잠재적으로 호환되지 않는 변경 사항 ***으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shm 파일의 해시 테이블은 다음 질문에 빠르게 대답하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git 미러에서 체크인 및 파일을 식별하는 해시는 Fossil의 해시와 다릅니다. 여기에는 여러 가지 이유가 있습니다. 그 중에서도 Fossil은 SHA3-256 해시를 사용하고 Git은 SHA1 해시를 사용합니다. 내보내는 동안 각 체크인에 대한 원래 Fossil 해시가 주석에 바닥 글로 추가됩니다. 혼동을 피하려면 SQLite 체크인을 참조 할 때 항상 Git 해시가 아닌 원래 Fossil 해시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">롤백 저널의 헤더를 유효하지 않은 헤더 텍스트 (예 : 모두 0)로 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">롤백 저널의 헤더가 올바르게 구성되어 있으며 특히 제로화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">헤더 크기 varint 및 serial type varint는 일반적으로 단일 바이트로 구성됩니다. 큰 문자열 및 BLOB의 직렬 유형 varint는 2 또는 3 바이트 varint로 확장 될 수 있지만 이는 규칙이 아닌 예외입니다. varint 형식은 레코드 헤더를 코딩하는 데 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">헤더 문자열 : &quot;SQLite 형식 3 \ 000&quot;</target>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG에서&lt;/a&gt; 사용하는 무거운 래퍼 는 SQLite의 테스트, 분석 및 디버깅 중에 만 사용하도록 고안되었습니다. 무거운 래퍼는 성능과 메모리 오버 헤드가 크므로 프로덕션 환경에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; 가 설정 될 때 사용되는 강력한 랩퍼는 또한 호출자에게 할당을 리턴하기 전에 각각의 새로운 할당이 넌센스 데이터로 채워지도록합니다. 그리고 할당이 자유 로워지면 다시 말도 안되는 데이터로 채워집니다. 이 두 가지 조치는 SQLite 코어가 새로 할당 된 메모리의 상태에 대해 가정하지 않고 메모리 할당이 해제 된 후에 사용되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex () 함수는 인수를 BLOB로 해석하고 해당 Blob 컨텐츠의 대문자 16 진 렌더링 인 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">캐시 그라인드의 높은 반복성은 SQLite 개발자가 &quot;미세 최적화&quot;를 구현하고 측정 할 수 있도록합니다. 미세 최적화는 코드를 변경하여 성능을 약간만 향상시킵니다. 일반적인 마이크로 최적화는 CPU주기 수를 0.1 % 또는 0.05 % 이하로 줄입니다. 이러한 개선은 실제 타이밍으로는 측정 할 수 없습니다. 그러나 수백 또는 수천 개의 미세 최적화가 추가되어 실제 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLite의 높은 신뢰성은 실제로 입증되었습니다. SQLite는 전 세계적으로 수십억 개의 스마트 폰, IoT 장치 및 데스크톱 응용 프로그램에서 10 년 이상 문제없이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">highlight () 함수는 구문의 시작과 끝이 일치하도록 추가 마크 업 텍스트를 삽입하여 현재 행의 지정된 열에서 텍스트 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">테이블 이름 뒤에 정확히 세 개의 인수를 사용하여 highlight ()를 호출해야합니다. 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">히스토그램 데이터는 제약 조건의 오른쪽이 간단한 컴파일 타임 상수 또는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 표현식이 아닌 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">SQLite의 과거 동작은 SQL : 1999 표준에 따라 올바르지 않으며 MySQL 및 PostgreSQL의 동작과 일치하지 않습니다. 버전 3.6.0은 IN 및 NOT IN 연산자의 동작을 변경하여 표준을 준수하고 다른 SQL 데이터베이스 엔진과 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost 열은 cFrom을 cTo로 변환하는 숫자 비용입니다. 이 값은 음이 아닌 정수 여야하며 100보다 작아야합니다. 기본 단일 문자 삽입 및 삭제 비용은 100이고 기본 단일 문자 대 단일 문자 대체 비용은 150입니다. 비용 10000 이상 &quot;무한&quot;으로 간주되며 규칙이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang 열은 특정 언어에 적합한 일련의 비용을 식별하는 음이 아닌 정수입니다. editdist3 함수는 주어진 편집 거리 계산에 단일 iLang 값만 사용합니다. 기본값은 0입니다. 단일 언어 만 사용해야하는 응용 프로그램은 항상 모든 항목에 대해 iLang == 0을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 iVersion 필드는 향후 개선 사항에 대한 보험으로 제공됩니다. SQLite 버전 3.5의 경우 iVersion 값은 항상 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 의 iVersion 필드는 SQLite 버전 3.5.0의 경우 1이어야합니다. VFS 객체를 어떤 방식으로 수정해야 할 경우이 버전은 향후 버전의 SQLite에서 증가 할 수 있습니다. 우리는 이것이 일어나지 않기를 희망하지만, 만일의 경우에 대비하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">예약 된 잠금의 개념은 프로세스가 가까운 시일 내에 데이터베이스 파일을 수정하려고하지만 아직 수정을 시작하지 않았다는 신호입니다. 수정이 아직 시작되지 않았으므로 데이터베이스에서 다른 프로세스를 계속 읽을 수 있습니다. 그러나 다른 프로세스도 데이터베이스에 쓰려고 시도하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNum 및 idxPtr 값이 기록되어 &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 로 전달됩니다 . &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 needToFreeIdxPtr이 true 인 경우에만 idxPtr을 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNum 및 idxPtr 값이 기록되어 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 로 전달됩니다 . &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 needToFreeIdxPtr이 true 인 경우에만 idxPtr을 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr 값은 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 SQLite 메모리 할당 함수에서 얻은 문자열 일 수 있습니다 . 이 경우 SQLite 코어가 해당 문자열에서 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 하여 메모리 누수가 발생하지 않도록 알 수 있도록 needToFreeIdxStr 플래그를 true로 설정해야합니다 . idxStr 값은 정적 상수 문자열 일 수도 있습니다.이 경우 needToFreeIdxStr 부울은 false로 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull () 함수는 NULL이 아닌 첫 번째 인수의 사본을 리턴하거나 두 인수가 모두 NULL 인 경우 NULL을 리턴합니다. Ifnull ()에는 정확히 2 개의 인수가 있어야합니다. ifnull () 함수는 두 개의 인수가있는 &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">변경 불가능한 조회 매개 변수는 기본 데이터베이스 파일이 읽기 전용 매체에 보유되고 상승 된 권한을 가진 다른 프로세스에 의해서도 수정할 수 없음을 SQLite에 알리는 부울입니다. SQLite는 항상 변경 불가능한 데이터베이스 파일을 읽기 전용으로 열고 변경 불가능한 데이터베이스 파일에 대한 모든 파일 잠금 및 변경 감지를 건너 뜁니다. 이러한 쿼리 매개 변수 (또는 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristics&lt;/a&gt; 의 SQLITE_IOCAP_IMMUTABLE 비트)가 데이터베이스 파일을 변경할 수없고 파일이 변경되는 경우 SQLite는 잘못된 쿼리 결과 및 / 또는 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 오류를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1 가상 테이블의 구현은 기타 확장 폴더의 SQLite 소스 트리, 특히 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c&lt;/a&gt; 파일에 있습니다. spellfix1 가상 테이블은 SQLite &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되어 있지 않으며 표준 SQLite 빌드의 일부가 아닙니다. 그것은이다 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">실제로 작동하는 이러한 루틴의 버전을 제공 할 필요는 없습니다. 구현에서 이러한 루틴의 작업 버전을 제공하지 않는 경우, 항상 참을 리턴하는 스텁을 제공하여 가짜 어설 션 오류가 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">구현은 fts5_api 객체의 xCreateFunction () 메소드를 호출하여 FTS5 모듈에 등록됩니다. 이름이 같은 보조 기능이 이미 있으면 새 기능으로 대체됩니다. NULL이 아닌 xDestroy 매개 변수가 xCreateFunction ()에 전달되면, 데이터베이스 핸들이 닫히거나 등록 된 보조 함수가 대체 될 때 유일한 인수로 전달 된 pContext 포인터의 사본으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">구현은 fts5_api 객체의 xCreateTokenizer () 메소드를 호출하여 FTS5 모듈에 등록됩니다. 이름이 같은 토크 나이저가 이미 있으면 교체됩니다. NULL이 아닌 xDestroy 매개 변수가 xCreateTokenizer ()에 전달되면, 데이터베이스 핸들이 닫히거나 토크 나이저가 교체 될 때 유일한 인수로 전달 된 pContext 포인터의 사본으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">예제 코드의 구현 언어는 &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt; 이지만 다른 프로그래밍 언어에서 동일한 작업을 쉽게 수행 할 수 있습니다. 여기서 코드는 자동으로 모든 것을 수행하는 드롭 인 모듈이 아니라 기술을 보여줍니다. 아래 표시된 데모 코드는 실제 프로덕션 코드에서 파생 된 것입니다. 그러나 애플리케이션에 맞게 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">이 기능의 구현은 최소한 두 가지 방법으로 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">출력의 중요한 부분 (개발자가 가장주의를 기울이는 부분)은 빨간색으로 표시됩니다. 기본적으로 개발자는 컴파일 된 SQLite 라이브러리의 크기와 성능 테스트를 실행하는 데 필요한 CPU주기 수를 알고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">임 포스터 테이블 메커니즘은 SQLite를위한 전력 분석 및 디버깅 도구입니다. 그러나 모든 날카로운 도구와 마찬가지로 위험 할 수 있으며 잘못 사용하면 데이터베이스 파일이 손상 될 수 있습니다. 응용 프로그램에서 임 포스터 테이블을 사용하지 마십시오. 임 포스터 테이블은 전문가가 실험실에서 사용하도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">헤더 내 데이터베이스 크기는 0이 아니고 오프셋 24 의 4 바이트 &lt;a href=&quot;fileformat2#chngctr&quot;&gt;변경 카운터&lt;/a&gt; 가 오프셋 92의 4 바이트 &lt;a href=&quot;fileformat2#validfor&quot;&gt;버전 유효 숫자&lt;/a&gt; 와 정확히 일치하는 경우에만 유효한 것으로 간주됩니다. 헤더 내 데이터베이스 size는 데이터베이스가 최신 버전의 SQLite, 버전 3.7.0 (2010-07-21) 이상을 사용하여 수정 된 경우 항상 유효합니다. 레거시 버전의 SQLite가 데이터베이스에 쓰면 헤더 내 데이터베이스 크기를 업데이트하는 것을 알 수 없으므로 헤더 내 데이터베이스 크기가 올바르지 않을 수 있습니다. 그러나 레거시 버전의 SQLite도 오프셋 92의 버전 유효 번호를 변경하지 않고 변경 카운터와 일치하지 않습니다. 따라서 변경 카운터가 버전-유효 버전 번호와 일치하지 않는 경우를 관찰하여 잘못된 헤더 내 데이터베이스 크기를 감지 (및 무시) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">incremental_vacuum pragma는 최대</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">인덱스의 가장 왼쪽 열 (열 &quot;a&quot;)이 제한되지 않으므로 인덱스를 전혀 사용할 수 없습니다. 다른 인덱스가 없다고 가정하면 위의 쿼리로 전체 테이블 스캔이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">WHERE 절 용어가 AND 대신 OR로 연결되어 있으므로 인덱스를 사용할 수 없습니다. 이 쿼리는 전체 테이블 스캔이됩니다. 그러나 열 b, c 및 d가 가장 왼쪽 열로 포함 된 추가 인덱스가 추가 된 경우 &lt;a href=&quot;#or_opt&quot;&gt;OR 절 최적화&lt;/a&gt; 가 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">열 내 용어 인스턴스의 색인입니다. 용어는 0부터 시작하여 순서대로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">인덱싱 된 문서는 SQLite 데이터베이스 ( &quot;contentless&quot;FTS4 테이블)에 전혀 저장되지 않거나</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">색인화 된 문서는 사용자가 작성하고 관리하는 데이터베이스 테이블 ( &quot;외부 컨텐츠&quot;FTS4 테이블)에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">접 두부 LIKE 연산자는 애플리케이션 정의 SQL 함수 &lt;a href=&quot;lang_corefunc#like&quot;&gt;(( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; )&lt;/a&gt; 또는 &lt;a href=&quot;lang_corefunc#like&quot;&gt;like ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; , &lt;i&gt;Z&lt;/i&gt; )&lt;/a&gt; 를 호출하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">위의 정보는 다음과 같이 테이블 형식으로 다시 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">이 API 및 해당 xPhraseFirstColumn ()을 사용하여 액세스 한 정보는 xPhraseFirst / xPhraseNext (또는 xInst / xInstCount)를 사용하여 얻을 수도 있습니다. 이 API의 주요 장점은 &quot;detail = column&quot;테이블과 함께 사용할 때 다른 API보다 훨씬 효율적이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 정보 는 일시적이며 xBestIndex 메소드가 리턴 되 자마자 덮어 쓰거나 할당 해제 될 수 있습니다. xBestIndex 메소드가 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조의 일부를 기억 해야하는 경우 복사해야합니다. needToFreeIdxStr이 1로 설정된 idxStr 필드와 같이 사본이 할당 해제 될 위치에 사본을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">이 기사의 정보는 SQLite가 &quot;롤백 모드&quot;에서 작동 중이거나 SQLite가 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그를&lt;/a&gt; 사용하지 않는 경우에만 적용됩니다 . SQLite는 미리 쓰기 로깅이 활성화 된 경우 여전히 아톰 커밋을 지원하지만이 기사에서 설명하는 것과 다른 메커니즘으로 아토믹 커밋을 수행합니다. SQLite가 해당 컨텍스트에서 원자 커밋을 지원하는 방법에 대한 추가 정보는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">초기 &quot;INSERT&quot;키워드는 &quot;REPLACE&quot;또는 &quot;INSERT OR로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">초기 내용은 UTF-16 텍스트이며 sqlite3_column_bytes () 또는 sqlite3_column_text ()가 호출됩니다. 내용은 UTF-8로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">초기 내용은 UTF-8 텍스트이며 sqlite3_column_bytes16 () 또는 sqlite3_column_text16 ()이 호출됩니다. 내용은 UTF-16으로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">초기 내용은 BLOB이며 sqlite3_column_text () 또는 sqlite3_column_text16 ()이 호출됩니다. 문자열에 제로 종결자를 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQP의 초기 구현은 단순 쿼리의 경우 N = 1, 양방향 조인의 경우 N = 5, 3 개 이상의 테이블과의 모든 조인의 경우 N = 10을 선택합니다. N을 선택하기위한이 공식은 후속 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">넘침 페이지로 넘치지 않는 페이로드의 초기 부분.</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">내부 SELECT 문은 명령 1-10으로 구현됩니다.이 코드는 &quot;p&quot;열에 대해 NULL이 아닌 값으로 examp2 테이블의 각 행에 대한 임시 테이블에 항목을 작성합니다. 각 임시 테이블 항목의 키는 examp2의 &quot;3&quot;열이며 데이터는 사용되지 않으므로 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">간단한 SELECT 쿼리에서 사용하는 입력 데이터는</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; 의 입력 은 0으로 끝나는 UTF-8 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16 ()에&lt;/a&gt; 대한 입력 은 기본 바이트 순서로 0으로 끝나는 UTF-16 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; 의 입력 은 0으로 끝나는 UTF-8 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16 ()에&lt;/a&gt; 대한 입력 은 기본 바이트 순서로 0으로 끝나는 UTF-16 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3에 대한 입력은 C 또는 SQL로 작성된 테스트 모듈이며 SQLite를 초기화하는 방법을 결정하는 작은 구성 파일입니다. TH3 패키지에는 1,444 개의 테스트 모듈과 47 개 이상의 구성이 포함되어 있습니다 (2018-05-19 기준). 특수 어플리케이션에 맞게 TH3을 사용자 정의하기 위해 새로운 모듈 및 구성을 추가 할 수 있습니다. TH3이 실행될 때마다 사용 가능한 테스트 모듈 및 구성 파일의 서브 세트를 읽고 지정된 모든 구성에서 지정된 모든 테스트를 수행하는 사용자 정의 C 프로그램을 생성합니다. SQLite의 전체 테스트는 일반적으로 TH3을 여러 번 실행하여 SQLite 작업의 다양한 측면을 다루는 여러 테스트 프로그램을 생성 한 다음 모든 테스트 프로그램을 공통 SQLite 라이브러리에 연결하고 대상 플랫폼에서 별도로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">이 문서에 대한 영감은 &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt; 입니다. 품질 표준 중에서 DO-178B는 서류 작업에 대한 유용성이 가장 높은 것 같습니다. 그럼에도 불구하고 완전한 DO-178B 구현에 필요한 문서의 양은 방대합니다. SQLite는 민첩하고 의식이 적도록 노력하고 있으며,이를 위해 필요한 DO-178B 문서의 대부분이 생략되었습니다. 우리는 SQLite와 같은 오픈 소스 소프트웨어 프로젝트의 품질을 진정으로 향상시키는 부분만을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr (X, Y) 함수는 문자열 X에서 문자열 Y의 첫 항목을 찾아 이전 문자 수에 1을 더한 값을 반환하거나, Y가 X 내에없는 경우 0을 반환합니다. 또는 X와 Y가 BLOB 인 경우 instr (X, Y)는 Y가 처음 발생하기 전에 숫자 바이트보다 하나 이상을 반환하거나, X 내에서 Y가 발생하지 않으면 0을 반환합니다. instr (X, Y)에 대한 인수 X와 Y가 모두 NULL이 아니고 BLOB가 아니라면 둘 다 문자열로 해석됩니다. instr (X, Y)에서 X 또는 Y가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">명령 &lt;a href=&quot;opcode#Close&quot;&gt;닫기&lt;/a&gt; 는 이전에 P1 (0, 유일한 열린 커서)으로 열린 커서를 닫 습니다. P1이 현재 열려 있지 않으면이 명령은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;커밋&lt;/a&gt; 명령 은 마지막 트랜잭션 이후에 작성된 데이터베이스에 대한 모든 수정 사항이 실제로 적용되도록합니다. 다른 트랜잭션이 시작될 때까지 추가 수정이 허용되지 않습니다. 커밋 명령은 저널 파일을 삭제하고 데이터베이스에서 쓰기 잠금을 해제합니다. 여전히 커서가 열려 있으면 읽기 잠금이 계속 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 명령 은 VDBE 엔진을 즉시 종료시킵니다. 열려있는 모든 커서, 목록, 정렬 등이 자동으로 닫힙니다. P1은 sqlite_exec ()에 의해 반환 된 결과 코드입니다. 정상적인 정지의 경우 SQLITE_OK (0)이어야합니다. 오류의 경우 다른 값이 될 수 있습니다. 피연산자 P2는 오류가있는 경우에만 사용됩니다. 모든 프로그램의 끝에 &quot;Halt 0 0 0&quot;명령이 내재되어 있습니다. VDBE는 프로그램 실행 준비시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">13에서 &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; 명령 은 인덱스에서 테이블 레코드 번호를 스택으로 푸시합니다. 다음 MoveTo는 그것을 팝하고 테이블 커서를 해당 행으로 이동합니다. 다음 3 개의 명령어는 색인화되지 않은 경우와 동일한 방식으로 열 데이터를 선택합니다. 열 명령어는 열 데이터를 가져오고 콜백 함수가 호출됩니다. 마지막 Next 명령어는 테이블 커서가 아닌 인덱스 커서를 다음 행으로 진행 한 다음 인덱스 레코드가 남아 있으면 루프 시작으로 다시 분기합니다.</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; 명령어 는 P1 피연산자 (99)를 스택으로 푸시합니다. 나중에 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">명령어 &lt;a href=&quot;opcode#Integer&quot;&gt;정수&lt;/a&gt; 는 정수 값 P1 (0)을 스택으로 푸시합니다. 여기서 0은 다음 OpenWrite 명령어에서 사용할 데이터베이스 번호입니다. P3이 NULL이 아니면 동일한 정수의 문자열 표현입니다. 나중에 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어 는 스택에서 최상위 P1 요소를 팝하고 (이 경우 2) 데이터베이스 파일에 레코드를 저장하는 데 사용되는 이진 형식으로 변환합니다. (자세한 내용은 &lt;a href=&quot;fileformat&quot;&gt;파일 형식&lt;/a&gt; 설명을 참조하십시오.) MakeRecord 명령으로 생성 된 새 레코드가 스택으로 다시 푸시됩니다. 나중에 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">명령 &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; 는 커서 P1이 가리키는 테이블에 대해 새로운 정수 레코드 번호를 작성합니다. 레코드 번호는 현재 테이블에서 키로 사용되지 않은 번호입니다. 새 레코드 번호가 스택으로 푸시됩니다. 나중에 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; 명령어 는 루트 페이지가 P2 (이 데이터베이스 파일에서 3) 인 &quot;examp&quot;테이블에서 핸들 P1 (이 경우 0)을 가진 새로운 읽기 / 쓰기 커서를 엽니 다. 커서 핸들은 음이 아닌 정수일 수 있습니다. 그러나 VDBE는 배열의 크기가 가장 큰 커서보다 하나 더 큰 배열에 커서를 할당합니다. 따라서 메모리를 절약하려면 0으로 시작하고 연속적으로 위쪽으로 작업하는 핸들을 사용하는 것이 가장 좋습니다. 여기서 P3 ( &quot;examp&quot;)은 열려있는 테이블의 이름이지만 사용되지 않으며 코드를보다 쉽게 ​​읽을 수 있도록 생성됩니다. 이 명령어는 스택의 맨 위에서 사용할 데이터베이스 번호 (0, 주 데이터베이스)를 팝한 후 스택이 다시 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; 명령 은 상위 2 개의 스택 항목을 사용하여 커서 P1이 가리키는 테이블에 항목을 씁니다. 새 항목이 존재하지 않거나 기존 항목의 데이터를 덮어 쓰면 새 항목이 작성됩니다. 레코드 데이터는 최상위 스택 항목이며 키는 다음 항목입니다. 이 명령으로 스택이 두 번 터집니다. 피연산자 P2가 1이므로 행 변경 횟수가 증가하고 sqlite_last_insert_rowid () 함수에 의해 후속 리턴을 위해 rowid가 저장됩니다. P2가 0이면 행 변경 계수가 수정되지 않습니다. 이 명령어는 실제로 인서트가 발생하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">명령 &lt;a href=&quot;opcode#String&quot;&gt;문자열&lt;/a&gt; 은 P3 피연산자를 스택으로 푸시합니다. 나중에 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">명령의 &lt;a href=&quot;opcode#Transaction&quot;&gt;트랜잭션은&lt;/a&gt; 트랜잭션을 시작한다. 커밋 또는 롤백 opcode가 발생하면 트랜잭션이 종료됩니다. P1은 트랜잭션이 시작된 데이터베이스 파일의 색인입니다. 인덱스 0은 기본 데이터베이스 파일입니다. 트랜잭션이 시작될 때 데이터베이스 파일에서 쓰기 잠금이 획득됩니다. 트랜잭션이 진행되는 동안 다른 프로세스는 파일을 읽거나 쓸 수 없습니다. 트랜잭션을 시작하면 롤백 저널도 작성됩니다. 데이터베이스를 변경하기 전에 트랜잭션을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; 명령은 쿠키 0 (데이터베이스 스키마 버전)이 P2 (데이터베이스 스키마를 마지막으로 읽었을 때 얻은 값)와 같은지 확인합니다. P1은 데이터베이스 번호입니다 (기본 데이터베이스의 경우 0). 이것은 데이터베이스 스키마가 다른 스레드에 의해 변경되지 않았는지 확인하기 위해 수행되며,이 경우 다시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">주소 9의 명령어는 루프의 분기 부분을 구현합니다. 주소 5에서 되감기와 함께 루프 논리를 형성합니다. 이것은주의를 기울여야하는 핵심 개념입니다. &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 명령은 다음 레코드 커서 P1을 진행한다. 커서가 성공적으로 진행되면 즉시 P2 (6, 루프 바디의 시작)로 점프합니다. 커서가 끝에 있으면 다음 명령으로 넘어가 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">레지스터 P1의 주소에있는 명령어는 &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; 입니다. 해당 &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; 의 P2 매개 변수로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동&lt;/a&gt; 하십시오 . 점프 후 레지스터 P1은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">명령어 6 ~ 8은 데이터베이스 파일의 각 레코드마다 한 번씩 실행되는 루프 본문을 구성합니다. 주소 6과 7 의 &lt;a href=&quot;opcode#Column&quot;&gt;열&lt;/a&gt; 명령어는 각각 P1 번째 커서에서 P2 번째 열을 가져와 스택에 밀어 넣습니다. 이 예에서 첫 번째 열 명령은 열 &quot;1&quot;에 대한 값을 스택으로 푸시하고 두 번째 열 명령은 열 &quot;2&quot;에 대한 값을 푸시합니다. 주소 8 의 &lt;a href=&quot;opcode#Callback&quot;&gt;콜백&lt;/a&gt; 명령어는 콜백 () 함수를 호출합니다. 콜백에 대한 P1 피연산자는 &lt;b&gt;nColumn&lt;/b&gt; 의 값이 &lt;b&gt;됩니다&lt;/b&gt; . 콜백 명령어는 스택에서 P1 값을 팝하고이를 사용하여 &lt;b&gt;azData []&lt;/b&gt; 배열 을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">동일한 연결에서 &quot;PRAGMA data_version&quot;을 두 번 호출하여 리턴 된 정수 값은 변경 사항이 중간에 다른 연결에 의해 데이터베이스에 커미트 된 경우 다릅니다. &quot;PRAGMA data_version&quot;값은 동일한 데이터베이스 연결에서 커밋 된 경우 변경되지 않습니다. &quot;PRAGMA data_version&quot;의 동작은 별도의 프로세스에서의 데이터베이스 연결 및 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 데이터베이스 연결을 포함하여 모든 데이터베이스 연결에서 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock () 및 xUnlock ()의 ​​정수 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">무결성 검사 명령은 텍스트 값 'integrity-check'를 FTS5 테이블과 동일한 이름의 특수 열에 삽입하여 호출됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">이 pragma의 의도 된 사용은 SQLite의 테스트 및 유효성 검증에만 사용됩니다. 이 pragma는 사전 통지없이 변경 될 수 있으며 응용 프로그램에서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">개발자의 의도는 2050 년까지 SQLite를 지원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 및 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령 에 대한 이러한 향상된 기능의 목적은 적어도 외래 키 제약 조건이 활성화되어있는 동안 외래 키 위반이 포함 된 데이터베이스를 만드는 데 사용할 수 없도록하는 것입니다. 그러나이 규칙에는 한 가지 예외가 있습니다. 상위 키가 상위 테이블 정의의 일부로 작성된 PRIMARY KEY 또는 UNIQUE 제한 조건의 영향을받지 않지만 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX를&lt;/a&gt; 사용하여 작성된 색인으로 인해 UNIQUE 제한 조건의 영향을받는 경우&quot;외래 키 불일치&quot;오류를 발생시키지 않고 자식 테이블이 채워질 수 있습니다. 데이터베이스 스키마에서 UNIQUE 인덱스가 삭제되면 상위 테이블 자체가 삭제되며 오류가보고되지 않습니다. 그러나 데이터베이스는 외래 키 제약 조건의 자식 테이블에 부모 테이블 행을 참조하지 않는 행이 포함 된 상태로 남아있을 수 있습니다. 데이터베이스 스키마의 모든 상위 키가 외부 UNIQUE 인덱스가 아닌 상위 테이블 정의의 일부로 추가 된 PRIMARY KEY 또는 UNIQUE 제약 조건으로 제한되는 경우이 경우를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE와 B-Tree 계층 간의 인터페이스가 향상되어 VDBE가 B-Tree 계층에 힌트를 제공하여 B-Tree 계층에 임시 테이블에 대해 B-Tree 대신 해싱을 사용하는 것이 안전한시기를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">B-tree 서브 시스템과 나머지 SQLite 라이브러리에 대한 &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;인터페이스&lt;/a&gt; 는 헤더 파일 btree.h에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLite 라이브러리 에 대한 인터페이스는 &lt;b&gt;sqlite3&lt;/b&gt; 이라는 단일 tcl 명령으로 구성 됩니다.이 명령은 하나뿐이므로 인터페이스는 별도의 네임 스페이스에 배치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite 라이브러리에 대한 인터페이스는 세 가지 핵심 함수, 하나의 불투명 한 데이터 구조 및 반환 값으로 사용되는 일부 상수로 구성됩니다. 핵심 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">이 opcode에 의해 설정된 데이터 정렬 시퀀스를 검색하기 위해 위에서 언급 한 함수의 구현에 사용되는 인터페이스는 공개적으로 사용할 수 없습니다. 내장 기능 만이 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">내장 날짜 / 시간 함수와 같이 입력에 따라 결정적이거나 결정적이지 않은 함수를 구성하는 데 필요한 인터페이스는 게시되지 않습니다. 일반 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 는 항상 결정적이거나 비 결정적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">내부 Mem 객체는 단일 레지스터의 값을 저장합니다. API에 노출 되는 추상 &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; 객체는 실제로 Mem 객체 또는 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLite 라이브러리의 내부 구성은 오른쪽에 표시된 모듈 스택으로 볼 수 있습니다. 토큰 화기, 구문 분석기 및 코드 생성기 구성 요소는 SQL 문을 처리하고이를 가상 머신 언어 또는 바이트 코드로 실행 가능한 프로그램으로 변환하는 데 사용됩니다. 대략적으로,이 최상위 3 개의 레이어는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 구현 합니다. 상위 3 개 계층에서 생성 된 바이트 코드는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문입니다.&lt;/a&gt;. 가상 머신 모듈은 SQL 문 바이트 코드를 실행합니다. B-Tree 모듈은 데이터베이스 파일을 정렬 된 키와 로그 성능을 가진 여러 키 / 값 저장소로 구성합니다. 호출기 모듈은 데이터베이스 파일의 페이지를 메모리로로드하고, 트랜잭션을 구현 및 제어하고, 충돌 또는 정전 후 데이터베이스 손상을 방지하는 저널 파일을 작성 및 유지 보수합니다. OS 인터페이스는 다른 운영 체제에서 실행되도록 SQLite를 조정하기위한 공통 루틴 세트를 제공하는 씬 추상화입니다. 대략 4 개의 레이어가 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">인터넷은 점점 적대적인 곳입니다. 오늘날 개발자는 공격자가 응용 프로그램에서 임의의 SQL을 실행할 수있는 방법을 찾을 것이라고 가정해야합니다. 응용 프로그램은 임의의 SQL 실행이보다 심각한 악용으로 확대되지 않도록 설계해야합니다.</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">존재하는 경우 최종 열의 해석은 &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">디스크 동기화를 제어하기위한 Mac OS X의 ioctl은 F_FULLSYNC가 아니라 F_FULLFSYNC입니다. 이전 릴리스에는 문제가있었습니다.</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">eval 메소드의 역할은 두 번째 인수에 제공된 SQL 문을 실행하는 것입니다. 예를 들어, 데이터베이스에서 새 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">이 메소드의 작업은 새 가상 테이블 오브젝트 ( &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 오브젝트)를 구성하고 * ppVTab에 포인터를 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">저널 머리글이 0이 아니고 올바른 형식이며</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">저널 테스트는 크래시 테스트 이상으로 추가적인 이중 점검으로 시스템 충돌 및 전원 장애시 SQLite 트랜잭션이 원 자성인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_mode pragma는 새 저널 모드 인 문자열을 반환합니다. 성공하면 pragma는 문자열 &quot; &lt;code&gt;wal&lt;/code&gt; &quot;을 반환합니다 . WAL 로의 변환을 완료 할 수없는 경우 (예 : &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 가 필요한 공유 메모리 기본 요소를 지원하지 않는 경우 ) 저널링 모드는 변경되지 않고 기본 요소에서 리턴 된 문자열은 이전 저널링 모드입니다 (예 : &quot; &quot;)를 &lt;code&gt;delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma는 트랜잭션 또는 검사 점 이후 파일 시스템에 남아있는 롤백 저널 및 WAL 파일의 크기를 제한하는 데 사용될 수 있습니다. 트랜잭션이 커밋되거나 WAL 파일이 재설정 될 때마다 SQLite는 파일 시스템에 남아있는 롤백 저널 파일 또는 WAL 파일의 크기를이 pragma에서 설정 한 크기 제한과 비교하고 저널 또는 WAL 파일이 더 큰 경우 잘립니다. 한도까지.</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json (X) 함수는 인수 X가 유효한 JSON 문자열인지 확인하고 해당 불필요한 모든 공백을 제거하여 해당 JSON 문자열의 축소 된 버전을 리턴합니다. X가 올바른 형식의 JSON 문자열이 아닌 경우이 루틴은 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1 확장은 (현재) JSON을 일반 텍스트로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1 확장은 (현재) JSON의 이진 인코딩을 지원하지 않습니다. 실험에서 일반 텍스트 인코딩보다 훨씬 작거나 빠른 이진 인코딩을 찾을 수 없습니다. (현재 구현은 JSON 텍스트를 1GB / s 이상으로 구문 분석합니다.) BLOB가 JSON의 바이너리 인코딩을 저장할 향후 향상을 위해 BLOB가 예약되어 있기 때문에 모든 json1 함수는 인수가 BLOB 인 경우 현재 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1 확장은 SQLite 버전 3.9.0 (2015-10-14)에서 도입 된 &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 인터페이스를 사용합니다. json1 확장은 이전 버전의 SQLite에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1 소스 코드는 SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 포함되어 있지만 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; 컴파일 타임 옵션을 추가하여 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 내장 된 json1 확장을 활성화하십시오 . 표준 makefile에는 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 및 일부 테스트 유틸리티를 빌드 할 때 -DSQLITE_ENABLE_JSON1이 포함되므로이 확장은 일반적으로 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array () SQL 함수는 0 개 이상의 인수를 허용하며 해당 인수로 구성된 올바른 형식의 JSON 배열을 리턴합니다. json_array ()에 대한 인수가 BLOB이면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length (X) 함수는 JSON 배열 X의 요소 수를 리턴하거나 X가 배열 이외의 JSON 값인 경우 0을 리턴합니다. json_array_length (X, P)는 X 내의 경로 P에서 배열을 찾아 해당 배열의 길이를 리턴하거나, 경로 P가 요소 또는 JSON 배열 이외의 X를 찾으면 0을, 경로 P가 X. X가 올바른 형식의 JSON이 아니거나 P가 올바른 형식의 경로가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">json_each (X) 및 json_tree (X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 첫 번째 인수로 제공된 JSON 값을 따라 각 요소에 대해 하나의 행을 반환합니다. json_each (X) 함수는 최상위 요소가 기본 값인 경우 최상위 배열 또는 객체의 직계 자식 또는 최상위 요소 자체 만 이동합니다. json_tree (X) 함수는 최상위 요소부터 시작하여 JSON 하위 구조를 반복적으로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each (X, P) 및 json_tree (X, P) 함수는 경로 P로 식별 된 요소를 최상위 요소로 취급한다는 점을 제외하고는 단일 인수 대응 함수와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract (X, P1, P2, ...)는 X에서 올바르게 구성된 JSON에서 하나 이상의 값을 추출하여 리턴합니다. 단일 경로 P1 만 제공되는 경우 결과의 SQL 데이터 유형은 JSON에 대해 NULL입니다. JSON 숫자 값의 경우 null, INTEGER 또는 REAL, JSON false 값의 경우 INTEGER 0, JSON true 값의 INTEGER 값, JSON 문자열 값의 인용 부호가없는 텍스트 및 JSON 객체 및 배열 값의 텍스트 표현 여러 경로 인수 (P1, P2 등)가있는 경우이 루틴은 다양한 값을 보유하는 올바른 형식의 JSON 배열 인 SQLite 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array (X) 함수는 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계&lt;/a&gt; 의 모든 X 값으로 구성된 JSON 배열을 리턴 하는 집계 SQL 함수 입니다. 마찬가지로 json_group_object (NAME, VALUE) 함수는 집계의 모든 NAME / VALUE 쌍으로 구성된 JSON 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert (), json_replace () 및 json_set () 함수는 항상 홀수의 인수를 사용합니다. 첫 번째 인수는 항상 편집 할 원래 JSON입니다. 후속 인수는 각 쌍의 첫 번째 요소가 경로이고 두 번째 요소가 해당 경로에 삽입하거나 바꾸거나 설정할 값인 쌍으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert (), json_replace 및 json_set () 함수는 모두 단일 JSON 값을 첫 번째 인수로 사용하고 0 개 이상의 경로 및 값 인수 쌍을 따르고 경로 / 입력으로 입력 JSON을 업데이트하여 형성된 새 JSON 문자열을 리턴합니다. 값 쌍. 함수는 새 값을 만들고 기존 값을 덮어 쓰는 방법 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object () SQL 함수는 0 개 이상의 인수 쌍을 허용하고 해당 인수로 구성된 올바른 형식의 JSON 오브젝트를 리턴합니다. 각 쌍의 첫 번째 인수는 레이블이고 각 쌍의 두 번째 인수는 값입니다. json_object ()에 대한 인수가 BLOB이면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object () 함수는 현재 불만 사항없이 중복 된 레이블을 허용하지만, 향후 개선에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch (T, P) SQL 함수는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch 알고리즘을 실행하여 입력 T에 대해 패치 P를 적용합니다. 패치 된 T 사본이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote (X) 함수는 SQL 값 X (숫자 또는 문자열)를 해당 JSON 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">json_remove () 함수는 첫 번째 인수의 형식이 잘못된 JSON이거나 이후의 인수가 올바른 형식의 경로가 아니거나 인수가 BLOB 인 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove (X, P, ...) 함수는 단일 JSON 값을 첫 번째 인수로 사용하고 0 개 이상의 경로 인수를 사용합니다. json_remove (X, P, ...) 함수는 경로 인수로 식별 된 모든 요소가 제거 된 X 인 새 JSON 값을 리턴합니다. X에없는 요소를 선택하는 경로는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">json_type () 함수는 인수가 올바르게 구성되지 않았거나 BLOB 인 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type (X) 함수는 X의 가장 바깥 쪽 요소의 &quot;type&quot;을 리턴합니다. json_type (X, P) 함수는 경로 P에 의해 선택된 X에서 요소의 &quot;type&quot;을 리턴합니다. json_type에 의해 리턴 된 &quot;type&quot; ()은 'null', 'true', 'false', 'integer', 'real', 'text', 'array'또는 'object'와 같은 SQL 텍스트 값 중 하나입니다. json_type (X, P)의 경로 P가 X에 존재하지 않는 요소를 선택하면이 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid (X) 함수는 인수 X가 형식이 올바른 JSON이면 1을 리턴하고 인수 X가 형식이 잘못된 JSON이면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">의 핵심 요소</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">요점은 SQLite가 데이터베이스에 넣는 데이터 유형을 매우 용서한다는 것입니다. 예를 들어 열에 데이터 유형이 &quot;INTEGER&quot;이고 응용 프로그램이 해당 열에 텍스트 문자열을 삽입하면 SQLite는 다른 모든 SQL 데이터베이스 엔진과 마찬가지로 먼저 텍스트 문자열을 정수로 변환하려고 시도합니다. 따라서 INTEGER 열에 &lt;b&gt;'1234'&lt;/b&gt; 를 삽입하면 해당 값이 정수 1234로 변환되어 저장됩니다. 그러나 다른 SQL 데이터베이스와 달리 &lt;b&gt;'wxyz'&lt;/b&gt; 와 같은 숫자가 아닌 문자열을 INTEGER 열에 삽입하면 SQLite에서 오류가 발생하지 않습니다. 대신 SQLite는 실제 문자열 값을 열에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">핵심 사항은 다음과 같습니다. CLI 작성은 두 개의 C 언어 파일을 함께 컴파일하는 것으로 구성됩니다. &lt;b&gt;shell.c의&lt;/b&gt; 파일은 진입 점의 정의 및 사용자 입력 루프와 SQLite는 합병에 포함 &lt;b&gt;sqlite3.c는&lt;/b&gt; SQLite는 라이브러리의 완전한 구현이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">이전 예제의 요점은 콜백 명령을 사용하여 콜백 함수를 호출하고 다음 명령을 사용하여 데이터베이스 파일의 모든 레코드에 대해 루프를 구현하는 것입니다. 이 예제는 더 많은 출력 열 (일부는 계산 된 값)과 실제로 어떤 레코드가 콜백 함수로 작성되는지를 제한하는 WHERE 절을 포함하는 약간 더 복잡한 쿼리를 보여줌으로써 이러한 아이디어를 이끌어 내려고 시도합니다. 이 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">각 세그먼트 b- 트리에서 사용되는 키는 용어 (단어)입니다. 키뿐만 아니라 각 세그먼트 b- 트리 항목에는 연관된 &quot;doclist&quot;(문서 목록)가 있습니다. doclist는 0 개 이상의 항목으로 구성되며 각 항목은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">키워드 &quot;INSERT&quot;, &quot;UPDATE&quot;또는 &quot;DELETE&quot;</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtest 프로그램은 다음과 같이 Android에서 컴파일되고 실행됩니다. 먼저 Android SDK 및 NDK를 설치하십시오. 그런 다음 대략 &quot;android-gcc&quot;라는 스크립트를 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">SELECT의 컬럼 목록에서 AS 오른쪽에있는 레이블을 WHERE, ORDER BY, GROUP BY 및 / 또는 HAVING 절에서 표현식의 일부로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">이 항목의 언어 ID입니다.</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid 옵션을 사용하면 FTS4 테이블에 각 행에 포함 된 텍스트의 언어를 식별하는 숨겨진 정수 열이 추가로 생깁니다. languageid 옵션을 사용하면 동일한 FTS4 테이블이 각각 다른 토크 나이저 규칙이있는 여러 언어 또는 스크립트로 텍스트를 보유하고 각 언어를 서로 독립적으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT의 가능한 최대 설정은 2147483646입니다. 최대 페이지 크기 65536과 함께 사용하면 약 140 테라 바이트의 최대 SQLite 데이터베이스 크기가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">위의 마지막 (4 번째) 글 머리 기호에 추가 설명이 있습니다. SQLite는 Unix에서 저널 파일을 작성할 때 디렉토리 정보를 디스크로 푸시하기 위해 해당 파일이 포함 된 디렉토리를 열고 디렉토리에서 fsync ()를 호출합니다. 그러나 정전 과정에서 데이터베이스 및 저널이 포함 된 디렉토리에 관련없는 파일을 추가하거나 제거하는 다른 프로세스가 있다고 가정합니다. 이 다른 프로세스의 관련없는 동작으로 인해 저널 파일이 디렉토리에서 삭제되고 &quot;손실 + 발견&quot;으로 이동 될 수 있습니다. 이것은 가능성이 적은 시나리오이지만 발생할 수 있습니다. 최선의 방어 방법은 저널링 파일 시스템을 사용하거나 데이터베이스와 저널을 자체 디렉토리에 보관하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">위의 마지막 글 머리 기호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">마지막 출력 모드는 &quot;html&quot;입니다. 이 모드에서 sqlite3는 쿼리 결과를 XHTML 테이블로 씁니다. 시작 &amp;lt;TABLE&amp;gt; 및 끝 &amp;lt;/ TABLE&amp;gt;은 쓰지 않지만 모든 개입 &amp;lt;TR&amp;gt;, &amp;lt;TH&amp;gt; 및 &amp;lt;TD&amp;gt;입니다. html 출력 모드는 CGI에 유용한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 루틴에 대한 마지막 매개 변수 는 SQLite가 완료되면 P 포인터를 처리하는 데 사용되는 프로 시저에 대한 포인터입니다. 이 포인터는 NULL 일 수 있으며이 경우 소멸자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">커밋 프로세스의 마지막 단계는 다른 프로세스가 데이터베이스 파일에 다시 액세스 할 수 있도록 배타적 잠금을 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">마지막으로 시작된 트랜잭션은 커밋되거나 롤백 된 첫 번째 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">마지막 두 개의 할당 제어 및 / 또는 구성에 의해 제거 될 수있는 &lt;a href=&quot;malloc#pagecache&quot;&gt;페이지 캐시 메모리를 할당&lt;/a&gt; 하고, &lt;a href=&quot;malloc#lookaside&quot;&gt;룩어 메모리 할당&lt;/a&gt; 한 바와 같이, 적절. &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트에 필요한 스토리지 공간 은 데이터베이스 파일의 파일 이름 길이에 따라 다르지만 32 비트 시스템에서는 2KB를 거의 초과하지 않습니다. 포인터 크기가 증가하여 64 비트 시스템에 더 많은 공간이 필요합니다. 각 파서 개체는 약 1.6KB의 메모리를 사용합니다. 따라서, 최대 메모리 할당 크기를 2KB 미만으로 유지하기 위해 상기 요소 3 내지 7을 쉽게 제어 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">이 예에서 마지막 두 쿼리는 같은 시간이 걸립니다. 그렇다면 SQLite는 어떤 인덱스, Idx1 또는 Idx2를 선택합니까? 경우 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령이 데이터베이스에서 실행 된, 그래서 SQLite는 사용 가능한 인덱스에 대한 통계를 수집 할 수있는 기회를 갖고 있음을, 다음 SQLite는이 IDX1 인덱스는 일반적으로는 단일 항목 (과일의 예제까지 검색 좁아 것을 알 = ' 주황색 '은이 규칙의 예외입니다.) 반면 Idx2 인덱스는 일반적으로 검색을 두 행으로 좁 힙니다. 따라서 다른 모든 것이 동일하면 SQLite는 가능한 한 적은 수의 행으로 검색 범위를 좁히기 위해 Idx1을 선택합니다. 이 선택은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE에서&lt;/a&gt; 제공 한 통계 때문에 가능합니다 . &lt;a href=&quot;lang_analyze&quot;&gt;분석하는&lt;/a&gt; 경우 실행되지 않은 경우 사용할 인덱스 선택은 임의적입니다.</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid () 함수는 함수 를 호출 한 데이터베이스 연결에서 마지막 행 삽입 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 리턴합니다 . last_insert_rowid () SQL 함수는 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; C / C ++ 인터페이스 함수 주위의 랩퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">최신 점검 목록에는 각 릴리스마다 개별적으로 확인되는 약 200 개의 항목이 포함되어 있습니다. 일부 점검 목록 항목은 확인하고 마크 오프하는 데 몇 초 밖에 걸리지 않습니다. 다른 것들은 몇 시간 동안 실행되는 테스트 스위트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">후자의 쿼리는 테이블에 b = 456 인 행이있을 수 있고 여기서 c는 NULL이므로 부분 인덱스를 사용할 수 없습니다. 그러나 해당 행은 부분 인덱스에 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">&quot;% _content&quot;테이블의 가장 왼쪽 열은 &quot;docid&quot;라는 INTEGER PRIMARY KEY 필드입니다. 다음은 사용자가 선언 한 FTS 가상 테이블의 각 열에 대해 하나의 열이며, 사용자가 제공 한 열 이름 앞에 &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">레거시 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 컴파일 타임 옵션이 이제 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">레거시 alter table 동작은 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; 옵션을 사용하여 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스 로 전환하거나 토글 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">레거시 xGeom 콜백은 4 개의 인수로 호출됩니다. 첫 번째 인수는 sqlite3_rtree_geometry 구조에 대한 포인터이며 SQL 함수 호출 방법에 대한 정보를 제공합니다. 두 번째 인수는 각 r- 트리 항목의 좌표 수이며 주어진 R * Tree에 대해 항상 동일합니다. 좌표의 수는 1 차원 R * Tree의 경우 2, 2 차원 R * Tree의 경우 4, 3 차원 R * Tree의 경우 6 등입니다. 세 번째 인수 인 aCoord []는 테스트 할 경계 상자를 정의하는 nCoord 좌표의 배열입니다. 마지막 인수는 콜백 결과를 작성해야하는 포인터입니다. aCoord []에 의해 정의 된 경계 상자가 xGeom 콜백에 의해 정의 된 영역 밖에 완전히 있으면 결과는 0이고, 경계 상자가 xGeom 영역 내에 있거나 겹치는 경우 결과는 0이 아닙니다.xGeom 콜백은 일반적으로 SQLITE_OK를 반환해야합니다. xGeom이 SQLITE_OK 이외의 것을 반환하면 r- 트리 쿼리가 오류와 함께 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">최신 파일 형식의 기존 데이터베이스를 처음 열면 legacy_file_format pragma가 OFF로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">기능 이름의 길이는 255자를 초과 할 수 없습니다. 이름이 255자를 초과하는 함수를 만들려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">인수 값의 길이는 대체 유형 문자 직전에 발생하는 하나 이상의 문자로 지정할 수 있습니다. SQLite에서 길이는 정수 유형에만 중요합니다. 항상 64 비트 값을 사용 하는 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf () SQL 함수&lt;/a&gt; 의 길이는 무시 됩니다. 다음 표는 SQLite가 허용하는 길이 지정자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">스페인어에서 &quot;h&quot;와 같이 발음 된 &quot;j&quot;: LaJolla</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">--enable-utf8 옵션을 구성하도록 지정하면 라이브러리는 이제 데이터가 UTF-8로 저장되어 있다고 가정합니다. 기본 동작은 항상했던 것처럼 iso8859-x로 가정하는 것입니다. 이는 LIKE 및 GLOB 연산자와 LENGTH 및 SUBSTR 함수에만 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">준비된 명령문 오브젝트의 수명주기는 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_str 객체의 수명주기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like () 함수는 &quot; &lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt; &quot;표현식 을 구현하는 데 사용됩니다 . 선택적 ESCAPE 절이 존재하면 like () 함수가 세 개의 인수와 함께 호출됩니다. 그렇지 않으면 두 개의 인수 만 사용하여 호출됩니다. X 및 Y 매개 변수는 infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자를 기준으로 like () 함수에서 반전됩니다 . X는 패턴이고 Y는 해당 패턴과 일치하는 문자열입니다. 따라서 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">likelihood (X, Y) 함수는 변경되지 않은 인수 X를 리턴합니다. 우도 (X, Y)의 Y 값은 0.0에서 1.0 사이의 부동 소수점 상수 여야합니다. likelihood (X) 함수는 코드 생성기가 최적화되어 런타임 중에 (즉, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 호출하는 동안) CPU주기를 소비하지 않도록 최적화 합니다. likelihood (X, Y) 함수의 목적은 쿼리 플래너에 인수 X가 대략 Y의 확률로 참인 부울이라는 힌트를 제공하는 것입니다. 가능성이 거의 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;없는 (X)&lt;/a&gt; 함수는 가능성의 단축 ( X, 0.0625). &lt;a href=&quot;lang_corefunc#likely&quot;&gt;가능성 (X)&lt;/a&gt; 함수는 우도에 대한 쇼트 핸드 (X, 0.9375)에있다.</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">likely (X) 함수는 변경되지 않은 인수 X를 반환합니다. possible (X) 함수는 코드 생성기가 최적화하여 런타임에 (즉, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 호출하는 동안) CPU 사이클을 소비하지 않도록 최적화 합니다. possible (X) 함수의 목적은 쿼리 플래너에 인수 X가 일반적으로 참인 부울 값이라는 힌트를 제공하는 것입니다. 가능성 (X) 함수는 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성&lt;/a&gt; (X, 0.9375)과 같습니다. &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely (X)&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">선 &quot;.once</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">아래 목록은 완전한 것이 아닙니다. 다른 가상 테이블 구현은 SQLite 소스 트리 및 다른 곳에 존재합니다. 아래 목록은 더 흥미로운 가상 테이블 구현을 캡처하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">아래 목록은 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션에&lt;/a&gt; 관계없이 모든 SQLite 빌드에서 사용 가능한 모든 키워드를 보여줍니다 . 가장 합리적인 구성은 이러한 키워드의 대부분 또는 전부를 사용하지만 SQL 언어 기능이 비활성화 된 경우 일부 키워드를 생략 할 수 있습니다. 애플리케이션은 &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count ()&lt;/a&gt; , &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check ()&lt;/a&gt; 인터페이스를 사용하여 런타임시 SQLite가 인식하는 키워드를 판별 할 수 있습니다. 컴파일 타임 구성에 관계없이 다음 143 요소 목록에없는 식별자는 SQLite의 SQL 파서에 대한 키워드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">이진 형식의 좌표 목록에는 중복성이 없습니다. 마지막 좌표는 GeoJSON과 마찬가지로 첫 번째 좌표의 반복이 아닙니다. 따라서 GeoJSON 표현과 비교하여 다각형의 이진 표현에는 좌표 쌍이 항상 하나 더 적습니다.</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECT 키워드와 FROM 키워드 사이의 표현식 목록을 결과 표현식 목록이라고합니다. 결과 표현식이 특수 표현식 &quot;*&quot;인 경우 입력 데이터의 모든 열이 해당 표현식으로 대체됩니다. 표현식이 FROM 절에서 테이블 또는 서브 쿼리의 별명이고 그 뒤에 &quot;. *&quot;가 있으면 명명 된 테이블 또는 서브 쿼리의 모든 컬럼이 단일 표현식으로 대체됩니다. 결과 표현식 목록 이외의 컨텍스트에서 &quot;*&quot;또는 &quot;alias. *&quot;표현식을 사용하면 오류가 발생합니다. FROM 절이없는 간단한 SELECT 쿼리에서 &quot;*&quot;또는 &quot;alias. *&quot;식을 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">stat 열의 정수 목록 다음에는 선택적으로 인수가 올 수 있으며 각 인수는 공백이 아닌 문자 시퀀스입니다. 모든 인수는 단일 공백으로 시작합니다. 인식 할 수없는 인수는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">확장 프로그램이 SQL 함수 또는 조합 순서를 수정 또는 삭제하려고 시도하면 load_extension () 함수가 실패합니다. 확장은 새 함수 또는 조합 순서를 추가 할 수 있지만 기존 함수 또는 조합 순서는 현재 실행중인 SQL 문의 다른 곳에서 사용될 수 있으므로 기존 함수 또는 조합 순서를 수정하거나 삭제할 수 없습니다. 함수 또는 조합 순서를 변경 또는 삭제하는 확장을로드하려면 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C 언어 API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension (X, Y) 함수 는 진입 점 Y를 사용하여 X라는 공유 라이브러리 파일에서 &lt;a href=&quot;loadext&quot;&gt;SQLite 확장명&lt;/a&gt; 을 로드 합니다. load_extension ()의 결과는 항상 NULL입니다. Y를 생략하면 기본 진입 점 이름이 사용됩니다. 확장 프로그램이 올바르게로드되지 않거나 초기화되지 않으면 load_extension () 함수에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">원격 헤드의 로컬 사본</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">로컬 헤드</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">잠금 바이트 페이지</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">잠금 바이트 페이지는이 파일 형식이 설계되었을 때 주요 운영 체제였으며 필수 파일 잠금 만 지원하는 Win95를 지원해야 할 필요성에서 생겨났습니다. 우리가 아는 모든 최신 운영 체제는 권고 파일 잠금을 지원하므로 잠금 바이트 페이지는 더 이상 필요하지 않지만 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">잠금 바이트 페이지는 데이터베이스 파일 잠금 기본을 구현할 때 운영 체제 별 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현에서 사용하기 위해 따로 설정 됩니다. SQLite는 잠금 바이트 페이지를 사용하지 않습니다. SQLite 코어는 잠금 바이트 페이지를 읽거나 쓰지 않지만 운영 체제 별 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현은 기본 시스템의 요구 및 절차에 따라 잠금 바이트 페이지에서 바이트를 읽거나 쓰도록 선택할 수 있습니다. SQLite에 내장 된 unix 및 win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현은 잠금 바이트 페이지에 쓰지 않지만 다른 운영 체제에 대한 타사 VFS 구현은 가능합니다.</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">잠금 바이트 페이지는 1073741824와 1073742335 사이의 오프셋에 바이트를 포함하는 데이터베이스 파일의 단일 페이지입니다. 크기가 1073741824 바이트 이하인 데이터베이스 파일에는 잠금 바이트 페이지가 없습니다. 1073741824보다 큰 데이터베이스 파일에는 정확히 하나의 잠금 바이트 페이지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">논리는 다음과 같이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">논리 데이터베이스 크기는 이제 데이터베이스 헤더에 저장되어 바이트를 손상시키지 않고 데이터베이스 파일의 끝에 바이트를 추가 할 수 있으며 SQLite는 ftruncate ()를 지원하지 않는 시스템에서 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">lookaside 구성은 데이터베이스 연결에 미해결 lookaside 할당이없는 동안에 만 변경할 수 있습니다. 따라서 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()을&lt;/a&gt; 사용하여 데이터베이스 연결을 작성한 직후 와 연결에서 SQL 문을 평가하기 전에 구성을 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">lookaside 메모리 할당자는 실제로 고장없는 메모리 할당을 보장하기위한 방법이 아니라 성능 최적화를위한 것이므로 안전에 중요한 작업을 위해 lookaside 메모리 할당기를 완전히 비활성화하는 것은 부당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">다음 호출을 사용하여 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; &quot;db&quot;에 대해 lookaside 풀을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">루프는 11에서 &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; 명령으로 시작 하여 인덱스 키 사본을 스택으로 다시 푸시합니다. 12 의 명령 &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; 는 키를 커서 P1이 가리키는 현재 인덱스 레코드의 키와 비교합니다. 현재 커서 위치의 색인 키가 찾고있는 색인보다 큰 경우 루프에서 뛰어 내립니다.</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower (X) 함수는 모든 ASCII 문자가 소문자로 변환 된 문자열 X의 사본을 리턴합니다. 기본 내장 lower () 함수는 ASCII 문자에서만 작동합니다. 비 ASCII 문자에서 케이스 변환을 수행하려면 ICU 확장을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim (X, Y) 함수는 X의 왼쪽에서 Y에 나타나는 모든 문자를 제거하여 형성된 문자열을 반환합니다. Y 인수가 생략되면 ltrim (X)는 X의 왼쪽에서 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">이 섹션의 매크로에는 값이 필요하지 않습니다. 다음 컴파일 스위치는 모두 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">기본 데이터베이스 파일은 하나 이상의 페이지로 구성됩니다. 페이지 크기는 512에서 65536 사이의 2의 거듭 제곱입니다. 동일한 데이터베이스 내의 모든 페이지는 동일한 크기입니다. 데이터베이스 파일의 페이지 크기는 데이터베이스 파일의 시작 부분에서 16 바이트 오프셋에있는 2 바이트 정수로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">임의의 이름이 &quot;X&quot;인 기본 데이터베이스 파일</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">위의 기본 표현식 버블 다이어그램은 모든 함수 호출에 대한 단일 구문을 보여줍니다. 그러나 이것은 단지 버블 표현 다이어그램을 단순화하기위한 것입니다. 실제로 각 유형의 함수는 아래와 같이 약간 다른 구문을 가지고 있습니다. 기본 표현식 버블 다이어그램에 표시된 함수 호출 구문은 다음에 표시된 세 가지 구문의 결합입니다.</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; 의 기본 시스템은 대부분의 사람들이 사용하는 기본 서버입니다. 다른 두 가지는 백업으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 의 주요 결과는 문자열에 대한 포인터 배열입니다. 이 배열에는 결과에서 각 행의 각 열마다 하나의 요소가 있습니다. NULL 결과는 NULL 포인터로 표시됩니다. 일반 데이터 외에도 배열의 시작 부분에 결과의 각 열 이름이 포함 된 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite 코어가 가상 테이블과 통신하려는 주된 것은 검색해야 할 행 수를 제한하는 데 사용할 수있는 제약 조건입니다. aConstraint [] 배열에는 각 제약 조건마다 하나의 항목이 포함됩니다. 해당 배열에는 정확히 nConstraint 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">문서를 생성하는 데 사용 된 makefile 및 스크립트는 문서 소스 저장소의 기본 문서에서 텍스트를 수집합니다. SQLite 소스 코드의 주석에서 추가 텍스트가 추출됩니다. 요구 사항 적용 범위 정보는 소스 저장소의 일부인 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트&lt;/a&gt; 의 특수 주석 및 별도의 개인 저장소 인 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 테스트 스위트의 주석에서 추출 됩니다.</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLite 용 makefile에는 &quot;아말감 화&quot;라는 파일을 빌드하기위한 &quot;sqlite3.c&quot;대상이 있습니다. 합병은 핵심 SQLite 라이브러리와 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; , &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; , &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt; , &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt; 및 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장에 대한 모든 C 코드를 포함하는 &quot;sqlite3.c&quot;라는 단일 C 코드 파일 입니다. 이 파일에는 약 184K 줄의 코드 (빈 줄과 주석을 생략하면 113K)가 있으며 크기는 6.4MB 이상입니다. 다양한 확장이 &quot;sqlite3.c&quot;통합 파일에 포함되어 있지만 #ifdef 문을 사용하여 비활성화됩니다. 다음 과 같은 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션을&lt;/a&gt; 사용하여 확장을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite가 임시 파일을 사용하는 방식은 SQLite가 응용 프로그램과 맺는 계약의 일부로 간주되지 않습니다. 이 문서의 정보는이 문서를 작성하거나 마지막으로 업데이트 할 당시 SQLite의 작동 방식에 대한 정확한 설명입니다. 그러나 이후 버전의 SQLite가 동일한 방식으로 임시 파일을 사용할 것이라는 보장은 없습니다. 새로운 종류의 임시 파일이 채택 될 수 있으며 현재 임시 파일 사용 중 일부는 향후 SQLite 릴리스에서 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">문자에서 선호도로의 맵핑은 sqliteInt.h에 정의 된 SQLITE_AFF_ 매크로에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">마스터 저널 파일은 둘 이상의 데이터베이스가 다음 요구 사항을 모두 충족하는 여러 데이터베이스 파일을 포함하는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 조작에 대해서만 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">마스터 저널 파일은 단일 트랜잭션이 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가 된 여러 데이터베이스를 변경할 때 원자 커밋 프로세스의 일부로 사용됩니다 . 마스터 저널 파일은 항상 기본 데이터베이스 파일과 동일한 디렉토리에 있습니다 (주 데이터베이스 파일은 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 작성한 원래 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출 에서 식별 된 데이터베이스입니다 ))에 임의의 접미사가 붙습니다. 마스터 저널 파일에는 트랜잭션 중에 변경된 다양한 첨부 된 보조 데이터베이스의 이름이 포함됩니다. 마스터 저널 파일이 삭제되면 다중 데이터베이스 트랜잭션이 커미트됩니다. 자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">matchinfo 'b'플래그는 &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y'플래그&lt;/a&gt; 와 유사한 정보를 제공 하지만보다 간단한 형식입니다. 정확한 적중 횟수 대신 'b'는 각 구 / 열 조합에 대해 단일 부울 플래그를 제공합니다. 문구가 열에 적어도 한 번 존재하면 (즉, 'y'의 해당 정수 출력이 0이 아닌 경우) 해당 플래그가 설정됩니다. 그렇지 않으면 지워집니다.</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">matchinfo 함수는 하나 또는 두 개의 인수로 호출됩니다. 모든 보조 기능의 경우 첫 번째 인수는 특수 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열&lt;/a&gt; 이어야합니다 . 두 번째 인수 (지정된 경우)는 문자 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y'만으로 구성된 텍스트 값이어야합니다. 그리고 'b'. 두 번째 인수가 명시 적으로 제공되지 않으면 기본값은 &quot;pcx&quot;입니다. 두 번째 인수는 아래 &quot;포맷 문자열&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 함수는 스 니펫 또는 오프셋 함수보다 훨씬 빠릅니다. 디스크에서 분석되는 문서를 검색하려면 스 니펫과 오프셋을 모두 구현해야하지만 matchinfo에 필요한 모든 데이터는 전체 텍스트를 구현하는 데 필요한 전체 텍스트 인덱스의 동일한 부분의 일부로 사용할 수 있기 때문입니다. 쿼리 자체. 이는 다음 두 쿼리 중 첫 번째 쿼리가 두 번째 쿼리보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo 함수는 전체 텍스트 검색 응용 프로그램에서 결과를 주문하는 데 사용될 수있는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt; 와 같은 확률 &quot;단어&quot;관련 점수를 계산하는 데 필요한 모든 정보를 제공합니다 . 이 문서의 부록 A &quot; &lt;a href=&quot;fts3#appendix_a&quot;&gt;검색 응용 프로그램 팁&lt;/a&gt; &quot;에는 matchinfo () 함수를 효율적으로 사용하는 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo 함수는 블롭 값을 반환합니다. 전체 텍스트 인덱스 ( &quot;query by rowid&quot;또는 &quot;linear scan&quot;)를 사용하지 않는 쿼리 내에서 사용되는 경우 BLOB의 크기는 0 바이트입니다. 그렇지 않으면, blob은 기계 바이트 순서로 0 개 이상의 32 비트 부호없는 정수로 구성됩니다. 반환 된 배열의 정확한 정수 수는 쿼리와 matchinfo 함수에 전달 된 두 번째 인수의 값 (있는 경우)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfo 옵션은 &quot;fts3&quot;값으로 만 설정할 수 있습니다. &quot;fts3&quot;이외의 것으로 matchinfo를 설정하려고하면 오류가 발생합니다. 이 옵션을 지정하면 FTS4에 저장된 일부 추가 정보가 생략됩니다. 이는 FTS4 테이블에서 사용하는 디스크 공간과 거의 동일 할 때까지 FTS4 테이블에서 사용하는 디스크 공간을 줄이지 만 'l'플래그를 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 에 전달하여 액세스 한 데이터를 의미합니다. 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">아래 매트릭스는 개별 파일에 저장된 BLOB를 읽는 데 필요한 시간을 데이터베이스에 완전히 저장된 BLOB를 읽는 데 필요한 시간으로 나눈 값을 보여줍니다. 따라서 1.0보다 큰 숫자의 경우 BLOB를 데이터베이스에 직접 저장하는 것이 더 빠릅니다. 1.0보다 작은 숫자의 경우 BLOB를 별도의 파일에 저장하는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max () 집계 함수는 그룹에있는 모든 값의 최대 값을 반환합니다. 최대 값은 동일한 열의 ORDER BY에서 마지막으로 리턴되는 값입니다. 집계 max ()는 그룹에 NULL이 아닌 값이없는 경우에만 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">'automerge'매개 변수에 허용되는 최대 값은 16입니다. 기본값은 4입니다. 'automerge'매개 변수를 0으로 설정하면 b- 트리의 자동 증분 병합이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">응용 프로그램에 필요한 범용 메모리의 최대 금액은 많은 동시 공개 방법 등의 요인에 의해 결정되는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문은&lt;/a&gt; 응용 프로그램에서 사용하는 오브젝트와의 복잡성에 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; . 주어진 응용 프로그램에 대해 이러한 요소는 일반적으로 고정되어 있으며 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED를&lt;/a&gt; 사용하여 실험적으로 확인할 수 있습니다 . 일반적인 응용 프로그램은 약 40KB의 범용 메모리 만 사용할 수 있습니다. &lt;b&gt;N&lt;/b&gt; 의 값 은 약 100KB입니다.</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">최대 및 최소 내장 페이로드 비율과 리프 페이로드 비율 값은 64, 32 및 32 여야합니다.이 값은 원래 b- 트리 알고리즘의 스토리지 형식을 수정하는 데 사용할 수있는 조정 가능한 매개 변수로 사용되었습니다. 그러나이 기능은 지원되지 않으며 향후 지원을 추가 할 계획이 없습니다. 따라서이 3 바이트는 지정된 값으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">SQLITE_MAX_EXPR_DEPTH가 처음에 양수인 경우 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; , size) 인터페이스를 사용하여 런타임에 표현식 트리의 최대 깊이를 낮출 수 있습니다 . 즉, 식 깊이에 이미 컴파일 시간 제한이있는 경우 런타임에 최대 식 깊이를 낮출 수 있습니다. 컴파일시 SQLITE_MAX_EXPR_DEPTH가 0으로 설정되면 (표현 깊이가 무제한 인 경우) &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; , size)는 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">트리거의 최대 재귀 깊이.</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">모든 표현식에서 구문 분석 트리의 최대 깊이입니다.</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; , size) 인터페이스를 사용하여 런타임시 최대 호스트 매개 변수 번호를 낮출 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL 문에서 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 최대 색인 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL 문에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 최대 색인 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt; , size) 인터페이스를 사용하여 LIKE 또는 GLOB 패턴의 최대 길이를 런타임에 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt; , size) 인터페이스를 사용하여 런타임시 SQL 문의 최대 길이를 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">SQL 문의 최대 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 에 대한 패턴 인수의 최대 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 에 대한 패턴 인수의 최대 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;연결된 데이터베이스&lt;/a&gt; 의 최대 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;연결된 데이터베이스&lt;/a&gt; 의 최대 수입니다 .</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">함수에서 최대 인수 수는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt; SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; , size) 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">함수의 최대 인수 수입니다.</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED를&lt;/a&gt; 사용하여 런타임에 접속 된 최대 데이터베이스 수를 줄일 수 있습니다. , size) 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">단일 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비 명령문이 준비한&lt;/a&gt; 최대 보조 작업자 스레드 수 이 시작할 수입니다.</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">단일 &lt;a href=&quot;stmt&quot;&gt;준비 명령문이 준비한&lt;/a&gt; 최대 보조 작업자 스레드 수 이 시작할 수입니다.</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">문자열의 최대 바이트 수 또는 SQLite의 BLOB는 전 처리기 매크로 SQLITE_MAX_LENGTH에 의해 정의됩니다. 이 매크로의 기본값은 10 억 (1,000 만 또는 1,000,000,000)입니다. 다음과 같은 명령 행 옵션을 사용하여 컴파일 타임에이 값을 올리거나 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL 문 텍스트의 최대 바이트 수는 SQLITE_MAX_SQL_LENGTH로 제한되며 기본값은 1000000입니다.이 한계를 SQLITE_MAX_LENGTH 및 1073741824보다 작게 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN을&lt;/a&gt; 사용하여 런타임시 최대 열 수를 줄일 수 있습니다. , size) 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">테이블 정의 또는 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 결과 세트의 최대 열 수최대 열 수 또는 인덱스 또는 ORDER BY 또는 GROUP BY 절의 최대 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">테이블 정의 또는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 결과 세트의 최대 열 수 또는 인덱스 또는 ORDER BY 또는 GROUP BY 절의 최대 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt; , size) 인터페이스를 사용하여 런타임시 복합 SELECT 용어의 최대 수를 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQL 문을 구현하는 데 사용되는 가상 머신 프로그램의 최대 명령어 수입니다. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 () 인&lt;/a&gt; 경우 또는 동등한 시도가 하나의 준비된 명령문이 많은 옵 코드보다 더 많은 공간을 할당하기 위해, SQLITE_NOMEM 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQL 문을 구현하는 데 사용되는 가상 머신 프로그램의 최대 명령어 수입니다. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 () 인&lt;/a&gt; 경우 또는 동등한 시도가 하나의 준비된 명령문이 많은 옵 코드보다 더 많은 공간을 할당하기 위해, SQLITE_NOMEM 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">복합 SELECT 문의 최대 용어 수입니다.</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">반환 된 텍스트의 최대 토큰 수입니다. 0보다 크고 64보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">최대 매개 변수 번호는 컴파일시 &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; 매크로에 의해 설정됩니다 . 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; , ...) 인터페이스를 사용하여 최대 매개 변수 수를 컴파일 시간 최대 값 아래로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">문자열 또는 BLOB 또는 테이블 행의 최대 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH를&lt;/a&gt; 사용하여 런타임시 최대 문자열 또는 BLOB 길이를 줄일 수 있습니다. , size) 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">모든 $ nResCode 결과 코드 값의 의미는 아래에 숫자 순서로 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">이러한 다양한 반환 값의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">이 기사의 측정은 2017-06-05 주 동안 3.19.2에서 3.20.0 사이의 SQLite 버전을 사용하여 수행되었습니다. 향후 버전의 SQLite가 더 나은 성능을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">메모리 &lt;a href=&quot;mmap&quot;&gt;매핑 된 I / O를&lt;/a&gt; 사용할 때 메모리 손상 문제가 더욱 심각해집니다 . 데이터베이스 파일의 일부 또는 전부가 응용 프로그램의 주소 공간에 맵핑 될 때, 해당 맵핑 된 공간의 일부를 겹쳐 쓰는 스트레이 포인터는 응용 프로그램이 후속 write () 시스템 호출을 수행하지 않아도 데이터베이스 파일을 즉시 손상시킵니다.</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">현재 디스플레이와 관련된 내용 만로드하고 대부분의 내용을 디스크에 유지함으로써 응용 프로그램의 메모리 공간을 크게 줄일 수 있습니다. SQLite의 빠른 쿼리 기능으로 인해 모든 콘텐츠를 항상 메모리에 보관할 수 있습니다. 또한 응용 프로그램이 적은 메모리를 사용하면 전체 컴퓨터의 응답 성이 향상되어 사용자 경험이 더욱 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">메모리 하이 워터 마크의 현재 값으로 리셋된다 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;() sqlite3_memory_used&lt;/a&gt; 경우와의 파라미터에만 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()가&lt;/a&gt; 그러하다. &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater (1)에&lt;/a&gt; 의해 반환 된 값 은 재설정 전 최고 사용 표시 점입니다.</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">메모리 하이 워터 마크의 현재 값으로 리셋된다 &lt;a href=&quot;memory_highwater&quot;&gt;() sqlite3_memory_used&lt;/a&gt; 경우와의 파라미터에만 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()가&lt;/a&gt; 그러하다. &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater (1)에&lt;/a&gt; 의해 반환 된 값 은 재설정 전 최고 사용 표시 점입니다.</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">선언 유형 및 조합 순서에 대해 리턴 된 문자 포인터가 가리키는 메모리는 다음 SQLite API 함수를 호출 할 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc (), sqlite3_realloc (), sqlite3_malloc64 () 및 sqlite3_realloc64 ()에 의해 리턴 된 메모리는 &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; 컴파일 시간 옵션이 사용되는 경우 항상 최소 8 바이트 경계 또는 4 바이트 경계에 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc (), sqlite3_realloc (), sqlite3_malloc64 () 및 sqlite3_realloc64 ()에 의해 리턴 된 메모리는 &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; 컴파일 시간 옵션이 사용되는 경우 항상 최소 8 바이트 경계 또는 4 바이트 경계에 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5 할당 기는 내장 시스템에서 사용하도록 설계되었지만 워크 스테이션에서 사용을 막을 수있는 것은 없습니다. szBuf는 일반적으로 시스템 요구 사항 및 메모리 예산에 따라 수백 킬로바이트에서 수십 메가 바이트 사이입니다.</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min () 집계 함수는 그룹에있는 모든 값의 NULL이 아닌 최소값을 반환합니다. 최소값은 열의 ORDER BY에 나타나는 NULL이 아닌 첫 번째 값입니다. 집계 min ()은 그룹에 NULL이 아닌 값이없는 경우에만 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">최소값 / 최대 값 쌍 열은 &quot;rtree&quot;가상 테이블의 32 비트 부동 소수점 값 또는 &quot;rtree_i32&quot;가상 테이블의 32 비트 부호있는 정수로 저장됩니다. 다양한 데이터 유형 및 형식으로 데이터를 저장할 수있는 일반 SQLite 테이블과 달리 R * Tree는 이러한 스토리지 유형을 엄격하게 시행합니다. 다른 유형의 값이 이러한 열에 삽입되면 r- 트리 모듈은 새 레코드를 데이터베이스에 기록하기 전에 필요한 유형으로 자동 변환합니다.</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">최소 &quot;3 + 4&quot;값</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite 데이터베이스의 최소 크기는 각 테이블과 각 인덱스에 대해 한 페이지입니다. 페이지 크기가 클수록 주어진 스키마에 대한 빈 데이터베이스의 크기가 4 배 증가합니다. 그러나 데이터베이스가 내용으로 채워지기 시작하면 이전 1024 바이트 페이지 데이터베이스와 최신 4096 바이트 페이지 데이터베이스의 크기가 빠르게 수렴됩니다. 빈 포장 제약 조건이 완화 되었기 때문에 4096 바이트 페이지 크기는 실제 내용이 추가되면 파일 크기가 작아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">마이너 버전 번호 Y는 코드 구조를 크게 변경하지 않은 새로운 기능 및 / 또는 새로운 인터페이스에 대해 역사적으로 증가했습니다. 의 추가 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; , &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 및 &lt;a href=&quot;expridx&quot;&gt;표현의 인덱스&lt;/a&gt; &quot;사소한&quot;변경의 예입니다. &quot;주&quot;와 &quot;주&quot;의 구별은 주관적입니다.</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">미러는 SQLite 에 대한 &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;표준 Fossil 저장소&lt;/a&gt; 의 증분 내보내기입니다 . 크론 작업은 한 시간에 한 번씩 GitHub 리포지토리를 업데이트합니다. 이것은 단방향 읽기 전용 코드 미러입니다. GitHub를 통해 풀 요청 또는 변경이 허용되지 않습니다. GitHub 저장소는 단지 Fossil 저장소의 컨텐츠를 복사합니다. 모든 변경 사항은 화석을 통해 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">mmap_size는 &quot; &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; &quot;문을 사용하여 각 데이터베이스 파일에 대해 별도로 설정됩니다 . 일반적인 기본 mmap_size는 0이며, 메모리 매핑 I / O는 기본적으로 비활성화되어 있습니다. 그러나 디폴트 mmap_size는 &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; 매크로를 사용하여 컴파일시 또는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE를&lt;/a&gt; 사용하여 시작 시)에서 증가 될 수 있습니다. , ...) 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">mode query 매개 변수는 새 데이터베이스가 읽기 전용으로 열려 있는지, 읽기-쓰기, 읽기-쓰기로되어 있는지, 존재하지 않는 경우에 작성되는지 또는 데이터베이스가 각각 디스크와 상호 작용하지 않는 순수한 인 메모리 데이터베이스인지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">UPDATE 문의 영향을받는 각 행의 수정 사항은 SET 키워드 다음의 지정 목록에 의해 결정됩니다. 각 할당은 등호 왼쪽에 열 이름을 지정하고 오른쪽에 스칼라 식을 지정합니다. 영향을받는 각 행에 대해 명명 된 열은 해당 스칼라 식을 평가하여 찾은 값으로 설정됩니다. 할당 표현식 목록에 단일 column-name이 두 번 이상 나타나면 가장 오른쪽에 나오는 것을 제외한 모든 것이 무시됩니다. 배정 목록에 나타나지 않는 열은 수정되지 않은 채로 있습니다. 스칼라 식은 업데이트중인 행의 열을 참조 할 수 있습니다. 이 경우 할당하기 전에 모든 스칼라식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">모듈 이름은 첫 번째 매개 변수로 지정된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 등록됩니다 . 모듈의 이름은 두 번째 매개 변수로 제공됩니다. 세 번째 매개 변수는 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 구현에 대한 포인터 입니다. 네 번째 매개 변수는 새 가상 테이블을 작성하거나 다시 초기화 할 때 가상 테이블 모듈 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드 로 전달되는 임의의 클라이언트 데이터 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">모듈 이름은 첫 번째 매개 변수로 지정된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 등록됩니다 . 모듈의 이름은 두 번째 매개 변수로 제공됩니다. 세 번째 매개 변수는 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 구현에 대한 포인터 입니다. 네 번째 매개 변수는 새 가상 테이블을 작성하거나 다시 초기화 할 때 가상 테이블 모듈 의 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드 로 전달되는 임의의 클라이언트 데이터 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">모듈 이름은 &quot;fts3&quot;또는 &quot;fts4&quot;에서 &quot;fts5&quot;로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">모듈 구조에는 가상 테이블의 새 인스턴스 작성 또는 이전 테이블 삭제, 데이터 읽기 및 쓰기, 행 검색 및 삭제, 업데이트 또는 삽입과 같은 가상 테이블에 대한 다양한 조치를 수행하기 위해 SQLite가 호출하는 메소드가 포함되어 있습니다. 모듈 구조는 아래에 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">모듈 구조는 각 가상 테이블 오브젝트에 대한 모든 메소드를 정의합니다. 모듈 구조에는 특정 모듈 테이블 구조 버전을 정의하는 iVersion 필드도 포함됩니다. 현재 iVersion은 항상 3 이하이지만 향후 릴리스의 SQLite에서는 추가 방법으로 모듈 구조 정의가 확장 될 수 있으며이 경우 최대 iVersion 값이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-name은 가상 테이블을 구현하는 오브젝트의 이름입니다. CREATE VIRTUAL TABLE 문을 발행하기 전에 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()를&lt;/a&gt; 사용하여 모듈 이름을 SQLite 데이터베이스 연결에 등록해야합니다 . 모듈은 0 개 이상의 쉼표로 구분 된 인수를 사용합니다. 인수는 균형 괄호가있는 한 거의 모든 텍스트 일 ​​수 있습니다. 인수 구문은 일반적인 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 인수가 &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;열 정의&lt;/a&gt; 로 표시 될 수 있도록 충분히 일반적입니다 . SQLite는 모듈 인수를 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate에&lt;/a&gt; 직접 전달합니다. 및 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect에&lt;/a&gt;해석없이 모듈 구현 방법. 자체 인수를 구문 분석하고 해석하는 것은 모듈 구현의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">가장 일반적인 이유는</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">SQLite 데이터베이스가 메모리에 순수하게 존재하도록하는 가장 일반적인 방법은 특수 파일 이름 &quot; &lt;b&gt;: memory :&lt;/b&gt; &quot;를 사용하여 데이터베이스를 여는 것 입니다. 즉, 실제 디스크 파일 이름을 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 함수 중 하나로 전달하는 대신 &quot;: memory :&quot;문자열을 전달하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">B- 트리 (SQLite가 각 테이블과 인덱스를 디스크에 저장하기 위해 사용하는 데이터 구조)에 변경 사항을 적용하는 가장 효율적인 방법은 키 순서대로 변경하는 것입니다. 그러나 SQL 테이블에 하나 이상의 인덱스가있는 경우 각 인덱스의 키 순서는 기본 테이블 및 다른 보조 인덱스와 다를 수 있습니다. 결과적으로 일련의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE를&lt;/a&gt; 실행할 때모든 b- 트리가 키 순서로 업데이트되도록 작업 순서를 정하는 것은 일반적으로 불가능합니다. RBU 업데이트 프로세스는 기본 테이블에 대한 모든 변경 사항을 한 번에 적용한 다음 별도의 패스로 각 인덱스에 변경 사항을 적용하여 각 B- 트리가 최적으로 업데이트되도록하여이 문제를 해결합니다. 큰 데이터베이스 파일 (OS 디스크 캐시에 맞지 않는 파일)의 경우이 절차를 수행하면 업데이트 속도가 2 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">가장 유용한</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">FTS 테이블에서 가장 유용한 것은 내장 전체 텍스트 인덱스를 사용하여 수행 할 수있는 쿼리입니다. 전체 텍스트 쿼리는 FTS 테이블에서 데이터를 읽는 SELECT 문의 WHERE 절의 일부로 &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;전체 텍스트 쿼리 식&amp;gt;&quot;형식의 절을 지정하여 수행됩니다. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;간단한 FTS 쿼리&lt;/a&gt; 주어진 용어가 포함 된 모든 문서를 반환하는 는 위에 설명되어 있습니다. 이 토론에서 MATCH 연산자의 오른쪽 피연산자는 단일 용어로 구성된 문자열로 가정했습니다. 이 섹션에서는 FTS 테이블에서 지원하는보다 복잡한 쿼리 유형과보다 복잡한 쿼리 식을 MATCH 연산자의 오른쪽 피연산자로 지정하여 활용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">다중 인수 max () 함수는 최대 값으로 인수를 리턴하거나 인수가 NULL 인 경우 NULL을 리턴합니다. 다중 인수 max () 함수는 왼쪽에서 오른쪽으로 인수를 검색하여 조합 함수를 정의하고 모든 문자열 비교에 해당 조합 함수를 사용하는 인수를 찾습니다. max () 인수가 배열 함수를 정의하지 않으면 BINARY 배열 함수가 사용됩니다. 하는 것으로 &lt;b&gt;최대는 ()&lt;/b&gt; 는 2 개 이상의 인수를 가지고 있지만로서 동작 할 때 간단한 함수이다 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;집계 함수&lt;/a&gt; 는 단일 인수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">다중 인수 min () 함수는 최소값을 가진 인수를 반환합니다. 다중 인수 min () 함수는 왼쪽에서 오른쪽으로 인수를 검색하여 조합 함수를 정의하고 모든 문자열 비교에 해당 조합 함수를 사용하는 인수를 찾습니다. min ()에 대한 인수가 배열 함수를 정의하지 않으면 BINARY 배열 함수가 사용됩니다. 참고 &lt;b&gt;분은 ()&lt;/b&gt; 는 2 개 이상의 인수를 가지고 있지만로서 동작 할 경우 간단한 함수이다 &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;집계 기능&lt;/a&gt; 단일 인자가 주어진다면.</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">곱하기 연산자는 이제 64 비트 정수 오버플로를 올바르게 감지하고 모든 코너 케이스에서 부동 소수점으로 승격합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tcl 스크립트는 돌연변이 테스트 실행에 대한 모든 세부 정보를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite 내의 뮤텍스 모듈은 &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 를 뮤텍스 객체의 추상 유형으로 정의 합니다. SQLite 코어는 &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 의 내부 표현을 보지 않습니다 . &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 객체에 대한 포인터 만 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite 내의 뮤텍스 모듈은 &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 를 뮤텍스 객체의 추상 유형으로 정의 합니다. SQLite 코어는 &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 의 내부 표현을 보지 않습니다 . &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 객체에 대한 포인터 만 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrame 값은 항상 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 및 nBackfillAttempted 보다 크거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname 필드는이 VFS가 사용할 수있는 파일 경로 이름의 최대 길이입니다. SQLite는 때때로이 크기의 버퍼를 미리 할당해야하므로 합리적으로 가능한 작아야합니다. 일부 파일 시스템은 큰 경로 이름을 허용하지만 실제로 경로 이름은 거의 100 바이트 이상으로 확장되지 않습니다. 기본 파일 시스템이 여기에서 처리 할 수있는 가장 긴 경로 이름을 입력하지 않아도됩니다. SQLite가 처리 할 수있는 가장 긴 경로 이름 만 입력하면됩니다. 대부분의 경우 수백이 좋은 가치입니다.</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArg 매개 변수는 함수에 대한 인수 수를 지정합니다. 값이 0이면 모든 인수가 허용됨을 나타냅니다. eTextRep 매개 변수는이 함수에 대한 인수에 사용될 표시 텍스트 값을 지정합니다. 이 매개 변수의 값은 위에 정의 된 매개 변수 중 하나 여야합니다. SQLite 버전 3에서는 다른 텍스트 표현을 사용하여 동일한 함수를 여러 번 구현할 수 있습니다. 데이터베이스 엔진은 필요한 텍스트 변환 횟수를 최소화하는 기능을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">nBackfill은 WAL_CKPT_LOCK을 누른 상태에서만 늘릴 수 있습니다. 그러나 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; 동안 nBackfill이 0으로 변경되며 이는 WAL_WRITE_LOCK을 유지하는 동안 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill 수는 mxFrame보다 크지 &lt;a href=&quot;walformat#mxframe&quot;&gt;않습니다&lt;/a&gt; . nBackfill이 &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; 이면 WAL 내용이 데이터베이스에 완전히 다시 쓰여지고 N&amp;gt; 0에 대해 WAL_READ_LOCK (N)에 잠금이없는 경우 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL&lt;/a&gt; 을 재설정 해도됩니다.</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">zero-malloc 메모리 할당 자에 사용되는 &quot;memsys5&quot;라는 이름은 사용 가능한 추가 메모리 할당 기가 몇 개 있으며 실제로는 있음을 의미합니다. 기본 메모리 할당자는 &quot;memsys1&quot;입니다. 디버깅 메모리 할당자는 &quot;memsys2&quot;입니다. 그것들은 이미 다뤄졌습니다.</target>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">인덱스 열의 값을 비교하는 데 사용되는 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">결과 열의 이름은 AS 절이있는 경우 해당 열에 대한 &quot;AS&quot;절의 값입니다. AS 절이없는 경우 열 이름이 지정되지 않으며 SQLite의 한 릴리스에서 다음 릴리스로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite 데이터베이스의 이름은 데이터베이스를 포함 할 파일의 이름입니다. 파일이 존재하지 않으면 SQLite는 파일을 작성하고 초기화하려고 시도합니다. 파일이 읽기 전용 (권한 비트로 인해 또는 CD-ROM과 같은 읽기 전용 매체에 있기 때문에) 인 경우 SQLite는 읽기 전용으로 데이터베이스를 엽니 다. 전체 SQL 데이터베이스는 디스크의 단일 파일에 저장됩니다. 그러나 데이터베이스 롤백 저널 또는 임시 및 중간 쿼리 결과를 저장하기 위해 SQL 명령을 실행하는 동안 추가 임시 파일이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">테이블에서 각 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">용어가 포함 된 FTS5 테이블 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">데이터 정렬의 이름은 sqlite3_create_collation () 및 sqlite3_create_collation_v2 ()의 UTF-8 문자열이고 sqlite3_create_collation16 ()의 기본 바이트 순서의 UTF-16 문자열입니다. &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 에 따라 동일하게 비교되는 데이터 정렬 이름 은 동일한 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">데이터 정렬의 이름은 sqlite3_create_collation () 및 sqlite3_create_collation_v2 ()의 UTF-8 문자열이고 sqlite3_create_collation16 ()의 기본 바이트 순서의 UTF-16 문자열입니다. &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 에 따라 동일하게 비교되는 데이터 정렬 이름 은 동일한 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">색인화되는 열의 이름. 색인 열이 색인화 되는 테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 또는 &lt;a href=&quot;expridx&quot;&gt;expression 인&lt;/a&gt; 경우 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">인덱싱되는 열의 이름입니다. 열이 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인&lt;/a&gt; 경우이 열은 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">용어 인스턴스를 포함하는 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">데이터베이스 이름은 일반적으로 데이터베이스가 저장된 디스크 파일 이름입니다. 데이터베이스 이름이 특수 이름 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;: memory :&lt;/a&gt; &quot;인 경우 새 데이터베이스가 메모리에 작성됩니다. 데이터베이스 이름이 빈 문자열 인 경우 데이터베이스는 빈 파일로 작성되며 데이터베이스 연결이 닫힐 때 자동으로 삭제됩니다. &lt;b&gt;sqlite3&lt;/b&gt; 명령 에 &quot; &lt;b&gt;-uri yes&lt;/b&gt; &quot;옵션이 제공 되면 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 사용할 수 있습니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">트랜잭션이 커밋 된 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">데이터베이스 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">변경중인 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">물론 예에서 '포터'대신 원하는 토크 나이저의 이름을 사용해야합니다. 토크 나이저에 하나 이상의 인수가 필요한 경우, fts3tokenize 선언에서 쉼표로 구분해야합니다 (일반적인 fts4 테이블 선언에서 공백으로 구분 되더라도). 다음은 동일한 토크 나이저를 사용하는 fts4 및 fts3tokenize 테이블을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">색인의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">새 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">결과 컬럼의 이름은 소스 테이블과 소스 컬럼 이름의 조합입니다. TABLE.COLUMN</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">테이블 이름에 하나 이상의 &quot;_&quot;문자가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">테이블 데이터의 이름을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">xColumnSize 값이 저장되는 테이블의 이름 (columnize = 0이 지정되지 않은 경우)은 &quot;&amp;lt;name&amp;gt; _docsize&quot;입니다. 여기서 &amp;lt;name&amp;gt;은 FTS5 테이블 자체의 이름입니다. &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer의&lt;/a&gt; 도구 ColumnSize가 = 0을 사용하여 FTS5 테이블을 다시 만들어 저장 될 수 있습니다 얼마나 많은 공간을 결정하기 위해 기존 데이터베이스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문 에서 수정 될 테이블의 이름은 규정되지 않은 테이블 이름이어야합니다. 다시 말해, &quot;</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS 키워드 다음에 나오는 이름은 SQLite에서 내부적으로 사용하는 데이터베이스 이름입니다. 스키마 이름 'main'및 'temp'는 기본 데이터베이스 및 임시 테이블에 사용 된 데이터베이스를 나타냅니다. 기본 및 임시 데이터베이스는 연결하거나 분리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">기존 결과 코드의 이름과 숫자 값은 고정되어 있으며 변경되지 않습니다. 그러나 새로운 결과 코드, 특히 새로운 확장 결과 코드는 향후 SQLite 릴리스에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">열의 이름은 먼저 포함됩니다</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">반환 된 이름은 데이터베이스, 테이블 및 열의 별칭이없는 원래 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스는 애플리케이션이 런타임시 SQLite의 동작을 사용자 정의 할 수 있도록합니다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 사용하여 가능한 사용자 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스를 통해 응용 프로그램은 런타임에 SQLite의 성능 상태를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">새로운 SQLite 3.0 API에는 호스트 컴퓨터의 기본 바이트 순서로 텍스트를 UTF-8과 UTF-16으로 받아들이는 루틴이 포함되어 있습니다. 각 데이터베이스 파일은 텍스트를 UTF-8, UTF-16BE (big-endian) 또는 UTF-16LE (little-endian)로 관리합니다. 내부 및 디스크 파일에서 동일한 텍스트 표현이 모든 곳에서 사용됩니다. 데이터베이스 파일 (파일 헤더에서)에 지정된 텍스트 표현이 인터페이스 루틴에 필요한 텍스트 표현과 일치하지 않으면 텍스트가 즉시 변환됩니다. 한 표현에서 다른 표현으로 텍스트를 지속적으로 변환하는 것은 계산 비용이 많이들 수 있으므로 프로그래머는 단일 표현을 선택하여 응용 프로그램 전체에 적용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLite의 새로운 OS 인터페이스는 &lt;a href=&quot;c3ref/vfs&quot;&gt; sqlite3_vfs&lt;/a&gt; . &quot;vfs&quot;는 &quot;가상 파일 시스템&quot;을 나타냅니다. sqlite3_vfs 객체는 기본적으로 데이터베이스를 읽고 쓰기 위해 SQLite가 수행해야하는 기본 디스크 I / O 작업을 구현하는 함수에 대한 포인터를 포함하는 구조입니다. 이 기사에서는 종종 sqlite3_vfs 객체를 &quot;VFS&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">새로운 변경은 무시됩니다. 변경 집합이 이미 변경 그룹에 추가 된 후 새 변경 집합이 기록 된 경우에는 이러한 상황이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">새로운 데이터베이스 파일 형식은 테이블에 B + 트리를 사용합니다. B + 트리에서 모든 데이터는 리프와 중간 분기 노드 대신 트리의 리프에 저장됩니다. 테이블에 B + 트리를 사용하면 오버플로 페이지를 사용하지 않고도 확장 성이 향상되고 더 큰 데이터 필드를 저장할 수 있습니다. 전통적인 B- 트리는 여전히 인덱스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">새로운 파일 형식은 512에서 65536 바이트 사이의 가변 페이지 크기도 지원합니다. 페이지 크기는 파일 헤더에 저장되므로 이론적으로 동일한 라이브러리가 다른 페이지 크기의 데이터베이스를 읽을 수 있지만 실제로는이 기능이 아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">새로운 파일 형식은 디스크 이미지에서 사용하지 않는 필드를 생략합니다. 예를 들어, 인덱스는 데이터가 아닌 B- 트리 레코드의 주요 부분 만 사용합니다. 따라서 인덱스의 경우 데이터 길이를 기록하는 필드는 생략됩니다. 키 및 데이터 길이와 같은 정수 값은 가변 길이 인코딩을 사용하여 저장되므로 가장 일반적인 경우를 저장하는 데 1-2 바이트 만 필요하지만 필요한 경우 최대 64 비트의 정보를 인코딩 할 수 있습니다. 정수 및 부동 소수점 데이터는 SQLite 버전 2.8에서와 같이 ASCII로 변환되지 않고 이진으로 디스크에 저장됩니다. 이러한 변경으로 인해 데이터베이스 파일은 일반적으로 SQLite 버전 2.8의 동등한 파일보다 25 %-35 % 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">새 인터페이스는 세 개의 개별 함수를 사용하여 단일 &lt;b&gt;sqlite_exec&lt;/b&gt; 함수 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">새로운 객체는 sqlite3rebaser_configure ()를 호출하여 sqlite3changeset_apply_v2 ()에서 얻은 리베이스 버퍼로 구성됩니다. 로컬 변경 세트를 여러 원격 변경 세트에 대해 리베이스하려면 여러 sqlite3changeset_apply_v2 () 호출과 동일한 순서로 sqlite3rebaser_configure ()를 여러 번 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">새 행은 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 과 동일한 기준을 충족 해야합니다. 반드시 존재해야하며 지명 된 열에 blob 또는 텍스트 값이 저장되어 있어야합니다. 새 행이 테이블에 없거나 blob 또는 text 값을 포함하지 않거나 다른 오류가 발생하면 SQLite 오류 코드가 리턴되고 blob 핸들이 중단 된 것으로 간주됩니다. 중단 된 얼룩 핸들 에서 &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 에 대한 모든 후속 호출은 즉시 SQLITE_ABORT를 반환합니다. 중단 된 blob 핸들에서 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 를 호출 하면 항상 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">새 행은 &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 과 동일한 기준을 충족 해야합니다. 반드시 존재해야하며 지명 된 열에 저장된 블롭 또는 텍스트 값이 있어야합니다. 새 행이 테이블에 없거나 blob 또는 text 값을 포함하지 않거나 다른 오류가 발생하면 SQLite 오류 코드가 리턴되고 blob 핸들이 중단 된 것으로 간주됩니다. 중단 된 얼룩 핸들 에서 &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 또는 &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 에 대한 모든 후속 호출은 즉시 SQLITE_ABORT를 반환합니다. 중단 된 blob 핸들에서 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 를 호출 하면 항상 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">행의 수정 된 각 필드에 대한 새 값</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">새 창 정의에는 PARTITION BY 절이 포함되지 않아야합니다. PARTITION BY 절 (있는 경우)은 기본 창 스펙에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">최신 &quot;.eqp trace&quot;명령은 &quot;.eqp full&quot;이 수행하는 모든 작업을 수행하고 &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE 추적&lt;/a&gt; 도 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">최신 xQueryFunc 콜백은 호출 할 때마다 r-tree 쿼리 엔진에서 더 많은 정보를 수신하고 반환되기 전에 더 많은 정보를 쿼리 엔진으로 다시 보냅니다. 인터페이스를 관리 가능하게 유지하기 위해 xQueryFunc 콜백은 sqlite3_rtree_query_info 구조의 필드로 쿼리 엔진에서 정보를 보내고받습니다.</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">다음 &quot;.mode&quot;명령은 &quot;.separator&quot;를 기본값으로 다시 설정합니다. 비표준 구분 기호를 계속 사용하려면 모드를 변경할 때마다 &quot;.separator&quot;명령을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">다음 블록에는 C로 구현 된 matchinfo 데이터를 사용하는 순위 함수의 예가 포함되어 있습니다. 단일 가중치 대신 가중치를 각 문서의 각 열에 외부 적으로 할당 할 수 있습니다. &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function을&lt;/a&gt; 사용하여 다른 사용자 함수와 마찬가지로 SQLite에 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">다음 SQL 블록은 FTS를 사용하여 검색 응용 프로그램을 개발할 때 발생할 수있는 두 가지 다른 문제에 대한 솔루션으로 쿼리를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">다음 차트는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 SQLite 데이터베이스 업데이트를 디스크에있는 별도의 파일에 대한 원시 디스크 직접 덮어 쓰기와 비교합니다. &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정은 보통입니다. 모든 데이터베이스 쓰기는 단일 트랜잭션에 있습니다. 데이터베이스 쓰기 타이머는 트랜잭션이 커밋 된 후, &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점이&lt;/a&gt; 실행 되기 전에 중지 됩니다. 디스크에 직접 쓰기와 달리 SQLite 쓰기는 &lt;a href=&quot;transactional&quot;&gt;트랜잭션&lt;/a&gt; 및 &lt;a href=&quot;transactional&quot;&gt;전원 안전&lt;/a&gt; 하지만 동기 설정이 FULL 대신 NORMAL이므로 트랜잭션은 내구성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">다음 차트는 트랜잭션이 비활성화되고 ( &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt; ) &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되어 있을 때 SQLite 대 디스크에 대한 성능을 보여줍니다 . 이러한 설정은 디스크에 직접 쓰기를 사용하여 SQLite를 동일하게 설정합니다. 즉, 시스템 충돌 및 정전으로 인해 데이터가 손상되기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">다음 예제는 lag (), lead (), first_value (), last_value () 및 nth_value ()를 보여줍니다. 프레임 스펙은 lag () 및 lead ()에 의해 무시되지만 first_value (), last_value () 및 nth_value ()에 의해 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">다음 예는 단일 WITH 절에서 두 개의 공통 테이블 표현식을 사용합니다. 다음 표는 가계도를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLite의 다음 인터페이스 루틴은 문자열이 완전한 SQL 문을 형성하는지 여부를 테스트하는 데 사용되는 편리한 함수입니다. 는 IF &lt;b&gt;sqlite_complete&lt;/b&gt; 입력 문자열 인 경우 함수가 반환 사실, 다음 인수는 완전한 SQL 문을 형성한다. 해당 문장의 구문이 정확하다는 보장은 없지만, 적어도 문장의 완성도는 알고 있습니다. 경우 &lt;b&gt;sqlite_complete&lt;/b&gt; 반환 거짓, 다음 더 많은 텍스트는 SQL 문을 완료하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">다중 파일 커밋의 다음 단계는 &quot;마스터 저널&quot;파일을 만드는 것입니다. 마스터 저널 파일의 이름 은 텍스트 가 &lt;a href=&quot;lang_attach&quot;&gt;--mj 인&lt;/a&gt; 원래 데이터베이스 파일 이름 ( 첨부 된 보조 데이터베이스 중 하나가 아닌 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 인터페이스를 사용하여 연 데이터베이스)과 이름이 &lt;b&gt;같습니다.&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">다음 단계는 마스터 저널 파일을 삭제하는 것입니다. 이것이 다중 파일 트랜잭션이 커밋하는 지점입니다. 이 단계 는 롤백 저널이 삭제되는 단일 파일 커밋 시나리오의 &lt;a href=&quot;#section_3_11&quot;&gt;3.11&lt;/a&gt; 단계에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">다음 단계는 롤백 저널 파일의 내용을 비 휘발성 저장소로 플러시하는 것입니다. 나중에 볼 수 있듯이, 이는 데이터베이스가 예기치 않은 전원 손실을 견뎌 낼 수 있도록하는 중요한 단계입니다. 비 휘발성 스토리지에 쓰는 작업은 일반적으로 느리게 수행되므로이 ​​단계에도 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">다음 단계는 공개 지점의 변경 사항을 개인 지점으로 옮기는 것입니다. 즉, 위 다이어그램에서 원 (5)을 만들고 싶습니다. &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;을 사용하여 개인 브랜치로 변경하여 시작하십시오 . 그런 다음이 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">다음 단계는 모든 롤백 저널의 헤더에 마스터 저널 파일의 전체 경로 이름을 기록하는 것입니다. 마스터 저널 파일 이름을 보유 할 공간은 롤백 저널이 작성 될 때 각 롤백 저널의 시작 부분에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">헤더의 다음 3 바이트는 다각형의 꼭지점 수를 빅 엔디안 정수로 기록합니다. 따라서 다각형 당 약 1600 만 버텍스의 상한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 에 P1 에 대한 &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; , &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; 또는 Next 명령어 사용은 데이터베이스 테이블 또는 인덱스의 첫 번째 항목을 참조합니다. 테이블이나 인덱스가 비어 있으면 즉시 P2로 이동하십시오. 테이블이나 인덱스가 비어 있지 않으면 다음 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">다음 에 P1 에 대한 &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; , &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; 명령어 사용은 데이터베이스 테이블 또는 인덱스의 마지막 항목을 참조합니다. 테이블 또는 인덱스가 비어 있고 P2&amp;gt; 0이면 즉시 P2로 이동하십시오. P2가 0이거나 테이블 또는 인덱스가 비어 있지 않으면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">no-op 메모리 할당자는 그 자체로는 유용하지 않습니다. SQLite에는 표준 라이브러리에 malloc (), free () 또는 realloc ()이없는 시스템에서 연결할 메모리 할당자가 있습니다. 컴파일 된 응용 프로그램 &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC은&lt;/a&gt; 사용해야합니다 &lt;a href=&quot;c3ref/config&quot;&gt;) sqlite3_config을 (&lt;/a&gt; 함께 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; SQLite는 사용하기 시작하기 전에 새로운 대안 메모리 할당을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolock 쿼리 매개 변수는 true 일 때 VFS의 xLock, xUnlock 및 xCheckReservedLock 메서드에 대한 모든 호출을 비활성화하는 부울 값입니다. 예를 들어, 파일 잠금을 지원하지 않는 파일 시스템의 파일에 액세스하려고 할 때 nolock 쿼리 매개 변수가 사용될 수 있습니다. 주의 : 둘 이상의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 동일한 SQLite 데이터베이스와 상호 작용하려고 시도하고 해당 연결 중 하나 이상이 &quot;nolock&quot;을 활성화 한 경우 데이터베이스가 손상 될 수 있습니다. &quot;nolock&quot;쿼리 매개 변수는 응용 프로그램이 데이터베이스에 대한 쓰기가 직렬화되도록 보장 할 수있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">위에서 설명한 일반 ROWID 선택 알고리즘은 최대 ROWID 값을 사용하지 않고 가장 큰 ROWID를 가진 테이블의 항목을 삭제하지 않는 한 단조 증가하는 고유 ROWID를 생성합니다. 행을 삭제하거나 가능한 최대 ROWID로 행을 작성하는 경우, 새 행을 작성할 때 이전에 삭제 한 행의 ROWID가 재사용 될 수 있으며 새로 작성된 ROWID가 오름차순으로 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed = 옵션을 사용할 수 없습니다. 열 정의에 &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; 를 추가 하는 것은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">nullif (X, Y) 함수는 인수가 다른 경우 첫 번째 인수를 리턴하고 인수가 동일한 경우 NULL을 리턴합니다. nullif (X, Y) 함수는 왼쪽에서 오른쪽으로 인수를 검색하여 조합 함수를 정의하고 모든 문자열 비교에 해당 조합 함수를 사용하는 인수를 찾습니다. nullif ()에 대한 인수가 조합 함수를 정의하지 않으면 BINARY가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">함수에 대한 인수의 수는 때때로 부호있는 문자로 저장됩니다. 따라서 SQLITE_MAX_FUNCTION_ARG의 하드 상한은 127입니다.</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFrom과 cTo의 문자 수가 같을 필요는 없습니다. 위의 규칙에 따르면 사용자 입력의 &quot;ss&quot;는 &quot;&amp;szlig;&quot;와 8의 패널티가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">테이블의 열 수</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">테이블의 열 수는 &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; 컴파일 시간 매개 변수에 의해 제한됩니다 . 테이블의 단일 행은 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 바이트 이상의 데이터를 저장할 수 없습니다 . &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; C / C ++ 인터페이스를 사용하여 런타임시 이러한 한계를 낮출 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">뷰의 열 수</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">인덱스의 열 수</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT 문 (있는 경우)에 의해 리턴되는 각 행의 열 수 및 리턴 된 특정 값은 EXISTS 연산자의 결과에 영향을 미치지 않습니다. 특히, NULL 값을 포함하는 행은 NULL 값이없는 행과 다르게 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT 문의 결과 세트에있는 열 수</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">간단한 SELECT 문으로 반환 된 행의 열 수는 * 및 alias. * 식을 대체 한 후 결과 식 목록의 식 수와 같습니다. 각 결과 행은 단일 행의 입력 데이터 또는 집계 쿼리의 경우 행 그룹에 대해 결과 표현식 목록의 표현식을 평가하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">테이블의 열 수</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">테이블에있는 열 수</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">해당 데이터베이스에 대한 미리 쓰기 로그 (WAL) 파일의 항목 수</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">이 행의 필드 수</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">프리리스트 페이지의 수는 파일의 시작 부분에서 36의 오프셋으로 데이터베이스 헤더에 4 바이트 빅 엔디안 정수로 저장됩니다. 데이터베이스 헤더는 첫 번째 사용 가능리스트 트렁크 페이지의 페이지 번호를 파일 시작 부분에서 32의 오프셋에 4 바이트 빅 엔디안 정수로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">쿼리에서 일치하는 문구 수입니다.</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">공유 캐시에서 열린 읽기 트랜잭션 수는 0으로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">하나의 준비된 명령문의 레지스터 수는 컴파일 타임에 고정됩니다. 준비된 명령문이 &lt;a href=&quot;c3ref/reset&quot;&gt;재설정&lt;/a&gt; 되거나 &lt;a href=&quot;c3ref/finalize&quot;&gt;완료&lt;/a&gt; 되면 모든 레지스터의 내용이 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES 절의&lt;/a&gt; 행 수 는 더 이상 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT에&lt;/a&gt; 의해 제한되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4 테이블의 행 수입니다. 이 값은 FTS3이 아닌 FTS4 테이블을 쿼리 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">열 $ col에 용어의 인스턴스가 하나 이상 포함 된 FTS5 테이블의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">용어의 인스턴스를 하나 이상 포함하는 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">파일 시스템 작업에 대한 시스템 호출 수가 줄어 성능이 약간 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BY 또는 ORDER BY 절의 용어 수</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE 문의 SET 절에있는 용어 수</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">파티션 내에서 현재 행의 피어 그룹 수-간격이없는 현재 행의 순위 파티션은 창 정의에서 ORDER BY 절에 의해 정의 된 순서대로 1부터 시작하여 번호가 매겨집니다. ORDER BY 절이 없으면 모든 행이 피어로 간주되며이 함수는 항상 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">현재 파티션 내의 행 수입니다. 창 정의에서 ORDER BY 절에 의해 정의 된 순서대로 또는 1에서 시작하여 행에 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTS 테이블의 사용자 정의 열 수 (예 : docid 또는 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열 포함&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT 문의 값 수</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">위의 번호가 매겨진 목록은 데이터베이스 파일의 첫 페이지에 대한 데이터가 존재하고 아직로드되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">여기 숫자는 의미가 없어졌습니다. 이 페이지는 역사적 유물로만 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">왼쪽의 숫자는 물론 해당 코드 줄의 CPU주기 수입니다.</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">sqlite3changegroup_delete ()를 호출하여 객체를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">b- 트리 페이지 유형을 나타내는 오프셋 0의 1 바이트 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">오프셋 7의 1 바이트 정수는 셀 내용 영역 내에서 조각난 여유 바이트 수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">온라인 백업 API는 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;여기&lt;/a&gt; 에 문서화되어 있습니다 . 이 페이지의 나머지 부분에는 API의 일반적인 사용과 그에 대한 설명을 보여주는 두 가지 C 언어 예제가 포함되어 있습니다. 이 예제를 읽는 것이 API 문서를 읽는 것의 대안이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">사용 된 유일한 SQLite 컴파일 타임 옵션은 &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; 입니다. 선택적 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 메모리 할당자는 Ubuntu의 라이브러리 제공 malloc () / free ()보다 반복 가능한 결과를 제공하므로 성능 테스트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">지원되는 유일한 압축 알고리즘은 &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">다음 두 CASE 표현식의 유일한 차이점은</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">유일한 차이점은 위에 열거 된 공개 sqlite3_XXX 함수는 유효한 뮤텍스 핸들 대신 NULL 포인터를 전달하는 호출을 자동으로 무시한다는 것입니다. 이 구조로 정의 된 메소드의 구현은이 경우를 처리하는 데 필요하지 않습니다. 유효한 뮤텍스 핸들 대신 NULL 포인터를 전달한 결과는 정의되지 않습니다 (즉, NULL 포인터를 전달하면 segfaults 구현을 제공하는 것이 허용됩니다). ).</target>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">실제로 어려운 부분은 1 단계입니다. 기존 가상 테이블 구현으로 시작하여 필요에 맞게 수정할 수 있습니다. SQLite 소스 트리에는 테스트 목적으로 몇 가지 가상 테이블 구현이 있습니다. 그중 하나를 가이드로 사용할 수 있습니다. &quot;sqlite3_create_module&quot;을 검색하여 이러한 테스트 가상 테이블 구현을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">strftime () 이외의 함수를 제공하는 유일한 이유는 편의성과 효율성 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLite가 직접 지원하는 유일한 스키마 변경 명령은 위에 표시된 &quot; &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;이름 바꾸기 테이블&lt;/a&gt; &quot;, &quot; &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;이름 바꾸기 열&lt;/a&gt; &quot;및 &quot; &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;열 추가&lt;/a&gt; &quot;명령입니다. 그러나 응용 프로그램은 간단한 조작 순서를 사용하여 테이블 형식을 임의로 변경할 수 있습니다. 일부 테이블 X의 스키마 디자인을 임의로 변경하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">개발자가 결정해야 할 유일한 중요한 결정은 -Os (크기에 최적화) 또는 -O6 (속도에 최적화)을 사용할지 여부입니다. -O6 설정은 바이너리를 약 2 % 또는 3 % 더 빠르게 실행하지만 66 % 더 큰 바이너리를 만듭니다. 여기서의 성능은 cachegrind를 사용하여 CPU주기를 계산하여 측정됩니다. I- 캐시 미스는 분석에서 고려되지 않습니다. I- 캐시 미스가 고려되면 -O6을 사용한 빌드는 -O를 사용한 빌드보다 빠르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">현재 예제에서 실제로 새로운 것은 주소 7에서 10까지의 명령어로 구현되는 WHERE 절입니다. 주소 7과 8의 명령어는 테이블에서 &quot;하나&quot;열의 값과 리터럴을 스택에 푸시합니다. 문자열 &quot;H %&quot;. 주소 9 의 &lt;a href=&quot;opcode#Function&quot;&gt;함수&lt;/a&gt; 명령은 스택에서이 두 값을 팝하고 LIKE () 함수의 결과를 스택으로 다시 푸시합니다. &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot의&lt;/a&gt; 명령은 상위 스택 값 나타나고 정상 값 (FALSE 인 경우 다음 명령으로 점프 순방향 즉시 발생 &lt;em&gt;하지&lt;/em&gt;리터럴 문자열 &quot;H %&quot;와 같지 않음). 이 점프를 효과적으로 수행하면 콜백을 건너 뜁니다. 이는 WHERE 절의 요점입니다. 비교 결과가 참이면 점프가 수행되지 않고 제어는 아래의 콜백 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">이것이 문제가 될 수있는 유일한 시간은 불완전한 트랜잭션으로 인해 충돌하는 버전 2.8.0 이상을 사용하는 프로그램이있는 경우 버전 2.7.6 이하를 사용하여 데이터베이스를 검사하려고 시도하는 것입니다. 2.7.6 코드는 저널 파일을 읽을 수 없으므로 데이터베이스를 복원하기 위해 불완전한 트랜잭션을 롤백 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite가 인덱스의 가장 왼쪽 열에 많은 중복이 있음을 알 수있는 유일한 방법은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령이 데이터베이스에서 실행 된 경우입니다. ANALYZE의 결과가 없으면 SQLite는 테이블에있는 데이터의 &quot;모양&quot;을 추측해야하며 기본 추측은 인덱스의 가장 왼쪽 열에있는 모든 값에 대해 평균 10 개의 복제본이 있다는 것입니다. 그러나 중복 스캔 수가 약 18 이상인 경우 건너 뛰기 스캔은 수익성이 높아집니다 (전체 테이블 스캔보다 빠릅니다). 따라서 스킵 스캔은 분석되지 않은 데이터베이스에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">데이터베이스 파일의 열기 및 / 또는 생성은 파일이 실제로 필요할 때까지 연기됩니다. 이를 통해 PRAGMA 문을 사용하여 기본 텍스트 표시 및 기본 페이지 크기와 같은 옵션 및 매개 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">운영 체제 인터페이스 계층은 위에서 설명한 다섯 가지 잠금 상태를 모두 이해하고 추적합니다. 호출기 모듈은 5 가지 잠금 상태 중 4 개만 추적합니다. PENDING 잠금은 항상 독점 잠금 경로의 임시 디딤돌이므로 호출기 모듈은 PENDING 잠금을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">특히 두 프로세스가 동일한 데이터베이스 파일에 액세스하고 한 프로세스는 메모리 매핑 된 I / O를 사용하는 반면 다른 프로세스는 메모리 매핑 된 I / O 확장이 올바르게 작동하려면 운영 체제에 통합 버퍼 캐시가 있어야합니다. 아니다. 모든 운영 체제에 통합 버퍼 캐시가있는 것은 아닙니다. 통합 버퍼 캐시가 있다고 주장하는 일부 운영 체제에서는 구현이 버그가 있으며 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">위의 작업으로 인해 원시 데이터베이스 파일이 크게 변경 될 수 있으므로 파일 수준에서 매우 다른 SHA1 해시가 발생할 수 있습니다. 그러나 데이터베이스 파일에 표시된 내용은 이러한 작업으로 변경되지 않으므로 dbhash로 계산 된 해시도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">인덱스를 사용하여 집계 min () 또는 max ()를 빠르게 계산하는 최적화는 &lt;a href=&quot;expridx&quot;&gt;expressions에 대한 인덱스&lt;/a&gt; 작업을 위해 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">옵티마이 저는 &quot;expr OP column&quot;형식의 용어를 자동으로 반전시키고 가능한 한 많은 WHERE 절 용어를 가능한 한 많은 형식으로 얻기 위해 WHERE 절을 다른 단순화합니다. aConstraint [] 배열은 쿼리중인 특정 가상 테이블과 관련된 WHERE 절만보고합니다.</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">옵티마이 저는 LEFT 조인이 있어도 FROM 절에서 테이블을 재정렬 할 수있는 자유가 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">ORDER BY ... DESC 절을 만족시키는 경우 옵티마이 저는 이제 역으로 테이블을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">이 옵션을 사용하면 SQLite가 Unix, Windows 및 OS / 2 용 내장 운영 체제 인터페이스를 생략합니다. 결과 라이브러리에는 기본 &lt;a href=&quot;c3ref/vfs&quot;&gt;운영 체제 인터페이스&lt;/a&gt; 가 없습니다 . 애플리케이션은 SQLite를 사용하기 전에 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 를 사용하여 적절한 인터페이스를 등록 해야합니다 . 응용 프로그램은 또한 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end ()&lt;/a&gt; 인터페이스에 대한 구현을 제공해야합니다 . 평소 연습 제공된위한 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; 호출의에 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; . SQLite는 초기화 될 때 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()를&lt;/a&gt; 자동으로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">선택적 &quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">선택적 &quot;AS 별명&quot;문구는 컨텐츠가 삽입되는 테이블의 대체 이름을 제공합니다. 별명 이름은 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; 의 WHERE 및 SET 절에서 사용될 수 있습니다 . &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; 가 없으면 별칭은 무의미하지만 무해합니다.</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">선택적인 &quot;OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">선택적 EXCLUDE 절은 다음 네 가지 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">선택적 IF EXISTS 절은 테이블이 존재하지 않는 경우 일반적으로 발생하는 오류를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">선택적 MASK 인수는 수행 할 최적화의 비트 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">선택적 인수는 직렬화 할 스키마 또는 데이터베이스의 이름입니다. 기본값은 &quot;main&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">CASE 키워드와 첫 번째 WHEN 키워드 사이에 발생하는 선택적 표현식을 &quot;기본&quot;표현식이라고합니다. CASE 표현식에는 기본 표현식이있는 양식과없는 기본 양식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">버전 3.3.0에서 도입 된 선택적 공유 캐시 및 메모리 관리 기능을 이제 동일한 프로세스 내에서 여러 스레드에서 사용할 수 있습니다. 이전에는 이러한 확장이 단일 스레드 내에서 작동하는 데이터베이스 연결에만 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">함수 인수의 평가 순서</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">인덱스 b- 트리의 키 순서는 키가 나타내는 레코드의 정렬 순서에 따라 결정됩니다. 레코드 비교는 열별로 진행됩니다. 레코드의 열은 왼쪽에서 오른쪽으로 검사됩니다. 같지 않은 첫 번째 열 쌍은 두 레코드의 상대 순서를 결정합니다. 개별 열의 정렬 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">인덱스를 더 잘 사용하기 위해 조인의 테이블 순서가 자동으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">내장 snprintf () 구현에서 버퍼 포인터 및 버퍼 크기 매개 변수의 순서는 표준 라이브러리 구현에 사용 된 순서와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_ % 테이블의 열 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">항목의 순서는 중첩 순서를 나타냅니다. 이 경우 인덱스 i2를 사용하는 테이블 t1의 스캔은 외부 루프이고 (먼저 나타남) 테이블 t2의 전체 테이블 스캔은 내부 루프입니다 (마지막에 나타남). 다음 예에서는 SELECT의 FROM 절에서 t1 및 t2의 위치가 반대입니다. 쿼리 전략은 동일하게 유지됩니다. EXPLAIN QUERY PLAN의 출력은 쿼리가 SQL 문에 지정된 방식이 아니라 실제로 평가되는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xnext&quot;&gt;orderByConsumed&lt;/a&gt; 는 별도의 정렬 단계가 필요하지 않도록 &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / xNext의 출력 이 ORDER BY 절을 충족시키기 위해 올바른 순서로 발생 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">&lt;a href=&quot;vtab#xnext&quot;&gt;orderByConsumed&lt;/a&gt; 는 별도의 정렬 단계가 필요하지 않도록 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / xNext의 출력 이 ORDER BY 절을 충족시키기 위해 올바른 순서로 발생 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">어휘 단어의 원래 UTF8 텍스트</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">우리가 여기에 넣은 원본 문서는 &lt;a href=&quot;codeofethics&quot;&gt;프로젝트 설립자의 윤리 강령에 더 가깝습니다&lt;/a&gt; . 우리는 이러한 원칙을 준수하지만 행동 규범의 현대적인 기술적 의미와 일치하지 않으므로 이름이 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLite의 원래 구현은 부분적으로 &quot;당신이 받아들이는 것에 자유 로워&quot;라는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel의 법칙&lt;/a&gt; 을 따르려고했습니다 . 이것은 좋은 디자인으로 여겨졌다. 시스템은 복잡한 입력을 받아들이고 너무 불평하지 않고 최선을 다하려고했다. 그러나 요즘 사람들은 입력에서 오류를 더 쉽게 찾을 수 있도록 때로는 당신이 받아들이는 것에 엄격한 것이 더 낫다는 것을 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">행의 수정 된 각 필드에 대한 원래 값</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">수정 된 필드의 원래 값은 UPDATE 레코드에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">ZIP 대신 SQLite를 사용하는 또 다른 이점은 업데이트 도중 전원 손실 또는 기타 충돌이 발생하는 경우 문서를 손상시킬 위험없이 문서를 증분 업데이트 할 수 있다는 것입니다. ( &lt;a href=&quot;atomiccommit&quot;&gt;SQLite 데이터베이스에 대한&lt;/a&gt; 쓰기 는 원자 적이라는 것을 기억하십시오 .) 사실, 모든 컨텐츠는 여전히 단일 문자가 변경되는 경우 완전히 다시 작성해야하는 하나의 큰 XML 파일 ( &quot;content.xml&quot;)로 유지됩니다. 그러나 SQLite를 사용하면 하나의 파일 만 변경하면됩니다. 저장소의 다른 77 파일은 변경되지 않은 상태로 남아있을 수 있습니다. 모두 다시 작성하지 않아도되므로 &quot;파일 / 저장&quot;이 훨씬 빠르게 실행되고 SSD의 마모가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc ()에 허용 된 다른 매개 변수 (SQLITE_MUTEX_FAST 및 SQLITE_MUTEX_RECURSIVE 이외의 다른 매개 변수)는 각각 정적 기존 뮤텍스에 대한 포인터를 리턴합니다. 현재 버전의 SQLite에서 9 개의 정적 뮤텍스를 사용합니다. 이후 버전의 SQLite는 추가 정적 뮤텍스를 추가 할 수 있습니다. 정적 뮤텍스는 SQLite에서만 내부 용입니다. SQLite 뮤텍스를 사용하는 응용 프로그램은 SQLITE_MUTEX_FAST 또는 SQLITE_MUTEX_RECURSIVE에서 반환 한 동적 뮤텍스 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">다른 파일 &quot;fts5.h&quot;는 FTS5 확장자를 컴파일하는 데 필요하지 않습니다. &lt;a href=&quot;fts5#extending_fts5&quot;&gt;사용자 정의 FTS5 토크 나이저 또는 보조 기능&lt;/a&gt; 을 구현하는 응용 프로그램에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 또는 &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()&lt;/a&gt; 이 호출 될 때 변경 세트 또는 패치 세트를 작성하는 데 필요한 다른 정보를 데이터베이스 파일에서 읽습니다 . 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">외부 SELECT는 명령어 11-25로 구현됩니다. 특히 IN 연산자를 포함하는 WHERE 절은 16, 17 및 20의 명령어로 구현됩니다. 명령어 16은 현재 행의 &quot;2&quot;열 값을 stack and instruction 17은 NULL이 아닌지 확인합니다. 이것이 성공하면 실행은 20으로 점프하여 스택의 상단이 임시 테이블의 키와 일치하는지 테스트합니다. 나머지 코드는 이전에 표시된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">외부 SELECT는 명령 14-25로 구현됩니다. 특히 중첩 선택을 포함하는 WHERE 절은 명령 19-21로 구현됩니다. 내부 선택의 결과가 명령 20에 의해 스택에로드되어 사용됨을 알 수 있습니다. 21의 조건부 점프에 의해.</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">외부 루프 오버 테이블 examp는 명령 7-23으로 구현됩니다. 내부 루프는 명령 13-22입니다. WHERE 표현식의 &quot;2 &amp;lt;50&quot;용어는 첫 번째 테이블의 열만 포함하며 내부 루프. SQLite는이를 수행하고 명령어 10에서 12까지의 &quot;two &amp;lt;50&quot;테스트를 구현합니다. &quot;four == two&quot;테스트는 내부 루프의 명령어 14에서 16까지 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">출력은의 보고서로 시작 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (교차 확인을 다시 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; 테스트중인 SQLite는 대한)에 의해보고 된 사용되는 컴파일 시간 옵션 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; . 결과는 테스트 결과 요약과 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 반복으로 끝납니다 . 오류가 발견되면 추가 라인이 문제점을 자세히 설명합니다. 오류보고 행은 항상 단일 공백 ​​문자로 시작하므로 다음을 사용하여 큰 출력 파일에서 빠르게 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAIN 및 EXPLAIN QUERY PLAN의 출력은 대화식 분석 및 문제 해결 전용입니다. 출력 형식의 세부 사항은 SQLite의 한 릴리스에서 다음 릴리스로 변경 될 수 있습니다. 애플리케이션은 정확한 동작이 가변적이고 부분적으로 만 문서화되므로 EXPLAIN 또는 EXPLAIN QUERY PLAN을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; 스크립트 의 출력은 각 코드 행에 소요 된 CPU주기 수를 보여줍니다. 보고서의 길이는 약 80,000 줄입니다. 다음은 보고서 중간에서 가져온 간단한 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tcl 스크립트의 출력은 SQLite 라이브러리 자체를 제외한 모든 테스트를 실행하는 데 필요한 모든 것을 포함하는 C 프로그램입니다. 생성 된 테스트 프로그램에는 테스트 모듈에서 사용하는 모든 지원 인터페이스에 대한 구현이 포함 되며 테스트를 구동하는 &lt;code&gt;main()&lt;/code&gt; 루틴이 포함 됩니다. 테스트 프로그램을 실행 가능한 실행 파일로 변환하려면 SQLite에 대해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">출력은 데이터베이스 파일의 공간 활용에 대한 정보를 제공하는 사람이 읽을 수있는 ASCII 텍스트 보고서입니다. 보고서 끝 부분에보고 된 다양한 매개 변수에 &lt;a href=&quot;sqlanalyze#defs&quot;&gt;대한 추가 설명&lt;/a&gt; 이 있지만이 보고서는 설명 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">출력도 유효한 SQL입니다. 대부분의 보고서 텍스트는 보고서 &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;끝에&lt;/a&gt; 데이터베이스를 작성하고 초기화하는 다양한 SQL 문과 함께 헤더 주석 내에 포함됩니다 . 구성된 데이터베이스에는 보고서를 추출한 원시 데이터가 포함됩니다. 따라서 원본 보고서를 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 인스턴스로 읽은 다음 원시 데이터베이스를 쿼리하여 특정 데이터베이스 파일의 공간 활용도를보다 심층적으로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 의 출력은 이제 트리거 내에서 실행되는 각 개별 SQL 문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">이 수정 된 쿼리의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">출력 s0 및 s1은 모두 피보나치 가중치를 역순으로 사용한 가중치 체크섬입니다. 가장 큰 피보나치 가중치는 합산되는 시퀀스의 첫 번째 요소에서 발생합니다. s1 값은 시퀀스의 모든 32 비트 정수 항에 걸쳐 있으며 s0은 최종 항을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">오버 플로우 임계 값은 인덱스 b- 트리에 대해 최소 팬 아웃 4를 제공하고 오버 헤드 페이지를 참조하지 않고 레코드 헤더에 일반적으로 액세스 할 수 있도록 페이로드가 b- 트리 페이지에 충분한 지 확인하도록 설계되었습니다. 뒷받침으로, SQLite b-tree 로직의 디자이너는 이러한 임계 값을 훨씬 더 간단하게 만들 수 있다는 것을 깨달았습니다. 그러나 파일 형식이 호환되지 않으면 계산을 변경할 수 없습니다. 그리고 현재 계산은 조금 복잡하더라도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData 포인터는 SQLite 코어에서 사용되지 않습니다. 포인터는 VFS 정보가 가지고 다닐 수있는 보조 정보를 저장하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf 매개 변수는 SQLite가 페이지 캐시 메모리 할당에 사용할 연속 바이트 범위에 대한 포인터입니다. 버퍼 크기는 sz * N 바이트 이상이어야합니다. &quot;sz&quot;매개 변수는 각 페이지 캐시 할당의 크기입니다. N은 사용 가능한 최대 할당 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry 구조의 pContext 멤버는 콜백이 등록 될 때 항상 sqlite3_rtree_geometry_callback ()에 전달 된 pContext 인수의 복사본으로 설정됩니다. aParam [] 배열 (크기 nParam)은 MATCH 연산자의 오른쪽에있는 SQL 함수에 전달 된 매개 변수 값을 포함합니다. 위의 &quot;circle&quot;쿼리 예에서 nParam은 3으로 설정되고 aParam [] 배열에는 3 개의 값 45.3, 22.9 및 5.0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()에&lt;/a&gt; 의해 작성된 반복자 일 수 있습니다. 후자의 경우, 가장 최근 호출에서 &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; 반환해야합니다 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW을&lt;/a&gt; . 그렇지 않은 경우이 함수는 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()에&lt;/a&gt; 의해 작성된 반복자 일 수 있습니다. 후자의 경우, &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()에&lt;/a&gt; 대한 가장 최근 호출은 SQLITE_ROW를 리턴해야합니다. 또한 반복자가 현재 가리키는 변경 유형이 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 인 경우에만 호출 될 수 있습니다 . 그렇지 않으면이 함수는 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 리턴 하고 * ppValue를 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()에&lt;/a&gt; 의해 작성된 반복자 일 수 있습니다. 있습니다. 후자의 경우, &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()에&lt;/a&gt; 대한 가장 최근 호출은 SQLITE_ROW를 리턴해야합니다. 또한 반복자가 현재 가리키는 변경 유형이 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; 인 경우에만 호출 될 수 있습니다 . 그렇지 않으면이 함수는&lt;a href=&quot;rescode#misuse&quot;&gt; SQLITE_MISUSE를&lt;/a&gt; 하고 * ppValue를 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 다음에 의해 작성된 반복자 일 수 있습니다.&lt;a href=&quot;sqlite3changeset_start&quot;&gt; sqlite3changeset_start ()에&lt;/a&gt; 있습니다. 후자의 경우, 가장 최근 호출 &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next은 ()&lt;/a&gt; 반환해야합니다 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW을&lt;/a&gt; . 그렇지 않은 경우이 함수는 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()에&lt;/a&gt; 의해 작성된 반복자 일 수 있습니다. 후자의 경우 &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()에&lt;/a&gt; 대한 가장 최근 호출 리턴해야합니다. 또한 반복자가 현재 가리키는 변경 유형이 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 인 경우에만 호출 될 수 있습니다 . 그렇지 않으면이 함수는 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 리턴 하고 * ppValue를 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">이 함수에 전달 된 pIter 인수는 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러에 전달 된 반복자이거나 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()에&lt;/a&gt; 의해 작성된 반복자 일 수 있습니다. 후자의 경우, &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()에&lt;/a&gt; 대한 가장 최근 호출은 SQLITE_ROW를 리턴해야합니다. 또한 반복자가 현재 가리키는 변경 유형이 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; 인 경우에만 호출 될 수 있습니다 . 그렇지 않으면이 함수는&lt;a href=&quot;../rescode#misuse&quot;&gt; SQLITE_MISUSE를&lt;/a&gt; 하고 * ppValue를 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNext 필드는 sqlite3_vfs 구조에서 SQLite가 수정할 유일한 필드입니다. SQLite는 특정 정적 뮤텍스를 보유한 상태에서만이 필드에 액세스하거나 수정합니다. 객체가 등록되면 응용 프로그램은 sqlite3_vfs 객체 내에서 아무것도 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext 필드는 SQLite에 의해 내부적으로 사용됩니다. 특히 SQLite는이 필드를 사용하여 등록 된 VFS의 링크 된 목록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry 구조의 pUser 및 xDelUser 멤버는 초기에 NULL로 설정됩니다. pUser 변수는 콜백 구현에 의해 동일한 쿼리 내에서 후속 콜백 호출에 유용 할 수있는 임의의 값으로 설정 될 수 있습니다 (예 : 영역 교차를 테스트하는 데 사용되는 복잡한 데이터 구조에 대한 포인터). xDelUser 변수가 NULL이 아닌 값으로 설정되면 쿼리 실행이 완료된 후 SQLite는 pUser 변수의 값을 유일한 인수로 사용하여 자동으로 호출합니다. 즉, xDelUser는 pUser 값에 대한 소멸자 함수로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">페이지 캐시는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config에서&lt;/a&gt; 제공 한 자체 메모리 풀에서 할당합니다 ( &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 는 힙이 아닌 , ...)가 합니다.</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">페이지 캐시는 &lt;a href=&quot;config&quot;&gt;sqlite3_config에서&lt;/a&gt; 제공 한 자체 메모리 풀에서 할당합니다 ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 는 힙이 아닌 , ...)가 합니다.</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">데이터베이스 파일의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">이것과 관련된 데이터베이스 페이지의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">자동 진공 또는 증분 진공 모드에있을 때 가장 큰 루트 b- 트리 페이지의 페이지 번호. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">이 행을 찾은 페이지의 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma를&lt;/a&gt; 사용하여 페이지 크기 및 캐시 크기를 런타임에 설정하거나 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">가져올 페이지는 키로 결정됩니다. 최소 키 값은 1입니다. xFetch를 사용하여 검색 한 후에는 페이지가 &quot;고정 된&quot;것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">페이지 캐시 메모리 할당자는 기본적으로 비활성화되어 있습니다. 응용 프로그램은 다음과 같이 시작시에 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">호출기 및 btree 하위 시스템이 다시 추가되었습니다. 현재 유일하게 사용 가능한 백엔드입니다.</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">페이저는 B- 트리, 텍스트 인코딩, 인덱스 등의 세부 사항에 대해서는 신경 쓰지 않습니다. 호출기의 관점에서 데이터베이스는 단일 크기의 블록으로 구성된 단일 파일로 구성됩니다. 각 블록을 &quot;페이지&quot;라고하며 일반적으로 크기는 1024 바이트입니다. 페이지 번호는 1부터 시작하여 번호가 매겨집니다. 따라서 데이터베이스의 첫 1024 바이트를 &quot;페이지 1&quot;이라고하고 두 번째 1024 바이트를 &quot;페이지 2&quot;라고합니다. 다른 모든 인코딩 세부 사항은 상위 계층의 라이브러리에서 처리됩니다. 호출기는 여러 모듈 중 하나를 사용하여 운영 체제와 통신합니다 (예 : &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; , &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; 는 운영 체제 서비스에 대한 균일 한 추상화를 제공하는 )를 합니다.</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">호출기 모듈은 별도의 스레드 또는 별도의 프로세스 또는 둘 다에 대한 액세스를 효과적으로 제어합니다. 이 문서 전체에서 &quot;프로세스&quot;라는 단어가 작성 될 때마다 문장의 진실을 변경하지 않고 &quot;스레드&quot;라는 단어를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">호출기 모듈은 매우 견고하지만 파괴 할 수 있습니다. 이 섹션에서는 위험을 식별하고 설명하려고합니다. ( &lt;a href=&quot;atomiccommit&quot;&gt;원자 커밋&lt;/a&gt; 에 대한 기사의 &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;잘못된&lt;/a&gt; 부분 도 참조하십시오.) .</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">위의 단락은 오른쪽 피연산자로 간단한 용어가있는 MATCH 연산자가 지정된 용어가 포함 된 모든 문서에 대해 true로 평가됨을 나타냅니다. 이와 관련하여, &quot;문서&quot;는 왼쪽 피연산자로 사용 된 식별자에 따라 FTS 테이블 행의 단일 열에 저장된 데이터 또는 단일 행의 모든 ​​열의 내용을 나타낼 수 있습니다. MATCH 연산자에게. MATCH 연산자의 왼쪽 피연산자로 지정된 식별자가 FTS 테이블 열 이름 인 경우 검색어를 포함해야하는 문서는 지정된 열에 저장된 값입니다. 그러나 식별자가 FTS의 이름 인 경우</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">매개 변수 P는 콜백 함수 X에 유일한 매개 변수로 전달됩니다. 매개 변수 N은 대략적인 &lt;a href=&quot;../opcode&quot;&gt;가상 머신 명령어 수입니다.&lt;/a&gt; 콜백 X의 연속 호출 사이에서 평가 N이 1보다 작 으면 진행 핸들러가 사용되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">매개 변수 P는 콜백 함수 X에 유일한 매개 변수로 전달됩니다. 매개 변수 N은 콜백 X의 연속 호출 사이에서 평가 되는 대략적인 &lt;a href=&quot;opcode&quot;&gt;가상 머신 명령어&lt;/a&gt; 수입니다. N이 1보다 작 으면 진행 핸들러가 사용되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">콜백에 대한 매개 변수는 pArg 값, 현재 사용중인 메모리 양 및 콜백을 유발 한 할당 크기입니다. 콜백은 아마도 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 하여 메모리 공간을 확보합니다. 콜백은 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()을&lt;/a&gt; 호출 할 수 있지만 호출하면 재귀 호출에 의해 추가 콜백이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">부모 및 하위 쿼리에는 WHERE 절이 포함될 수 있습니다. 규칙 (11), (12) 및 (13)에 따라 ORDER BY, LIMIT 및 OFFSET 절이 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">외래 키 제약 조건에 명명 된 부모 키 열은 부모 테이블의 기본 키가 아니며 CREATE TABLE에 지정된 조합 시퀀스를 사용하는 고유 제약 조건이 적용되지 않습니다. 또는</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">외래 키 제약 조건에 명명 된 부모 키 열이 존재하지 않거나</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">부모 테이블이 존재하지 않거나</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">파서는 컨텍스트에 따라 토큰에 의미를 할당합니다. SQLite 용 파서는 &lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기를&lt;/a&gt; 사용하여 생성 됩니다. 레몬은 YACC / BISON과 동일한 작업을 수행하지만 오류가 덜 발생하는 다른 입력 구문을 사용합니다. 레몬은 재진입 및 스레드 안전 파서를 생성합니다. 그리고 레몬은 구문 오류가 발생했을 때 메모리가 누출되지 않도록 비단 말 소멸자의 개념을 정의합니다. 레몬을 구동하고 SQLite가 이해하는 SQL 언어를 정의하는 문법 파일은 &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y에 있습니다.&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">파서는 이제 명령문을 실행하기 전에 세미콜론 또는 입력 끝을 보도록 요구합니다. UPDATE 또는 DELETE 문에서 WHERE 키워드의 철자가 틀리면 우발적 인 재난을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite가 사용하는 파서는 용서합니다. 구문 분석 모호성을 초래하지 않는 한 키워드를 식별자로 사용하는 것이 종종 가능합니다. 예를 들어 &quot;CREATE TABLE BEGIN (REPLACE, PRAGMA, END);&quot; SQLite에 의해 허용되며 &quot;REPLACE&quot;, &quot;PRAGMA&quot;및 &quot;END&quot;라는 3 개의 열이있는 &quot;BEGIN&quot;이라는 새 테이블을 만듭니다. 그럼에도 불구하고 모범 사례는 키워드를 식별자로 사용하지 않는 것입니다. 키워드 이름 충돌을 피하기 위해 사용되는 일반적인 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">파서의 스택이 매우 긴 UPDATE 문에서 오버플로되었습니다. 이제 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">SQL 문의 구문 분석은 모든 SQL 데이터베이스 엔진에서 CPU주기를 많이 소비합니다. SQLite를 최적화하려는 지속적인 노력으로 인해 개발자는 레몬을 조정하여 더 빠른 파서를 생성하는 데 많은 시간을 소비했습니다. 이러한 노력은 SQLite뿐만 아니라 모든 레몬 파서 생성기 사용자에게 도움이되었습니다. 그러나 레몬을 별도로 유지 관리 한 도구라면 SQLite와 레몬을 모두 조정하기가 더 어려웠으므로 결과적으로 많은 최적화가 이루어지지 않았을 것입니다. 따라서 파서 생성기 도구가 SQLite의 소스 트리에 포함되어 있다는 사실은 도구 자체와 SQLite 모두에게 순이익이되는 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">마지막 &quot;_&quot;이전의 이름 부분은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE을&lt;/a&gt; 사용하여 작성된 가상 테이블의 이름과 정확히 일치합니다 . (쉐도우 테이블은 시상 &lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수에&lt;/a&gt; 대해 인식되지 않습니다. .)</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">패치 레벨 Z는 역사적으로 적은 수의 코드 라인 만 변경 한 버그 수정 릴리스에만 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URI의 경로 구성 요소는 열 SQLite 데이터베이스 인 디스크 파일을 지정합니다. 경로 구성 요소가 생략되면 데이터베이스는 데이터베이스 연결이 닫힐 때 자동으로 삭제되는 임시 파일에 저장됩니다. 권한 섹션이 있으면 경로는 항상 절대 경로 이름입니다. 권한 섹션이 생략 된 경우 경로는 &quot;/&quot;문자 (ASCII 코드 0x2f)로 시작하면 절대 경로 이름이고 그렇지 않으면 상대 경로 이름입니다. Windows에서 절대 경로가 &quot; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt; : /&lt;/b&gt; &quot; 로 시작하면 &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; 는 임의의 단일 ASCII 알파벳 문자 ( &quot;a&quot;- &quot;z&quot;또는 &quot;A&quot;- &quot;Z&quot;)이고 &quot;&lt;b&gt;&lt;i&gt; X :&lt;/i&gt;&lt;/b&gt;&quot;는 최상위 디렉토리가 아니라 파일을 포함하는 볼륨의 드라이브 문자로 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">권한이 있으면 경로는 선택 사항입니다. 권한이 생략되면 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">기본 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 에서 사용되는 패턴 일치 알고리즘SQLite의 구현은 특정 병리학 적 사례에 대해 O (N &amp;amp; sup2) 성능 (여기서 N은 패턴의 문자 수임)을 나타낼 수 있습니다. 자체 LIKE 또는 GLOB 패턴을 지정할 수있는 잘못된 작성기의 서비스 거부 공격을 피하기 위해 LIKE 또는 GLOB 패턴의 길이는 SQLITE_MAX_LIKE_PATTERN_LENGTH 바이트로 제한됩니다. 이 한계의 기본값은 50000입니다. 최신 워크 스테이션은 50000 바이트의 병리학 적 LIKE 또는 GLOB 패턴도 비교적 빠르게 평가할 수 있습니다. 서비스 거부 문제는 패턴 길이가 수백만 바이트에 도달 할 때만 작동합니다. 그럼에도 불구하고 가장 유용한 LIKE 또는 GLOB 패턴의 길이는 최대 수십 바이트이므로편집증 응용 프로그램 개발자는 외부 사용자가 임의의 패턴을 생성 할 수 있음을 알고있는 경우이 매개 변수를 수백 대의 범위로 줄이려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">people 테이블에는 대규모 조직의 각 사용자마다 하나의 항목이 있습니다. 각 역할은 &quot;역할&quot;필드에 의해 결정되는 &quot;학생&quot;또는 &quot;교사&quot;입니다. 그리고 우리는 각 사람의 키를 센티미터 단위로 기록합니다. 역할과 높이가 색인됩니다. 인덱스의 가장 왼쪽 열은 선택 사항이 아니며 두 개의 가능한 값만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">연결 별 통계는 전역 변수를 사용하지 않으므로 업데이트하거나 액세스하기 위해 뮤텍스가 필요하지 않습니다. 결과적으로 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 꺼져 있어도 연결 별 통계는 계속 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">다음 차트와 같이 SQL 계층을 무시하고 &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 인터페이스를 사용하여 직접 Blob 내용을 읽어 성능을 약간 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">SQLite 데이터베이스에서 작업 할 때 open () 및 close () 시스템 호출은 한 번만 호출되는 반면에 open () 및 close ()는 저장된 blob을 사용할 때 각 blob에 대해 한 번 호출되므로 성능 차이가 발생합니다. 개별 파일. open () 및 close () 호출의 오버 헤드가 데이터베이스 사용의 오버 헤드보다 큰 것 같습니다. 크기 감소는 개별 파일이 파일 시스템 블록 크기의 다음 배수로 채워지는 반면 블롭은 SQLite 데이터베이스에 더 밀접하게 압축되어 있기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">순열은 OPFLAG_PERMUTE 비트가 P5에 설정된 다음 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 까지만 유효합니다 . 일반적으로 &lt;a href=&quot;opcode#Permutation&quot;&gt;순열&lt;/a&gt; 은 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 직전에 발생해야합니다 .</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WAL 모드의 지속성은 응용 프로그램 자체를 변경하지 않고도 WAL 모드에서 SQLite를 사용하여 응용 프로그램을 변환 할 수 있음을 의미합니다. &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 또는 기타 유틸리티를 사용하여 데이터베이스 파일에서 &quot; &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; &quot;을 실행 한 다음 응용 프로그램을 다시 시작하면됩니다.</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">&quot;VALUES (</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">플래너는 알 수없는 조합 함수가있는 인덱스를 사용하는 쿼리 계획을 피합니다.</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">플래너는 쿼리의 가장 오른쪽 조인이 아니더라도 사용되지 않은 LEFT JOIN을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">이러한 테스트에 사용되는 플랫폼은 1GB 또는 메모리 및 IDE 디스크 드라이브가있는 1.6GHz Athlon입니다. 운영 체제는 스톡 커널이있는 RedHat Linux 7.2입니다.</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">요점은 이것입니다. SQL 데이터베이스 스키마는 거의 항상 테이블과 데이터 구조 및 관계를 정의하고 구성하는 데 훨씬 더 나은 작업을 수행합니다. 명확하고 간결하며 명확하게 정의 된 표현을 사용하면 거의 항상 응용 프로그램의 성능이 향상되고 문제가 적으며 개발 및 유지 관리가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()에&lt;/a&gt; 대한 포인터 인수 는 NULL이거나 아직 릴리스되지 않은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 의 이전 호출에서 얻은 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()에&lt;/a&gt; 대한 포인터 인수 는 NULL이거나 아직 릴리스되지 않은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 의 이전 호출에서 얻은 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">포인터 유형은 유연하고 동적이 아닙니다. 포인터 유형은 디자인 타임 상수입니다. 응용 프로그램은 런타임에 포인터 유형 문자열을 합성해서는 안됩니다. 동적 포인터 유형 문자열을 지원하면 개발자가 런타임 합성 포인터 유형 문자열을 생성하여 포인터 전달 인터페이스를 잘못 사용할 수 있습니다. 포인터 유형 문자열을 정적으로 요구하면 개발자는 디자인 타임에 고정 포인터 유형 이름을 선택하고 해당 이름을 상수 문자열로 인코딩하여 올바른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">리턴 된 포인터는 위에서 설명한대로 유형 변환이 발생하거나 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 호출 될 때까지 유효합니다 . 문자열 및 BLOB를 보유하는 데 사용되는 메모리 공간이 자동으로 해제됩니다. 반환 된 포인터를 통과하지 마십시오 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob을 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; 에 등을 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">리턴 된 포인터는 위에서 설명한대로 유형 변환이 발생하거나 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 호출 될 때까지 유효합니다 . 문자열 및 BLOB를 보유하는 데 사용되는 메모리 공간이 자동으로 해제됩니다. 반환 된 포인터를 통과하지 마십시오 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob을 ()&lt;/a&gt; , &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; 에 등을 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 인터페이스를 사용하여 SQL NULL 값을 피기 백하는 포인터 는 일시적이며 일시적입니다. 포인터는 데이터베이스에 쓰여지지 않습니다. 포인터는 정렬 후에도 유지되지 않습니다. 후자의 사실은 sqlite3_column_pointer () 인터페이스가없는 이유입니다. 쿼리 플래너가 쿼리에서 값을 반환하기 전에 정렬 작업을 삽입할지 여부를 예측할 수 없기 때문에 포인터 값을 알 수 없습니다. &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; 의해 쿼리에 삽입 되면 결과 집합까지 살아남을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">포터 토크 나이 저는 래퍼 토크 나이저입니다. 다른 토크 나이저의 출력을 가져와 &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;포터 형태소 분석 알고리즘&lt;/a&gt; 을 각 토큰에 적용하여 FTS5에 반환합니다. 이를 통해 &quot;수정&quot;과 같은 검색어가 &quot;수정 됨&quot;또는 &quot;수정 됨&quot;과 같은 유사한 단어와 일치 할 수 있습니다. 포터 형태소 분석 알고리즘은 영어 용어에만 사용하도록 설계되었습니다. 다른 언어와 함께 사용하면 검색 유틸리티가 향상되거나 향상되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">이론적으로 SQLite 데이터베이스의 힘은 사용자 정의 파일 형식을 사용하여 달성 할 수 있습니다. 그러나 관계형 데이터베이스만큼 표현적인 사용자 정의 파일 형식은 구현하려면 막대한 설계 사양과 수만 또는 수십만 줄의 코드가 필요할 수 있습니다. 그리고 최종 결과는 특수 도구 없이는 액세스 할 수없는 &quot;불투명 한 얼룩&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI filename으로&lt;/a&gt; &quot;psow&quot;쿼리 매개 변수를 사용하여 데이터베이스를 열면 개별 데이터베이스의 powersafe 겹쳐 쓰기 특성을 지정할 수 있습니다 . 예를 들어, 파일의 전원 안전 덮어 쓰기를 항상 가정하려면 (최대 쓰기 성능을 보장하기 위해) 다음과 같이여십시오.</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe 덮어 쓰기 속성은 쓰여진 바이트의 상태에 대해 아무 것도 말하지 않습니다. 해당 바이트에는 이전 값, 새 값, 임의 값 또는 이들의 조합이 포함될 수 있습니다. powersafe 덮어 쓰기 속성은 단순히 쓰기가 쓴 바이트 범위 밖의 바이트를 변경할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragma 명령은 SQLite에만 적용되며 다른 SQL 데이터베이스 엔진과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">pragma는 UNIQUE 제약 조건을 확인하지 않고 인덱스 내용이 테이블 내용과 일치하는지 확인하지 않는다는 점을 제외하면 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; 와 같습니다. UNIQUE 및 인덱스 일관성 검사를 건너 뛰어 quick_check는 integrity_check보다 훨씬 빠르게 실행될 수 있습니다. 그렇지 않으면 두 pragma는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">사전 업데이트 후크</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">사전 업데이트 후크.</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">적대적인 입력으로 SQLite를 안전하게 사용하기 위해 위의주의 사항은 필요하지 않습니다. 그러나 제로 데이 익스플로잇에 대한 추가 방어 계층을 제공하며 신뢰할 수없는 소스의 데이터를 SQLite로 전달하는 응용 프로그램에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">ON CONFLICT 절의 우선 순위 순서가 변경되어 BEGIN 문의 ON CONFLICT 절이 제한 조건의 ON CONFLICT 절보다 우선 순위가 높습니다.</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">이전 단락에는 많은 정보가 포함되어 있습니다. 새로운 Vite for SQLite 구성 작업을 쉽게하기 위해 다음과 같은 구현 점검 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">정밀도 필드 (있는 경우)는 단일 &quot;.&quot;으로 구분 된 너비를 따라야합니다. 캐릭터. 너비가 없으면 &quot;.&quot; 정밀도는 즉시 플래그 (있는 경우) 또는 초기 &quot;%&quot;를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">선호되는 루틴은 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 입니다. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스는 기존과 피해야한다. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 에는 특별한 목적으로 사용되는 추가 &quot;prepFlags&quot;옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">선호되는 루틴은 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 입니다. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스는 기존과 피해야한다. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 에는 특별한 목적으로 사용되는 추가 &quot;prepFlags&quot;옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windows에서 임시 파일 이름의 접두사가 &quot;sqlite&quot;에서 &quot;etilqs&quot;로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">사용중인 핸들러가 있다고해서 잠금 경합이있을 때 호출되는 것은 아닙니다. SQLite가 사용중인 처리기를 호출하면 교착 상태가 발생할 수 있다고 판단하면 사용중인 처리기 를 호출하는 대신 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 응용 프로그램에 반환 합니다 . 하나의 프로세스가 예약 잠금으로 승격시키려는 읽기 잠금을 보유하고 있고 두 번째 프로세스가 독점 잠금으로 승격하려는 예약 된 잠금을 보유하는 시나리오를 고려하십시오. 첫 번째 프로세스는 두 번째 프로세스에 의해 차단되었으므로 진행할 수 없으며 두 번째 프로세스는 첫 번째 프로세스에 의해 차단되었으므로 진행할 수 없습니다. 두 프로세스 모두 사용중인 처리기를 호출하면 어느 쪽도 진행되지 않습니다. 따라서 SQLite는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 반환 합니다.첫 번째 프로세스의 경우 첫 번째 프로세스가 읽기 잠금을 해제하고 두 번째 프로세스가 진행될 수 있기를 희망합니다.</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">사용중인 핸들러가 있다고해서 잠금 경합이있을 때 호출되는 것은 아닙니다. SQLite가 사용중인 처리기를 호출하면 교착 상태가 발생할 수 있다고 판단하면 사용중인 처리기 를 호출하는 대신 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 응용 프로그램에 반환 합니다 . 하나의 프로세스가 예약 잠금으로 승격시키려는 읽기 잠금을 보유하고 있고 두 번째 프로세스가 독점 잠금으로 승격하려는 예약 된 잠금을 보유하는 시나리오를 고려하십시오. 첫 번째 프로세스는 두 번째 프로세스에 의해 차단되었으므로 진행할 수 없으며 두 번째 프로세스는 첫 번째 프로세스에 의해 차단되었으므로 진행할 수 없습니다. 두 프로세스 모두 사용중인 처리기를 호출하면 어느 쪽도 진행되지 않습니다. 따라서 SQLite는 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 반환 합니다.첫 번째 프로세스의 경우 첫 번째 프로세스가 읽기 잠금을 해제하고 두 번째 프로세스가 진행될 수 있기를 희망합니다.</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">핫 저널이 존재한다는 것은 이전 프로세스가 트랜잭션을 커밋하려고했지만 커밋이 완료되기 전에 어떤 이유로 중단되었음을 나타냅니다. 핫 저널은 데이터베이스 파일이 일관성이없는 상태이며 사용하기 전에 롤백하여 복구해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">인덱스의 sqlite_stat1.stat 필드에 &quot;noskipscan&quot;토큰이 있으면 해당 인덱스가 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 와 함께 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">위의 쿼리 플래너 문제의 표현은 단순화되었습니다. 비용은 추정치입니다. 실제로 루프를 실행할 때까지 루프를 실행하는 데 드는 실제 비용이 얼마인지 알 수 없습니다. SQLite는 WHERE 절에있는 인덱스 및 제약 조건의 가용성을 기반으로 루프 실행 비용을 추측합니다. 이러한 추측은 일반적으로 꽤 좋지만 때로는 꺼져있을 수 있습니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 사용하여 데이터베이스에 대한 추가 통계 정보를 수집하면 때때로 SQLite가 비용을 더 잘 추측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">사전 업데이트 후크 인터페이스는 원래 &lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 확장 을 지원하기 위해 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">사전 갱신 후크는 실제 데이터베이스 테이블의 변경에 대해서만 실행됩니다. &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 또는 sqlite_master 또는 sqlite_stat1과 같은 시스템 테이블 을 변경하기 위해 사전 갱신 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">사전 갱신 후크는 실제 데이터베이스 테이블의 변경에 대해서만 실행됩니다. &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 또는 sqlite_master 또는 sqlite_stat1과 같은 시스템 테이블 을 변경하기 위해 사전 갱신 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">이전 토론에서는 검색과 정렬을 별도의 주제로 취급했습니다. 그러나 실제로는 검색과 정렬을 동시에 원하는 경우가 종종 있습니다. 다행히도 단일 인덱스를 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">앞의 예는보다 일반적인 문제의 특정 경우입니다. SQLite 데이터베이스의 상태는 데이터베이스 파일과 저널 파일 모두에 의해 제어됩니다. 대기 상태에서 저널 파일은 존재하지 않으며 데이터베이스 파일 만 중요합니다. 그러나 저널 파일이 존재하면 손상을 피하기 위해 데이터베이스와 함께 보관해야합니다. 다음 조치는 모두 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">이전 예제는 $ query_polygon 매개 변수에서 _shape가 다각형과 겹치는 모든 행을 리턴합니다. geopoly_within () 함수는 비슷하게 작동하지만 $ query_polygon 내에 _shape가 완전히 포함 된 행만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">이전 예에서 SQLite는 인덱스 &quot;i1&quot;을 사용하여 (a =?) 형식의 WHERE 절 용어를 최적화합니다 (이 경우 &quot;a = 1&quot;). 이전 예제에서는 &lt;a href=&quot;queryplanner#covidx&quot;&gt;포함 인덱스를&lt;/a&gt; 사용할 수 없지만 다음 예제는 사용할 수 있으며 그 사실은 출력에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">이전 수정은 옳지 않았습니다. 이것은 더 잘 작동하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">이전 단락에서는 동기식 pragma 설정이 &quot;full&quot;일 때 발생하는 상황에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">이전 단락에서 (별도의 데이터베이스 연결이 하나에서 서로 분리되어)도 마찬가지입니다 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 만큼 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTED 프라 그마&lt;/a&gt; 남아 꺼져. &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTED pragma는&lt;/a&gt; 기본적으로 꺼져 있고 응용 프로그램을 켜 아무것도하지 않는 경우이를 해제 유지됩니다. 따라서 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma가&lt;/a&gt; 아니라면 가 기본 동작을 변경하는 데 사용 하나의 데이터베이스 연결에 의한 변경 사항은 기록기가 트랜잭션을 커밋 할 때까지 동일한 캐시를 공유하는 다른 데이터베이스 연결의 독자에게는 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">이전 단락에서는 SQLite가 섹터 쓰기가 원자 적이라고 가정하지 않습니다. 기본적으로 적용됩니다. 그러나 SQLite 버전 3.5.0부터는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; (Virtual File System) 인터페이스라는 새로운 인터페이스가 있습니다. 그만큼&lt;a href=&quot;vfs&quot;&gt; VFS&lt;/a&gt;SQLite가 기본 파일 시스템과 통신하는 유일한 방법입니다. 이 코드에는 Unix 및 Windows 용 기본 VFS 구현이 포함되어 있으며 런타임시 새로운 사용자 지정 VFS 구현을 생성하는 메커니즘이 있습니다. 이 새로운 VFS 인터페이스에는 xDeviceCharacteristics라는 메소드가 있습니다. 이 방법은 기본 파일 시스템을 조사하여 파일 시스템이 나타내거나 나타내지 않을 수있는 다양한 속성과 동작을 검색합니다. xDeviceCharacteristics 메소드는 섹터 쓰기가 원자적임을 나타내며, 그렇게 표시하면 SQLite가 해당 사실을 활용하려고 시도합니다. 그러나 Unix와 Windows의 기본 xDeviceCharacteristics 방법은 원자 섹터 쓰기를 나타내지 않으므로 이러한 최적화는 일반적으로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">이전 단락에서는 기본 SQLite 구성에서 임시 데이터베이스의 동작을 설명했습니다. 애플리케이션은 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 및 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수를 사용하여 원하는 경우 임시 데이터베이스가 순수한 인 메모리 데이터베이스로 작동하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">이전 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">이전 단계는 위 다이어그램에서 원 (1)을 작성했습니다. 이 단계는 원 (2)을 만듭니다. 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">기본 페이지 캐시 구현은 &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; 파일에 있습니다. &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 로직은 별도의 &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c에&lt;/a&gt; 있습니다. 메모리 내 캐싱은 &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; 파일로 구현됩니다 . 페이지 캐시 서브 시스템과 나머지 SQLite 간의 인터페이스는 헤더 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">레몬의 주요 용도는 SQL 언어 파서를 만드는 것입니다. 문법 파일 ( &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt; )은 레몬에 의해 parse.c 및 parse.h로 컴파일됩니다. parse.c 파일은 추가 수정없이 &lt;a href=&quot;amalgamation&quot;&gt;합병에&lt;/a&gt; 통합됩니다 .</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQL 데이터베이스 엔진의 주요 작업은 SQL의 SQL 문을 평가하는 것입니다. 이를 위해 개발자는 두 가지 객체가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3 / 4와 FTS5의 주요 차이점은 FTS3 / 4에서는 각 인스턴스 목록이 하나의 큰 데이터베이스 레코드로 저장되는 반면 FTS5에서는 큰 인스턴스 목록이 여러 데이터베이스 레코드로 구분된다는 것입니다. 이는 큰 목록을 포함하는 큰 데이터베이스를 처리 할 때 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLite의 printf ()는 SQLite 및 SQLite를 사용하는 응용 프로그램 모두에 유용한 새로운 비표준 대체 유형 ( &lt;a href=&quot;printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;printf#percentw&quot;&gt;% w&lt;/a&gt; 및 &lt;a href=&quot;printf#percentz&quot;&gt;% z&lt;/a&gt; )을 지원합니다. 표준 라이브러리 printf ()는 일반적으로 이런 방식으로 확장 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">printf (FORMAT, ...) SQL 함수 는 표준 C 라이브러리 의 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; C 언어 함수 및 printf () 함수와 같이 작동합니다. 첫 번째 인수는 후속 인수에서 가져온 값을 사용하여 출력 문자열을 구성하는 방법을 지정하는 형식 문자열입니다. FORMAT 인수가 없거나 NULL이면 결과는 NULL입니다. % n 형식은 자동으로 무시되며 인수를 사용하지 않습니다. % p 형식은 % X의 별칭입니다. % z 형식은 % s와 호환됩니다. 인수 목록에 인수가 너무 적은 경우 누락 된 인수는 NULL 값을 갖는 것으로 가정하며, 숫자 형식의 경우 0 또는 0.0으로 변환되거나 % s의 경우 빈 문자열입니다. 자세한 내용은 &lt;a href=&quot;printf&quot;&gt;내장 printf ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">개인 메모리 셀은 처음 두 명령에 의해 NULL로 초기화됩니다. 명령어 2에서 13까지는 examp2 테이블에 대해 내부 SELECT 문을 구현합니다. 결과를 콜백으로 보내거나 결과를 분류기에 저장하는 대신, 명령 결과는 명령 10에 의해 메모리 셀로 푸시되고 명령 11에 점프하면 루프가 중단됩니다. 흔적이며 절대로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">문제는 인덱스의 품질이 동일하지 않다는 것입니다. 체크인시 한 명의 자녀 만있을 수 있습니다. 따라서 PLINK_I1의 첫 번째 필드는 일반적으로 검색 범위를 단일 행으로 좁 힙니다. 그러나 &quot;trunk&quot;로 태그 된 수천 및 수천 개의 체크인이 있으므로 TAGXREF_I1의 첫 번째 필드는 검색 범위를 좁히는 데 거의 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">동적 메모리 할당 문제, 특히 메모리 할당 자 고장 문제는 JM Robson에 의해 연구되었으며 그 결과는 다음과 같이 발표되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">최상의 쿼리 계획을 찾는 문제는 각 노드를 정확히 한 번 방문하는 그래프를 통해 최소 비용 경로를 찾는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">이 문제는 2011 년 2 월 20 일에 해결되었습니다. 이 수정은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;버전 3.7.6&lt;/a&gt; (2011-04-12) 에서 처음 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">rowid로 정보를 찾는 데있어 문제점은 아마도 &quot;항목 4&quot;의 가격이 무엇인지 상관하지 않을 것입니다. 복숭아의 가격을 알고 싶어합니다. 따라서 rowid 조회는 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">이 후자의 쿼리의 문제점은 contains_in () 함수를 demo_data 테이블의 수백만 개의 항목에 적용해야한다는 것입니다. 두 번째 쿼리에서 R * Tree를 사용하면 contains_in () 함수에 대한 호출 수가 전체 테이블의 작은 하위 집합으로 줄어 듭니다. R * Tree 색인은 정확한 답변 자체를 찾지 못했으며 검색 공간 만 제한했습니다.</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">탐지하는 데 사용되는 절차</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">프로세스는 &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">progress 콜백은 긴 쿼리의 상태를 표시하거나 긴 쿼리 중에 GUI 이벤트를 처리하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">진행 핸들러 콜백은 진행 핸들러를 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 참고 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">진행 핸들러 콜백은 진행 핸들러를 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 참고 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">위에서 설명한 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 및 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령 의 속성은 외래 키가 활성화 된 경우에만 적용됩니다. 사용자가이를 바람직하지 않다고 생각하는 경우, 해결 방법은 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 를 사용하여 DROP 또는 ALTER TABLE 명령을 실행하기 전에 외래 키 제약 조건을 비활성화하는 것입니다. 물론 외래 키 제약 조건이 비활성화되어 있지만 사용자가 외래 키 제약 조건을 위반하여 내부적으로 일관성이없는 데이터베이스를 만드는 것을 막을 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">WHERE 절에서 LEFT JOIN의 오른쪽 테이블 열이 NULL이 아니어야하는지 여부를 결정하는 증명자는 불완전합니다. 때로는 거짓 부정을 반환합니다. 다시 말해, 실제로 가능할 때 LEFT JOIN의 강도를 낮추지 못하는 경우가 있습니다. 예를 들어, 증명 인은 &lt;a href=&quot;lang_datefunc&quot;&gt;datetime () SQL 함수&lt;/a&gt; 가 첫 번째 인수가 NULL 인 경우 항상 NULL을 리턴한다는 것을 알지 못하므로 다음 쿼리에서 LEFT JOIN이 강도 감소 될 수 있음을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psow query 매개 변수 는 열려있는 데이터베이스 파일 의 &lt;a href=&quot;psow&quot;&gt;powersafe 겹쳐 쓰기&lt;/a&gt; 특성을 대체합니다 . psow query 매개 변수는 기본 창 및 유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS에서 작동&lt;/a&gt; 하지만 다른 독점 또는 비표준 VFS에서는 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads 인터페이스는 pthread_cond_wait () 함수를 제공합니다. 이 기능을 사용하면 호출자가 동시에 뮤텍스를 해제하고 비동기 신호를 기다릴 수 있습니다. 이 함수, &quot;fired&quot;플래그 및 뮤텍스를 사용하여 위에서 설명한 경쟁 조건을 다음과 같이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads 라이브러리는 SQLite 스레드 안전을 위해 필요합니다. 그러나 CLI는 단일 스레드이므로 SQLite에 스레드 안전 모드로 빌드하도록 지시하여 pthreads 라이브러리를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">마스터 저널의 목적은 다중 파일 트랜잭션이 전력 손실에 걸쳐 원 자성이되도록하는 것입니다. 그러나 데이터베이스 파일에 전원 손실 이벤트에서 무결성을 손상시키는 다른 설정 (예 : &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt; )이있는 경우 마스터 저널 작성이 최적화로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">다른 파일과 폴더의 목적은 현재 저자에게 알려지지 않았지만 알아 내기 어려운 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">wal-index의 목적은이 질문에 빨리 답하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">이 문서의 목적은 네 번째 범주의 응용 프로그램 파일 형식 인 SQLite 데이터베이스 파일을 선호하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">이 문서의 목적은 SQLite 개발 팀이 SQLite 소프트웨어를 지속적으로 향상시키고 이미 높은 안정성을 향상시키기 위해 노력하면서 매일 SQLite 개발 팀이 어떻게 작동하는지에 대해 간략하게 설명하는 것입니다. 이 문서를 숙지 한 후 유능한 개발자를 개발 팀에 신속하게 동화시킬 수 있다면이 문서의 목적을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">푸시 다운 최적화를 항상 사용할 수있는 것은 아닙니다. 예를 들어, 부속 조회에 LIMIT가 포함 된 경우 외부 조회에서 WHERE 절의 일부를 누르면 내부 조회 결과가 변경 될 수 있습니다. 이 최적화를 구현하는 pushDownWhereTerms () 루틴에 대한 소스 코드의 주석에 설명 된 다른 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">품질 관리 계획은 원래 DO-178B의 섹션 11 (48-56 페이지)에서 출력에 대한 설명을 살펴보고 SQLite와 관련이있는 것으로 보이는 요소를 작성하여 구성되었습니다. SQLite 품질 프로세스 향상을 추적하기 위해 텍스트가 계속 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; 함수를 사용하여 각 쿼리에 나타나는 쿼리 용어 인스턴스 수를 결정하여 위 쿼리를 더 빠르게 실행할 수 있습니다 . matchinfo 함수는 오프셋 함수보다 훨씬 효율적입니다. 또한 matchinfo 함수는 현재 행뿐만 아니라 전체 문서 세트에서 각 쿼리 용어의 전체 발생 수 및 각 쿼리 용어가 나타나는 문서 수에 대한 추가 정보를 제공합니다. 이것은 예를 들어 덜 일반적인 용어에 더 높은 가중치를 부여하여 사용자가 더 흥미롭게 생각하는 결과의 전체 계산 된 관련성을 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">위의 쿼리는 행 값을 사용하지 않고 조인으로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">위의 쿼리는 $ prefix로 시작하는 전체 입력 단어에 대한 제안을 반환합니다. $ wholeline 매개 변수는 줄의 시작 부분부터 삽입 지점까지의 모든 텍스트입니다. $ wholeline 매개 변수는 컨텍스트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">po_parent 인덱스에 관심있는 모든 행에 대한 항목이 포함되어 있으므로 위의 쿼리는 po_parent 인덱스를 사용하여 답을 찾는 데 도움이됩니다. po_parent가 전체 인덱스보다 작으므로 쿼리도 더 빠르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">R * Tree에 수백만 개의 항목이 포함되어 있어도 위의 쿼리는 id 1을 매우 빠르게 찾습니다. 앞의 내용은 &quot;포함 된&quot;쿼리의 예입니다. R * Tree는 &quot;겹치는&quot;쿼리도 지원합니다. 예를 들어 샬럿 영역과 겹치는 모든 경계 상자를 찾으려면</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI의 쿼리 구성 요소에는 SQLite 자체 또는 &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;사용자 지정 VFS 구현에&lt;/a&gt; 의해 해석되는 매개 변수가 포함될 수 있습니다 . SQLite 및 해당 내장 &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; 는 다음 쿼리 매개 변수를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI의 쿼리 구성 요소에는 SQLite 자체 또는 &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;사용자 지정 VFS 구현에&lt;/a&gt; 의해 해석되는 매개 변수가 포함될 수 있습니다 . SQLite 및 해당 내장 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 다음 쿼리 매개 변수를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">쿼리에는 WHERE 절의 검색 제한과 ORDER BY 절의 정렬 순서가 모두 포함되어 있습니다. 2 열 인덱스 Idx3을 사용하여 검색과 정렬을 동시에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">쿼리는 fruit = 'Orange'가있는 행의 하위 집합을 찾기 위해 인덱스에서 이진 검색을 수행합니다. (과일 열은 인덱스의 가장 왼쪽 열이므로 인덱스의 행은 정렬 된 순서로 정렬되므로 모든 행이 인접 해 있습니다.) 그런 다음 일치하는 인덱스 행을 위에서 아래로 스캔하여 행 ID를 가져옵니다. 원래 테이블을 사용하고 각 rowid에 대해 가격을 찾기 위해 원래 테이블에서 이진 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">검색어가 집계가 아닙니다</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">쿼리 루프는 명령어 5에서 13까지 작성됩니다. 명령어 6에서 8은 단일 콜백 호출에 대한 azData [] 값이 포함 된 레코드를 작성합니다. 정렬 키는 명령 9-11에 의해 생성됩니다. 명령 12는 호출 레코드와 정렬 키를 단일 항목으로 결합하고 해당 항목을 정렬 목록에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">쿼리 루프는 명령 8-22로 구현됩니다. GROUP BY 절에 지정된 집계 키는 명령 9 및 10에 의해 계산됩니다. 명령 11은 적절한 버킷에 초점을 맞 춥니 다. 주어진 키를 가진 버킷이 없으면 새 버킷이 생성되고 버킷을 초기화하는 명령 12 및 13으로 제어가 넘어갑니다. 버킷이 이미 존재하면 명령어 14로 이동합니다. 집계 함수의 값은 11과 21 사이의 명령어에 의해 업데이트됩니다. 명령어 14 ~ 18은 메모리 슬롯 1을 업데이트하여 다음 값 &quot;min (three + four)을 유지합니다. ) &quot; 그런 다음 &quot;4&quot;열의 합계는 명령 19에서 21까지 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">쿼리 최적화 프로그램은이를 세 가지 별도의 제약 조건으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">쿼리 최적화 프로그램은 이제 인덱스를 사용하여 ORDER BY 절을 구현하려고합니다. 적합한 색인이없는 경우 정렬은 여전히 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">쿼리 플래너는 ORDER BY의 비용을 추정 할 때 LIMIT 절을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">쿼리 플래너는 바인딩 된 매개 변수의 값을 검사하여 부분 인덱스를 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite의 쿼리 플래너는 일반적으로 SQL 문을 실행하기 위해 빠른 알고리즘을 선택하는 훌륭한 작업을 수행합니다. 이는 레거시 쿼리 플래너와 새 NGQP의 경우 더욱 그렇습니다. 불완전한 정보로 인해 쿼리 플래너가 차선책을 선택하는 경우가 가끔 있습니다. 이는 기존 쿼리 플래너보다 NGQP에서 덜 자주 발생하지만 여전히 발생할 수 있습니다. 이러한 드문 경우에만 응용 프로그램 개발자가 참여하여 쿼리 플래너가 올바른 작업을 수행하도록 도와야합니다. 일반적인 경우, NGQP는 SQLite의 새로운 개선 사항으로 응용 프로그램을 조금 더 빠르게 실행하며 새로운 개발자의 생각이나 행동이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">이후 버전의 SQLite에서 쿼리 플래너는 위와 같은 변환을 양방향으로 자동으로 수행 할 수있을 정도로 똑똑해질 수 있습니다. 즉, 향후 버전의 SQLite는 첫 번째 형식의 쿼리를 두 번째 형식으로 변환하거나 두 번째 방식으로 작성된 쿼리를 첫 번째 형식으로 변환 할 수 있습니다. SQLite 버전 3.22.0 (2018-01-22)부터 쿼리 플래너는 외부 쿼리가 결과 집합에서 사용자 정의 함수 또는 하위 쿼리를 사용하지 않으면 하위 쿼리를 병합합니다. 그러나 위에 표시된 예제의 경우 SQLite는 각 쿼리를 작성된대로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">쿼리 플래너에 사업자 IN 최적화 할 수있는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 짝수 경우 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex의&lt;/a&gt; 방법은 IN 연산자의 왼쪽에 가상 테이블 컬럼의 sqlite3_index_constraint_usage.omit 플래그를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">쿼리 플래너는 지속적 인덱스를 작성할 수없는 뷰 및 서브 쿼리에 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱스&lt;/a&gt; 를 사용하는 데 더 적극적 입니다.</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">쿼리 플래너는 이제 WHERE 절에 AND로 연결된 용어를 포함 하는 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">쿼리 플래너는 스키마를 읽을 때 통계 테이블의 내용을 메모리에로드합니다. 따라서 애플리케이션이 통계 테이블을 직접 변경하면 SQLite는 변경 사항을 즉시 인식하지 않습니다. 애플리케이션은 &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt; 를 실행하여 쿼리 플래너가 통계 테이블을 다시 읽도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">쿼리 플래너는이 쿼리의 가능한 여러 구현 중에서 결정해야하지만 특히 두 가지 계획이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">쿼리 플래너는 이제 &lt;a href=&quot;vtab&quot;&gt;가상 테이블의&lt;/a&gt; 제약 조건이 두 개 이상의 다른 조인 테이블에 분산되어있는 3 방향 이상의 조인에서 가상 테이블 액세스 를 최적화하는 작업을 개선 합니다.</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">쿼리 계획은 현재 사용 FROM 절 하위 쿼리를 구현하는 것을 선호 &lt;a href=&quot;optoverview#coroutines&quot;&gt;공동 루틴&lt;/a&gt; 대신 사용하여 &lt;a href=&quot;optoverview#flattening&quot;&gt;쿼리 병합&lt;/a&gt; 최적화. 서브 쿼리에 대한 코 루틴 사용에 대한 지원이 더 이상 비활성화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">쿼리 플래너는 이제 해당 열에 NOT NULL 제약 조건이 있더라도 LEFT JOIN의 오른쪽 테이블에있는 모든 열이 NULL 일 수 있음을 인식합니다. 이 경우 NULL 테스트를 최적화하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">쿼리 플래너는 이제 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 정보 ( &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE에&lt;/a&gt; 의해 생성됨 )를 사용하여 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 가 적절한 지 판단합니다.</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">쿼리 플래너 는 현재 연결 수명 동안 특정 시점에서 테이블의 하나 이상의 인덱스에 대해 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; 스타일 통계를 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">쿼리 플래너는 의미가있는 경우 기본 테이블의 전체 스캔 대신 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 전체 스캔을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">fruit = 'Peach'인 항목에 대해 Idx1 색인에서 이진 검색을 수행하여 쿼리를 시작합니다. SQLite는 Idx1의 행이 &quot;과일&quot;열을 기준으로 정렬되므로 Idx1 인덱스에서는이 바이너리 검색을 수행 할 수 있지만 원래 FruitsForSale 테이블에서는 수행 할 수 없습니다. fruit = 'Peach'인 Idx1 인덱스에서 행을 찾았 으면 데이터베이스 엔진은 해당 행의 rowid를 추출 할 수 있습니다. 그런 다음 데이터베이스 엔진은 원래 FruitsForSale 테이블에서 두 번째 이진 검색을 수행하여 fruit = 'Peach'가 포함 된 원래 행을 찾습니다. FruitsForSale 테이블의 행에서 SQLite는 가격 열의 값을 추출 할 수 있습니다. 이 절차는 &lt;a href=&quot;#fig5&quot;&gt;그림 5에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">쿼리 문자열은 선택 사항입니다. 쿼리 문자열이 있으면 모든 쿼리 매개 변수가 기본 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xOpen 메서드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">모호성을 제거하고 쿼리 용어에서 특수 문자를 이스케이프 할 수 있도록 필요한 경우 쿼리 구문이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragma는 사용 가능한 경우 데이터베이스 파일에 대한 모든 변경을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote (X) 함수는 SQL 문에 포함하기에 적합한 인수 값인 SQL 리터럴의 텍스트를 반환합니다. 문자열은 필요에 따라 내부 따옴표로 이스케이프 된 작은 따옴표로 묶습니다. BLOB는 16 진 리터럴로 인코딩됩니다. NUL 문자가 포함 된 문자열은 SQL에서 문자열 리터럴로 표현할 수 없으므로 반환 된 문자열 리터럴은 첫 번째 NUL 이전에 잘립니다.</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random () 함수는 32 비트 대신 64 비트의 임의성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random () 함수는 -9223372036854775808과 +9223372036854775807 사이의 의사 난수 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randomblob (N) 함수는 의사 난수 바이트가 포함 된 N 바이트 Blob을 반환합니다. N이 1보다 작 으면 1 바이트 랜덤 블롭이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">인덱스 내 열의 순위입니다. (0은 가장 왼쪽을 의미합니다. 키 열은 보조 열 앞에옵니다.)</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">인덱스 내 열의 순위입니다. (0은 가장 왼쪽을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">색인화되는 테이블 내의 열 순위 또는 색인 열이 색인화되는 테이블 의 행 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt; 인 경우 -1이고 &lt;a href=&quot;expridx&quot;&gt;색인이 표현식에있는&lt;/a&gt; 경우 -2 입니다.</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">인덱싱되는 테이블 내 열의 순위입니다. -1 값은 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 의미하고 -2 값은 &lt;a href=&quot;expridx&quot;&gt;표현식&lt;/a&gt; 이 사용되고 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">단어의 순위.</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">순위 옵션은 순위 열의 기본 보조 기능 매핑을 변경하는 데 사용됩니다. 옵션은 &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH?&quot;에&lt;/a&gt; 설명 된 것과 동일한 형식의 텍스트 값으로 설정해야합니다. 위의 조건. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">지난 5 년간 (2010-2015) SQLite의 향상률은 매년 약 6 씩 증가합니다. &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; 및 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number ()에&lt;/a&gt; 사용되는 번호 매기기 형식 은 최대 3.999.999까지의 버전을 허용하며 2050 년에 SQLite의 지원 종료 날짜에 충분합니다. 그러나 현재 타르볼 명명 규칙은 Y와 다운로드의 이름 형식은 약 2030 년에 수정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">이전 단락의 판독기 알고리즘은 올바르게 작동하지만 페이지 P의 프레임이 WAL 내의 어느 곳에 나 나타날 수 있기 때문에 판독기는 페이지 P 프레임을 찾기 위해 전체 WAL을 스캔해야합니다. WAL이 크면 (여러 메가 바이트가 일반적 임) 스캔 속도가 느려질 수 있으며 읽기 성능이 저하됩니다. 이 문제를 극복하기 위해 wal-index라는 별도의 데이터 구조가 유지되어 특정 페이지의 프레임을 신속하게 검색합니다.</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile (X) SQL 함수는 X라는 파일의 전체 컨텐츠를 읽고 해당 컨텐츠를 BLOB으로 리턴합니다. 컨텐츠를 테이블에로드하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">집계 쿼리가 실제로 두 개의 연속 루프라는 사실을 이해하면 SQL 쿼리 문의 WHERE 절과 HAVING 절의 차이점을 훨씬 쉽게 이해할 수 있습니다. WHERE 절은 첫 번째 루프에 대한 제한이며 HAVING 절은 두 번째 루프에 대한 제한입니다. 예제 쿼리에 WHERE 및 HAVING 절을 모두 추가하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray () 인터페이스는 메모리 할당 크기 계산에서 32 비트 정수 산술 오버플로를 피함으로써 다음 &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;하트 블러&quot;버그&lt;/a&gt; 를 방지하려는 노력으로 성장한 OpenBSD 커뮤니티의 최근 혁신 (2014 년경)입니다 . reallocarray () 함수에는 단위 크기 및 개수 매개 변수가 있습니다. 각 X 바이트 크기의 N 요소 배열을 보유하기에 충분한 메모리를 할당하기 위해 &quot;reallocarray (0, X, N)&quot;을 호출합니다. reallocarray ()는 X * N 곱셈이 오버플로 될 위험을 제거하고 malloc ()이 응용 프로그램과 다른 크기의 버퍼를 리턴하도록하기 때문에 &quot;malloc (X * N)&quot;을 호출하는 기존 기술보다 선호됩니다. 예상했다.</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">읽으려고하는 이유</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">문서를 FTS5 테이블에 삽입하면 전체 문서 색인에 항목이 추가되어 새 문서 내에서 각 토큰의 위치를 ​​기록합니다. 문서가 제거되면 전체 텍스트 인덱스에서 제거해야하는 항목 집합을 결정하기 위해 원본 데이터가 필요합니다. 따라서이 명령을 사용하여 행을 삭제할 때 FTS5에 제공된 데이터가 삽입 될 때 토큰 인스턴스 세트를 판별하는 데 사용 된 데이터와 다른 경우 일부 전체 텍스트 색인 항목이 올바르게 삭제되지 않거나 FTS5가 제거하려고 시도 할 수 있습니다 존재하지 않는 색인 항목. 이렇게하면 전체 텍스트 인덱스가 예측할 수없는 상태가되어 향후 쿼리 결과를 신뢰할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">그 이유 것을 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf가 ()&lt;/a&gt; ()는 Hipp 먼저 자신의 버전을 구현 한 표준 C 라이브러리에는 현재 snprintf () 루틴이 없었기 때문에 루틴 인 버퍼 포인터를 가지고 있으며, 표준 라이브러리의 현재 snprintf에서 발견되는 것과 반대로 크기 인수 버퍼, 그는 표준 C 라이브러리의 디자이너와 다른 순서를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">C가 SQLite를 구현하는 가장 좋은 언어 인 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">이 문제에 대한 권장 수정은 다른 파일 시스템을 선택하는 것입니다. 요즘에는 긴 파일 이름을 지원하는 고성능의 안정적인 특허없는 파일 시스템이 많이 있습니다. 가능하면 임베디드 장치는 이러한 다른 파일 시스템 중 하나를 사용하는 것이 좋습니다. 이로 인해 호환성 문제와 &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;8 + 3 파일 이름의 일관성없는 사용으로 인한 데이터베이스 손상&lt;/a&gt; 의 위험을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">권장 설정은 0이며, 큰 따옴표로 묶인 문자열은 모든 상황에서 허용되지 않습니다. 그러나 레거시 응용 프로그램과의 최대 호환성을 위해 기본 설정은 3입니다.</target>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">SQLite Archive를 생성, 업데이트, 나열 및 추출하는 권장 방법은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;버전 3.23.0&lt;/a&gt; (2018-04-02) 이상에 &lt;a href=&quot;cli&quot;&gt;sqlite3.exe 명령 줄 셸&lt;/a&gt; 을 사용하는 것 입니다. 이 CLI는 SQLite Archive를 쉽게 관리 할 수있는 -A 명령 줄 옵션을 지원합니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;버전 3.22.0&lt;/a&gt; (2018-01-22) 용 CLI 에는 SQLite Archives 관리를위한 &lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령&lt;/a&gt; 이 있지만 셸과 상호 작용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">레코드 형식은 위에 정의 된 64 비트 부호있는 정수 의 &lt;a href=&quot;fileformat2#varint&quot;&gt;가변 길이 정수&lt;/a&gt; 또는 &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; 표현을 광범위하게 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">레지스터 P3에 허용되는 최대 오류 수보다 하나가 적습니다. 최대 reg (P3) 오류가보고됩니다. 다시 말하면, reg (P1) 오류가 발견되는 즉시 분석이 중지됩니다. Reg (P1)는 남아있는 오류 수로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">레지스터 P1 ~ P1 + P2-1에는 단일 행의 결과가 포함됩니다. 이 opcode는 sqlite3_step () 호출이 SQLITE_ROW 리턴 코드로 종료되도록하며 sqlite3_stmt 구조를 설정하여 r (P1) .. r (P1 + P2-1) 값에 결과 행으로 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">설정 조작의 상대적 우선 순위가 다릅니다. 특히 표준 쿼리 구문을 사용하면 &quot;OR&quot;연산자가 &quot;AND&quot;보다 우선 순위가 높습니다. 표준 쿼리 구문을 사용할 때 연산자의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">릴리스 빌드는 생성 된 기계 코드의 유효성을 검증하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">릴리스 체크리스트는 지속적으로 발전하고 있습니다. 새로운 문제 나 잠재적 인 문제가 발견되면 새로운 점검 목록 항목이 추가되어 이후 릴리스에서 해당 문제가 나타나지 않도록합니다. 릴리스 체크리스트는 릴리스 프로세스 중에 간과되는 것이 없는지 확인하는 데 유용한 도구로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">릴리스 체크리스트는 자동화되지 않습니다. 개발자는 체크리스트의 각 항목을 수동으로 실행합니다. 우리는 인간을 반복적으로 유지하는 것이 중요하다는 것을 알게되었습니다. 테스트 자체가 통과되었지만 검사 목록 항목을 실행하는 동안 문제가 발견되는 경우가 있습니다. 인간이 테스트 결과를 가장 높은 수준으로 검토하고 지속적으로 &quot;정말입니까?&quot;라고 묻는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">문서의 관련성은 matchinfo의 반환 값에서 사용 가능한 데이터 이외의 다른 것에 의존 할 수 있습니다. 예를 들어, 데이터베이스의 각 문서에는 내용과 관련없는 요소 (원본, 저자, 나이, 참조 수 등)를 기반으로 정적 가중치가 할당 될 수 있습니다. 이러한 값은 응용 프로그램에 의해 별도의 테이블에 저장되어 하위 쿼리의 문서 테이블과 조인 될 수 있으므로 순위 함수가 해당 테이블에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLite의 신뢰성과 견고성은 부분적이고 철저한 테스트를 통해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">이 문서의 나머지 부분에서는 독자가 개인 브랜치를 유지 관리하는 데 필요한 단계를 안내합니다. 일반적인 아이디어는 위에서 설명한 것과 같습니다. 이 섹션은 더 자세한 내용 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 나머지 필드는 모두 기본 작업을 구현하는 함수에 대한 포인터를 저장합니다. 우리는 이것을 &quot;방법&quot;이라고 부릅니다. 첫 번째 방법 인 xOpen은 기본 스토리지 미디어에서 파일을 여는 데 사용됩니다. 결과는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체입니다. 파일을 읽고 쓰고 닫는 데 사용되는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 자체에 의해 정의 된 추가 방법 이 있습니다. 추가 방법은 아래에 자세히 설명되어 있습니다. 파일 이름은 UTF-8입니다. SQLite는 xOpen ()에 전달 된 zFilename 문자열이 xFullPathname ()에 의해 생성 된 전체 경로 이름이며 xClose ()가 호출 될 때까지 문자열이 유효하고 변경되지 않음을 보증합니다. 그래서 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;어떤 이유로 파일 이름을 기억 해야하는 경우 파일 이름에 대한 포인터를 저장할 수 있습니다. xOpen ()에 대한 flags 인자는 sqlite3_open_v2 ()에 대한 flags 인자의 복사본입니다. sqlite3_open () 또는 sqlite3_open16 ()이 사용되면 플래그는 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . XOPEN ()가 열리면 파일은 읽기 전용 다음은 설정 * pOutFlags를 포함 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . * pOutFlags의 다른 비트가 설정 될 수 있습니다. SQLite는 열린 객체에 따라 xOpen () 호출에 다음 플래그 중 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">이 구조로 정의 된 나머지 7 가지 메소드 (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld 및 xMutexNotheld)는 다음과 같은 인터페이스를 각각 구현합니다.</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">remove_diacritics 옵션은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacritics 옵션은 &quot;0&quot;, &quot;1&quot;또는 &quot;2&quot;로 설정 될 수 있습니다. 기본값은 &quot;1&quot;입니다. &quot;1&quot;또는 &quot;2&quot;로 설정되면 위에서 설명한대로 분음 부호가 라틴어 스크립트 문자에서 제거됩니다. 그러나 &quot;1&quot;로 설정하면 하나의 유니 코드 코드 포인트가 하나 이상의 분음 부호를 갖는 문자를 나타내는 데 사용되는 드문 경우에 분음 부호가 제거되지 않습니다. 예를 들어 분음 부호는 코드 포인트 0x1ED9에서 제거되지 않습니다 ( &quot;CIRCUMFLEX와 DOT 아래의 라틴 문자가 너무 작음&quot;). 이것은 기술적으로 버그이지만 이전 버전과의 호환성 문제를 일으키지 않으면 해결할 수 없습니다. 이 옵션을 &quot;2&quot;로 설정하면 분음 부호가 모든 라틴 문자에서 올바르게 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace (X, Y, Z) 함수는 문자열 X에서 문자열 Y가 &lt;a href=&quot;datatype3#collation&quot;&gt;나타날&lt;/a&gt; 때마다 문자열 Z를 대체하여 구성된 문자열을 반환합니다. BINARY 조합 시퀀스는 비교에 사용됩니다. Y가 빈 문자열이면 X를 변경하지 않고 반환합니다. Z가 처음에 문자열이 아닌 경우 처리 전에 UTF-8 문자열로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">이전 단계에서 작성된 저장소는 처음에 비어 있습니다. 다음 단계는 위의 다이어그램에서 기준선 SQLite 릴리스-원 (1)을로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">예약 된 영역은 확장 프로그램이 페이지 별 정보를 보유하는 데 사용할 수있는 모든 페이지 끝에있는 사용되지 않은 공간 영역입니다 (잠금 페이지 제외). 예약 영역의 크기는 데이터베이스 파일 헤더에서 20의 오프셋에서 발견 된 1 바이트 부호없는 정수에 의해 결정됩니다. 예약 영역의 크기는 일반적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">예약 된 지역</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">메모리 부족 (OOM) 오류에 대한 SQLite의 응답은 메모리 장애를 시뮬레이션 할 수있는 특수 메모리 할당 기 오버레이를 사용하여 테스트됩니다. 오버레이는 메모리 할당 자와 나머지 SQLite 사이에 삽입되는 레이어입니다. 오버레이는 대부분의 메모리 할당 요청을 기본 할당 자로 직접 전달하고 결과를 요청자에게 다시 전달합니다. 그러나 N 번째 메모리 할당이 실패하도록 오버레이를 설정할 수 있습니다. OOM 테스트를 실행하기 위해 첫 번째 할당 시도에서 오버레이가 먼저 실패하도록 설정됩니다. 그런 다음 일부 테스트 스크립트가 실행되고 할당이 올바르게 포착되고 처리되었는지 확인합니다. 그런 다음 두 번째 할당에서 오버레이가 실패하도록 설정되고 테스트가 반복됩니다.메모리 할당 오류가 발생하지 않고 전체 테스트 절차가 완료 될 때까지 실패 지점이 한 번에 한 번의 할당으로 계속 진행됩니다. 이 전체 테스트 순서는 두 번 실행됩니다. 첫 번째 패스에서 오버레이는 N 번째 할당 만 실패하도록 설정됩니다. 두 번째 패스에서 오버레이는 N 번째 및 모든 후속 할당에 실패하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">나머지 모듈 구조는 가상 테이블의 다양한 기능을 구현하는 데 사용되는 메소드로 구성됩니다. 이러한 각 방법이 수행하는 작업에 대한 자세한 내용은 후속편에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">복합 서브 쿼리에 대해 생성 된 결과 컬럼 이름은 원래 테이블의 컬럼 이름 만 표시하고 테이블 이름을 생략하도록 단순화되었습니다. 이를 통해 SQLite는 다른 SQL 데이터베이스 엔진처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&quot;(1,2,3) = (1, NULL, 3)&quot;의 결과는 NULL입니다. NULL &amp;rarr; 2를 대체하면 결과가 true이고 NULL &amp;rarr; 9를 대체하면 false입니다. &quot;(1,2,3) = (1, NULL, 4)&quot;의 결과는 NULL이 아닙니다. 3 번째 열에서 3은 절대로 4가 아니기 때문에 식을 true로 만드는 구성 요소 NULL을 대체하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">IN 또는 NOT IN 연산자의 결과는 다음 매트릭스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">이항 연산자의 결과는 숫자 값이거나 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">모든 입력 변경 세트를 함께 결합한 결과는 sqlite3changegroup_output ()에 대한 호출을 통해 애플리케이션에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">파일을 연 결과는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 의 인스턴스입니다 . &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file에&lt;/a&gt; 다음과 같이 객체는 추상 기본 클래스 정의된다 :</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">복합 선택의 결과는 명령 22에서 25까지의 루프에 의해 콜백 루틴으로 전송됩니다. 23의 열 명령이 레코드에서 열을 추출한다는 사실을 제외하고는이 루프에 대해 새롭거나 주목할만한 것이 없습니다. 레코드 데이터보다는 키.</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">마지막 예의 결과는 examp2의 &quot;4&quot;열에있는 값이 제거되는 것을 제외하고 examp 테이블의 &quot;2&quot;열의 모든 고유 값이어야합니다. 이 쿼리를 구현하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total ()의 결과는 항상 부동 소수점 값입니다. NULL이 아닌 모든 입력이 정수인 경우 sum ()의 결과는 정수 값입니다. sum ()에 대한 입력이 정수 또는 NULL이 아닌 경우 sum ()은 부동 소수점 값을 리턴하며 이는 실제 합계에 대한 근사치 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">결과 &quot;sqlite3.c&quot;통합 코드 파일 (및 관련 헤더 파일 &quot;sqlite3.h&quot;)은 기본 컴파일러를 사용하여 최종 컴파일을 위해 비 유닉스 플랫폼으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">비교 결과는 다음 규칙에 따라 피연산자의 스토리지 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">여기에 제시된 결과에는 다음과 같은 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64 ()의 반환 값은 호출 전의 소프트 힙 제한 크기이거나 오류의 경우 음수입니다. 인수 N이 음수이면 소프트 힙 한계가 변경되지 않습니다. 따라서 소프트 힙 제한의 현재 크기는 sqlite3_soft_heap_limit64 ()를 음수 인수로 호출하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">리턴 값은 간접 플래그의 최종 상태를 나타냅니다. 지워지면 0, 설정되어 있으면 1입니다.</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">리턴 값은 세션 오브젝트의 최종 상태를 나타냅니다. 세션이 사용 불가능하면 0, 사용 가능하면 1</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스 의 반환 값은 컴파일 타임 스레딩 모드 선택에 의해 결정됩니다. 컴파일 타임에 단일 스레드 모드를 선택하면 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 가 false를 반환합니다. 다중 스레드 또는 직렬 모드를 선택하면 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 가 true를 반환합니다. &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스는 시작 시간 또는 런타임 모드 변경 사항을보고 할 수있는 멀티 스레드 모드를 선행하고 시작 시간과 런타임 모드 선택 등 멀티 스레드 및 직렬화 모드도 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt; 함수 의 반환 값은 불투명 한 &lt;b&gt;sqlite&lt;/b&gt; 구조에 대한 포인터 입니다. 이 포인터는 동일한 데이터베이스를 처리하는 모든 후속 SQLite 함수 호출에 대한 첫 번째 인수입니다. 어떤 이유로 든 열기에 실패하면 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">리턴 된 문자열 포인터는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()에&lt;/a&gt; 의해 삭제 되거나 특정 실행에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 다음에 sqlite3_column_name () 또는 sqlite3_column_name16 ()에 대한 다음 호출까지 자동으로 다시 준비 될 때까지 유효 합니다. 같은 열.</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">리턴 된 문자열 포인터는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()에&lt;/a&gt; 의해 삭제 되거나 특정 실행에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 다음에 sqlite3_column_name () 또는 sqlite3_column_name16 ()에 대한 다음 호출까지 자동으로 다시 준비 될 때까지 유효 합니다. 같은 열.</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">위에서 다시 작성된 표현은 개념입니다. OR가 포함 된 WHERE 절은 실제로이 방법으로 다시 작성되지 않습니다. OR 절의 실제 구현은 더 효율적이고 &quot;rowid&quot;에 액세스 할 수없는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 테이블에 대해서도 작동하는 메커니즘을 사용합니다 . 그러나 구현의 본질은 위의 진술에 의해 포착됩니다. 각 OR 절 용어에서 후보 결과 행을 찾는 데 별도의 인덱스가 사용되며 최종 결과는 해당 행의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">다시 작성된 용어는 * IN * 연산자에 대한 일반 규칙을 사용하여 색인을 제한하기 위해 계속 될 수 있습니다. 참고</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">IN 또는 NOT IN 연산자의 오른쪽 피연산자는 피연산자가 목록 인 경우 선호도가없고 피연산자가 SELECT 인 경우 결과 세트 표현식의 선호도와 동일한 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">IN 연산자의 오른쪽은 상수 목록 대신 표현식 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKE 또는 GLOB의 오른쪽은 문자열 리터럴이거나 와일드 카드 문자로 시작하지 않는 문자열 리터럴에 바인드 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOIN의 오른쪽 테이블은 자체 USING 또는 ON 절 이외의 쿼리에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH 또는 = 연산자의 오른쪽은 호출 할 보조 함수로 구성된 문자열로 평가되고 괄호 안에 쉼표로 구분 된 인수가 0 개 이상인 문자열로 평가되는 상수 표현식이어야합니다. 인수는 SQL 리터럴이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">복합 선택의 가장 오른쪽 SELECT는 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계&lt;/a&gt; 또는 &lt;a href=&quot;windowfunctions&quot;&gt;창 함수를&lt;/a&gt; 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">롤백 저널에는 데이터베이스 파일의 원래 크기를 기록하는 작은 헤더 (다이어그램에서 녹색으로 표시)가 있습니다. 따라서 변경으로 인해 데이터베이스 파일이 커져도 데이터베이스의 원래 크기를 알 수 있습니다. 페이지 번호는 롤백 저널에 기록 된 각 데이터베이스 페이지와 함께 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">롤백 저널에 마스터 저널 파일의 이름이 없거나 (아래 &lt;a href=&quot;#section_5_5&quot;&gt;섹션 5.5&lt;/a&gt; 참조) 마스터 저널의 이름이있는 경우 해당 마스터 저널 파일이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">롤백 저널이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">롤백 저널 파일을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">롤백 저널 파일을 길이가 0으로 잘 리거나</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">롤백 저널은</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">롤백 저널은 트랜잭션 중에 데이터베이스 파일을 초기 상태로 복원하는 데 사용되는 정보를 보유하는 각 SQLite 데이터베이스 파일과 연관된 파일입니다. 롤백 저널 파일은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 데이터베이스 파일과 이름은 동일하지만 문자열 &quot; &lt;code&gt;-journal&lt;/code&gt; &quot;이 추가됩니다. give 데이터베이스와 연관된 단일 롤백 저널 만있을 수 있으므로 한 번에 하나의 데이터베이스에 대해 하나의 쓰기 트랜잭션 만 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">전원이 복원되면 롤백 저널이 완료되어 디스크에 그대로 있습니다. 이것이 핵심입니다. &lt;a href=&quot;#section_3_7&quot;&gt;3.7 단계&lt;/a&gt; 에서 플러시 작업을 수행 하는 이유 는 데이터베이스 파일 자체를 변경하기 전에 모든 롤백 저널이 비 휘발성 저장소에 안전하게 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">롤백 저널이 빈 파일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">데이터베이스에있는 모든 테이블의 루트 페이지 번호는 P4_INTARRAY 인수에 저장된 정수입니다.</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round (X, Y) 함수는 소수점 오른쪽에 Y 자리로 반올림 된 부동 소수점 값 X를 반환합니다. Y 인수가 생략되면 0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 루틴 은 세미콜론으로 구분 된 SQL 문 목록 (sql-stmt-list)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">행 값 표기법은 단일 쿼리 결과에서 테이블의 둘 이상의 열을 업데이트하는 데 유용합니다. 이에 대한 예는 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템&lt;/a&gt; 의 전체 텍스트 검색 기능에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">각 그룹에서 첫 번째 피어의 row_number ()-공백이있는 현재 행의 순위입니다. ORDER BY 절이 없으면 모든 행이 피어로 간주되며이 함수는 항상 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number () 창 함수는 window-defn (이 경우 &quot;ORDER BY y&quot;) 내의 &quot;ORDER BY&quot;절 순서로 각 행에 연속 정수를 할당합니다. 이는 전체 쿼리에서 결과가 반환되는 순서에 영향을주지 않습니다. 최종 출력 순서는 여전히 SELECT 문에 첨부 된 ORDER BY 절 (이 경우 &quot;ORDER BY x&quot;)에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에서는 rowid (및 &quot;oid&quot;및 &quot;_rowid_&quot;)가 생략됩니다 . WITHOUT ROWID 테이블은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;버전 3.8.2&lt;/a&gt; (2013-12-06) 이상 에서만 사용 가능 합니다. WITHOUT ROWID 절이없는 테이블을 &quot;행 테이블&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">물론 WITHOUT ROWID 가상 테이블에서 rowid 열에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">용어 인스턴스를 포함하는 문서의 rowid</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">변경되는 테이블에서 행의 rowid</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck () 함수는 다음 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim (X, Y) 함수는 X의 오른쪽에서 Y에 나타나는 모든 문자를 제거하여 형성된 문자열을 반환합니다. Y 인수가 생략되면 rtrim (X)는 X의 오른쪽에서 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">위의 규칙에 따르면 사용자 입력의 문자 &quot;a&quot;는 페널티가 5 인 사전의 문자 &quot;&amp;auml;&quot;와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">이진 비교 연산자에 사용할 조합 함수 (=, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =,! =, IS 및 IS NOT)를 결정하는 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">테이블이 분석되는시기에 대한 규칙은 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">가장 안전하고 기억하기 쉬운 정책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">가장 안전한 정책은 다음 방법 중 하나를 사용하여 이러한 루틴을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">프레임 헤더의 소금 1과 소금 2 값은 월 헤더의 소금 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">키워드 &quot;union&quot;, &quot;true&quot;및 &quot;with&quot;를 식별자로 사용하기 때문에 알고있는 다른 모든 SQL 구현에서 동일한 SQL 문이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">동일한 기본 B- 트리 형식이 사용되지만 더 나은 쿼리 최적화 기회를 제공하기 위해 인덱스 키의 세부 사항이 변경되었습니다. 행의 최대 크기를 64KB에서 24MB로 늘리기 위해 일부 헤더도 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">동일한 기본 알고리즘을 따릅니다. 이번에는 색인의 일치하는 행이 위에서 아래로가 아니라 아래에서 위로 스캔되어 상태가 내림차순으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">동일한 핵심 문자열 포맷터도 SQLite에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">동일한 데이터베이스 연결을 이제 별도의 스레드에서 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">동일한 인덱스가 두 구현 옵션에서 모든 루프의 속도를 높이는 데 사용됩니다. 이 두 쿼리 계획의 유일한 차이점은 루프가 중첩되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">동일한 기술을 사용하면 부적절한 순간에 시스템 장애로 인해 SQLite 데이터베이스 파일을 손상시킬 수 없습니다. SQLite가 충분한 실행 기회를 갖기 전에 시스템 장애가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">물론 엔터프라이즈 클라이언트 / 서버 데이터베이스에서도 동일한 작업을 수행 할 수 있습니다. SQLite의 장점은 설치 및 사용이 더 쉽고 결과 데이터베이스는 USB 메모리 스틱에 작성하거나 동료에게 이메일로 보낼 수있는 단일 파일이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">스칼라 SQL 함수 rtreecheck (R) 또는 rtreecheck (S, R)은 데이터베이스 S에 포함 된 R이라는 rtree 테이블에서 무결성 검사를 실행합니다.이 함수는 발견 된 문제점에 대한 인간 언어 설명 또는 발견 된 경우 문자열 'ok'를 리턴합니다. 다 괜찮아 R * Tree 가상 테이블에서 rtreecheck ()를 실행 하는 것은 데이터베이스 에서 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 를 실행하는 것과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">위의 시나리오는 많이 들립니다. 그러나 SQLite 개발자들은 정확히이 버그로 출시 된 하나 이상의 상용 제품을 알고 있습니다. 공급 업체는 Linux 및 Mac에서 자주 발생하는 데이터베이스 손상 문제를 추적하는 데 도움을 요청하는 SQLite 개발자에게 왔습니다. 결국이 문제는 응용 프로그램이 두 개의 별도 SQLite 복사본에 연결되어 있다는 사실로 추적되었습니다. 해결책은 애플리케이션 빌드 프로 시저를 변경하여 두 개의 SQLite 대신 한 개의 SQLite에 대해서만 링크하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">위의 스키마는 각 노드에 이름을 저장할 수있는 유향 그래프를 정의합니다. 이제이 스키마에 대한 쿼리를 고려하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
