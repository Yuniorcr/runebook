<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">버그 수정 : 조인의 WHERE 절에 나타나는 함수를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">버그 수정 : 비교 연산자가 포함되지 않은 조인의 WHERE 절에서 용어를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">버그 수정 : 단일 트랜잭션 내에서 테이블 작성 및 삭제가 모두 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : DISTINCT는 이제 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; 과 모든 0x00 바이트의 얼룩이 같은 것을 인식합니다. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;티켓 [fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">버그 수정 : 단일 트랜잭션 내에서 DROP TABLE 다음에 같은 이름을 가진 CREATE TABLE이 코어 덤프를 일으켰습니다.</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">버그 수정 : 버전 2.4.0 (체크인 [410])에서 도입 된 최적화로 인해 데이터베이스 손상이 발생할 수 있습니다. 이제 문제가 해결되었습니다. 버전 2.4.0부터 2.5.2는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 모든 외부 루프가 하나 이상의 행 결과를 반환하도록 보장되지 않는 한 가상 테이블이 ORDER BY 절을 취소하도록 허용하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">버그 수정 : FROM 절이없는 쿼리에서 하위 쿼리 병합 최적화를 시도하지 마십시오. 그렇게하면 segfault가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : SELECT에 LIMIT도 포함되어 있으면 IN 연산자의 오른쪽을 구성하는 SELECT에서 DISTINCT 키워드를 자동으로 제거하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 결과 집합의 부분 집합이 UNIQUE 제약 조건이 적용되지 않는 음주 불필요한으로 DISTINCT를 버리지 &lt;em&gt;과&lt;/em&gt; 그 부분 집합의 열 그 어느 것도 NULL이 될 수 있습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">버그 수정 : WHERE 절 용어를 LEFT JOIN의 ON 절에 포함 된 OR 표현식으로 이동하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 해당 용어도 NOT NULL이 아닌 한 UNIQUE 인덱스와 동일한 용어를 가진 ORDER BY 절을 최적화하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : IN 제약 조건이 사용되는 경우 가상 테이블 쿼리에서 ORDER BY 절을 억제하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : &quot;ORDER BY random ()&quot;절이 최적화되지 않았는지 확인하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;티켓 [65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 작동 하고 동일한 공유 캐시의 다른 데이터베이스 연결을 계속 열어두고 일부 데이터베이스 연결을 자주 닫았다가 다시 열 때 캐시 된 KeyInfo 객체 (애플리케이션에 보이지 않는 내부 추상화)가 오래 걸리지 않도록 하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">버그 수정 : 16GB보다 큰 데이터베이스의 CREATE INDEX에서 32 비트 오버 플로우 문제를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 닫히고 다른 데이터베이스 연결 이 쓰기 트랜잭션 도중에 있을 때 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 잠재적 인 &lt;b&gt;데이터베이스 손상 버그&lt;/b&gt; 를 수정 합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">버그 수정 : ROWID가 뷰의 SELECT 문의 열일 때 발생하는 어설 션 오류를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">버그 수정 : VDBE에서 초기화되지 않은 변수를 수정하여 어설 션 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">버그 수정 : &quot;DEFAULT (-(-9223372036854775808))&quot;형식의 열 기본값 표현식을 수정하여 열이 거의 +9223372036854775808.0과 같은 부동 소수점 값으로 초기화되도록 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_corefunc#char&quot;&gt;char ()&lt;/a&gt; SQL 함수를 수정하여 인수가 0 인 경우 &quot;메모리 부족&quot;오류가 아닌 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">버그 수정 : 보류중인 쿼리를 취소하지 않도록 &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 명령을 수정하십시오 . 3.7.11에서 소개 된 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">버그 수정 : 복합 SELECT가 하위 쿼리로 사용될 때 올바른 열 헤더를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; CSV 가져 오기 기능에서 이스케이프 된 큰 따옴표가 CRLN 줄의 끝에서 발생할 때 필드를 끝내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">버그 수정 다음에서 &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; 의 토크 나이 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; , 식별자 상징으로 모든 개인 코드 포인트를 취급합니다.</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">버그 수정 : 지나치게 복잡한 쿼리로 인해 뷰의 16 비트 참조 카운터가 오버플로되면 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 일반 테이블과 WITHOUT ROWID 테이블 사이의 조인에서 &quot;rowid&quot;열이 올바르게 분석되는지 확인하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;티켓 [c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문이 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 출력에 나타나는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 누락 된 &lt;a href=&quot;datatype3#collation&quot;&gt;배열 순서&lt;/a&gt; 가 필요한 작업을 수행 할 때 항상 오류가보고되는지 확인하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : OP_Column의 NULL 결과가 완전하고 완전히 NULL이며 MEM_Ephem 비트가 설정되어 있지 않은지 확인하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">버그 수정 : 데이터베이스 파일을 쓰기 전에 저널 파일 디렉토리 항목이 디스크에 커밋되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : ORDER BY 절을 포함하는 복합 SELECT 문을 구현하는 데 사용되는 동시 동시 루틴에서 동일한 임시 레지스터를 사용하지 마십시오. 오답으로 이어질 수 있습니다. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;티켓 [8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">버그 수정 : pragmas table_info, index_list, index_info 및 foreign_key_list를 실행하기 전에 스키마가 최신인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자&lt;/a&gt; 콜백이 rowid를 변경 하는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 column-name 매개 변수에 대한 &quot;ROWID&quot;문자열에 대한 유효한 포인터를 가져 오도록합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 일치하는 다른 항목이없는 경우 결과 집합의 AS 이름 만 WHERE 절에서 식별자를 해결할 후보로 고려하십시오. ORDER BY 절에서 AS 이름은 모든 열 이름보다 우선합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">버그 수정 : &lt;b&gt;sqlite_open ()에&lt;/b&gt; 세 번째 매개 변수로 NULL을 전달하면 때때로 코어 덤프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 열에 NOT NULL 제약 조건이 있어도 LEFT JOIN의 오른쪽 테이블에있는 열이 NULL 일 수 있음을 인식하십시오. 열이 NULL이 아니라고 가정하는 최적화를 적용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : TRIGGER에 포함 된 하위 선택문에서 발생할 수있는 이름 확인 오류를 수정하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;티켓 [4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">버그 수정 : TCL 인터페이스를 사용하여 작성된 SQL 함수는 &quot;널값&quot;설정을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">버그 수정 : 때때로 열의 실제 값이 NULL 일 때 임의의 문자열이 콜백 함수에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">버그 수정 : sqlite3_mprintf ()의 % c 형식은 70보다 큰 정밀도를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">버그 수정 : &quot;.quit&quot;명령을 사용하여 종료하면 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 종료 코드 0을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">버그 수정 : pager.c에 잘못된 assert ()가있었습니다. 실제 코드는 (알고있는 한) 모두 정확하므로 -DNDEBUG = 1로 컴파일하면 모든 것이 정상적으로 작동합니다. 어설 션이 비활성화되지 않은 경우 결함이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">버그 수정 : INTEGER PRIMARY KEY 및 인덱스를 포함하는 테이블 업데이트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">버그 수정 : 가상 테이블은 이제 IS NOT NULL 제약 조건을 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 와 함께 ORDER BY 절을 사용하는 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 쿼리&lt;/a&gt; 는 지정된 데이터 정렬에 따라 정렬이 수행되고 복합 쿼리와 연관된 비교가 기본 데이터 정렬을 사용하는지 확인하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">버그 수정 : EMPTY_RESULT_CALLBACKS pragma를 설정 한 후 빈 데이터베이스에서 VACUUM (segfaulting 없음)을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">버그 수정 : 데이터베이스 파일을 보유한 디스크가 가득 차거나 다른 이유로 쓰기 허용을 중지하면 어설 션이 실패했습니다. 앞으로 비슷한 문제를 발견하기 위해 새로운 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">버그 수정 : 모호하고 비교적 무해한 버그로 인해 gcc 최적화를 켤 때 테스트 중 하나가 실패했습니다. 이 릴리스는 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">버그 수정 : segfaulting없이 뷰의 뷰를 올바르게 평가합니다.</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">버그 수정 : 스키마 변경 후 스키마를 재분석 할 때 권한 부여자를 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">버그 수정 : 정수 값이 32 비트 int에 맞지 않으면 대신 double로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">버그 수정 : 다음과 같은 상황에서 잘못된 VDBE 코드가 생성되었습니다. 오른쪽에 하위 쿼리가있는 IN 연산자가있는 WHERE 절이 포함 된 인덱스 테이블의 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">버그 수정 : 테이블과 이름이 같은 트리거를 삭제 한 경우 데이터베이스 손상을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 잘못된 쿼리로 인해 INTEGER 필드와 두 개 이상의 위치에있는 TEXT 필드를 비교하는 3 방향 이상의 조인이 발생할 수있는 오랜 문제를 해결합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">버그 수정 : &lt;b&gt;sqlite_busy_timeout ()&lt;/b&gt; 함수가 실패하기 전에 1000 배 너무 오래 지연되었습니다.</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">버그 수정</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">쿼리 최적화 프로그램의 버그 수정 및 성능 향상</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">버그 수정 및 속도 개선 테스트 범위가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">fts1 및 fts2 모듈의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">Oleg Oleinick로 식별 된 TCL 인터페이스의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">실험 날짜 / 시간 기능의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">날짜 / 시간 기능에 대한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">언급하기에는 너무 많은 버그 수정 (변경 로그 참조)</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">버그 수정:</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">버그 수정 : WHERE 절에서 인덱스와 함께 사용되는 중첩 된 상관 서브 쿼리를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 레거시 쿼리 최적화 프로그램의 여러 문제가 &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt; 로 이동하여 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">버그는 사용자 정의 파일 I / O 코드보다 SQLite에서 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">FTS3 / 4 가상 테이블의 버그 &quot;무결성 검사&quot;명령은 FTS3 / 4 용 테스트 스위트의 일부로 원래 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">&quot;fts5.c&quot;대상을 빌드하십시오. 또한 fts5.h를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">개별 소스 코드 파일에서 직접 SQLite를 빌드하는 것은 가능하지만 권장되지는 않습니다. 일부 특수 응용 프로그램의 경우 웹 사이트에서 다운로드 한 사전 빌드 된 합병 소스 파일을 사용하여 수행 할 수없는 방식으로 빌드 프로세스를 수정해야 할 수도 있습니다. 이러한 상황에서는 맞춤형 아말감 화 ( &lt;a href=&quot;howtocompile#amal&quot;&gt;아래&lt;/a&gt; 설명 참조 )를 만들어 사용 하는 것이 좋습니다 . 즉, 프로젝트에서 개별 소스 파일로 시작하는 SQLite를 빌드해야하더라도 여전히 합병 소스 파일을 중간 단계로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">DLL 작성</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">불행히도 Mac OS X 및 Windows 용 공유 라이브러리를 구축하는 것은 그리 간단하지 않습니다. 이러한 플랫폼의 경우 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball에&lt;/a&gt; 포함 된 configure 스크립트 및 makefile을 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">융합을 구축</target>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">일반 SQL 쿼리 내에서 사용하기 위해 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문의 결과를 반환하는 내장 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">내장 함수는 새로운 응용 프로그램 정의 함수에 의해 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">내장 창 함수는 집계 창 함수와 동일한 방식으로 PARTITION BY 절을 준수합니다. 선택한 각 행이 파티션에 지정되고 각 파티션이 개별적으로 처리됩니다. ORDER BY 절이 각 내장 창 함수에 영향을주는 방식은 아래에 설명되어 있습니다. 일부 창 함수 (rank (), dense_rank (), percent_rank () 및 ntile ())는 &quot;피어 그룹&quot;(모든 ORDER BY 표현식에 대해 동일한 값을 갖는 동일한 파티션 내의 행) 개념을 사용합니다. 이 경우 frame-spec이 ROWS, GROUPS 또는 RANGE를 지정하는지 여부는 중요하지 않습니다. 내장 창 함수 처리를 위해 프레임 유형에 관계없이 모든 ORDER BY 표현식에 대해 동일한 값을 가진 행은 피어로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">내장 윈도우 기능</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">라이브러리와 함께 sqlite_encode_binary () 및 sqlite_decode_binary ()를 번들하십시오.</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">죽은자를 묻어 라.</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">그러나 SQLite는 선언 된 유형의 열을 해당 형식의 값을 선호한다는 힌트로 사용합니다. 예를 들어, 열이 INTEGER 유형 인 경우 해당 열에 문자열을 삽입하려고하면 SQLite는 문자열을 정수로 변환하려고 시도합니다. 가능하면 정수를 대신 삽입합니다. 그렇지 않으면 문자열을 삽입합니다. 이 기능을 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">그러나 SQLite는 응용 프로그램에 내장되어 있습니다. 따라서 데이터가 응용 프로그램과 별도의 장치에있는 경우 더 높은 대역폭의 엔진 대 디스크 링크가 네트워크를 거쳐야합니다. 이것은 작동하지만 차선책입니다. 따라서 데이터가 응용 프로그램과 별도의 장치에있는 경우 일반적으로 클라이언트 / 서버 데이터베이스 엔진을 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">그러나 SQLite 데이터베이스는 파일 더미 데이터베이스와 같은 간단한 키 / 값 구조로 제한되지 않습니다. SQLite 데이터베이스는 테이블 당 수십 또는 수백 또는 수천 개의 서로 다른 테이블을 가질 수 있으며, 각각 테이블마다 수십 또는 수백 또는 수천 개의 필드가 있으며, 각각 서로 다른 데이터 유형 및 제약 조건 및 특정 의미를 가지며, 서로를 상호 참조하고, 빠른 검색을 위해 적절하고 자동으로 색인을 생성합니다. 하나의 디스크 파일에 효율적이고 컴팩트하게 저장됩니다. 그리고이 구조는 모두 SQL 스키마에 의해 간결하게 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">그러나 쿼리 플래너 변경과 마찬가지로 NGQP로 업그레이드해도 성능이 저하 될 위험이 적습니다. 여기서 문제는 NGQP가 잘못되었거나 버그가 있거나 레거시 쿼리 플래너보다 열등하지 않다는 것입니다. 인덱스의 선택성에 대한 신뢰할 수있는 정보가 제공되면 NGQP는 항상 이전보다 좋은 계획을 선택해야합니다. 문제는 일부 응용 프로그램이 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하지 않고 저품질 및 저 선택성 인덱스를 사용하고있을 수 있다는 것입니다. 오래된 쿼리 플래너는 각 쿼리에 대해 가능한 적은 구현을 검토하므로 어리석은 운으로 좋은 계획을 우연히 발견했을 수 있습니다. 반면에 NGQP는 더 많은 쿼리 계획 가능성을 검토하며, 좋은 인덱스를 가정 할 때 이론적으로 더 잘 작동하지만 데이터의 모양으로 인해 실제로 성능 회귀를 제공하는 다른 쿼리 계획을 선택할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">그러나 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 데이터베이스 파일을 직접 변경하지 않기 때문에 sqlite3_stmt_readonly ()는 여전히 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">그러나 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 데이터베이스 파일을 직접 변경하지 않기 때문에 sqlite3_stmt_readonly ()는 여전히 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">그러나 이것이 실제로 시간을 절약합니까? &lt;a href=&quot;#fig16&quot;&gt;원래 인덱스없는 정렬&lt;/a&gt; 의 단계 수는 N 행을 정렬하는 데 걸리는 시간이므로 NlogN에 비례합니다. 그러나 여기에 표시된대로 Idx1을 사용할 때는 각각 logN 시간이 걸리는 N rowid 조회를 수행해야하므로 NlogN의 총 시간은 동일합니다!</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">그러나 VDBE의 관점에서 CREATE는 INSERT와 거의 유사하게 작동하며 DROP은 DELETE와 유사하게 작동합니다. SQLite 라이브러리가 기존 데이터베이스를 열 때 가장 먼저하는 일은 sqlite_master 테이블의 모든 항목에서 &quot;sql&quot;열을 읽는 SELECT입니다. &quot;sql&quot;열에는 원래 인덱스 또는 테이블을 생성 한 CREATE 문의 전체 SQL 텍스트가 포함됩니다. 이 텍스트는 SQLite 파서로 피드백되어 인덱스 또는 테이블을 설명하는 내부 데이터 구조를 재구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">그러나 SQLite가 데이터베이스 파일의 페이지에 액세스하려고하고 메모리 매핑 된 I / O가 활성화 된 경우 먼저 xFetch () 메서드를 호출합니다. xFetch () 메소드는 가능한 경우 운영 체제에 요청 된 페이지에 대한 포인터를 리턴하도록 요청합니다. 요청 된 페이지가 응용 프로그램 주소 공간에 맵핑되었거나 맵핑 될 수있는 경우, xFetch는 아무것도 복사하지 않고 SQLite가 사용할 페이지에 대한 포인터를 리턴합니다. 복사 단계를 건너 뛰면 메모리 매핑 I / O가 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">그러나 해커가 임의의 SQL을 실행할 수 있으면 다음과 같이 약간 다른 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">그러나 EMPTY_RESULT_CALLBACKS pragma가 ON이면 다음이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">그러나 case_sensitive_like pragma가 다음과 같이 사용 가능한 경우 :</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">그러나 i 번째 매개 변수가 NULL이면 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">그러나 ORDER BY 절을 변경하여 &quot;DESC&quot;수정자를 추가하면 조직의 하위 수준 (더 큰 &quot;수준&quot;값)이 재귀 선택에 의해 먼저 처리되어 깊이 우선 검색이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">그러나 커버리지 측정 빌드에서 &lt;code&gt;testcase()&lt;/code&gt; 매크로는 인수에서 조건식을 평가하는 코드를 생성합니다. 그런 다음 분석 중에 조건부 참과 거짓 모두를 평가하는 테스트가 존재하는지 확인합니다. 예를 들어 &lt;code&gt;Testcase()&lt;/code&gt; 매크로는 경계 값이 테스트되는지 확인하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">그러나 동일한 쿼리의 다음과 같은 논리적으로 동등한 공식에서 &quot;,&quot;에 대한 &quot;CROSS JOIN&quot;의 대체는 테이블 순서가 N1, E, N2 여야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">그러나 &quot;.tables&quot;명령은 더 많은 작업을 수행합니다. 기본 데이터베이스뿐만 아니라 &lt;a href=&quot;lang_attach&quot;&gt;연결된&lt;/a&gt; 모든 데이터베이스에 대해 sqlite_master 테이블을 쿼리 합니다. 그리고 출력을 깔끔한 열로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">그러나 다음 선언으로 인해 &quot;x&quot;가 rowid의 별칭이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">그러나 다음 쿼리는 부분 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">그러나 하위 유형을 사용하면 다음과 같은 SQL 코드를 사용하여 포인터 값을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">그러나 단점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">그러나 이러한 루틴은 선택 사항이며 &lt;a href=&quot;compile#zero_malloc&quot;&gt;컴파일 타임 옵션을&lt;/a&gt; 사용하여 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">그러나 N은 어떤 가치를 선택해야할까요? N = K를 시도 할 수 있습니다. K 의 최대 값이 64이고 K가 거의 10을 초과하지 않기 때문에 알고리즘 O (K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt; )는 실제로 여전히 매우 효율적입니다. 그러나 TPC-H Q8 문제에는 충분하지 않습니다. TPC-H Q8에서 N = 8 인 N3 알고리즘은 29.78의 비용으로 솔루션 R-N1-COLS-N2-P를 찾습니다. 이는 NN에 비해 크게 개선되었지만 여전히 최적은 아닙니다. N3은 N이 10 이상인 경우 TPC-H Q8에 대한 최적의 솔루션을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">그러나 SQLite를 사용하면 웹 페이지 당 200 개 이상의 SQL 문이 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">그러나 일반적으로 R * Tree 모듈이 처리해야하는 제약 조건이 많을수록 경계 상자가 작을수록 결과가 더 빨리 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">&quot;정적 문자열&quot;은 프로그램 수명 동안 고정되고 변경되지 않는 0으로 끝나는 바이트 배열을 의미합니다. 즉, 포인터 유형 문자열은 문자열 상수 여야합니다. 반대로, &quot;동적 문자열&quot;은 힙에서 할당 된 메모리에 보유되는 0으로 끝나는 바이트 배열이며 메모리 누수를 방지하기 위해 해제되어야합니다. 동적 문자열을 포인터 유형 문자열로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">단일 용어에 대한 여러 동의어를 FTS 색인에 추가합니다. 이 방법을 사용하면 문서 텍스트를 토큰화할 때 토크 나이 저는 각 토큰에 대해 여러 동의어를 제공합니다. 따라서 &quot;I won first place&quot;와 같은 문서가 토큰 화되면 &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot;및 &quot;place&quot;에 대한 항목이 FTS 색인에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">보조 열은 위치 데이터와 관련 정보를 동일한 테이블로 결합하여보다 깔끔한 모델을 제공하고 조인 필요성을 줄일 수 있습니다. 예를 들어, &lt;a href=&quot;#diquery&quot;&gt;demo_index와 demo_data 사이&lt;/a&gt; 의 이전 조인 은 이제 다음과 같이 간단한 쿼리로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">각 테이블이 처음 기록 될 때 호출되도록 콜백을 구성하여 테이블의 변경 사항을 모니터해야하는지 여부를 세션 모듈에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">반대로, 자식 테이블의 정의를보고 부모 테이블 정의를 참조하지 않고 외래 키 오류를 쉽게 인식 할 수 있으면 자식 테이블의 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문이 실패합니다. 스키마 변경 중에 오류가 발생하기 때문에 이는 DDL 오류입니다. 외래 키 DDL 오류는 테이블을 만들 때 외래 키 제약 조건의 활성화 여부에 관계없이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">기본적으로 세션 오브젝트는 데이터베이스 테이블의 변경 사항을 모니터하지 않습니다. 그렇게하기 전에 반드시 구성해야합니다. 변경 사항을 모니터하도록 테이블 세트를 구성하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">기본적으로 &quot;unicode61&quot;은 라틴 스크립트 문자에서 분음 부호를 제거하려고 시도합니다. 토크 나이저 인수 &quot;remove_diacritics = 0&quot;을 추가하면이 동작을 무시할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 는 비 결정적인 것으로 간주됩니다. 그러나 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()&lt;/a&gt; 의 네 번째 매개 변수 가 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC으로&lt;/a&gt; OR-ed 인 경우 SQLite는 해당 함수를 결정적인 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">기본적으로 FTS 쿼리 (MATCH 연산자를 사용하는 쿼리)는 languageid 열이 0으로 설정된 행만 고려합니다. 다른 languageid 값이있는 행을 쿼리하려면 &quot;</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">기본적으로 FTS3 / 4는 때때로 사용자가 실행하는 INSERT, UPDATE 또는 DELETE 문 내에서 전체 텍스트 인덱스를 구성하는 둘 이상의 b- 트리를 병합합니다. 즉, FTS3 / 4가 예상치 못하게 두 개 이상의 큰 b- 트리를 함께 병합하도록 선택할 수 있으므로 FTS3 / 4 테이블의 작업이 놀랍게도 느려질 수 있습니다. FTS5는 기본적으로 증분 병합을 사용하여 지정된 INSERT, UPDATE 또는 DELETE 작업 내에서 발생할 수있는 처리량을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">기본적으로 FTS5 전체 텍스트 검색은 대소 문자를 구분하지 않습니다. ORDER BY 절을 포함하지 않는 다른 SQL 쿼리와 마찬가지로 위의 예는 임의의 순서로 결과를 반환합니다. 관련성에 따라 (가장 관련성이 높거나 가장 낮은) 결과를 정렬하기 위해 ORDER BY를 다음과 같이 전체 텍스트 쿼리에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">기본적으로 FTS5는 문서 세트 내에서 각 토큰 인스턴스의 위치를 ​​기록하는 단일 인덱스를 유지합니다. 즉, 단일 조회가 필요하므로 완전한 토큰에 대한 쿼리가 빠르지 만 범위 스캔이 필요하므로 접두사 토큰에 대한 쿼리가 느려질 수 있습니다. 예를 들어, 접두사 토큰 &quot;abc *&quot;를 쿼리하려면 &quot;abc&quot;이상 &quot;abd&quot;보다 작은 모든 토큰의 범위 스캔이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">기본적으로 SQLite는 모든 데이터가 고정 크기 8 비트 문자 (iso8859)를 사용한다고 가정합니다. 그러나 --enable-utf8 옵션을 configure 스크립트에 제공하면 라이브러리는 UTF-8 가변 크기 문자를 가정합니다. 이는 LIKE 및 GLOB 연산자와 LENGTH () 및 SUBSTR () 함수에 차이를 만듭니다. 정적 문자열 &lt;b&gt;sqlite_encoding&lt;/b&gt; 은 &quot;UTF-8&quot;또는 &quot;iso8859&quot;로 설정되어 라이브러리 컴파일 방법을 나타냅니다. 또한 &lt;b&gt;sqlite.h&lt;/b&gt; 헤더 파일은 적절하게 매크로 &lt;b&gt;SQLITE_UTF8&lt;/b&gt; 또는 &lt;b&gt;SQLITE_ISO8859&lt;/b&gt; 중 하나를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">기본적으로 SQLite는 쓰기 중 전원 손실이나 OS 충돌이 발생하더라도 바이트 범위를 작성하기위한 운영 체제 호출이 해당 범위 밖의 바이트를 손상 시키거나 변경하지 않는다고 가정합니다. 이것을 &quot; &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; &quot;속성이라고합니다. &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;버전 3.7.9&lt;/a&gt; (2011-11-01) 이전에는 SQLite가 전원 안전 덮어 쓰기를 가정하지 않았습니다. 그러나 대부분의 디스크 드라이브에서 표준 섹터 크기가 512 바이트에서 4096 바이트로 증가함에 따라 기록 성능 수준을 유지하기 위해 전원 안전 덮어 쓰기를 가정해야하므로 최신 버전의 SQLite에서는 기본적으로 전원 안전 덮어 쓰기가 가정됩니다. powersafe 덮어 쓰기 속성의 가정은 컴파일 타임 또는 원하는 경우 런타임에 비활성화 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;psow&quot;&gt;powersafe 덮어 쓰기 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">기본적으로 SQLite는 WAL 파일이 임계 값 크기 인 1000 페이지에 도달하면 자동으로 검사 점을 수행합니다. 합니다 ( &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; WAL를 사용하여 컴파일시 옵션이 다른 기본을 지정할 수 있습니다.) 응용 프로그램은 이러한 체크 포인트가 발생하기에 위해 아무것도 할 필요가 없습니다. 그러나 원하는 경우 응용 프로그램에서 자동 검사 점 임계 값을 조정할 수 있습니다. 또는 유휴 순간이나 별도의 스레드 또는 프로세스에서 자동 검사 점을 끄고 검사 점을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">기본적으로 SQLite는 메모리 사용량에 대한 통계를 유지합니다. 이 통계는 응용 프로그램에 실제로 필요한 메모리 양을 결정하는 데 도움이됩니다. 통계는 메모리 사용량이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증명&lt;/a&gt; 의 한계에 근접하거나이를 초과하는지 여부를 판별하기 위해 고 신뢰성 시스템에서 사용될 수 있으며 , 따라서 메모리 할당 서브 시스템이 고장날 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">기본적으로 SQLite는 표준 라이브러리의 malloc () / free () 구현에서 객체 및 캐시에 필요한 메모리를 얻습니다. 또한 응용 프로그램 시작시 SQLite로 전달 된 단일 고정 메모리 버퍼에서 모든 메모리 요청을 만족시키는 실험용 메모리 할당 자에 대한 작업도 진행 중입니다. 이 실험 메모리 할당 자에 대한 추가 정보는이 문서의 향후 개정판에서 제공 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">기본적으로 SQLite는 메모리 할당 요구에 표준 C 라이브러리의 malloc (), realloc () 및 free () 루틴을 사용합니다. 이러한 루틴은 얇은 래퍼로 둘러싸여 있으며 기존 할당의 크기를 반환하는 &quot;memsize ()&quot;함수도 제공합니다. 미해결 메모리의 바이트 수를 정확하게 계산하려면 memsize () 함수가 필요합니다. memsize ()는 할당이 해제 될 때 미해결 카운트에서 제거 할 바이트 수를 결정합니다. 기본 할당자는 각 malloc () 요청에 항상 8 개의 추가 바이트를 할당하고 해당 8 바이트 헤더에 할당 크기를 저장하여 memsize ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">기본적으로 SQLite는 &lt;a href=&quot;lang_transaction&quot;&gt;COMAL이&lt;/a&gt; 발생할 때마다 WAL 파일의 크기가 1000 페이지 이상이되거나 데이터베이스 파일의 마지막 데이터베이스 연결이 닫힐 때 자동으로 검사 점을 검사 합니다. 기본 구성은 대부분의 응용 프로그램에 적합합니다. 그러나 더 많은 제어를 원하는 프로그램은 &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스를 호출 하여 검사 점을 강제 실행할 수 있습니다. &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; C 인터페이스를 호출하여 자동 검사 점 임계 값을 변경하거나 자동 검사 점을 완전히 비활성화 할 수 있습니다 . 프로그램은 &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용할 수도 있습니다트랜잭션이 WAL에 커밋 될 때마다 호출 할 콜백을 등록합니다. 이 콜백 은 적절하다고 생각하는 기준에 따라 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 를 호출 할 수 있습니다 . (자동 체크 포인트 메커니즘은 &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 주위에 간단한 래퍼로 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">기본적으로 VACUUM은 기본 데이터베이스에서만 작동합니다. VACUUM 문에 적절한 스키마 이름을 추가하여 &lt;a href=&quot;lang_attach&quot;&gt;연결된 데이터베이스&lt;/a&gt; 를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">기본적으로 좌표는 32 비트 부동 소수점 값을 사용하여 R * Tree에 저장됩니다. 좌표가 32 비트 부동 소수점 숫자로 정확하게 표현 될 수없는 경우 하한 좌표는 내림되고 상한 좌표는 내림됩니다. 따라서 경계 상자는 지정된 것보다 약간 클 수 있지만 더 작을 수는 없습니다. 응용 프로그램이 쿼리 경계 상자와 겹치는 R * Tree의 모든 항목을 찾으려는 일반적인 &quot;중복&quot;쿼리를 수행하는 데 필요한 것입니다. 항목 경계 상자를 바깥쪽으로 반올림하면 항목 경계 상자의 가장자리가 쿼리 경계 상자의 가장자리에 해당하는 경우 겹치는 쿼리에 몇 가지 추가 항목이 나타날 수 있습니다. 그러나 겹치는 쿼리는 유효한 테이블 항목을 절대 놓치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">기본적으로 분음 부호는 모든 라틴 스크립트 문자에서 제거됩니다. 예를 들어 &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot;및 &quot;&amp;acirc;&quot;는 모두 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">기본적으로 가상 테이블의 스키마 또는 내용의 차이는보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">기본적으로 각 INSERT 문은 자체 트랜잭션입니다. 그러나 여러 개의 INSERT 문을 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 로 둘러싸면 모든 삽입이 단일 트랜잭션으로 그룹화됩니다. 트랜잭션을 커밋하는 데 필요한 시간은 동봉 된 모든 insert 문에서 상각되므로 insert 문당 시간이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">기본적으로 각 열은 열 머리글 이름과 첫 번째 데이터 열의 너비에 따라 1-10 자 사이입니다. 열에 맞지 않는 너무 넓은 데이터는 잘립니다. &quot;.width&quot;도트 명령을 사용하여 다음과 같이 열 너비를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">기본적으로 SQLite의 모든 행에는 일반적으로 테이블에서 해당 행을 고유하게 식별 하는 특수한 열 (일반적으로 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &quot;)이 있습니다. 그러나 &quot;WITHOUT ROWID&quot;구가 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 끝에 추가 되면 특수 &quot;rowid&quot;열이 생략됩니다. rowid를 생략하면 공간 및 성능 이점이있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">기본적으로 kvtest는 단일 트랜잭션 내에서 데이터베이스 I / O 측정을 모두 실행합니다. --multitrans 옵션을 사용하여 각 블롭 읽기 또는 쓰기를 별도의 트랜잭션으로 실행하십시오. --multitrans 옵션은 직접 디스크 I / O와 함께 SQLite를 훨씬 느리게하고 비 경쟁적으로 만듭니다. 이 옵션은 SQLite를 최대한 활용하려면 단일 트랜잭션 내에서 가능한 많은 데이터베이스 상호 작용을 그룹화해야한다는 것을 다시 한 번 입증합니다.</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">기본적으로 sqldiff는 제공된 두 데이터베이스 내의 모든 비가 상 테이블을 처리하려고 시도합니다. 한 데이터베이스에는 테이블이 있지만 다른 데이터베이스에는 나타나지 않는 테이블이 있거나 한 데이터베이스에 약간 다른 스키마가있는 테이블은 오류입니다. &quot;--table&quot;옵션이 문제를 일으키는 경우 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">기본적으로 sqlite3은 쿼리 결과를 표준 출력으로 보냅니다. &quot;.output&quot;및 &quot;.once&quot;명령을 사용하여이를 변경할 수 있습니다. 출력 파일의 이름을 .output의 인수로 입력하면 모든 후속 쿼리 결과가 해당 파일에 기록됩니다. 또는 .output 대신 .once 명령을 사용하면 콘솔로 복귀하기 전에 단일 다음 명령에 대해서만 출력이 리디렉션됩니다. 표준 출력에 다시 쓰기 시작하려면 인수없이 .output을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">기본적으로 swarmvtab은 동시에 열려있는 데이터베이스 수를 9 개로 제한하려고합니다. 이 매개 변수를 사용하면 한계를 변경할 수 있습니다. 예를 들어, 최대 30 개의 데이터베이스를 동시에 열 수있는 swarmvtab 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">기본적으로 &quot;.expert&quot;명령은 쿼리 및 데이터베이스 스키마 만 기반으로 인덱스를 권장합니다. 이는 사용자가 데이터 분산 통계를 생성하기 위해 데이터베이스 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하지 않은 경우 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 가 쿼리에 대한 인덱스를 선택 하는 방식과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 자동으로 호출 하여 필요한 경우 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 재설정합니다 . 이 컴파일 타임 옵션은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_reset ()&lt;/a&gt; 에 대한 중간 호출이없는 한 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 또는 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 이외의 것을 반환 한 후 다시 호출하면 sqlite3_step () 이 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 를 반환 하도록 해당 동작을 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">기본적으로 SQLite 코어는 수신하는 가상 테이블의 각 행에서 모든 제약 조건을 이중으로 확인합니다. 이러한 검사가 중복되면 xBestFilter 메소드는 aConstraintUsage []. omit를 설정하여 해당 이중 검사를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">기본적으로 EXPLAIN QUERY PLAN 명령의 출력에는 트리거 프로그램에 의해 수행 된 조작에 대한 출력이 포함되지 않습니다. 이 옵션은이 동작을 제어하는 ​​플래그를 설정하거나 지우는 데 사용됩니다 (기본값). 이 작업에 전달 된 첫 번째 매개 변수는 정수입니다. 트리거 프로그램의 출력을 활성화하려면 양수, 비활성화하려면 0, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는 0 또는 1로 기록 된 정수에 대한 포인터입니다. 트리거에 대한 출력이 비활성화되었는지 여부를 나타냅니다. 비활성화되지 않은 경우 0, 비활성화 된 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">기본적으로 포터 토크 나이 저는 기본 토크 나이저 (unicode61)를 감싸는 래퍼로 작동합니다. 또는 &quot;포터&quot;다음에 &quot;토큰 화&quot;옵션에 하나 이상의 추가 인수가 추가되면 포터 스테 머가 사용하는 기본 토크 나이저에 대한 스펙으로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">기본적으로 세션 모듈 스트리밍 인터페이스는 약 1 KiB 청크로 데이터를 입력 및 출력하려고 시도합니다. 이 피연산자는이 구성 설정의 값을 설정하고 쿼리하는 데 사용될 수 있습니다. 두 번째 인수로 전달 된 포인터는 유형 (int)의 값을 가리켜 야합니다. 이 값이 0보다 크면 입력 및 출력 모두에 대한 새로운 스트리밍 데이터 청크 크기로 사용됩니다. 반환하기 전에 pArg가 가리키는 (int) 값은 스트리밍 인터페이스 청크 크기의 최종 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">기본적으로 쉘은 이제 &quot;자동 설명&quot;모드에 있습니다. &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령 의 출력 은 자동으로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">기본적으로 spellfix1 테이블은 20 개 이하의 결과를 리턴합니다. 일치하는 항목이 적 으면 20 미만을 반환 할 수 있습니다. 쿼리의 WHERE 절에 &quot;top = N&quot;용어를 추가하여 반환 된 행 수의 상한을 변경할 수 있습니다. 여기서 N은 새로운 최대 값입니다. . 예를 들어 5 개의 가장 일치하는 항목을 보려면</target>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">큰 따옴표 ( &quot;)로 묶으면 문자열에 포함 된 큰 따옴표는 두 번째 큰 따옴표 문자를 추가하여 SQL 스타일을 이스케이프 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">각 테이블에 대해 &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 를 한 번 호출하여 테이블을 명시 적으로 지정 하거나</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">데이터베이스 파일에서 열린 파일 핸들의 xCheckReservedLock () 메소드를 호출하여 SQLite는 다른 연결이</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">모든 동의어를 단일 토큰에 매핑합니다. 이 경우 위 예제에서 토크 나이 저는 입력 &quot;first&quot;및 &quot;1st&quot;에 대해 동일한 토큰을 반환합니다. 사용자가 문서를 삽입 할 때 토큰 &quot;i&quot;, &quot;won&quot;, &quot;first&quot;및 &quot;place&quot;에 대한 색인에 항목이 추가되도록 토큰이 실제로 &quot;first&quot;라고 가정하십시오. 사용자가 '1st + place'를 쿼리하면 토크 나이저가 &quot;1st&quot;를 &quot;1st&quot;로 대체하고 쿼리가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">각 검색어의 모든 동의어에 대한 색인을 별도로 조회합니다. 이 경우, 쿼리 텍스트를 토큰화할 때 토크 나이 저는 문서 내의 단일 용어에 대해 여러 동의어를 제공 할 수 있습니다. 그런 다음 FTS5는 각 동의어에 대한 인덱스를 개별적으로 쿼리합니다. 예를 들어 쿼리에 직면했습니다.</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블을 작성하려면 빈 문자열로 설정하십시오. 이 경우 FTS5는 쿼리를 처리 할 때 원래 열 값을 사용할 수 없다고 가정합니다. 전체 텍스트 쿼리 및 일부 보조 기능을 계속 사용할 수 있지만 rowid 이외의 열 값은 테이블에서 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">컬럼 값을 검색하기 위해 언제든지 FTS5가 조회 할 수있는 데이터베이스 오브젝트 (테이블, 가상 테이블 또는 뷰)의 이름으로 설정합니다. 이것을 &quot;외부 컨텐츠&quot;테이블이라고합니다. 이 경우 모든 FTS5 기능을 사용할 수 있지만 전체 텍스트 인덱스의 내용이 명명 된 데이터베이스 개체와 일치하는지 확인하는 것은 사용자의 책임입니다. 그렇지 않으면 쿼리 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">NULL 인수 를 사용하여 &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()에&lt;/a&gt; 대한 호출을 사용하여 데이터베이스의 모든 테이블에서 변경 사항을 모니터링하도록 지정</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">시간에 의해 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; wait_for_unlock_notify ()에 의해 호출, 블록 접속 즉, sqlite3_step () 또는 sqlite3_prepare_v2 이미 거래를 완료 성공에서 () 호출을 방지하는 것이 가능하다. 이 경우, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()가&lt;/a&gt; 반환 되기 전에 unlock-notify 콜백이 즉시 호출됩니다 . 또는 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 가 호출 된 후 스레드가 비동기 적으로 신호되기를 대기하기 전에 두 번째 스레드가 잠금 해제 알림 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">SQLite는 자체 내장 구현을 사용하여 모든 플랫폼과 모든 LOCALE에서 출력이 동일하게 보장됩니다. 일관성과 테스트에 중요합니다. 한 시스템에서 &quot;5.25e + 08&quot;을 제공하고 다른 시스템에서 &quot;5.250e + 008&quot;을 제공하면 문제가 될 수 있습니다. 두 답변 모두 정확하지만 SQLite가 항상 동일한 답변을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">프로그래머는 SELECT 조회의 WHERE 절에서 표준 SQL 표현식을 사용하여 특정 경계 상자와 교차하거나 포함되는 모든 R * Tree 항목을 조회 할 수 있습니다. SELECT의 WHERE 절에서 MATCH 연산자를 사용하여 사용자 지정 R * Tree 쿼리를 사용하면 프로그래머는 상자뿐만 아니라 임의의 영역이나 모양과 교차하는 R * Tree 항목 집합을 쿼리 할 수 ​​있습니다. 이 기능은 예를 들어 3D 공간에 위치한 카메라에서 볼 수있는 R * Tree의 객체 하위 세트를 계산하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">바이트 오프셋</target>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">바이트 코드 엔진</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">바이트 12-15</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">바이트 16-19</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">바이트 20-23</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">바이트 24-27</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">바이트 8-11</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">각 페이지 끝에 사용되지 않은 &quot;예약 된&quot;공간 바이트. 보통 0입니다.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">C API 요구 사항 문서.</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C 인터페이스</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">C 인터페이스 : 세션 모듈</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C는 빠른 코드 작성을위한 훌륭한 언어입니다. C는 때때로 &quot;휴대용 어셈블리 언어&quot;로 설명됩니다. 이를 통해 개발자는 플랫폼간에 이식성을 유지하면서 가능한 한 기본 하드웨어에 최대한 가까이 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">SQLite에 대한 C 언어 인터페이스 사양</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">C 스타일 주석은 이제 토크 나이저에 의해 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">C 스타일 주석은 &quot;/ *&quot;로 시작하고 다음 &quot;* /&quot;문자 쌍까지 또는 입력이 끝날 때까지 포함합니다. C 스타일 주석은 여러 줄에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 C / C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">SQLite 버전 3 용 C / C ++ 인터페이스 (이전)</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">x = w1 일 때 r1 x = w2 일 때 r2 그렇지 않으면 r3 끝</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">CASE 표현</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">사례 x 언제 w1 그때 r1 때 w2 그때 r2 다른 r3 끝</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">CAST 표현식</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">CAST 연산자</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">조작으로 인해 기본 키 값이 중복되는 경우 INSERT 변경을 처리하는 동안 CHANGESET_CONFLICT가 충돌 핸들러에 두 번째 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">제약 조건 확인</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">점검 제한 조건</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">CHECK 제약 조건은 충돌 해결 알고리즘을 올바르게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">COLLATE 연산자</target>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">거래 커밋</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">색인 만들기</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">색인 i2a를 t2 (a)에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">색인 i2b 작성 t2 (b);</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">색인 i3을 t3 (c)에 작성;</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">CREATE TABLE ... AS SELECT 문</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE 문</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLE 및 DROP TABLE은 이제 준비된 명령문으로 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t1 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">테이블 생성 t1 (a, b 기본 키);</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">테이블 생성 t1 (a, b 고유);</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">테이블 생성 t1 (a, b);</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">테이블 생성 t1 (c1 VARIANT);</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t2 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t3 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">트리거 만들기</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">t1 (b)에 고유 색인 t1b 작성;</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">보기 작성</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">가상 테이블 생성</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">작성 및 삭제</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">CSV 내보내기</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">CSV 가져 오기</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 CSV 출력은 이제 행 분리 자로 항상 CRNL을 사용하고 데이터에 포함 된 NL 앞에 CR을 삽입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">캐시 유효성 검사</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">전체 프로세스에 대해 캐시 공유가 활성화 및 비활성화됩니다. 이것은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007-09-04) 에서 변경된 내용 입니다. 이전 버전의 SQLite에서는 공유가 각 스레드에 대해 개별적으로 활성화 또는 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">명령문 핸들에서 sqlite3_reset ()을 호출하십시오. SQLITE_LOCKED 오류는 sqlite3_step ()에 대한 첫 번째 호출에서만 발생할 수 있기 때문에 (sqlite3_step ()에 대한 한 번의 호출은 SQLITE_ROW를 리턴 한 후 다음 SQLITE_LOCKED를 리턴 할 수 없음) 결과에 영향을주지 않고이 시점에서 명령문 핸들이 재설정 될 수 있습니다. 발신자의 관점에서 이 시점에서 sqlite3_reset ()이 호출되지 않은 경우 다음 sqlite3_step () 호출은 SQLITE_MISUSE를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">제공된 명령문 핸들에서 sqlite3_step ()을 호출하십시오. 호출이 SQLITE_LOCKED 이외의 것을 리턴하면이 값을 호출자에게 리턴하십시오. 그렇지 않으면 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">sqlite3rbu_close (X)를 호출하여 sqlite3rbu 객체 포인터를 제거하십시오. sqlite3rbu_step (X)가 대상 데이터베이스에 업데이트를 완전히 적용하기에 충분한 횟수로 호출 된 경우 RBU 데이터베이스가 완전히 적용됨으로 표시됩니다. 그렇지 않으면 RBU 업데이트 응용 프로그램의 상태는 나중에 업데이트 재개를 위해 상태 데이터베이스 (또는 sqlite3rbu_open ()의 상태 데이터베이스 파일 이름이 NULL 인 경우 RBU 데이터베이스)에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">재귀 공통 테이블 표현식에서 &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; 으로 명명 된 테이블을 &quot;재귀 테이블&quot;이라고합니다. 위의 &lt;a href=&quot;syntax/recursive-cte&quot;&gt;재귀 cte&lt;/a&gt; 버블 다이어그램에서 재귀 테이블은 재귀 선택의 FROM 절에 정확히 한 번 나타나야하며 서브 쿼리를 포함하여 초기 선택 또는 재귀 선택의 어느 곳에도 나타나서는 안됩니다. 초기 선택은 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 select&lt;/a&gt; 일 수 있지만 ORDER BY, LIMIT 또는 OFFSET을 포함하지 않을 수 있습니다. 재귀 선택은 복합이 아닌 단순한 선택이어야합니다. 재귀 선택에는 ORDER BY, LIMIT 및 / 또는 OFFSET이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">이미 자동 확장 목록에있는 진입 점 X로 sqlite3_auto_extension (X)를 호출하는 것은 무해합니다. 열린 각 데이터베이스 연결에 대해 시작점이 두 번 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">sqlite3_malloc () 또는 sqlite3_realloc ()에 의해 이전에 리턴 된 포인터로 sqlite3_free ()를 호출하면 해당 메모리가 해제되어 재사용 될 수 있습니다. NULL 포인터로 호출 된 경우 sqlite3_free () 루틴은 작동하지 않습니다. sqlite3_free ()에 NULL 포인터를 전달하는 것은 무해합니다. 해제 된 후에는 메모리를 읽거나 쓰지 않아야합니다. 이전에 해제 된 메모리를 읽더라도 세그먼트 화 오류 또는 기타 심각한 오류가 발생할 수 있습니다. sqlite3_malloc () 또는 sqlite3_realloc ()에서 얻지 못한 NULL이 아닌 포인터로 sqlite3_free ()를 호출하면 메모리 손상, 세그먼트 오류 또는 기타 심각한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULL 포인터 또는 열린 얼룩 핸들이 아닌 인수로이 함수를 호출하면 정의되지 않은 동작이 발생합니다. null 포인터를 사용하여이 루틴을 호출하면 ( &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 실패한 호출로 반환되는 ) 무해한 no-op입니다. 그렇지 않으면,이 함수에 유효한 열린 얼룩 핸들이 전달되면 sqlite3_errcode () 및 sqlite3_errmsg () 함수가 리턴 한 값이 리턴되기 전에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULL 포인터 또는 열린 얼룩 핸들이 아닌 인수로이 함수를 호출하면 정의되지 않은 동작이 발생합니다. null 포인터를 사용하여이 루틴을 호출하면 ( &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 실패한 호출로 반환되는 ) 무해한 no-op입니다. 그렇지 않으면,이 함수에 유효한 열린 얼룩 핸들이 전달되면 sqlite3_errcode () 및 sqlite3_errmsg () 함수가 리턴 한 값이 리턴되기 전에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">0보다 작거나 같은 인수로이 루틴을 호출하면 사용중인 모든 핸들러가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X) 형식의 호출 이 지원되며, 여기서 X는 정수입니다. X가 0이면 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드가 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config ()를&lt;/a&gt; 호출 한 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 제한 조건을 지원하지 않습니다. 받는 호출하는 경우 (기본값)이 구성에 &lt;a href=&quot;vtab#xupdate&quot;&gt;의해 XUpdate&lt;/a&gt; 방법 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT는&lt;/a&gt; 다음 전체 문이 다시 것처럼 압연 &lt;a href=&quot;lang_conflict&quot;&gt;또는 ABORT는&lt;/a&gt; 관계없이 지정된 실제 ON 충돌 모드, 사용자의 SQL 문의 일부로 지정되었다.</target>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X) 형식의 호출 이 지원되며, 여기서 X는 정수입니다. X가 0이면 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 또는 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드가 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config ()를&lt;/a&gt; 호출 한 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 제한 조건을 지원하지 않습니다. 받는 호출하는 경우 (기본값)이 구성에 &lt;a href=&quot;../vtab#xupdate&quot;&gt;의해 XUpdate&lt;/a&gt; 방법 반환 &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT는&lt;/a&gt; 다음 전체 문이 다시 것처럼 압연 &lt;a href=&quot;../lang_conflict&quot;&gt;또는 ABORT는&lt;/a&gt; 관계없이 지정된 실제 ON 충돌 모드, 사용자의 SQL 문의 일부로 지정되었다.</target>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">sqlite3_db_config ()에 대한 호출은 호출이 성공한 것으로 간주되는 경우에만 SQLITE_OK를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">로열티를 지불하지 않고 상용 제품에 SQLite를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">여러 응용 프로그램이나 같은 응용 프로그램의 여러 인스턴스가 단일 데이터베이스 파일에 동시에 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">자동 확장 로딩 취소</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">트리거를 사용하여 변경 사항 캡처</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray ($ PTR, $ N)는 단일 열 (이름이 &quot;value&quot;)이고 0 개 이상의 행 이있는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 입니다. carray ()에서 각 행의 &quot;값&quot;은 $ N 요소 길이의 C 언어 배열에서 가져옵니다. $ PTR은 배열의 시작을 가리키는 포인터입니다. 이런 식으로 carray () 함수는 C 언어 배열을 SQL 쿼리에 바인딩하는 편리한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">대소 문자 접기는 ASCII 문자에 대해서만 수행됩니다. 따라서 &quot;A&quot;와 &quot;a&quot;는 동등한 것으로 간주되지만 &quot;&amp;Atilde;&quot;와 &quot;&amp;atilde;&quot;는 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">대소 문자를 구분하지 않는 유니 코드 문자 일치는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">기본 컨텐츠 테이블에 명시적인 INTEGER PRIMARY KEY 열이있는 경우 rbu_control 컬럼에 저장된 텍스트 값이 FTS 인덱스 및 기본 컨텐츠 테이블과 약간 다르기 때문에 약간 더 어렵습니다. 기본 컨텐츠 테이블의 경우 명시 적 IPK의 rbu_control 텍스트 값에 문자를 포함해야하지만 내재적 인 rowid가있는 FTS 테이블 자체에는 문자를 포함해서는 안됩니다. 이는 불편하지만 다음과 같이 더 복잡한보기를 사용하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">WAL 모드 데이터베이스에 대한 쿼리가 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 반환 할 수 있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">데이터베이스 pInMemory와 zFilename의 페이지 크기가 다른 경우 더 잘 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">실제 값을 무손실로 정수로 변환 할 수 있어도 REAL 또는 INTEGER 값을 NUMERIC에 캐스트하는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">TEXT 또는 BLOB 값을 NUMERIC에 캐스트하면 INTEGER 또는 REAL 결과가 생성됩니다. 입력 텍스트가 정수처럼 보이거나 (소수점이나 지수가 없음) 값이 64 비트 부호있는 정수에 맞도록 충분히 작 으면 결과는 INTEGER입니다. 부동 소수점처럼 보이는 입력 텍스트 (소수점 및 / 또는 지수가 있음) 및 텍스트는 IEEE 754 64 비트 부동 소수점과 51 비트 부호있는 정수 사이에서 무손실로 변환 할 수있는 값을 설명합니다. 결과는 정수입니다. (이전 문장에서, 51 비트 정수는 IEEE 754 64 비트 플로트의 가수 길이보다 1 비트 작으므로 텍스트-플로트 변환을위한 1 비트 마진을 제공하므로 51 비트 정수가 지정됩니다. 64 비트 부호있는 정수 범위를 벗어난 값을 설명하는 텍스트 입력은 REAL 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">선호도가없는 유형 이름으로 값을 캐스트하면 값이 BLOB로 변환됩니다. BLOB로 캐스트는 먼저 데이터베이스 연결 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 에서 값을 TEXT로 캐스트 한 다음 결과 바이트 시퀀스를 TEXT 대신 BLOB로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">INTEGER 또는 REAL 값을 TEXT로 캐스트하면 결과 TEXT가 데이터베이스 연결 의 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 을 사용하는 것을 제외하고 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통해 마치 값이 렌더링 됩니다.</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">일반 독자는 이러한 규칙을 모두 이해하지 않아도됩니다. 이 섹션에서 중요한 것은 쿼리 플래 팅이 안전한시기와 안전하지 않은시기를 결정하는 규칙이 미묘하고 복잡하다는 것입니다. 지나치게 공격적인 쿼리 병합으로 인해 몇 년 동안 여러 버그가 발생했습니다. 반면에 복잡한 쿼리 및 / 또는 뷰와 관련된 쿼리의 성능은 쿼리 병합이보다 보수적 일 경우 어려움을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">사전 컴파일 된 명령문이 만료되도록합니다. sqlite3_step ()을 사용하여 만기 된 명령문이 실행될 때 자동으로 다시 준비되거나 (sqlite3_prepare_v2 ()를 사용하여 작성된 경우) SQLITE_SCHEMA로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">customer.cust_id가 $ cust_id 매개 변수와 동일한 특정 고객 항목에 대해 customer.cust_addr 필드가 업데이트되도록합니다. 뷰에 할당 된 값이 트리거 본문 내 특수 &quot;NEW&quot;테이블에서 필드로 사용 가능한 방식에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">BEFORE 트리거 사용시주의 사항</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">경고와 버그</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">SQLite 축하 &quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">셀 컨텐츠는 b- 트리 페이지의 셀 컨텐츠 영역에 저장됩니다. SQLite는 셀 포인터 배열의 향후 성장을위한 공간을 확보하기 위해 셀을 가능한 한 b- 트리 페이지 끝쪽으로 배치하려고합니다. 마지막 셀 포인터 배열 항목과 첫 번째 셀의 시작 부분 사이의 영역은 할당되지 않은 영역입니다.</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">셀 형식 요약</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">셀 페이로드</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령&lt;/a&gt; 에서 &lt;a href=&quot;cli#arinsup&quot;&gt;--update 옵션&lt;/a&gt; 을 변경 하여 아카이브에 이미 있고 변경되지 않은 파일을 건너 뜁니다. 작동하는 데 사용되는 --update와 같은 새 --insert 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">성능 향상을 위해 &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; 를 100에서 20으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">이전 기본값 인 512 대신 섹터 크기를 4096으로보고하도록 unix 및 windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 모두 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">카운터 변경</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">SQLite 버전 3.12.0에서 기본 페이지 크기 변경</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">변경 로그</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">Tcl_Obj 인터페이스를 사용하도록 tclsqlite.c를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬&lt;/a&gt; 소스 코드를 변경하여 OpenBSD가 위험한 것으로 간주하는 C 라이브러리 함수를 호출하지 않도록하십시오. (예 : sprintf).</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">쓰기 및 실행 권한이 있지만 읽기 권한이없는 디렉토리가 임시 디렉토리 역할을 할 수 있도록 Unix 에서 &lt;a href=&quot;tempfiles#tempdir&quot;&gt;임시 디렉토리 검색 알고리즘&lt;/a&gt; 을 변경하십시오 . 이 표준을 &quot;.&quot;에 적용하십시오. 대체 디렉토리.</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">쓰기 권한이없는 데이터베이스를 읽을 수 있도록 &lt;b&gt;sqlite&lt;/b&gt; 프로그램을 변경하십시오 . (쓰기가 불가능한 경우 모든 액세스를 거부했습니다.)</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">SQLITE_MASTER 테이블이 (약간) 손상된 경우에도 위의 버그로 읽을 수없는 버전 2.1.1 데이터베이스를이 버전의 라이브러리에서 읽을 수 있도록 코드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">AIX의 C 컴파일러에서 문제를 해결하려면 SrcList.nSrc의 데이터 유형을 u8 유형에서 int 유형으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">최대 16MB 크기의 레코드를 저장할 수 있도록 데이터 레코드 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">더 나은 쿼리 최적화를 위해 인덱스 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">버전 2.1.0에서 시작된 설계 결함을 정정하려면 색인 형식을 변경하십시오. *** 이것은 호환되지 않는 파일 형식 변경입니다. *** 라이브러리 버전 2.6.0 이상이 버전 2.5.6 이하에서 작성된 데이터베이스 파일을 열려고하면 파일 형식이 자동으로 돌이킬 수 없게 변환됩니다. &lt;b&gt;라이브러리의 버전 2.6.0에서 이전 데이터베이스 파일을 열기 전에 백업 사본을 작성하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">데이터베이스 P1의 저널 모드를 P3으로 변경하십시오. P3은 PAGER_JOURNALMODE_XXX 값 중 하나 여야합니다. 다양한 롤백 모드 (삭제, 자르기, 지속, 끄기 및 메모리)간에 변경하는 경우 간단한 조작입니다. IO가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">더 이상 GNUmake 확장이 필요하지 않도록 makefile을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">ALTER TABLE new_X RENAME TO X를 사용하여 new_X의 이름을 X로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">sanity_check PRAGMA의 이름을 &lt;b&gt;integrity_check로&lt;/b&gt; 변경하고 모든 컴파일에서 사용 가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">TEXT 대신 REAL을 반환하도록 round () 함수를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 의 type, name 및 tbl_name 컬럼 이 손상되고 데이터베이스 연결이 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; 모드 가 아닌 경우 오류가 발생하도록 스키마 구문 분석기를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">table_info pragma가 기본값이없는 경우 기본값으로 NULL을 리턴하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">콜백 스크립트가 지정되지 않은 경우 tclsqlite &quot;eval&quot;메소드를 변경하여 결과 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 가 전체 요청 바이트 수보다 적은 값을 리턴하는 read () 시스템 호출을 허용하도록 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">SQL 표준을 준수하기 위해 SUM ()이 NULL 값을 처리하는 방식 변경</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">에 xFileControl () 메소드를 변경하는 모든 내장 돌아 VFSes &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 대신 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; 알 수없는 동작 코드.</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">0으로 끝나지 않은 문자열을 비교할 때 memcmp () 대신 strncmp () 또는 이와 동등한 항목을 사용하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">지수 표기법 (예 : 1.234e + 05)의 숫자가 숫자 순서로 정렬되도록 비교 기능을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 기&lt;/a&gt; 의 기본 구성이 각각 128 바이트의 500 개 슬롯에서 512 바이트의 125 개 슬롯으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">+9223372036854775807보다 큰 부동 소수점 값이 정수로 캐스트 될 때 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식에&lt;/a&gt; 대해 정의 된 동작이 변경되어 결과는 가능한 가장 작은 정수 대신 -9223372036854775808이 될 수 있습니다. 이 변경 후 CAST (INT는 9223372036854775809.0)가 -9223372036854775808 대신 +9223372036854775807을 산출합니다. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; 잠재적으로 호환되지 않는 변경!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">부동 소수점 값의 인쇄 형식이 &quot;% g&quot;에서 &quot;% .15g&quot;로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">이전 버전과 호환되지만 해당 인터페이스를 사용하는 새로운 응용 프로그램 빌드에서 경고가 발생할 수있는 방식으로 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 인터페이스 의 프로토 타입을 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">이전 버전과 호환되지만 컴파일러 경고가 발생할 수있는 방식으로 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xDlSym 메소드의 서명을 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">변경 그룹 핸들</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">SQLite 버전 3.7.10의 변경 사항</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">SQL 문을 실행하여 데이터베이스를 변경합니다. 세션 개체는 이러한 변경 사항을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">하나 이상의 PRIMARY KEY 열에 NULL 값이 저장된 개별 행에 대한 변경 내용은 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">하나 이상의 PRIMARY KEY 열에 NULL 값이 저장된 행의 변경 내용은 기록되지 않습니다. 이러한 행을 삽입하거나 삭제하면이 함수가 반환 한 변경 집합에 해당하는 변경 사항이 없습니다. PRIMARY KEY 열에 저장된 하나 이상의 NULL 값이있는 기존 행이 업데이트되어 모든 PRIMARY KEY 열이 NULL이 아닌 경우 INSERT 만 변경 세트에 나타납니다. 마찬가지로, 하나 이상의 PRIMARY KEY 열이 NULL로 설정되도록 NULL이 아닌 PRIMARY KEY 값이있는 기존 행을 업데이트하면 결과 변경 집합에 DELETE 변경 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">CREATE TABLE 문의 일부로 PRIMARY KEY가 명시 적으로 정의 된 테이블에 대해서만 변경 사항을 기록 할 수 있습니다. PRIMARY KEY가 &quot;INTEGER PRIMARY KEY&quot;(행 별명)인지 여부는 중요하지 않습니다. PRIMARY KEY는 단일 열로 구성되거나 복합 키일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;외래 키 작업의&lt;/a&gt; 일부로 변경 한 내용은 개수에 포함되지만 REPLACE 제약 조건 해결의 일부로 변경 한 내용 은 포함되지 않습니다. INSTEAD OF 트리거에 의해 인터셉트 된 뷰에 대한 변경 사항은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업의&lt;/a&gt; 일부로 변경 한 내용은 개수에 포함되지만 REPLACE 제약 조건 해결의 일부로 변경 한 내용 은 포함되지 않습니다. INSTEAD OF 트리거에 의해 인터셉트 된 뷰에 대한 변경 사항은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">커밋하기 전에 한 데이터베이스 연결에서 변경 한 내용은 다른 모든 데이터베이스 연결에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">CREATE VIRTUAL TABLE 문 변경</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">SELECT 문 변경</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거에&lt;/a&gt; 의해 인터셉트 된 뷰에 대한 변경 사항 은 계산되지 않습니다. 뷰에서 INSERT, UPDATE 또는 DELETE 문이 실행 된 직후 sqlite3_changes ()에 의해 리턴 된 값은 항상 0입니다. 실제 테이블에 대한 변경 사항 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거에&lt;/a&gt; 의해 인터셉트 된 뷰에 대한 변경 사항 은 계산되지 않습니다. 뷰에서 INSERT, UPDATE 또는 DELETE 문이 실행 된 직후 sqlite3_changes ()에 의해 리턴 된 값은 항상 0입니다. 실제 테이블에 대한 변경 사항 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">주석 변경.</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">컴파일 타임 옵션 변경 :</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">변경 그룹에 아직 표시되지 않은 행에 대한 변경 내용은 단순히 해당 그룹에 복사됩니다. 또는 새 변경 세트와 변경 그룹에 단일 행에 적용되는 변경 사항이 포함 된 경우 변경 그룹의 최종 내용은 다음과 같이 각 변경 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">Unix 외에도 Windows에서 작동하도록 일부 테스트 스크립트 변경</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">64 비트 아키텍처를 지원하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체로 변경</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 변경 MSVC를 사용하여 컴파일 할 때 더 잘 작동하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">ODBC 드라이버를 돕기 위해 FULL_COLUMN_NAMES pragma로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">OS- 계층 인터페이스 변경 : 이제 뮤텍스가 재귀 적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">패치 세트 내 변경 사항은 sqlite3session_changeset () 함수에 의해 생성 된 변경 세트와 동일한 방식으로 정렬됩니다 (즉, 단일 테이블에 대한 모든 변경 사항이 함께 그룹화되고 테이블은 세션 객체에 연결된 순서대로 나타납니다).</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">로컬 변경 세트 내의 변경 사항은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">체인지 셋 생성</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">체인저 셋 반복자 핸들</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">변경 집합은 변경 집합에 저장된 위의 세 가지 기준과 일치하는 테이블이 포함 된 데이터베이스에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">파일 시스템 변경</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">다른 데이터베이스 연결이 열려있는 동안 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; 변경</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">data_store_directory 설정 변경은 스레드로부터 안전 &lt;u&gt;하지 않습니다&lt;/u&gt; . 응용 프로그램 내의 다른 스레드가 동시에 SQLite 인터페이스를 실행중인 경우 data_store_directory 설정을 변경하지 마십시오. 그렇게하면 정의되지 않은 동작이 발생합니다. data_store_directory 설정을 변경하면 &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 전역 변수에 기록되며 해당 전역 변수는 뮤텍스에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">foreign_keys 설정을 변경하면 설정이 변경되기 전에 준비된 명령문을 포함하여 데이터베이스 연결을 사용하여 준비된 모든 명령문의 실행에 영향을줍니다. foreign_keys 설정이 변경된 후 레거시 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스를 사용하여 준비된 기존 명령문 은 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">recursive_triggers 설정을 변경하면 설정이 변경되기 전에 준비된 명령문을 포함하여 데이터베이스 연결을 사용하여 준비된 모든 명령문의 실행에 영향을줍니다. recursive_triggers 설정이 변경된 후 레거시 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스를 사용하여 준비된 기존 명령문 은 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">temp_store_directory 설정 변경은 스레드로부터 안전 &lt;u&gt;하지 않습니다&lt;/u&gt; . 응용 프로그램 내의 다른 스레드가 동시에 SQLite 인터페이스를 실행중인 경우 temp_store_directory 설정을 변경하지 마십시오. 그렇게하면 정의되지 않은 동작이 발생합니다. temp_store_directory 설정을 변경하면 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 전역 변수에 기록되며 해당 전역 변수는 뮤텍스에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">데이터베이스 연결이 열린 상태에서이 변수의 값을 변경하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">matchinfo 형식 문자열의 문자는 왼쪽에서 오른쪽으로 처리됩니다. 형식 문자열의 각 문자는 하나 이상의 32 비트 부호없는 정수 값이 반환 된 배열에 추가되도록합니다. 다음 표의 &quot;값&quot;열에는 지원되는 각 형식 문자열 문자의 출력 버퍼에 추가 된 정수 값 수가 포함됩니다. 주어진 공식에서</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 1 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 2 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 3 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">차트 4 : 직접 파일 시스템 쓰기와 관련된 SQLite 쓰기 대기 시간.</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">차트 5 : 직접 파일 시스템 쓰기와 관련된 SQLite 쓰기 대기 시간.</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">시체를 쫓아 라.</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">로컬 (외래 키가 아닌) 제약 조건을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">커서 P1을 점검하여 현재 NULL 행을 가리키는 지 확인하십시오. 그렇다면 레지스터 P3을 NULL로 설정하고 즉시 P2로 점프하십시오. P1이 NULL 행에 없으면 변경하지 않고 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">레지스터 P3의 값을 확인하십시오. 그 후 NULL이면 &lt;a href=&quot;opcode#Halt&quot;&gt;중지&lt;/a&gt; 이것은 마치 P1, P2 및 P4 파라미터 사용 &lt;a href=&quot;opcode#Halt&quot;&gt;정지를&lt;/a&gt; 지시. 레지스터 P3의 값이 NULL이 아닌 경우이 루틴은 작동하지 않습니다. P5 매개 변수는 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">데이터베이스 파일에 핫 저널이 있는지 확인하십시오. 파일에 핫 저널이 없으면 완료된 것입니다. 즉시 반납하십시오. 핫 저널이있는 경우이 알고리즘의 후속 단계에서 해당 저널을 롤백해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">올바른 데이터베이스 엔진을 선택하기위한 점검 목록</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">검사 점 정보 및 잠금</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">검사 점 모드 값</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">데이터베이스 검사 점</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료 될 때까지 기다리지 않고 가능한 많은 프레임을 체크 포인트 한 다음 로그의 모든 프레임이 체크 포인트 된 경우 데이터베이스 파일을 동기화하십시오. 사용 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;중인 핸들러 콜백&lt;/a&gt; 은 SQLITE_CHECKPOINT_PASSIVE 모드에서 호출되지 않습니다. 반면에 패시브 모드는 동시 판독기 또는 기록기가있는 경우 검사 점을 완료하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료 될 때까지 기다리지 않고 가능한 많은 프레임을 체크 포인트 한 다음 로그의 모든 프레임이 체크 포인트 된 경우 데이터베이스 파일을 동기화하십시오. 사용 &lt;a href=&quot;busy_handler&quot;&gt;중인 핸들러 콜백&lt;/a&gt; 은 SQLITE_CHECKPOINT_PASSIVE 모드에서 호출되지 않습니다. 반면에 패시브 모드는 동시 판독기 또는 기록기가있는 경우 검사 점을 완료하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료되기를 기다리지 않고 가능한 많은 프레임을 체크 포인트하십시오. 로그의 모든 프레임이 체크 포인트되면 db 파일을 동기화하십시오. 이 모드는 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 . &lt;a href=&quot;c3ref/busy_handler&quot;&gt;바쁜 핸들러 콜백은&lt;/a&gt; 이 모드에서 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">체크 포인트 데이터베이스 P1. P1이 현재 WAL 모드에 있지 않으면 이것은 작동하지 않습니다. 매개 변수 P2는 SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART 또는 TRUNCATE 중 하나입니다. 검사 점이 각각 SQLITE_BUSY를 반환하는지 여부를 mem [P3]에 1 또는 0을 씁니다. 검사 점 다음에 WAL의 페이지 수를 mem [P3 + 1]에 기록하고 검사 점이 완료된 후 검사 점에 도달 한 WAL의 페이지 수를 mem [P3 + 2]에 기록하십시오. 그러나 오류가 발생하면 mem [P3 + 1] 및 mem [P3 + 2]가 -1로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">검사 점 시퀀스 번호</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">체크 포인트는 전원 손실 또는 하드 재부팅으로 인한 데이터베이스 손상의 가능성을 피하기 위해 동기화 작업이 필요합니다. 콘텐츠를 WAL에서 데이터베이스로 이동하기 전에 WAL을 영구 저장소에 동기화해야하며 WAL을 재설정하기 전에 데이터베이스 파일을 동기화해야합니다. 체크 포인트는 더 많은 탐색이 필요합니다. 검사 점은 데이터베이스에 가능한 많은 순차 페이지 쓰기를 수행하기 위해 노력하지만 (페이지가 WAL에서 데이터베이스로 오름차순으로 전송 됨), 그럼에도 불구하고 일반적으로 페이지 쓰기 사이에 많은 찾기 작업이 분산됩니다. 이러한 요소들이 결합되어 체크 포인트가 쓰기 트랜잭션보다 느려집니다.</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">이 메커니즘에 의해 시작된 체크 포인트는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;수동입니다&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">이 메커니즘에 의해 시작된 체크 포인트는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;수동입니다&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">&quot;fired&quot;플래그가 설정되어 있는지 확인합니다. 그렇다면 잠금 해제 알림 콜백이 이미 호출되었습니다. 뮤텍스를 풀고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">WAL 파일에서 마지막 프레임의 체크섬.</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">체크섬 -1 :이 페이지를 포함하여 누적 체크섬</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">체크섬 -1 : 헤더의 첫 24 바이트에 대한 체크섬의 첫 부분</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">체크섬 -2 : 누적 체크섬의 후반.</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">체크섬 -2 : 헤더의 처음 24 바이트에있는 체크섬의 두 번째 부분</target>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">3.30.0 릴리스 이후 발견 된 다른 모호한 문제에 대한 Cherrypick 수정</target>
        </trans-unit>
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">가장 오른쪽이 아닌 가장 왼쪽의 SELECT에서 복합 쿼리의 열 이름을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">각 루프에 적합한 인덱스 선택</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">주석과 변수 이름을 정리하십시오. 설명서 변경. 코드의 기능 변경이 없습니다.</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">데이터베이스 파일이나 저널의 중간에 잘못된 데이터를 초래하는 하드웨어 또는 운영 체제 결함으로 인해 문제가 발생할 수 있습니다. 마찬가지로, 불량 프로세스가 데이터베이스 파일 또는 저널을 열고 조작 된 데이터를 그 중간에 쓰면 데이터베이스가 손상됩니다. 이러한 종류의 문제에 대해서는 할 수있는 일이 많지 않으므로 더 이상주의를 기울이지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">클라이언트 응용 프로그램은 일반적으로 다양한 SQL 데이터베이스 엔진에 연결할 수있는 일반 데이터베이스 인터페이스를 사용합니다. 지원되는 데이터베이스의 혼합에 SQLite를 포함시키고 SQLite 엔진을 클라이언트와 정적으로 링크하는 것이 좋습니다. 이렇게하면 테스트 또는 데모를 위해 클라이언트 프로그램을 SQLite 데이터 파일과 함께 독립형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">클라이언트 / 서버 SQL 데이터베이스 엔진은 엔터프라이즈 데이터의 공유 저장소를 구현하려고 노력합니다. 확장 성, 동시성, 중앙 집중화 및 제어를 강조합니다. SQLite는 개별 응용 프로그램 및 장치에 로컬 데이터 저장소를 제공하기 위해 노력하고 있습니다. SQLite는 경제성, 효율성, 신뢰성, 독립성 및 단순성을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">클라이언트 / 서버 데이터베이스 엔진은 네트워크의 핵심에있는 사랑스런 데이터 센터 내부에 살도록 설계되었습니다. SQLite도 작동하지만 SQLite는 네트워크의 가장자리에서 번성하여 연결성이 떨어지는 응용 프로그램에 빠르고 안정적인 데이터 서비스를 제공하면서 스스로를 지키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">MySQL, PostgreSQL, SQL Server, Oracle 등과 같은 클라이언트 / 서버 데이터베이스는 최신 시스템의 중요한 구성 요소입니다. 이 시스템은 중요한 문제를 해결합니다. 그러나 SQLite는 다른 문제를 해결합니다. SQLite 및 클라이언트 / 서버 데이터베이스 모두 역할이 있습니다. SQLite를 다른 SQL 데이터베이스 엔진과 비교하는 개발자는이 차이점을 명확하게 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">BLOB 핸들 닫기</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">이전에 P1으로 열린 커서를 닫습니다. P1이 현재 열려 있지 않으면이 명령은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">두 커서를 모두 닫습니다.</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">커서를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">데이터베이스 연결 닫기</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">연결 종료</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">연결을 닫는 중입니다.</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">데이터베이스 연결을 닫는 것은 간단합니다. 열린 VFS 파일 핸들이 닫혀 있고 메모리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">알몸을 입으십시오.</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">클러스터형 인덱스 및 WITHOUT ROWID 최적화</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">클러스터형 인덱스</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">코 루틴은 메모리를 덜 사용하기 때문에 서브 쿼리의 전체 결과 세트를 임시 테이블에 저장하는 것보다 코 루틴이 좋습니다. 동시 루틴을 사용하면 결과의 단일 행만 기억해야하지만 결과의 모든 행은 임시 테이블에 저장해야합니다. 또한 외부 쿼리가 작업을 시작하기 전에 코 루틴을 완료하기 위해 실행하지 않아도되므로 첫 번째 출력 행이 훨씬 더 빨리 나타날 수 있으며 전체 쿼리가 중단되면 전체적으로 더 적은 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">코드 생성기</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">윤리 강령</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">코드 변경 검사</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">OpenWatcom을 사용하여 깨끗하게 컴파일되도록 코드 변경.</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">성능 향상을위한 코드 최적화 및 리팩토링.</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">우연히도, 동일한 색인이 특정 팀의 팀 리더를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">조합 순서는 두 개의 텍스트 문자열을 비교하는 데 사용됩니다. 조합 순서는 텍스트의 NULL, 숫자 또는 BLOB 순서를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">콜 레이션에 필요한 콜백</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">종합적으로, aPgno 항목은 WAL 파일의 모든 프레임에 저장된 데이터베이스 페이지 번호를 기록합니다. 첫 번째 해시 테이블의 aPgno [0] 항목은 WAL 파일의 첫 번째 프레임에 저장된 데이터베이스 페이지 번호를 기록합니다. 첫 번째 해시 테이블의 aPgno [i] 항목은 WAL 파일의 i 번째 프레임에 대한 데이터베이스 페이지 번호입니다. 두 번째 해시 테이블의 aPgno [k] 항목은 WAL 파일에서 (k + 4062) 번째 프레임의 데이터베이스 페이지 번호입니다. shm 파일의 n 번째 32768 바이트 해시 테이블에 대한 aPgno [k] 항목 (n&amp;gt; 1의 경우)은 (k + 4062 + 4096 * (n-2)) 번째 프레임에 저장된 데이터베이스 페이지 번호를 보유합니다. WAL 파일의</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">구어체 적으로 Robson 증거는 고장없는 작동을 보장하기 위해 모든 메모리 할당자가 최대 크기의 비율 &lt;b&gt;n에&lt;/b&gt; 의존하는 승수에 의해 &lt;b&gt;M&lt;/b&gt; 을 사용한 최대 메모리 양을 초과하는 &lt;b&gt;N&lt;/b&gt; 크기의 메모리 풀을 사용해야 함을 보여줍니다. 가장 작은 할당 크기. 다시 말해서, 모든 메모리 할당이 정확히 같은 크기 ( &lt;b&gt;n&lt;/b&gt; = 1) 가 아니라면 시스템은 한 번에 사용하는 것보다 더 많은 메모리에 액세스해야합니다. 또한 가장 큰 할당량과 가장 작은 할당량의 비율이 증가함에 따라 필요한 잉여 메모리의 양이 급격히 증가하므로 모든 할당을 가능한 한 동일한 크기에 가깝게 유지해야하는 동기가 있습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">열 내용</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">열 선언 유형</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">열 정의</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">결과 집합의 열 이름</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">열 정의</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">열 필터 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">열 필터 사양은 괄호로 묶인 임의의 표현식에도 적용될 수 있습니다. 이 경우 열 필터는 표현식 내의 모든 구에 적용됩니다. 중첩 열 필터 작업은 일치하는 열의 하위 집합 만 추가로 제한 할 수 있으며 필터링 된 열을 다시 활성화하는 데 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">UPDATE 문의 열 이름은 대소 문자를 구분했습니다. 이 실수는 이제 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">DO UPDATE 표현식의 열 이름은 INSERT를 시도하기 전에 열의 원래 변경되지 않은 값을 참조합니다. 제약 조건이 실패하지 않았을 때 삽입되었을 값을 사용하려면 특수한 &quot;제외&quot;를 추가하십시오. 테이블 규정자를 열 이름에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">zColumn 열이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">zColumn 열은 인덱스, PRIMARY KEY 또는 UNIQUE 제약 조건의 일부이며 읽기 / 쓰기 액세스를 위해 Blob이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">열 분리기는 선택적 열 구분자 문자열입니다. 기본값은 ASCII 탭 문자 \ t입니다.</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">INTEGER PRIMARY KEY 유형의 열은 실제로 테이블의 기본 B- 트리 표현에서 기본 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">LIKE 및 GLOB의 구현을 단일 패턴 일치 서브 루틴으로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">SQLite의 모든 코드를 하나의 큰 파일로 결합하면 SQLite를보다 쉽게 ​​배포 할 수 있습니다. 추적 할 파일은 하나뿐입니다. 또한 모든 코드가 단일 변환 단위로되어 있기 때문에 컴파일러는보다 나은 절차 간 최적화를 수행하여 기계 코드가 5 %에서 10 % 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">SQLite 데이터베이스를 관리하는 데 사용할 수 있는 독립형 &lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; (CLI) 클라이언트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">SQLite 용 명령 줄 셸</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">주석은 SQL 명령이 아니지만 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 및 관련 인터페이스에 전달 된 SQL 쿼리 텍스트 내에서 발생할 수 있습니다 . 주석은 구문 분석기에서 공백으로 처리됩니다. 주석은 여러 줄에 걸쳐있는 내부 표현식을 포함하여 공백이있는 모든 위치에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">주석은 내부 표현식 및 다른 SQL 문의 중간을 포함하여 공백이 발생할 수있는 모든 위치에 나타날 수 있습니다. 주석이 중첩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">커밋 및 롤백 알림 콜백</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">2 단계에서 시작한 트랜잭션을 커미트하십시오.</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">위의 1 단계에서 시작된 트랜잭션을 커미트하십시오.</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">커밋</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">거래 커밋</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">다중 파일 트랜잭션 커밋</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">명세서 거래 커밋.</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">공통 테이블 표현식 또는 CTE 는 단일 SQL 문 기간 동안 만 존재하는 임시 &lt;a href=&quot;lang_createview&quot;&gt;보기&lt;/a&gt; 처럼 작동 합니다. 공통 테이블 표현식에는 &quot;일반&quot;과 &quot;재귀&quot;의 두 가지 종류가 있습니다. 일반 공통 테이블 표현식은 기본 SQL 문에서 서브 쿼리를 인수 화하여 쿼리를 더 쉽게 이해하는 데 도움이됩니다. 재귀 공통 테이블 표현식은 SQL 언어에서 사용할 수없는 기능인 트리 및 그래프의 계층 적 또는 재귀 쿼리를 수행하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">두 스냅 샷 핸들의 연령 비교</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">두 스냅 샷 핸들의 연령을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">레지스터 P1과 P3의 값을 비교하십시오. reg (P3) &amp;lt;reg (P1)이면 주소 P2로 이동하십시오. 또는 SQLITE_STOREP2 플래그가 P5 저장소에 설정된 경우 비교 결과 (0 또는 1 또는 NULL)를 레지스터 P2에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">레지스터 P1과 P3의 값을 비교하십시오. reg (P3) == reg (P1)이면 주소 P2로 이동하십시오. 또는 SQLITE_STOREP2 플래그가 P5에 설정된 경우 비교 결과를 레지스터 P2에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">reg (P1) .. reg (P1 + P3-1) (이 벡터를 &quot;A&quot;라고 함)와 reg (P2) .. reg (P2 + P3-1) ( &quot;B&quot;)의 레지스터 벡터 두 개를 비교합니다. 다음 &lt;a href=&quot;opcode#Jump&quot;&gt;점프&lt;/a&gt; 명령 에서 사용할 비교 결과를 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">선호도 규칙 비교</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">비교 표현</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">fts4와 비교</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">호환성 노드 : SQLite 버전 3.28.0 (2019-04-16) 이전에는 --update 옵션 만 지원되었지만 변경 여부에 관계없이 모든 파일을 항상 다시 삽입한다는 점에서 --insert와 비슷하게 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">특별한 원격 측정 또는 디버깅 옵션없이 제공된 구성으로 SQLite를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">fts 컴파일</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">컴파일 시간 옵션 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; 중 하나를 사용하여 SQLite 라이브러리를 컴파일하십시오 . 8 + 3 파일 이름에 대한 지원은 약간의 오버 헤드를 유발하므로 기본적으로 SQLite에 포함되지 않습니다. 오버 헤드는 작지만 8 + 3 파일 이름 지원이 필요하지 않은 수십억 개의 SQLite 응용 프로그램에 부담을주고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">컴파일 타임 인증 콜백</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">컴파일 타임 라이브러리 버전 번호</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">컴파일 타임 옵션</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">컴파일 시간 옵션 OS_UNIX, OS_WIN, OS_OS2, OS_OTHER 및 TEMP_STORE의 이름이 &quot;SQLITE_&quot;접두사를 포함하도록 변경되어 응용 프로그램 소프트웨어와 네임 스페이스 충돌이 발생하지 않도록합니다. 이러한 옵션의 새 이름은 각각 SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER 및 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">SQLite에 대한 컴파일 시간 옵션은 C-preprocessor 매크로에 의해 제어됩니다. SQLite 버전 3.6.0은 이러한 매크로 중 일부의 이름을 변경하여 SQLite와 관련된 모든 C 전 처리기 매크로가 &quot;SQLITE_&quot;접두사로 시작되도록합니다. 이것은 다른 소프트웨어 모듈과 이름 충돌의 위험을 줄이기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">SQL 문 컴파일</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">로드 가능한 확장 컴파일</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">CLI 컴파일</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">TCL 인터페이스 컴파일</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">GCC 및 -Os로 컴파일하면 크기가 500KB보다 약간 작은 이진 파일이 생성됩니다. (업데이트 2018-07-07 : &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; 및 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 과 같은 새로운 기능이 추가 되었기 때문에 라이브러리 공간이 500KB보다 약간 큽니다.)</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">단일 스레드 응용 프로그램에서 사용할 수 있도록 모든 뮤텍스를 완전히 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">완료 = 100 % * (pagecount ()-나머지 ()) / pagecount ()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된&lt;/a&gt; 큰 문장으로 컴파일하는 복잡한 SQL 쿼리 .</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">구성 요소 테이블은 ROWID없이 선언되어서는 안되며 모두 동일한 스키마를 가져야하지만 데이터베이스 내에서 이름이 다를 수 있습니다. 이 문맥에서 &quot;동일한 스키마&quot;는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">복합 SELECT 문</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">UNION, EXCEPT 또는 INTERSECT로 결합 된 복합 SELECT 문</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">복합 선택문</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">복합 선택</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">압축 된 FTS4 내용</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">결과의 현재 행에 대한 모든 열을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">만델 브로트 세트 계산</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">현재 날짜를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">현재 유닉스 타임 스탬프를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">유닉스 타임 스탬프 1092941466이 주어진 날짜와 시간을 계산하고 현지 시간대를 보상하십시오.</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">유닉스 타임 스탬프 1092941466이 주어진 날짜와 시간을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">현재 연도의 10 월 첫 번째 화요일 날짜를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">해시 값을 계산합니다. h = P * 383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">현재 달의 마지막 날을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">미국 독립 선언서에 서명 한 후 일 수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">2004 년 특정 시점 이후의 시간 (초)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">정수 레지스터 P2를 레지스터 P1로 나눈 후 나머지를 계산하고 결과를 레지스터 P3에 저장합니다. 레지스터 P1의 값이 0이면 결과는 NULL입니다. 피연산자 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">유닉스 시대 이후 초 단위로 시간을 계산하십시오 (분수 부분을 포함하지 않는 strftime ( '% s', 'now')).</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">세트의 전이 폐쇄를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">두 개의 Changeset 객체 연결</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">현재 VFS 구현에서는 운영 체제 이식성을 위해 메모리 매핑 된 파일을 사용하지만 개념적으로 wal-index는 공유 메모리입니다. 메모리 매핑 된 파일은 데이터베이스와 동일한 디렉토리에 있으며 접미사 가 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;인 데이터베이스와 이름이 같습니다 . wal-index는 공유 메모리이므로 데이터베이스의 모든 클라이언트가 동일한 메모리를 공유 할 수 있어야하기 때문에 클라이언트가 다른 시스템에있을 때 SQLite는 네트워크 파일 시스템에서 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">개념적으로 단일 삭제 모드 잠금이 있습니다. 단일 데이터베이스 연결에 대한 DELETE 모드 잠금은 다음 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">여러 프로세스에 의한 동시 사용</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">구성 가능한 편집 거리</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">구성 옵션</target>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 저 객체 구성</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">자동 검사 점 구성</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">데이터베이스 연결 구성</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">글로벌 매개 변수 구성</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">sqlite3changeset_apply_v2 ()에 대한 이전 호출에서 얻은 버퍼 pRebase (크기 nRebase 바이트)에 설명 된 충돌 해결에 따라 변경 세트를 리베이스하도록 변경 세트 리저 저 오브젝트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">메모리 매핑 된 I / O 구성</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 구성</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">ON UPDATE 또는 ON DELETE 작업을 구성한다고해서 외래 키 제약 조건을 만족할 필요는 없습니다. 예를 들어, &quot;ON DELETE SET DEFAULT&quot;조치가 구성되어 있지만 상위 테이블에 하위 키 열의 기본값에 해당하는 행이없는 경우 종속 하위 키가 존재하는 동안 상위 키를 삭제하면 여전히 외부 키가 발생합니다. 위반. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">갈등 해결 알고리즘</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">충돌 해결 모드</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">충돌 알고리즘은 INSERT 문에 대한 SQLite 충돌 알고리즘 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">연결은 WAL 모드와 다양한 롤백 모드 사이에서 변경 될 때 독점 잠금을 유지합니다. 연결이 WAL 모드에서 연결을 끊을 때 독점 잠금을 얻으려고 시도 할 수도 있습니다. 연결이 독점 잠금을 확보 할 수있는 경우 이는 데이터베이스에 대한 유일한 연결이므로 검사 점을 시도한 다음 WAL 색인 및 WAL 파일을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">&quot;CREATE TABLE big (json JSON)&quot;이있는 다른 데이터베이스를 고려하십시오. 데이터의 완전한 라인 별 분해를 보려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">약간 다른 시나리오를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">일부 단어 모음에서 각 단어의 발생 횟수와 함께 단어의 어휘를 저장하기위한 표 (아래 그림 참조)를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">다음과 같은 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">조직의 구성원과 해당 조직 내의 명령 체인을 설명하는 표를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">예를 고려하십시오. 문자열 값을 사용자 입력에서 얻은 데이터베이스 테이블에 문자열 값을 삽입하려고한다고 가정하십시오. 삽입 할 문자열이 zString이라는 변수에 저장되었다고 가정하십시오. 삽입을 수행하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">쿼리 최적화 프로그램에서 WHERE 제약 조건을 인덱스와 일치시킬 때 명시 적 대조 절을 고려하십시오. 티켓 # 2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">이 쿼리의 작동 방식을 고려하십시오. 초기 선택은 먼저 실행되고 단일 열 &quot;1&quot;을 가진 단일 행을 반환합니다. 이 한 행이 대기열에 추가됩니다. 단계 2a에서, 하나의 행이 큐로부터 추출되어 &quot;cnt&quot;에 추가된다. 그런 다음, 단계 2c에 따라 재귀 선택이 실행되어 &quot;2&quot;값을 갖는 단일의 새로운 행이 큐에 추가된다. 대기열에는 여전히 하나의 행이 있으므로 2 단계가 반복됩니다. &quot;2&quot;행이 추출되어 단계 2a 및 2b에 의해 재귀 테이블에 추가된다. 그런 다음 2를 포함하는 행은 재귀 테이블의 전체 내용 인 것처럼 사용되며 재귀 선택이 다시 실행되어 값이 &quot;3&quot;인 행이 큐에 추가됩니다. 마지막으로 2a 단계에서 큐의 유일한 값은 1000000을 포함하는 행입니다.해당 행이 추출되어 재귀 테이블에 추가됩니다. 그러나 이번에는 WHERE 절로 인해 재귀 선택이 행을 반환하지 않으므로 큐가 비어 있고 재귀가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">단어 &quot;xyzzy&quot;의 발생 횟수를 찾으려면이 테이블을 쿼리하십시오. :</target>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">다음 두 명령 순서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 처리 할 SQL 범위를 제한하십시오. 예를 들어, 데이터베이스 스키마를 변경할 필요가없는 응용 프로그램은 sqlite3_set_authorizer () 콜백을 추가하여 CREATE 또는 DROP 문이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">전원 손실로 인해 디스크 섹터 쓰기가 중단되면 어떻게 될지 고려하십시오. 응용 프로그램이 일부 파일 중간에 2 바이트 또는 3 바이트를 쓰면 운영 체제는 먼저 해당 바이트가 포함 된 전체 섹터를 읽고 메모리의 섹터를 변경 한 다음 전체 섹터를 디스크에 다시 써서이를 구현합니다. 다시 쓰기 도중 전원 손실이 발생하고 섹터가 완전히 기록되지 않은 경우 재부팅 후 다음에 읽을 때 섹터의 오류 수정 코드는 복구 할 수없는 손상을 감지하고 디스크 컨트롤러는 섹터를 모두 0 또는 모두 1로 읽습니다. . 따라서 값은 응용 프로그램 수준에서 작성된 2 바이트 또는 3 바이트 범위를 벗어나서 변경됩니다 (powersafe 덮어 쓰기 속성 위반).</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">슬픔을 콘솔.</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">상수 값 0</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">상수 값 1.이 필드는 열 0과 관련된 모든 용어 오프셋 목록에 대해 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">특수 소멸자 동작을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">충돌 처리기에 전달 된 상수</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">충돌 처리기에서 반환하는 상수</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">SQLite의 제약 조건 충돌 해결</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">FTS5 테이블에 삽입 된 실제 데이터를 포함합니다. 이 그림자 테이블에 존재하지 않는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; FTS5 테이블.</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">가상 테이블에있는 각 행의 각 열 크기를 토큰으로 포함합니다. &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot;옵션&lt;/a&gt; 이 0으로 설정된 경우이 새도우 테이블이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">이 행에 대한 용어 텍스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">지속적 구성 매개 변수의 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">내용 크기</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">길고 오류가 발생하기 쉬운 절차 적 루틴 대신 간결한 SQL 쿼리를 사용하여 컨텐츠에 액세스하고 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">정전이나 충돌시 작업이 거의 또는 전혀 손실되지 않도록 컨텐츠를 지속적으로 원자 적으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">SQLite 데이터베이스에 저장된 콘텐츠는 원본 응용 프로그램의 모든 흔적을 잃어버린 후에도 향후 수십 년 동안 복구 가능성이 높습니다. 코드보다 데이터 수명이 깁니다.</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">콘텐츠가없는 FTS4 테이블은 SELECT 문도 지원합니다. 그러나 docid 열 이외의 테이블 열 값을 검색하려고하면 오류가 발생합니다. 보조 함수 matchinfo ()를 사용할 수 있지만 snippet () 및 offsets ()는 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블은 UPDATE 또는 DELETE 문 또는 rowid 필드에 NULL이 아닌 값을 제공하지 않는 INSERT 문을 지원하지 않습니다. 컨텐츠가없는 테이블은 REPLACE 충돌 처리를 지원하지 않습니다. REPLACE 및 INSERT 또는 REPLACE 문은 일반 INSERT 문으로 처리됩니다. &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete 명령을&lt;/a&gt; 사용하여 contentless 테이블에서 행을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">무 콘텐츠 fts4 테이블</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3에 대한&lt;/a&gt; 지속적인 개선 및 개선 .</target>
        </trans-unit>
        <trans-unit id="2009f584db4b6762c01a87103a205a43fe3cb848" translate="yes" xml:space="preserve">
          <source>Continuing improvements to the test suite and fixes to obscure bugs and inconsistencies that the test suite improvements are uncovering.</source>
          <target state="translated">테스트 스위트에 대한 지속적인 개선 및 테스트 스위트 개선에서 발견 된 버그 및 불일치를 모호하게 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="1ca7bf3d67fb3020228ac37bd4bc93280daba832" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">많은 직관과 달리 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 을 재설정하지 않습니다 . 이 루틴을 사용하여 모든 호스트 매개 변수를 NULL로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cdcbd7d39f460823aca9b9fc7f28e86a6837fad5" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">많은 직관과 달리 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 은 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 을 재설정하지 않습니다 . 이 루틴을 사용하여 모든 호스트 매개 변수를 NULL로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="56e3d51f494e6dd366ee62fae61ac03a93a7f2a3" translate="yes" xml:space="preserve">
          <source>Controlling Depth-First Versus Breadth-First Search Of a Tree Using ORDER BY</source>
          <target state="translated">ORDER BY를 사용하여 트리의 너비 우선 검색에 대한 깊이 우선 제어</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">쿼리 실행을위한 편의 루틴</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="5e7d5a98bcc47f452d8a4ce28a7202d2ed515e6c" translate="yes" xml:space="preserve">
          <source>Conversion Processing</source>
          <target state="translated">변환 처리</target>
        </trans-unit>
        <trans-unit id="d77ae256c17778b6b22cdb6d26f46c01f50b1386" translate="yes" xml:space="preserve">
          <source>Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified. Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be와 UTF-16le 사이의 변환은 항상 제자리에서 수행되며 이전 포인터가 참조하는 버퍼의 내용은 물론 이전 포인터를 무효화하지 않습니다. 다른 종류의 변환은 가능할 때 수행되지만 때로는 불가능할 수도 있으며 이러한 경우 이전 포인터가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="8527a14f28507a486e3c2038fa5167e707f4acec" translate="yes" xml:space="preserve">
          <source>Convert P2 registers beginning with P1 into the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; use as a data record in a database table or as a key in an index. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode can decode the record later.</source>
          <target state="translated">P1로 시작하는 P2 레지스터를 데이터베이스 테이블의 데이터 레코드 또는 인덱스의 키로 사용 하는 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드 형식&lt;/a&gt; 으로 변환하십시오 . &lt;a href=&quot;opcode#Column&quot;&gt;열&lt;/a&gt; 연산 코드는 나중에 기록을 디코딩 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6110d61a4f0b93f4f1786cc181b877ffbc07b6f5" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;#&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%23&lt;/code&gt;&quot;.</source>
          <target state="translated">모든 &quot; &lt;code&gt;#&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;%23&lt;/code&gt; &quot; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb7da03590965d6f39aa9b4cc1a3abd9c78729ec" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;?&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%3f&lt;/code&gt;&quot;.</source>
          <target state="translated">모든 &quot; &lt;code&gt;?&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;%3f&lt;/code&gt; &quot; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba96b2a30818bbfb1c821c9fb2ff8c5dd760ffc" translate="yes" xml:space="preserve">
          <source>Convert all sequences of two or more &quot;&lt;code&gt;/&lt;/code&gt;&quot; characters into a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">둘 이상의 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자 의 모든 시퀀스를 단일 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="9218bd4afe759364703b183410a2dc13af3bfd80" translate="yes" xml:space="preserve">
          <source>Convert array constants in the code to have type &quot;const&quot;.</source>
          <target state="translated">코드의 배열 상수를 &quot;const&quot;유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="efad9a1cd6300f3155adba4fdbf6f2272fac9217" translate="yes" xml:space="preserve">
          <source>Convert from integer to float</source>
          <target state="translated">정수에서 부동으로 변환</target>
        </trans-unit>
        <trans-unit id="2d1e75be417c65c8d6a61a4be607d4baf9fd907e" translate="yes" xml:space="preserve">
          <source>Convert the underlying virtual machine to be a register-based machine rather than a stack-based machine. The only user-visible change is in the output of EXPLAIN.</source>
          <target state="translated">기본 가상 머신을 스택 기반 머신이 아닌 레지스터 기반 머신으로 변환하십시오. 사용자가 볼 수있는 유일한 변경은 EXPLAIN의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="293e7888094e60e7ae942b34aacf8692de6ac28c" translate="yes" xml:space="preserve">
          <source>Convert to the new website: http://www.sqlite.org/</source>
          <target state="translated">새 웹 사이트로 변환하십시오 : http://www.sqlite.org/</target>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="translated">Copy</target>
        </trans-unit>
        <trans-unit id="62e344ae607b939275b619f121fe73746c0c7f9a" translate="yes" xml:space="preserve">
          <source>Copy And Free SQL Values</source>
          <target state="translated">복사 및 사용 가능한 SQL 값</target>
        </trans-unit>
        <trans-unit id="2a054004f4716fcfdd66797784227739af6ae2e6" translate="yes" xml:space="preserve">
          <source>Copy data</source>
          <target state="translated">데이터 복사</target>
        </trans-unit>
        <trans-unit id="a8edd5c34da27f929be29297a3e1a0b2b7d510c9" translate="yes" xml:space="preserve">
          <source>Copy the contents of all</source>
          <target state="translated">모든 내용을 복사</target>
        </trans-unit>
        <trans-unit id="206ba42d17a054137e160f699cf45b4c2254d889" translate="yes" xml:space="preserve">
          <source>Copy the database file using an external tool (for example the unix 'cp' utility or the DOS 'copy' command).</source>
          <target state="translated">외부 도구를 사용하여 데이터베이스 파일을 복사하십시오 (예 : unix 'cp'유틸리티 또는 DOS 'copy'명령).</target>
        </trans-unit>
        <trans-unit id="c901be66df5ef99ab4f24023bacf5da468cc8855" translate="yes" xml:space="preserve">
          <source>Copying a database file without also copying its journal.</source>
          <target state="translated">저널도 복사하지 않고 데이터베이스 파일을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="9a851d1cd68948a591dc0c34333564d39d950b93" translate="yes" xml:space="preserve">
          <source>Copyright on all code was disclaimed. The library is now in the public domain.</source>
          <target state="translated">모든 코드에 대한 저작권이 부인되었습니다. 라이브러리는 이제 공개 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc488c7530d4abc0197fb3c29656e9202c9e37f" translate="yes" xml:space="preserve">
          <source>Core Functions</source>
          <target state="translated">핵심 기능</target>
        </trans-unit>
        <trans-unit id="c93aea3a25070916d94552b3271d6e2cb60ffbf1" translate="yes" xml:space="preserve">
          <source>Core URI query parameters</source>
          <target state="translated">핵심 URI 쿼리 매개 변수</target>
        </trans-unit>
        <trans-unit id="48e09e45c570a5fc20d51a90faf1c88a9a965b16" translate="yes" xml:space="preserve">
          <source>Correct</source>
          <target state="translated">Correct</target>
        </trans-unit>
        <trans-unit id="ab43f5950b771276d5096eea017224ae40627bd3" translate="yes" xml:space="preserve">
          <source>Correct affinity computations for a SELECT on the RHS of an IN operator. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c&lt;/a&gt;.</source>
          <target state="translated">IN 연산자의 RHS에서 SELECT에 대한 올바른 선호도 계산 티켓 &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="0a9b4eee2570183dd2ddac6a6366a16f57f34e60" translate="yes" xml:space="preserve">
          <source>Correct column meta-information returned for aggregate queries</source>
          <target state="translated">집계 쿼리에 대해 올바른 열 메타 정보가 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="27273ddb3178ccf762d7085c22704a1fb0549237" translate="yes" xml:space="preserve">
          <source>Correct handling of columns with redundant unique indexes when those columns are used on the LHS of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 LHS에서 해당 열을 사용할 때 중복 고유 인덱스가있는 열을 올바르게 처리 합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="cfd7a02e00c8b2f225f8799044d14f56f7302d29" translate="yes" xml:space="preserve">
          <source>Correct handling of integers in SQL expressions that are larger than what can be represented by the machine integer.</source>
          <target state="translated">SQL 표현식에서 기계 정수로 표시 할 수있는 것보다 큰 정수를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cd691a2e765f41b11a9cf96cd3df086682295d23" translate="yes" xml:space="preserve">
          <source>Correct miscounts in the sqlite3_analyzer.exe utility related to WITHOUT ROWID tables.</source>
          <target state="translated">WITHOUT ROWID 테이블과 관련된 sqlite3_analyzer.exe 유틸리티의 잘못된 수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfdca133fa3a4141a30355604a149499e687b80" translate="yes" xml:space="preserve">
          <source>Correctly compute a LEFT OUTER JOINs that is constrained on the left table only</source>
          <target state="translated">왼쪽 테이블에만 제한되는 LEFT OUTER JOIN을 올바르게 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ad24fffac831d94ed1f6d73e123b29057262887e" translate="yes" xml:space="preserve">
          <source>Correctly handle NULL filenames in ATTACH and DETACH</source>
          <target state="translated">ATTACH 및 DETACH에서 NULL 파일 이름을 올바르게 처리</target>
        </trans-unit>
        <trans-unit id="f488953bdefc614e6154ab271713b957ab57b302" translate="yes" xml:space="preserve">
          <source>Correctly handle comparisons between an INTEGER PRIMARY KEY and a floating point number.</source>
          <target state="translated">정수 PRIMARY KEY와 부동 소수점 숫자 간의 비교를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="35c4ec0c87f0e558ee367fb68087e03066aab5fb" translate="yes" xml:space="preserve">
          <source>Correctly handle quoted names in CREATE INDEX statements.</source>
          <target state="translated">CREATE INDEX 문에서 인용 된 이름을 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="352dc237e245240eb4ea083bad4ff8dfb11f6950" translate="yes" xml:space="preserve">
          <source>Correctly handle the integer literal -0x8000000000000000 in the query planner.</source>
          <target state="translated">쿼리 플래너에서 정수 리터럴 -0x8000000000000000을 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="88e07d9ff26fe66b408e72d9ac5048ccb06e2c58" translate="yes" xml:space="preserve">
          <source>Correctly interpret negative &quot;PRAGMA cache_size&quot; values when determining the cache size used for sorting large amounts of data.</source>
          <target state="translated">많은 양의 데이터를 정렬하는 데 사용되는 캐시 크기를 결정할 때 음수 &quot;PRAGMA cache_size&quot;값을 올바르게 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="ee9849f5daa0323fb5d424718df3f8368eafb771" translate="yes" xml:space="preserve">
          <source>Correlated Subqueries</source>
          <target state="translated">상관 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="f13b587e5391fe217559af3492527b67d6307d3d" translate="yes" xml:space="preserve">
          <source>Correlated subqueries</source>
          <target state="translated">상관 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="44355aa8b49da824d97a083ad2a8a3860b7b6f30" translate="yes" xml:space="preserve">
          <source>Corresponds to a puzzle like this:</source>
          <target state="translated">다음과 같은 퍼즐에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9de7bd4ef28516474c07432e4cafa11ec15920ae" translate="yes" xml:space="preserve">
          <source>Corruption to the underlying SQLite database file. (See documentation on &lt;a href=&quot;howtocorrupt&quot;&gt;how to corrupt&lt;/a&gt; and SQLite database for additional information.)</source>
          <target state="translated">기본 SQLite 데이터베이스 파일이 손상되었습니다. 추가 정보는 데이터베이스 &lt;a href=&quot;howtocorrupt&quot;&gt;손상&lt;/a&gt; 및 SQLite 데이터베이스에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">수정 된 행 수 계산</target>
        </trans-unit>
        <trans-unit id="2b8bef37451c2cbce07a23488203e5542d9f4dd1" translate="yes" xml:space="preserve">
          <source>Count the number of CPU cycles consumed using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind를&lt;/a&gt; 사용하여 소비 된 CPU주기 수를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="49d2ca2c89047e9021ce54796bb5abdb2fd3bc0c" translate="yes" xml:space="preserve">
          <source>Countless bug fixes</source>
          <target state="translated">수많은 버그 수정</target>
        </trans-unit>
        <trans-unit id="00252cf377dd27368f8326fbe29b91bd69acc82e" translate="yes" xml:space="preserve">
          <source>Countless minor bug fixes, documentation improvements, new and improved test cases, and code simplifications and cleanups.</source>
          <target state="translated">수많은 사소한 버그 수정, 문서 개선, 새롭고 개선 된 테스트 사례, 코드 단순화 및 정리.</target>
        </trans-unit>
        <trans-unit id="30106347ab7dfc885850c282c1789d99c22c045f" translate="yes" xml:space="preserve">
          <source>Coverage Testing</source>
          <target state="translated">적용 범위 테스트</target>
        </trans-unit>
        <trans-unit id="1c7ccdf4836b4b91d53aaf066e241e1e63bcb54a" translate="yes" xml:space="preserve">
          <source>Covering indexes</source>
          <target state="translated">커버링 인덱스</target>
        </trans-unit>
        <trans-unit id="cf43e93921ba031c40cac261f4d24c6115ca0a3e" translate="yes" xml:space="preserve">
          <source>Covering indices</source>
          <target state="translated">취재 지수</target>
        </trans-unit>
        <trans-unit id="ba58feb4df54a21eed20b23d82daa39d2f414cf2" translate="yes" xml:space="preserve">
          <source>Crash and power loss tests</source>
          <target state="translated">충돌 및 전력 손실 테스트</target>
        </trans-unit>
        <trans-unit id="d1e3f610852d10da5d8935701b8e1938e2ea49d4" translate="yes" xml:space="preserve">
          <source>Crash testing seeks to demonstrate that an SQLite database will not go corrupt if the application or operating system crashes or if there is a power failure in the middle of a database update. A separate white-paper titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit in SQLite&lt;/a&gt; describes the defensive measure SQLite takes to prevent database corruption following a crash. Crash tests strive to verify that those defensive measures are working correctly.</source>
          <target state="translated">충돌 테스트는 응용 프로그램이나 운영 체제가 충돌하거나 데이터베이스 업데이트 도중 정전이 발생해도 SQLite 데이터베이스가 손상되지 않는지 보여줍니다. &lt;a href=&quot;atomiccommit&quot;&gt;SQLite의 Atomic Commit&lt;/a&gt; 이라는 제목의 별도 백서 에서는 충돌 후 데이터베이스 손상을 방지하기 위해 SQLite가 취하는 방어 조치에 대해 설명합니다. 충돌 테스트는 이러한 방어 조치가 올바르게 작동하는지 확인하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="a6531b5d9a390a38e977f855630c550e6d918ac6" translate="yes" xml:space="preserve">
          <source>Crash tests in SQLite use a modified VFS that can simulate the kinds of filesystem damage that occur during a power loss or operating system crash. The crash-test VFS can simulate incomplete sector writes, pages filled with garbage data because a write has not completed, and out of order writes, all occurring at varying points during a test scenario. Crash tests execute transactions over and over, varying the time at which a simulated power loss occurs and the properties of the damage inflicted. Each test then reopens the database after the simulated crash and verifies that the transaction either occurred completely or not at all and that the database is in a completely consistent state.</source>
          <target state="translated">SQLite의 충돌 테스트는 전원 손실 또는 운영 체제 충돌 중에 발생하는 파일 시스템 손상을 시뮬레이션 할 수있는 수정 된 VFS를 사용합니다. 충돌 테스트 VFS는 불완전한 섹터 쓰기, 쓰기가 완료되지 않았기 때문에 가비지 데이터로 채워진 페이지 및 비 순차 쓰기가 모두 테스트 시나리오 동안 다양한 시점에서 발생하는 것을 시뮬레이션 할 수 있습니다. 충돌 테스트는 시뮬레이션 된 전력 손실이 발생하는 시간과 손상의 속성에 따라 다양한 트랜잭션을 반복해서 실행합니다. 그런 다음 각 테스트는 시뮬레이션 충돌 후 데이터베이스를 다시 열고 트랜잭션이 완전히 발생했는지 또는 전혀 발생하지 않았으며 데이터베이스가 완전히 일관된 상태인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b3391e1c037afbc39bd6f7690619a52ba958e865" translate="yes" xml:space="preserve">
          <source>Crash when calling undocumented SQL function sqlite_rename_parent() with NULL parameters. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</source>
          <target state="translated">NULL 매개 변수를 사용하여 문서화되지 않은 SQL 함수 sqlite_rename_parent ()를 호출 할 때 충돌이 발생합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbedd1aa577cfa78e4159988e6015e4a622476e7" translate="yes" xml:space="preserve">
          <source>Create A New Changegroup Object</source>
          <target state="translated">새로운 변경 그룹 객체 생성</target>
        </trans-unit>
        <trans-unit id="0eb8a02be6b191c11fc9bb259dafebba87dc4f53" translate="yes" xml:space="preserve">
          <source>Create A New Database</source>
          <target state="translated">새로운 데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">새로운 동적 문자열 객체 생성</target>
        </trans-unit>
        <trans-unit id="b6fb0a01eeb8fbfa08db1af0e99f321400dca595" translate="yes" xml:space="preserve">
          <source>Create A New Session Object</source>
          <target state="translated">새로운 세션 객체 생성</target>
        </trans-unit>
        <trans-unit id="b8c295ec5c8d9e2d803be8b00c7291210939416a" translate="yes" xml:space="preserve">
          <source>Create An Iterator To Traverse A Changeset</source>
          <target state="translated">변경 세트를 순회하는 반복자 작성</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">SQL 함수 작성 또는 재정의</target>
        </trans-unit>
        <trans-unit id="fd00ea9a768424e224cb5c7effdeb94d4b4041fe" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9c0f9f8f5c2a818fac05ebd0144409b195c2755" translate="yes" xml:space="preserve">
          <source>Create a Makefile as described in &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일하는 방법에&lt;/a&gt; 설명 된대로 Makefile을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="340fd5cb0d944699f9f2262601f8e8515f6277c0" translate="yes" xml:space="preserve">
          <source>Create a background thread to perform write operations and call sqlite3async_run().</source>
          <target state="translated">쓰기 작업을 수행하고 sqlite3async_run ()을 호출 할 백그라운드 스레드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="af7db7815d1cb1d51e5af0cd7f358563250421b6" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 저 객체 생성</target>
        </trans-unit>
        <trans-unit id="08a7eb180eb01b1b848907571f8cab91fa3fadc5" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="43d32b083ccd73d48458a8a788df239ec0749647" translate="yes" xml:space="preserve">
          <source>Create a fossil repository to host the private branch using the following command:</source>
          <target state="translated">다음 명령을 사용하여 개인 브랜치를 호스팅 할 화석 저장소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="020976ba5dc8b4a36c10d54c801ec1a4a89f48ac" translate="yes" xml:space="preserve">
          <source>Create a master-journal. The name of the master-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the master journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">마스터 저널을 작성하십시오. 마스터 저널의 이름은 임의적입니다. (현재 구현에서는 이전에 존재하지 않는 이름을 찾을 때까지 기본 데이터베이스 파일 이름에 임의의 접미 부를 추가합니다.) 모든 개별 저널의 이름으로 마스터 저널을 채우고 해당 컨텐츠를 디스크로 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="da3af537bba9d7121766b2210dfaab8be2fac3f3" translate="yes" xml:space="preserve">
          <source>Create a new archive containing specified files.</source>
          <target state="translated">지정된 파일을 포함하는 새 아카이브를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="afef83edf1b36bb49d450af9b70529ceb53e63d8" translate="yes" xml:space="preserve">
          <source>Create a new archive, overwriting any existing archive (either in the current &quot;main&quot; db or in the file specified by a --file option). Each argument following the options is a file to add to the archive. Directories are imported recursively. See above for examples.</source>
          <target state="translated">기존 아카이브를 덮어 쓰면서 새 아카이브를 만듭니다 (현재 &quot;main&quot;db 또는 --file 옵션으로 지정된 파일에 있음). 옵션 뒤에 오는 각 인수는 아카이브에 추가 할 파일입니다. 디렉토리는 재귀 적으로 가져옵니다. 예는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c399fd2512bbe2d0e4a05efd898526951d10b8a" translate="yes" xml:space="preserve">
          <source>Create a new session object attached to database handle db. If successful, a pointer to the new object is written to *ppSession and SQLITE_OK is returned. If an error occurs, *ppSession is set to NULL and an SQLite error code (e.g. SQLITE_NOMEM) is returned.</source>
          <target state="translated">데이터베이스 핸들 db에 첨부 된 새 세션 오브젝트를 작성하십시오. 성공하면 새 오브젝트에 대한 포인터가 * ppSession에 기록되고 SQLITE_OK가 리턴됩니다. 오류가 발생하면 * ppSession이 NULL로 설정되고 SQLite 오류 코드 (예 : SQLITE_NOMEM)가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef7c8e6020507b3b903b737530a1a743ade6fb2" translate="yes" xml:space="preserve">
          <source>Create a partial index by adding a WHERE clause to the end of an ordinary &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">일반 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문의 끝에 WHERE 절을 추가하여 부분 색인을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="7044aef02f57d684bf1ace2c33f2aa3769b845ad" translate="yes" xml:space="preserve">
          <source>Create a static and constant &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object containing pointers to the methods from the previous step.</source>
          <target state="translated">이전 단계의 메소드에 대한 포인터를 포함 하는 정적 및 상수 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce77c2b32feacc25a54f9d8046773c75cc6d0f0f" translate="yes" xml:space="preserve">
          <source>Create an instance of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure containing pointers to all the methods from step 1.</source>
          <target state="translated">1 단계의 모든 메소드에 대한 포인터를 포함 하는 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조 의 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a8ad313a3f6f92e33200837c1d1b7d9a66475fb" translate="yes" xml:space="preserve">
          <source>Create an iterator used to iterate through the contents of a changeset. If successful, *pp is set to point to the iterator handle and SQLITE_OK is returned. Otherwise, if an error occurs, *pp is set to zero and an SQLite error code is returned.</source>
          <target state="translated">변경 세트의 내용을 반복하는 데 사용되는 반복자를 작성하십시오. 성공하면 * pp가 반복자 핸들을 가리 키도록 설정되고 SQLITE_OK가 리턴됩니다. 그렇지 않으면 오류가 발생하면 * pp가 0으로 설정되고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f282c6f0dcaa864a9b91c1b0857728fb4f3b6cf7" translate="yes" xml:space="preserve">
          <source>Create if does not exist?</source>
          <target state="translated">존재하지 않는 경우 생성 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="a6746bd3f5b981be1960788a63b361beb206e80d" translate="yes" xml:space="preserve">
          <source>Create new table</source>
          <target state="translated">새 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="552737e86fdab069e1553393c32b2d735d03da2b" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 사용하여 준비된 명령문 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3aaf4f3bc8aa8975fba3c24e7982e7ad410e2d3" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 사용하여 준비된 명령문 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6cd0fb8dc0636107f3c2eeec94775a363db607d" translate="yes" xml:space="preserve">
          <source>CreateBtree</source>
          <target state="translated">CreateBtree</target>
        </trans-unit>
        <trans-unit id="f6d526ccd323387bacc30fe97239e7bfe08e6f7e" translate="yes" xml:space="preserve">
          <source>Created a new mutex subsystem and made it replicable at compile-time.</source>
          <target state="translated">새로운 mutex 서브 시스템을 작성하고 컴파일시 복제 할 수있게했습니다.</target>
        </trans-unit>
        <trans-unit id="015db039081a96e714bbc870bb70163882fcd0ef" translate="yes" xml:space="preserve">
          <source>Created the &lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; command-line utility.</source>
          <target state="translated">&lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; 명령 행 유틸리티를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="acf789d2331ea2a8bf5399f72dadd8b178eecbe4" translate="yes" xml:space="preserve">
          <source>Creation of a transient imposter table involves a special &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; call. Unlike all other SQLite APIs, &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface is subject to incompatible changes from one release to the next, and so the mechanism described below is not guaranteed to work in future releases of SQLite. The SQLite developers do not consider this a problem because imposter tables should not be used in applications. Imposter tables are for analysis and testing use only.</source>
          <target state="translated">임시 임 포스터 테이블 작성에는 특수 &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 호출이 포함됩니다. 다른 모든 SQLite API와 달리 &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스는 한 릴리스에서 다음 릴리스로 호환되지 않는 변경 사항이 적용되므로 아래에 설명 된 메커니즘이 향후 SQLite 릴리스에서 작동하지 않을 수 있습니다. SQLite 개발자는 임 포스터 테이블을 응용 프로그램에서 사용해서는 안되므로이 문제를 문제로 간주하지 않습니다. 임 포스터 테이블은 분석 및 테스트 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="f3072cfe38995c94aede1e379bdbc87872e32b2e" translate="yes" xml:space="preserve">
          <source>Cross-Platform</source>
          <target state="translated">Cross-Platform</target>
        </trans-unit>
        <trans-unit id="a84c73487927d0c8de6b6f553d91f81e8f3c67ef" translate="yes" xml:space="preserve">
          <source>Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows (Win32, WinCE, WinRT) are supported out of the box. Easy to port to other systems.</source>
          <target state="translated">크로스 플랫폼 : Android, * BSD, iOS, Linux, Mac, Solaris, VxWorks 및 Windows (Win32, WinCE, WinRT)가 기본적으로 지원됩니다. 다른 시스템으로 쉽게 포팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe50f9415f0538595ee673bee95f6e9b7af30913" translate="yes" xml:space="preserve">
          <source>Currently the asynchronous IO extension is compatible with win32 systems and systems that support the pthreads interface, including Mac OS X, Linux, and other varieties of Unix.</source>
          <target state="translated">현재 비동기 IO 확장은 Mac OS X, Linux 및 기타 다양한 Unix를 포함하여 pthreads 인터페이스를 지원하는 win32 시스템 및 시스템과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="5527dcef9928e4b30b2e113bf906b6aad70626b4" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 contains any NULL value, jump immediately to P2. If all terms of the record are not-NULL then a check is done to determine if any row in the P1 index btree has a matching key prefix. If there are no matches, jump immediately to P2. If there is a match, fall through and leave the P1 cursor pointing to the matching row.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드에 NULL 값이 있으면 즉시 P2로 이동하십시오. 레코드의 모든 용어가 NULL이 아닌 경우 P1 인덱스 btree의 행에 일치하는 키 접두사가 있는지 확인하기 위해 검사가 수행됩니다. 일치하는 항목이 없으면 즉시 P2로 이동하십시오. 일치하는 것이 있으면 넘어져서 P1 커서가 일치하는 행을 가리 키도록 둡니다.</target>
        </trans-unit>
        <trans-unit id="d32c868a8066f0bb0c8cbc2fdacd1dcc4df55aff" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is a prefix of any entry in P1 then a jump is made to P2 and P1 is left pointing at the matching entry.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드가 P1의 항목 접 두부 인 경우 P2로 점프하고 P1은 일치하는 항목을 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4499a408e8cf9ba0a64b6a7abae32a3e8598a9c" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is not the prefix of any entry in P1 then a jump is made to P2. If P1 does contain an entry whose prefix matches the P3/P4 record then control falls through to the next instruction and P1 is left pointing at the matching entry.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드가 P1의 항목 접 두부가 아닌 경우 P2로 이동합니다. P1에 접두사가 P3 / P4 레코드와 일치하는 항목이 포함 된 경우 제어는 다음 명령어로 넘어 가고 P1은 일치하는 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="cce417cb09cb0e87ed39f345b9827448814078c5" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the seekHit flag is set on P1, then this opcode is a no-op. But if the seekHit flag of P1 is clear, then check to see if there is any entry in P1 that matches the prefix identified by P3 and P4. If no entry matches the prefix, jump to P2. Otherwise fall through.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. seekHit 플래그가 P1에 설정된 경우이 opcode는 작동하지 않습니다. 그러나 P1의 seekHit 플래그가 명확한 경우 P1에 P3 및 P4로 식별 된 접 두부와 일치하는 항목이 있는지 확인하십시오. 접두사와 일치하는 항목이 없으면 P2로 이동하십시오. 그렇지 않으면 넘어집니다.</target>
        </trans-unit>
        <trans-unit id="22ec5d401662b5703126ca0123e136b6c810e79d" translate="yes" xml:space="preserve">
          <source>CursorHint</source>
          <target state="translated">CursorHint</target>
        </trans-unit>
        <trans-unit id="836bce7485bd48ef5bf35926e3fb08781cfcdae7" translate="yes" xml:space="preserve">
          <source>Custom Builds Of SQLite</source>
          <target state="translated">SQLite의 커스텀 빌드</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">맞춤 페이지 캐시 객체</target>
        </trans-unit>
        <trans-unit id="076c8e2f21c1b5d23882403c8926d30c1101585d" translate="yes" xml:space="preserve">
          <source>Custom auxiliary functions</source>
          <target state="translated">맞춤형 보조 기능</target>
        </trans-unit>
        <trans-unit id="c77373601428abf208eee7bad389ec98739fcb31" translate="yes" xml:space="preserve">
          <source>Custom r-tree queries</source>
          <target state="translated">사용자 정의 r- 트리 쿼리</target>
        </trans-unit>
        <trans-unit id="7057308b175a54061ae194ee69576ebf4bb75f55" translate="yes" xml:space="preserve">
          <source>Custom tokenizers</source>
          <target state="translated">맞춤형 토크 나이저</target>
        </trans-unit>
        <trans-unit id="c9cb8f8539741bdce4da7c0edbda58f7c8a5bb30" translate="yes" xml:space="preserve">
          <source>Custom tokenizers may also support synonyms. Consider a case in which a user wishes to query for a phrase such as &quot;first place&quot;. Using the built-in tokenizers, the FTS5 query 'first + place' will match instances of &quot;first place&quot; within the document set, but not alternative forms such as &quot;1st place&quot;. In some applications, it would be better to match all instances of &quot;first place&quot; or &quot;1st place&quot; regardless of which form the user specified in the MATCH query text.</source>
          <target state="translated">맞춤형 토크 나이 저는 동의어를 지원할 수도 있습니다. 사용자가 &quot;1 등&quot;과 같은 문구를 쿼리하려는 경우를 고려하십시오. 내장 된 토크 나이저를 사용하면 FTS5 쿼리 'first + place'는 문서 세트 내의 &quot;first place&quot;인스턴스와 일치하지만 &quot;1st place&quot;와 같은 대체 형식은 아닙니다. 일부 응용 프로그램에서는 사용자가 MATCH 쿼리 텍스트에 지정된 형식에 관계없이 &quot;1 위&quot;또는 &quot;1 위&quot;의 모든 인스턴스를 일치시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd763a855efd9c913568b8cd20dab17c4af423" translate="yes" xml:space="preserve">
          <source>Cut over configuration management to a new CVS repository with its own CVSTrac bug tracking system.</source>
          <target state="translated">자체 CVSTrac 버그 추적 시스템을 사용하여 구성 관리를 새로운 CVS 저장소로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="fd5aaa888331e7fdbb9873b0f3118383cbd0f6f2" translate="yes" xml:space="preserve">
          <source>Cut-over to the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; for faster and better query plans.</source>
          <target state="translated">컷 오버에 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 빠르고 더 나은 쿼리 계획에 대한.</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="339588e68f8e2dd5f57cc156ab01c5b4dcaa9da0" translate="yes" xml:space="preserve">
          <source>DATABASE</source>
          <target state="translated">DATABASE</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="6e915cae90d2c29f2358559dc05c3df58595f55d" translate="yes" xml:space="preserve">
          <source>DATETIME</source>
          <target state="translated">DATETIME</target>
        </trans-unit>
        <trans-unit id="e37624f858dc2af6156398ee78609c8c3c886ca3" translate="yes" xml:space="preserve">
          <source>DB2</source>
          <target state="translated">DB2</target>
        </trans-unit>
        <trans-unit id="645f10d83e7588e1eb33d0d2939905688a530e61" translate="yes" xml:space="preserve">
          <source>DB2, SQL Anywhere, and Borland Interbase do not allow NULLs in a UNIQUE column.</source>
          <target state="translated">DB2, SQL Anywhere 및 Borland Interbase는 UNIQUE 열에서 NULL을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbdd0b7d0c739234955599c5455d354e4fae19b3" translate="yes" xml:space="preserve">
          <source>DDDDDDDDDD</source>
          <target state="translated">DDDDDDDDDD</target>
        </trans-unit>
        <trans-unit id="3a98757f7ab109581d6b2954839e6421cda4bacd" translate="yes" xml:space="preserve">
          <source>DECIMAL(10,5)</source>
          <target state="translated">DECIMAL(10,5)</target>
        </trans-unit>
        <trans-unit id="c189207a55da45305c884fe2b50e086fcad4724b" translate="yes" xml:space="preserve">
          <source>DEFAULT</source>
          <target state="translated">DEFAULT</target>
        </trans-unit>
        <trans-unit id="b79011ba88d8043cebb3f51bd20a68d85873c9ee" translate="yes" xml:space="preserve">
          <source>DEFAULT VALUES&quot; form of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement is not supported.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문의 DEFAULT VALUES &quot;형식은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb9fe9e9d3e08f670bce95fe32d00c47dbc6b299" translate="yes" xml:space="preserve">
          <source>DEFERRABLE</source>
          <target state="translated">DEFERRABLE</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="5d0190695366a57cfee9ace793fdb8c89b47bb42" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERRED는 데이터베이스에 처음 액세스 할 때까지 트랜잭션이 실제로 시작되지 않음을 의미합니다. 내부적으로 BEGIN DEFERRRED 문은 데이터베이스 연결에서 마지막 명령문이 완료 될 때 일반적으로 발생하는 자동 커밋을 끄는 플래그를 설정하기 만합니다. 이로 인해 명시 적 COMMIT 또는 ROLLBACK까지 또는 오류 또는 ON CONFLICT ROLLBACK 절에 의해 롤백이 발생할 때까지 자동으로 시작된 트랜잭션이 발생합니다. BEGIN DEFERRED 다음의 첫 번째 명령문이 SELECT이면 읽기 트랜잭션이 시작됩니다. 후속 쓰기 명령문은 가능하면 트랜잭션을 쓰기 트랜잭션으로 업그레이드하거나 SQLITE_BUSY를 리턴합니다. BEGIN DEFERRED 다음의 첫 번째 명령문이 쓰기 명령문 인 경우 쓰기 트랜잭션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c44f0fc249bf9f56573cce35739bdbf358753ec9" translate="yes" xml:space="preserve">
          <source>DEFERRED, IMMEDIATE, and EXCLUSIVE transactions</source>
          <target state="translated">지연, 즉시 및 독점 거래</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="ddf5a8b95a67a245ead92340f3a1d492b967db1c" translate="yes" xml:space="preserve">
          <source>DELETE Changes</source>
          <target state="translated">변경 사항 삭제</target>
        </trans-unit>
        <trans-unit id="6d2d8ff5f66968f5a9016744e065d7b055778fa4" translate="yes" xml:space="preserve">
          <source>DELETE FROM t1;</source>
          <target state="translated">t1에서 삭제;</target>
        </trans-unit>
        <trans-unit id="ee62fe04ef6c5b85e13e87e697e2bed7ca49475c" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE a&amp;gt;10 AND a&amp;lt;20000;</source>
          <target state="translated">a&amp;gt; 10 및 a &amp;lt;20000 인 t2로부터 삭제;</target>
        </trans-unit>
        <trans-unit id="a5ebf9c0b02aa24303cdb7fb5cf5371c628bba2a" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE c LIKE '%fifty%';</source>
          <target state="translated">'% fifty %'와 같은 위치에서 t2에서 삭제;</target>
        </trans-unit>
        <trans-unit id="b4aac6d0cf9ea3a89dec994c5ddb8ad46701ed40" translate="yes" xml:space="preserve">
          <source>DELETE records consist of the primary key fields only. The original values of other fields are omitted.</source>
          <target state="translated">DELETE 레코드는 기본 키 필드로만 구성됩니다. 다른 필드의 원래 값은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="b5093023417eb749513563ec16d8c0c821aa5aff" translate="yes" xml:space="preserve">
          <source>DESC</source>
          <target state="translated">DESC</target>
        </trans-unit>
        <trans-unit id="a26814be2b9a9bc0d8c52b43abfaf6e5c82a51a4" translate="yes" xml:space="preserve">
          <source>DESC indices</source>
          <target state="translated">DESC 지수</target>
        </trans-unit>
        <trans-unit id="c10fec47e3203a12a4865741f863a30dc8d9e348" translate="yes" xml:space="preserve">
          <source>DETACH</source>
          <target state="translated">DETACH</target>
        </trans-unit>
        <trans-unit id="53dda846085ef522df42849d527936da7055a14d" translate="yes" xml:space="preserve">
          <source>DETACH DATABASE</source>
          <target state="translated">세부 데이터베이스</target>
        </trans-unit>
        <trans-unit id="45b1a3f093ba639c208b0bbbbe6cad9eff65396f" translate="yes" xml:space="preserve">
          <source>DISTINCT</source>
          <target state="translated">DISTINCT</target>
        </trans-unit>
        <trans-unit id="3804145294052baefad623cd8cebfa752f431578" translate="yes" xml:space="preserve">
          <source>DISTINCT, ORDER BY, GROUP BY, HAVING, LIMIT, and OFFSET</source>
          <target state="translated">구별, 주문, 그룹 별, HAVING, LIMIT 및 오프셋</target>
        </trans-unit>
        <trans-unit id="8feb29077a1df95bd8e261f267cf55119b1eac74" translate="yes" xml:space="preserve">
          <source>DO</source>
          <target state="translated">DO</target>
        </trans-unit>
        <trans-unit id="9bf5aa462fedb77794614582aa9cb6f368384112" translate="yes" xml:space="preserve">
          <source>DOC - Word Perfect and Microsoft Office documents</source>
          <target state="translated">DOC-Word Perfect 및 Microsoft Office 문서</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="0282a2e2726b5fdbd89b48e12c5edb38b5d2c29e" translate="yes" xml:space="preserve">
          <source>DOUBLE PRECISION</source>
          <target state="translated">더블 정밀</target>
        </trans-unit>
        <trans-unit id="39514a7a66f0433579dbc23ecfbb8c6c3e079395" translate="yes" xml:space="preserve">
          <source>DROP</source>
          <target state="translated">DROP</target>
        </trans-unit>
        <trans-unit id="383ac905b2bc5cb0e45bdf7ad063398c7f4d0280" translate="yes" xml:space="preserve">
          <source>DROP INDEX</source>
          <target state="translated">드롭 인덱스</target>
        </trans-unit>
        <trans-unit id="ac02c0b871c5f0a59ae432b32af6203946972208" translate="yes" xml:space="preserve">
          <source>DROP TABLE</source>
          <target state="translated">드롭 테이블</target>
        </trans-unit>
        <trans-unit id="1627fd06710bbc68919d746def7dc2f189b53feb" translate="yes" xml:space="preserve">
          <source>DROP TABLE t1;</source>
          <target state="translated">DROP TABLE t1;</target>
        </trans-unit>
        <trans-unit id="d1be8c338ef5a7bcca5157c5203b61e7d14d5f12" translate="yes" xml:space="preserve">
          <source>DROP TABLE t2;</source>
          <target state="translated">DROP TABLE t2;</target>
        </trans-unit>
        <trans-unit id="5771355d686a88f9aec56e2304026908b55bffb4" translate="yes" xml:space="preserve">
          <source>DROP TABLE t3;</source>
          <target state="translated">DROP TABLE t3;</target>
        </trans-unit>
        <trans-unit id="fc6194eca24e844585523f3d0e5cb90acd2f1cd1" translate="yes" xml:space="preserve">
          <source>DROP TRIGGER</source>
          <target state="translated">드롭 트리거</target>
        </trans-unit>
        <trans-unit id="6a23d5fa27b31fab3e560233e685dfb52af23fcc" translate="yes" xml:space="preserve">
          <source>DROP VIEW</source>
          <target state="translated">드롭 뷰</target>
        </trans-unit>
        <trans-unit id="6a98041e1291d5c0fcb8031e8dc6b0f10dbdcd21" translate="yes" xml:space="preserve">
          <source>DWG - AutoCAD drawings</source>
          <target state="translated">DWG-AutoCAD 도면</target>
        </trans-unit>
        <trans-unit id="4b5fe1d0668c6a074a9b45de43a0ab7e93ea3537" translate="yes" xml:space="preserve">
          <source>Daily in your prayers, with tears and sighs, confess your past sins to God, and amend them for the future.</source>
          <target state="translated">눈물과 한숨으로 매일기도하며 과거의 죄를 하나님 께 고백하고 미래를 위해 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="352953a16a74f0790135416ee3270f630371240c" translate="yes" xml:space="preserve">
          <source>Data Change Notification Callbacks</source>
          <target state="translated">데이터 변경 알림 콜백</target>
        </trans-unit>
        <trans-unit id="a073b1a4a370adc09bf5c624ac412d5da3300853" translate="yes" xml:space="preserve">
          <source>Data can be inserted into such an FTS4 table using an INSERT statements. However, unlike ordinary FTS4 tables, the user must supply an explicit integer docid value. For example:</source>
          <target state="translated">INSERT 문을 사용하여 이러한 FTS4 테이블에 데이터를 삽입 할 수 있습니다. 그러나 일반 FTS4 테이블과 달리 사용자는 명시 적 정수 도큐 드 값을 제공해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dd6b7f9a7a5a10b73550e3715829adf5933cc29" translate="yes" xml:space="preserve">
          <source>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</source>
          <target state="translated">데이터가 지배적입니다. 올바른 데이터 구조를 선택하고 체계적으로 정리 한 경우 알고리즘은 거의 항상 자명합니다. 알고리즘이 아닌 데이터 구조는 프로그래밍의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="7765119a34cb37ce325b7908102a741f5f04decc" translate="yes" xml:space="preserve">
          <source>Data format conversions can invalidate the pointer returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16(). Pointers might be invalided in the following cases:</source>
          <target state="translated">데이터 형식 변환은 sqlite3_column_blob (), sqlite3_column_text () 및 / 또는 sqlite3_column_text16 ()에 대한 이전 호출에서 리턴 된 포인터를 무효화 할 수 있습니다. 다음과 같은 경우 포인터가 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f53192d7efb1f452daf4e4ce9588f68c43c7ab" translate="yes" xml:space="preserve">
          <source>Data read while in the process of opening a read-only transaction (see section</source>
          <target state="translated">읽기 전용 트랜잭션을 여는 과정에서 읽은 데이터 (섹션 참조)</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="c0b1a7d66556ee25336c34353c17486dba3e302f" translate="yes" xml:space="preserve">
          <source>Data-types specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create an FTS table are ignored completely. Instead of the normal rules for applying type &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; to inserted values, all values inserted into FTS table columns (except the special rowid column) are converted to type TEXT before being stored.</source>
          <target state="translated">FTS 테이블을 작성하는 데 사용 된 &quot;CREATE VIRTUAL TABLE&quot;문의 일부로 지정된 데이터 유형은 완전히 무시됩니다. 삽입 된 값에 유형 &lt;a href=&quot;datatype3#affinity&quot;&gt;선호도&lt;/a&gt; 를 적용하는 일반적인 규칙 대신 FTS 테이블 열에 삽입 된 모든 값 (특수 rowid 열 제외)은 저장되기 전에 유형 TEXT로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c196bb9b92e16036aa92c8d07d6256ad34cf47b" translate="yes" xml:space="preserve">
          <source>Database Connection Configuration Options</source>
          <target state="translated">데이터베이스 연결 구성 옵션</target>
        </trans-unit>
        <trans-unit id="87ad120a4ba60c79863260e10eca7015248baadd" translate="yes" xml:space="preserve">
          <source>Database Connection For Functions</source>
          <target state="translated">함수를위한 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="f77d22fb96d5dfa5073b2fe8ffcf8caa0f1f055f" translate="yes" xml:space="preserve">
          <source>Database Connection Handle</source>
          <target state="translated">데이터베이스 연결 핸들</target>
        </trans-unit>
        <trans-unit id="ed913bb076648fca64b8de1c707bbce02bda0945" translate="yes" xml:space="preserve">
          <source>Database Connection Status</source>
          <target state="translated">데이터베이스 연결 상태</target>
        </trans-unit>
        <trans-unit id="d7a15726be6aee139cc047e8d19aae61e2286733" translate="yes" xml:space="preserve">
          <source>Database Connections</source>
          <target state="translated">데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="3390636be52618dc7d118d178ce5ea03789b0200" translate="yes" xml:space="preserve">
          <source>Database Corruption Warning</source>
          <target state="translated">데이터베이스 손상 경고</target>
        </trans-unit>
        <trans-unit id="e9ab5f94bcd6c1898d03a1e6b8469a59f0ed3a77" translate="yes" xml:space="preserve">
          <source>Database File Format</source>
          <target state="translated">데이터베이스 파일 형식</target>
        </trans-unit>
        <trans-unit id="ff50d56bfc81a7b956e4d1921d6d66d7a383a42b" translate="yes" xml:space="preserve">
          <source>Database Header Format</source>
          <target state="translated">데이터베이스 헤더 형식</target>
        </trans-unit>
        <trans-unit id="a3535d6748b55df8651025dc19ca0f9492aecee6" translate="yes" xml:space="preserve">
          <source>Database Object Name Resolution</source>
          <target state="translated">데이터베이스 객체 이름 확인</target>
        </trans-unit>
        <trans-unit id="bd8632f168d3516aef62fc843146b450c3c26a99" translate="yes" xml:space="preserve">
          <source>Database Page Size</source>
          <target state="translated">데이터베이스 페이지 크기</target>
        </trans-unit>
        <trans-unit id="4f02b6e9702df3600e6e312d593f7caa8819e1dd" translate="yes" xml:space="preserve">
          <source>Database Snapshot</source>
          <target state="translated">데이터베이스 스냅 샷</target>
        </trans-unit>
        <trans-unit id="bd1d5e56dd1e83bbe0ee14778f6008e4f92501fb" translate="yes" xml:space="preserve">
          <source>Database Speed Comparison</source>
          <target state="translated">데이터베이스 속도 비교</target>
        </trans-unit>
        <trans-unit id="a8dad839985eddb5586b8b561fd417de9bc6e759" translate="yes" xml:space="preserve">
          <source>Database URI</source>
          <target state="translated">데이터베이스 URI</target>
        </trans-unit>
        <trans-unit id="2d4c00611e1b6734ce538563059febb504705359" translate="yes" xml:space="preserve">
          <source>Database as object</source>
          <target state="translated">객체로서의 데이터베이스</target>
        </trans-unit>
        <trans-unit id="83a5cb19e95dc1d8b5d7e1441d8c579a45d5724b" translate="yes" xml:space="preserve">
          <source>Database cache can be optionally shared between connections in the same thread</source>
          <target state="translated">동일한 캐시의 연결간에 데이터베이스 캐시를 선택적으로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7de38dba43f0a278e3056a00a39519bfc9b665e" translate="yes" xml:space="preserve">
          <source>Database connections can now be used by multiple threads, not just the thread in which they were created.</source>
          <target state="translated">데이터베이스 연결은 이제 작성된 스레드뿐만 아니라 여러 스레드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212efa9f11c5959aadd0fce19cdf94993470615e" translate="yes" xml:space="preserve">
          <source>Database corruption caused by inconsistent use of 8+3 filenames</source>
          <target state="translated">8 + 3 파일 이름의 일관성없는 사용으로 인한 데이터베이스 손상</target>
        </trans-unit>
        <trans-unit id="053ad514468635665438176cd86a58d603813544" translate="yes" xml:space="preserve">
          <source>Database filename aliasing</source>
          <target state="translated">데이터베이스 파일 이름 별칭</target>
        </trans-unit>
        <trans-unit id="3b7f204e04933e97d6ac68630583c1313b9cb271" translate="yes" xml:space="preserve">
          <source>Database files can now grow to be up to 2^41 bytes. The old limit was 2^31 bytes.</source>
          <target state="translated">데이터베이스 파일은 이제 최대 2 ^ 41 바이트로 증가 할 수 있습니다. 이전 제한은 2 ^ 31 바이트였습니다.</target>
        </trans-unit>
        <trans-unit id="73a52851158627ec8f4a087842d9a7bc471fcd2f" translate="yes" xml:space="preserve">
          <source>Database files that contain partial indices are not readable or writable by versions of SQLite prior to 3.8.0. However, a database file created by SQLite 3.8.0 is still readable and writable by prior versions as long as its schema contains no partial indexes. A database that is unreadable by legacy versions of SQLite can be made readable simply by running &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; on the partial indexes.</source>
          <target state="translated">부분 인덱스가 포함 된 데이터베이스 파일은 3.8.0 이전의 SQLite 버전에서 읽거나 쓸 수 없습니다. 그러나 스키마에 부분 인덱스가없는 한 SQLite 3.8.0으로 작성된 데이터베이스 파일은 여전히 ​​이전 버전에서 읽고 쓸 수 있습니다. 레거시 버전의 SQLite에서 읽을 수없는 데이터베이스 는 부분 인덱스 에서 &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; 를 실행하여 간단히 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78486fa6ae30389540b15aab7739d7ecbc3140a" translate="yes" xml:space="preserve">
          <source>Database header</source>
          <target state="translated">데이터베이스 헤더</target>
        </trans-unit>
        <trans-unit id="d8a9d9190c53a37330666f4da1d52eb4d5397265" translate="yes" xml:space="preserve">
          <source>Database locks obtained by a connection in EXCLUSIVE mode may be released either by closing the database connection, or by setting the locking-mode back to NORMAL using this pragma and then accessing the database file (for read or write). Simply setting the locking-mode to NORMAL is not enough - locks are not released until the next time the database file is accessed.</source>
          <target state="translated">EXCLUSIVE 모드에서 연결하여 얻은 데이터베이스 잠금은 데이터베이스 연결을 닫거나이 pragma를 사용하여 잠금 모드를 다시 NORMAL로 설정 한 다음 데이터베이스 파일에 액세스하여 (읽기 또는 쓰기) 해제 할 수 있습니다. 잠금 모드를 NORMAL로 설정하는 것만으로는 충분하지 않습니다. 다음에 데이터베이스 파일에 액세스 할 때까지 잠금이 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9118c7b06bcc534b6f4c486616838692892faa73" translate="yes" xml:space="preserve">
          <source>Database page size. Example: 1024</source>
          <target state="translated">데이터베이스 페이지 크기 예 : 1024</target>
        </trans-unit>
        <trans-unit id="19e5379d75e917575fd8db9bff227b50947f62a7" translate="yes" xml:space="preserve">
          <source>Database read and write operations, and the way in which they interact with and use the</source>
          <target state="translated">데이터베이스 읽기 및 쓰기 작업과 작업 방식 및 작업 방식</target>
        </trans-unit>
        <trans-unit id="c8a8e97f4d032178ae62a7d1cf0df7f938947c9e" translate="yes" xml:space="preserve">
          <source>Database zDb does not exist,</source>
          <target state="translated">데이터베이스 zDb가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="684ece0a836446078b844add11528674b80daff5" translate="yes" xml:space="preserve">
          <source>Databases are opened using &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; when the --append flag is used on the command line or with the .open command.</source>
          <target state="translated">명령 행에서 --append 플래그를 사용하거나 .open 명령을 사용하면 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS를&lt;/a&gt; 사용하여 데이터베이스가 열립니다 .</target>
        </trans-unit>
        <trans-unit id="537610cacac4e984aff9fc9a16523e33b6616036" translate="yes" xml:space="preserve">
          <source>Databases created by the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command always use the same encoding as the main database. An attempt to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; a database with a different text encoding from the &quot;main&quot; database will fail.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령으로 작성된 데이터베이스는 항상 기본 데이터베이스와 동일한 인코딩을 사용합니다. 시도가하는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 실패합니다 &quot;기본&quot;데이터베이스에서 다른 텍스트 인코딩을 사용하여 데이터베이스를.</target>
        </trans-unit>
        <trans-unit id="3c4ce966e1af83816196cb8a675f0d67e707135b" translate="yes" xml:space="preserve">
          <source>Databases generated with this option enabled are not readable by SQLite version 3.1.6 (2005-03-17) and earlier. Also, databases generated with this option enabled are prone to triggering the &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; bug in the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. For those reasons, this optimization is disabled by default. However, this optimization may be enabled by default in a future release of SQLite.</source>
          <target state="translated">이 옵션을 사용하여 생성 된 데이터베이스는 SQLite 버전 3.1.6 (2005-03-17) 및 이전 버전에서 읽을 수 없습니다. 또한이 옵션을 사용하여 생성 된 데이터베이스 는 &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스 에서 &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; 버그 를 트리거하는 경향이 있습니다. 이러한 이유로이 최적화는 기본적으로 비활성화되어 있습니다. 그러나이 최적화는 향후 SQLite 릴리스에서 기본적으로 사용 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b3b2437f86ea4a0a8830ee6f8676cb1c3fc7da2" translate="yes" xml:space="preserve">
          <source>Datatype</source>
          <target state="translated">Datatype</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="baca0ff89b200ca165a0e54ccac355e7a923a643" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 2</source>
          <target state="translated">SQLite 버전 2의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1148668ae941abc0a854dc721e03d190e3485da6" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1c55ea91377b3b902abf3a2f501f4ea2f40cdee4" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite version 2</source>
          <target state="translated">SQLite 버전 2의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="233589836b520dde667809090f43b167594ea046" translate="yes" xml:space="preserve">
          <source>Date And Time Functions</source>
          <target state="translated">날짜 및 시간 함수</target>
        </trans-unit>
        <trans-unit id="6e2d2613130a40dc5bf62f65d270a32aa2b8b643" translate="yes" xml:space="preserve">
          <source>Date and time datatype</source>
          <target state="translated">날짜 및 시간 데이터 유형</target>
        </trans-unit>
        <trans-unit id="75a33d1bae263935cd17a2f9f5d07d057859dce8" translate="yes" xml:space="preserve">
          <source>Dbhash can be used to compare two databases to confirm that they are equivalent, even though their representation on disk is quite different. Dbhash might also be used to verify the content of a remote database without having to transmit the entire content of the remote database over a slow link.</source>
          <target state="translated">Dbhash를 사용하면 두 데이터베이스를 비교하여 디스크에서의 표현이 상당히 다르더라도 동등한 지 확인합니다. Dbhash는 느린 링크를 통해 원격 데이터베이스의 전체 내용을 전송하지 않고도 원격 데이터베이스의 내용을 확인하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bbc93e532fc52d7a861418ae6b728933b34062d" translate="yes" xml:space="preserve">
          <source>Dbhash ignores extraneous formatting details and hashes only the database schema and content. Hence the hash is constant even if the database file is modified by:</source>
          <target state="translated">Dbhash는 불필요한 형식화 세부 사항을 무시하고 데이터베이스 스키마 및 컨텐츠 만 해시합니다. 따라서 데이터베이스 파일이 다음에 의해 수정 되더라도 해시는 일정합니다.</target>
        </trans-unit>
        <trans-unit id="fb601abda7bdb73c50bfb1396b0751c831eb5fce" translate="yes" xml:space="preserve">
          <source>Dbhash is a command-line utility. To run it, type &quot;dbhash&quot; on a command-line prompt followed by the names of one or more SQLite database files that are to be hashed. The database hashes will be displayed on standard output. For example:</source>
          <target state="translated">Dbhash는 명령 줄 유틸리티입니다. 실행하려면 명령 줄 프롬프트에서 &quot;dbhash&quot;를 입력하고 해시 할 하나 이상의 SQLite 데이터베이스 파일 이름을 입력하십시오. 데이터베이스 해시는 표준 출력에 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e18681716fd7987f00ad554ff7f96da73e19fc13" translate="yes" xml:space="preserve">
          <source>Dbhash supports command-line options that can restrict the tables of the database file that are hashed, or restrict the hash to only content or only the schema. Run &quot;dbhash --help&quot; for further information.</source>
          <target state="translated">Dbhash는 해시 된 데이터베이스 파일의 테이블을 제한하거나 해시를 컨텐츠 또는 스키마로만 제한 할 수있는 명령 행 옵션을 지원합니다. 자세한 내용은 &quot;dbhash --help&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4a3882260abac88b66d6979bfd1282ccb93420d4" translate="yes" xml:space="preserve">
          <source>Deactivate the &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; keyword on subqueries on the right-hand side of the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 오른쪽에있는 서브 쿼리에서 &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; 키워드를 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f6794b197abfdc80b581fdd1340dcd8182be7db" translate="yes" xml:space="preserve">
          <source>Debugging Hints</source>
          <target state="translated">디버깅 힌트</target>
        </trans-unit>
        <trans-unit id="6558db0cb9f4028912366a41e3c7533d49d4b391" translate="yes" xml:space="preserve">
          <source>Debugging memory allocator</source>
          <target state="translated">메모리 할당 자 디버깅</target>
        </trans-unit>
        <trans-unit id="7c281fc0eea49fa90d5204752efe02a46e78181a" translate="yes" xml:space="preserve">
          <source>Debugging mode. Do not actually perform any optimizations but instead return one line of text for each optimization that would have been done. Off by default.</source>
          <target state="translated">디버깅 모드. 실제로 최적화를 수행하지 말고 각 최적화에 대해 한 줄의 텍스트를 반환하십시오. 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c3a2d0cc24a4535ef91791064ffe989cbd382a" translate="yes" xml:space="preserve">
          <source>Decimal</source>
          <target state="translated">Decimal</target>
        </trans-unit>
        <trans-unit id="4884a58f8854eaff9e14e4541fa2bfc15e139d8a" translate="yes" xml:space="preserve">
          <source>Declare The Schema Of A Virtual Table</source>
          <target state="translated">가상 테이블의 스키마 선언</target>
        </trans-unit>
        <trans-unit id="c657d4e9ebee4c198c968bcba7aff6eeab9209c1" translate="yes" xml:space="preserve">
          <source>Declared Datatype Of A Query Result</source>
          <target state="translated">쿼리 결과의 선언 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="52f7f00d0ba2d4f4aaef6d6440932d8183870fe3" translate="yes" xml:space="preserve">
          <source>Decompose the &quot;settings.xml&quot; file into an SQL table that is more easily viewed and edited by separate applications.</source>
          <target state="translated">&quot;settings.xml&quot;파일을 별도의 애플리케이션에서보다 쉽게보고 편집 할 수있는 SQL 테이블로 분해하십시오.</target>
        </trans-unit>
        <trans-unit id="e090288f7922e2e7bbb158d2a90c3c98da108024" translate="yes" xml:space="preserve">
          <source>DecrJumpZero</source>
          <target state="translated">DecrJumpZero</target>
        </trans-unit>
        <trans-unit id="7078198f7cae420890a1abe183a812a6a35f8ed6" translate="yes" xml:space="preserve">
          <source>Default Value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="349c243fc47f07030e17a3729d694bcfe2dadb05" translate="yes" xml:space="preserve">
          <source>Default builds of SQLite contain appropriate &lt;a href=&quot;vfs&quot;&gt;VFS objects&lt;/a&gt; for talking to underlying operating system, and those VFS objects will contain operating system calls such as open(), read(), write(), fsync(), and so forth. All of these interfaces are readily available on most platforms, and custom VFSes can be designed to run SQLite on even the most austere embedded devices.</source>
          <target state="translated">SQLite의 기본 빌드에는 기본 운영 체제와 통신하기위한 적절한 &lt;a href=&quot;vfs&quot;&gt;VFS 개체&lt;/a&gt; 가 포함되며 이러한 VFS 개체에는 open (), read (), write (), fsync () 등과 같은 운영 체제 호출이 포함됩니다. 이러한 모든 인터페이스는 대부분의 플랫폼에서 쉽게 사용할 수 있으며, 가장 엄격한 임베디드 장치에서도 SQLite를 실행하도록 사용자 지정 VFS를 설계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038803a5a725763be7d5665007510dd34ef1f8ce" translate="yes" xml:space="preserve">
          <source>Default memory allocator</source>
          <target state="translated">기본 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="e25af978372277845b3d313829fc8e2e019d17ec" translate="yes" xml:space="preserve">
          <source>Default page cache size.</source>
          <target state="translated">기본 페이지 캐시 크기</target>
        </trans-unit>
        <trans-unit id="bdffe654f8554300a98d2acefcbbf1d894339b2b" translate="yes" xml:space="preserve">
          <source>Default value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="f9d91891053643138161539927c04de3021744dd" translate="yes" xml:space="preserve">
          <source>Defense Against Dark Arts</source>
          <target state="translated">어두운 예술에 대한 방어</target>
        </trans-unit>
        <trans-unit id="c78392ffee2ec805b3bc60c680fa04c8a3bfdd3e" translate="yes" xml:space="preserve">
          <source>DeferredSeek</source>
          <target state="translated">DeferredSeek</target>
        </trans-unit>
        <trans-unit id="2a32a694b454b48f0c6093b3ea95bcc7ae1e63ab" translate="yes" xml:space="preserve">
          <source>Define New Collating Sequences</source>
          <target state="translated">새로운 조합 순서 정의</target>
        </trans-unit>
        <trans-unit id="7a8df33d7a4ee8c98b8a16229139f0094608d9e9" translate="yes" xml:space="preserve">
          <source>Define a static (but not constant) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure that contains pointers to the xOpen method and the other methods and which contains the appropriate values for iVersion, szOsFile, mxPathname, zName, and pAppData.</source>
          <target state="translated">xOpen 메소드 및 기타 메소드에 대한 포인터를 포함하고 iVersion, szOsFile, mxPathname, zName 및 pAppData에 대한 적절한 값을 포함 하는 정적 (정수는 아님) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 구조를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d00d0274d811a9571e6a7d0d105251d14e6c534a" translate="yes" xml:space="preserve">
          <source>Define an appropriate subclass of the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 적절한 서브 클래스를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eb6b16d370a1014df05c39f19a4497ee0d61573" translate="yes" xml:space="preserve">
          <source>Define the &quot;payload&quot; of a cell to be the arbitrary length section of the cell. For an index b-tree, the key is always arbitrary in length and hence the payload is the key. There are no arbitrary length elements in the cells of interior table b-tree pages and so those cells have no payload. Table b-tree leaf pages contain arbitrary length content and so for cells on those pages the payload is the content.</source>
          <target state="translated">셀의 &quot;페이로드&quot;를 셀의 임의의 길이 섹션으로 정의하십시오. 인덱스 b- 트리의 경우 키의 길이는 항상 임의적이므로 페이로드가 키입니다. 내부 테이블 b- 트리 페이지의 셀에는 임의의 길이 요소가 없으므로 해당 셀에는 페이로드가 없습니다. 표 b- 트리 리프 페이지에는 임의 길이의 컨텐츠가 포함되므로 해당 페이지의 셀에 대한 페이로드는 컨텐츠입니다.</target>
        </trans-unit>
        <trans-unit id="09695710d6ec87af0ba3720c928922e55056227a" translate="yes" xml:space="preserve">
          <source>Define the depth of a leaf b-tree to be 1 and the depth of any interior b-tree to be one more than the maximum depth of any of its children. In a well-formed database, all children of an interior b-tree have the same depth.</source>
          <target state="translated">리프 b- 트리의 깊이를 1로 정의하고 내부 b- 트리의 깊이를 자식의 최대 깊이보다 1 이상 높게 정의하십시오. 올바르게 구성된 데이터베이스에서 내부 b- 트리의 모든 자식의 깊이는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e75225c3111252da2f1b0958f137acf031ed75f2" translate="yes" xml:space="preserve">
          <source>Defining this option causes the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; command to be omitted from the library. Attempting to execute an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; statement will cause a parse error.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령이 라이브러리에서 생략됩니다. &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 문 을 실행하려고 하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95e30519291de496ce9227bf803508402c5b0e39" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying and modifying the database schema version and user version from the build. Specifically, the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMAs are omitted.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 데이터베이스 스키마 버전 및 사용자 버전을 쿼리하고 수정하기위한 실습이 생략됩니다. 특히 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMA는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="438bf5a3e905d9e27a03501948a3300c579faa96" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying the database schema from the build.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 데이터베이스 스키마를 쿼리하기위한 실용성이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="fb53b1a942ec49b6ce242dc0903a83562676a9de" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas related to the pager subsystem from the build.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 호출기 서브 시스템과 관련된 pragma가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2296b74c87da37e10da27f66b21bb73a4427d7" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for TRIGGER objects. Neither the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; or &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error. This option also disables enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;, since the code that implements triggers and which is omitted by this option is also used to implement &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 정의하면 TRIGGER 객체에 대한 지원이 생략됩니다. 어느 쪽도 아니는 &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER CREATE 없습니다&lt;/a&gt; 또는 &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; 명령이 경우에 사용할 수 있으며, 구문 분석 오류가 발생합니다 중 하나를 실행하려고 시도. 트리거를 구현하고이 옵션에서 생략 된 코드가 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업&lt;/a&gt; 을 구현하는 데 에도 사용되므로이 옵션은 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건의&lt;/a&gt; 적용을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="15c4cfc354a842ec38f01dc56ced3bf25c4ad5b6" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for VIEW objects. Neither the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; nor the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error.</source>
          <target state="translated">이 옵션을 정의하면 VIEW 객체에 대한 지원이 생략됩니다. 이 경우 &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; 명령을 사용할 수 없으며 둘 중 하나를 실행하려고하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8d0bb74e48c16e4de7827a8ffc7d0dc3f87633f" translate="yes" xml:space="preserve">
          <source>Defining this option omits the authorization callback feature from the library. The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">이 옵션을 정의하면 라이브러리에서 권한 부여 콜백 기능이 생략됩니다. &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; API 함수는 라이브러리에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83f644802e49a1cbe2ffeee1f4e6042a39cd0de9" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">정의 : &lt;b&gt;결과 테이블&lt;/b&gt; 은 &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 인터페이스로 작성된 메모리 데이터 구조입니다 . 결과 테이블은 하나 이상의 쿼리의 전체 쿼리 결과를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e259d1f20b6fd6c9ce46ea6e1dc31fde6f204fb8" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">정의 : &lt;b&gt;결과 테이블&lt;/b&gt; 은 &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 인터페이스로 작성된 메모리 데이터 구조입니다 . 결과 테이블은 하나 이상의 쿼리의 전체 쿼리 결과를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="6ae0a530b1b7677b78998487aadb9d2cadf7f88f" translate="yes" xml:space="preserve">
          <source>Delete A Changegroup Object</source>
          <target state="translated">변경 그룹 객체 삭제</target>
        </trans-unit>
        <trans-unit id="2b620c0b18464aba1294c125c40ed5d238146244" translate="yes" xml:space="preserve">
          <source>Delete A Session Object</source>
          <target state="translated">세션 객체 삭제</target>
        </trans-unit>
        <trans-unit id="12eda7c48435244e864fe35cc6d11a7bc5eebd9b" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 서 객체 삭제</target>
        </trans-unit>
        <trans-unit id="6ccb779f78fa4c2f40b79e1431ac32a6c85e1c13" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="12991bc9bb4a12d326aa6753050041d7a4fabc24" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()를&lt;/a&gt; 사용하여 이전에 할당 된 세션 객체를 삭제하십시오 . 세션 객체가 삭제되면 다른 세션 모듈 함수와 함께 pSession을 사용한 시도 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d762d1040e85482796c9fd4d534519cef24d74ed" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()를&lt;/a&gt; 사용하여 이전에 할당 된 세션 객체를 삭제하십시오 . 세션 객체가 삭제되면 다른 세션 모듈 함수와 함께 pSession을 사용한 시도 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02512a6317bed133605bfc468e6ef4822f972b23" translate="yes" xml:space="preserve">
          <source>Delete all contents from the ephemeral table or sorter that is open on cursor P1.</source>
          <target state="translated">커서 P1에 열려있는 임시 테이블 또는 분류기에서 모든 컨텐츠를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="aedb82abe0e510f8fa2d29632ac81d5268819e7f" translate="yes" xml:space="preserve">
          <source>Delete all contents of the database table or index whose root page in the database file is given by P1. But, unlike &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;, do not remove the table or index from the database file.</source>
          <target state="translated">데이터베이스 파일의 루트 페이지가 P1에 의해 제공되는 데이터베이스 테이블 또는 인덱스의 모든 내용을 삭제하십시오. 그러나 &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; 와 달리 데이터베이스 파일에서 테이블 또는 인덱스를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f095a0ada2906d2012dfcefd96beaf7902bce51" translate="yes" xml:space="preserve">
          <source>Delete all individual journal files.</source>
          <target state="translated">모든 개별 저널 파일을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1b9b7fadc6e867c3913361047ae2f1e082e237" translate="yes" xml:space="preserve">
          <source>Delete an entire database table or index whose root page in the database file is given by P1.</source>
          <target state="translated">데이터베이스 파일의 루트 페이지가 P1에 의해 제공되는 전체 데이터베이스 테이블 또는 인덱스를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc9013dca7ae3cd28443b3643084c1962bbbebb" translate="yes" xml:space="preserve">
          <source>Delete the changeset rebaser object and all associated resources. There should be one call to this function for each successful invocation of sqlite3rebaser_create().</source>
          <target state="translated">변경 세트 리바 저 오브젝트 및 모든 관련 자원을 삭제하십시오. sqlite3rebaser_create ()를 성공적으로 호출 할 때마다이 함수를 한 번 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="60bf70613708367f728d96356276360d98741581" translate="yes" xml:space="preserve">
          <source>Delete the journal file (or truncate the journal to zero bytes in length if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; is set, or zero the journal header if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=PERSIST&lt;/a&gt; is set).</source>
          <target state="translated">저널 파일을 삭제하십시오 (또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt; 가 설정된 경우 저널을 0 바이트 길이로 자르 거나 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = PERSIST&lt;/a&gt; 가 설정된 경우 저널 헤더 를 0으로 자르십시오 ).</target>
        </trans-unit>
        <trans-unit id="424c686346d72ee424e3afead9478d41b73e0e95" translate="yes" xml:space="preserve">
          <source>Delete the journal file. (Or if the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is TRUNCATE or PERSIST, truncate the journal file or zero the header of the journal file, respectively.) This is the instant when the changes are committed. Prior to deleting the journal file, if a power failure or crash occurs, the next process to open the database will see that it has a hot journal and will roll the changes back. After the journal is deleted, there will no longer be a hot journal and the changes will persist.</source>
          <target state="translated">저널 파일을 삭제하십시오. (또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; 가 TRUNCATE 또는 PERSIST 인 경우 저널 파일을 잘라내거나 저널 파일의 헤더를 각각 0으로 변경하십시오.) 변경 사항이 커밋 된 순간입니다. 저널 파일을 삭제하기 전에 정전 또는 충돌이 발생하면 데이터베이스를 여는 다음 프로세스에서 데이터베이스에 핫 저널이 있음을 확인하고 변경 사항을 롤백합니다. 저널이 삭제 된 후에는 더 이상 핫 저널이 없으며 변경 사항이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="aae017b3d4b04098148419004c202430e143c042" translate="yes" xml:space="preserve">
          <source>Delete the master journal file if it is safe to do so. This step is optional. It is here only to prevent stale master journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">마스터 저널 파일이 안전한 경우 삭제하십시오. 이 단계는 선택 사항입니다. 오래된 마스터 저널이 디스크 드라이브를 어지럽히는 것을 방지하기 위해서입니다. 자세한 내용은 아래 토론을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e10f41bbb6b9a5c4d90c81334bd806252b81f5b3" translate="yes" xml:space="preserve">
          <source>Delete the master journal file. This is the instant when the changes are committed. Prior to deleting the master journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the master journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">마스터 저널 파일을 삭제하십시오. 변경 사항이 커밋 된 순간입니다. 마스터 저널 파일을 삭제하기 전에 정전 또는 충돌이 발생하면 개별 파일 저널은 핫으로 간주되고 다음 파일을 읽으려고 시도하는 프로세스에 의해 롤백됩니다. 마스터 저널이 삭제 된 후에는 파일 저널이 더 이상 핫으로 간주되지 않으며 변경 사항이 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="29e75bc2e3dd1128b5b5e72142f38e94e6c04b31" translate="yes" xml:space="preserve">
          <source>Delete the record at which the P1 cursor is currently pointing.</source>
          <target state="translated">P1 커서가 현재 가리키는 레코드를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="91c899cb9487830103f86062414b65279777c00c" translate="yes" xml:space="preserve">
          <source>Delete triggers fire when rows are removed due to a &lt;a href=&quot;lang_conflict&quot;&gt;REPLACE conflict resolution&lt;/a&gt;. This feature is only enabled when recursive triggers are enabled.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;REPLACE 충돌 해결&lt;/a&gt; 로 인해 행이 제거되면 삭제 트리거가 실행됩니다 . 이 기능은 재귀 트리거가 활성화 된 경우에만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f97f11b2a9d7f4d5cfcb9f5b6bc157b876524629" translate="yes" xml:space="preserve">
          <source>Deleting a file is an expensive operation on many systems. So as an optimization, SQLite can be configured to avoid the delete operation of &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;. Instead of deleting the journal file in order to commit a transaction, the file is either truncated to zero bytes in length or its header is overwritten with zeros. Truncating the file to zero length saves having to make modifications to the directory containing the file since the file is not removed from the directory. Overwriting the header has the additional savings of not having to update the length of the file (in the &quot;inode&quot; on many systems) and not having to deal with newly freed disk sectors. Furthermore, at the next transaction the journal will be created by overwriting existing content rather than appending new content onto the end of a file, and overwriting is often much faster than appending.</source>
          <target state="translated">파일 삭제는 많은 시스템에서 비용이 많이 드는 작업입니다. 따라서 최적화로서 &lt;a href=&quot;#section_3_11&quot;&gt;섹션 3.11&lt;/a&gt; 의 삭제 조작을 피하도록 SQLite를 구성 할 수 있습니다.. 트랜잭션을 커밋하기 위해 저널 파일을 삭제하는 대신 파일 길이가 0 바이트로 잘 리거나 헤더가 0으로 덮어 쓰기됩니다. 파일을 길이가 0으로 자르면 파일이 디렉토리에서 제거되지 않기 때문에 파일이 포함 된 디렉토리를 수정해야합니다. 헤더를 덮어 쓰면 파일 길이를 업데이트 할 필요가없고 (많은 시스템의 &quot;inode&quot;에서) 새로 해제 된 디스크 섹터를 처리하지 않아도되므로 추가 절약이 가능합니다. 또한 다음 트랜잭션에서 파일 끝에 새 내용을 추가하지 않고 기존 내용을 덮어 써서 저널을 만들며, 덮어 쓰기가 추가하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="2696b8d0813903709611732c9e8977b50fd62e40" translate="yes" xml:space="preserve">
          <source>Deleting a file is not really an atomic operation, but it appears to be from the point of view of a user process. A process is always able to ask the operating system &quot;does this file exist?&quot; and the process will get back a yes or no answer. After a power failure that occurs during a transaction commit, SQLite will ask the operating system whether or not the rollback journal file exists. If the answer is &quot;yes&quot; then the transaction is incomplete and is rolled back. If the answer is &quot;no&quot; then it means the transaction did commit.</source>
          <target state="translated">파일을 삭제하는 것은 실제로 원자 작업이 아니지만 사용자 프로세스의 관점에서 볼 수 있습니다. 프로세스는 항상 운영 체제에 &quot;이 파일이 있습니까?&quot;를 요청할 수 있습니다. 프로세스가 예 또는 아니오로 돌아옵니다. 트랜잭션 커밋 중에 발생하는 정전 후 SQLite는 롤백 저널 파일이 존재하는지 여부를 운영 체제에 묻습니다. 대답이 &quot;예&quot;이면 트랜잭션이 불완전하며 롤백됩니다. 대답이 &quot;아니오&quot;이면 트랜잭션이 커밋되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c09fda80ecfdf9e281d56a4afdd3670077682c0b" translate="yes" xml:space="preserve">
          <source>Deleting a hot journal</source>
          <target state="translated">인기 저널 삭제</target>
        </trans-unit>
        <trans-unit id="9d50c7931911f099d06f9c5c9dcef20c05a1a010" translate="yes" xml:space="preserve">
          <source>Deliberately changing out of WAL mode changes the database file format version numbers back to 1 so that older versions of SQLite can once again access the database file.</source>
          <target state="translated">의도적으로 WAL 모드를 변경하면 이전 버전의 SQLite가 데이터베이스 파일에 다시 액세스 할 수 있도록 데이터베이스 파일 형식 버전 번호가 1로 다시 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="94c24d036a23e21672451696acb1226b9371946b" translate="yes" xml:space="preserve">
          <source>Deny oneself in order to follow Christ.</source>
          <target state="translated">그리스도를 따르기 위해 자신을 부인하십시오.</target>
        </trans-unit>
        <trans-unit id="4b72ef41c3b1c98245c65c2469b7a10fdf627d58" translate="yes" xml:space="preserve">
          <source>Depending how badly your database is corrupted, you may be able to recover some of the data by using the CLI to dump the schema and contents to a file and then recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally not possible to put him back together again.</source>
          <target state="translated">데이터베이스가 얼마나 손상되었는지에 따라 CLI를 사용하여 스키마와 내용을 파일로 덤프 한 후 다시 작성하여 일부 데이터를 복구 할 수 있습니다. 불행하게도 일단 험피 덤프가 벽에서 떨어지면 일반적으로 그를 다시 합치는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="5466f1e1c1f4f0fffe016c26643a67d2ad503e26" translate="yes" xml:space="preserve">
          <source>Depending on the query, SQLite might need to materialize the &quot;(SELECT b FROM ex2)&quot; subquery into a temporary table, then perform the join between ex1 and the temporary table. The query optimizer tries to avoid this by &quot;flattening&quot; the query. In the previous example the query can be flattened, and SQLite will automatically transform the query into</source>
          <target state="translated">쿼리에 따라 SQLite는 &quot;(SELECT b FROM ex2)&quot;하위 쿼리를 임시 테이블로 구체화 한 다음 ex1과 임시 테이블간에 조인을 수행해야 할 수 있습니다. 쿼리 최적화 프로그램은 쿼리를 &quot;평 평화&quot;하여이를 피하려고합니다. 앞의 예에서 쿼리를 병합 할 수 있으며 SQLite는 자동으로 쿼리를</target>
        </trans-unit>
        <trans-unit id="886d67dc402c58b18f059201de3cb182bdcca2d0" translate="yes" xml:space="preserve">
          <source>Depending on the type of conflict, a sessions application has a variety of configurable options for dealing with conflicts, ranging from omitting the conflicting change, aborting the entire changeset application or applying the change despite the conflict. For details, refer to the documentation for the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">충돌 유형에 따라 세션 응용 프로그램에는 충돌 변경을 생략하거나 전체 변경 집합 응용 프로그램을 중단하거나 충돌에도 불구하고 변경 사항을 적용하는 등 충돌을 처리하기위한 다양한 구성 가능한 옵션이 있습니다. 자세한 내용은 &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; API 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99099b8d7e1bb8542438e0ec64f4aa03573d7d34" translate="yes" xml:space="preserve">
          <source>Depending on which parameter is being interrogated, one of the VALUE or HIWTR mark measurements might be undefined. For example, only the high-water mark is meaningful for &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;, and only the current value is meaningful for &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;. For rows where one or the other of VALUE or HIWTR is not meaningful, that value is returned as NULL. the interfaces, with the initial</source>
          <target state="translated">어떤 매개 변수를 조사 하느냐에 따라 VALUE 또는 HIWTR 마크 측정 중 하나가 정의되지 않을 수 있습니다. 예를 들어, 단지 하이 워터 마크에 대한 의미 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt; , 단지 현재 값에 대한 의미 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; . VALUE 또는 HIWTR 중 하나가 의미가없는 행의 경우 해당 값은 NULL로 리턴됩니다. 초기와 인터페이스</target>
        </trans-unit>
        <trans-unit id="3a49085fe4eb15cab436b357201995ee9bf9e4bd" translate="yes" xml:space="preserve">
          <source>Depending on your hardware and operating system, you should see that reads from the test1.db database file are about 35% faster than reads from individual files in the test1.dir or test1.tree folders. Results can vary significantly from one run to the next due to caching, so it is advisable to run tests multiple times and take an average or a worst case or a best case, depending on your requirements.</source>
          <target state="translated">하드웨어 및 운영 체제에 따라 test1.db 데이터베이스 파일의 읽기는 test1.dir 또는 test1.tree 폴더의 개별 파일에서 읽는 것보다 약 35 % 빠릅니다. 캐싱으로 인해 결과가 실행마다 크게 다를 수 있으므로 테스트를 여러 번 실행하고 요구 사항에 따라 평균 또는 최악의 경우 또는 최상의 경우를 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="42a66abe1669ce3ffad7695dbe407c22ed591eb2" translate="yes" xml:space="preserve">
          <source>Deprecated Functions</source>
          <target state="translated">더 이상 사용되지 않는 함수</target>
        </trans-unit>
        <trans-unit id="bfc32553e9a3941dedadb9fb40b33e7008f653d9" translate="yes" xml:space="preserve">
          <source>Deprecated Soft Heap Limit Interface</source>
          <target state="translated">더 이상 사용되지 않는 소프트 힙 제한 인터페이스</target>
        </trans-unit>
        <trans-unit id="3a682fd508565521834d60be19ff2f936a43d34b" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces have been superceded by better methods of accomplishing the same thing and should be avoided in new applications. Deprecated interfaces continue to be supported for the sake of backwards compatibility. At some point in the future, it is possible that deprecated interfaces may be removed.</source>
          <target state="translated">더 이상 사용되지 않는 인터페이스는 동일한 작업을 수행하는 더 나은 방법으로 대체되었으며 새로운 응용 프로그램에서는 피해야합니다. 이전 버전과의 호환성을 위해 더 이상 사용되지 않는 인터페이스가 계속 지원됩니다. 향후 언젠가는 더 이상 사용되지 않는 인터페이스가 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd86ca0936a352d07e01faf8385985c6bcfbe7d" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces should not be used in new code and might be removed in some future release.</source>
          <target state="translated">더 이상 사용되지 않는 인터페이스는 새 코드에서 사용해서는 안되며 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384385f4ecfb14efac5a6de95da0a3708e15bd88" translate="yes" xml:space="preserve">
          <source>Descending indices</source>
          <target state="translated">내림차순 지수</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="4d25e019c14ea4edb8919779e923685a3363cdef" translate="yes" xml:space="preserve">
          <source>Description Of File Format Change</source>
          <target state="translated">파일 형식 변경 설명</target>
        </trans-unit>
        <trans-unit id="cd8429891c87cd83470eecb59eba348d84f2f5d1" translate="yes" xml:space="preserve">
          <source>Deserialize a database</source>
          <target state="translated">데이터베이스 역 직렬화</target>
        </trans-unit>
        <trans-unit id="99d0530263d176ccac0fdc529fd7f2dedfa20826" translate="yes" xml:space="preserve">
          <source>Designing software is hard. It takes a lot of focus. A good version control system should provide the developer with assistance, not frustration. Git has gotten better in this regard over the past decade, but it still has a long way to go.</source>
          <target state="translated">소프트웨어 설계는 어렵습니다. 많은 초점이 필요합니다. 좋은 버전 관리 시스템은 개발자에게 좌절이 아닌 도움을 제공해야합니다. Git은 지난 10 년 동안 이와 관련하여 더 나아졌지 만 여전히 갈 길이 멀다.</target>
        </trans-unit>
        <trans-unit id="a83ebad2040aac26354ce69d33c75a8e23379288" translate="yes" xml:space="preserve">
          <source>Desire eternal life with all the passion of the spirit.</source>
          <target state="translated">영의 모든 열정으로 영생을 소망하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd8f751199e13822ef7d9714c88c6e47db10e8e" translate="yes" xml:space="preserve">
          <source>Despite the name, this function always returns a value between 0.0 and 1.0 equal to (</source>
          <target state="translated">이름에도 불구하고이 함수는 항상 0.0과 1.0 사이의 값을</target>
        </trans-unit>
        <trans-unit id="577ef7dc1516f4b3c43ddbe63327a8a039a0edec" translate="yes" xml:space="preserve">
          <source>Destroy</source>
          <target state="translated">Destroy</target>
        </trans-unit>
        <trans-unit id="839c441dcc29d361bfacf38afa416f18a1637928" translate="yes" xml:space="preserve">
          <source>Destroy A Prepared Statement Object</source>
          <target state="translated">준비된 명령문 오브젝트 삭제</target>
        </trans-unit>
        <trans-unit id="8a43abf112611732f3dfb583fa8f44e2049379d4" translate="yes" xml:space="preserve">
          <source>Destroy a snapshot</source>
          <target state="translated">스냅 샷 파괴</target>
        </trans-unit>
        <trans-unit id="7d83f3ed4b5d324ccef4af3b6f9a3539eb93e67c" translate="yes" xml:space="preserve">
          <source>Destroy the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="c75278c7e28535f5ea9e950ab84092bdea32a614" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 객체를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="64b1ed1f1b53763efdc1c78265116d5fa0da95e8" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 객체를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="5284d7d2a9c5b9dbf72aafe5558f4a26a439739f" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1afb291d062f0484331555f28baeeafd003c3dfa" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be5ef256fde14f27a6be2d2b33459ee64ab4a321" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bc54ba31c2c513271f833dc8e2d60c1be1b1091" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="689b80c76ccc07fa3d2942a087706f3eef81d330" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c105a9f0c702f6cd4ef79cd3b0f385965920de3c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed39236d0e8e7446d0cb599cd5b738b2811bcf10" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d822a3174515e8f21e47ce59b4339bb51f6db978" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f60221cb8d7f3a49adecb2493f31cebddcb5e00c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e83f5c6e38c161fc2b5c1d7abe156cb9aad8f5f3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41e4345992429802aea5872bac2716f7c77be8e3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6b6c509cccb52d51368c6e4ebb375738475d8f0" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="359201cc8ce5eb69bceb0fd81af7a37ed2f96a48" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e0b565701116b40edb353da662ba766f93f65b1" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; , &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="3ee5fd57c6234479272be39f53b7a756c8fad2c3" translate="yes" xml:space="preserve">
          <source>Details of the low-level B-tree format used in SQLite version 3.0 can be found in header comments to the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; source file and in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation.</source>
          <target state="translated">SQLite 버전 3.0에서 사용되는 하위 수준의 B- 트리 형식에 대한 자세한 내용은 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; 소스 파일 에 대한 헤더 주석 및 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057c54e32daecfe5f3f91aea6c17b8880637989a" translate="yes" xml:space="preserve">
          <source>Detect integer overflow in abs().</source>
          <target state="translated">abs ()에서 정수 오버플로를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="0cb93bae74fdeaac6fc236f4e82d733ebb774f3f" translate="yes" xml:space="preserve">
          <source>Determine If A Prepared Statement Has Been Reset</source>
          <target state="translated">준비된 명령문이 재설정되었는지 판별</target>
        </trans-unit>
        <trans-unit id="db966195ad1f618275836e22992513b99d0a007c" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Is Complete</source>
          <target state="translated">SQL 문이 완전한지 판별</target>
        </trans-unit>
        <trans-unit id="625d5f335e20e089846651b3578340604a6b4c2f" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Writes The Database</source>
          <target state="translated">SQL 문이 데이터베이스를 작성하는지 확인</target>
        </trans-unit>
        <trans-unit id="eb26a9bebe8d2e098f033d011256a86267629d8a" translate="yes" xml:space="preserve">
          <source>Determine If Virtual Table Column Access Is For UPDATE</source>
          <target state="translated">가상 테이블 열 액세스가 UPDATE인지 확인</target>
        </trans-unit>
        <trans-unit id="5ad12b059791066c3ea756f7418d5b987aa492a2" translate="yes" xml:space="preserve">
          <source>Determine The Collation For a Virtual Table Constraint</source>
          <target state="translated">가상 테이블 제약 조건에 대한 데이터 정렬 결정</target>
        </trans-unit>
        <trans-unit id="c8aa46b4240b68859dbf6ca40dcc17adbb0b5d9d" translate="yes" xml:space="preserve">
          <source>Determine The Number Of Foreign Key Constraint Violations</source>
          <target state="translated">외래 키 제약 조건 위반 수 결정</target>
        </trans-unit>
        <trans-unit id="3e28f586fecd10c20cfef343cf0e0a2554afa731" translate="yes" xml:space="preserve">
          <source>Determine The Virtual Table Conflict Policy</source>
          <target state="translated">가상 테이블 충돌 정책 결정</target>
        </trans-unit>
        <trans-unit id="378e53b0c9705af12aa3d20a3dfea2de180d3964" translate="yes" xml:space="preserve">
          <source>Determine if a database is read-only</source>
          <target state="translated">데이터베이스가 읽기 전용인지 확인</target>
        </trans-unit>
        <trans-unit id="ec9ead520b9e56d263fd7de0b9b24771183e3061" translate="yes" xml:space="preserve">
          <source>Deterministic SQL Functions</source>
          <target state="translated">결정적 SQL 함수</target>
        </trans-unit>
        <trans-unit id="96de162ae9388387b4d27ffd24dfdaec4b72faef" translate="yes" xml:space="preserve">
          <source>Developers report that SQLite is often faster than a client/server SQL database engine in this scenario. Database requests are serialized by the server, so concurrency is not an issue. Concurrency is also improved by &quot;database sharding&quot;: using separate database files for different subdomains. For example, the server might have a separate SQLite database for each user, so that the server can handle hundreds or thousands of simultaneous connections, but each SQLite database is only used by one connection.</source>
          <target state="translated">개발자들은이 시나리오에서 SQLite가 종종 클라이언트 / 서버 SQL 데이터베이스 엔진보다 빠르다고보고합니다. 데이터베이스 요청은 서버에 의해 직렬화되므로 동시성은 문제가되지 않습니다. &quot;데이터베이스 샤딩&quot;을 통해 동시성이 향상되었습니다. 하위 도메인마다 별도의 데이터베이스 파일을 사용합니다. 예를 들어, 서버는 각 사용자마다 별도의 SQLite 데이터베이스를 가질 수 있으므로 서버는 수백 또는 수천 개의 동시 연결을 처리 할 수 ​​있지만 각 SQLite 데이터베이스는 하나의 연결에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b17665b2663239e18f10a989ee4b32e6490c33f2" translate="yes" xml:space="preserve">
          <source>Developers sometimes experience trouble debugging the 185,000-line-long amalgamation source file because some debuggers are only able to handle source code line numbers less than 32,768. The amalgamation source code runs fine. One just cannot single-step through it in a debugger.</source>
          <target state="translated">일부 디버거는 32,768 미만의 소스 코드 라인 번호 만 처리 할 수 ​​있기 때문에 개발자는 때때로 185,000 줄 길이의 아말감 화 소스 파일을 디버깅하는 데 문제가 있습니다. 합병 소스 코드가 제대로 실행됩니다. 디버거에서 단일 단계를 통과 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="db23e94c152c3c70f28ce4fd2250cf8e7e90d0ef" translate="yes" xml:space="preserve">
          <source>Device Characteristics</source>
          <target state="translated">장치 특성</target>
        </trans-unit>
        <trans-unit id="10fe8e0881142639bc54f8ec9a79de4f49557439" translate="yes" xml:space="preserve">
          <source>Devote yourself frequently to prayer.</source>
          <target state="translated">기도에 자주 헌신하십시오.</target>
        </trans-unit>
        <trans-unit id="d2bfc098e435319899700359a7c7ade5b2cceea5" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;../vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xshadowname&quot;&gt;새도우 테이블에&lt;/a&gt; 직접 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3ea4196b155e79b0ed2d425b768b9f76a1de7e8d" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블에&lt;/a&gt; 직접 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d9d75aac27ba7c6d07be6644243da8087e5f97b8" translate="yes" xml:space="preserve">
          <source>Disable schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF를&lt;/a&gt; 사용하여 스키마 편집을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="d741b71f5f87bb5b09855b9b7b964ab4719c4656" translate="yes" xml:space="preserve">
          <source>Disable the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; while reparsing the schema.</source>
          <target state="translated">스키마를 재분석하는 동안 &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자 콜백&lt;/a&gt; 을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b94299f848122e7aa2027a43aba54a8bdf1eb66" translate="yes" xml:space="preserve">
          <source>Disable the use of posix_fallocate() on all (unix) systems unless the HAVE_POSIX_FALLOCATE compile-time option is used.</source>
          <target state="translated">HAVE_POSIX_FALLOCATE 컴파일 타임 옵션을 사용하지 않으면 모든 (유닉스) 시스템에서 posix_fallocate () 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="dc4409d907665c9eda9e8c714ab538568a93fe4c" translate="yes" xml:space="preserve">
          <source>Disable the use of the strchrnul() C-library routine unless it is specifically enabled using the -DHAVE_STRCHRNULL compile-time option.</source>
          <target state="translated">-DHAVE_STRCHRNULL 컴파일 타임 옵션을 사용하여 특별히 활성화되지 않은 경우 strchrnul () C 라이브러리 루틴 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="44313c14bb780bbf9fd9d83b8ed923886b89675b" translate="yes" xml:space="preserve">
          <source>Disabled optimization tests</source>
          <target state="translated">비활성화 된 최적화 테스트</target>
        </trans-unit>
        <trans-unit id="801e1c0ae6276f6c1470108fe61a442d30ca4372" translate="yes" xml:space="preserve">
          <source>Disabling mutexes at run-time is not as effective as disabling them at compile-time since SQLite still must do a test of a boolean variable to see if mutexes are enabled or disabled at each point where a mutex might be required. But there is still a performance advantage for disabling mutexes at run-time.</source>
          <target state="translated">SQLite는 여전히 뮤텍스가 필요한 각 지점에서 뮤텍스가 활성화 또는 비활성화되었는지 확인하기 위해 부울 변수를 테스트해야하기 때문에 런타임에 뮤텍스를 비활성화하는 것은 컴파일 타임에 뮤텍스를 비활성화하는 것만 큼 효과적이지 않습니다. 그러나 런타임에 뮤텍스를 비활성화하면 여전히 성능 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="db38b8db0ff11ad2083b7f6905b27367bbd64018" translate="yes" xml:space="preserve">
          <source>Disallow &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; in the &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt; of triggers and views. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</source>
          <target state="translated">트리거 및 뷰 의 &lt;a href=&quot;lang_with&quot;&gt;WITH 절&lt;/a&gt; 에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 허용하지 않습니다 . 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a4f5b6881f751cbf37ca7be8a10d5fc1ce5e931" translate="yes" xml:space="preserve">
          <source>Disallow control characters inside of strings in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551&lt;/a&gt;.</source>
          <target state="translated">JSON에서 문자열 내부의 제어 문자를 허용하지 않습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="4fbe5a75e7ecac67d383efc523453d8ca0e96ce9" translate="yes" xml:space="preserve">
          <source>Disallow leading zeros in numeric constants in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt;.</source>
          <target state="translated">JSON에서 숫자 상수에서 선행 0을 허용하지 않습니다. &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="2630cbc2f1d0549bdb067048921921ca0d31c770" translate="yes" xml:space="preserve">
          <source>Disallow temporary indices on permanent tables.</source>
          <target state="translated">영구 테이블에서 임시 인덱스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5acb0a0adde49aba96e6fc288d48b3950eb87672" translate="yes" xml:space="preserve">
          <source>Disallow the use of &quot;rowid&quot; in &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에서 &quot;rowid&quot;를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="664d42cee9dc2838800ae0429fea3975df123ee1" translate="yes" xml:space="preserve">
          <source>Disallow the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; in the recursive part of a CTE. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</source>
          <target state="translated">CTE의 재귀 부분에서 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 을 사용할 수 없습니다 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268c696f729a3bb7208ee6e45627908c164ce6fd" translate="yes" xml:space="preserve">
          <source>Disclose wrongful thoughts to your spiritual mentor.</source>
          <target state="translated">영적 멘토에게 잘못된 생각을 공개하십시오.</target>
        </trans-unit>
        <trans-unit id="df353315b1ac203fbf0fbde5acfa1d6dd139f099" translate="yes" xml:space="preserve">
          <source>Discontinue the use of posix_fallocate() on unix, as it does not work on all filesystems.</source>
          <target state="translated">모든 파일 시스템에서 작동하지 않으므로 유닉스에서 posix_fallocate () 사용을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="630ed0127b8c49cb6701137391eeab0c764d29db" translate="yes" xml:space="preserve">
          <source>Discontinue the use of thread-specific data for out-of-memory exception handling</source>
          <target state="translated">메모리 부족 예외 처리에 스레드 특정 데이터 사용 중단</target>
        </trans-unit>
        <trans-unit id="dc4ca73be659333abaa3afecb8d712a96bb9f569" translate="yes" xml:space="preserve">
          <source>Disk I/O operations tends to be more sequential using WAL.</source>
          <target state="translated">디스크 I / O 작업은 WAL을 사용하여보다 순차적 인 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="875cf7c3c58abcb6b2af3c59e6f41f8c4ce9ca26" translate="yes" xml:space="preserve">
          <source>Distinctive Features Of SQLite</source>
          <target state="translated">SQLite의 특징</target>
        </trans-unit>
        <trans-unit id="f327b00a868bc2fc77c6168d0e2d509cf7d8a51a" translate="yes" xml:space="preserve">
          <source>Diverse content which might otherwise be stored as a &quot;pile-of-files&quot; is encapsulated into a single disk file for simpler transport via scp/ftp, USB stick, and/or email attachment.</source>
          <target state="translated">&quot;파일의 파일&quot;로 저장 될 수있는 다양한 컨텐츠는 scp / ftp, USB 스틱 및 / 또는 이메일 첨부 파일을 통한보다 간단한 전송을 위해 단일 디스크 파일로 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="104ed7c21cfc9b8ba11824e5729cef81f421e172" translate="yes" xml:space="preserve">
          <source>Divide</source>
          <target state="translated">Divide</target>
        </trans-unit>
        <trans-unit id="6a4bfffd32ff9d65b9739b01f6b92d5a2a406ec8" translate="yes" xml:space="preserve">
          <source>Divide the value in register P1 by the value in register P2 and store the result in register P3 (P3=P2/P1). If the value in register P1 is zero, then the result is NULL. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값을 레지스터 P2의 값으로 나누고 결과를 레지스터 P3에 저장합니다 (P3 = P2 / P1). 레지스터 P1의 값이 0이면 결과는 NULL입니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="4bd6c15a025907299e44072515501d69283cf065" translate="yes" xml:space="preserve">
          <source>Do an analysis of the currently open database. Store in register P1 the text of an error message describing any problems. If no problems are found, store a NULL in register P1.</source>
          <target state="translated">현재 열려있는 데이터베이스를 분석하십시오. 문제를 설명하는 오류 메시지의 텍스트를 레지스터 P1에 저장하십시오. 문제가 없으면 레지스터 P1에 NULL을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="b58dc41668bbf2d2a5ac0f7843e60d1fd0b29a30" translate="yes" xml:space="preserve">
          <source>Do full-table scans using covering indices when possible, under the theory that an index will be smaller and hence can be scanned with less I/O.</source>
          <target state="translated">인덱스가 더 작아서 적은 I / O로 스캔 할 수 있다는 이론 하에서 가능하면 커버링 인덱스를 사용하여 전체 테이블 스캔을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d61e75c7c6aa57e44ccfb36bea2e0d2cd4826003" translate="yes" xml:space="preserve">
          <source>Do no wrong to anyone, and bear patiently wrongs done to yourself.</source>
          <target state="translated">누구에게도 잘못하지 말고, 자신에게 행한 참을성있는 잘못을 감당하십시오.</target>
        </trans-unit>
        <trans-unit id="c7acd87886221e65424bf1acce3086f3655acf30" translate="yes" xml:space="preserve">
          <source>Do not allocate a new page. Return NULL.</source>
          <target state="translated">새 페이지를 할당하지 마십시오. NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1baafbd29f15f73b5db2bd55006fe595ca88606" translate="yes" xml:space="preserve">
          <source>Do not allow dot-commands of the command-line shell to occur in the middle of a real SQL command.</source>
          <target state="translated">실제 SQL 명령 중에 명령 행 쉘의 도트 명령이 발생하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="722464d20a4d3822872080ca5426f1791b661a71" translate="yes" xml:space="preserve">
          <source>Do not apply the WHERE-clause pushdown optimization on terms that originate in the ON or USING clause of a LEFT JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN의 ON 또는 USING 절에서 시작된 용어에 대해서는 WHERE 절 푸시 다운 최적화를 적용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="9e626f7dec3803cf39b9ed3c8d4b8ddd26aa3a01" translate="yes" xml:space="preserve">
          <source>Do not apply the flattening optimization if the outer query is an aggregate and the inner query contains ORDER BY. (Ticket #2943)</source>
          <target state="translated">외부 쿼리가 집계이고 내부 쿼리에 ORDER BY가 포함 된 경우 병합 최적화를 적용하지 마십시오. (티켓 # 2943)</target>
        </trans-unit>
        <trans-unit id="47f951dc04aa5e685ae032b56eb35642da21ee4e" translate="yes" xml:space="preserve">
          <source>Do not attempt to use terms from the WHERE clause to enable indexed lookup of the right-hand table of a LEFT JOIN. Ticket &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</source>
          <target state="translated">LEFT JOIN의 오른쪽 테이블을 인덱스로 조회 할 수 있도록 WHERE 절에서 용어를 사용하지 마십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb440372f32dec89b9398b09a9e6e2779b9db126" translate="yes" xml:space="preserve">
          <source>Do not attempt to use the strchrnul() function from the standard C library unless the HAVE_STRCHRNULL compile-time option is set.</source>
          <target state="translated">HAVE_STRCHRNULL 컴파일 시간 옵션이 설정되어 있지 않으면 표준 C 라이브러리에서 strchrnul () 함수를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b64adffd7b86aaa3092ff02c70021235bc894300" translate="yes" xml:space="preserve">
          <source>Do not be afraid to explore and experiment. Without a log-in you won't be able to push back any changes you make, so you cannot damage the project.</source>
          <target state="translated">탐험하고 실험하는 것을 두려워하지 마십시오. 로그인하지 않으면 변경 사항을 되돌릴 수 없으므로 프로젝트를 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d05159095924dcadc1e25110c5f5f929ebba2a2a" translate="yes" xml:space="preserve">
          <source>Do not be confused by the fact that a column might have a &quot;numeric&quot; datatype. This does not mean that the column can contain only numbers. It merely means that if the column does contain a number, that number will sort in numerical order.</source>
          <target state="translated">열에 &quot;숫자&quot;데이터 유형이있을 수 있으므로 혼동하지 마십시오. 이것은 열에 숫자 만 포함될 수 있음을 의미하지는 않습니다. 이는 열에 숫자가 포함 된 경우 해당 숫자가 숫자 순서로 정렬됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b5c9cbefc6ca63f2b182857e9018d39b28c3534" translate="yes" xml:space="preserve">
          <source>Do not be misled by the &quot;Lite&quot; in the name. SQLite has a full-featured SQL implementation, including:</source>
          <target state="translated">이름에서 &quot;Lite&quot;로 오해하지 마십시오. SQLite에는 다음을 포함한 모든 기능을 갖춘 SQL 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ad576ed2750422c0fb9b979bec85d0e4fc99e1" translate="yes" xml:space="preserve">
          <source>Do not bear false witness.</source>
          <target state="translated">거짓 증거를하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dc340a536129d864cf116ede217fe057492374c8" translate="yes" xml:space="preserve">
          <source>Do not become attached to pleasures.</source>
          <target state="translated">즐거움에 집착하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="47541d37d26b95f8c181a2dc345a039022162ef4" translate="yes" xml:space="preserve">
          <source>Do not commit adultery.</source>
          <target state="translated">간음하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0527e2ce52914545d104d45569846431699a53a2" translate="yes" xml:space="preserve">
          <source>Do not confuse automatic indexes with the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; (having names like &quot;sqlite_autoindex_</source>
          <target state="translated">자동 색인과 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 색인을&lt;/a&gt; 혼동하지 마십시오 (예 : &quot;sqlite_autoindex_</target>
        </trans-unit>
        <trans-unit id="5b87dbbc2f82f39fe5e094dea4061b8791b8238e" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그를 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = NORMAL 및 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = FULL 설정 과 혼동하지 마십시오 . &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;동기 프라그는&lt;/a&gt; xSync VFS 메소드 호출이 발생할 때 결정하고, 모든 플랫폼에 걸쳐 균일하게 적용된다. SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그는 동기화 작업이 얼마나 활기차고 엄격하거나 강력한 지 결정하며 기본 SQLite 코드에 대해 Mac OSX에서만 차이를 만듭니다. (타사 VFS 구현은 SQLITE_SYNC_NORMAL과 SQLITE_SYNC_FULL을 구별 할 수도 있지만 SQLite가 기본적으로 지원하는 운영 체제 중에서는 Mac OSX 만 차이에 신경을 씁니다.)</target>
        </trans-unit>
        <trans-unit id="002e1751e184528adf8c6f1d702e80e85446806a" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그를 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = NORMAL 및 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = FULL 설정 과 혼동하지 마십시오 . &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;동기 프라그는&lt;/a&gt; xSync VFS 메소드 호출이 발생할 때 결정하고, 모든 플랫폼에 걸쳐 균일하게 적용된다. SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그는 동기화 작업이 얼마나 활기차고 엄격하거나 강력한 지 결정하며 기본 SQLite 코드에 대해 Mac OSX에서만 차이를 만듭니다. (타사 VFS 구현은 SQLITE_SYNC_NORMAL과 SQLITE_SYNC_FULL을 구별 할 수도 있지만 SQLite가 기본적으로 지원하는 운영 체제 중에서는 Mac OSX 만 차이에 신경을 씁니다.)</target>
        </trans-unit>
        <trans-unit id="ad2017a368e4acba6381b0a256f7226272260dc0" translate="yes" xml:space="preserve">
          <source>Do not count rows where the IGNORE conflict resolution occurs in the row count.</source>
          <target state="translated">행 수에서 IGNORE 충돌 해결이 발생한 행은 계산하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b7c755ee6b849cdf60ae59e908ab1fc867a27494" translate="yes" xml:space="preserve">
          <source>Do not covet.</source>
          <target state="translated">탐 내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="db62bb840a97eee5b8883ebcef3e582e3e673f43" translate="yes" xml:space="preserve">
          <source>Do not curse those who curse you, but rather bless them.</source>
          <target state="translated">당신을 저주하는 사람들을 저주하지 말고 축복하십시오.</target>
        </trans-unit>
        <trans-unit id="2d234151c3e9c3911335b0f3da32177b2942f1e3" translate="yes" xml:space="preserve">
          <source>Do not do to another what you would not have done to yourself.</source>
          <target state="translated">자신에게하지 않았던 일을 다른 사람에게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="acd5314ee2a0e4064ce9351ca89b05b07641e78e" translate="yes" xml:space="preserve">
          <source>Do not enable memory-mapped I/O. In other words, make sure that &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size=0&lt;/a&gt;.</source>
          <target state="translated">메모리 매핑 된 I / O를 활성화하지 마십시오. 즉, &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size = 0&lt;/a&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="034edd930627c1bd6308a4139c12b6665fcb2787" translate="yes" xml:space="preserve">
          <source>Do not entertain deceit in your heart.</source>
          <target state="translated">당신의 마음 속에 속임수를 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="81fd74cab483c5a336f294ba599bad0042897a37" translate="yes" xml:space="preserve">
          <source>Do not escape the backslash '\' character in the output of the &lt;b&gt;sqlite&lt;/b&gt; command-line access program.</source>
          <target state="translated">&lt;b&gt;sqlite&lt;/b&gt; 명령 행 액세스 프로그램 의 출력에서 ​​백 슬래시 '\'문자를 이스케이프하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c890cde5441c19e16767be21e8b596d667fd4a4d" translate="yes" xml:space="preserve">
          <source>Do not even call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on a database connection from a child process if the connection was opened in the parent. It is safe to close the underlying file descriptor, but the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; interface might invoke cleanup activities that will delete content out from under the parent, leading to errors and perhaps even database corruption.</source>
          <target state="translated">부모에서 연결이 열린 경우 자식 프로세스의 데이터베이스 연결에서 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 마십시오 . 기본 파일 디스크립터를 닫는 것이 안전하지만 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 인터페이스는 정리 활동을 호출하여 상위에서 컨텐츠를 삭제하여 오류 및 데이터베이스 손상을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9842d9ca1b62003346b1050ca3868a78c6e6df5b" translate="yes" xml:space="preserve">
          <source>Do not flush the page cache (and thus avoiding a cache refill) unless another process changes the underlying database file.</source>
          <target state="translated">다른 프로세스가 기본 데이터베이스 파일을 변경하지 않는 한 페이지 캐시를 플러시 (캐시 리필하지 않도록)하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2176e7264952425c2f250491ec533bbb7089a674" translate="yes" xml:space="preserve">
          <source>Do not forsake charity.</source>
          <target state="translated">자선 단체를 버리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bca45f5adbe0136828b61d27215211c39ce6b83c" translate="yes" xml:space="preserve">
          <source>Do not give a false peace.</source>
          <target state="translated">거짓 평화를주지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0fe47eb7b363d5a152896bf66373bc2d500a51a8" translate="yes" xml:space="preserve">
          <source>Do not give way to anger.</source>
          <target state="translated">화를 내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3d1cede4ac2a286b898864b92bb8c0cd08137e3b" translate="yes" xml:space="preserve">
          <source>Do not love much or boisterous laughter.</source>
          <target state="translated">많은 웃음을 사랑하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3c45d126a4940542085bf1e96a3ac522f5385ee4" translate="yes" xml:space="preserve">
          <source>Do not love much talking.</source>
          <target state="translated">많은 말을 좋아하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="68cc3d30139a8559e135cd4c8f558235d11abccb" translate="yes" xml:space="preserve">
          <source>Do not love quarreling.</source>
          <target state="translated">다툼을 좋아하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="629a7228998a89704c92b419f13085418997b310" translate="yes" xml:space="preserve">
          <source>Do not misunderstand: There is nothing technically wrong with displaying the error logger messages to end users. The messages do not contain sensitive or private information that must be protected from unauthorized viewing. Rather the messages are technical in nature and are not useful or meaningful to the typical end user. The messages coming from the error logger are intended for database geeks. Display them accordingly.</source>
          <target state="translated">오해하지 마십시오. 최종 사용자에게 오류 로거 메시지를 표시하는 데 기술적으로 잘못된 것은 없습니다. 메시지에는 무단으로 보지 않도록 보호해야하는 민감한 정보 나 개인 정보가 포함되어 있지 않습니다. 오히려 메시지는 기술적 인 것이며 일반적인 최종 사용자에게는 유용하지 않습니다. 오류 로거에서 오는 메시지는 데이터베이스 전문가를위한 것입니다. 그에 따라 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8f8ddbae63c42651d375c0bd04cebf3413348f90" translate="yes" xml:space="preserve">
          <source>Do not murder.</source>
          <target state="translated">살인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1f35225b21f15dae6087ed7eeacb7e2fc8285c86" translate="yes" xml:space="preserve">
          <source>Do not nurse a grudge.</source>
          <target state="translated">원한을 간호하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0a1c640222a0771668990edc889cc0113169d8ac" translate="yes" xml:space="preserve">
          <source>Do not open an SQLite database connection, then fork(), then try to use that database connection in the child process. All kinds of locking problems will result and you can easily end up with a corrupt database. SQLite is not designed to support that kind of behavior. Any database connection that is used in a child process must be opened in the child process, not inherited from the parent.</source>
          <target state="translated">SQLite 데이터베이스 연결을 연 다음 fork ()를 사용하지 말고 하위 프로세스에서 해당 데이터베이스 연결을 사용하십시오. 모든 종류의 잠금 문제가 발생하여 데이터베이스가 손상 될 수 있습니다. SQLite는 이러한 종류의 동작을 지원하도록 설계되지 않았습니다. 하위 프로세스에서 사용되는 모든 데이터베이스 연결은 상위 프로세스에서 상속되지 않고 하위 프로세스에서 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="3df8aad94da73f8e621cafc5e1cbb5ccbe166028" translate="yes" xml:space="preserve">
          <source>Do not put write locks on the file used to hold TEMP tables.</source>
          <target state="translated">TEMP 테이블을 보유하는 데 사용되는 파일에 쓰기 잠금을 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="167222828b6a7323e00470f04ccff91439f97f91" translate="yes" xml:space="preserve">
          <source>Do not read in the (meaningless) content of pages extracted from the freelist.</source>
          <target state="translated">자유 목록에서 추출 된 페이지의 (의미없는) 내용을 읽지 마십시오.</target>
        </trans-unit>
        <trans-unit id="88443743067599e18c7d1c7b495b0aed7fcc56ac" translate="yes" xml:space="preserve">
          <source>Do not read the last page of an overflow chain when deleting the row - just add that page to the freelist.</source>
          <target state="translated">행을 삭제할 때 오버 플로우 체인의 마지막 페이지를 읽지 말고 해당 페이지를 자유 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a7d06580230b34d6f8a726d493bee6f3225055ed" translate="yes" xml:space="preserve">
          <source>Do not require commas between constraints in CREATE TABLE statements.</source>
          <target state="translated">CREATE TABLE 문에서 제한 조건 사이에 쉼표가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fc4941b3cd021627fe69bb109677c3c3d923f4e" translate="yes" xml:space="preserve">
          <source>Do not return evil for evil.</source>
          <target state="translated">악을 악으로 돌려 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="21dd78a660444cf8065985daa16f5a53b2b94b26" translate="yes" xml:space="preserve">
          <source>Do not steal.</source>
          <target state="translated">훔치지 마.</target>
        </trans-unit>
        <trans-unit id="ad5e34ebf9599545e50b3a0dc2ba3f44f88168b2" translate="yes" xml:space="preserve">
          <source>Do not store pages being deleted in the rollback journal.</source>
          <target state="translated">롤백 저널에서 삭제중인 페이지를 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4db470ddd81b2b754811d69f10c92e79bba57171" translate="yes" xml:space="preserve">
          <source>Do not swear, for fear of perjuring yourself.</source>
          <target state="translated">자신을 다치게 할까봐 맹세하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ec7cd9078e5c61634a562846d1cb709ab20d0358" translate="yes" xml:space="preserve">
          <source>Do not use a partial index to do a table scan on an IN operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;.</source>
          <target state="translated">IN 연산자에서 테이블 스캔을 수행하기 위해 부분 인덱스를 사용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20680b9a624f1f557a55b0811ddc984091848e37" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; for a sub-query on the RHS of a LEFT JOIN if that subquery reads data from a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; as doing so prevents the query planner from creating &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the results of the sub-query, which can slow down the query.</source>
          <target state="translated">하위 쿼리가 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 데이터를 읽을 때 쿼리 플래너 가 하위 쿼리의 결과에 대해 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱스&lt;/a&gt; 를 작성하지 못하게하는 경우 하위 쿼리의 RHS에서 하위 쿼리에 대한 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 를 사용하지 마십시오. 검색어를</target>
        </trans-unit>
        <trans-unit id="f5a36cf13f2d75f5b1d063cbaf3e6dabed9e5e96" translate="yes" xml:space="preserve">
          <source>Do not wish to be called holy before one is holy; but first to be holy, that you may be truly so called.</source>
          <target state="translated">거룩하기 전에 거룩하게되기를 원하지 마십시오. 그러나 먼저 거룩 해져서 진정으로 그렇게 부름받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5969cbceed42549abcad3776ee3d2a22161ed52f" translate="yes" xml:space="preserve">
          <source>Do not write changes to standard output. Instead, write a (binary) changeset file into FILE. The changeset can be interpreted using the sessions extension to SQLite.</source>
          <target state="translated">표준 출력에 변경 사항을 쓰지 마십시오. 대신 (이진) 변경 세트 파일을 FILE에 작성하십시오. 변경 세트는 세션 확장을 SQLite로 사용하여 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab50d236c22af4547ec015790d6040a4642e45e" translate="yes" xml:space="preserve">
          <source>Do nothing. This instruction is often useful as a jump destination.</source>
          <target state="translated">아무것도하지 마세요. 이 명령어는 종종 점프 대상으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19eb9de9fe2776c399eac9b123129daec5f5dd94" translate="yes" xml:space="preserve">
          <source>Document Lists And Indexes</source>
          <target state="translated">문서 목록 및 색인</target>
        </trans-unit>
        <trans-unit id="8c461e6b3d5184a9059cf94be86da7dbc747e4cf" translate="yes" xml:space="preserve">
          <source>Document Structure</source>
          <target state="translated">문서 구조</target>
        </trans-unit>
        <trans-unit id="3a469072b5974a6ac1b0b86818461b57cc048dea" translate="yes" xml:space="preserve">
          <source>Document the hazards of type conversions in &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt; and related APIs. Fix unnecessary type conversions. Ticket #2321.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob ()&lt;/a&gt; 및 관련 API 에서 유형 변환의 위험성을 문서화하십시오 . 불필요한 유형 변환을 수정하십시오. 티켓 # 2321.</target>
        </trans-unit>
        <trans-unit id="28ddcac222be4dd54f888cc20f015c092a5e040c" translate="yes" xml:space="preserve">
          <source>Document versioning</source>
          <target state="translated">문서 버전 관리</target>
        </trans-unit>
        <trans-unit id="fe7304ab51248437db8b4b66ad9ad43f8b781a02" translate="yes" xml:space="preserve">
          <source>Documentation updates</source>
          <target state="translated">설명서 업데이트</target>
        </trans-unit>
        <trans-unit id="e7eabf63bf0b622355ee7928fc5a397625e241a7" translate="yes" xml:space="preserve">
          <source>Documentation updates and typo fixes</source>
          <target state="translated">설명서 업데이트 및 오타 수정</target>
        </trans-unit>
        <trans-unit id="b3606774842986999d74ead8587f30081f764162" translate="yes" xml:space="preserve">
          <source>Documentation updates.</source>
          <target state="translated">설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="b4f8a8a7e46cd0f4bef297d6b523710d4bbf11e1" translate="yes" xml:space="preserve">
          <source>Documentation updates. Mostly fixing of typos and spelling errors.</source>
          <target state="translated">설명서 업데이트. 대부분 오타 및 철자 오류 수정.</target>
        </trans-unit>
        <trans-unit id="2014de1c64e4558d3e684536a5eead31d8646480" translate="yes" xml:space="preserve">
          <source>Documented support for the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt;. This feature has actually been in the code since &lt;a href=&quot;#version_3_7_9&quot;&gt;version 3.7.9&lt;/a&gt; but is only now considered to be officially supported.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 컨텐츠 옵션에&lt;/a&gt; 대한 문서화 된 지원 . 이 기능은 실제로 &lt;a href=&quot;#version_3_7_9&quot;&gt;버전 3.7.9&lt;/a&gt; 부터 코드에 포함 되었지만 현재 공식적으로 지원되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1141953a3cac893e565c0cb7afc09130be28d815" translate="yes" xml:space="preserve">
          <source>Does SQLite support a BLOB type?</source>
          <target state="translated">SQLite는 BLOB 유형을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="d7ac8ab68849b9ef0f13b08bdcc3c9b49215d5ba" translate="yes" xml:space="preserve">
          <source>Does SQLite support foreign keys?</source>
          <target state="translated">SQLite는 외래 키를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="e2a8b45f99cb6f35744147d23ba67820b9196a7e" translate="yes" xml:space="preserve">
          <source>Does not support ZIP archives that span multiple files.</source>
          <target state="translated">여러 파일에 걸쳐있는 ZIP 아카이브는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f67d427a021b49d829af064322fcd164d0d520fe" translate="yes" xml:space="preserve">
          <source>Does not support encryption.</source>
          <target state="translated">암호화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a182c94fa152e112192c0491165a8fdd3fd894bc" translate="yes" xml:space="preserve">
          <source>Does not support zip64 extensions.</source>
          <target state="translated">zip64 확장자를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="266906722673b9d89a70b9366dca968b0e3c9bf4" translate="yes" xml:space="preserve">
          <source>Dot-commands do not recognize comments.</source>
          <target state="translated">점 명령은 주석을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8a31aee94d3aa206ec99f016bf029e559e48bfac" translate="yes" xml:space="preserve">
          <source>Dot-file locking style. This locking style is used when neither flock nor POSIX locking styles are supported by the file system. Database locks are obtained by creating and entry in the file-system at a well-known location relative to the database file (a &quot;dot-file&quot;) and relinquished by deleting the same file.</source>
          <target state="translated">도트 파일 잠금 스타일. 이 잠금 스타일은 파일 시스템에서 무리 또는 POSIX 잠금 스타일을 지원하지 않을 때 사용됩니다. 데이터베이스 잠금은 데이터베이스 파일과 관련하여 잘 알려진 위치 ( &quot;도트 파일&quot;)에서 파일 시스템을 작성하고 항목을 입력하여 얻어지며 동일한 파일을 삭제하여 포기합니다.</target>
        </trans-unit>
        <trans-unit id="5886a74b53398ec47ad06e2d60de33d78d94131a" translate="yes" xml:space="preserve">
          <source>Double-Quoted Strings Allowed</source>
          <target state="translated">이중 인용 문자열 허용</target>
        </trans-unit>
        <trans-unit id="9527eaee4dc6adf69520b29f63dfd254ba6893eb" translate="yes" xml:space="preserve">
          <source>Double-quoted strings interpreted as column names not text literals.</source>
          <target state="translated">큰 따옴표로 묶인 문자열은 텍스트 리터럴이 아닌 열 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ffe7363e8f5e47f6d5cff2a021a49b0ba15973c3" translate="yes" xml:space="preserve">
          <source>Download The Code</source>
          <target state="translated">코드 다운로드</target>
        </trans-unit>
        <trans-unit id="2bf81ffb06a97ae87b64f9122c76cd7ce2c19062" translate="yes" xml:space="preserve">
          <source>Download the self-contained Fossil executable from &lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; and put the executable somewhere on your $PATH.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; 에서 자체 포함 된 Fossil 실행 파일을 다운로드 하여 $ PATH의 어딘가에 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="bf164a21eb062e18af9a991c052f3c70484a26df" translate="yes" xml:space="preserve">
          <source>Dozens of minor bug fixes</source>
          <target state="translated">수십 가지 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="a929098ee87888960431567bedaf2f19daf292b0" translate="yes" xml:space="preserve">
          <source>Drop all support for the &lt;a href=&quot;malloc#memsysx&quot;&gt;experimental memory allocators&lt;/a&gt; memsys4 and memsys6.</source>
          <target state="translated">&lt;a href=&quot;malloc#memsysx&quot;&gt;실험 메모리 할당 자&lt;/a&gt; memsys4 및 memsys6에 대한 모든 지원을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="1f3f7deb8c2edee3371b95381860beff36c9b366" translate="yes" xml:space="preserve">
          <source>Drop built-in support for OS/2. If you need to upgrade an OS/2 application to use this or a later version of SQLite, then add an application-defined &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface. The code removed in this release can serve as a baseline for the application-defined VFS.</source>
          <target state="translated">OS / 2에 대한 기본 제공 지원. 이 버전 또는 이후 버전의 SQLite를 사용하기 위해 OS / 2 애플리케이션을 업그레이드해야하는 경우 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 애플리케이션 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 추가하십시오 . 이 릴리스에서 제거 된 코드는 응용 프로그램 정의 VFS의 기준으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e9878b7430ec40bb0aac87c5455cd33a663347" translate="yes" xml:space="preserve">
          <source>Drop old table</source>
          <target state="translated">이전 테이블 삭제</target>
        </trans-unit>
        <trans-unit id="831cee7fe7313360794c461d24e27019d0aa0fa8" translate="yes" xml:space="preserve">
          <source>Drop support for SQLITE_ENABLE_TREE_EXPLAIN. The SELECTTRACE mechanism provides more useful diagnostics information.</source>
          <target state="translated">SQLITE_ENABLE_TREE_EXPLAIN에 대한 삭제 지원. SELECTTRACE 메커니즘은보다 유용한 진단 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0bd2f0f029e99d0a73743bc173e5b08aa4ae2984" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks but retain the SHARED lock.</source>
          <target state="translated">독점 잠금 및 보류 잠금을 제거하고 공유 잠금을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="cece823a856676f78f4a41646b3bcd314a06e9ba" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from all database files.</source>
          <target state="translated">모든 데이터베이스 파일에서 독점 및 보류 잠금을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="41ede7277f5fa3c98b30f351e4b2a0728bbb7eac" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from the database file.</source>
          <target state="translated">데이터베이스 파일에서 EXCLUSIVE 및 PENDING 잠금을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="daced6c943d50569fdbed0b8c852df4819f96d8b" translate="yes" xml:space="preserve">
          <source>Drop the old table X: &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X&lt;/a&gt;.</source>
          <target state="translated">이전 테이블 X : &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X를&lt;/a&gt; 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e57de85bbf5c15a59892ff50c8f7c01032ec317" translate="yes" xml:space="preserve">
          <source>DropIndex</source>
          <target state="translated">DropIndex</target>
        </trans-unit>
        <trans-unit id="4a8749bce90b847b8afa8914da8c1204a28e572c" translate="yes" xml:space="preserve">
          <source>DropTable</source>
          <target state="translated">DropTable</target>
        </trans-unit>
        <trans-unit id="5194da2ad6f6b74ff6082f247ce4ac8437a9ce02" translate="yes" xml:space="preserve">
          <source>DropTrigger</source>
          <target state="translated">DropTrigger</target>
        </trans-unit>
        <trans-unit id="e5c413032a9c5e630e19fe262e62d7fb21ec3a73" translate="yes" xml:space="preserve">
          <source>Dropped support for the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 컴파일 타임 옵션에 대한 지원이 중단되었습니다 .</target>
        </trans-unit>
        <trans-unit id="13fc6ee3a5aa40fdb0e1d5ecf732cd2ab210b40a" translate="yes" xml:space="preserve">
          <source>Duplicate ephemeral cursors are used for self-joins of materialized views.</source>
          <target state="translated">중복 된 임시 커서는 구체화 된 뷰의 자체 조인에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22bb6bc640d9e76642a03f301228df50bc0c544a" translate="yes" xml:space="preserve">
          <source>Duplicate row returned on a query against a table with more than 16 indices, each on a separate column, and all used via OR-connected constraints. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</source>
          <target state="translated">16 개 이상의 인덱스 (각각 별도 열에 있음)가있는 테이블에 대해 쿼리에서 중복 행이 반환되었으며 모두 OR 연결 제약 조건을 통해 사용되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93d7730f8826a2d54d04e212d85d32152f0ff3ce" translate="yes" xml:space="preserve">
          <source>During a transaction, SQLite stores additional information in a second file called the &quot;rollback journal&quot;, or if SQLite is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, a write-ahead log file.</source>
          <target state="translated">트랜잭션 중에 SQLite는 추가 정보를 &quot;롤백 저널&quot;이라는 두 번째 파일에 저장하거나 SQLite가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 인 경우 미리 쓰기 로그 파일입니다.</target>
        </trans-unit>
        <trans-unit id="d30f21585fed5c23f99fb922e9805bc00a1eabdf" translate="yes" xml:space="preserve">
          <source>During a transaction, some of the data written to an FTS table may be cached in memory and written to the database only when the transaction is committed. However the implementation of the fts4aux module is only able to read data from the database. In practice this means that if an fts4aux table is queried from within a transaction in which the associated FTS table has been modified, the results of the query are likely to reflect only a (possibly empty) subset of the changes made.</source>
          <target state="translated">트랜잭션 중에 FTS 테이블에 기록 된 일부 데이터는 트랜잭션이 커밋 된 경우에만 메모리에 캐시되고 데이터베이스에 기록 될 수 있습니다. 그러나 fts4aux 모듈의 구현은 데이터베이스에서 데이터를 읽을 수만 있습니다. 실제로 이는 관련 FTS 테이블이 수정 된 트랜잭션 내에서 fts4aux 테이블을 쿼리하면 쿼리 결과에 변경 사항 중 일부만 반영 될 가능성이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad42e3b2740327c2dba977f94946673b656caef3" translate="yes" xml:space="preserve">
          <source>During most testing, however, these macros will throw an assertion fault if their argument does not have the expected truth value. This alerts the developers quickly to incorrect design assumptions.</source>
          <target state="translated">그러나 대부분의 테스트 중에 이러한 매크로는 인수에 예상되는 진리 값이 없으면 어설 션 오류가 발생합니다. 이는 개발자에게 잘못된 설계 가정을 신속하게 알립니다.</target>
        </trans-unit>
        <trans-unit id="12f7d01f7aef91494af4f6f7a834f78084a02691" translate="yes" xml:space="preserve">
          <source>During part of SQLite's INSERT and SELECT processing, the complete content of each row in the database is encoded as a single BLOB. So the SQLITE_MAX_LENGTH parameter also determines the maximum number of bytes in a row.</source>
          <target state="translated">SQLite의 INSERT 및 SELECT 처리 중에 데이터베이스에있는 각 행의 전체 내용이 단일 BLOB으로 인코딩됩니다. 따라서 SQLITE_MAX_LENGTH 매개 변수는 행의 최대 바이트 수를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="11df476623628b473251d2d86924a52d99a7ec80" translate="yes" xml:space="preserve">
          <source>During recovery of the global shared-memory WAL-index, exclusive locks are held on WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK, and WAL_READ_LOCK(1) through WAL_READ_LOCK(4). In other words, all locks associated with the WAL-index except for WAL_READ_LOCK(0) are held exclusively. This prevents any other thread from writing the database and from reading any transactions that are held in the WAL, until the recovery is complete.</source>
          <target state="translated">글로벌 공유 메모리 WAL 인덱스를 복구하는 동안 배타적 잠금은 WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK 및 WAL_READ_LOCK (1)에서 WAL_READ_LOCK (4)까지 유지됩니다. 즉, WAL_READ_LOCK (0)을 제외한 WAL- 인덱스와 관련된 모든 잠금은 독점적으로 유지됩니다. 이렇게하면 복구가 완료 될 때까지 다른 스레드가 데이터베이스를 쓰거나 WAL에 보유 된 트랜잭션을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1358f8df690459d3328e508cecf523a429f80164" translate="yes" xml:space="preserve">
          <source>During testing, the SQLite library is compiled with special instrumentation that allows the test scripts to simulate a wide variety of failures in order to verify that SQLite recovers correctly. Memory allocation is carefully tracked and no memory leaks occur, even following memory allocation failures. A custom VFS layer is used to simulate operating system crashes and power failures in order to ensure that transactions are atomic across these events. A mechanism for deliberately injecting I/O errors shows that SQLite is resilient to such malfunctions. (As an experiment, try inducing these kinds of errors on other SQL database engines and see what happens!)</source>
          <target state="translated">테스트 중에 SQLite 라이브러리는 특수 계측으로 컴파일되어 SQLite가 올바르게 복구되는지 테스트 스크립트가 다양한 실패를 시뮬레이션 할 수 있도록합니다. 메모리 할당은 신중하게 추적되며 메모리 할당 실패 후에도 메모리 누수가 발생하지 않습니다. 사용자 지정 VFS 계층은 이러한 이벤트에서 트랜잭션이 원 자성을 갖도록 운영 체제 충돌 및 정전을 시뮬레이션하는 데 사용됩니다. 의도적으로 I / O 오류를 주입하는 메커니즘은 SQLite가 이러한 오작동에 대해 탄력적이라는 것을 보여줍니다. 실험으로 다른 SQL 데이터베이스 엔진에서 이러한 종류의 오류를 유도하고 어떻게되는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="083eeb3cf3761acd0b9b1944cd026822ab96a1ec" translate="yes" xml:space="preserve">
          <source>During the 250 ms sleep in step 3 above, no read-lock is held on the database file and the mutex associated with pDb is not held. This allows other threads to use &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pDb and other connections to write to the underlying database file.</source>
          <target state="translated">위의 3 단계에서 250ms 절전 동안 데이터베이스 파일에 대한 읽기 잠금이 유지되지 않고 pDb와 관련된 뮤텍스가 유지되지 않습니다. 이것은 다른 스레드가 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pDb 를 사용 하고 다른 연결이 기본 데이터베이스 파일에 쓸 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5bc5d8e5dea4ffc98e00ec0c1ec074dd1e7d3ff2" translate="yes" xml:space="preserve">
          <source>During the conclusion of a</source>
          <target state="translated">의 결론 동안</target>
        </trans-unit>
        <trans-unit id="fe8ce31db6eecdb3f85f2298aa1ab49d66128d02" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation</source>
          <target state="translated">동적 메모리 할당</target>
        </trans-unit>
        <trans-unit id="720d5bb7b021bd57042c2b5aa6c65c1226f1ffcd" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation In SQLite</source>
          <target state="translated">SQLite의 동적 메모리 할당</target>
        </trans-unit>
        <trans-unit id="6a1ec417f9656bfa58ac913f9a623361c31817a1" translate="yes" xml:space="preserve">
          <source>Dynamic String Object</source>
          <target state="translated">동적 문자열 객체</target>
        </trans-unit>
        <trans-unit id="75da5571b32189815fa4662789976e48c0ca6b04" translate="yes" xml:space="preserve">
          <source>Dynamic analysis refers to internal and external checks on the SQLite code which are performed while the code is live and running. Dynamic analysis has proven to be a great help in maintaining the quality of SQLite.</source>
          <target state="translated">동적 분석은 코드가 작동하고 실행되는 동안 수행되는 SQLite 코드의 내부 및 외부 검사를 말합니다. 동적 분석은 SQLite의 품질을 유지하는 데 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a5cb0906656acf2bda3bc32fbfc18bd37f772de3" translate="yes" xml:space="preserve">
          <source>Dynamic and static analysis of the code</source>
          <target state="translated">코드의 동적 및 정적 분석</target>
        </trans-unit>
        <trans-unit id="758e372147a13eab85e0e2348816aeca5a5cf87b" translate="yes" xml:space="preserve">
          <source>Dynamically Typed Value Object</source>
          <target state="translated">동적으로 입력 된 값 개체</target>
        </trans-unit>
        <trans-unit id="dd5afbce0893bc1f40078bd68b471379645389da" translate="yes" xml:space="preserve">
          <source>EACH</source>
          <target state="translated">EACH</target>
        </trans-unit>
        <trans-unit id="bf4cc46f7f1441b1500c1ac4cef239d17020ff30" translate="yes" xml:space="preserve">
          <source>ELSE</source>
          <target state="translated">ELSE</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="79e27d141723fbb1d4275c9dc81bef88d08e1858" translate="yes" xml:space="preserve">
          <source>END TRANSACTION</source>
          <target state="translated">거래 종료</target>
        </trans-unit>
        <trans-unit id="4351e320e43aa32eebed42b35b21b2097a23c049" translate="yes" xml:space="preserve">
          <source>END TRANSACTION is an alias for COMMIT.</source>
          <target state="translated">END TRANSACTION은 COMMIT의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="01dce0e5ecf8d5b17ab6b7c1ca9a8662e220cefd" translate="yes" xml:space="preserve">
          <source>EPUB - The Electronic Publication format used by non-Kindle eBooks</source>
          <target state="translated">EPUB-Kindle 이외의 전자 책에서 사용하는 전자 출판 형식</target>
        </trans-unit>
        <trans-unit id="ac47189c9768197d8574c8f14988b8ef7e5d8f6d" translate="yes" xml:space="preserve">
          <source>ESCAPE</source>
          <target state="translated">ESCAPE</target>
        </trans-unit>
        <trans-unit id="c23142c6f147963dd2685f230238ef6772802e99" translate="yes" xml:space="preserve">
          <source>EXCEPT</source>
          <target state="translated">EXCEPT</target>
        </trans-unit>
        <trans-unit id="9cb33cc90a8a55873e7bc639c8e97e85186cc428" translate="yes" xml:space="preserve">
          <source>EXCLUDE</source>
          <target state="translated">EXCLUDE</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="e374cc411cf56ba9d22e8a8dfb723b4ab3e4424c" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE is similar to IMMEDIATE in that a write transaction is started immediately. EXCLUSIVE and IMMEDIATE are the same in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, but in other journaling modes, EXCLUSIVE prevents other database connections from reading the database while the transaction is underway.</source>
          <target state="translated">EXCLUSIVE는 쓰기 트랜잭션이 즉시 시작된다는 점에서 IMMEDIATE와 유사합니다. EXCLUSIVE와 IMMEDIATE는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서는 동일 하지만 다른 저널링 모드에서는 EXCLUSIVE는 트랜잭션이 진행되는 동안 다른 데이터베이스 연결이 데이터베이스를 읽지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="2fbf78b206db15c2139a66a9634e3bf1d2176ccc" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN</source>
          <target state="translated">쿼리 계획 설명</target>
        </trans-unit>
        <trans-unit id="38addf8721d2c74e08b308b7b8b2dd7a72f15eb2" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN is most useful on a SELECT statement, but may also appear with other statements that read data from database tables (e.g. UPDATE, DELETE, INSERT INTO ... SELECT).</source>
          <target state="translated">EXPLAIN QUERY PLAN은 SELECT 문에서 가장 유용하지만 데이터베이스 테이블에서 데이터를 읽는 다른 문과 함께 나타날 수도 있습니다 (예 : UPDATE, DELETE, INSERT INTO ... SELECT).</target>
        </trans-unit>
        <trans-unit id="8e9da9a85266351f71e77f3e9609cc22715ef94e" translate="yes" xml:space="preserve">
          <source>EXPLAIN operates at run-time, not at prepare-time</source>
          <target state="translated">EXPLAIN은 준비 시간이 아닌 런타임에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="18fd69d15aa01be81ef0e1d97815be761eb30270" translate="yes" xml:space="preserve">
          <source>EXTRA synchronous is like FULL with the addition that the directory containing a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; is synced after that journal is unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability if the commit is followed closely by a power loss.</source>
          <target state="translated">EXTRA 동기는 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널을&lt;/a&gt; 포함하는 디렉토리가 DELETE 모드에서 트랜잭션을 커미트하기 위해 링크 해제 된 후에 롤백 저널을 포함하는 디렉토리 가 동기화 된다는 점에서 FULL과 비슷 합니다. EXTRA는 커밋 뒤에 전력 손실이 발생할 경우 추가적인 내구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="483d2106efe09daa894eea6a0c9033d9a67cc38c" translate="yes" xml:space="preserve">
          <source>Each 5-byte entry on a ptrmap page provides back-link information about one of the pages that immediately follow the pointer map. If page B is a ptrmap page then back-link information about page B+1 is provided by the first entry on the pointer map. Information about page B+2 is provided by the second entry. And so forth.</source>
          <target state="translated">ptrmap 페이지의 각 5 바이트 항목은 포인터 맵 바로 뒤에 오는 페이지 중 하나에 대한 백 링크 정보를 제공합니다. 페이지 B가 ptrmap 페이지 인 경우 페이지 B + 1에 대한 백 링크 정보는 포인터 맵의 첫 번째 항목에 의해 제공됩니다. B + 2 페이지에 대한 정보는 두 번째 항목에 의해 제공됩니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="1aabd87ca95da90a5c129eaf9247506c8bd66646" translate="yes" xml:space="preserve">
          <source>Each 5-byte ptrmap entry consists of one byte of &quot;page type&quot; information followed by a 4-byte big-endian page number. Five page types are recognized:</source>
          <target state="translated">각 5 바이트 ptrmap 항목은 1 바이트의 &quot;페이지 유형&quot;정보와 4 바이트 빅 엔디안 페이지 번호로 구성됩니다. 5 가지 페이지 유형이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="9a01146dc5470d97274ce8927b43f8fec82d7371" translate="yes" xml:space="preserve">
          <source>Each DELETE change is changed to an INSERT, and</source>
          <target state="translated">각 DELETE 변경이 INSERT로 변경되고</target>
        </trans-unit>
        <trans-unit id="eeb9033e1e45a2bbbcad76e978600d892c37b372" translate="yes" xml:space="preserve">
          <source>Each INSERT change is changed to a DELETE, and</source>
          <target state="translated">각 INSERT 변경 사항은 DELETE로 변경되고</target>
        </trans-unit>
        <trans-unit id="7b99091b54756df2ed9f1a0564ab23ebb66063ec" translate="yes" xml:space="preserve">
          <source>Each ORDER BY expression is processed as follows:</source>
          <target state="translated">각 ORDER BY 표현식은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="90ec8a858058608d92c79ea2b4e9e7b9bbccd9eb" translate="yes" xml:space="preserve">
          <source>Each SQL index, whether explicitly declared via a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implied by a UNIQUE or PRIMARY KEY constraint, corresponds to an index b-tree in the database file. Each entry in the index b-tree corresponds to a single row in the associated SQL table. The key to an index b-tree is a record composed of the columns that are being indexed followed by the key of the corresponding table row. For ordinary tables, the row key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, and for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables the row key is the PRIMARY KEY. Because every row in the table has a unique row key, all keys in an index are unique.</source>
          <target state="translated">&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 통해 명시 적으로 선언 되었거나 UNIQUE 또는 PRIMARY KEY 제한 조건에 의해 암시 된 각 SQL 인덱스 는 데이터베이스 파일의 인덱스 b- 트리에 해당합니다. 인덱스 b- 트리의 각 항목은 연관된 SQL 테이블의 단일 행에 해당합니다. 인덱스 b- 트리의 키는 색인을 생성하는 열과 해당 테이블 행의 키로 구성된 레코드입니다. 일반 테이블의 경우 행 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 이고 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 경우 행 키는 PRIMARY KEY입니다. 테이블의 모든 행에는 고유 한 행 키가 있으므로 인덱스의 모든 키는 고유합니다.</target>
        </trans-unit>
        <trans-unit id="972d3bbdff7b7be08051158b4855057f49ea49cd" translate="yes" xml:space="preserve">
          <source>Each SQL statement in the statement list is an instance of the following:</source>
          <target state="translated">명령문 목록의 각 SQL 문은 다음의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="8780624428063f8d9d37cbf9ecae097671b04573" translate="yes" xml:space="preserve">
          <source>Each SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; records cases when the query planner would benefit from having accurate results of ANALYZE at hand. These records are held in memory and accumulate over the life of a database connection. The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command looks at those records and runs ANALYZE on only those tables for which new or updated ANALYZE data seems likely to be useful. In most cases &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; will not run ANALYZE, but it will occasionally do so either for tables that have never before been analyzed, or for tables that have grown significantly since they were last analyzed.</source>
          <target state="translated">각 SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 쿼리 플래너가 정확한 ANALYZE 결과를 얻을 수있는 경우를 기록합니다. 이러한 레코드는 메모리에 보관되며 데이터베이스 연결 수명 동안 누적됩니다. &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA 최적화&lt;/a&gt; 레코드 및 실행에서 명령 외모는 신규 또는 ANALYZE 업데이트 된 데이터가 유용 할 것으로 보인다있는 테이블 만에 분석 할 수 있습니다. 대부분의 경우 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 는 ANALYZE를 실행하지 않지만, 이전에 분석 한 적이없는 테이블 또는 마지막 분석 이후 크게 성장한 테이블에 대해 때때로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="830748b5154094e00d6f1556c43a3fc63fc4833c" translate="yes" xml:space="preserve">
          <source>Each VFS implementation will subclass the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; by adding additional fields at the end to hold whatever information the VFS needs to know about an open file. It does not matter what information is stored as long as the total size of the structure does not exceed the szOsFile value recorded in the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">각 VFS 구현은 VFS가 열린 파일에 대해 알아야하는 정보를 보유하기 위해 끝에 추가 필드를 추가 하여 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 을 서브 클래 싱 합니다. 구조의 전체 크기가 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트에 기록 된 szOsFile 값을 초과하지 않는 한 어떤 정보가 저장되는지는 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="096a69c85e04b646e0b565d9908edc0c892b7052" translate="yes" xml:space="preserve">
          <source>Each argument specified as part of a &quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot; statement is either a column declaration or a configuration option. A &lt;b&gt;column declaration&lt;/b&gt; consists of one or more whitespace separated FTS5 barewords or string literals quoted in any manner acceptable to SQLite.</source>
          <target state="translated">&quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot;문의 일부로 지정된 각 인수는 열 선언 또는 구성 옵션입니다. &lt;b&gt;열 선언&lt;/b&gt; SQLite는 받아 들일 수있는 방식으로 인용 FTS5 barewords 또는 문자열 리터럴 분리 공백 하나 이상의 구성.</target>
        </trans-unit>
        <trans-unit id="c100bec1aacd96fc583726f3228e69edd0918c29" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; affects subsequent database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Database connections that already exist are unaffected. Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; overrides all previous calls within the same process.</source>
          <target state="translated">를 호출 할 때마다 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache은 ()&lt;/a&gt; 이후의 데이터베이스 사용하여 작성된 연결에 영향을 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16를 ()&lt;/a&gt; , 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2을 ()&lt;/a&gt; . 이미 존재하는 데이터베이스 연결에는 영향을 미치지 않습니다. &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에 대한&lt;/a&gt; 각 호출 은 동일한 프로세스 내의 모든 이전 호출을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f53a6a65a1ce3426676e4e3e0eefc393f32a825e" translate="yes" xml:space="preserve">
          <source>Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().</source>
          <target state="translated">sqlite3_trace () 또는 sqlite3_trace_v2 ()에 대한 각 호출은 sqlite3_trace () 또는 sqlite3_trace_v2 ()에 대한 이전 호출을 대체합니다 (취소).</target>
        </trans-unit>
        <trans-unit id="210d7d62dedd7b7a03aaed5a472bf17f4f31c5cb" translate="yes" xml:space="preserve">
          <source>Each call to sqlite3rbu_step() does a small amount of work towards completing the vacuum operation. Depending on the size of the database, a single vacuum may require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not finished but no error has occurred, and an SQLite error code if an error is encountered. If an error does occur, all subsequent calls to sqlite3rbu_step() immediately return the same error code.</source>
          <target state="translated">sqlite3rbu_step ()에 대한 각 호출은 진공 작업을 완료하기 위해 소량의 작업을 수행합니다. 데이터베이스의 크기에 따라 단일 진공에서 sqlite3rbu_step ()에 대한 수천 번의 호출이 필요할 수 있습니다. sqlite3rbu_step ()은 진공 작업이 완료된 경우 SQLITE_DONE, 진공 작업이 완료되지 않았지만 오류가 발생하지 않은 경우 SQLITE_OK, 오류가 발생한 경우 SQLite 오류 코드를 리턴합니다. 오류가 발생하면 sqlite3rbu_step ()에 대한 모든 후속 호출은 즉시 동일한 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="945385f146c601eb7773bb4497e85e560cda1868" translate="yes" xml:space="preserve">
          <source>Each call to xUpdate will fall into one of cases shown below. Not that references to &lt;b&gt;argv[i]&lt;/b&gt; mean the SQL value held within the argv[i] object, not the argv[i] object itself.</source>
          <target state="translated">xUpdate에 대한 각 호출은 아래 표시된 경우 중 하나에 해당합니다. &lt;b&gt;argv [i]에&lt;/b&gt; 대한 참조가 argv [i] 오브젝트 자체가 아니라 argv [i] 오브젝트 내에 보유 된 SQL 값을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc164ad4bbc60e4e26ece4689029d1fc885eb00a" translate="yes" xml:space="preserve">
          <source>Each change recorded by a session object is marked as either direct or indirect. A change is marked as indirect if either:</source>
          <target state="translated">세션 개체에 의해 기록 된 각 변경 사항은 직접 또는 간접으로 표시됩니다. 다음 중 하나에 해당하면 변경이 간접적 인 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="23f47a6b73c8dc551b62d8a4d686a08cd0fe7e37" translate="yes" xml:space="preserve">
          <source>Each column in an SQLite 3 database is assigned one of the following type affinities:</source>
          <target state="translated">SQLite 3 데이터베이스의 각 열에는 다음 유형 선호도 중 하나가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="b225a6098d76a95e7290e27ffd041b5076929def" translate="yes" xml:space="preserve">
          <source>Each column name or expression can be followed by one of the &quot;ASC&quot; or &quot;DESC&quot; keywords to indicate sort order. The sort order may or may not be ignored depending on the database file format, and in particular the &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt;. The &quot;legacy&quot; schema format (1) ignores index sort order. The descending index schema format (4) takes index sort order into account. Only versions of SQLite 3.3.0 (2006-01-11) and later are able to understand the descending index format. For compatibility, version of SQLite between 3.3.0 and 3.7.9 use the legacy schema format by default. The newer schema format is used by default in version 3.7.10 (2012-01-16) and later. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to change set the specific behavior for any version of SQLite.</source>
          <target state="translated">각 열 이름 또는 표현식 뒤에는 &quot;ASC&quot;또는 &quot;DESC&quot;키워드 중 하나가 정렬 순서를 나타냅니다. 정렬 순서는 데이터베이스 파일 형식, 특히 &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식 번호에&lt;/a&gt; 따라 무시되거나 무시되지 않을 수 있습니다 . &quot;레거시&quot;스키마 형식 (1)은 인덱스 정렬 순서를 무시합니다. 내림차순 색인 스키마 형식 (4)은 색인 정렬 순서를 고려합니다. SQLite 3.3.0 (2006-01-11) 이상의 버전 만 내림차순 인덱스 형식을 이해할 수 있습니다. 호환성을 위해 3.3.0과 3.7.9 사이의 SQLite 버전은 기본적으로 레거시 스키마 형식을 사용합니다. 최신 스키마 형식은 기본적으로 버전 3.7.10 (2012-01-16) 이상에서 사용됩니다. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그는&lt;/a&gt; SQLite는 모든 버전에 대한 특정 동작을 설정 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49f9ccaac189604c31d61c6229cff4580f28bbe6" translate="yes" xml:space="preserve">
          <source>Each component query of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; (UNION, UNION ALL, EXCEPT or INTERSECT) is assigned computed separately and is given its own line in the EXPLAIN QUERY PLAN output.</source>
          <target state="translated">&lt;a href=&quot;lang_select#compound&quot;&gt;복합 조회&lt;/a&gt; (UNION, UNION ALL, EXCEPT 또는 INTERSECT) 의 각 구성 요소 조회는 별도로 계산되어 할당되며 EXPLAIN QUERY PLAN 출력에 고유 한 행이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a75cebae36bdcbe0495a4d634fceea0a434ea48a" translate="yes" xml:space="preserve">
          <source>Each condition in a decision is shown to independently affect the outcome of the decision.</source>
          <target state="translated">결정의 각 조건은 결정의 결과에 독립적으로 영향을 미치는 것으로 나타납니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
