<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0e6d35373bda34d7225b9f57bccbcc2d79c79acc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jset&quot;&gt;json_set&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;#jset&quot;&gt;json_set&lt;/a&gt;(</target>
        </trans-unit>
        <trans-unit id="97f25c95e83e6d305d9bb2696177ff2aa91f941d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jtree&quot;&gt;json_tree&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;#jtree&quot;&gt;json_tree&lt;/a&gt;(</target>
        </trans-unit>
        <trans-unit id="dd6865df97694d5d5ef8ad02b58ddc9d1e991ec8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jtype&quot;&gt;json_type&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;#jtype&quot;&gt;json_type&lt;/a&gt;(</target>
        </trans-unit>
        <trans-unit id="6334a8ace93b23b7800ba8ccb539df52960de15e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jvalid&quot;&gt;json_quote&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;#jvalid&quot;&gt;json_quote&lt;/a&gt;(</target>
        </trans-unit>
        <trans-unit id="5a37f23bc9c8562c6637f44c1a08c645ec7a673b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jvalid&quot;&gt;json_valid&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;#jvalid&quot;&gt;json_valid&lt;/a&gt;(</target>
        </trans-unit>
        <trans-unit id="6f55b054f8c809c18b7b0bd3b004c097ae926bcd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#section_3_0&quot;&gt;Section 3.0&lt;/a&gt; above provides an overview of how atomic commit works in SQLite. But it glosses over a number of important details. The following subsections will attempt to fill in the gaps.</source>
          <target state="translated">&lt;a href=&quot;#section_3_0&quot;&gt;&lt;/a&gt;위의 3.0 절 은 SQLite에서 원자 커밋이 어떻게 작동하는지에 대한 개요를 제공합니다. 그러나 많은 중요한 세부 사항에 대해 설명합니다. 다음 하위 섹션은 간격을 채우려 고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2e049fd9ed33cce78a407cc4c2fede78bd62b56c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#section_3_12&quot;&gt;Step 3.12&lt;/a&gt; of the commit process shows that once the shared lock has been released, all user-space cache images of database content must be discarded. This is done because without a shared lock, other processes are free to modify the database file content and so any user-space image of that content might become obsolete. Consequently, each new transaction would begin by rereading data which had previously been read. This is not as bad as it sounds at first since the data being read is still likely in the operating systems file cache. So the &quot;read&quot; is really just a copy of data from kernel space into user space. But even so, it still takes time.</source>
          <target state="translated">&lt;a href=&quot;#section_3_12&quot;&gt;&lt;/a&gt;커밋 프로세스의 3.12 단계 에서는 공유 잠금이 해제되면 데이터베이스 컨텐츠의 모든 사용자 공간 캐시 이미지를 버려야합니다. 공유 잠금이 없으면 다른 프로세스가 데이터베이스 파일 컨텐츠를 자유롭게 수정할 수 있으므로 해당 컨텐츠의 사용자 공간 이미지가 더 이상 사용되지 않을 수 있습니다. 결과적으로 각각의 새 트랜잭션은 이전에 읽은 데이터를 다시 읽음으로써 시작됩니다. 읽고있는 데이터가 운영 체제 파일 캐시에있을 가능성이 있기 때문에 처음에 들리는 것만 큼 나쁘지 않습니다. &quot;읽기&quot;는 실제로 커널 공간에서 사용자 공간으로의 데이터 사본입니다. 그러나 그럼에도 불구하고 여전히 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="45dbff6dad481ecef4838db7e7146a272a190a63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec&lt;/a&gt;(db, &quot;&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;&quot;, 0, 0, 0);</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec&lt;/a&gt; (db, &quot; &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; &quot;, 0, 0, 0);</target>
        </trans-unit>
        <trans-unit id="95b7a51dba399b29b6408bce8b46a6ed6ac0ebc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3_rebaser&quot;&gt;sqlite3_rebaser&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_rebaser&quot;&gt;sqlite3_rebaser&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a96d20b2df7b01d08847f841f15ed32f77a17955" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3rebaser_configure&quot;&gt;sqlite3rebaser_configure&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3rebaser_configure&quot;&gt;sqlite3rebaser_configure&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f24ab516509730442e5c8614290d6e4eff41ff5c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3rebaser_create&quot;&gt;sqlite3rebaser_create&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3rebaser_create&quot;&gt;sqlite3rebaser_create&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f976f2c42c7ddcf6b7923ca7e807d7edd8c1f3c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3rebaser_delete&quot;&gt;sqlite3rebaser_delete&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3rebaser_delete&quot;&gt;sqlite3rebaser_delete&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="10fd29c06fc02428f5321d1341fdbbe090b076c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#sqlite3rebaser_rebase&quot;&gt;sqlite3rebaser_rebase&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3rebaser_rebase&quot;&gt;sqlite3rebaser_rebase&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="54d804fb24a12841c5f92a2cb45acb472aa4a3cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#transient_database_used_by_vacuum_&quot;&gt;2.9. Transient Database Used By &lt;/a&gt;&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#transient_database_used_by_vacuum_&quot;&gt;2.9. &lt;/a&gt;&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM에서 &lt;/a&gt;사용하는 임시 데이터베이스</target>
        </trans-unit>
        <trans-unit id="d65733a2b251f5d1e8663817c698ea704cc29dcf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../foreignkeys&quot;&gt;Foreign key constraints&lt;/a&gt; are enabled, column zColumn is part of a &lt;a href=&quot;../foreignkeys#parentchild&quot;&gt;child key&lt;/a&gt; definition and the blob is being opened for read/write access.</source>
          <target state="translated">&lt;a href=&quot;../foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 이 활성화되고 zColumn 열이 &lt;a href=&quot;../foreignkeys#parentchild&quot;&gt;하위 키&lt;/a&gt; 정의의 일부이며 읽기 / 쓰기 액세스를 위해 Blob이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a2809423a21fa6e454df9b109d3adbc789a570" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to BLOB</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;캐스트&lt;/a&gt; 에서 BLOB</target>
        </trans-unit>
        <trans-unit id="9f46763f5b77113131a34236472485d4c1045407" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to INTEGER</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; 정수로</target>
        </trans-unit>
        <trans-unit id="2befe0ef4821f1590e0920e37a88207241f549be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to REAL</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; REAL에</target>
        </trans-unit>
        <trans-unit id="a16877813ab31ebfa38e409b6e71a5bfe4f628db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../quickstart&quot;&gt;SQLite In 5 Minutes Or Less&lt;/a&gt; and/or</source>
          <target state="translated">&lt;a href=&quot;../quickstart&quot;&gt;5 분 이내&lt;/a&gt; 및 / 또는 SQLite</target>
        </trans-unit>
        <trans-unit id="6f10df3323b93c635e9714ed95fce74b7f6b38fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; means that the database engine was unable to acquire the database locks it needs to do its job. If the statement is a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or occurs outside of an explicit transaction, then you can retry the statement. If the statement is not a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; and occurs within an explicit transaction then you should rollback the transaction before continuing.</source>
          <target state="translated">&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 는 데이터베이스 엔진이 작업을 수행하는 데 필요한 데이터베이스 잠금을 확보 할 수 없음을 의미 합니다 . 명령문이 &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 이거나 명시 적 트랜잭션 외부에서 발생하는 경우 명령문을 재 시도 할 수 있습니다. 명령문이 &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 가 아니고 명시 적 트랜잭션 내에서 발생하는 경우 계속하기 전에 트랜잭션을 롤백해야합니다.</target>
        </trans-unit>
        <trans-unit id="83f367b014093970ab24fe49d977ad428f493534" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; means that the statement has finished executing successfully. sqlite3_step() should not be called again on this virtual machine without first calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the virtual machine back to its initial state.</source>
          <target state="translated">&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; 은 명령문이 성공적으로 실행 되었음을 의미합니다. 가상 머신을 초기 상태로 다시 재설정하기 위해 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 먼저 호출하지 않고이 가상 머신에서 sqlite3_step () 을 다시 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="8882865414dc363b41b031eed382f84b5b427c94" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; means that a run-time error (such as a constraint violation) has occurred. sqlite3_step() should not be called again on the VM. More information may be found by calling &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. With the legacy interface, a more specific error code (for example, &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;, &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;, &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;, and so forth) can be obtained by calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. In the &quot;v2&quot; interface, the more specific error code is returned directly by sqlite3_step().</source>
          <target state="translated">&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 는 런타임 오류 (예 : 제한 조건 위반)가 발생 했음을 의미합니다. VM에서 sqlite3_step ()을 다시 호출하면 안됩니다. &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 를 호출하여 자세한 정보를 찾을 수 있습니다 . 레거시 인터페이스를 통해보다 구체적으로 에러 코드 (예를 들어, &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT는&lt;/a&gt; , &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA는&lt;/a&gt; , &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT는&lt;/a&gt; , 등)를 호출하여 얻을 수있다 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 상의 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; . &quot;v2&quot;인터페이스에서보다 구체적인 오류 코드는 sqlite3_step ()에 의해 직접 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="709ddc6c75618da44b4acfcc0ca7f98f4c946b81" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; means that the this routine was called inappropriately. Perhaps it was called on a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has already been &lt;a href=&quot;finalize&quot;&gt;finalized&lt;/a&gt; or on one that had previously returned &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.</source>
          <target state="translated">&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 는이 루틴이 부적절하게 호출 되었음을 의미합니다. 아마이 부름을 받았다 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이미되었습니다 &lt;a href=&quot;finalize&quot;&gt;완료&lt;/a&gt; 또는 이전에 돌아온 하나 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; . 또는 같은 순간에 둘 이상의 스레드에서 동일한 데이터베이스 연결을 사용하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3018dadc8b82565fb830d6970b49f3e99af74d80" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;34to35&quot;&gt;Moving From SQLite 3.4 to 3.5&lt;/a&gt;&amp;rarr; A document describing the differences between SQLite version 3.4.2 and 3.5.0.</source>
          <target state="translated">&lt;a href=&quot;34to35&quot;&gt;SQLite 3.4에서 3.5로 이동&lt;/a&gt; &amp;rarr; SQLite 버전 3.4.2와 3.5.0의 차이점을 설명하는 문서.</target>
        </trans-unit>
        <trans-unit id="fd9b447ec11ca30f84a70012bbc4053ea17ad7d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;35to36&quot;&gt;Moving From SQLite 3.5 to 3.6&lt;/a&gt;&amp;rarr; A document describing the differences between SQLite version 3.5.9 and 3.6.0.</source>
          <target state="translated">&lt;a href=&quot;35to36&quot;&gt;SQLite 3.5에서 3.6으로 이동&lt;/a&gt; &amp;rarr; SQLite 버전 3.5.9와 3.6.0의 차이점을 설명하는 문서.</target>
        </trans-unit>
        <trans-unit id="77d896200630fe45db69d2fac7ac2222ee753416" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;appfileformat&quot;&gt;SQLite As An Application File Format&lt;/a&gt;&amp;rarr; This article advocates using SQLite as an application file format in place of XML or JSON or a &quot;pile-of-file&quot;.</source>
          <target state="translated">&lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로 SQLite&lt;/a&gt; &amp;rarr;이 기사에서는 SQLite를 XML 또는 JSON 대신 &quot;파일 파일&quot;대신 응용 프로그램 파일 형식으로 사용하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="3f5d872526b0dc325a0db25b861c4f5e18483646" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;arch&quot;&gt;Architecture&lt;/a&gt;&amp;rarr; An architectural overview of the SQLite library, useful for those who want to hack the code.</source>
          <target state="translated">&lt;a href=&quot;arch&quot;&gt;아키텍처&lt;/a&gt; &amp;rarr; 코드를 해킹하려는 사람들에게 유용한 SQLite 라이브러리의 아키텍처 개요.</target>
        </trans-unit>
        <trans-unit id="f162d3ea2bff4cb3b017567e6514db09653516cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;asyncvfs&quot;&gt;Asynchronous IO Mode&lt;/a&gt;&amp;rarr; This page describes the asynchronous IO extension developed alongside SQLite. Using asynchronous IO can cause SQLite to appear more responsive by delegating database writes to a background thread.</source>
          <target state="translated">&lt;a href=&quot;asyncvfs&quot;&gt;비동기 IO 모드&lt;/a&gt; &amp;rarr;이 페이지는 SQLite와 함께 개발 된 비동기 IO 확장을 설명합니다. 비동기 IO를 사용하면 데이터베이스 쓰기를 백그라운드 스레드에 위임하여 SQLite의 응답 성이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d2e08f6e869d993ae3e09766c8ef60766b0099" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomiccommit&quot;&gt;How SQLite Implements Atomic Commit&lt;/a&gt;&amp;rarr; A description of the logic within SQLite that implements transactions with atomic commit, even in the face of power failures.</source>
          <target state="translated">&lt;a href=&quot;atomiccommit&quot;&gt;SQLite가 원자 커밋을 구현하는 방법&lt;/a&gt; &amp;rarr; 정전에도 불구하고 원자 커밋으로 트랜잭션을 구현하는 SQLite 내 논리에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="ec84bf98845a9d49326bb7e3559e15093eff12ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;autoinc&quot;&gt;Autoincrement&lt;/a&gt;&amp;rarr; A description of the AUTOINCREMENT keyword in SQLite, what it does, why it is sometimes useful, and why it should be avoided if not strictly necessary.</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;Autoincrement&lt;/a&gt; &amp;rarr; SQLite의 AUTOINCREMENT 키워드에 대한 설명, 그것이하는 일, 때로는 유용한 이유 및 엄격하게 필요하지 않은 경우 피해야하는 이유.</target>
        </trans-unit>
        <trans-unit id="bba92e3d0a5514c8b10d0681e88c22b4571cf8f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;backup&quot;&gt;Backup API&lt;/a&gt;&amp;rarr; The [sqlite3_backup_init | online-backup interface] can be used to copy content from a disk file into an in-memory database or vice versa and it can make a hot backup of a live database. This application note gives examples of how.</source>
          <target state="translated">&lt;a href=&quot;backup&quot;&gt;백업 API&lt;/a&gt; &amp;rarr; [sqlite3_backup_init | 온라인 백업 인터페이스]를 사용하여 디스크 파일의 내용을 메모리 내 데이터베이스로 복사하거나 그 반대로 복사하여 라이브 데이터베이스의 핫 백업을 수행 할 수 있습니다. 이 애플리케이션 노트는 방법의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c281a8f5f9eb5969b5b7b187a98e8b1b4b6f660a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="7ee52086e5b22a4588206f36529e0c4c15e16172" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ API Reference&lt;/a&gt;&amp;rarr; This document describes each API function separately.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++ API 참조&lt;/a&gt; &amp;rarr;이 문서는 각 API 기능을 개별적으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e76c06031fb4781d59ce5986e61251b6ae81efe1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; &amp;rarr; Store the formatted string in memory obtained &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; &amp;rarr; 포맷 된 문자열을 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="2f5deac6c1d5081c814c9cce5144f06486562d96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; &amp;rarr; Store the formatted string in a static buffer</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; &amp;rarr; 포맷 된 문자열을 정적 버퍼에 저장</target>
        </trans-unit>
        <trans-unit id="9863663364fb2dd4dc525bcea1b6ecc25f9b3ee2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf()&lt;/a&gt; &amp;rarr; Varargs version of sqlite3_mprintf()</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf ()&lt;/a&gt; &amp;rarr; sqlite3_mprintf ()의 Varargs 버전</target>
        </trans-unit>
        <trans-unit id="0561c61db3d675ff625600e7395b191e0133666e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vsnprintf()&lt;/a&gt; &amp;rarr; Varargs version of sqlite3_snprintf()</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vsnprintf ()&lt;/a&gt; &amp;rarr; sqar3_snprintf ()의 Varargs 버전</target>
        </trans-unit>
        <trans-unit id="69aa0af0e77217e35ec38647be1eb70e764e4d7c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="0d0cb59fc90782c4cd135a6d1a6f5f0dbded063e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; (destructor)</source>
          <target state="translated">&lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; (소멸자)</target>
        </trans-unit>
        <trans-unit id="8819c94e569ea6784509b57120e8e8467233972e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; (constructor)</source>
          <target state="translated">&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; (생성자)</target>
        </trans-unit>
        <trans-unit id="8a5bbc15d08ec1956a2409932ddada2724323a3d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of crashing when called with a NULL parameter.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 은 NULL 매개 변수로 호출 될 때 충돌하는 대신 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b1468573ddbe13b4beaac967df1b06833ee16e45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt; &amp;rarr; Append formatted text to a dynamic string</source>
          <target state="translated">&lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; &amp;rarr; 동적 문자열에 형식화 된 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="2643aae52f03517685961c3d6ce6bcf2a4a2657d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_vappendf()&lt;/a&gt; &amp;rarr; Varargs version of sqlite3_str_appendf()</source>
          <target state="translated">&lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_vappendf ()&lt;/a&gt; &amp;rarr; sqar3_str_appendf ()의 Varargs 버전</target>
        </trans-unit>
        <trans-unit id="4bc45c8277e4267460c47213db7db851679f7cc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="665616501b9c146b0c97ea52614dcf0455b8f9ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c3ref/vfs&quot;&gt;VFSes&lt;/a&gt; that do not support shared memory are allowed to access &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; databases if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;VFSes&lt;/a&gt; 공유 메모리를 지원하지 않는 액세스가 허용되는 &lt;a href=&quot;wal&quot;&gt;WAL의&lt;/a&gt; 경우 데이터베이스 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA의 locking_mode가&lt;/a&gt; EXCLUSIVE로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d20926ea6f725972723d987c5b3c074b89535d63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="97993ea487384a52a41e5ff9f40bc38d2edd1537" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="bbf0225cd498500c9bc29df8706ae83eae2199cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="75489bc3940f60f3f1ca9466097577b46fb49230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7481a04ecced1eac7a8e489365c50362f95599f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="49c21989e2c5837557742e8dc84068f95c4f1dae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_interface&quot;&gt;Version 2 C/C++ API&lt;/a&gt;&amp;rarr; A description of the C/C++ interface bindings for SQLite through version 2.8</source>
          <target state="translated">&lt;a href=&quot;c_interface&quot;&gt;버전 2 C / C ++ API&lt;/a&gt; &amp;rarr; 버전 2.8을 통한 SQLite의 C / C ++ 인터페이스 바인딩에 대한 설명</target>
        </trans-unit>
        <trans-unit id="a0c1e6ae46304fe04de11ceea1eb6f60276464cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bf160b7b1c6e250919c6c78fb2901dd1fdd6b641" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="e7e6b918c699c0613314f6e9fedcf024f8ab5d06" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="d0ada1402089436ea13b928659e6cf7b129a5e8f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="13a762f23af7798efadf4de5466a76fb3466040e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="00bd8d8ec9d7c42958d0e4d5658403c4aa56d6b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80279c7383fea85ec7e54824b373d75277a44c6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;capi3&quot;&gt;Version 3 C/C++ API&lt;/a&gt;&amp;rarr; A summary of the API related changes between SQLite version 2.8 and SQLite version 3.0.</source>
          <target state="translated">&lt;a href=&quot;capi3&quot;&gt;버전 3 C / C ++ API&lt;/a&gt; &amp;rarr; SQLite 버전 2.8과 SQLite 버전 3.0 간의 API 관련 변경 사항 요약.</target>
        </trans-unit>
        <trans-unit id="afcf65070e3ae8420fac8ed55eff277974ca0538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;carray&quot;&gt;Carray&lt;/a&gt;&amp;rarr; CARRAY is a [table-valued function] that allows C-language arrays to be used in SQL queries.</source>
          <target state="translated">&lt;a href=&quot;carray&quot;&gt;Carray&lt;/a&gt; &amp;rarr; CARRAY는 C- 언어 배열을 SQL 쿼리에 사용할 수있는 [테이블 값 함수]입니다.</target>
        </trans-unit>
        <trans-unit id="f1be08c8f50862ca74fc28c9f25041007b291486" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;carray&quot;&gt;carray(PTR,N)&lt;/a&gt; &amp;rarr; requires &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; to set the PTR parameter.</source>
          <target state="translated">&lt;a href=&quot;carray&quot;&gt;carray (PTR, N)&lt;/a&gt; &amp;rarr; PTR 매개 변수를 설정 하려면 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d27605eceea4fb5464c61e8e4c261e6511d1b7e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;changes&quot;&gt;Release History&lt;/a&gt;&amp;rarr; A chronology of SQLite releases going back to version 1.0.0</source>
          <target state="translated">&lt;a href=&quot;changes&quot;&gt;릴리스 기록&lt;/a&gt; &amp;rarr; 버전 1.0.0으로 돌아가는 SQLite 릴리스의 연대기</target>
        </trans-unit>
        <trans-unit id="d31ca0e6cc65099033f4021d251a64d78fc2185c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cintro&quot;&gt;Introduction to the C/C++ API &lt;/a&gt;&amp;rarr; This document introduces the C/C++ API. Users should read this document before the C/C++ API Reference Guide linked below.</source>
          <target state="translated">&lt;a href=&quot;cintro&quot;&gt;C / C ++ API&lt;/a&gt; 소개 &amp;rarr;이 문서는 C / C ++ API를 소개합니다. 사용자는 아래 링크 된 C / C ++ API 참조 안내서 전에이 문서를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="467c4136091ea19ad0648f170e844dc7d1542157" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cli&quot;&gt;Command-Line Shell (sqlite3.exe)&lt;/a&gt;&amp;rarr; Notes on using the &quot;sqlite3.exe&quot; command-line interface that can be used to create, modify, and query arbitrary SQLite database files.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸 (sqlite3.exe)&lt;/a&gt; &amp;rarr; 임의의 SQLite 데이터베이스 파일을 생성, 수정 및 쿼리하는 데 사용할 수있는 &quot;sqlite3.exe&quot;명령 줄 인터페이스 사용에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4abeca1648497ad14401ab3d8f4ffee24b529866" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;compile&quot;&gt;Compilation Options&lt;/a&gt;&amp;rarr; This document describes the compile time options that may be set to modify the default behavior of the library or omit optional features in order to reduce binary size.</source>
          <target state="translated">&lt;a href=&quot;compile&quot;&gt;컴파일 옵션&lt;/a&gt; &amp;rarr;이 문서에서는 바이너리 크기를 줄이기 위해 라이브러리의 기본 동작을 수정하거나 선택적 기능을 생략하도록 설정할 수있는 컴파일 시간 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c34e0e93a1b8c06471f58ba2f9e8cc98b7cd7115" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=0&lt;/a&gt; is now a &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = 0&lt;/a&gt; 은 이제 &lt;a href=&quot;compile#rcmd&quot;&gt;권장 컴파일 시간 옵션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f13757ce949ccf02d85b3bea11c70094d76d776" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;constlist&quot;&gt;&lt;b&gt;List Of Constants.&lt;/b&gt;&lt;/a&gt; This is a list of numeric constants used by SQLite and represented by #defines in the sqlite3.h header file. These constants are things such as numeric &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; from various interfaces (ex: &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;) or flags passed into functions to control behavior (ex: &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;constlist&quot;&gt;&lt;b&gt;상수 목록. &lt;/b&gt;&lt;/a&gt;이것은 SQLite에서 사용하고 sqlite3.h 헤더 파일에서 #defines로 표시되는 숫자 상수 목록입니다. 이러한 상수는다양한 인터페이스의숫자&lt;a href=&quot;../rescode&quot;&gt; 결과 코드&lt;/a&gt; (예 :&lt;a href=&quot;../rescode#ok&quot;&gt; SQLITE_OK&lt;/a&gt; ) 또는 동작을 제어하기 위해 함수에 전달되는 플래그 (예 :&lt;a href=&quot;c_open_autoproxy&quot;&gt; SQLITE_OPEN_READONLY&lt;/a&gt; )와 같은 것입니다.</target>
        </trans-unit>
        <trans-unit id="46d15a8dfa78a1f10bf9885ff882b0894463cbe4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;csv&quot;&gt;Csv Virtual Table&lt;/a&gt;&amp;rarr; The CSV virtual table allows SQLite to directly read and query [https://www.ietf.org/rfc/rfc4180.txt|RFC 4180] formatted files.</source>
          <target state="translated">&lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블&lt;/a&gt; &amp;rarr; CSV 가상 테이블을 사용하면 SQLite가 [https://www.ietf.org/rfc/rfc4180.txt|RFC 4180] 형식의 파일을 직접 읽고 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f453724bedab57cdefc6d50fa5571cf19469e17f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;custombuild&quot;&gt;Customizing And Porting SQLite&lt;/a&gt;&amp;rarr; This document explains how to customize the build of SQLite and how to port SQLite to new platforms.</source>
          <target state="translated">&lt;a href=&quot;custombuild&quot;&gt;SQLite 사용자 정의 및 이식&lt;/a&gt; &amp;rarr;이 문서는 SQLite 빌드를 사용자 정의하는 방법과 SQLite를 새 플랫폼으로 이식 하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3e408de6fc918ad4e050853acdfbc830aedfefeb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;datatype3&quot;&gt;DataTypes&lt;/a&gt;&amp;rarr; SQLite version 3 introduces the concept of manifest typing, where the type of a value is associated with the value itself, not the column that it is stored in. This page describes data typing for SQLite version 3 in further detail.</source>
          <target state="translated">&lt;a href=&quot;datatype3&quot;&gt;DataTypes&lt;/a&gt; &amp;rarr; SQLite 버전 3에는 매니페스트 입력 개념이 도입되었습니다. 여기서 값의 유형은 값이 저장된 열이 아니라 값 자체와 연결됩니다.이 페이지에서는 SQLite 버전 3의 데이터 입력에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5ec882ce38f6be187a7717e75678454e46030414" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;datatypes&quot;&gt;Version 2 DataTypes &lt;/a&gt;&amp;rarr; A description of how SQLite version 2 handles SQL datatypes. Short summary: Everything is a string.</source>
          <target state="translated">&lt;a href=&quot;datatypes&quot;&gt;버전 2 데이터 유형&lt;/a&gt; &amp;rarr; SQLite 버전 2가 SQL 데이터 유형을 처리하는 방법에 대한 설명. 짧은 요약 : 모든 것이 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7bc330df5fd8ab98823bcb18dc9d1020c48dd158" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;dbhash&quot;&gt;Database Hash (dbhash.exe)&lt;/a&gt;&amp;rarr; This program demonstrates how to compute a hash over the content of an SQLite database.</source>
          <target state="translated">&lt;a href=&quot;dbhash&quot;&gt;데이터베이스 해시 (dbhash.exe)&lt;/a&gt; &amp;rarr;이 프로그램은 SQLite 데이터베이스의 콘텐츠에 대한 해시를 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="17d9246fdbc7174a0190cb84390b3c7af5c620f1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;dbstat&quot;&gt;Dbstat Virtual Table&lt;/a&gt;&amp;rarr; The DBSTAT virtual table reports on the sizes and geometries of tables storing content in an SQLite database, and is the basis for the [sqlite3_analyzer] utility program.</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;Dbstat 가상 테이블&lt;/a&gt; &amp;rarr; DBSTAT 가상 테이블은 SQLite 데이터베이스에 컨텐츠를 저장하는 테이블의 크기 및 구조를보고하며 [sqlite3_analyzer] 유틸리티 프로그램의 기초입니다.</target>
        </trans-unit>
        <trans-unit id="7e86c1d52cac25e0d8103ad6fb957255259c3892" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;debugging&quot;&gt;Debugging Hints&lt;/a&gt;&amp;rarr; A list of tricks and techniques used to trace, examine, and understand the operation of the core SQLite library.</source>
          <target state="translated">&lt;a href=&quot;debugging&quot;&gt;디버깅 힌트&lt;/a&gt; &amp;rarr; 핵심 SQLite 라이브러리의 작동을 추적, 검사 및 이해하는 데 사용되는 트릭 및 기술 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b5a0baf5c39b4205bbc8e6f7f067d05cb3cb01fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;different&quot;&gt;Distinctive Features&lt;/a&gt;&amp;rarr; This document enumerates and describes some of the features of SQLite that make it different from other SQL database engines.</source>
          <target state="translated">&lt;a href=&quot;different&quot;&gt;고유 한 기능&lt;/a&gt; &amp;rarr;이 문서는 다른 SQL 데이터베이스 엔진과 다른 SQLite의 일부 기능을 열거하고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ca3ea47499748d3c4c0fb2a7333ec8dbe4f4efca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;errlog&quot;&gt;Error and Warning Log&lt;/a&gt;&amp;rarr; SQLite supports an &quot;error and warning log&quot; design to capture information about suspicious and/or error events during operation. Embedded applications are encouraged to enable the error and warning log to help with debugging application problems that arise in the field. This document explains how to do that.</source>
          <target state="translated">&lt;a href=&quot;errlog&quot;&gt;오류 및 경고 로그&lt;/a&gt; &amp;rarr; SQLite는 &quot;오류 및 경고 로그&quot;디자인을 지원하여 작동 중 의심스러운 및 / 또는 오류 이벤트에 대한 정보를 캡처합니다. 임베디드 응용 프로그램은 오류 및 경고 로그를 활성화하여 현장에서 발생하는 응용 프로그램 문제를 디버깅하는 데 도움이됩니다. 이 문서는이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d84e1d9d81086fbb9bc8e9812a2ddcbfc57c3c61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;exec&quot;&gt;sqlite3_exec&lt;/a&gt;(db, &quot;&lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;&quot;, 0, 0, 0);</source>
          <target state="translated">&lt;a href=&quot;exec&quot;&gt;sqlite3_exec&lt;/a&gt; (db, &quot; &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; &quot;, 0, 0, 0);</target>
        </trans-unit>
        <trans-unit id="cc90474dbc04f8f09341681e7a8f00acd46699b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt;&amp;rarr; Notes on how to create indexes on expressions instead of just individual columns.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식&lt;/a&gt; 에 대한 색인 &amp;rarr; 개별 열 대신 표현식에 대한 색인을 작성하는 방법에 대한 참고 사항.</target>
        </trans-unit>
        <trans-unit id="075ac5d4d2d7fea94e761fa62f411d3079b36722" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;faq&quot;&gt;Frequently Asked Questions&lt;/a&gt;&amp;rarr; The title of the document says all...</source>
          <target state="translated">&lt;a href=&quot;faq&quot;&gt;자주 묻는 질문 (FAQ)&lt;/a&gt; &amp;rarr;이 문서의 제목은 모두 ...</target>
        </trans-unit>
        <trans-unit id="91de52785973c7095f80dc478f773650b18ff146" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt;&amp;rarr; This article points out that reading blobs out of an SQLite database is often faster than reading the same blobs from individual files in the filesystem.</source>
          <target state="translated">&lt;a href=&quot;fasterthanfs&quot;&gt;파일 시스템보다 35 % 빠름&lt;/a&gt; &amp;rarr;이 기사에서는 SQLite 데이터베이스에서 블롭을 읽는 것이 파일 시스템의 개별 파일에서 동일한 블롭을 읽는 것보다 빠르다는 것을 지적합니다.</target>
        </trans-unit>
        <trans-unit id="e450dc5e006a3a642d026d6d1e7faf01454e8137" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fileformat2&quot;&gt;SQLite File Format&lt;/a&gt;&amp;rarr; A description of the format used for SQLite database and journal files, and other details required to create software to read and write SQLite databases without using SQLite.</source>
          <target state="translated">&lt;a href=&quot;fileformat2&quot;&gt;SQLite 파일 형식&lt;/a&gt; &amp;rarr; SQLite 데이터베이스 및 저널 파일에 사용되는 형식에 대한 설명 및 SQLite를 사용하지 않고 SQLite 데이터베이스를 읽고 쓰는 소프트웨어를 작성하는 데 필요한 기타 세부 사항.</target>
        </trans-unit>
        <trans-unit id="a733ef2cc4c56a7b8f6b692dad20f9d93a57b13b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;foreignkeys&quot;&gt;Foreign Key Support&lt;/a&gt;&amp;rarr; This document describes the support for foreign key constraints introduced in version 3.6.19.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 지원&lt;/a&gt; &amp;rarr;이 문서는 버전 3.6.19에서 도입 된 외래 키 제약 조건에 대한 지원을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="07778829782b505c9142ac3bc00c208ffe3c959f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;foreignkeys&quot;&gt;Foreign key constraints&lt;/a&gt; are enabled, column zColumn is part of a &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;child key&lt;/a&gt; definition and the blob is being opened for read/write access.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 이 활성화되고 zColumn 열이 &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;하위 키&lt;/a&gt; 정의의 일부이며 읽기 / 쓰기 액세스를 위해 Blob이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="257da37e09dc717710d6cdabd276ea0266dc5117" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;Parent Table&lt;/a&gt; references are updated</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;부모 테이블&lt;/a&gt; 참조가 업데이트되었습니다</target>
        </trans-unit>
        <trans-unit id="e44847a1295686347ed001f74e42affb0705cbf2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;formatchng&quot;&gt;Backwards Compatibility&lt;/a&gt;&amp;rarr; This document details all of the incompatible changes to the SQLite file format that have occurred since version 1.0.0.</source>
          <target state="translated">&lt;a href=&quot;formatchng&quot;&gt;이전 버전과의 호환성&lt;/a&gt; &amp;rarr;이 문서는 버전 1.0.0 이후 발생한 SQLite 파일 형식에 대한 모든 호환되지 않는 변경 사항에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e490a0ec2dd974b2dd94f951db72a83ca44cfe68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts3&quot;&gt;FTS3 - Full Text Search&lt;/a&gt;&amp;rarr; A description of the SQLite Full Text Search (FTS3) extension.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3-전체 텍스트 검색&lt;/a&gt; &amp;rarr; SQLite 전체 텍스트 검색 (FTS3) 확장에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="392cec013a8d65dffa4260fc636640a165d11b28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts3#_contentless_fts4_tables_&quot;&gt;Contentless FTS4 tables&lt;/a&gt; are handled similarly, except that any attempt to update or delete rows will cause an error when applying the update.</source>
          <target state="translated">&lt;a href=&quot;fts3#_contentless_fts4_tables_&quot;&gt;&lt;/a&gt;행을 업데이트하거나 삭제하려고하면 업데이트를 적용 할 때 오류가 발생한다는 점을 제외하고는 내용이 없는 FTS4 테이블 도 비슷하게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="93758b1224795e01173dfa8f03df7fc9562689d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts3#_external_content_fts4_tables_&quot;&gt;External content FTS4 tables&lt;/a&gt; may also be updated using RBU. In this case the user is required to configure the RBU database so that the same set of UPDATE, DELETE and INSERT operations are applied to the FTS4 index as to the underlying content table. As for all updates of external content FTS4 tables, the user is also required to ensure that any UPDATE or DELETE operations are applied to the FTS4 index before they are applied to the underlying content table (refer to FTS4 documentation for a detailed explanation). In RBU, this is done by ensuring that the name of the data_% table used to write to the FTS4 table sorts before the name of the data_% table used to update the underlying content table using the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence. In order to avoid duplicating data within the RBU database, an SQL view may be used in place of one of the data_% tables. For example, for the target database schema:</source>
          <target state="translated">&lt;a href=&quot;fts3#_external_content_fts4_tables_&quot;&gt;&lt;/a&gt;RBU를 사용하여 외부 콘텐츠 FTS4 테이블을 업데이트 할 수도 있습니다. 이 경우 기본 컨텐츠 테이블과 동일한 UPDATE, DELETE 및 INSERT 조작 세트가 FTS4 인덱스에 적용되도록 RBU 데이터베이스를 구성해야합니다. 외부 컨텐츠 FTS4 테이블의 모든 갱신에 대해, 사용자는 UPDATE 또는 DELETE 조작이 기본 컨텐츠 테이블에 적용되기 전에 FTS4 인덱스에 적용되는지 확인해야합니다 (자세한 설명은 FTS4 문서를 참조하십시오). RBU에서 이는 FTS4 테이블에 쓰는 데 사용 된 data_ % 테이블의 이름이 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY를&lt;/a&gt; 사용하여 기본 컨텐츠 테이블을 업데이트하는 데 사용되는 data_ % 테이블의 이름보다 먼저 정렬되도록함으로써 수행됩니다.조합 순서. RBU 데이터베이스 내에서 데이터가 중복되는 것을 방지하기 위해 data_ % 테이블 중 하나 대신 SQL 뷰를 사용할 수 있습니다. 예를 들어, 대상 데이터베이스 스키마의 경우 :</target>
        </trans-unit>
        <trans-unit id="64a3c180a9e199b42f0200d55916814840ea619a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; queries are better able to make use of docidAdded the hidden &lt;a href=&quot;fts3#f4alid&quot;&gt;fts4aux languageid column&lt;/a&gt; to the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; virtual table.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 쿼리는 docid 를보다 잘 활용할 수 있습니다. 숨겨진 &lt;a href=&quot;fts3#f4alid&quot;&gt;fts4aux languageid 열&lt;/a&gt; 을 &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; 가상 테이블에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="4de6777c19d8adbc6ef6ba676a94d03073722e64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts5&quot;&gt;FTS5 - Full Text Search&lt;/a&gt;&amp;rarr; A description of the SQLite Full Text Search (FTS5) extension.</source>
          <target state="translated">&lt;a href=&quot;fts5&quot;&gt;FTS5-전체 텍스트 검색&lt;/a&gt; &amp;rarr; SQLite 전체 텍스트 검색 (FTS5) 확장에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="d7c4e4d9b00680d5a216e98fc5a3192ddc1c8a3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fts5#extending_fts5&quot;&gt;Extending FTS5&lt;/a&gt; &amp;rarr; requires &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; to find the fts5_api pointer.</source>
          <target state="translated">&lt;a href=&quot;fts5#extending_fts5&quot;&gt;FTS5를 확장&lt;/a&gt; &amp;rarr; fts5_api 포인터를 찾으 려면 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="45098f533d48b8824c7850300020c2f27db72d69" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fullsql&quot;&gt;Full-featured SQL&lt;/a&gt; implementation with advanced capabilities like &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. (&lt;a href=&quot;omitted&quot;&gt;Omitted features&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;fullsql&quot;&gt;&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; , &lt;a href=&quot;json1&quot;&gt;JSON&lt;/a&gt; , &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 및 &lt;a href=&quot;windowfunctions&quot;&gt;창 함수&lt;/a&gt; 와 같은 고급 기능을 갖춘 모든 기능을 갖춘 SQL 구현 . ( &lt;a href=&quot;omitted&quot;&gt;생략 된 기능&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b2b798b5808f775ada356aa071a5e2b1d8eb3df8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;funclist&quot;&gt;&lt;b&gt;List Of Functions.&lt;/b&gt;&lt;/a&gt; This is a list of all functions and methods operating on the &lt;a href=&quot;objlist&quot;&gt;objects&lt;/a&gt; and using and/or returning &lt;a href=&quot;constlist&quot;&gt;constants&lt;/a&gt;. There are many functions, but most applications only use a handful.</source>
          <target state="translated">&lt;a href=&quot;funclist&quot;&gt;&lt;b&gt;기능 목록. &lt;/b&gt;&lt;/a&gt;이것은&lt;a href=&quot;objlist&quot;&gt; 객체에서&lt;/a&gt; 작동하고&lt;a href=&quot;constlist&quot;&gt; 상수를&lt;/a&gt; 사용 및 / 또는 반환하는 모든 함수와 메소드의 목록입니다. 많은 기능이 있지만 대부분의 응용 프로그램은 소수만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7e44bd3d316a266b0e5c8a1d620001fd65afe0c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt;&amp;rarr; Instructions and hints for compiling SQLite C code and integrating that code with your own application.</source>
          <target state="translated">&lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일하는 방법&lt;/a&gt; &amp;rarr; SQLite C 코드를 컴파일하고 해당 코드를 자신의 응용 프로그램과 통합하기위한 지침 및 힌트</target>
        </trans-unit>
        <trans-unit id="0e80fbb27ab302ec44b4dc49687fe7d9c8c0d945" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;howtocorrupt&quot;&gt;How Database Corruption Can Occur&lt;/a&gt;&amp;rarr; SQLite is highly resistant to database corruption. But application, OS, and hardware bugs can still result in corrupt database files. This article describes many of the ways that SQLite database files can go corrupt.</source>
          <target state="translated">&lt;a href=&quot;howtocorrupt&quot;&gt;데이터베이스 손상이 발생할 수있는 방법&lt;/a&gt; &amp;rarr; SQLite는 데이터베이스 손상에 매우 강합니다. 그러나 응용 프로그램, OS 및 하드웨어 버그로 인해 데이터베이스 파일이 손상 될 수 있습니다. 이 문서에서는 SQLite 데이터베이스 파일이 손상 될 수있는 여러 가지 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2cd7a0cb2bda2ec80cd52b0164d2dfa93fa9d483" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Fuzz_testing&quot;&gt;Fuzz testing&lt;/a&gt; seeks to establish that SQLite responds correctly to invalid, out-of-range, or malformed inputs.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Fuzz_testing&quot;&gt;퍼지 테스트&lt;/a&gt; 는 SQLite가 유효하지 않거나 범위를 벗어 났거나 형식이 잘못된 입력에 올바르게 응답하는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bc6b19df084503f7d0af990b1e4c146fc5f41494" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://git.savannah.gnu.org/cgit/readline.git?h=devel&quot;&gt;readline&lt;/a&gt; or &lt;a href=&quot;http://thrysoee.dk/editline/&quot;&gt;editline&lt;/a&gt; or &lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt; for command-line editing.</source>
          <target state="translated">&lt;a href=&quot;http://git.savannah.gnu.org/cgit/readline.git?h=devel&quot;&gt;&lt;/a&gt;명령 줄 편집을위한 readline 또는 &lt;a href=&quot;http://thrysoee.dk/editline/&quot;&gt;editline&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="deaecdd5f841f4b1ca2e1c319e3237de7c2dbdbc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://sqlite.org/android/&quot;&gt;SQLite Android Bindings&lt;/a&gt;&amp;rarr; Information on how to deploy your own private copy of SQLite on Android, bypassing the built-in SQLite, but using the same Java interface.</source>
          <target state="translated">&lt;a href=&quot;http://sqlite.org/android/&quot;&gt;SQLite Android 바인딩&lt;/a&gt; &amp;rarr; 내장 SQLite를 무시하고 동일한 Java 인터페이스를 사용하여 Android에 개인 SQLite 사본을 배포하는 방법에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="57a5590601551434867113917dae8533cf482430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://system.data.sqlite.org/&quot;&gt;System.Data.SQLite&lt;/a&gt;&amp;rarr; C#/.NET bindings for SQLite</source>
          <target state="translated">&lt;a href=&quot;http://system.data.sqlite.org/&quot;&gt;System.Data.SQLite&lt;/a&gt; &amp;rarr; SQLite에 대한 C # /. NET 바인딩</target>
        </trans-unit>
        <trans-unit id="238d8ff8be37bef0b0db4fd1ff7553bad7d7843a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://valgrind.org/&quot;&gt;Valgrind&lt;/a&gt; is perhaps the most amazing and useful developer tool in the world. Valgrind is a simulator - it simulates an x86 running a Linux binary. (Ports of Valgrind for platforms other than Linux are in development, but as of this writing, Valgrind only works reliably on Linux, which in the opinion of the SQLite developers means that Linux should be the preferred platform for all software development.) As Valgrind runs a Linux binary, it looks for all kinds of interesting errors such as array overruns, reading from uninitialized memory, stack overflows, memory leaks, and so forth. Valgrind finds problems that can easily slip through all of the other tests run against SQLite. And, when Valgrind does find an error, it can dump the developer directly into a symbolic debugger at the exact point where the error occur, to facilitate a quick fix.</source>
          <target state="translated">&lt;a href=&quot;http://valgrind.org/&quot;&gt;발 그린 드&lt;/a&gt;아마도 세계에서 가장 놀랍고 유용한 개발자 도구 일 것입니다. Valgrind는 시뮬레이터입니다. Linux 바이너리를 실행하는 x86을 시뮬레이션합니다. (리눅스 이외의 플랫폼을위한 Valgrind 포트는 현재 개발 중이지만이 글을 쓰는 시점에서 Valgrind는 Linux에서만 안정적으로 작동합니다. 이는 SQLite 개발자의 견해로는 Linux가 모든 소프트웨어 개발에서 선호되는 플랫폼이어야 함을 의미합니다.) Valgrind로서 Linux 바이너리를 실행하면 배열 오버런, 초기화되지 않은 메모리에서 읽기, 스택 오버플로, 메모리 누수 등과 같은 모든 종류의 흥미로운 오류를 찾습니다. Valgrind는 SQLite에 대해 실행되는 다른 모든 테스트를 쉽게 수행 할 수있는 문제를 찾습니다. 그리고 Valgrind가 오류를 발견하면 오류가 발생한 정확한 지점에서 개발자를 기호 디버거에 직접 덤프하여 빠른 수정을 용이하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a922f96e55a867751834b51640a60b84819b33" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;Cachegrind&lt;/a&gt; is used to measure performance because it gives answers that are repeatable to 7 or more significant digits. In comparison, actual (wall-clock) run times are scarcely repeatable beyond one significant digit.</source>
          <target state="translated">&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;Cachegrind&lt;/a&gt; 는 7 자리 이상의 유효 숫자로 반복 가능한 답변을 제공하므로 성능을 측정하는 데 사용됩니다. 이에 비해 실제 (벽시계) 실행 시간은 한 자리수 이상으로 거의 반복 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b560de16e3927df2a2f7333ca12b889d30b6db48" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf&quot;&gt;Threads are evil&lt;/a&gt;. Avoid them.</source>
          <target state="translated">&lt;a href=&quot;http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf&quot;&gt;실은 악하다&lt;/a&gt; . 피하십시오.</target>
        </trans-unit>
        <trans-unit id="86b6c9e1245e1bc41dc60f6324621f7399c365da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; is a computer program that must be installed on your machine before you use it. Fortunately, installing fossil is very easy. Fossil is a single &quot;*.exe&quot; file that you simply download and run. To uninstall fossil, simply delete the exe file. &lt;a href=&quot;http://www.fossil-scm.org/index.html/doc/tip/www/quickstart.wiki&quot;&gt;Detailed instructions&lt;/a&gt; for installing and getting started with fossil are available on the &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;fossil website&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 은 사용하기 전에 컴퓨터에 설치해야하는 컴퓨터 프로그램입니다. 다행히 화석 설치는 매우 쉽습니다. Fossil은 간단하게 다운로드하여 실행할 수있는 단일 &quot;* .exe&quot;파일입니다. 화석을 제거하려면 간단히 exe 파일을 삭제하십시오. 화석 설치 및 시작에 대한 &lt;a href=&quot;http://www.fossil-scm.org/index.html/doc/tip/www/quickstart.wiki&quot;&gt;자세한 지침&lt;/a&gt; 은 &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;화석 웹 사이트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32bf4db2317bdc439f7211b238c14cd63961c8fb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;&amp;rarr; The Fossil Version Control System is a distributed VCS designed specifically to support SQLite development. Fossil uses SQLite as for storage.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; &amp;rarr; Fossil Version Control System은 SQLite 개발을 지원하도록 특별히 설계된 분산 VCS입니다. 화석은 스토리지로 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="776470815d04fef6faed648c9a62fc552a2c35c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/sqlar/&quot;&gt;SQLite Archiver (sqlar.exe)&lt;/a&gt;&amp;rarr; A ZIP-like archive program that uses SQLite for storage.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/sqlar/&quot;&gt;SQLite Archiver (sqlar.exe)&lt;/a&gt; &amp;rarr; 저장을 위해 SQLite를 사용하는 ZIP과 유사한 아카이브 프로그램.</target>
        </trans-unit>
        <trans-unit id="fe8a9163e518a98353ef8d32d8adc311cc4e744e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_demovfs.c&quot;&gt;test_demovfs.c&lt;/a&gt; - This file implements a very simple VFS named &quot;demo&quot; that uses POSIX functions such as open(), read(), write(), fsync(), close(), fsync(), sleep(), time(), and so forth. This VFS only works on unix systems. But it is not intended as a replacement for the standard &quot;unix&quot; VFS used by default on unix platforms. The &quot;demo&quot; VFS is deliberately kept very simple so that it can be used as a learning aid or as template for building other VFSes or for porting SQLite to new operating systems.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_demovfs.c&quot;&gt;test_demovfs.c-&lt;/a&gt; 이 파일은 open (), read (), write (), fsync (), close (), fsync (), sleep (), time과 같은 POSIX 함수를 사용하는 &quot;demo&quot;라는 매우 간단한 VFS를 구현합니다. (), 기타 등등. 이 VFS는 유닉스 시스템에서만 작동합니다. 그러나 유닉스 플랫폼에서 기본적으로 사용되는 표준 &quot;유닉스&quot;VFS를 대체하기위한 것은 아닙니다. &quot;데모&quot;VFS는 다른 VFS를 구축하거나 SQLite를 새로운 운영 체제로 이식하기위한 학습 보조 도구 또는 템플릿으로 사용할 수 있도록 의도적으로 매우 단순하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4b6ffddb2b5d00970ad79570716fef343d120422" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_journal.c&quot;&gt;test_journal.c&lt;/a&gt; - This file implements a shim used during SQLite testing that verifies that the database and rollback journal are written in the correct order and are &quot;synced&quot; at appropriate times in order to guarantee that the database can recover from a power lose are hard reset at any time. The shim checks several invariants on the operation of databases and rollback journals and raises exceptions if any of those invariants are violated. These invariants, in turn, assure that the database is always recoverable. Running a large suite of test cases using this shim provides added assurance that SQLite databases will not be damaged by unexpected power failures or device resets.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_journal.c&quot;&gt;test_journal.c-&lt;/a&gt; 이 파일은 SQLite 테스트 중에 사용되는 shim을 구현하여 데이터베이스 및 롤백 저널이 올바른 순서로 작성되었으며 데이터베이스가 전원 손실로부터 복구 될 수 있음을 보장하기 위해 적절한 시간에 &quot;동기화&quot;되었는지 확인합니다. 언제든지 재설정하십시오. shim은 데이터베이스 및 롤백 저널 작업에서 여러 가지 변형을 확인하고 이러한 변형 중 하나라도 위반하면 예외를 발생시킵니다. 이러한 불변은 차례로 데이터베이스를 항상 복구 할 수있게합니다. 이 shim을 사용하여 대규모 테스트 사례를 실행하면 예기치 않은 정전이나 장치 재설정으로 인해 SQLite 데이터베이스가 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34b6ee40cad7ea691fd329793d324b35174c6fd4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_multiplex.c&quot;&gt;test_multiplex.c&lt;/a&gt; - This file implements a shim that allows database files to exceed the maximum file size of the underlying filesystem. This shim presents an interface to the upper six layers of SQLite that makes it look like very large files are being used, when in reality each such large file is split up into many smaller files on the underlying system. This shim has been used, for example, to allow databases to grow larger than 2 gibibytes on FAT16 filesystems.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_multiplex.c&quot;&gt;test_multiplex.c-&lt;/a&gt; 이 파일은 데이터베이스 파일이 기본 파일 시스템의 최대 파일 크기를 초과 할 수 있도록 shim을 구현합니다. 이 심은 SQLite의 상위 6 개 계층에 대한 인터페이스를 제공하여 실제로 큰 파일이 사용되는 것처럼 보이게합니다. 실제로 이러한 큰 파일은 기본 시스템에서 여러 개의 작은 파일로 분할됩니다. 예를 들어이 shim은 FAT16 파일 시스템에서 데이터베이스가 2 기가 바이트보다 커질 수 있도록 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d80e27cb029c175ec02f70a4f1d0e290cf46734" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_onefile.c&quot;&gt;test_onefile.c&lt;/a&gt; - This file implements a demonstration VFS named &quot;fs&quot; that shows how SQLite can be used on an embedded device that lacks a filesystem. Content is written directly to the underlying media. A VFS derived from this demonstration code could be used by a gadget with a limited amount of flash memory to make SQLite behave as the filesystem for the flash memory on the device.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_onefile.c&quot;&gt;test_onefile.c-&lt;/a&gt; 이 파일은 파일 시스템이없는 임베디드 장치에서 SQLite를 사용하는 방법을 보여주는 &quot;fs&quot;라는 데모 VFS를 구현합니다. 내용은 기본 미디어에 직접 기록됩니다. 이 데모 코드에서 파생 된 VFS는 제한된 양의 플래시 메모리가있는 가젯에서 SQLite를 장치의 플래시 메모리에 대한 파일 시스템으로 작동하도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a046f7710247bcac9d46a2952691d377a15d85cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_quota.c&quot;&gt;test_quota.c&lt;/a&gt; - This file implements a shim called &quot;quota&quot; that enforces cumulative file size limits on a collection of database files. An auxiliary interface is used to define &quot;quota groups&quot;. A quota group is a set of files (database files, journals, and temporary files) whose names all match a &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern. The sum of the sizes of all files in each quota group is tracked, and if that sum exceeds a threshold defined for the quota group, a callback function is invoked. That callback can either increase the threshold or cause the operation that would have exceeded the quota to fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. One of the uses of this shim is used to enforce resource limits on application databases in Firefox.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_quota.c&quot;&gt;test_quota.c-&lt;/a&gt; 이 파일은 &quot;quota&quot;라는 shim을 구현하여 데이터베이스 파일 모음에 누적 파일 크기 제한을 적용합니다. 보조 인터페이스는 &quot;quota groups&quot;를 정의하는 데 사용됩니다. 할당량 그룹은 이름이 모두 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 패턴 과 일치하는 파일 세트 (데이터베이스 파일, 저널 및 임시 파일)입니다 . 각 할당량 그룹에있는 모든 파일 크기의 합계가 추적되고 해당 합계가 할당량 그룹에 대해 정의 된 임계 값을 초과하면 콜백 함수가 호출됩니다. 이 콜백은 임계 값을 증가 시키거나 할당량을 초과 한 조작이 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 로 실패하게 할 수 있습니다. 이 shim의 사용 중 하나는 Firefox에서 응용 프로그램 데이터베이스에 대한 리소스 제한을 적용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="694f4496b41a8d5c2e071d19cbe16fc58bceedc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfs.c&quot;&gt;test_vfs.c&lt;/a&gt; - This file implements a shim that can be used to simulate filesystem faults. This shim is used during testing to verify that SQLite responses sanely to hardware malfunctions or to other error conditions such as running out of filesystem space that are difficult to test on a real system.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfs.c&quot;&gt;test_vfs.c-&lt;/a&gt; 이 파일은 파일 시스템 결함을 시뮬레이션하는 데 사용할 수있는 shim을 구현합니다. 이 shim은 테스트 중에 하드웨어 고장이나 실제 시스템에서 테스트하기 어려운 파일 시스템 공간 부족과 같은 기타 오류 조건에 대한 SQLite 응답을 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b521fd8f56ec5ba85e8ba549bc177d135c760f09" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;appendvfs.c&lt;/a&gt; - This VFS allows an SQLite database to be appended to the end of some other file. This can be used, for example, to append an SQLite database onto the end of an executable such that the executable where it can then be easily located by the executable when needed. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will use this VFS if launched with the --append option.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;appendvfs.c-&lt;/a&gt; 이 VFS를 사용하면 SQLite 데이터베이스를 다른 파일 끝에 추가 할 수 있습니다. 예를 들어, SQLite 데이터베이스를 실행 파일 끝에 추가하여 실행 파일이 필요할 때 실행 파일로 쉽게 찾을 수 있도록 실행 파일 끝에 추가 할 수 있습니다. &lt;a href=&quot;cli&quot;&gt;명령 줄 셸은&lt;/a&gt; --append 옵션으로 시작하는 경우이 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1af52e4208dd24275750eb11b19ea83c661ff12a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://core.tcl.tk/&quot;&gt;Tcl&lt;/a&gt; version 8.6 or later.</source>
          <target state="translated">&lt;a href=&quot;https://core.tcl.tk/&quot;&gt;Tcl&lt;/a&gt; 버전 8.6 이상</target>
        </trans-unit>
        <trans-unit id="9ac66c2f42d45bc22c27630c047ee60e490737ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/cosmos-db/serverless-computing-database&quot;&gt;Microsoft Azure Cosmo DB&lt;/a&gt; and &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;Amazon S3&lt;/a&gt; are examples of a neo-serverless databases. These database are implemented by server processes running separately in the cloud. But the servers are maintained and administered by the ISP, not by the application developer. Application developers just use the service. Developers do not have to provision, configure, or manage database server instances, as all of that work is handled automatically by the service provider. Database servers do in fact exist, they are just hidden from the developers.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/cosmos-db/serverless-computing-database&quot;&gt;Microsoft Azure Cosmo DB&lt;/a&gt; 및 &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;Amazon S3&lt;/a&gt; 는 서버가없는 데이터베이스의 예입니다. 이러한 데이터베이스는 클라우드에서 별도로 실행되는 서버 프로세스에 의해 구현됩니다. 그러나 서버는 응용 프로그램 개발자가 아닌 ISP에서 유지 관리합니다. 응용 프로그램 개발자는 서비스를 사용합니다. 모든 작업이 서비스 공급자가 자동으로 처리하므로 개발자는 데이터베이스 서버 인스턴스를 프로비저닝, 구성 또는 관리 할 필요가 없습니다. 데이터베이스 서버는 실제로 존재하며 개발자에게 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="19809801c68c51fa8685908eff20779d1bbb5d44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/about.html&quot;&gt;About SQLite&lt;/a&gt;&amp;rarr; A high-level overview of what SQLite is and why you might be interested in using it.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/about.html&quot;&gt;SQLite 정보&lt;/a&gt; &amp;rarr; SQLite의 정의와 사용에 관심이있는 이유에 대한 고급 개요.</target>
        </trans-unit>
        <trans-unit id="3500bfac2f65b8182235fae5f4ef265e6b6733c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/android/&quot;&gt;Android Bindings for SQLite&lt;/a&gt;&amp;rarr; A description of how to compile your own SQLite for Android (bypassing the SQLite that is built into Android) together with code and makefiles.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/android/&quot;&gt;SQLite 용 Android 바인딩&lt;/a&gt; &amp;rarr; 코드 및 makefile과 함께 Android 용 SQLite (Android에 내장 된 SQLite를 무시 함)를 컴파일하는 방법에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="027fcb4cafa6f3e81e38a6fc54bd8c8a8293a02f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/books.html&quot;&gt;Books About SQLite&lt;/a&gt;&amp;rarr; A list of independently written books about SQLite.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/books.html&quot;&gt;SQLite 관련 서적&lt;/a&gt; &amp;rarr; SQLite에 대한 독자적으로 작성된 서적 목록.</target>
        </trans-unit>
        <trans-unit id="126da3a97dce7ec022711e2c404b75fae7593715" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;Copyright&lt;/a&gt;&amp;rarr; SQLite is in the public domain. This document describes what that means and the implications for contributors.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;저작권&lt;/a&gt; &amp;rarr; SQLite는 공개 도메인에 있습니다. 이 문서는 그 의미와 기여자에게 미치는 영향에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="91db4fedc208f005df9fd017f53d8eb7ac29275c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/famous.html&quot;&gt;Well Known Users&lt;/a&gt;&amp;rarr; This page lists a small subset of the many thousands of devices and application programs that make use of SQLite.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/famous.html&quot;&gt;잘 알려진 사용자&lt;/a&gt; &amp;rarr;이 페이지에는 SQLite를 사용하는 수천 개의 장치 및 응용 프로그램 중 일부가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac7b24b0e6cb2086b49a2b8697b7176ff94a4c0c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/doc/trunk/doc/lemon.html&quot;&gt;lemon.html&lt;/a&gt; &amp;rarr; The original detailed usage documentation and programmers reference for Lemon.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/doc/trunk/doc/lemon.html&quot;&gt;lemon.html&lt;/a&gt; &amp;rarr; 레몬에 대한 원본 사용 설명서 및 프로그래머 참조.</target>
        </trans-unit>
        <trans-unit id="70231463d582db0f93b43651ea2a4ea9f1244982" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;appendvfs.c&lt;/a&gt; &amp;mdash; This extension implements a new &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; that allows an SQLite database to be appended to some other file, such as an executable. This extension is only needed if the --append option to the .archive command is used.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;appendvfs.c&lt;/a&gt; &amp;mdash;이 확장 은 SQLite 데이터베이스를 실행 파일과 같은 다른 파일에 추가 할 수 있는 새로운 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 구현합니다 . 이 확장은 .archive 명령에 --append 옵션을 사용하는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed3114f80a2eed1612fb72f24c94c6dbceaf2862" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; &amp;mdash; This extension adds SQL functions readfile() and writefile() for reading and writing content from files on disk. The fileio.c extension also includes fsdir() table-valued function for listing the contents of a directory and the lsname() function for converting numeric st_mode integers from the stat() system call into human-readable strings after the fashion of the &quot;ls -l&quot; command.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; &amp;mdash;이 확장은 디스크의 파일에서 내용을 읽고 쓰는 SQL 함수 readfile () 및 writefile ()을 추가합니다. fileio.c 확장명에는 디렉토리의 내용을 나열하는 fsdir () 테이블 반환 함수와 stat () 시스템 호출의 숫자 st_mode 정수를 사람이 읽을 수있는 문자열로 변환하기위한 lsname () 함수도 포함되어 있습니다. ls -l &quot;명령.</target>
        </trans-unit>
        <trans-unit id="e09e496ba6b38936f13074d18b4ee39b32553351" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;sqlar.c&lt;/a&gt; &amp;mdash; This extension adds the sqlar_compress() and sqlar_uncompress() functions that are needed to compress and uncompress file content as it is insert and extracted from an SQLite Archive.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;sqlar.c&lt;/a&gt; &amp;mdash;이 확장은 SQLite Archive에서 삽입 및 추출 될 때 파일 내용을 압축 및 압축 해제하는 데 필요한 sqlar_compress () 및 sqlar_uncompress () 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="65dc955fd1bab12cdddba775936cc991c8aac06d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/file/tool/lemon.c&quot;&gt;lemon.c&lt;/a&gt; &amp;rarr; The source code for the utility program that reads a grammar file and generates corresponding parser C-code.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/lemon.c&quot;&gt;lemon.c&lt;/a&gt; &amp;rarr; 문법 파일을 읽고 해당 파서 C 코드를 생성하는 유틸리티 프로그램의 소스 코드.</target>
        </trans-unit>
        <trans-unit id="c9db8df2bbf08b45294373dde5327d0b66e5caca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://sqlite.org/src/file/tool/lempar.c&quot;&gt;lempar.c&lt;/a&gt; &amp;rarr; A template for the generated parser C-code. The &quot;lemon&quot; utility program reads this template and inserts additional code in order to generate a parser.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/lempar.c&quot;&gt;lempar.c&lt;/a&gt; &amp;rarr; 생성 된 파서 C 코드 용 템플릿. &quot;lemon&quot;유틸리티 프로그램은이 템플리트를 읽고 구문 분석기를 생성하기 위해 추가 코드를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="9b46f2ccf9463814b19c5fed75eba21c4687b88b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt; requires that polygons use CCW rotation. But the spec also observes that many legacy GeoJSON files do not following the spec and contain polygons with clockwise (CW) rotation. The geopoly_ccw() function is useful for applications that are reading legacy GeoJSON scripts. If the input to geopoly_ccw() is a correctly-formatted polygon, then no changes are made. However, if the circulation of the input polygon is backwards, then geopoly_ccw() reverses the circulation order so that it conforms to the spec and so that it will work correctly with the Geopoly module.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt; 에는 다각형이 CCW 회전을 사용해야합니다. 그러나이 사양은 많은 기존 GeoJSON 파일이 사양을 따르지 않으며 시계 방향 (CW) 회전의 다각형을 포함하고 있음을 관찰합니다. geopoly_ccw () 함수는 레거시 GeoJSON 스크립트를 읽는 응용 프로그램에 유용합니다. geopoly_ccw ()에 대한 입력이 올바른 형식의 다각형이면 변경 사항이 없습니다. 그러나 입력 다각형의 순환이 역순이면 geopoly_ccw ()는 순환 순서를 반대로하여 스펙을 준수하고 Geopoly 모듈과 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="595f58b0cdcf0e836878e371a088c530f62d8918" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version 2.5 and later offers &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive files&lt;/a&gt; as a download format, in addition to traditional tarball and ZIP archive. The &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; version 3.22.0 and later will create, list, or unpack an SQL archiving using the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; 버전 2.5 이상은 전통적인 tarball 및 ZIP 아카이브 외에도 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive 파일&lt;/a&gt; 을 다운로드 형식으로 제공합니다 . &lt;a href=&quot;cli&quot;&gt;sqlite3.exe 명령 행 쉘&lt;/a&gt; 버전 3.22.0 이상에서는 목록을 만들거나 사용하여 보관하여 SQL 압축 해제됩니다 &lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6d5971ce459ba85e0e0ba0f7afbf7a44a125409" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.microsoft.com/en-us/research/people/gray/&quot;&gt;Jim Gray&lt;/a&gt; and others studied the read performance of BLOBs versus file I/O for Microsoft SQL Server and found that reading BLOBs out of the database was faster for BLOB sizes less than between 250KiB and 1MiB. (&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/to-blob-or-not-to-blob-large-object-storage-in-a-database-or-a-filesystem/&quot;&gt;Paper&lt;/a&gt;). In that study, the database still stores the filename of the content even if the content is held in a separate file. So the database is consulted for every BLOB, even if it is only to extract the filename. In this article, the key for the BLOB is the filename, so no preliminary database access is required. Because the database is never used at all when reading content from individual files in this article, the threshold at which direct file I/O becomes faster is smaller than it is in Gray's paper.</source>
          <target state="translated">&lt;a href=&quot;https://www.microsoft.com/en-us/research/people/gray/&quot;&gt;Jim Gray&lt;/a&gt; 와 다른 사람들은 Microsoft SQL Server에 대한 BLOB의 읽기 성능과 파일 I / O를 연구 한 결과 데이터베이스에서 BLOB를 읽는 것이 250KiB와 1MiB 미만의 BLOB 크기에서 더 빠르다는 것을 발견했습니다. ( &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/to-blob-or-not-to-blob-large-object-storage-in-a-database-or-a-filesystem/&quot;&gt;종이&lt;/a&gt; ). 이 연구에서 데이터베이스는 내용이 별도의 파일에 보관되어 있어도 내용의 파일 이름을 저장합니다. 따라서 데이터베이스는 파일 이름 만 추출하더라도 모든 BLOB에 대해 참조됩니다. 이 기사에서 BLOB의 핵심은 파일 이름이므로 예비 데이터베이스 액세스는 필요하지 않습니다. 이 기사에서 개별 파일의 내용을 읽을 때 데이터베이스가 전혀 사용되지 않기 때문에 직접 파일 I / O가 빨라지는 임계 값은 Gray의 논문보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="3d5293e417eef6458cd876ba73b20d567317ae9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/cgi/docsrc&quot;&gt;https://www.sqlite.org/cgi/docsrc&lt;/a&gt; (Dallas)</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/cgi/docsrc&quot;&gt;https://www.sqlite.org/cgi/docsrc&lt;/a&gt; (달라스)</target>
        </trans-unit>
        <trans-unit id="4d278dc39d8b5b6d67dba4566ae76a4852145368" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/cgi/src&quot;&gt;https://www.sqlite.org/cgi/src&lt;/a&gt; (Dallas)</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/cgi/src&quot;&gt;https://www.sqlite.org/cgi/src&lt;/a&gt; (달라스)</target>
        </trans-unit>
        <trans-unit id="c67531814538c670d36066c83b9153caa908da0c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.c&quot;&gt;carray.c&lt;/a&gt; &amp;mdash; Implementation of the &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.c&quot;&gt;carray.c&lt;/a&gt; &amp;mdash; &lt;a href=&quot;carray&quot;&gt;carray 테이블 반환 함수의&lt;/a&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="1e6b4fc5dedfec34e9cf16833688ec3ea683c352" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/compress.c&quot;&gt;compress.c&lt;/a&gt; &amp;mdash; Implementation of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; compress() and uncompress() that do zLib compression of text or blob content.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/compress.c&quot;&gt;compress.c&lt;/a&gt; &amp;mdash; 텍스트 또는 BLOB 내용의 zLib 압축을 수행 하는 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; compress () 및 uncompress ()의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="7c43d188cc4f3abaee237fcdb536c244fdd500f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/json1.c&quot;&gt;json1.c&lt;/a&gt; &amp;mdash; Implementation of &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. This is a larger and more complex extension.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/json1.c&quot;&gt;json1.c&lt;/a&gt; - 구현 &lt;a href=&quot;json1&quot;&gt;JSON SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; . 이것은 더 크고 복잡한 확장입니다.</target>
        </trans-unit>
        <trans-unit id="f653f6743fec7668b77eaeac8d0a4139143b767c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/memvfs.c&quot;&gt;memvfs.c&lt;/a&gt; &amp;mdash; Implementation of a new &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; that stores all content in-memory.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/memvfs.c&quot;&gt;memvfs.c&lt;/a&gt; &amp;mdash; 모든 내용을 메모리에 저장 하는 새로운 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="f4ca445824fa567da122d01aaf7765abbd20faac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember(V,PTR)&lt;/a&gt; &amp;rarr; requires &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; to set the PTR parameter.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember (V, PTR)&lt;/a&gt; &amp;rarr; PTR 매개 변수를 설정 하려면 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="21ff3a0ef04e696c05b2a0075b1b32d6b3375a4b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/rot13.c&quot;&gt;rot13.c&lt;/a&gt; &amp;mdash; Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/ROT13&quot;&gt;rot13()&lt;/a&gt; SQL function. This is a very simple example of an extension function and is useful as a template for creating new extensions.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/rot13.c&quot;&gt;rot13.c&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/ROT13&quot;&gt;rot13 ()&lt;/a&gt; SQL 함수의 구현입니다 . 이것은 확장 기능의 매우 간단한 예이며 새 확장을 작성하기위한 템플리트로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="be4563b7bc01f4760fbba7be3952b39b8c6cd843" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/series.c&quot;&gt;series.c&lt;/a&gt; &amp;mdash; Implementation of the generate_series &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;. This is a relatively simple example of a virtual table implementation which can serve as a template for writing new virtual tables.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/series.c&quot;&gt;series.c&lt;/a&gt; - generate_series의 구현 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 과 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; . 새 가상 테이블을 작성하기위한 템플리트로 사용할 수있는 가상 테이블 구현의 비교적 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="9c13d1e0d8c62483b71e8fb2bd87ccf258f003d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www2.sqlite.org/cgi/docsrc&quot;&gt;https://www2.sqlite.org/cgi/docsrc&lt;/a&gt; (Newark)</source>
          <target state="translated">&lt;a href=&quot;https://www2.sqlite.org/cgi/docsrc&quot;&gt;https://www2.sqlite.org/cgi/docsrc&lt;/a&gt; (뉴 어크)</target>
        </trans-unit>
        <trans-unit id="46ed7bd5f4a8ce97dd41aa3e8d94cfe556c21962" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www2.sqlite.org/cgi/src&quot;&gt;https://www2.sqlite.org/cgi/src&lt;/a&gt; (Newark)</source>
          <target state="translated">&lt;a href=&quot;https://www2.sqlite.org/cgi/src&quot;&gt;https://www2.sqlite.org/cgi/src&lt;/a&gt; (뉴 어크)</target>
        </trans-unit>
        <trans-unit id="c56ef0337b003b6e4bdc63849a10976a52155a80" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www3.sqlite.org/cgi/docsrc&quot;&gt;https://www3.sqlite.org/cgi/docsrc&lt;/a&gt; (San Francisco)</source>
          <target state="translated">&lt;a href=&quot;https://www3.sqlite.org/cgi/docsrc&quot;&gt;https://www3.sqlite.org/cgi/docsrc&lt;/a&gt; (샌프란시스코)</target>
        </trans-unit>
        <trans-unit id="e8c93e9dbd954f1255d65cb23b0212c930a4bd4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www3.sqlite.org/cgi/src&quot;&gt;https://www3.sqlite.org/cgi/src&lt;/a&gt; (San Francisco)</source>
          <target state="translated">&lt;a href=&quot;https://www3.sqlite.org/cgi/src&quot;&gt;https://www3.sqlite.org/cgi/src&lt;/a&gt; (샌프란시스코)</target>
        </trans-unit>
        <trans-unit id="e4076a283b9c190fbdf3f5c1801a8f7cc0cdc999" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;inmemorydb&quot;&gt;In-Memory Databases&lt;/a&gt;&amp;rarr; SQLite normally stores content in a disk file. However, it can also be used as an in-memory database engine. This document explains how.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;메모리 내 데이터베이스&lt;/a&gt; &amp;rarr; SQLite는 일반적으로 디스크 파일에 내용을 저장합니다. 그러나 인 메모리 데이터베이스 엔진으로도 사용할 수 있습니다. 이 문서는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ef3ace6371f15916f1559f671f25326445924451" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;inmemorydb&quot;&gt;In-memory databases&lt;/a&gt; that are specified using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are allowed to use &lt;a href=&quot;sharedcache#inmemsharedcache&quot;&gt;shared cache&lt;/a&gt;, so that the same in-memory database can be accessed from multiple database connections.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;&lt;/a&gt;&lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 사용하여 지정된 메모리 내 데이터베이스 는 &lt;a href=&quot;sharedcache#inmemsharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 사용할 수 있으므로 여러 데이터베이스 연결에서 동일한 메모리 내 데이터베이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="add6ec15c936e3df93ba265a52ddac6c8277acd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal versus External Blob Storage&lt;/a&gt;&amp;rarr; Should you store large BLOBs directly in the database, or store them in files and just record the filename in the database? This document seeks to shed light on that question.</source>
          <target state="translated">&lt;a href=&quot;intern-v-extern-blob&quot;&gt;내부 및 외부 Blob 저장소&lt;/a&gt; &amp;rarr; 대용량 BLOB를 데이터베이스에 직접 저장하거나 파일에 저장하고 파일 이름을 데이터베이스에 기록해야합니까? 이 문서는 그 질문에 대해 밝히고 자합니다.</target>
        </trans-unit>
        <trans-unit id="e97102749522c28fe4c38d80e2e93ecd4e1f0bcc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;isolation&quot;&gt;Isolation In SQLite&lt;/a&gt;&amp;rarr; When we say that SQLite transactions are &quot;serializable&quot; what exactly does that mean? How and when are changes made visible within the same database connection and to other database connections?</source>
          <target state="translated">&lt;a href=&quot;isolation&quot;&gt;SQLite에서 격리&lt;/a&gt; &amp;rarr; SQLite 트랜잭션이 &quot;직렬화 가능&quot;하다고 할 때 정확히 무엇을 의미합니까? 동일한 데이터베이스 연결 및 다른 데이터베이스 연결에서 변경 내용이 언제 어떻게 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="acf3a2c855e1ba87fb17fd17fe7587c578135fe8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;json1&quot;&gt;Json1 - JSON Integration&lt;/a&gt;&amp;rarr; SQL functions for creating, parsing, and querying JSON content.</source>
          <target state="translated">&lt;a href=&quot;json1&quot;&gt;Json1-JSON 통합&lt;/a&gt; &amp;rarr; JSON 컨텐츠 작성, 구문 분석 및 조회를위한 SQL 함수</target>
        </trans-unit>
        <trans-unit id="fbfee052d0109cb8af6ceba860ea67aa05800e90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang&quot;&gt;SQL Syntax&lt;/a&gt;&amp;rarr; This document describes the SQL language that is understood by SQLite.</source>
          <target state="translated">&lt;a href=&quot;lang&quot;&gt;SQL 구문&lt;/a&gt; &amp;rarr;이 문서는 SQLite가 이해하는 SQL 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="80376d53985210baf876754829e6359b6d876ae7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_aggfunc&quot;&gt;Aggregate SQL Functions&lt;/a&gt;&amp;rarr; General-purpose built-in aggregate SQL functions.</source>
          <target state="translated">&lt;a href=&quot;lang_aggfunc&quot;&gt;집계 SQL 함수&lt;/a&gt; &amp;rarr; 범용 내장 집계 SQL 함수.</target>
        </trans-unit>
        <trans-unit id="ed26e10b0ca047694c87d2ba573f4b4baf09449c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_aggfunc&quot;&gt;Aggregate functions&lt;/a&gt; including DISTINCT aggregates</source>
          <target state="translated">&lt;a href=&quot;lang_aggfunc&quot;&gt;&lt;/a&gt;DISTINCT 집계를 포함한 집계 함수</target>
        </trans-unit>
        <trans-unit id="7b14b3624a06db71d554f781ea3678b65b94cf53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_corefunc&quot;&gt;Core SQL Functions&lt;/a&gt;&amp;rarr; General-purpose built-in scalar SQL functions.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc&quot;&gt;핵심 SQL 함수&lt;/a&gt; &amp;rarr; 범용 내장 스칼라 SQL 함수.</target>
        </trans-unit>
        <trans-unit id="1d850e9761f04a6bd61517cbdd21ebb8202cc727" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf()&lt;/a&gt; &amp;rarr; an SQL function returning the formatted string</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf ()&lt;/a&gt; &amp;rarr; 포맷 된 문자열을 반환하는 SQL 함수</target>
        </trans-unit>
        <trans-unit id="5ccb350eba7579e71e08d643438db5c3dfe941ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_createtable&quot;&gt;Tables&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;indexes&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; in unlimited quantity</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;&lt;/a&gt;무제한 수량의 테이블 , &lt;a href=&quot;lang_createindex&quot;&gt;인덱스&lt;/a&gt; , &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 및 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ae9fd3a0faa3c7c207de41253338989ca74962c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, and &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; , &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 및 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY 제약 조건&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7177a425e852c8863b306e2f074699f4faac5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_createtrigger&quot;&gt;Triggers&lt;/a&gt; need to be reentrant. Since bytecode subroutines are not reentrant a different mechanism must be used to implement triggers. Each trigger is implemented using a separate bytecode program with its own opcodes, program counter, and register set. The &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; opcode invokes the trigger subprogram. The &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction allocates and initializes a fresh register set for each invocation of the subprogram, so subprograms can be reentrant and recursive. The &lt;a href=&quot;opcode#Param&quot;&gt;Param&lt;/a&gt; opcode is used by subprograms to access content in registers of the calling bytecode program.</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger&quot;&gt;트리거를 다시 입력&lt;/a&gt; 해야합니다. 바이트 코드 서브 루틴이 재진입되지 않으므로 트리거를 구현하는 데 다른 메커니즘을 사용해야합니다. 각 트리거는 자체 ​​opcode, 프로그램 카운터 및 레지스터 세트가있는 별도의 바이트 코드 프로그램을 사용하여 구현됩니다. &lt;a href=&quot;opcode#Program&quot;&gt;프로그램&lt;/a&gt; 연산 코드는 트리거 서브 프로그램을 호출합니다. &lt;a href=&quot;opcode#Program&quot;&gt;프로그램의&lt;/a&gt; 서브 프로그램 재진입 및 순환 될 수 있도록 지시를 할당하고, 각각의 서브 프로그램의 호출을위한 새로운 레지스터 세트를 초기화한다. &lt;a href=&quot;opcode#Param&quot;&gt;의 param&lt;/a&gt; 오피 코드 바이트는 호출 프로그램 레지스터 액세스 서브 콘텐츠에 의해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ac5349d805a2e8520d6782d62d0c9b5a1e1f1865" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_datefunc&quot;&gt;Date and Time SQL Functions&lt;/a&gt;&amp;rarr; SQL functions for manipulating dates and times.</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 SQL 함수&lt;/a&gt; &amp;rarr; 날짜 및 시간 조작을위한 SQL 함수.</target>
        </trans-unit>
        <trans-unit id="db7af1f5a44ea354e7e7bd69327dcf91a2d90e39" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to BLOB</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;캐스트&lt;/a&gt; 에서 BLOB</target>
        </trans-unit>
        <trans-unit id="23bb0f7ce0d79b5c5f128dad61b53b9c153fae63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to INTEGER</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; 정수로</target>
        </trans-unit>
        <trans-unit id="ed5c18f9ebb11f4107e03ea9a1dedc176dea7725" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; to REAL</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; REAL에</target>
        </trans-unit>
        <trans-unit id="28bc5e22563f572f65cd611d01fa06754a3ac1f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_expr#subq&quot;&gt;Subqueries&lt;/a&gt;, including &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_expr#subq&quot;&gt;&lt;/a&gt;&lt;a href=&quot;lang_expr#cosub&quot;&gt;상관 된 서브 &lt;/a&gt;쿼리 를 포함한 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="0cc60dc258387057b503626f14e8da6aa81dd71c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements may not use default values.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문은 기본값을 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ab4adce49f5d97df898e3893ee36f533094ddd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT/ALL keyword&lt;/a&gt; processing: If the query is a &quot;SELECT DISTINCT&quot; query, duplicate rows are removed from the set of result rows.</source>
          <target state="translated">&lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT / ALL 키워드&lt;/a&gt; 처리 : 쿼리가 &quot;SELECT DISTINCT&quot;쿼리 인 경우 결과 행 집합에서 중복 행이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cd90022371a5bfe4e6ee7861bc47b97c0249d6a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_select#fromclause&quot;&gt;FROM clause&lt;/a&gt; processing: The input data for the simple SELECT is determined. The input data is either implicitly a single row with 0 columns (if there is no FROM clause) or is determined by the FROM clause.</source>
          <target state="translated">&lt;a href=&quot;lang_select#fromclause&quot;&gt;FROM 절&lt;/a&gt; 처리 : 단순 SELECT에 대한 입력 데이터가 결정됩니다. 입력 데이터는 암시 적으로 0 개의 열이있는 단일 행이거나 (FROM 절이없는 경우) FROM 절에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="08125b14844cfd5e3dba411af5a0d56cd87bd914" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_select#resultset&quot;&gt;GROUP BY, HAVING and result-column expression&lt;/a&gt; processing: The set of result rows is computed by aggregating the data according to any GROUP BY clause and calculating the result-set expressions for the rows of the filtered input dataset.</source>
          <target state="translated">&lt;a href=&quot;lang_select#resultset&quot;&gt;GROUP BY, HAVING 및 결과 열 식&lt;/a&gt; 처리 : 결과 행 집합은 GROUP BY 절에 따라 데이터를 집계하고 필터링 된 입력 데이터 집합의 행에 대한 결과 집합 식을 계산하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9db4c4beeec274dd596467613fa50eba131f91e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_select#whereclause&quot;&gt;WHERE clause&lt;/a&gt; processing: The input data is filtered using the WHERE clause expression.</source>
          <target state="translated">&lt;a href=&quot;lang_select#whereclause&quot;&gt;WHERE 절&lt;/a&gt; 처리 : 입력 데이터는 WHERE 절 표현식을 사용하여 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca608e2cac8ab5e430ca18b20cbf55a2715c550" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements must identify the target rows by rowid or by non-NULL PRIMARY KEY values.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문은 rowid 또는 NULL이 아닌 PRIMARY KEY 값으로 대상 행을 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="e543de55c506f5ff8c4b4657294948ee1847977c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; avoids unnecessary low-level disk writes when the contents of the database file do not actually change. For example, &quot;UPDATE t1 SET x=25 WHERE y=?&quot; generates no extra disk I/O if the value in column x is already 25. Similarly, when doing &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on records that span multiple pages, only the subset of pages that actually change are written to disk. This is a low-level performance optimization only and does not affect the behavior of TRIGGERs or other higher level SQL structures.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 는 데이터베이스 파일의 내용이 실제로 변경되지 않을 때 불필요한 저수준 디스크 쓰기를 방지합니다. 예를 들어, &quot;UPDATE t1 SET x = 25 WHERE y =?&quot; x 열의 값이 이미 25 인 경우 추가 디스크 I / O를 생성하지 않습니다. 마찬가지로, 여러 페이지에 걸쳐있는 레코드 에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 실제로 변경되는 페이지의 서브 세트 만 디스크에 기록됩니다. 이는 저수준 성능 최적화 일 뿐이며 TRIGGER 또는 다른 상위 SQL 구조의 동작에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea993e1e37614bdfd47db46d0eb53c1e9f2332d9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements may not modify PRIMARY KEY or rowid values.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문은 PRIMARY KEY 또는 rowid 값을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50fa03686db9c26c875290a6c07cf3eb36e4143b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; (of course)</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; (물론)</target>
        </trans-unit>
        <trans-unit id="6c0bb918e2a4d420bc32ae4cad0fb1e8bbb98191" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lang_with&quot;&gt;Common table expressions&lt;/a&gt; including &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expressions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 을 포함하여 &lt;a href=&quot;lang_with#recursivecte&quot;&gt;재귀 공통 테이블 표현식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f383fff88e9cda5a68a7ef9f2d3e4b82206ead29" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;limits&quot;&gt;Limits In SQLite&lt;/a&gt;&amp;rarr; This document describes limitations of SQLite (the maximum length of a string or blob, the maximum size of a database, the maximum number of tables in a database, etc.) and how these limits can be altered at compile-time and run-time.</source>
          <target state="translated">&lt;a href=&quot;limits&quot;&gt;SQLite의 한계&lt;/a&gt; &amp;rarr;이 문서는 SQLite의 한계 (문자열 또는 BLOB의 최대 길이, 데이터베이스의 최대 크기, 데이터베이스의 최대 테이블 수 등)와 컴파일 타임에 이러한 한계를 변경하는 방법에 대해 설명합니다. 그리고 런타임.</target>
        </trans-unit>
        <trans-unit id="60437e515cf622747c7612c69d29f1d9c5031dfc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt;&amp;rarr; A general overview on how run-time loadable extensions work, how they are compiled, and how developers can create their own run-time loadable extensions for SQLite.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;런타임로드 가능한 확장 기능&lt;/a&gt; &amp;rarr; 런타임로드 가능한 확장 기능의 작동 방식, 확장 방법 및 개발자가 SQLite 용 런타임로드 가능한 확장 기능을 만드는 방법에 대한 일반적인 개요.</target>
        </trans-unit>
        <trans-unit id="d2caad7915dc6ea6105623823a86c6a13f1de504" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lockingv3&quot;&gt;Locking And Concurrency&lt;br/&gt;In SQLite Version 3&lt;/a&gt;&amp;rarr; A description of how the new locking code in version 3 increases concurrency and decreases the problem of writer starvation.</source>
          <target state="translated">&lt;a href=&quot;lockingv3&quot;&gt;&lt;br/&gt;SQLite 버전 3의 잠금 및 동시성&lt;/a&gt; &amp;rarr; 버전 3 의 새로운 잠금 코드가 동시성을 높이고 라이터 기아 문제를 줄이는 방법에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="64ece5531696a034c9b3db23e2179394a7bd965b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;malloc&quot;&gt;Dynamic Memory Allocation in SQLite&lt;/a&gt;&amp;rarr; SQLite has a sophisticated memory allocation subsystem that can be configured and customized to meet memory usage requirements of the application and that is robust against out-of-memory conditions and leak-free. This document provides the details.</source>
          <target state="translated">&lt;a href=&quot;malloc&quot;&gt;SQLite의 동적 메모리 할당&lt;/a&gt; &amp;rarr; SQLite에는 응용 프로그램의 메모리 사용 요구 사항을 충족하도록 구성 및 사용자 정의 할 수있는 메모리 할당 하위 시스템이 있으며 메모리 부족 조건 및 누수가 없습니다. 이 문서는 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c19a69a8239a2ac6001b13074bef86ba6f8a0bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mmap&quot;&gt;Memory-Mapped I/O&lt;/a&gt;&amp;rarr; SQLite supports memory-mapped I/O. Learn how to enable memory-mapped I/O and about the various advantages and disadvantages to using memory-mapped I/O in this document.</source>
          <target state="translated">&lt;a href=&quot;mmap&quot;&gt;메모리 매핑 된 I / O&lt;/a&gt; &amp;rarr; SQLite는 메모리 매핑 된 I / O를 지원합니다. 이 문서에서 메모리 매핑 된 I / O를 활성화하는 방법과 메모리 매핑 된 I / O 사용의 다양한 장단점에 대해 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="25e1da1978bd2d4e97d36aecf38b448c58b039cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;nulls&quot;&gt;Null Handling&lt;/a&gt;&amp;rarr; Different SQL database engines handle NULLs in different ways. The SQL standards are ambiguous. This (circa 2003) document describes how SQLite handles NULLs in comparison with other SQL database engines.</source>
          <target state="translated">&lt;a href=&quot;nulls&quot;&gt;널 처리&lt;/a&gt; &amp;rarr; 다른 SQL 데이터베이스 엔진은 다른 방식으로 NULL을 처리합니다. SQL 표준은 모호합니다. 이 문서 (2003 년경)는 다른 SQL 데이터베이스 엔진과 비교하여 SQLite가 NULL을 처리하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba3a1b2c128b67d9754d79b2e275212b7630ae3b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;objlist&quot;&gt;&lt;b&gt;List Of Objects.&lt;/b&gt;&lt;/a&gt; This is a list of all abstract objects and datatypes used by the SQLite library. There are couple dozen objects in total, but the two most important objects are: A database connection object &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;, and the prepared statement object &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;objlist&quot;&gt;&lt;b&gt;객체 목록. &lt;/b&gt;&lt;/a&gt;이것은 SQLite 라이브러리가 사용하는 모든 추상 객체 및 데이터 유형의 목록입니다. 총 12 개의 오브젝트가 있지만 가장 중요한 두 가지 오브젝트는 데이터베이스 연결 오브젝트&lt;a href=&quot;sqlite3&quot;&gt; sqlite3&lt;/a&gt; 및 준비된 명령문 오브젝트&lt;a href=&quot;stmt&quot;&gt; sqlite3_stmt&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1bf65d4c434db50bca34a75c52c805f46d21c854" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;opcode&quot;&gt;VDBE Opcodes&lt;/a&gt;&amp;rarr; This document is an automatically generated description of the various opcodes that the VDBE understands. Programmers can use this document as a reference to better understand the output of EXPLAIN listings from SQLite.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE Opcodes&lt;/a&gt; &amp;rarr;이 문서는 VDBE가 이해하는 다양한 opcode에 대한 자동 생성 설명입니다. 프로그래머는이 문서를 참조로 사용하여 SQLite의 EXPLAIN 리스팅 출력을 더 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb7ee7ac3dce908875bb9212f4d657ef18be509" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;optoverview&quot;&gt;Overview Of The Optimizer&lt;/a&gt;&amp;rarr; A quick overview of the various query optimizations that are attempted by the SQLite code generator.</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;옵티 마이저 개요&lt;/a&gt; &amp;rarr; SQLite 코드 생성기가 시도하는 다양한 쿼리 최적화에 대한 간략한 개요.</target>
        </trans-unit>
        <trans-unit id="ea4ed6dd72bde663cee320c7a8021bfbdb94a418" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;optoverview#autoindex&quot;&gt;Automatic indexing&lt;/a&gt; is enabled by default as of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), but this might change in future releases of SQLite.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20)부터 자동 인덱싱 이 기본적으로 사용 되지만 향후 SQLite 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="345c212ed365d373e726643866ed8f3817144df7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;optoverview#uplus&quot;&gt;The unary &quot;+&quot; operator&lt;/a&gt; can be used to disqualify terms in the WHERE clause from use by indices. Careful use of unary + can sometimes help prevent the query planner from choosing a poor index without restricting it to using one specific index. Careful placement of unary + operators is a better method for controlling which indices are used by a query.</source>
          <target state="translated">&lt;a href=&quot;optoverview#uplus&quot;&gt;단항 &quot;+&quot;연산자&lt;/a&gt; 를 사용하면 WHERE 절의 용어를 인덱스에서 사용할 수 없습니다. 단항 +를주의해서 사용하면 쿼리 플래너가 하나의 특정 인덱스를 사용하도록 제한하지 않고 열악한 인덱스를 선택하지 못하게하는 데 도움이 될 수 있습니다. 단항 + 연산자를주의해서 배치하는 것이 쿼리에서 사용되는 인덱스를 제어하는 ​​더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="57aaf1478b733e61a52c980c798ed985126a9b87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;partialindex&quot;&gt;Partial Indexes&lt;/a&gt;&amp;rarr; A partial index is an index that only covers a subset of the rows in a table. Learn how to use partial indexes in SQLite from this document.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; &amp;rarr; 부분 인덱스는 테이블에있는 행의 하위 집합 만 포함하는 인덱스입니다. 이 문서를 통해 SQLite에서 부분 인덱스를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="c4a98fdd9e70a73a0e561bb8a3d55b5f015c59bd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma&quot;&gt;Pragma commands&lt;/a&gt;&amp;rarr; This document describes SQLite performance tuning options and other special purpose database commands.</source>
          <target state="translated">&lt;a href=&quot;pragma&quot;&gt;Pragma 명령&lt;/a&gt; &amp;rarr;이 문서는 SQLite 성능 조정 옵션 및 기타 특수 목적 데이터베이스 명령에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bf59977e0701a50eb22a9e131e5250eabd1254c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;&lt;s&gt;count_changes&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;&lt;s&gt;count_changes&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="63f19b515ae3ec99b3aa3e6331e5a26ef6dcf0c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;&lt;s&gt;data_store_directory&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;&lt;s&gt;data_store_directory&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="d5164258fce23340a8176e74c0d8df7f603d44c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;&lt;s&gt;default_cache_size&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;&lt;s&gt;default_cache_size&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="403b20b9bb0f601d10a6ab66d5ba7ed090196c82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;&lt;s&gt;empty_result_callbacks&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;&lt;s&gt;empty_result_callbacks&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="a4758c50a659d7efaa281e74ec088d647a39084c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;&lt;s&gt;full_column_names&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;&lt;s&gt;full_column_names&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="2cfaeaf31d38f4d6dfca235270cea97a4478c33c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;Journal mode PERSIST&lt;/a&gt; is the default behavior in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;저널 모드 PERSIST&lt;/a&gt; 는 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드&lt;/a&gt; 의 기본 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="a70fcb58d0a61882d730e714c285927e74886b8a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_parser_trace&quot;&gt;parser_trace&lt;/a&gt;&amp;sup2;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_parser_trace&quot;&gt;parser_trace&lt;/a&gt;&amp;sup2;</target>
        </trans-unit>
        <trans-unit id="641bbd1853906b798f5b59b288aaf660fab52051" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;&amp;sup3;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;&amp;sup3;</target>
        </trans-unit>
        <trans-unit id="ce9d4b979d939dcdc122cbb52811ed9f56641a60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;&lt;s&gt;short_column_names&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;&lt;s&gt;short_column_names&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="05a23ccc0c52e6a0f04a26dd607178eab097a398" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_stats&quot;&gt;stats&lt;/a&gt;&amp;sup3;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_stats&quot;&gt;stats&lt;/a&gt;&amp;sup3;</target>
        </trans-unit>
        <trans-unit id="2838edb923c8639c8234d63aa4687a41fdecdd28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;&lt;s&gt;temp_store_directory&lt;/s&gt;&lt;/a&gt;&amp;sup1;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;&lt;s&gt;temp_store_directory&lt;/s&gt;&lt;/a&gt;&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="8e40c968a22d3a7d4fe015db7d98ba15dd9afd0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;vdbe_addoptrace&lt;/a&gt;&amp;sup2;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;vdbe_addoptrace&lt;/a&gt;&amp;sup2;</target>
        </trans-unit>
        <trans-unit id="6a0f779ac353fd434842dd2e03a7503a9a752862" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;vdbe_debug&lt;/a&gt;&amp;sup2;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;vdbe_debug&lt;/a&gt;&amp;sup2;</target>
        </trans-unit>
        <trans-unit id="ca79c4159fdc8c45bb8bd81e07a059247c531a08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_vdbe_listing&quot;&gt;vdbe_listing&lt;/a&gt;&amp;sup2;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_listing&quot;&gt;vdbe_listing&lt;/a&gt;&amp;sup2;</target>
        </trans-unit>
        <trans-unit id="e07c6eddd4958037fd1e4ee0d0769fe8a13e22f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;&amp;sup2;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;&amp;sup2;</target>
        </trans-unit>
        <trans-unit id="ce0ac41c7212c9c15eac72b6b1a4ff736bffb735" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;&amp;sup3;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;&amp;sup3;</target>
        </trans-unit>
        <trans-unit id="096230d99a385a337ad2d8bf471af997f8e84faa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;privatebranch&quot;&gt;Private Branches&lt;/a&gt;&amp;rarr; This document suggests procedures for maintaining a private branch or fork of SQLite and keeping that branch or fork in sync with the public SQLite source tree.</source>
          <target state="translated">&lt;a href=&quot;privatebranch&quot;&gt;개인 분기&lt;/a&gt; &amp;rarr;이 문서는 개인 분기 또는 SQLite 포크를 유지 관리하고 해당 분기 또는 포크를 공개 SQLite 소스 트리와 동기화하는 절차를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="3cb4be051dbc1c02b6c3e4a7e4589022aeadbeff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;queryplanner-ng&quot;&gt;The Next-Generation Query Planner&lt;/a&gt;&amp;rarr; Additional information about the SQLite query planner, and in particular the redesign of the query planner that occurred for version 3.8.0.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; &amp;rarr; SQLite 쿼리 플래너에 대한 추가 정보, 특히 버전 3.8.0에서 발생한 쿼리 플래너의 재 설계</target>
        </trans-unit>
        <trans-unit id="b70245f940ab056984003fb8adf2f4923854f5c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;quickstart&quot;&gt;SQLite In 3 Minutes Or Less&lt;/a&gt; and/or</source>
          <target state="translated">&lt;a href=&quot;quickstart&quot;&gt;3 분 이내&lt;/a&gt; 및 / 또는 SQLite</target>
        </trans-unit>
        <trans-unit id="b5ed43ac0ee13eb653779d0c4df20a4b2281696c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;quickstart&quot;&gt;SQLite In 5 Minutes Or Less&lt;/a&gt;&amp;rarr; A very quick introduction to programming with SQLite.</source>
          <target state="translated">&lt;a href=&quot;quickstart&quot;&gt;5 분 이내에 SQLite&lt;/a&gt; &amp;rarr; SQLite를 사용한 프로그래밍에 대한 빠른 소개.</target>
        </trans-unit>
        <trans-unit id="5479464413a4fb97b0ca593dfebeca3f7ce94c86" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;quirks&quot;&gt;Quirks of SQLite&lt;/a&gt;&amp;rarr; This document is a short list of some unusual features of SQLite that tend to cause misunderstandings and confusion. The list includes both deliberate innovations and &quot;misfeatures&quot; that are retained only for backwards compatibility.</source>
          <target state="translated">&lt;a href=&quot;quirks&quot;&gt;SQLite Quirks&lt;/a&gt; &amp;rarr;이 문서는 오해와 혼동을 일으키는 경향이있는 SQLite의 몇 가지 특이한 기능에 대한 간단한 목록입니다. 이 목록에는 이전 버전과의 호환성을 위해서만 유지되는 고의적 인 혁신과 &quot;부정한 기능&quot;이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="671585a590d31cefe3cd2c82f5a1ca31d5396074" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;&amp;rarr; The &quot;Resumable Bulk Update&quot; utility program allows a batch of changes to be applied to a remote database running on embedded hardware in a way that is resumeable and does not interrupt ongoing operation.</source>
          <target state="translated">&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; &amp;rarr; &quot;재개 가능한 대량 업데이트&quot;유틸리티 프로그램을 사용하면 재개 가능하고 지속적인 작동을 방해하지 않는 방식으로 임베디드 하드웨어에서 실행중인 원격 데이터베이스에 일괄 변경 사항을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cba8ad870718cd4e38b9a57b2ee2268cd4b46c87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rebaser&quot;&gt;sqlite3_rebaser&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;rebaser&quot;&gt;sqlite3_rebaser&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="71c4fb0470c553b6a2dc9b594fccdee970fab365" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rescode&quot;&gt;Result and Error Codes&lt;/a&gt;&amp;rarr; A description of the meanings of the numeric result codes returned by various C/C++ interfaces.</source>
          <target state="translated">&lt;a href=&quot;rescode&quot;&gt;결과 및 오류 코드&lt;/a&gt; &amp;rarr; 다양한 C / C ++ 인터페이스에서 리턴 된 숫자 결과 코드의 의미에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="a95733ff6676d206adadb44f7d4eb55f682b59d9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;: database in use by another process</source>
          <target state="translated">&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; : 다른 프로세스에서 사용중인 데이터베이스</target>
        </trans-unit>
        <trans-unit id="847627693ff21e374be6b21405f915af1416165b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;: database or disk full</source>
          <target state="translated">&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; : 데이터베이스 또는 디스크 가득 참</target>
        </trans-unit>
        <trans-unit id="a20953e53a2c72b7507ea0336b02b9e72bb96481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;: disk I/O error</source>
          <target state="translated">&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; : 디스크 I / O 오류</target>
        </trans-unit>
        <trans-unit id="79f49a36140bf66ab0c7366678358b178089328e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;: out or memory</source>
          <target state="translated">&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; : 출력 또는 메모리</target>
        </trans-unit>
        <trans-unit id="8f8f863ba1e87eded11c8a45eacf42d7b446fd54" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rtree&quot;&gt;R-Tree Module&lt;/a&gt;&amp;rarr; A description of the SQLite R-Tree extension. An R-Tree is a specialized data structure that supports fast multi-dimensional range queries often used in geospatial systems.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R- 트리 모듈&lt;/a&gt; &amp;rarr; SQLite R- 트리 확장에 대한 설명. R-Tree는 지형 공간 시스템에서 자주 사용되는 빠른 다차원 범위 쿼리를 지원하는 특수한 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="7591e90e60b92972e86a9a8923ebb0fd9e773c85" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;selfcontained&quot;&gt;Self-contained&lt;/a&gt;: no external dependencies.</source>
          <target state="translated">&lt;a href=&quot;selfcontained&quot;&gt;독립형&lt;/a&gt; : 외부 종속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d09be6ce67efb959942aa570716ca35d623501fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;&amp;rarr; A description of the generate_series() [table-valued function].</source>
          <target state="translated">&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; &amp;rarr; generate_series () [테이블 반환 함수]에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="230e6fb167c4223db634b26c54d4b4643fd72dc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sessionintro&quot;&gt;Sessions&lt;/a&gt;&amp;rarr; The Sessions extension allows change to an SQLite database to be captured in a compact file which can be reverted on the original database (to implement &quot;undo&quot;) or transferred and applied to another similar database.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; &amp;rarr; 세션 확장을 사용하면 SQLite 데이터베이스에 대한 변경을 압축 파일로 캡처하여 원본 데이터베이스에서 되돌 리거나 ( &quot;실행 취소&quot;를 구현하기 위해) 다른 유사한 데이터베이스로 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eece8a544a088a210af295837c78b9d112910f6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sharedcache&quot;&gt;Shared Cache Mode&lt;/a&gt;&amp;rarr; Version 3.3.0 and later supports the ability for two or more database connections to share the same page and schema cache. This feature is useful for certain specialized applications.</source>
          <target state="translated">&lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; &amp;rarr; 버전 3.3.0 이상은 둘 이상의 데이터베이스 연결이 동일한 페이지 및 스키마 캐시를 공유 할 수있는 기능을 지원합니다. 이 기능은 특정 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e352bb5c23f8de21d64545a18a49a20c330f7ef9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;shortnames&quot;&gt;8+3 Filenames&lt;/a&gt;&amp;rarr; How to make SQLite work on filesystems that only support 8+3 filenames.</source>
          <target state="translated">&lt;a href=&quot;shortnames&quot;&gt;8 + 3 파일 이름&lt;/a&gt; &amp;rarr; 8 + 3 파일 이름 만 지원하는 파일 시스템에서 SQLite를 작동시키는 방법.</target>
        </trans-unit>
        <trans-unit id="a18f14b5dd934e89b6e688ffef8ceafe0b6748a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;speed&quot;&gt;Speed Comparison&lt;/a&gt;&amp;rarr; The speed of version 2.7.6 of SQLite is compared against PostgreSQL and MySQL.</source>
          <target state="translated">&lt;a href=&quot;speed&quot;&gt;속도 비교&lt;/a&gt; &amp;rarr; SQLite 버전 2.7.6의 속도는 PostgreSQL 및 MySQL과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="e28a515fd65d8411a2a04beb909c2792f201c6ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;spellfix1&quot;&gt;Spellfix1&lt;/a&gt;&amp;rarr; The spellfix1 extension is an experiment in doing spelling correction for [full-text search].</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;Spellfix1&lt;/a&gt; &amp;rarr; spellfix1 확장은 [전체 텍스트 검색]에 대한 맞춤법 교정을 수행하는 실험입니다.</target>
        </trans-unit>
        <trans-unit id="8f70677f7daf9367f9e273a90e6c8e4a724a89c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqlanalyze&quot;&gt;SQLite Database Analyzer (sqlite3_analyzer.exe)&lt;/a&gt;&amp;rarr; This stand-alone program reads an SQLite database and outputs a file showing the space used by each table and index and other statistics. Built using the [dbstat virtual table].</source>
          <target state="translated">&lt;a href=&quot;sqlanalyze&quot;&gt;SQLite 데이터베이스 분석기 (sqlite3_analyzer.exe)&lt;/a&gt; &amp;rarr;이 독립 실행 형 프로그램은 SQLite 데이터베이스를 읽고 각 테이블과 인덱스 및 기타 통계에 사용 된 공간을 보여주는 파일을 출력합니다. [dbstat virtual table]을 사용하여 빌드되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8c1345a503c8b9893e7685bf16c69cd50932aec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqldiff&quot;&gt;SQLite Database Diff (sqldiff.exe)&lt;/a&gt;&amp;rarr; This stand-alone program compares two SQLite database files and outputs the SQL needed to convert one into the other.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;SQLite 데이터베이스 차이 (sqldiff.exe)&lt;/a&gt; &amp;rarr;이 독립 실행 형 프로그램은 두 개의 SQLite 데이터베이스 파일을 비교하여 하나를 다른 것으로 변환하는 데 필요한 SQL을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d0d414c5901fea015daeb90ccf94add74e3a9201" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqlite3rebaser_configure&quot;&gt;sqlite3rebaser_configure&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;sqlite3rebaser_configure&quot;&gt;sqlite3rebaser_configure&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe397aee0268851ccc19631348a5d7527245f822" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqlite3rebaser_create&quot;&gt;sqlite3rebaser_create&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;sqlite3rebaser_create&quot;&gt;sqlite3rebaser_create&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c2102fd6f96dde819dafbe9aa15b5073d03f6dd1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqlite3rebaser_delete&quot;&gt;sqlite3rebaser_delete&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;sqlite3rebaser_delete&quot;&gt;sqlite3rebaser_delete&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="93d57308ebc4fe3682adce42e84041c3bd3b0530" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sqlite3rebaser_rebase&quot;&gt;sqlite3rebaser_rebase&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</source>
          <target state="translated">&lt;a href=&quot;sqlite3rebaser_rebase&quot;&gt;sqlite3rebaser_rebase&lt;/a&gt;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4d03230f68fbea71b170a53f968de250f5d71910" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;syntax/common-table-expression&quot;&gt;Common table expression&lt;/a&gt; are not supported for statements inside of triggers.</source>
          <target state="translated">&lt;a href=&quot;syntax/common-table-expression&quot;&gt;&lt;/a&gt;트리거 내부의 명령문에는 공통 테이블 표현식 이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33fbc5d490ef6f8037a48c4a61f5780dfe709967" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tclsqlite&quot;&gt;Tcl API&lt;/a&gt;&amp;rarr; A description of the TCL interface bindings for SQLite.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;Tcl API&lt;/a&gt; &amp;rarr; SQLite에 대한 TCL 인터페이스 바인딩에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="402968c246d859e66ea321cdf18dd24e5f849e8d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tempfiles&quot;&gt;Temporary Files Used By SQLite&lt;/a&gt;&amp;rarr; SQLite can potentially use many different temporary files when processing certain SQL statements. This document describes the many kinds of temporary files that SQLite uses and offers suggestions for avoiding them on systems where creating a temporary file is an expensive operation.</source>
          <target state="translated">&lt;a href=&quot;tempfiles&quot;&gt;SQLite에서 사용하는 임시 파일&lt;/a&gt; &amp;rarr; SQLite는 특정 SQL 문을 처리 할 때 여러 가지 다른 임시 파일을 사용할 수 있습니다. 이 문서는 SQLite가 사용하는 많은 종류의 임시 파일을 설명하고 임시 파일을 만드는 것이 비용이 많이 드는 시스템에서 이러한 파일을 피하기위한 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cd360ea758a21c34b4a8aa4abe6cfb4daf5c0ca3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing&quot;&gt;How SQLite Is Tested&lt;/a&gt;&amp;rarr; The reliability and robustness of SQLite is achieved in large part by thorough and careful testing. This document identifies the many tests that occur before every release of SQLite.</source>
          <target state="translated">&lt;a href=&quot;testing&quot;&gt;SQLite의 테스트 방법&lt;/a&gt; &amp;rarr; 철저하고 신중한 테스트를 통해 SQLite의 안정성과 견고성이 크게 향상되었습니다. 이 문서는 모든 SQLite 릴리스 전에 발생하는 많은 테스트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="80a04dbc151357fd307e9afb76af9e255e0d511b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;threadsafe&quot;&gt;Multi-threaded Programs and SQLite&lt;/a&gt;&amp;rarr; SQLite is safe to use in multi-threaded programs. This document provides the details and hints on how to maximize performance.</source>
          <target state="translated">&lt;a href=&quot;threadsafe&quot;&gt;다중 스레드 프로그램 및 SQLite&lt;/a&gt; &amp;rarr; SQLite는 다중 스레드 프로그램에서 사용하기에 안전합니다. 이 문서는 성능을 최대화하는 방법에 대한 세부 사항과 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a834303147e6f7cfaf5bcff5fd1defecb618d65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;transactional&quot;&gt;Transactions&lt;/a&gt; are atomic, consistent, isolated, and durable (ACID) even after system crashes and power failures.</source>
          <target state="translated">&lt;a href=&quot;transactional&quot;&gt;트랜잭션&lt;/a&gt; 은 시스템 충돌 및 정전 후에도 원 자성, 일관성, 격리 및 내구성 (ACID)입니다.</target>
        </trans-unit>
        <trans-unit id="69b8f80261af60c42848405eb70b81e76ea6c4be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;unlock_notify&quot;&gt;Unlock Notify&lt;/a&gt;&amp;rarr; The &quot;unlock notify&quot; feature can be used in conjunction with [shared cache mode] to more efficiently manage resource conflict (database table locks).</source>
          <target state="translated">&lt;a href=&quot;unlock_notify&quot;&gt;잠금 해제 알림&lt;/a&gt; &amp;rarr; &quot; 알림 해제&quot;기능을 [공유 캐시 모드]와 함께 사용하여 리소스 충돌 (데이터베이스 테이블 잠금)을보다 효율적으로 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="07673362ffde2ad091111ef13ff4ad7dcd88f229" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;uri&quot;&gt;URI Filenames&lt;/a&gt;&amp;rarr; The names of database files can be specified using either an ordinary filename or a URI. Using URI filenames provides additional capabilities, as this document describes.</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; &amp;rarr; 데이터베이스 파일 이름은 일반 파일 이름이나 URI를 사용하여 지정할 수 있습니다. 이 문서에서 설명하는 것처럼 URI 파일 이름을 사용하면 추가 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="12590662cc9db6eba3564f41b3d37b067aa0f6f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; normally throws an error if the authority section is not either empty or &quot;localhost&quot;. However, if SQLite is compiled with the SQLITE_ALLOW_URI_AUTHORITY compile-time option, then the URI is converted into a Uniform Naming Convention (UNC) filename and passed down to the underlying operating system that way.</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;&lt;/a&gt;권한 섹션이 비어 있거나 &quot;localhost&quot;가 아닌 경우 URI 파일 이름은 일반적으로 오류를 발생시킵니다. 그러나 SQLite가 SQLITE_ALLOW_URI_AUTHORITY 컴파일 타임 옵션으로 컴파일 된 경우 URI는 UNC (Uniform Naming Convention) 파일 이름으로 변환되어 기본 운영 체제로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8d255bd308af4a3d827fbabc91d32c508e1d9cc7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;vdbe&quot;&gt;VDBE Tutorial&lt;/a&gt;&amp;rarr; The VDBE is the subsystem within SQLite that does the actual work of executing SQL statements. This page describes the principles of operation for the VDBE in SQLite version 2.7. This is essential reading for anyone who want to modify the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;vdbe&quot;&gt;VDBE 튜토리얼&lt;/a&gt; &amp;rarr; VDBE는 SQLite를 실행하는 실제 작업을 수행하는 SQLite 내의 하위 시스템입니다. 이 페이지는 SQLite 버전 2.7의 VDBE 작동 원리를 설명합니다. 이는 SQLite 소스를 수정하려는 모든 사람에게 필수적인 자료입니다.</target>
        </trans-unit>
        <trans-unit id="83f4321423f0c85ceffcf3b0874f660d62bfc2ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;version3&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;version3&quot;&gt;자세한 정보&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaff08a103299993a597ee75ac7dc6a621945e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;version3&quot;&gt;SQLite Version 3&lt;/a&gt;&amp;rarr; A summary of the changes between SQLite version 2.8 and SQLite version 3.0.</source>
          <target state="translated">&lt;a href=&quot;version3&quot;&gt;SQLite 버전 3&lt;/a&gt; &amp;rarr; SQLite 버전 2.8과 SQLite 버전 3.0 간의 변경 사항 요약</target>
        </trans-unit>
        <trans-unit id="bcd5b70c4b290cad72dd9d5e2ae89567c26f5cae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;vfs&quot;&gt;Virtual Filesystem&lt;/a&gt;&amp;rarr; The &quot;VFS&quot; object is the interface between the SQLite core and the underlying operating system. Learn more about how the VFS object works and how to create new VFS objects from this article.</source>
          <target state="translated">&lt;a href=&quot;vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; &amp;rarr; &quot;VFS&quot;개체는 SQLite 코어와 기본 운영 체제 간의 인터페이스입니다. VFS 객체의 작동 방식과이 기사에서 새로운 VFS 객체를 생성하는 방법에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="270e9a0159605d8d46c75221e12f2a0ed15b7955" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;vtab&quot;&gt;Virtual Tables&lt;/a&gt;&amp;rarr; This article describes the virtual table mechanism and API in SQLite and how it can be used to add new capabilities to the core SQLite library.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; &amp;rarr;이 기사에서는 SQLite의 가상 테이블 메커니즘 및 API와이를 사용하여 코어 SQLite 라이브러리에 새로운 기능을 추가하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b408021d7063e9c2eca44467f7b7b580995ccfa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; databases can be accessed in EXCLUSIVE mode without the use of shared memory. (&lt;a href=&quot;wal#noshm&quot;&gt;Additional information&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;&lt;/a&gt;공유 메모리를 사용하지 않고 EXCLUSIVE 모드에서 WAL 데이터베이스에 액세스 할 수 있습니다. ( &lt;a href=&quot;wal#noshm&quot;&gt;추가 정보&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e6cd3794820ef889cd9633be79f57630e5cc6cd2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;wal&quot;&gt;Write-Ahead Log (WAL) Mode&lt;/a&gt;&amp;rarr; Transaction control using a write-ahead log offers more concurrency and is often faster than the default rollback transactions. This document explains how to use WAL mode for improved performance.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그 (WAL) 모드&lt;/a&gt; &amp;rarr; 미리 쓰기 로그를 사용하는 트랜잭션 제어는 더 많은 동시성을 제공하며 종종 기본 롤백 트랜잭션보다 빠릅니다. 이 문서는 성능 향상을 위해 WAL 모드를 사용하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="db9aeda4beee88469cb1761c18d632b04f7291e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;whentouse&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt;&amp;rarr; This document describes situations where SQLite is an appropriate database engine to use versus situations where a client/server database engine might be a better choice.</source>
          <target state="translated">&lt;a href=&quot;whentouse&quot;&gt;SQLite의 적절한 사용&lt;/a&gt; &amp;rarr;이 문서는 SQLite가 사용하기에 적합한 데이터베이스 엔진 인 상황과 클라이언트 / 서버 데이터베이스 엔진이 더 나은 선택 일 수있는 상황을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ebf191632376494fef56b2861844a8aa5b00260" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID Tables&lt;/a&gt;&amp;rarr; The WITHOUT ROWID optimization is a option that can sometimes result in smaller and faster databases.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID 테이블&lt;/a&gt; &amp;rarr; WITHOUT ROWID 최적화는 때때로 더 작고 빠른 데이터베이스를 생성 할 수있는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="2b5278213e68e9778cd940251d583f6417e054a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zeroconf&quot;&gt;Zero-configuration&lt;/a&gt; - no setup or administration needed.</source>
          <target state="translated">&lt;a href=&quot;zeroconf&quot;&gt;제로 구성&lt;/a&gt; -설정이나 관리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf913ca9421c25de1abe7c44f3d9eaf868a9d50b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zipfile&quot;&gt;zipfile.c&lt;/a&gt; &amp;mdash; This extension implements the &quot;zipfile(FILE)&quot; table-valued function which is used to read ZIP archives. This extension is only needed when reading ZIP archives instead of SQLite archives.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;zipfile.c&lt;/a&gt; &amp;mdash;이 확장은 ZIP 아카이브를 읽는 데 사용되는 &quot;zipfile (FILE)&quot;테이블 반환 함수를 구현합니다. 이 확장은 SQLite 아카이브 대신 ZIP 아카이브를 읽을 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6811b7472c1e9bff3761b5dfe7c4915240c7975d" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;pragma_default_cache_size&quot;&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b id=&quot;pragma_default_cache_size&quot;&gt;PRAGMA &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="64aa4c0ecf4c05c7e23f514c8ee2af1db403717c" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/b&gt;</source>
          <target state="translated">&lt;b id=&quot;sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="906dbf8443d11e3690371bc51fb57266030830cd" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/b&gt;</source>
          <target state="translated">&lt;b id=&quot;sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40d019ffd89e6325ca6c127488d5127912091260" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;sqlite3backuppagecount&quot;&gt;sqlite3_backup_remaining() and sqlite3_backup_pagecount()&lt;/b&gt;</source>
          <target state="translated">&lt;b id=&quot;sqlite3backuppagecount&quot;&gt;sqlite3_backup_remaining () 및 sqlite3_backup_pagecount ()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="304a0cd8c2b1aa920e3c11adc74e25efe9529c29" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/b&gt;</source>
          <target state="translated">&lt;b id=&quot;sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="704f3e508e8d8d39b75957eb1806b91b1206567a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; *** Alpha Release - Research And Testing Use Only ***&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; *** 알파 릴리스-연구 및 테스트 전용 ***&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7cefb33e8ab13bd487d7dd4384b1856bf4bb55af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; DEFAULT VALUES;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; 기본 값;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f9681dc40bdf6965b38ed2411e2feb998953f6ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; EXCLUDE CURRENT ROW&lt;/b&gt;: In this case the current row is excluded from the window frame. Peers of the current row remain in the frame for the GROUPS and RANGE frame types.</source>
          <target state="translated">&lt;b&gt;EXCLUDE CURRENT ROW&lt;/b&gt; :이 경우 현재 행이 창 프레임에서 제외됩니다. 현재 행의 피어는 GROUPS 및 RANGE 프레임 유형의 프레임에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e08983ac51b8712e8f326561c5df331df4ad72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; EXCLUDE GROUP&lt;/b&gt;: In this case the current row and all other rows that are peers of the current row are excluded from the frame. When processing an EXCLUDE clause, all rows with the same ORDER BY values, or all rows in the partition if there is no ORDER BY clause, are considered peers, even if the frame type is ROWS.</source>
          <target state="translated">&lt;b&gt;EXCLUDE GROUP&lt;/b&gt; :이 경우 현재 행과 현재 행의 피어 인 다른 모든 행은 프레임에서 제외됩니다. EXCLUDE 절을 처리 할 때 프레임 유형이 ROWS 인 경우에도 ORDER BY 값이 동일한 모든 행 또는 ORDER BY 절이없는 경우 파티션의 모든 행은 피어로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f25059e206945898d98c0ea6307514aa2d066e3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; EXCLUDE NO OTHERS&lt;/b&gt;: This is the default. In this case no rows are excluded from the window frame as defined by its starting and ending frame boundaries.</source>
          <target state="translated">&lt;b&gt;다른 사람 제외&lt;/b&gt; : 이것이 기본값입니다. 이 경우 시작 및 끝 프레임 경계에 의해 정의 된대로 창 프레임에서 행이 제외되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97d280e9134394c88de0729725c1ba04e640799b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; EXCLUDE TIES&lt;/b&gt;: In this case the current row is part of the frame, but peers of the current row are excluded.</source>
          <target state="translated">&lt;b&gt;EXCLUDE TIES&lt;/b&gt; :이 경우 현재 행은 프레임의 일부이지만 현재 행의 피어는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f952a78c369b77691bd553882a5eb4f70f0acec1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; Note: This document is very very old. It describes a speed comparison between archaic versions of SQLite, MySQL and PostgreSQL. &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;참고 :이 문서는 매우 오래되었습니다. SQLite, MySQL 및 PostgreSQL의 구식 버전 간의 속도 비교에 대해 설명합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="752b123e9f4b08702bc84e3edd70919abf493fd9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; PRAGMA &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19ed7bd689658dc4cd7be801076fbd1aa8662d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; SELECT ...;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; 고르다 ...;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d6e895043900c5975b4b3ea380fda6f8ba6f187" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; Security Warning:&lt;/b&gt; Because it is just an ordinary SQL function, rank() may be invoked as part of any SQL query in any context. This means that the first argument passed may not be a valid matchinfo blob. Implementors should take care to handle this case without causing buffer overruns or other potential security problems.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 일반적인 SQL 함수이므로 rank ()는 모든 컨텍스트에서 SQL 쿼리의 일부로 호출 될 수 있습니다. 이는 전달 된 첫 번째 인수가 유효한 matchinfo blob이 아닐 수 있음을 의미합니다. 구현자는 버퍼 오버런이나 기타 잠재적 인 보안 문제를 일으키지 않고이 경우를 처리하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e4d9771fc6ff459e1be6a01dd5cd180f71a1cd1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; This document is a work-in-progress. It is incomplete and unverified. &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;이 문서는 진행 중입니다. 불완전하고 검증되지 않았습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d759e4949dc21a3fb00af2e7989572f9990636d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; VALUES(...);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; VALUES(...);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8d2307f646750eba433fac072454f777a30da22" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; xDelete:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; xDelete:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25a93d3a3d5adb9d17f5ebe4e2f080fef62bb472" translate="yes" xml:space="preserve">
          <source>&lt;b&gt; xTokenize:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt; xTokenize:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceae6d9068526e25ce729540b7629cf70231ff02" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;!&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2a54bf8f1c76da5242b319615fedbaba05adb948" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;#&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;#&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="60c7bf28588cf14027311a2e6a1d66a464119682" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;$&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;$&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddb3ade75fc56e43a32922429a6ee0852bf973ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&amp;gt;=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;gt;=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef93d254e9f12336b0eac14443131f8b21793d4c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&amp;lt;=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;lt;=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76c27abd353a6e860ea25086f8e4c3ad21c285b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&amp;lt;expr&amp;gt; FOLLOWING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;lt;expr&amp;gt; 다음&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2367ca706fe7274c8cfc5e77427d166b90d2b62e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;lt;expr&amp;gt; 선행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33b4ad6baf6eafc5c6c65c7851b7b7c957557ba4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;';&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;';&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf9c84c606cbea53b5769c7f74d21af80290a86a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(1) How do I create an AUTOINCREMENT field?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(1) AUTOINCREMENT 필드는 어떻게 만듭니 까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9882049d899e0d549295a62a0fe77b42754f3866" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(10) Does SQLite support a BLOB type?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(10) SQLite는 BLOB 유형을 지원합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668075f28f5a83e930a1a9e5f588596ebb45bf60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(11) How do I add or delete columns from an existing table in SQLite.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(11) SQLite의 기존 테이블에서 열을 추가하거나 삭제하는 방법&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8a025467e1b373e8cb2c56dbd924cd8c82008870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(12) I deleted a lot of data but the database file did not get any smaller. Is this a bug?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(12) 많은 데이터를 삭제했지만 데이터베이스 파일이 더 작아지지 않았습니다. 이것이 버그입니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebed30c5ee6bcaa2f8adc66d04b1762e53945a17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(13) Can I use SQLite in my commercial product without paying royalties?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(13) 로열티를 지불하지 않고 상용 제품에 SQLite를 사용할 수 있습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="06781d28aa520ed9499b96d77ef36693fea294dc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(14) How do I use a string literal that contains an embedded single-quote (') character?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(14) 작은 따옴표 ( ') 문자가 포함 된 문자열 리터럴을 어떻게 사용합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3217e17f1c3991a421d2eded1889c8ef3e61948a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(15) What is an SQLITE_SCHEMA error, and why am I getting one?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(15) SQLITE_SCHEMA 오류는 무엇이며 왜 발생합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9817ac0bd78123cd9508de2639c5a1f197bd1b3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(16) Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn't 9.95 round up?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(16) ROUND (9.95,1)가 10.0 대신 9.9를 반환하는 이유는 무엇입니까? 9.95를 반올림해서는 안됩니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="230ec6989c0e8e2d75b3b1c14f9c341b9f0b8ea7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(17) I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(17) SQLite를 컴파일 할 때 컴파일러 경고가 발생합니다. 이것이 문제가되지 않습니까? 코드 품질이 좋지 않습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8b87ccde63f950ec2a60831ddb8acaf66adfe659" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(18) Case-insensitive matching of Unicode characters does not work.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(18) 대소 문자를 구분하지 않는 유니 코드 문자 일치는 작동하지 않습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7827fcbce45729e26966dc7dadcc37db74ebf5d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(19) INSERT is really slow - I can only do few dozen INSERTs per second&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(19) INSERT는 실제로 느리다-초당 수십 개의 INSERT 만 할 수있다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdf59d4398a2fe3bb2f9ad8403fed372b05b3ace" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(2) What datatypes does SQLite support?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(2) SQLite는 어떤 데이터 유형을 지원합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ea2e723be19e58a6a7e80950c6300a82fc2facd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(20) I accidentally deleted some important information from my SQLite database. How can I recover it?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(20) 실수로 SQLite 데이터베이스에서 중요한 정보를 삭제했습니다. 어떻게 복구 할 수 있습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48aa7a79c27727cffca37eb946dcc3173dc1129d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(21) What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting this error?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(21) SQLITE_CORRUPT 오류는 무엇입니까? 데이터베이스가 &quot;잘못된&quot;다는 것은 무엇을 의미합니까? 이 오류가 발생하는 이유는 무엇입니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="93886e00582e9ded504e6537b12b06cbb1197365" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(22) Does SQLite support foreign keys?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(22) SQLite는 외래 키를 지원합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="beb654854590008864ebd2262a24c439213ee7f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(23) I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(23) SQLite를 빌드 할 때 SQLITE_OMIT _... 컴파일 타임 옵션을 사용하면 컴파일러 오류가 발생합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="991986f84bcc4c709f987899dd9f790a0f245344" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(24) My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(24) WHERE 절 표현식 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 이 작동하지 않습니다. column1의 값이 &quot;column1&quot;인 행뿐만 아니라 테이블의 모든 행이 리턴됩니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02dbf738711f510339ac2e6bd5b6bb094b5ade26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(25) How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(25) SQLite에 대한 구문 다이어그램 (일명 &quot;철도&quot;다이어그램)은 어떻게 생성됩니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e334912753866621140be0a6e4d074f86925c8d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(26) The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(26) SQL 표준에서는 제약 조건에있는 하나 이상의 열이 NULL 인 경우에도 UNIQUE 제약 조건을 적용해야하지만 SQLite는이를 수행하지 않습니다. 그게 버그 아니야?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf315a1205476654e3cdf38e083628c16295451e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(27) What is the Export Control Classification Number (ECCN) for SQLite?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(27) SQLite에 대한 ECCN (Export Control Classification Number)은 무엇입니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e57aeed99fc4878fb4f20047509cd02bd061ddd8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(28) My query does not return the column name that I expect. Is this a bug?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(28) 쿼리가 예상 한 열 이름을 반환하지 않습니다. 이것이 버그입니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="79c0afa7b766c08b6ce9a88d8fbf46ee9b385dc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(3) SQLite lets me insert a string into a database column of type integer!&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(3) SQLite를 사용하면 정수 유형의 데이터베이스 열에 문자열을 삽입 할 수 있습니다!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3cfd21578eb466c317ee7a10c3ed14339f461572" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(4) Why doesn't SQLite allow me to use '0' and '0.0' as the primary key on two different rows of the same table?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(4) SQLite에서 왜 동일한 테이블의 두 개의 다른 행에서 '0'과 '0.0'을 기본 키로 사용할 수 없습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d4bfe6a433f0b7960075ec18ba555747f30059e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(5) Can multiple applications or multiple instances of the same application access a single database file at the same time?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(5) 여러 응용 프로그램 또는 같은 응용 프로그램의 여러 인스턴스가 단일 데이터베이스 파일에 동시에 액세스 할 수 있습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5723e424e8a7de93ec43ce5143ade3b05bbcf674" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(6) Is SQLite threadsafe?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(6) SQLite는 안전합니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a9a68baa5cbb98080ef84bc15baa0e8ebae2550" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(7) How do I list all tables/indices contained in an SQLite database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(7) SQLite 데이터베이스에 포함 된 모든 테이블 / 표시를 나열하는 방법&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fca4502c4a68eb95fe06055f3d0a583bc7745e19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(8) Are there any known size limits to SQLite databases?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(8) SQLite 데이터베이스에 알려진 크기 제한이 있습니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c529dcefacda9f204d399c964361fd922d61150d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(9) What is the maximum size of a VARCHAR in SQLite?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;(9) SQLite에서 VARCHAR의 최대 크기는 얼마입니까?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8b97335159e949a2bbe71424bebb77cf3d59e84" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)&lt;/b&gt; - Same as FTS5_TOKENIZE_QUERY, except that the bareword or quoted string is followed by a &quot;*&quot; character, indicating that the last token returned by the tokenizer will be treated as a token prefix.</source>
          <target state="translated">&lt;b&gt;(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)-FTS5_TOKENIZE_QUERY&lt;/b&gt; 와 동일합니다. 단, 따옴표 나 따옴표로 묶인 문자열 뒤에 &quot;*&quot;문자가 오는 것을 제외하고는 토크 나이저가 반환 한 마지막 토큰이 토큰 접두사로 처리됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7cba1ca4dc3498123c95bc5c43ff6622cb8f877" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;); &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;); &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="67868d12674d7da2538a0cedae570f2d6a0ec0e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2cad33ec00064442e42ac77da6f245aad8b2418f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="67bc5fc211d0c822604ade3edc51f43191fc07b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;+&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;+&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="737ac8c595045b895a70a5fd0a0c1cb5a34fb108" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;,&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;,&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8791d597f6089c8bf0b51f0b7b285a62756572f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--changeset FILE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--changeset 파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="056a5975049e92f5af2a2af048491b19b92795b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--lib LIBRARY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--lib 라이브러리&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96f9084803aeef9f4ddab8d0cc58d7199c5054af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--primarykey&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--primarykey&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="af63fe6906196232ac0dd4ff9857249a260e87ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--schema&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--schema&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a886cdd0d6644a3299de6a89850647c5ea1b02ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--summary&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--summary&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dba8eec6e4a49556ef9d20e7aa60b010fc74ec5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--table TABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-테이블 테이블&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca4ab8e74d0d5de4d4e01acc2b6e60bfbd91fab8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--transaction&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--transaction&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e350b15a9d308265ed858b16b76071213b7a3f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;--vtab&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;--vtab&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96e86cbe97a79dd888e437aa202e44226be81c3b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c191561f1e666680eba92b6cbd188f16463876e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-DSQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt; - This enables some extra APIs that are required by some common systems, including Ruby-on-Rails.</source>
          <target state="translated">&lt;b&gt;-DSQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt; -Ruby-on-Rails를 포함하여 일부 공통 시스템에 필요한 일부 추가 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc4f80fc206b7ae7618ca0f8bb2e6c1dedf28ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-DSQLITE_ENABLE_FTS4&lt;/b&gt; - Include the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; engine code in SQLite.</source>
          <target state="translated">&lt;b&gt;-DSQLITE_ENABLE_FTS4 &lt;/b&gt;&lt;a href=&quot;fts3&quot;&gt;-&lt;/a&gt; SQLite에 전체 텍스트 검색 엔진 코드를 포함시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d0883c33a3b1c3b49dc377e8aec4a6d07f77811f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-DSQLITE_ENABLE_RTREE&lt;/b&gt; - Include the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-DSQLITE_ENABLE_RTREE &lt;/b&gt;&lt;a href=&quot;rtree&quot;&gt;-R-Tree 확장을&lt;/a&gt; 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="04411564bde84dde1be8ab322d130e43b08a155c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-L LIBRARY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-L 라이브러리&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6786f6ede92580c5c3986ba578c12e50d4fcba69" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-O2&lt;/b&gt; - Optimize for speed. This will make the DLL larger by unrolling loops and inlining functions.</source>
          <target state="translated">&lt;b&gt;-O2-&lt;/b&gt; 속도를 최적화합니다. 이렇게하면 루프를 풀고 함수를 인라인하여 DLL을 더 크게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="114c93d8cffcb7ece6ab585bf3384f37a54a3abd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;-Os&lt;/b&gt; - Optimize for size. Make the DLL as small as possible.</source>
          <target state="translated">&lt;b&gt;-Os-&lt;/b&gt; 크기를 최적화합니다. DLL을 가능한 작게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="e777a40e9584fb1e8dce43b4c619feb904fbf579" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ff8972a8ebbde75a2b9290e97c9fc02164aae9df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.&lt;/b&gt; prefix on the table name is not allowed within triggers. If the table to which the trigger is attached is not in the temp database, then DELETE statements within the trigger body must operate on tables within the same database as it. If the table to which the trigger is attached is in the TEMP database, then the unqualified name of the table being deleted is resolved in the same way as it is for a top-level statement (by searching first the TEMP database, then the main database, then any other databases in the order they were attached).</source>
          <target state="translated">&lt;b&gt;.&lt;/b&gt; 테이블 이름의 접두사는 트리거 내에서 허용되지 않습니다. 트리거가 첨부 된 테이블이 임시 데이터베이스에 없으면 트리거 본문 내의 DELETE 문은 동일한 데이터베이스 내의 테이블에서 작동해야합니다. 트리거가 첨부 된 테이블이 TEMP 데이터베이스에있는 경우, 삭제중인 테이블의 규정되지 않은 이름은 최상위 레벨 명령문과 동일한 방식으로 분석됩니다 (먼저 TEMP 데이터베이스를 검색하여 기본 연결된 순서대로 다른 데이터베이스).</target>
        </trans-unit>
        <trans-unit id="76f36975a4893d84fdfba330ba531fc960ae4a28" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.&lt;/b&gt; prefix on the table name of the UPDATE is not allowed within triggers. Unless the table to which the trigger is attached is in the TEMP database, the table being updated by the trigger program must reside in the same database as it. If the table to which the trigger is attached is in the TEMP database, then the unqualified name of the table being updated is resolved in the same way as it is for a top-level statement (by searching first the TEMP database, then the main database, then any other databases in the order they were attached).</source>
          <target state="translated">&lt;b&gt;.&lt;/b&gt; UPDATE 테이블 이름의 접두어는 트리거 내에서 허용되지 않습니다. 트리거가 접속 된 테이블이 TEMP 데이터베이스에 있지 않으면, 트리거 프로그램에 의해 갱신되는 테이블은 동일한 데이터베이스에 상주해야합니다. 트리거가 첨부 된 테이블이 TEMP 데이터베이스에있는 경우, 갱신중인 테이블의 규정되지 않은 이름은 최상위 레벨의 명령문과 동일한 방식으로 (TEMP 데이터베이스를 먼저 검색하여) 연결된 순서대로 다른 데이터베이스).</target>
        </trans-unit>
        <trans-unit id="561cae7021f321015ca871d384ce48e7812158ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.&lt;/b&gt;&quot; prefix on the table-name is supported for top-level INSERT statements only. The table name must be unqualified for INSERT statements that occur within &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statements. Similarly, the &quot;DEFAULT VALUES&quot; form of the INSERT statement is supported for top-level INSERT statements only and not for INSERT statements within triggers.</source>
          <target state="translated">&lt;b&gt;. &lt;/b&gt;&quot;table-name의 접두사는 최상위 레벨 INSERT 문에서만 지원됩니다. &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문 내에서 발생하는 INSERT 문에서는 테이블 이름이 규정되지 않아야합니다 . 마찬가지로, INSERT 문의&quot;DEFAULT VALUES &quot;형식은 최상위 트리거 내의 INSERT 문에 대해서는 레벨 INSERT 문에만 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9a6a27b1677b1d03c44dc4251548988a7019141" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.optimize(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;.optimize(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c1391848b7d30d6b42dae0bf8a925f90c8553ec0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.optimize; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;.optimize; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f428c959fe72467a698de5848763395c447e1f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;.rc&lt;/b&gt; - These files contain -D options to the compiler that are used by various notable downstreams.</source>
          <target state="translated">&lt;b&gt;.rc-&lt;/b&gt; 이 파일에는 다양한 주목할만한 다운 스트림에서 사용되는 컴파일러에 대한 -D 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef14163e9eb8f1650916b0e598f8e1ab1ad7080" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;0&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="855f12a870609a7f45f9fb316c63c24bcd71a2ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for equality lookups (implemented as a pair of opcodes &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;/&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; of &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;/&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;)</source>
          <target state="translated">&lt;b&gt;0x02로 OPFLAG_SEEKEQ&lt;/b&gt; :이 커서 만 (옵 코드의 쌍으로 구현 평등 조회에 사용됩니다 &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; / &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; 의 &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; / &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c6f4c10fd80cdaf6776dafe52c520e9169544b39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;0x08 OPFLAG_FORDELETE&lt;/b&gt;: This cursor is used only to seek and subsequently delete entries in an index btree. This is a hint to the storage engine that the storage engine is allowed to ignore. The hint is not used by the official SQLite b*tree storage engine, but is used by COMDB2.</source>
          <target state="translated">&lt;b&gt;0x08 OPFLAG_FORDELETE&lt;/b&gt; :이 커서는 인덱스 btree에서 항목을 찾은 후 삭제하는 데만 사용됩니다. 이는 스토리지 엔진이 무시할 수있는 스토리지 엔진에 대한 힌트입니다. 힌트는 공식 SQLite b * tree 저장 엔진에서 사용되지 않지만 COMDB2에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="763ade555d6aaa86344ad9ab6b3e454b8e1f4463" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;0x10 OPFLAG_P2ISREG&lt;/b&gt;: Use the content of register P2 as the root page, not the value of P2 itself.</source>
          <target state="translated">&lt;b&gt;0x10 OPFLAG_P2ISREG&lt;/b&gt; : 레지스터 P2의 내용을 P2 자체의 값이 아닌 루트 페이지로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e660e12f5e19240a0d95b062b8a2d025d23732e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;1 yes true on&lt;br/&gt;0 no false off&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;1 예 true on &lt;br/&gt;0 아니오 false off&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40a5996c4d58a3e268191452d50f13b8d55ce26f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;1. Determination of input data (FROM clause processing).&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;1. 입력 데이터 결정 (FROM 절 처리).&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="885f36629261dac49e97b89440ef217a4183025a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;2. WHERE clause filtering.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;2. WHERE 절 필터링.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e1c5af14e35fd4f8116b981defc5255f2b5ce03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;3. Generation of the set of result rows.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;3. 결과 행 세트 생성.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3eee95809e8458d31dfec82b2902f5002f206523" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;4. Removal of duplicate rows (DISTINCT processing).&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;4. 중복 행 제거 (DISTINCT 처리).&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f016f62a93e0a72fec1ab93abfeb58af08a4085c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ee9a83d7b79becb68d5e4f94e17db1f98799510" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;; &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;; &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6d2b84eb14e0a1c01c82b73a9de5fa8763af379" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3779166b01a51c3c954312dce62a93c6629d1a5a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="daebb5330e4e16b78593fba2107cc92787e39f4f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;;&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ae186ce89e4989ce0567238e8019bd91105b543" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; does not work on WITHOUT ROWID tables.&lt;/b&gt; The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; mechanism assumes the presence of a rowid and so it does not work on a WITHOUT ROWID table. An error is raised if the &quot;AUTOINCREMENT&quot; keyword is used in the CREATE TABLE statement for a WITHOUT ROWID table.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;autoinc&quot;&gt;&lt;/a&gt;WITHOUT ROWID 테이블에서는 AUTOINCREMENT 가 작동하지 않습니다. &lt;/b&gt;&lt;a href=&quot;autoinc&quot;&gt;자동 증가&lt;/a&gt; 가 ROWID 테이블을하지 않고도 작동하지 않도록 메커니즘은 ROWID의 존재를 가정하고. WITHOUT ROWID 테이블의 CREATE TABLE 문에서 &quot;AUTOINCREMENT&quot;키워드를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59dd15f02086bed1d534a3cd833dc26813e4022a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Store application data into &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; of the original SQL.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt;&lt;/b&gt; &amp;rarr; 응용 프로그램 데이터를원본 SQL의&lt;a href=&quot;lang_expr#varparam&quot;&gt; 매개 변수&lt;/a&gt; 에저장합니다.</target>
        </trans-unit>
        <trans-unit id="ab70b2abd3fa3f710b214b1bcc8c5718fdf109eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer&lt;/a&gt;(S,I,P,T,D)&lt;/b&gt; &amp;rarr; Bind pointer P of type T to the I-th parameter of prepared statement S. D is an optional destructor function for P.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer&lt;/a&gt; (S, I, P, T, D)&lt;/b&gt; &amp;rarr; 유형 T의 포인터 P를 준비된 명령문 S의 i 번째 매개 변수에 바인드하십시오. D는 P의 선택적 소멸자 함수입니다.</target>
        </trans-unit>
        <trans-unit id="6e981c91af1a03479ec45dbc349a2de075c7c4e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="57cbd5810b446c58480ec668df818e28dd35d697" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Destructor for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt;&lt;/b&gt; &amp;rarr;&lt;a href=&quot;c3ref/sqlite3&quot;&gt; sqlite3의&lt;/a&gt; 소멸자.</target>
        </trans-unit>
        <trans-unit id="5fbd123d32d15a37bb0b50dba8ec3ce3e0518275" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f74bf248a537f24cf9dabde58a97e5713adf7254" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Column values in the current result row for an &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()&lt;/a&gt;&lt;/b&gt; 현재 결과 행 &amp;rarr; 열 값&lt;a href=&quot;c3ref/stmt&quot;&gt; sqlite3_stmt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="645269c38950aad3bed19c12072ff33bf501c923" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;&lt;/b&gt; &amp;rarr; A wrapper function that does &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt;, and &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; for a string of one or more SQL statements.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt;&lt;/b&gt; &amp;rarr;하나 이상의 SQL 문의 문자열에 대해&lt;a href=&quot;c3ref/prepare&quot;&gt; sqlite3_prepare ()&lt;/a&gt; ,&lt;a href=&quot;c3ref/step&quot;&gt; sqlite3_step ()&lt;/a&gt; ,&lt;a href=&quot;c3ref/column_blob&quot;&gt; sqlite3_column ()&lt;/a&gt; 및&lt;a href=&quot;c3ref/finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt; 를 수행하는랩퍼 함수.</target>
        </trans-unit>
        <trans-unit id="639569adb38c6ba8368be9fecec5da0711878e6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cbe4a2679e2dbb671b717f20369605adb9eb94c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Destructor for &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;&lt;/b&gt; &amp;rarr;&lt;a href=&quot;c3ref/stmt&quot;&gt; sqlite3_stmt의&lt;/a&gt; 소멸자.</target>
        </trans-unit>
        <trans-unit id="d59ffea08570892eba0ed8d0c3aed5f0162390d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ea7f92ba612e83c944cf15b194ef6eeefe6de776" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Open a connection to a new or existing SQLite database. The constructor for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt;&lt;/b&gt; &amp;rarr; 새로운 또는 기존 SQLite 데이터베이스에 대한 연결을 엽니 다. 생성자&lt;a href=&quot;c3ref/sqlite3&quot;&gt; sqlite3를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b6af56fd8296dafa16776565e5164ff99942c56" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4e0265d5e2a7dd30bb173f7097cb3d7290ef32c1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Compile SQL text into byte-code that will do the work of querying or updating the database. The constructor for &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt;&lt;/b&gt; &amp;rarr; 데이터베이스 쿼리 또는 업데이트 작업을 수행하는 SQL 텍스트를 바이트 코드로 컴파일합니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 의 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="c5531218a3e79a0aa7406d947ebfff43cf87436c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer&lt;/a&gt;(C,P,T,D)&lt;/b&gt; &amp;rarr; Return pointer P of type T as the argument of function C. D is an optional destructor function for P.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer&lt;/a&gt; (C, P, T, D)&lt;/b&gt; &amp;rarr; 함수 C의 인수로 T 유형의 포인터 P를 반환합니다. D는 P의 선택적 소멸자 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1d37507f9c70f1fd4b3f95d3a27e9736b9b5973c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;&lt;/b&gt; &amp;rarr; The database connection object. Created by &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;&lt;/b&gt; &amp;rarr; 데이터베이스 연결 객체. 만든&lt;a href=&quot;c3ref/open&quot;&gt; sqlite3_open ()를&lt;/a&gt; 에 의해 파괴&lt;a href=&quot;c3ref/close&quot;&gt; sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2416bb22ef4fd56a03eb2fbd58a2c0fd8f08411" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1f67be9d78b2fffbcc49dbb36587b5c00a513cb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;&lt;/b&gt; &amp;rarr; Advance an &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; to the next result row or to completion.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt;&lt;/b&gt; &amp;rarr;다음 결과 행 또는 완료로&lt;a href=&quot;c3ref/stmt&quot;&gt; sqlite3_stmt&lt;/a&gt; 를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="c89d4f49a285c4b06a7ad8ff94064e5ca6c2e6d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;&lt;/b&gt; &amp;rarr; The prepared statement object. Created by &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and destroyed by &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;&lt;/b&gt; &amp;rarr; 준비된 명령문 오브젝트. 만든&lt;a href=&quot;c3ref/prepare&quot;&gt; sqlite3_prepare ()를&lt;/a&gt; 에 의해 파괴&lt;a href=&quot;c3ref/finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08eebebaf33ffb444d8db2405c88ff5d6cef5e18" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer&lt;/a&gt;(V,T)&lt;/b&gt; &amp;rarr; Return the pointer of type T associated with value V, or if V has no associated pointer, or if the pointer on V is of a type different from T, then return NULL.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer&lt;/a&gt; (V, T)&lt;/b&gt; &amp;rarr; 값 V와 연관된 T 유형의 포인터를 반환하거나 V에 연관된 포인터가 없거나 V의 포인터가 T와 다른 유형 인 경우 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abaa92711ed5a18658e0921eaaf01ac55ed0309f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;carray&quot;&gt;carray&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;carray&quot;&gt;carray&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eeebad716ace451a39c5fe7cfbc1539e98cfb5db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; Enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 향상 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2469f59a6d0a137982b4266edfbdcd11be3bc7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;&lt;/b&gt;. This setting causes the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interfaces that track memory usage to be disabled. This helps the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; routines run much faster, and since SQLite uses &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; internally, this helps to make the entire library faster.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt;&lt;/b&gt; . 이 설정은메모리 사용량을 추적하는&lt;a href=&quot;c3ref/status&quot;&gt; sqlite3_status ()&lt;/a&gt; 인터페이스가 비활성화되도록합니다. 이것은&lt;a href=&quot;c3ref/free&quot;&gt; sqlite3_malloc ()&lt;/a&gt; 루틴이 훨씬 빠르게 실행되는데 도움이되고 SQLite는&lt;a href=&quot;c3ref/free&quot;&gt; sqlite3_malloc ()을&lt;/a&gt; 내부적으로 사용하므로 전체 라이브러리를 더 빠르게 만드는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="589439895f53d55b9d43edf2171a23d98d1aa6ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;&lt;/b&gt;. For maximum database safety following a power lose, the setting of &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=FULL&lt;/a&gt; is recommended. However, in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, complete database integrity is guaranteed with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=NORMAL&lt;/a&gt;. With &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=NORMAL&lt;/a&gt; in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, recent changes to the database might be rolled back by a power loss, but the database will not be corrupted. Furthermore, transaction commit is much faster in WAL mode using synchronous=NORMAL than with the default synchronous=FULL. For these reasons, it is recommended that the synchronous setting be changed from FULL to NORMAL when switching to WAL mode. This compile-time option will accomplish that.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt;&lt;/b&gt; . 정전시 데이터베이스 안전을 최대화&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt; 하려면 PRAGMA synchronous = FULL&lt;/a&gt; 설정을권장합니다. 그러나&lt;a href=&quot;wal&quot;&gt; WAL 모드&lt;/a&gt; 에서는&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt; PRAGMA synchronous = NORMAL로&lt;/a&gt; 완전한 데이터베이스 무결성이 보장됩니다. 으로&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt; PRAGMA 동기 = NORMAL&lt;/a&gt; 에서&lt;a href=&quot;wal&quot;&gt; WAL 모드&lt;/a&gt; , 데이터베이스에 대한 최근 변경 사항은 전력 손실로 롤백 할 수 있지만 데이터베이스가 손상되지 않습니다. 또한 트랜잭션 커밋은 기본 synchronous = FULL보다 synchronous = NORMAL을 사용하는 WAL 모드에서 훨씬 빠릅니다. 이러한 이유로 WAL 모드로 전환 할 때 동기 설정을 FULL에서 NORMAL로 변경하는 것이 좋습니다. 이 컴파일 타임 옵션이이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7b193aba71bb707029a4103e44e57679999753e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#dqs&quot;&gt;SQLITE_DQS=0&lt;/a&gt;&lt;/b&gt;. This setting disables the &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#dqs&quot;&gt;SQLITE_DQS = 0&lt;/a&gt;&lt;/b&gt; . 이 설정은&lt;a href=&quot;quirks#dblquote&quot;&gt; 큰 따옴표로 묶인 문자열 리터럴&lt;/a&gt; 오작동을비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1e6513755f0b6dc718ffb075a94bcbd66f319e20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;&lt;/b&gt;. Historically, SQLite has allowed BLOB operands to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators. But having a BLOB as an operand of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; complicates and slows the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt;. When this option is set, it means that the LIKE and GLOB operators always return FALSE if either operand is a BLOB. That simplifies the implementation of the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; and allows queries that use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; to run faster.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;&lt;/b&gt; . 역사적으로 SQLite는 BLOB 피연산자를&lt;a href=&quot;lang_expr#like&quot;&gt; LIKE&lt;/a&gt; 및&lt;a href=&quot;lang_expr#glob&quot;&gt; GLOB&lt;/a&gt; 연산자에 허용했습니다. 그러나&lt;a href=&quot;lang_expr#glob&quot;&gt; BLIKE&lt;/a&gt; 를&lt;a href=&quot;lang_expr#like&quot;&gt; LIKE&lt;/a&gt; 또는 GLOB 의 피연산자로 사용하면&lt;a href=&quot;optoverview#like_opt&quot;&gt; LIKE 최적화&lt;/a&gt; 가 복잡해지고 느려집니다. 이 옵션을 설정하면 피연산자 중 하나가 BLOB 인 경우 LIKE 및 GLOB 연산자는 항상 FALSE를 반환합니다. 즉,의 구현을 단순화&lt;a href=&quot;optoverview#like_opt&quot;&gt; LIKE 최적화&lt;/a&gt; 하고 사용하는 쿼리 수&lt;a href=&quot;optoverview#like_opt&quot;&gt; LIKE 최적화를&lt;/a&gt; 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed465e656ef3e7b59f47b1f7399fdf905672470a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#omit_decltype&quot;&gt;SQLITE_OMIT_DECLTYPE&lt;/a&gt;&lt;/b&gt;. By omitting the (seldom-needed) ability to return the declared type of columns from the result set of query, &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; can be made to consume less memory.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#omit_decltype&quot;&gt;SQLITE_OMIT_DECLTYPE&lt;/a&gt;&lt;/b&gt; . 쿼리 결과 집합에서 선언 된 유형의 열을 반환하는 (거의 필요하지 않은) 기능을 생략함으로써메모리를 덜 사용하도록&lt;a href=&quot;c3ref/stmt&quot;&gt; 준비된 명령문을&lt;/a&gt; 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="332df3f707bef9403ee3e71df8bb3d0469f6f627" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;&lt;/b&gt;. Omitting deprecated interfaces and features will not help SQLite to run any faster. It will reduce the library footprint, however. And it is the right thing to do.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;&lt;/b&gt; . 더 이상 사용되지 않는 인터페이스 및 기능을 생략해도 SQLite가 더 빨리 실행되는 데 도움이되지 않습니다. 그러나 라이브러리 공간을 줄입니다. 그리고 옳은 일입니다.</target>
        </trans-unit>
        <trans-unit id="dd412c3dc340a66b4394607d7c46273b57e0805a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#omit_progress_callback&quot;&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;&lt;/b&gt;. The progress handler callback counter must be checked in the inner loop of the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt;. By omitting this interface, a single conditional is removed from the inner loop of the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt;, helping SQL statements to run slightly faster.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#omit_progress_callback&quot;&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;&lt;/b&gt; . &lt;a href=&quot;opcode&quot;&gt;바이트 코드 엔진&lt;/a&gt; 의 내부 루프에서 진행 처리기 콜백 카운터를 확인해야합니다. 이 인터페이스를 생략하면&lt;a href=&quot;opcode&quot;&gt; 바이트 코드 엔진&lt;/a&gt; 의 내부 루프에서 단일 조건이 제거되어SQL 문이 약간 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e0cdb08c7789590fab1c8de9a1b1175df3617575" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#omit_shared_cache&quot;&gt;SQLITE_OMIT_SHARED_CACHE&lt;/a&gt;&lt;/b&gt;. Omitting the possibility of using &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; allows many conditionals in performance-critical sections of the code to be eliminated. This can give a noticable improvement in performance.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#omit_shared_cache&quot;&gt;SQLITE_OMIT_SHARED_CACHE&lt;/a&gt;&lt;/b&gt; . &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 사용 가능성을 생략하면코드의 성능에 중요한 섹션에서 많은 조건을 제거 할 수 있습니다. 이로 인해 성능이 눈에 띄게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f7ffd5a5ea425e172063da4272aa25c85096f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt;&lt;/b&gt;. Setting -DSQLITE_THREADSAFE=0 causes all of the mutex and thread-safety logic in SQLite to be omitted. This is the single compile-time option that makes the most difference in optimizing the performance of SQLite.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;&lt;/b&gt; . -DSQLITE_THREADSAFE = 0을 설정하면 SQLite의 모든 뮤텍스 및 스레드 안전성 로직이 생략됩니다. 이는 SQLite의 성능 최적화에서 가장 큰 차이를 만드는 단일 컴파일 타임 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="6d31da9a48b4692883bd92d02c0ea34bd04c220e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;compile#use_alloca&quot;&gt;SQLITE_USE_ALLOCA&lt;/a&gt;&lt;/b&gt;. Make use of alloca() for dynamically allocating temporary stack space for use within a single function, on systems that support alloca(). Without this option, temporary space is allocated from the heap.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;compile#use_alloca&quot;&gt;SQLITE_USE_ALLOCA&lt;/a&gt;&lt;/b&gt; . alloca ()를 지원하는 시스템에서 단일 함수 내에서 사용할 임시 스택 공간을 동적으로 할당하기 위해 alloca ()를 사용하십시오. 이 옵션이 없으면 임시 공간이 힙에서 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="d5a8c908e85376d7e4fc03cc70f919293461550b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;completion&quot;&gt;completion&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;completion&quot;&gt;completion&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ca37e336466c1da9d6ee24721d2d46abe9e7037" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;csv&quot;&gt;csv&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;csv&quot;&gt;csv&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="303c76351b375f067d2618634912477bd086013d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="59fe4e02185e8baa1f2552d3436732a0f4d1f831" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;dbstat&quot;&gt;dbstat&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;dbstat&quot;&gt;dbstat&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4a0a76aaa673ba6f7421879dfd9bb64677a0d94d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5014f8e8c8da250472b9ff4cb2b9227f71d80f0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="163a73b33104767b25c10b8657b5d23570020a1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://fossil-scm.org/fossil/file/src/foci.c&quot;&gt;files_of_checkin&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://fossil-scm.org/fossil/file/src/foci.c&quot;&gt;files_of_checkin&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d5ac2bba09285e89d2130ef622d86666dd058422" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://osquery.readthedocs.io/en/stable/&quot;&gt;OsQuery&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://osquery.readthedocs.io/en/stable/&quot;&gt;OsQuery&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c5f2c4a96ebc98cd9451395954b4ba275e3d0bdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/amatch.c&quot;&gt;approximate_match&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/amatch.c&quot;&gt;approximate_match&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="57b0b3c1fd9764f171a360aefb6c034eff59ec07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b2087ae917a8f24cc0915b759456bd7a8e9de41c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/closure.c&quot;&gt;closure&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/closure.c&quot;&gt;closure&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffb1c144aa26acce59fec25349dca754a38ca63b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fsdir&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fsdir&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="04701a346564d94d6aa3bd13c738c71fa914b8b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/templatevtab.c&quot;&gt;templatevtab&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/templatevtab.c&quot;&gt;templatevtab&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf00aa58d800d6480d93b3199e54337c206407a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="01915bb0f8a786a98397c94568cb66815f849fd5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vtablog.c&quot;&gt;vtablog&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vtablog.c&quot;&gt;vtablog&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c926660fb799a329674cb7c617c67bce894e4428" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/wholenumber.c&quot;&gt;wholenumber&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/wholenumber.c&quot;&gt;wholenumber&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d788296555dcf3637f6cf70059d29b967496d195" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/test_tclvar.c&quot;&gt;tclvar&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/test_tclvar.c&quot;&gt;tclvar&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2a66c976b626a199e6cfc1ce84f203a99c4006c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;json1#jeach&quot;&gt;json_each&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;json1#jeach&quot;&gt;json_each&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f09173772886e65ace26a5149a8670c924ceb788" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;json1#jtree&quot;&gt;json_tree&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;json1#jtree&quot;&gt;json_tree&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc419d684c8654f9bd33f06cd7dbcd4a2cb93757" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;limits#max_expr_depth&quot;&gt;SQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;&lt;/b&gt;. Setting the maximum expression parse-tree depth to zero disables all checking of the expression parse-tree depth, which simplifies the code resulting in faster execution, and helps the parse tree to use less memory.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;limits#max_expr_depth&quot;&gt;SQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt;&lt;/b&gt; 입니다. 최대 표현식 구문 분석 트리 깊이를 0으로 설정하면 표현식 구문 분석 트리 깊이의 모든 검사가 비활성화되어 코드가 단순화되어 실행 속도가 빨라지고 구문 분석 트리가 더 적은 메모리를 사용하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d5cae4e986df31c6d099c7ea2c3bab98099dd90b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;memstat&quot;&gt;sqlite_memstat&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;memstat&quot;&gt;sqlite_memstat&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abd2e9ff7615edc7876ddc6c813a3b60a0c56529" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;pragma#pragfunc&quot;&gt;pragma&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;pragma#pragfunc&quot;&gt;pragma&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="24d7838418b64d3972b6a360a071788e9c09f8bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;rtree&quot;&gt;RTree&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;rtree&quot;&gt;RTree&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e74dd2aafdd0d6a40a5f7ce51f0defeceee35779" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a783ff1da86af279fbd876c20d237f4c89ded57c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b9c53ce6fadad482f45b6453ffed7721b85877af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;stmt&quot;&gt;sqlite_stmt&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;stmt&quot;&gt;sqlite_stmt&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb3275fd965bc2f6afd091b827a1a0ccbde03d3c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;swarmvtab#overview&quot;&gt;swarmvtab&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;swarmvtab#overview&quot;&gt;swarmvtab&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="155d8aaceabfc9539a441a2150dd3ce5171745c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/aggregate-function-invocation&quot;&gt;aggregate-function-invocation:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/aggregate-function-invocation&quot;&gt;aggregate-function-invocation:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="47d913bf637581f11395bc1347608df051a4ff4c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/alter-table-stmt&quot;&gt;alter-table-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/alter-table-stmt&quot;&gt;alter-table-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4e5b2161aca9a1a0feea95546711318f8a466cc0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/analyze-stmt&quot;&gt;analyze-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/analyze-stmt&quot;&gt;analyze-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffd40c606a332777534da22b69a809498f97cf28" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/attach-stmt&quot;&gt;attach-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/attach-stmt&quot;&gt;attach-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f5f47b15fa11f0bdf0322356c374833d841fe90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/begin-stmt&quot;&gt;begin-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/begin-stmt&quot;&gt;begin-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1c5a29fe403de60236599d8ac388c5528a7e4b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9835701ad2b4b168d4b9be1d829787fcec5b9232" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/column-def&quot;&gt;column-def:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/column-def&quot;&gt;column-def:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="525627bb1fbfc5a0baab7d613505b9108972dd37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/column-name-list&quot;&gt;column-name-list:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/column-name-list&quot;&gt;column-name-list:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f8bf6eb0af422c596e856d6b2bf42e7e582fbcdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/comment-syntax&quot;&gt;comment-syntax:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/comment-syntax&quot;&gt;comment-syntax:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eab971465a26e2f5a7f4d41825484ec5ed5802a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/commit-stmt&quot;&gt;commit-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/commit-stmt&quot;&gt;commit-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="45fd3af689d70c446f8ea58e4db409c4ad04f45b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/common-table-expression&quot;&gt;common-table-expression:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/common-table-expression&quot;&gt;common-table-expression:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7f5786025f4b3eed4f84fc8f7efe046c333f1edd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="934feb3e4bea0a3754e4c282abba740b38a063f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/compound-select-stmt&quot;&gt;compound-select-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/compound-select-stmt&quot;&gt;compound-select-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c12cf1f37eed900da75da90961ff09391373fe8a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e5af2eed8cf24ff12a6daa80d1b2b3341a72368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/create-index-stmt&quot;&gt;create-index-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/create-index-stmt&quot;&gt;create-index-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9403f02c2d7d4243d04165701a10065b8848c01a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/create-table-stmt&quot;&gt;create-table-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/create-table-stmt&quot;&gt;create-table-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6a168876311e244f3b61310bd7f686cfdcd60e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/create-trigger-stmt&quot;&gt;create-trigger-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/create-trigger-stmt&quot;&gt;create-trigger-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5aa1ed682da12797837640f87eb894fec414b19b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/create-view-stmt&quot;&gt;create-view-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/create-view-stmt&quot;&gt;create-view-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f260961a1785481972bff5a1e25757ae120b8796" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc5852a7c0abf149b40e0f6e1c702fdd874781de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="21c5075f7ddf450c3a40ac440ec23c1c1452efd3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/delete-stmt&quot;&gt;delete-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/delete-stmt&quot;&gt;delete-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="185e4a97b3500bfc3f06b8a2472ebc329b5d9c68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/delete-stmt-limited&quot;&gt;delete-stmt-limited:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/delete-stmt-limited&quot;&gt;delete-stmt-limited:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0da083cb6ab00aff063876c0a7b554f65c39a952" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/detach-stmt&quot;&gt;detach-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/detach-stmt&quot;&gt;detach-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1af41a2bfacb54e6156410a3272bc57642c3ddd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/drop-index-stmt&quot;&gt;drop-index-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/drop-index-stmt&quot;&gt;drop-index-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4a98f6c5aae457bb9d6a5d5c40ef5ed86f5028de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/drop-table-stmt&quot;&gt;drop-table-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/drop-table-stmt&quot;&gt;drop-table-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="609cac5852ab60e5e697c8277b8d3c340f984c8d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/drop-trigger-stmt&quot;&gt;drop-trigger-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/drop-trigger-stmt&quot;&gt;drop-trigger-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7b6fd629ea1119d84de945a768a1d8c86cc38497" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/drop-view-stmt&quot;&gt;drop-view-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/drop-view-stmt&quot;&gt;drop-view-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56210641bfcd7cf249dffd41f80eaeedb1f21b0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/expr&quot;&gt;expr:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/expr&quot;&gt;expr:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61399e0d529927d7d2826f5a246936f6598a39be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="73747bea6e4a3a248d87ed7cddb9a47e9ae557f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/filter-clause&quot;&gt;filter-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/filter-clause&quot;&gt;filter-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5e7c86c0e91f689fc34d5dfc519f7a552d0daf78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;foreign-key-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;foreign-key-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="23fe890eab00e2f0149af0e8ae017c2fe6ff34ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/frame-spec&quot;&gt;frame-spec:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/frame-spec&quot;&gt;frame-spec:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8bf8ecd5b38ad5e13de28a30d9d79c0f2cf485d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c57211b38acfd6f8c6ec820c0d0645e1cc0ab2ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/insert-stmt&quot;&gt;insert-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/insert-stmt&quot;&gt;insert-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1010a61215e9eebee22fb60a79116c6998cde88f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/join-clause&quot;&gt;join-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/join-clause&quot;&gt;join-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9f615ecde4cdf74d174c0c3521d9156e3b7a7207" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="16ddef8c90bbe80d12255043133fde5d4ecd81d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="edc6885825402fc09d542fdce2824aad25eec795" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/literal-value&quot;&gt;literal-value:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/literal-value&quot;&gt;literal-value:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fa2d8b59191d904a59f77a9873071eb5456a167d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/numeric-literal&quot;&gt;numeric-literal:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/numeric-literal&quot;&gt;numeric-literal:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ecc308944ded97971430cdb01f8faa89a3b6f02" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/ordering-term&quot;&gt;ordering-term:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/ordering-term&quot;&gt;ordering-term:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf581874b48552a55b74c7b5f374f38456c73eb8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/over-clause&quot;&gt;over-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/over-clause&quot;&gt;over-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb6f103773a7c78d7f28ea58c26ad8d5cbbbe442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/pragma-stmt&quot;&gt;pragma-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/pragma-stmt&quot;&gt;pragma-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ecd8e34f1480aead0b7c35c5ee4a167f848ddf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/pragma-value&quot;&gt;pragma-value:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/pragma-value&quot;&gt;pragma-value:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3c46a7bec1b0b2598c4f97a5584afad89910dd41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="120d05f736a56f93ec5e6ab4fae681c7972003ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/raise-function&quot;&gt;raise-function:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/raise-function&quot;&gt;raise-function:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a18541892fe43267fcbc5157f186521a7053c07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="959d4d4be6ade1d2ece52e5ae5d3988abae4050a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/reindex-stmt&quot;&gt;reindex-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/reindex-stmt&quot;&gt;reindex-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2c55b45ed30539d6e0d06d648a10c8a37454d1e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/release-stmt&quot;&gt;release-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/release-stmt&quot;&gt;release-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3c1aa49d7f7227e8ea5d38b6557d5a3f63dd1cda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/result-column&quot;&gt;result-column:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/result-column&quot;&gt;result-column:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a9dab4e0579f598df27367bdb5e841e9ae309bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/rollback-stmt&quot;&gt;rollback-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/rollback-stmt&quot;&gt;rollback-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b915c95b786e85057f69f3306806653cad54511" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/savepoint-stmt&quot;&gt;savepoint-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/savepoint-stmt&quot;&gt;savepoint-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b3b8fb1a5249059a5bc77a7ca220bf656701e225" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/select-core&quot;&gt;select-core:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/select-core&quot;&gt;select-core:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c0426d4a2ec31093f2247476b8716c06ea13e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="485c72c2b2ec8d4cc8d861ed923bd5fdfe5fa2ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/signed-number&quot;&gt;signed-number:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/signed-number&quot;&gt;signed-number:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95983313672ed2437d7287e503470da5b4e0e4d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/simple-function-invocation&quot;&gt;simple-function-invocation:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/simple-function-invocation&quot;&gt;simple-function-invocation:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c1c876d509e449abd4f4b4b3ccef4b589d91f62f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="edcdc9ff77ef473480b343c99587640ae50a17f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/sql-stmt&quot;&gt;sql-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/sql-stmt&quot;&gt;sql-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f209837f6ab48761d9658829999ad4ee19a928c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/sql-stmt-list&quot;&gt;sql-stmt-list:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/sql-stmt-list&quot;&gt;sql-stmt-list:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9291e416d2635fed56309e803051c61a5cde50d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a51d48c76d468bf3ee8e8a0ea769330efb704" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/table-or-subquery&quot;&gt;table-or-subquery:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/table-or-subquery&quot;&gt;table-or-subquery:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3ed9394fd4c9e9201fdaffa734452c45ed17be9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/type-name&quot;&gt;type-name:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/type-name&quot;&gt;type-name:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2193d5df7b8be7f31cde4fc17d65f6cf51821446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/update-stmt&quot;&gt;update-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/update-stmt&quot;&gt;update-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1bf9b9b7792cb8a9d79898da344f34073024d2a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/update-stmt-limited&quot;&gt;update-stmt-limited:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/update-stmt-limited&quot;&gt;update-stmt-limited:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4e5fa5e7736751a015e3d18097e4152bddea7cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13edcad1cc88886862d7bc38cf3c42ef8240ef1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/vacuum-stmt&quot;&gt;vacuum-stmt:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/vacuum-stmt&quot;&gt;vacuum-stmt:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eef994816592b2a72b89c7f34e0fd6324cc283fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/window-defn&quot;&gt;window-defn:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/window-defn&quot;&gt;window-defn:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f0b6c7bd3a06dd70d9e44a8e745f5656745cddc3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/window-function-invocation&quot;&gt;window-function-invocation:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/window-function-invocation&quot;&gt;window-function-invocation:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="907f44f12e3580abd336bbd64dbc764c8259f510" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;syntax/with-clause&quot;&gt;with-clause:&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;syntax/with-clause&quot;&gt;with-clause:&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="93886de0e945b8f30f13a971b6e1a4cdfef6ba7b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;testing&quot;&gt;Aviation-grade testing&lt;/a&gt;&lt;/b&gt; &amp;rarr; Every machine-code branch instruction is tested in both directions. Multiple times. On multiple platforms and with multiple compilers. This helps make the code robust for future migrations. The intense testing also means that new developers can make experimental enhancements to SQLite and, assuming legacy tests all pass, be reasonably sure that the enhancement does not break legacy.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;testing&quot;&gt;항공 등급 테스트&lt;/a&gt;&lt;/b&gt; &amp;rarr; 모든 기계 코드 분기 명령은 양방향으로 테스트됩니다. 여러 번. 여러 플랫폼과 여러 컴파일러에서. 이를 통해 향후 마이그레이션을 위해 코드를 강력하게 만들 수 있습니다. 강렬한 테스트는 또한 새로운 개발자가 SQLite를 실험적으로 향상시킬 수 있음을 의미하며, 레거시 테스트가 모두 통과되었다고 가정하면 향상된 기능으로 인해 레거시가 손상되지 않도록 합리적으로 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5393ac5dc349af8163e6055363dc4fdadb9bb5d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;unionvtab&quot;&gt;unionvtab&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;unionvtab&quot;&gt;unionvtab&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f5f9a80e93c57ea475729412c3cf82e199d6589" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="afcc9456755d6104e8e39873c6688b4ab3e2612c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;nobr&gt;Complete ALTER TABLE support&lt;/nobr&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;nobr&gt;완벽한 ALTER TABLE 지원&lt;/nobr&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97dab16243584f37360439eb35855d1917c50ff5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;nobr&gt;Complete trigger support&lt;/nobr&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;nobr&gt;완벽한 트리거 지원&lt;/nobr&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07292414055cfe92a93a81ca46ccbedae361b55e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;nobr&gt;GRANT and REVOKE&lt;/nobr&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;nobr&gt;그랜트와 리 보크&lt;/nobr&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c7e735a14e8e0a267afb5330bd5f3756d42dbef1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;nobr&gt;RIGHT and FULL OUTER JOIN&lt;/nobr&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;nobr&gt;옳고 완전한 외부 참여&lt;/nobr&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b099ff059fd2fee9e241750d729c2225c2a29f19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;nobr&gt;Writing to VIEWs&lt;/nobr&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;nobr&gt;VIEW에 쓰기&lt;/nobr&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebfb34485d3a9447bf4a4f594eb6cc5c8b649ba8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9edd071971ecf655859536e6fa5b8bbe4ec1af5b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;?&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;?&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0147239a3ebb80ced86ccb75ffc2393c8a68e869" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;@&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;@&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fcf9b076d76abb342b37955ed077bfd842fb5b1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ABORT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ABORT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="174e7c946cf648bafa6290271faa20de3ec5d232" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ALWAYS(X)&lt;/b&gt; &amp;rarr; The ALWAYS(X) function indicates that condition X is always true as far as the developers know, but there is no proof the X is true, or the proof is complex and error-prone, or the proof depends on implementation details that are likely to change in the future. ALWAYS(X) behaves like a function that returns the boolean value X, and is intended to be used within the conditional of an &quot;if&quot; statement.</source>
          <target state="translated">&lt;b&gt;ALWAYS (X)&lt;/b&gt; &amp;rarr; ALWAYS (X) 함수는 개발자가 알고있는 한 조건 X가 항상 참임을 나타내지 만 X가 참이라는 증거가 없거나 증명이 복잡하고 오류가 발생하기 쉬우거나 증명이 향후 변경 될 수있는 구현 세부 사항 ALWAYS (X)는 부울 값 X를 반환하는 함수처럼 작동하며 &quot;if&quot;문의 조건부 내에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3837b9ed99f53c780e4ec97b51899c742dc9d00a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;AND&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;AND&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1c3c893f9c33e965420f62565eade64d43f556a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Accessibility&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Accessibility&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="855ac1dadb05ec903456ad95e5d201959377cfc3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Accessible Content.&lt;/b&gt; Information held in an SQLite database file is accessible using commonly available open-source command-line tools - tools that are installed by default on Mac and Linux systems and that are freely available as a self-contained EXE file on Windows. Unlike custom file formats, application-specific programs are not required to read or write content in an SQLite database. An SQLite database file is not an opaque blob. It is true that command-line tools such as text editors or &quot;grep&quot; or &quot;awk&quot; are not useful on an SQLite database, but the SQL query language is a much more powerful and convenient way for examining the content, so the inability to use &quot;grep&quot; and &quot;awk&quot; and the like is not seen as a loss.</source>
          <target state="translated">&lt;b&gt;접근 가능한 컨텐츠.&lt;/b&gt; SQLite 데이터베이스 파일에 저장된 정보는 일반적으로 사용 가능한 오픈 소스 명령 줄 도구를 사용하여 액세스 할 수 있습니다.이 도구는 Mac 및 Linux 시스템에 기본적으로 설치되며 Windows에서 자체 포함 EXE 파일로 무료로 사용할 수 있습니다. 사용자 정의 파일 형식과 달리, 응용 프로그램 특정 프로그램은 SQLite 데이터베이스에서 컨텐츠를 읽거나 쓸 필요가 없습니다. SQLite 데이터베이스 파일은 불투명 한 얼룩이 아닙니다. 텍스트 편집기 나 &quot;grep&quot;또는 &quot;awk&quot;와 같은 명령 줄 도구는 SQLite 데이터베이스에서 유용하지 않지만 SQL 쿼리 언어는 내용을 검사하는 데 훨씬 강력하고 편리한 방법이므로 &quot;grep&quot;및 &quot;awk&quot;를 사용하면 손실로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3480e09e4e9b64a063f83b879a585c93ba7b80d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Adoption.&lt;/b&gt; Degree to which the format is already used by the primary creators, disseminators, or users of information resources. This includes use as a master format, for delivery to end users, and as a means of interchange between systems.</source>
          <target state="translated">&lt;b&gt;양자. &lt;/b&gt;기본 작성자, 유포자 또는 정보 자원 사용자가 형식을 이미 사용하고있는 정도. 여기에는 최종 사용자에게 제공하기위한 마스터 형식 및 시스템 간 교환 수단으로 사용하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6f31211685796eafa4dcf6136994521b34d44596" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Alert:&lt;/b&gt; As warned above, the EXPLAIN QUERY PLAN output format did change substantially with the version 3.24.0 release (2018-06-04). Further changes are possible in subsequent releases.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; 위에서 경고 한 것처럼 EXPLAIN QUERY PLAN 출력 형식은 버전 3.24.0 릴리스 (2018-06-04)에서 크게 변경되었습니다. 후속 릴리스에서 추가 변경이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="01d17e561c40ec23996c4f2ca356bd118ab389b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Android&lt;/b&gt;: Galaxy S3, ARMv7, 2GiB RAM</source>
          <target state="translated">&lt;b&gt;안드로이드&lt;/b&gt; : Galaxy S3, ARMv7, 2GiB RAM</target>
        </trans-unit>
        <trans-unit id="370ae8a7436b00f2bdc40b3013bd4680bc170ab3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Append a new transaction to the end of the WAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL 끝에 새로운 거래 추가&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2f3925c4343fca1c55be4fb4b9b822d8415572e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Application File Format.&lt;/b&gt; Rather than using fopen() to write XML, JSON, CSV, or some proprietary format into disk files used by your application, use an SQLite database. You'll avoid having to write and troubleshoot a parser, your data will be more easily accessible and cross-platform, and your updates will be transactional. (&lt;a href=&quot;appfileformat&quot;&gt;more...&lt;/a&gt;)</source>
          <target state="translated">&lt;b&gt;응용 프로그램 파일 형식. &lt;/b&gt;fopen ()을 사용하여 XML, JSON, CSV 또는 일부 독점 형식을 응용 프로그램에서 사용하는 디스크 파일에 쓰지 않고 SQLite 데이터베이스를 사용하십시오. 파서를 작성하고 문제를 해결하지 않아도되며, 데이터에보다 쉽게 ​​액세스하고 크로스 플랫폼 할 수 있으며 업데이트는 트랜잭션 방식입니다. ( &lt;a href=&quot;appfileformat&quot;&gt;더 ...&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="017d797f146028652994868843424362cc5f4441" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Application file format&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;응용 프로그램 파일 형식&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cd06d88e35f132fbc67e4f32653d2b99388a9b68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Application-supplied memory allocators.&lt;/b&gt; The application can provide SQLite with pointers to alternative memory allocators at start-time. The alternative memory allocator will be used in place of system malloc() and free().</source>
          <target state="translated">&lt;b&gt;응용 프로그램 제공 메모리 할당 자. &lt;/b&gt;응용 프로그램은 시작시 대체 메모리 할당 자에 대한 포인터를 SQLite에 제공 할 수 있습니다. 대체 메모리 할당자는 시스템 malloc () 및 free () 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="228c0afe789ccf9b0979a03b4128f939fff05ebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Atomic Transactions.&lt;/b&gt; Writes to an SQLite database are &lt;a href=&quot;atomiccommit&quot;&gt;atomic&lt;/a&gt;. They either happen completely or not at all, even during system crashes or power failures. So there is no danger of corrupting a document just because the power happened to go out at the same instant that a change was being written to disk.</source>
          <target state="translated">&lt;b&gt;원자 거래. &lt;/b&gt;SQLite 데이터베이스에 대한 쓰기는 &lt;a href=&quot;atomiccommit&quot;&gt;원자 적&lt;/a&gt; 입니다. 시스템 충돌이나 정전시에도 완전히 발생하거나 전혀 발생하지 않습니다. 따라서 변경 사항이 디스크에 기록되는 순간 전원이 꺼지더라도 문서가 손상 될 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="654835d3d8e10954475b635ee3094f3dab782170" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Avoid creating low-quality indexes.&lt;/b&gt;. A low-quality index (for the purpose of this checklist) is one where there are more than 10 or 20 rows in the table that have the same value for the left-most column of the index. In particular, avoid using boolean or &quot;enum&quot; columns as the left-most columns of your indexes.</source>
          <target state="translated">&lt;b&gt;품질이 낮은 색인을 작성하지 마십시오. &lt;/b&gt;. 품질이 낮은 인덱스 (이 검사 목록의 목적으로)는 테이블에서 인덱스의 가장 왼쪽 열에 대해 동일한 값을 갖는 10 개 또는 20 개가 넘는 행이있는 인덱스입니다. 특히 부울 또는 &quot;열&quot;열을 색인의 가장 왼쪽 열로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="523b4778a75353eca801ba987350c4fb4a04f2c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;BETWEEN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;BETWEEN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95d9edaf0937255bc1ba14d572cefdbfe961faf3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;BINARY&lt;/b&gt; - Compares string data using memcmp(), regardless of text encoding.</source>
          <target state="translated">&lt;b&gt;BINARY-&lt;/b&gt; 텍스트 인코딩에 관계없이 memcmp ()를 사용하여 문자열 데이터를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b50af69dd13e80374299454b7f782f39c57537fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;BLOB&lt;/b&gt;. The value is a blob of data, stored exactly as it was input.</source>
          <target state="translated">&lt;b&gt;BLOB&lt;/b&gt; . 값은 입력 한대로 정확하게 저장된 데이터 덩어리입니다.</target>
        </trans-unit>
        <trans-unit id="88600ad1c85a78f3c3f304f03bd46c329b5ec5fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Backwards Compatibility Warning:&lt;/b&gt; Prior to SQLite version 3.20.0 (2017-08-01), the fts5() worked slightly differently. Older applications that extend FTS5 must be revised to use the new technique shown above.</source>
          <target state="translated">&lt;b&gt;이전 버전과의 호환성 경고 :&lt;/b&gt; SQLite 버전 3.20.0 (2017-08-01) 이전에는 fts5 ()가 약간 다르게 작동했습니다. 위에 표시된 새로운 기술을 사용하려면 FTS5를 확장하는 이전 응용 프로그램을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e12433635ead9dc1d59ae50db81019458eb7227" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Backwards Compatibility:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;이전 버전과의 호환성 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9f457244d750e2e02a88d4bcfbce9156bf7916a6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Better Applications.&lt;/b&gt; If the application file format is an SQLite database, the complete documentation for that file format consists of the database schema, with perhaps a few extra words about what each table and column represents. The description of a custom file format, on the other hand, typically runs on for hundreds of pages. A pile-of-files format, while much simpler and easier to describe than a fully custom format, still tends to be much larger and more complex than an SQL schema dump, since the names and format for the individual files must still be described.</source>
          <target state="translated">&lt;b&gt;더 나은 응용 프로그램. &lt;/b&gt;애플리케이션 파일 형식이 SQLite 데이터베이스 인 경우 해당 파일 형식에 대한 전체 문서는 데이터베이스 스키마로 구성되며 각 테이블 및 열이 나타내는 내용에 대한 몇 가지 추가 단어가있을 수 있습니다. 반면에 사용자 정의 파일 형식에 대한 설명은 일반적으로 수백 페이지에 걸쳐 실행됩니다. 파일 더미 형식은 완전한 사용자 정의 형식보다 훨씬 간단하고 설명하기 쉽지만 개별 파일의 이름과 형식을 계속 설명해야하기 때문에 여전히 SQL 스키마 덤프보다 훨씬 크고 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="6dd8e49fe539bdf1a6ab65017bf21cd21a7c8f04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Better performance&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;더 나은 성능&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6a99456641530b7d0c207a1bd328b2c46a99c23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Big data? &amp;rarr; choose client/server&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;빅 데이터? &amp;rarr; 클라이언트 / 서버 선택&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f66853513c32c6e6fa5a69f699d45ac61babe7d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bounds checking.&lt;/b&gt; The instrumented memory allocator places sentinel values at both ends of each memory allocation to verify that nothing within SQLite writes outside the bounds of the allocation.</source>
          <target state="translated">&lt;b&gt;경계 점검. &lt;/b&gt;인스트루먼트 된 메모리 할당자는 각 메모리 할당의 양쪽 끝에 센티넬 값을 배치하여 SQLite 내의 어떤 것도 할당 범위를 벗어나는 것을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="da7f9b05e3949de833e29773fc46e89b0c809690" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Breakpoints on test_addoptrace&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;test_addoptrace의 중단 점&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46f0725b3775062e837d3bba993299f452498eaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug Fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a48402057818543de615729df04e98ac523ca092" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fix:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97daecfde6944efc8d05cfed77bc191a297d1127" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fix:&lt;/b&gt; Add an additional xSync when restarting a WAL in order to prevent an exceedingly unlikely but theoretically possible database corruption following power-loss. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ff5be73dee&quot;&gt;ff5be73dee&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;버그 수정 :&lt;/b&gt; WAL을 다시 시작할 때 추가적인 xSync를 추가하여 전원 손실 후 발생할 수는 없지만 이론적으로 가능한 데이터베이스 손상을 방지하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/ff5be73dee&quot;&gt;ff5be73dee&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9a7d6d9fddfbda7eb9108c635343be365813ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fix:&lt;/b&gt; Change the VDBE so that all registers are initialized to Invalid instead of NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/7bbfb7d442&quot;&gt;7bbfb7d442&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정 :&lt;/b&gt; 모든 레지스터가 NULL 대신 Invalid로 초기화되도록 VDBE를 변경하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/7bbfb7d442&quot;&gt;7bbfb7d442&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71624ed373f00188a3ac05efddc2870bf5fbc85f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fix:&lt;/b&gt; Fix problems that can result from 32-bit integer overflow. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ac0ff496b7e2&quot;&gt;ac00f496b7e2&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정 :&lt;/b&gt; 32 비트 정수 오버플로로 인해 발생할 수있는 문제를 해결합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/ac0ff496b7e2&quot;&gt;AC00F496B7E2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a96f3dbd4e3bfb7191f061d88c4cd78afc799e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fix:&lt;/b&gt; Return the correct answer for &quot;SELECT count(*) FROM table&quot; even if there is a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; on the table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a5c8ed66ca&quot;&gt;a5c8ed66ca&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;버그 수정 :&lt;/b&gt; 테이블에 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 가 있어도 &quot;SELECT count (*) FROM table&quot;에 대한 정답을 반환 합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/a5c8ed66ca&quot;&gt;a5c8ed66ca&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c3886c768a7d34e77338f7280816c3ba89c3cc0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fixes backported into patch release 3.8.0.2 (2013-09-03):&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;패치 릴리스 3.8.0.2 (2013-09-03)로 백 포트 된 버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="82d4a9ad633644382ba34f07f6c7e4f5b4fa8150" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fixes backported into patch release 3.8.1 (2013-10-17):&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;패치 릴리스 3.8.1 (2013-10-17)로 백 포트 된 버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f878491d12761b2703108548b36457fa48232f05" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9c52ffc958888c5de5484cec3cc22948bd97447" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Bug fixes&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;버그 수정&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20b0e9d7c52962bbabc1d3705acdcac2004ff4b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;CASCADE&lt;/b&gt;: A &quot;CASCADE&quot; action propagates the delete or update operation on the parent key to each dependent child key. For an &quot;ON DELETE CASCADE&quot; action, this means that each row in the child table that was associated with the deleted parent row is also deleted. For an &quot;ON UPDATE CASCADE&quot; action, it means that the values stored in each dependent child key are modified to match the new parent key values.</source>
          <target state="translated">&lt;b&gt;CASCADE&lt;/b&gt; : &quot;CASCADE&quot;조치는 상위 키의 삭제 또는 업데이트 조작을 각 종속 하위 키로 전파합니다. &quot;ON DELETE CASCADE&quot;조치의 경우 이는 삭제 된 상위 행과 연관된 하위 테이블의 각 행도 삭제됨을 의미합니다. &quot;ON UPDATE CASCADE&quot;조치의 경우, 각 종속 하위 키에 저장된 값이 새 상위 키 값과 일치하도록 수정됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0f53c0da676e107a458aeeed28e6a009e9b0b7ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;CURRENT ROW&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;현재 행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5fd60963e3aea952df6f7a7b12136b09caecdfa0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Cache for enterprise data&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;엔터프라이즈 데이터 용 캐시&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ebe9796511ca6a4a88a2c5bfd75688236bb73a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Call sqlite3TreeViewExpr() and similar from the debugger.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;디버거에서 sqlite3TreeViewExpr () 및 유사 항목을 호출하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49d80493fbeff7f97cf28ed149efa189bf2df08c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Callback Invocation Details&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;콜백 호출 세부 사항&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7913ba2a77e75487c2f59f2ddc9cb17ce9cdf8a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Caution:&lt;/b&gt; Take care to follow the procedure above precisely. The boxes below summarize two procedures for modifying a table definition. At first glance, they both appear to accomplish the same thing. However, the procedure on the right does not always work, especially with the enhanced &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt; capabilities added by versions 3.25.0 and 3.26.0. In the procedure on the right, the initial rename of the table to a temporary name might corrupt references to that table in triggers, views, and foreign key constraints. The safe procedure on the left constructs the revised table definition using a new temporary name, then renames the table into its final name, which does not break links.</source>
          <target state="translated">&lt;b&gt;주의 :&lt;/b&gt; 위의 절차를 정확하게 따르십시오. 아래 상자는 테이블 정의를 수정하는 두 가지 절차를 요약합니다. 언뜻보기에, 그들은 모두 같은 것을 성취하는 것으로 보입니다. 그러나 오른쪽 버전의 절차가 항상 작동하지는 않습니다. 특히 버전 3.25.0 및 3.26.0에 의해 추가 된 향상된 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;이름 바꾸기 테이블&lt;/a&gt; 기능이 있는 경우에는 더욱 그렇습니다. 오른쪽의 절차에서 테이블의 초기 이름을 임시 이름으로 바꾸면 트리거, 뷰 및 외래 키 제약 조건에서 해당 테이블에 대한 참조가 손상 될 수 있습니다. 왼쪽의 안전한 절차는 새로운 임시 이름을 사용하여 수정 된 테이블 정의를 구성한 다음 테이블 이름을 최종 이름으로 바꾸어 연결을 끊지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28bcd665d3a172c2a79319966e5630d9424e6fae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Checkpoint starvation.&lt;/b&gt; A checkpoint is only able to run to completion, and reset the WAL file, if there are no other database connections using the WAL file. If another connection has a read transaction open, then the checkpoint cannot reset the WAL file because doing so might delete content out from under the reader. The checkpoint will do as much work as it can without upsetting the reader, but it cannot run to completion. The checkpoint will start up again where it left off after the next write transaction. This repeats until some checkpoint is able to complete.</source>
          <target state="translated">&lt;b&gt;검문소 기아. &lt;/b&gt;WAL 파일을 사용하는 다른 데이터베이스 연결이없는 경우 검사 점은 완료까지만 실행하고 WAL 파일을 재설정 할 수 있습니다. 다른 연결에 읽기 트랜잭션이 열려 있으면 검사 점에서 WAL 파일을 재설정 할 수 없습니다. 그렇게하면 판독기 아래에서 내용이 삭제 될 수 있습니다. 검사 점은 리더를 화나게하지 않으면 서 최대한 많은 작업을 수행하지만 완료 될 수는 없습니다. 다음 쓰기 트랜잭션 후 중단 된 지점에서 검사 점이 다시 시작됩니다. 이것은 체크 포인트가 완료 될 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="1a070510c09733609af2784be20a330f2571d114" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Classic Serverless:&lt;/b&gt; The database engine runs within the same process, thread, and address space as the application. There is no message passing or network activity.</source>
          <target state="translated">&lt;b&gt;클래식 서버리스 :&lt;/b&gt; 데이터베이스 엔진은 응용 프로그램과 동일한 프로세스, 스레드 및 주소 공간 내에서 실행됩니다. 메시지 전달 또는 네트워크 활동이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4499b3ec1d9cd34a1fda2b5b809c30392ec5e59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Client/Server Applications&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;클라이언트 / 서버 애플리케이션&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc7e07303f923c060de767eb03fadd7aaf431bc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Close a connection to a WAL mode database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL 모드 데이터베이스에 대한 연결을 닫습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f29c03ecb97110259cb63f427ffd64bb089bbcba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Compact&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Compact&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c415b3080f7a0d9991529e2b898f4d8ff272f5b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Compatibility Warning:&lt;/b&gt; The ability to vacuum attached databases was added in &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). Prior to that, a schema-name added to the VACUUM statement would be silently ignored and the &quot;main&quot; schema would be vacuumed.</source>
          <target state="translated">&lt;b&gt;호환성 경고 :&lt;/b&gt; 연결된 데이터베이스를 진공 청소기로 청소하는 기능이 &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;버전 3.15.0&lt;/a&gt; (2016-10-14) 에 추가되었습니다 . 그 전에 VACUUM 문에 추가 된 스키마 이름은 자동으로 무시되고 &quot;주&quot;스키마는 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="e30113409e0bd0ead1b7ec82573df96ea1e26d57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Concurrent Usage of Database Handles&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데이터베이스 핸들의 동시 사용&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3bc11fc6bce2aa132e0fb6159898721a6c71920a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Concurrent Use By Multiple Processes.&lt;/b&gt; SQLite automatically coordinates concurrent access to the same document from multiple threads and/or processes. Two or more applications can connect and read from the same document at the same time. Writes are serialized, but as writes normally only take milliseconds, applications simply take turns writing. SQLite automatically ensures that the low-level format of the document is uncorrupted. Accomplishing the same with a custom or pile-of-files format, in contrast, requires extensive support in the application. And the application logic needed to support concurrency is a notorious bug-magnet.</source>
          <target state="translated">&lt;b&gt;여러 프로세스에 의한 동시 사용. &lt;/b&gt;SQLite는 여러 스레드 및 / 또는 프로세스에서 동일한 문서에 대한 동시 액세스를 자동으로 조정합니다. 동일한 문서에서 동시에 두 개 이상의 응용 프로그램을 연결하고 읽을 수 있습니다. 쓰기는 직렬화되지만 쓰기는 일반적으로 밀리 초에 불과하므로 응용 프로그램은 단순히 쓰기를 수행합니다. SQLite는 문서의 하위 수준 형식이 손상되지 않도록 자동으로 보장합니다. 이와 대조적으로, 사용자 정의 또는 파일 더미 형식으로이를 달성하려면 응용 프로그램에서 광범위한 지원이 필요합니다. 동시성을 지원하는 데 필요한 응용 프로그램 논리는 악명 높은 버그 자석입니다.</target>
        </trans-unit>
        <trans-unit id="0b7ed2b79615cb8c40fa8bcd4d9bdb711cbc85aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Content is inaccessible.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;내용에 액세스 할 수 없습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f307cf74bf5f164b145c7103671d7c3044678d74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Crash recovery is difficult.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;충돌 복구가 어렵습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22d58506e6afea5842d356ad551e9d0b052818a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Create appropriate indexes.&lt;/b&gt; Most SQL performance problems arise not because of query planner issues but rather due to lack of appropriate indexes. Make sure indexes are available to assist all large queries. Most performance issues can be resolved by one or two CREATE INDEX commands and with no changes to application code.</source>
          <target state="translated">&lt;b&gt;적절한 색인을 작성하십시오. &lt;/b&gt;대부분의 SQL 성능 문제는 쿼리 플래너 문제가 아니라 적절한 인덱스가 없기 때문에 발생합니다. 모든 대형 쿼리를 지원하는 인덱스를 사용할 수 있는지 확인하십시오. 대부분의 성능 문제는 하나 또는 두 개의 CREATE INDEX 명령으로 해결할 수 있으며 응용 프로그램 코드는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14c983ae625a5f52d979de4358130ad0bfbd0681" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Create file&lt;/b&gt; operations. SQLite may create new files within the file-system by invoking the xOpen() method of the sqlite3_io_methods object.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 작업을 &lt;b&gt;만듭니다&lt;/b&gt; . SQLite는 sqlite3_io_methods 객체의 xOpen () 메서드를 호출하여 파일 시스템 내에 새 파일을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d3339e9454dd9ccdd4e12e8731ed5f3ab4eb01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Critical bug fix:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;중요한 버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1ad7228529de0e16e3c07d51578ffec5006fd085" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Cross-Platform.&lt;/b&gt; SQLite database files are portable between 32-bit and 64-bit machines and between big-endian and little-endian architectures and between any of the various flavors of Windows and Unix-like operating systems. The application using an SQLite application file format can store binary numeric data without having to worry about the byte-order of integers or floating point numbers. Text content can be read or written as UTF-8, UTF-16LE, or UTF-16BE and SQLite will automatically perform any necessary translations on-the-fly.</source>
          <target state="translated">&lt;b&gt;플랫폼 간.&lt;/b&gt; SQLite 데이터베이스 파일은 32 비트 및 64 비트 컴퓨터와 빅 엔디안 및 리틀 엔디안 아키텍처, 다양한 Windows 및 Unix 계열 운영 체제간에 이식 가능합니다. SQLite 응용 프로그램 파일 형식을 사용하는 응용 프로그램은 정수 또는 부동 소수점 숫자의 바이트 순서에 대해 걱정할 필요없이 이진 숫자 데이터를 저장할 수 있습니다. 텍스트 내용은 UTF-8, UTF-16LE 또는 UTF-16BE로 읽거나 쓸 수 있으며 SQLite는 필요한 번역을 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="90eba990624b6893cace88f1902c123db3641b66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Cross-platform&lt;/b&gt; &amp;rarr; SQLite runs on any platform with an 8-bit byte, two's complement 32-bit and 64-bit integers, and a C compiler. It is actively tested on all currently popular CPUs and operating systems. The extreme portability of the SQLite code will help it remain viable on future platforms.</source>
          <target state="translated">&lt;b&gt;크로스 플랫폼&lt;/b&gt; &amp;rarr; SQLite는 8 비트 바이트, 2의 보수 32 비트 및 64 비트 정수 및 C 컴파일러가있는 모든 플랫폼에서 실행됩니다. 현재 널리 사용되는 모든 CPU 및 운영 체제에서 적극적으로 테스트됩니다. SQLite 코드의 뛰어난 이식성은 향후 플랫폼에서 실행 가능한 상태를 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ac07fee284fe047b93f49f465c97736a6510fb9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Data analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데이터 분석&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="15cbe037d219f0a2a56c5727d0af032b36f9667f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Data transfer format&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데이터 전송 형식&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b86e284d54be5986075ed16964bc2a21967d0adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Database For The Internet Of Things.&lt;/b&gt; SQLite is popular choice for the database engine in cellphones, PDAs, MP3 players, set-top boxes, and other electronic gadgets. SQLite has a small code footprint, makes efficient use of memory, disk space, and disk bandwidth, is highly reliable, and requires no maintenance from a Database Administrator.</source>
          <target state="translated">&lt;b&gt;사물 인터넷 데이터베이스. &lt;/b&gt;SQLite는 휴대폰, PDA, MP3 플레이어, 셋톱 박스 및 기타 전자 기기에서 데이터베이스 엔진에 널리 사용됩니다. SQLite는 코드 공간이 작고 메모리, 디스크 공간 및 디스크 대역폭을 효율적으로 사용하며 안정성이 높으며 데이터베이스 관리자의 유지 관리가 필요 없습니다.</target>
        </trans-unit>
        <trans-unit id="49c79c3148a2a1dc146be2eb3c84f988539d9eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Database URI&lt;/b&gt;. A filename or URI that can be used to open the database containing the component table.</source>
          <target state="translated">&lt;b&gt;데이터베이스 URI&lt;/b&gt; . 구성 요소 테이블이 포함 된 데이터베이스를 여는 데 사용할 수있는 파일 이름 또는 URI입니다.</target>
        </trans-unit>
        <trans-unit id="1c2384f37d2d34b9a797814f3319b04ec39e0d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Deadlock Detection&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;교착 상태 감지&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22d16bbb04b225407526c33438fc4688391754fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Delete file&lt;/b&gt; operations. SQLite may remove files from the file system by calling the xDelete() method of the sqlite3_io_methods object.</source>
          <target state="translated">&lt;b&gt;파일 삭제&lt;/b&gt; 작업. SQLite는 sqlite3_io_methods 객체의 xDelete () 메서드를 호출하여 파일 시스템에서 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409360aee85e9a3a2c1a6b94d9ffa6a73130e580" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Details:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Details:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e3af8fb6c1bf601678288333ed8c58b87a39df6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Determination Of When To Run Analyze&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;분석 실행시기 결정&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1921671df2e8e6d754003b0f64176ba90694146a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Disable the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 기&lt;/a&gt; 비활성화&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0861730d55fc487db6e03350d90130df81d8d490" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Disabling the automatic checkpoint mechanism.&lt;/b&gt; In its default configuration, SQLite will checkpoint the WAL file at the conclusion of any transaction when the WAL file is more than 1000 pages long. However, compile-time and run-time options exist that can disable or defer this automatic checkpoint. If an application disables the automatic checkpoint, then there is nothing to prevent the WAL file from growing excessively.</source>
          <target state="translated">&lt;b&gt;자동 체크 포인트 메커니즘 비활성화 &lt;/b&gt;기본 구성에서 SQLite는 WAL 파일의 길이가 1000 페이지를 초과 할 때 트랜잭션이 끝날 때 WAL 파일을 체크 포인트합니다. 그러나이 자동 검사 점을 비활성화하거나 연기 할 수있는 컴파일 타임 및 런타임 옵션이 있습니다. 응용 프로그램이 자동 검사 점을 비활성화하면 WAL 파일이 과도하게 커지는 것을 막을 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f77f36cf9df788901458ad46db8249720a91aeed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Disaster planning&lt;/b&gt; &amp;rarr; Every byte of source-code history for SQLite is cryptographically protected and is automatically replicated to multiple geographically separated servers, in datacenters owned by different companies. Thousands of additional clones exist on private servers around the world. The primary developers of SQLite live in different regions of the world. SQLite can survive a continental catastrophe.</source>
          <target state="translated">&lt;b&gt;재해 계획&lt;/b&gt; &amp;rarr; SQLite에 대한 모든 소스 코드 기록 바이트 단위는 암호화 방식으로 보호되며 여러 회사가 소유 한 데이터 센터에서 지리적으로 분리 된 여러 서버에 자동으로 복제됩니다. 수천 개의 추가 클론이 전 세계의 개인 서버에 존재합니다. SQLite의 주요 개발자는 세계의 다른 지역에 살고 있습니다. SQLite는 대륙 재앙에서도 살아남을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cddf1ac2f170bd61e6d29fb00a792869eb8382d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Disclosure.&lt;/b&gt; Degree to which complete specifications and tools for validating technical integrity exist and are accessible to those creating and sustaining digital content. A spectrum of disclosure levels can be observed for digital formats. What is most significant is not approval by a recognized standards body, but the existence of complete documentation.</source>
          <target state="translated">&lt;b&gt;폭로. &lt;/b&gt;기술적 무결성을 검증하기위한 완전한 사양과 도구가 존재하며 디지털 컨텐츠를 작성하고 유지하는 사람들이 이용할 수있는 정도. 디지털 형식의 경우 공개 수준의 스펙트럼을 관찰 할 수 있습니다. 가장 중요한 것은 인정 된 표준기구의 승인이 아니라 완전한 문서의 존재입니다.</target>
        </trans-unit>
        <trans-unit id="75e37845be72aa41640ff23c2f979f57810420c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Don't panic!&lt;/b&gt; Cases where the query planner picks an inferior plan are actually quite rare. You are unlikely to run across any problems in your application. If you are not having performance issues, you do not need to worry about any of this.</source>
          <target state="translated">&lt;b&gt;당황하지 마십시오! &lt;/b&gt;쿼리 플래너가 열등한 계획을 선택하는 경우는 실제로 매우 드 rare니다. 응용 프로그램의 모든 문제를 해결할 가능성이 거의 없습니다. 성능 문제가없는 경우이 문제에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f79677b3826c02d8cce9586f7cdd9b438cd00f7b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;EXTRA&lt;/b&gt; (3)</source>
          <target state="translated">&lt;b&gt;엑스트라&lt;/b&gt; (3)</target>
        </trans-unit>
        <trans-unit id="c939cb6555dba0c5f528d2ad067c4bdcc3d9d627" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Easily Extensible.&lt;/b&gt; As an application grows, new features can be added to an SQLite application file format simply by adding new tables to the schema or by adding new columns to existing tables. Adding columns or tables does not change the meaning of prior queries, so with a modicum of care to ensuring that the meaning of legacy columns and tables are preserved, backwards compatibility is maintained.</source>
          <target state="translated">&lt;b&gt;쉽게 확장 할 수 있습니다. &lt;/b&gt;응용 프로그램이 증가함에 따라 스키마에 새 테이블을 추가하거나 기존 테이블에 새 열을 추가하여 새로운 기능을 SQLite 응용 프로그램 파일 형식에 추가 할 수 있습니다. 열이나 테이블을 추가해도 이전 쿼리의 의미는 바뀌지 않으므로 레거시 열과 테이블의 의미를 유지하고 이전 버전과의 호환성이 유지되도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="9ec8223f83f404abd9852361e4f0392d9db7a5cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Editorial Note:&lt;/b&gt; This document describes SQLite version 2, which was deprecated and replaced by SQLite3 in 2004. This document is retained as part of the historical record of SQLite. Modern programmers should refer to more up-to-date documentation on SQLite is available elsewhere on this website.</source>
          <target state="translated">&lt;b&gt;편집 참고 :&lt;/b&gt; 이 문서는 2004 년에 더 이상 사용되지 않고 SQLite3으로 대체 된 SQLite 버전 2에 대해 설명합니다 &lt;b&gt;.&lt;/b&gt; 이 문서는 SQLite의 과거 기록의 일부로 유지됩니다. 현대 프로그래머는이 웹 사이트의 다른 곳에서 구할 수있는 SQLite에 대한 최신 설명서를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="67147b451d3aa8d2422ff9207e8aff52d1e2abfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Editorial Note:&lt;/b&gt; This document was written in 2004 as a guide to programmers who were transitioning from SQLite2 to SQLite3. It is retained as part of the historical record of SQLite. Modern programmers should refer to more up-to-date documentation on SQLite available elsewhere on this website.</source>
          <target state="translated">&lt;b&gt;편집 참고 :&lt;/b&gt; 이 문서는 2004 년에 SQLite2에서 SQLite3으로 전환하는 프로그래머를위한 안내서로 작성되었습니다. SQLite의 기록 레코드의 일부로 유지됩니다. 현대 프로그래머는이 웹 사이트의 다른 곳에서 구할 수있는 SQLite에 대한 최신 설명서를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbcbea791ce55ba88e5749053d78db7d46a0cef6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Education and Training&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;교육과 훈련&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7d82cddb74a43bc253719751c620b21117dd21d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Embedded devices and the internet of things&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;임베디드 장치 및 사물 인터넷&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18f91cf7d40dd26f866b4af91224f9f7fff8ed0c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Enhancements to makefiles:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;makefile 개선 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d6e43cb9b1d6984306e2f79820e2e490d99b40d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Enhancements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 개선 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d5bda2f960648c6442d9cf2656b3aea9249fb54" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Enhancements to the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 향상 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2de9f95c307e08717c431c992569ee1ca473419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Error handling&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;오류 처리&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="62a0ead10a10503b1bea02718915650d82d81359" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Every WITHOUT ROWID table must have a PRIMARY KEY.&lt;/b&gt; An attempt to create a WITHOUT ROWID table without a PRIMARY KEY results in an error.</source>
          <target state="translated">&lt;b&gt;모든 WITHOUT ROWID 테이블에는 PRIMARY KEY가 있어야합니다. &lt;/b&gt;PRIMARY KEY없이 WITHOUT ROWID 테이블을 작성하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c0502173d99ec8b9c5b5780802f3524540bd750e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Experimental SQL language extensions&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;실험적인 SQL 언어 확장&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5669ae1e716d7e546f45a39dacf3a6816e4dda8d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Extensive, detailed documentation&lt;/b&gt; &amp;rarr; SQLite has candid, developer-friendly, and open-source documentation. Docs are written by and for programmers. (A few examples: &lt;a href=&quot;arch&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;fileformat&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;queryplanner&quot;&gt;[3]&lt;/a&gt;&lt;a href=&quot;opcode&quot;&gt;[4]&lt;/a&gt;&lt;a href=&quot;compile&quot;&gt;[5]&lt;/a&gt;&lt;a href=&quot;malloc&quot;&gt;[6]&lt;/a&gt;&lt;a href=&quot;debugging&quot;&gt;[7]&lt;/a&gt;&lt;a href=&quot;howtocorrupt&quot;&gt;[8]&lt;/a&gt;) The extensive documentation helps new developers come up to speed on SQLite very quickly.</source>
          <target state="translated">&lt;b&gt;광범위하고 자세한 문서&lt;/b&gt; &amp;rarr; SQLite는 솔직하고 개발자 친화적이며 오픈 소스 문서입니다. 문서는 프로그래머가 작성합니다. (몇 가지 예 : &lt;a href=&quot;arch&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;fileformat&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;queryplanner&quot;&gt;[3] &lt;/a&gt;&lt;a href=&quot;opcode&quot;&gt;[4] &lt;/a&gt;&lt;a href=&quot;compile&quot;&gt;[5] &lt;/a&gt;&lt;a href=&quot;malloc&quot;&gt;[6] &lt;/a&gt;&lt;a href=&quot;debugging&quot;&gt;[7] &lt;/a&gt;&lt;a href=&quot;howtocorrupt&quot;&gt;[8]&lt;/a&gt; ) 광범위한 문서는 새로운 개발자가 SQLite를 매우 빠르게 익힐 수 있도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="a9af100086bbaf75ddb2d283899375da0163b265" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;External Dependencies.&lt;/b&gt; Degree to which a particular format depends on particular hardware, operating system, or software for rendering or use and the predicted complexity of dealing with those dependencies in future technical environments.</source>
          <target state="translated">&lt;b&gt;외부 의존성. &lt;/b&gt;렌더링 또는 사용을 위해 특정 하드웨어, 운영 체제 또는 소프트웨어에 따라 특정 형식이 결정되는 정도 및 향후 기술 환경에서 이러한 종속성을 처리하는 데 필요한 복잡성을 예측합니다.</target>
        </trans-unit>
        <trans-unit id="1ebaf4b61f2dd47f7bdff1c828ca895c0a0bcf55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;FAIL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;FAIL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1de61cbf572cbc0fbd0c3cf97e3c36d728c46fef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;FTS5_TOKENIZE_AUX&lt;/b&gt; - The tokenizer is being invoked to satisfy an fts5_api.xTokenize() request made by an auxiliary function. Or an fts5_api.xColumnSize() request made by the same on a columnsize=0 database.</source>
          <target state="translated">&lt;b&gt;FTS5_TOKENIZE_AUX-&lt;/b&gt; 토크 나이저가 보조 함수에 의해 작성된 fts5_api.xTokenize () 요청을 충족시키기 위해 호출됩니다. 또는 columnsize = 0 데이터베이스에서 동일하게 작성된 fts5_api.xColumnSize () 요청.</target>
        </trans-unit>
        <trans-unit id="dfd59cbc1bc8c7a8496986f39b206d39984b5750" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;FTS5_TOKENIZE_DOCUMENT&lt;/b&gt; - A document is being inserted into or removed from the FTS table. The tokenizer is being invoked to determine the set of tokens to add to (or delete from) the FTS index.</source>
          <target state="translated">&lt;b&gt;FTS5_TOKENIZE_DOCUMENT-&lt;/b&gt; 문서가 FTS 테이블에 삽입 또는 제거되고 있습니다. FTS 인덱스에 추가하거나 삭제할 토큰 세트를 결정하기 위해 토크 나이저가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd5fd901f2f00b745b0e43f52abf1c34f69b0df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;FTS5_TOKENIZE_QUERY&lt;/b&gt; - A MATCH query is being executed against the FTS index. The tokenizer is being called to tokenize a bareword or quoted string specified as part of the query.</source>
          <target state="translated">&lt;b&gt;FTS5_TOKENIZE_QUERY&lt;/b&gt; -FTS 인덱스에 대해 MATCH 쿼리가 실행되고 있습니다. 토크 나이 저는 쿼리의 일부로 지정된 베어 워드 또는 인용 문자열을 토큰 화하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f656f155e4dd577b512f131fab3e313af4e7a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;FULL&lt;/b&gt; (2)</source>
          <target state="translated">&lt;b&gt;전체&lt;/b&gt; (2)</target>
        </trans-unit>
        <trans-unit id="c849f4f2695c1275d1504620b275d7de739b426e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;File and Database Connection Locking&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;파일 및 데이터베이스 연결 잠금&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6875785ff15efae50a6d685e207c28d265a55b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;File archive and/or data container&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;파일 아카이브 및 / 또는 데이터 컨테이너&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="783f3b27505c4738ae984e6fa127b4ed0aae6936" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Fossil:&lt;/b&gt;&lt;a href=&quot;https://sqlite.org/src/timeline?r=prefer-coroutine-sort-subquery&quot;&gt;https://sqlite.org/src/timeline?r=prefer-coroutine-sort-subquery&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;Fossil:&lt;/b&gt;&lt;a href=&quot;https://sqlite.org/src/timeline?r=prefer-coroutine-sort-subquery&quot;&gt;https://sqlite.org/src/timeline?r=prefer-coroutine-sort-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d925010f1da1a56364c855946d2ad1d8c7d0d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Freeing memory not obtained from malloc.&lt;/b&gt; Each memory allocation from the instrumented memory allocator contains sentinels used to verify that every allocation freed came from prior malloc.</source>
          <target state="translated">&lt;b&gt;malloc에서 확보 한 메모리를 확보하지 못했습니다. &lt;/b&gt;인스트루먼트 된 메모리 할당 기의 각 메모리 할당에는 사용 가능한 모든 할당이 이전 malloc에서 온 것인지 확인하는 데 사용되는 센티넬이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="35d119f57edad26d65c1d32cee538f16b6d60bf8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Full-text query&lt;/b&gt;. If the WHERE clause of the SELECT statement contains a sub-clause of the form &quot;&amp;lt;column&amp;gt; MATCH ?&quot;, FTS is able to use the built-in full-text index to restrict the search to those documents that match the full-text query string specified as the right-hand operand of the MATCH clause.</source>
          <target state="translated">&lt;b&gt;전체 텍스트 쿼리&lt;/b&gt; . SELECT 문의 WHERE 절에 &quot;&amp;lt;column&amp;gt; MATCH?&quot;형식의 하위 절이 포함되어 있으면 FTS는 기본 제공 전체 텍스트 인덱스를 사용하여 전체 텍스트와 일치하는 문서로 검색을 제한 할 수 있습니다. MATCH 절의 오른쪽 피연산자로 지정된 쿼리 문자열.</target>
        </trans-unit>
        <trans-unit id="f1923d0853ade26ea73756b1593004c32840042f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Fully Custom Formats.&lt;/b&gt; Custom formats are specifically designed for a single application. DOC, DWG, PDF, XLS, and PPT are examples of custom formats. Custom formats are usually contained within a single file, for ease of transport. They are also usually binary, though the DWG format is a notable exception. Custom file formats require specialized application code to read and write and are not normally accessible from commonly available tools such as unix command-line programs and text editors. In other words, custom formats are usually &quot;opaque blobs&quot;. To access the content of a custom application file format, one needs a tool specifically engineered to read and/or write that format.</source>
          <target state="translated">&lt;b&gt;완전 맞춤형 형식.&lt;/b&gt; 사용자 정의 형식은 단일 응용 프로그램을 위해 특별히 설계되었습니다. DOC, DWG, PDF, XLS 및 PPT는 사용자 정의 형식의 예입니다. 사용자 정의 형식은 일반적으로 전송하기 쉽도록 단일 파일 내에 포함됩니다. DWG 형식은 눈에 띄는 예외이지만 일반적으로 이진입니다. 사용자 정의 파일 형식은 읽고 쓰는 데 특수 응용 프로그램 코드가 필요하며 일반적으로 유닉스 명령 줄 프로그램 및 텍스트 편집기와 같은 일반적으로 사용 가능한 도구로는 액세스 할 수 없습니다. 즉, 사용자 지정 형식은 일반적으로 &quot;불투명 한 얼룩&quot;입니다. 사용자 지정 응용 프로그램 파일 형식의 내용에 액세스하려면 해당 형식을 읽거나 쓰도록 특별히 설계된 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="22a3557ebffb648b50f26333f00df80d52a34aab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;GROUPS &amp;rarr;&lt;/b&gt; A &quot;group&quot; is a set of peer rows - rows that all have the same values for every term in the ORDER BY clause. The frame boundary is the group that is &amp;lt;expr&amp;gt; groups before the group containing the current row, or the first group of the partition if there are fewer than &amp;lt;expr&amp;gt; groups before the current row. For the starting boundary of a frame, the first row of the group is used and for the ending boundary of a frame, the last row of the group is used. &amp;lt;expr&amp;gt; must be an integer.</source>
          <target state="translated">&lt;b&gt;GROUPS &amp;rarr;&lt;/b&gt; &quot;group&quot;은 ORDER BY 절의 모든 용어에 대해 동일한 값을 갖는 행 (행)의 집합입니다. 프레임 경계는 현재 행을 포함하는 그룹 이전의 &amp;lt;expr&amp;gt; 그룹 인 그룹 또는 현재 행 앞에 &amp;lt;expr&amp;gt; 그룹 미만인 경우 파티션의 첫 번째 그룹입니다. 프레임의 시작 경계에는 그룹의 첫 번째 행이 사용되고 프레임의 끝 경계에는 그룹의 마지막 행이 사용됩니다. &amp;lt;expr&amp;gt;은 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="51f1b6ea467bd6a61492cfd3469678de786d20f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;GROUPS&lt;/b&gt;: The GROUPS frame type means that the starting and ending boundaries are determine by counting &quot;groups&quot; relative to the current group. A &quot;group&quot; is a set of rows that all have equivalent values for all all terms of the window ORDER BY clause. (&quot;Equivalent&quot; means that the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is true when comparing the two values.) In other words, a group consists of all peers of a row.</source>
          <target state="translated">&lt;b&gt;GROUPS&lt;/b&gt; : GROUPS 프레임 유형은 현재 그룹을 기준으로 &quot;그룹&quot;을 세어 시작 및 끝 경계를 결정 함을 의미합니다. &quot;그룹&quot;은 창 ORDER BY 절의 모든 항에 대해 동등한 값을 갖는 행 세트입니다. ( &quot;등가&quot; 는 두 값을 비교할 때 &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS 연산자&lt;/a&gt; 가 참 임을 의미 합니다.) 즉, 그룹은 행의 모든 ​​피어로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b67eb8be640148ed59fd70a81b8a8ce2de5c99e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;General improvements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;일반적인 개선 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="86d0fe4e8a715b802eb3b327d1fd9e3d26c4858e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;GitHub:&lt;/b&gt;&lt;a href=&quot;https://github.com/sqlite/sqlite/commits/prefer-coroutine-sort-subquery&quot;&gt;https://github.com/sqlite/sqlite/commits/prefer-coroutine-sort-subquery&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;GitHub:&lt;/b&gt;&lt;a href=&quot;https://github.com/sqlite/sqlite/commits/prefer-coroutine-sort-subquery&quot;&gt;https://github.com/sqlite/sqlite/commits/prefer-coroutine-sort-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0932519e29992e06ec3bcb39372a43618f3c3c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Goofy Interface Alert:&lt;/b&gt; In the legacy interface, the sqlite3_step() API always returns a generic error code, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, following any error other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. You must call &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; in order to find one of the specific &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; that better describes the error. We admit that this is a goofy design. The problem has been fixed with the &quot;v2&quot; interface. If you prepare all of your SQL statements using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; instead of the legacy &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt; interfaces, then the more specific &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; are returned directly by sqlite3_step(). The use of the &quot;vX&quot; interfaces is recommended.</source>
          <target state="translated">&lt;b&gt;구피 인터페이스 경고 :&lt;/b&gt; 레거시 인터페이스에서 sqlite3_step () API 는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 및 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 이외의 오류 뒤에 항상 일반 오류 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR를 &lt;/a&gt;반환합니다 . &lt;a href=&quot;rescode&quot;&gt;오류&lt;/a&gt; 를보다 잘 설명하는 특정 오류 코드 중 하나를 찾으려면 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 를 호출해야합니다 . 우리는 이것이 구피 디자인임을 인정합니다. &quot;v2&quot;인터페이스로 문제가 해결되었습니다. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()을&lt;/a&gt; 사용하여 모든 SQL 문을 준비하는 경우레거시 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 인터페이스 대신 보다 구체적인 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 sqlite3_step ()에 의해 직접 반환됩니다. &quot;vX&quot;인터페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d8c5237c781096ef872e1e231a7288f8d8aede9b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Goofy Interface Alert:&lt;/b&gt; In the legacy interface, the sqlite3_step() API always returns a generic error code, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, following any error other than &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; and &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. You must call &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; in order to find one of the specific &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; that better describes the error. We admit that this is a goofy design. The problem has been fixed with the &quot;v2&quot; interface. If you prepare all of your SQL statements using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; instead of the legacy &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt; interfaces, then the more specific &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; are returned directly by sqlite3_step(). The use of the &quot;vX&quot; interfaces is recommended.</source>
          <target state="translated">&lt;b&gt;구피 인터페이스 경고 :&lt;/b&gt; 레거시 인터페이스에서 sqlite3_step () API 는 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 및 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 이외의 오류 뒤에 항상 일반 오류 코드 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR를 &lt;/a&gt;반환합니다 . &lt;a href=&quot;../rescode&quot;&gt;오류&lt;/a&gt; 를보다 잘 설명하는 특정 오류 코드 중 하나를 찾으려면 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 를 호출해야합니다 . 우리는 이것이 구피 디자인임을 인정합니다. &quot;v2&quot;인터페이스로 문제가 해결되었습니다. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()을&lt;/a&gt; 사용하여 모든 SQL 문을 준비하는 경우레거시 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 인터페이스 대신 보다 구체적인 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 sqlite3_step ()에 의해 직접 반환됩니다. &quot;vX&quot;인터페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2361899431c4b3189a42aa3e83eda715d8150621" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_FDATASYNC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_FDATASYNC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad694b2b86473e86ff26d195e67b8c0ac1d45a10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_GMTIME_R&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_GMTIME_R&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a008e0044d1f9b704010cdf7a007f2e6fffb93fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_ISNAN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_ISNAN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="689ce9760982165bb1115414b75039f78b6c4ba1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_LOCALTIME_R&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_LOCALTIME_R&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="73f7ed908c52b28b49126e4fa2a687d44a6aff24" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_LOCALTIME_S&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_LOCALTIME_S&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5c1436542dde0fcf99fd61bebfe40640a8cacb68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_MALLOC_USABLE_SIZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_MALLOC_USABLE_SIZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6072a89b31518ff693ef96d24455282dbaae00c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_STRCHRNUL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_STRCHRNUL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="efcbb25090db53f6552cedd8ff4a9dfecdb2c986" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_USLEEP&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_USLEEP&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05c6bf5f606292f9b501f06d287e512f42f8440f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;HAVE_UTIME&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;HAVE_UTIME&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3f90f54d07f5fe8a2ea644ef71c89e82030559a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Hashes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Hashes:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e785b248f6c87bc3cc43b4ef877f8aecd6c55aba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Heavily commented source code&lt;/b&gt; &amp;rarr; The SQLite source code is over 35% comment. Not boiler-plate comments, but useful comments that explain the meaning of variables and objects and the intent of methods and procedures. The code is designed to be accessible to new programmers and maintainable over a span of decades.</source>
          <target state="translated">&lt;b&gt;주석이 많은 소스 코드&lt;/b&gt; &amp;rarr; SQLite 소스 코드가 35 % 이상의 주석입니다. 보일러 플레이트 주석이 아니라 변수 및 객체의 의미와 방법 및 절차의 의도를 설명하는 유용한 주석입니다. 이 코드는 새로운 프로그래머가 액세스 할 수 있도록 설계되었으며 수십 년에 걸쳐 유지 보수가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8334f6bea1bc5c05f130996dd29cd2b29b1ddab9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;High Concurrency&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;높은 동시성&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d77811ae28fca9d8a2880eccdcf0590822d89c95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;High-Level Query Language.&lt;/b&gt; SQLite is a complete relational database engine, which means that the application can access content using high-level queries. Application developers need not spend time thinking about &quot;how&quot; to retrieve the information they need from a document. Developers write SQL that expresses &quot;what&quot; information they want and let the database engine to figure out how to best retrieve that content. This helps developers operate &quot;heads up&quot; and remain focused on solving the user's problem, and avoid time spent &quot;heads down&quot; fiddling with low-level file formatting details.</source>
          <target state="translated">&lt;b&gt;고급 쿼리 언어. &lt;/b&gt;SQLite는 완전한 관계형 데이터베이스 엔진으로, 응용 프로그램이 높은 수준의 쿼리를 사용하여 콘텐츠에 액세스 할 수 있습니다. 응용 프로그램 개발자는 문서에서 필요한 정보를 검색하는 &quot;방법&quot;에 대해 생각할 필요가 없습니다. 개발자는 원하는 &quot;무엇&quot;정보를 나타내는 SQL을 작성하고 데이터베이스 엔진이 해당 컨텐츠를 가장 잘 검색하는 방법을 알아낼 수있게합니다. 이를 통해 개발자는 &quot;헤드 업&quot;을 수행하고 사용자의 문제를 해결하는 데 집중하고 하위 수준의 파일 형식 세부 정보로 &quot;헤드 다운&quot;에 걸리는 시간을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a35eac17a5517e734657403d5a0db91f667d61c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;High-volume Websites&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;대용량 웹 사이트&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bafa47de757a66e06f9b04ff90e780821181a0c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;IGNORE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;IGNORE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c06c1fefb7dabca9e432265e24500a758aedf3d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;INSERT INTO &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;에 집어 넣다 &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1691e49c9c60e6db50cb55bbd45655f73bb2d91a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;INTEGER&lt;/b&gt; as Unix Time, the number of seconds since 1970-01-01 00:00:00 UTC.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;1970-01-01 00:00:00 UTC 이후의 초 수인 유닉스 시간으로 &lt;b&gt;INTEGER&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="26656f81d28aa177784600fde36f0d3f60e5854b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;INTEGER&lt;/b&gt;. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.</source>
          <target state="translated">&lt;b&gt;INTEGER&lt;/b&gt; . 값은 부호의 정수이며 값의 크기에 따라 1, 2, 3, 4, 6 또는 8 바이트로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b91b26d94ca8c1712c6899c76ff83ad5c61a0184" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;If you must use a low-quality index, be sure to run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;.&lt;/b&gt; Low-quality indexes will not confuse the query planner as long as the query planner knows that the indexes are of low quality. And the way the query planner knows this is by the content of the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table, which is computed by the ANALYZE command.</source>
          <target state="translated">&lt;b&gt;품질이 낮은 색인을 사용해야하는 경우 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하십시오 . &lt;/b&gt;쿼리 플래너가 인덱스의 품질이 낮다는 것을 알고있는 한 품질이 낮은 인덱스는 쿼리 플래너를 혼동하지 않습니다. 쿼리 플래너가이를 알고있는 방법 은 ANALYZE 명령으로 계산되는 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; 테이블 의 컨텐츠에 의한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f1dd46adad95114a6e19e4d83d15f05ab3bd235" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Impact of Patents.&lt;/b&gt; Degree to which the ability of archival institutions to sustain content in a format will be inhibited by patents.</source>
          <target state="translated">&lt;b&gt;특허의 영향. &lt;/b&gt;보관 기관이 콘텐츠를 형식으로 유지할 수있는 능력은 특허에 의해 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec6b989d73bbf9b3363ada6320215b6e80a7fa5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important bug fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;중요한 버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4902c398404e8d1677cd8a93a0799692f2d48508" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;중요한 수정 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2fc5a18ab476b492409672c6c8e6e10bb970ddfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important:&lt;/b&gt; This interface is &lt;a href=&quot;../c3ref/experimental&quot;&gt;experimental&lt;/a&gt; and is subject to change without notice.</source>
          <target state="translated">&lt;b&gt;중요 :&lt;/b&gt; 이 인터페이스는 &lt;a href=&quot;../c3ref/experimental&quot;&gt;실험용&lt;/a&gt; 이며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ea03061d790f24d5186d93c745886676c0b539" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important:&lt;/b&gt; This interface is &lt;a href=&quot;c3ref/experimental&quot;&gt;experimental&lt;/a&gt; and is subject to change without notice.</source>
          <target state="translated">&lt;b&gt;중요 :&lt;/b&gt; 이 인터페이스는 &lt;a href=&quot;c3ref/experimental&quot;&gt;실험용&lt;/a&gt; 이며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37585308f35f7042267e9ea422b5d2b460ac971" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Incremental And Continuous Updates.&lt;/b&gt; When writing to an SQLite database file, only those parts of the file that actually change are written out to disk. This makes the writing happen faster and saves wear on SSDs. This is an enormous advantage over custom and wrapped pile-of-files formats, both of which usually require a rewrite of the entire document in order to change a single byte. Pure pile-of-files formats can also do incremental updates to some extent, though the granularity of writes is usually larger with pile-of-file formats (a single file) than with SQLite (a single page).</source>
          <target state="translated">&lt;b&gt;증분 및 지속적인 업데이트. &lt;/b&gt;SQLite 데이터베이스 파일에 쓸 때 실제로 변경되는 파일 부분 만 디스크에 기록됩니다. 따라서 쓰기 속도가 빨라지고 SSD의 마모가 줄어 듭니다. 이것은 일반적으로 단일 바이트를 변경하기 위해 전체 문서를 다시 작성해야하는 사용자 정의 및 랩핑 된 파일 더미 형식에 비해 엄청난 이점입니다. 순수한 파일 더미 형식도 어느 정도 증분 업데이트를 수행 할 수 있지만 쓰기 세분성은 일반적으로 SQLite (단일 페이지)보다 파일 더미 형식 (단일 파일)으로 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="b114861c4522a884902870f48990f5d264830a60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Incremental update is hard.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;증분 업데이트가 어렵습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b7278616bc46883ec8980728e3f679bfce5309e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Instrument your code.&lt;/b&gt; Add logic that lets you know quickly and easily which queries are taking too much time. Then work on just those specific queries.</source>
          <target state="translated">&lt;b&gt;코드를 계측하십시오. &lt;/b&gt;너무 많은 시간이 걸리는 쿼리를 빠르고 쉽게 알 수있는 논리를 추가하십시오. 그런 다음 해당 특정 쿼리에 대해서만 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="905c8166a2f95fe374f1c1ac9cd27e80f57c4512" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Internal or temporary databases&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;내부 또는 임시 데이터베이스&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bcbb4a6b0e2b77efa8a6612ac6930c0cb58d959" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Is the data separated from the application by a network? &amp;rarr; choose client/server&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데이터가 네트워크에 의해 응용 프로그램과 분리되어 있습니까? &amp;rarr; 클라이언트 / 서버 선택&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dab5af5a8126b56d87b058e4a388eca00a91bb3b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Mac&lt;/b&gt;: A 2015 MacBook Pro, 3.1GHz intel Core i7, 16GiB RAM, MacOS 10.12.5</source>
          <target state="translated">&lt;b&gt;Mac&lt;/b&gt; : 2015 MacBook Pro, 3.1GHz 인텔 코어 i7, 16GiB RAM, MacOS 10.12.5</target>
        </trans-unit>
        <trans-unit id="41ff24bd102fbdd0a0ff58b1b908d32749e36655" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Makefile improvements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;메이크 파일 개선 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e11e7d287f79d8280d73a2f62ced875a727e6fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Manifest typing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;매니페스트 타이핑&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e603e159bc5bf448765586b157921ece7cf5f12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Many concurrent writers? &amp;rarr; choose client/server&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;동시 작가가 많습니까? &amp;rarr; 클라이언트 / 서버 선택&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5b1ea40584ac9f12571dd633c3e01896bf539917" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Database Size&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;최대 데이터베이스 크기&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="47a277a9c353baff0fa169a1a8ee47120656893b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Depth Of An Expression Tree&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;표현식 트리의 최대 깊이&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="16122be45060124565313c564507690373673bbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Depth Of Trigger Recursion&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;트리거 재귀의 최대 깊이&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d6f64e1e8575c8051120eb72bee973f0b4e72f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Length Of A LIKE Or GLOB Pattern&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;LIKE 또는 GLOB 패턴의 최대 길이&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="92b909d055cf670ca35b20cf11097195b67fde69" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Length Of An SQL Statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQL 문의 최대 길이&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="235d22b98036f18f1c38f9b51dbeb65e0b7cdc4e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Arguments On A Function&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;함수에 대한 최대 인수 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a9ff2f7530abc03bd5c9fbdda1ea6f722de74114" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Attached Databases&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;연결된 데이터베이스의 최대 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eedc6cd153d5045af1125436ddaed3abb20da68a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Columns&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;최대 열 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6362d2cd461dec5dcbfc60987e66ee36d1860942" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Host Parameters In A Single SQL Statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;단일 SQL 문에서 최대 호스트 매개 변수 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1258790c99b8771fe2b8f23f0db4e03741f7a1a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Pages In A Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데이터베이스 파일의 최대 페이지 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e7163f240f66f603b3e20f62078c6794f21934d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Rows In A Table&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;테이블의 최대 행 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2d0bf257d263bb08e10e507a7d5ef997ec690e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Tables In A Join&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;조인의 최대 테이블 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f79933923d7ad307575bd24d2cb1b8307eed7b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Tables In A Schema&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;스키마의 최대 테이블 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="169c2ec60ca25de1ab997ca1eb6f1443ea741306" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum Number Of Terms In A Compound SELECT Statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;복합 SELECT 문의 최대 용어 수&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e56d33967a7fcefbdc65a5ee080540ae930c877" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum length of a string or BLOB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;문자열 또는 BLOB의 최대 길이&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3d0e1aab3f55a04c767df99678fb92226f23d442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Maximum rowid&lt;/b&gt;. The smallest rowid value that the component table may contain.</source>
          <target state="translated">&lt;b&gt;최대 rowid로&lt;/b&gt; . 구성 요소 테이블에 포함될 수있는 가장 작은 rowid 값입니다.</target>
        </trans-unit>
        <trans-unit id="6318f29d05d966104949282460b1df59508c41bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Memory usage limits.&lt;/b&gt; The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; mechanism allows the application to set a memory usage limit that SQLite strives to stay below. SQLite will attempt to reuse memory from its caches rather than allocating new memory as it approaches the soft limit.</source>
          <target state="translated">&lt;b&gt;메모리 사용 제한 &lt;/b&gt;&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 메커니즘은 SQLite는 최선의 노력을 기울이고 아래에 머물 수있는 메모리 사용 제한을 설정하도록 응용 프로그램을 할 수 있습니다. SQLite는 소프트 한계에 접근 할 때 새 메모리를 할당하지 않고 캐시에서 메모리를 재사용하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f61cf344077cd4c8c3b57db289515e56b78fb80f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Memory usage statistics.&lt;/b&gt; Applications can see how much memory they are using and detect when memory usage is approaching or exceeding design boundaries.</source>
          <target state="translated">&lt;b&gt;메모리 사용량 통계. &lt;/b&gt;애플리케이션은 사용중인 메모리 양을 확인하고 메모리 사용량이 설계 경계에 도달하거나이를 초과하는 시점을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346c3edf0c186f42ef11577264ff728d408c1d20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Minimal calls to the allocator.&lt;/b&gt; The system malloc() and free() implementations are inefficient on many systems. SQLite strives to reduce overall processing time by minimizing its use of malloc() and free().</source>
          <target state="translated">&lt;b&gt;할당 자에 대한 최소 호출. &lt;/b&gt;시스템 malloc () 및 free () 구현은 많은 시스템에서 비효율적입니다. SQLite는 malloc () 및 free () 사용을 최소화하여 전체 처리 시간을 단축하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="b673c9e63e004b0100dfc535e9d853efdab058cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Minimum rowid&lt;/b&gt;. The smallest rowid value that the component table may contain.</source>
          <target state="translated">&lt;b&gt;최소 rowid로&lt;/b&gt; . 구성 요소 테이블에 포함될 수있는 가장 작은 rowid 값입니다.</target>
        </trans-unit>
        <trans-unit id="8854a71cda0085046b9147447cbd41e78a4e1177" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;More memory is required.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;더 많은 메모리가 필요합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="adf6ecb6b32f577e6034acbe2733682fb3971d41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Multi-thread&lt;/b&gt;. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</source>
          <target state="translated">&lt;b&gt;멀티 스레드&lt;/b&gt; . 이 모드에서는 단일 데이터베이스 연결이 둘 이상의 스레드에서 동시에 사용되지 않는 경우 여러 스레드에서 SQLite를 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e561077759c3b37ee660c8471d465edf7d23f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Multiple Programming Languages.&lt;/b&gt; Though SQLite is itself written in ANSI-C, interfaces exist for just about every other programming language you can think of: C++, C#, Objective-C, Java, Tcl, Perl, Python, Ruby, Erlang, JavaScript, and so forth. So programmers can develop in whatever language they are most comfortable with and which best matches the needs of the project.</source>
          <target state="translated">&lt;b&gt;여러 프로그래밍 언어. &lt;/b&gt;SQLite 자체는 ANSI-C로 작성되었지만 C ++, C #, Objective-C, Java, Tcl, Perl, Python, Ruby, Erlang, JavaScript 등 생각할 수있는 다른 모든 프로그래밍 언어에 대한 인터페이스가 존재합니다. 따라서 프로그래머는 가장 편한 언어로 프로젝트 요구에 가장 잘 맞는 언어로 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbbccf371c0e234307bee4d30da38a5ab800fce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NEAR queries&lt;/b&gt;. A NEAR query is a query that returns documents that contain a two or more nominated terms or phrases within a specified proximity of each other (by default with 10 or less intervening terms). A NEAR query is specified by putting the keyword &quot;NEAR&quot; between two phrase, token or token prefix queries. To specify a proximity other than the default, an operator of the form &quot;NEAR/</source>
          <target state="translated">&lt;b&gt;검색어가 거의 없습니다&lt;/b&gt; . NEAR 쿼리는 서로 지정된 거리 내에 둘 이상의 지명 된 용어 또는 구가 포함 된 문서를 반환하는 쿼리입니다 (기본적으로 10 개 이하의 용어가 포함됨). NEAR 쿼리는 토큰 또는 토큰 접두사 쿼리라는 두 구 사이에 키워드 &quot;NEAR&quot;을 넣어 지정합니다. 기본값 이외의 근접성을 지정하려면 &quot;NEAR /</target>
        </trans-unit>
        <trans-unit id="dc6e2c1220d03e58ac2509cb68f476535ca76ad4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NEVER(X)&lt;/b&gt; &amp;rarr; The NEVER(X) function indicates that condition X is never true. This is the negative analog of the ALWAYS(X) function.</source>
          <target state="translated">&lt;b&gt;NEVER (X)&lt;/b&gt; &amp;rarr; NEVER (X) 함수는 조건 X가 참이 아님을 나타냅니다. 이것은 ALWAYS (X) 함수의 음의 아날로그입니다.</target>
        </trans-unit>
        <trans-unit id="487c11243d3fac95cee85c11a75c7074cf502311" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NO ACTION&lt;/b&gt;: Configuring &quot;NO ACTION&quot; means just that: when a parent key is modified or deleted from the database, no special action is taken.</source>
          <target state="translated">&lt;b&gt;NO ACTION&lt;/b&gt; : &quot;NO ACTION&quot;구성은 다음을 의미합니다. 부모 키가 데이터베이스에서 수정되거나 삭제 될 때 특별한 조치가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73bf333ea09aa218cf78c2dd7bfb9dec4bd07bda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOCASE&lt;/b&gt; - The same as binary, except the 26 upper case characters of ASCII are folded to their lower case equivalents before the comparison is performed. Note that only ASCII characters are case folded. SQLite does not attempt to do full UTF case folding due to the size of the tables required.</source>
          <target state="translated">&lt;b&gt;NOCASE&lt;/b&gt; -ASCII의 26 개의 대문자가 비교를 수행하기 전에 소문자로 접힌 &lt;b&gt;다는&lt;/b&gt; 점을 제외하면 2 &lt;b&gt;진과&lt;/b&gt; 동일합니다. ASCII 문자 만 대소 문자를 구분합니다. SQLite는 필요한 테이블 크기로 인해 전체 UTF 케이스 접기를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73917940be12b8220f84e5b4e122d810efa37b48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NORMAL&lt;/b&gt; (1)</source>
          <target state="translated">&lt;b&gt;노멀&lt;/b&gt; (1)</target>
        </trans-unit>
        <trans-unit id="3166160b441c48e36b2b91d3bbf403ed10e55a52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOT NULL is enforced on every column of the PRIMARY KEY in a WITHOUT ROWID table.&lt;/b&gt; This is in accordance with the SQL standard. Each column of a PRIMARY KEY is supposed to be individually NOT NULL. However, NOT NULL was not enforced on PRIMARY KEY columns by early versions of SQLite due to a bug. By the time that this bug was discovered, so many SQLite databases were already in circulation that the decision was made not to fix this bug for fear of breaking compatibility. So, ordinary rowid tables in SQLite violate the SQL standard and allow NULL values in PRIMARY KEY fields. But WITHOUT ROWID tables do follow the standard and will throw an error on any attempt to insert a NULL into a PRIMARY KEY column.</source>
          <target state="translated">&lt;b&gt;WITHOUT ROWID 테이블에서 PRIMARY KEY의 모든 열에 NOT NULL이 적용됩니다.&lt;/b&gt; 이것은 SQL 표준에 따릅니다. PRIMARY KEY의 각 열은 개별적으로 NOT NULL이어야합니다. 그러나 버그로 인해 초기 버전의 SQLite에서 PRIMARY KEY 열에 NOT NULL을 적용하지 않았습니다. 이 버그가 발견 될 당시에는 많은 SQLite 데이터베이스가 이미 유통되고 있었기 때문에 호환성을 깨뜨릴 염려가 있으므로이 버그를 수정하지 않기로 결정했습니다. 따라서 SQLite의 일반 rowid 테이블은 SQL 표준을 위반하고 PRIMARY KEY 필드에서 NULL 값을 허용합니다. 그러나 WITHOUT ROWID 테이블은 표준을 따르며 PRIMARY KEY 열에 NULL을 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc95fb99938c21923a9788d0583a16ed520163ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOTE:&lt;/b&gt;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL avoids calls to fsync() during transaction commit and only invokes fsync() during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. The use of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; largely obviates the need for this asynchronous I/O module. Hence, this module is no longer supported. The source code continues to exist in the SQLite source tree, but it is not a part of any standard build and is no longer maintained. This documentation is retained for historical reference.</source>
          <target state="translated">&lt;b&gt;참고 : &lt;/b&gt;&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 NORMAL로 설정된 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 는 트랜잭션 커밋 동안 fsync ()에 대한 호출을 피하고 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업 중에 만 fsync ()를 호출 합니다. &lt;a href=&quot;wal&quot;&gt;WAL 모드를&lt;/a&gt; 사용 하면이 비동기 I / O 모듈이 필요하지 않습니다. 따라서이 모듈은 더 이상 지원되지 않습니다. 소스 코드는 SQLite 소스 트리에 계속 존재하지만 표준 빌드의 일부가 아니며 더 이상 유지 관리되지 않습니다. 이 문서는 기록 참조 용으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="fca578107aaae50ff26d325fed0b62080c6889c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NULL&lt;/b&gt;. The value is a NULL value.</source>
          <target state="translated">&lt;b&gt;NULL&lt;/b&gt; . 값은 NULL 값입니다.</target>
        </trans-unit>
        <trans-unit id="e60921d575a23c23be358d8fdf5a97676ed11dc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Neo-Serverless:&lt;/b&gt; The database engine runs in a separate namespace from the application, probably on a separate machine, but the database is provided as a turn-key service by the hosting provider, requires no management or administration by the application owners, and is so easy to use that the developers can think of the database as being serverless even if it really does use a server under the covers.</source>
          <target state="translated">&lt;b&gt;네오 서버리스 (Neo-Serverless) :&lt;/b&gt; 데이터베이스 엔진은 응용 프로그램과 별도의 네임 스페이스에서, 아마도 별도의 컴퓨터에서 실행되지만 데이터베이스는 호스팅 공급자가 턴키 서비스로 제공하며 응용 프로그램 소유자의 관리 나 관리가 필요하지 않습니다. 개발자는 데이터베이스가 실제로 서버를 사용하더라도 서버가없는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="909ffbf0ae97af25590d0beca9f09f95e1eb7f6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New Features And Enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;새로운 기능 및 개선 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4094fb73a2434b6f612129976d4358e6c63a97c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New Features:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;새로운 기능 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87ec9bcc3d59100d87299b8acd1d29514ed4eae1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;New feature:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;새로운 기능:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52148d849517ab1764396005cd63ec9ff28d2ca7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No memory leaks.&lt;/b&gt; The application is responsible for destroying any objects it allocates. (For example, the application must use &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on every &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on every &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.) But as long as the application cooperates, SQLite will never leak memory. This is true even in the face of memory allocation failures or other system errors.</source>
          <target state="translated">&lt;b&gt;메모리 누수가 없습니다.&lt;/b&gt; 응용 프로그램은 할당 된 객체를 파기해야합니다. (예를 들어, 응용 프로그램을 사용해야합니다 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize를 ()&lt;/a&gt; 마다에 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 및 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 마다에 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; .) 그러나 한 응용 프로그램 연동으로, SQLite는 메모리를 누출하지 않습니다. 이는 메모리 할당 실패 또는 기타 시스템 오류가 발생하더라도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b2e8146a12b6e95ae9f367f65ae55cd056327016" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No support for switching constraints between deferred and immediate mode.&lt;/b&gt; Many systems allow the user to toggle individual foreign key constraints between &lt;a href=&quot;#fk_deferred&quot;&gt;deferred&lt;/a&gt; and immediate mode at runtime (for example using the Oracle &quot;SET CONSTRAINT&quot; command). SQLite does not support this. In SQLite, a foreign key constraint is permanently marked as deferred or immediate when it is created.</source>
          <target state="translated">&lt;b&gt;지연 모드와 즉시 모드 간 제약 조건 전환을 지원하지 않습니다.&lt;/b&gt; 많은 시스템에서 사용자 는 런타임시 (예 : Oracle &quot;SET CONSTRAINT&quot;명령 사용) &lt;a href=&quot;#fk_deferred&quot;&gt;지연&lt;/a&gt; 모드와 즉시 모드 간에 개별 외래 키 제약 조건을 전환 할 수 있습니다 . SQLite는 이것을 지원하지 않습니다. SQLite에서 외래 키 제약 조건은 생성 될 때 영구적으로 지연되거나 즉시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="be87423d536436e28041d8e31466ad6f3ca43fc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;No support for the MATCH clause.&lt;/b&gt; According to SQL92, a MATCH clause may be attached to a composite foreign key definition to modify the way NULL values that occur in child keys are handled. If &quot;MATCH SIMPLE&quot; is specified, then a child key is not required to correspond to any row of the parent table if one or more of the child key values are NULL. If &quot;MATCH FULL&quot; is specified, then if any of the child key values is NULL, no corresponding row in the parent table is required, but all child key values must be NULL. Finally, if the foreign key constraint is declared as &quot;MATCH PARTIAL&quot; and one of the child key values is NULL, there must exist at least one row in the parent table for which the non-NULL child key values match the parent key values.</source>
          <target state="translated">&lt;b&gt;MATCH 절을 지원하지 않습니다.&lt;/b&gt; SQL92에 따르면, MATCH 절은 복합 외부 키 정의에 첨부되어 하위 키에서 발생하는 NULL 값이 처리되는 방식을 수정할 수 있습니다. &quot;MATCH SIMPLE&quot;이 지정된 경우 하나 이상의 하위 키 값이 NULL 인 경우 하위 키는 상위 테이블의 행에 해당하지 않아도됩니다. &quot;MATCH FULL&quot;이 지정된 경우, 하위 키 값 중 하나가 NULL이면 상위 테이블의 해당 행이 필요하지 않지만 모든 하위 키 값은 NULL이어야합니다. 마지막으로 외래 키 제약 조건이 &quot;MATCH PARTIAL&quot;로 선언되고 자식 키 값 중 하나가 NULL이면 NULL이 아닌 자식 키 값이 부모 키 값과 일치하는 부모 테이블에 하나 이상의 행이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ff3423278c8d679f0e463fab7ceefdb8e87b547d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Nota Bene:&lt;/b&gt; We are not using terms &quot;alpha&quot; or &quot;beta&quot; on this release because the code is stable and because if we use those terms, nobody will upgrade. However, we still reserve the right to make incompatible changes to the new VFS interface in future releases.</source>
          <target state="translated">&lt;b&gt;Nota Bene :&lt;/b&gt; 이 릴리스에서는 &quot;알파&quot;또는 &quot;베타&quot;라는 용어를 사용하지 않습니다. 코드가 안정적이고 해당 용어를 사용하면 아무도 업그레이드하지 않기 때문입니다. 그러나 향후 릴리스에서 새 VFS 인터페이스를 호환되지 않게 변경할 수있는 권한이 여전히 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4af7cf88e9968ffacaf7a5e73935d76ee917e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2&lt;/a&gt;. Otherwise, various features that require the use of temporary files may fail. Here is an example of how to do this using C++ with the Windows Runtime:</source>
          <target state="translated">&lt;b&gt;Windows 런타임 사용자 참고 사항 : &lt;/b&gt;&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2&lt;/a&gt; 를 호출하기 전에 임시 디렉토리를 설정해야합니다 . 그렇지 않으면 임시 파일을 사용해야하는 다양한 기능이 실패 할 수 있습니다. 다음은 Windows 런타임에서 C ++를 사용하여이를 수행하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c0ded749e5fd3733acdedad822b087151eadbb0c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling &lt;a href=&quot;open&quot;&gt;sqlite3_open&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2&lt;/a&gt;. Otherwise, various features that require the use of temporary files may fail. Here is an example of how to do this using C++ with the Windows Runtime:</source>
          <target state="translated">&lt;b&gt;Windows 런타임 사용자 참고 사항 : &lt;/b&gt;&lt;a href=&quot;open&quot;&gt;sqlite3_open&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2&lt;/a&gt; 를 호출하기 전에 임시 디렉토리를 설정해야합니다 . 그렇지 않으면 임시 파일을 사용해야하는 다양한 기능이 실패 할 수 있습니다. 다음은 Windows 런타임에서 C ++를 사용하여이를 수행하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="444b5de2baa7866b26c5c35eb4066557d970f9f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows Runtime users:&lt;/b&gt; The temporary directory must be set prior to calling sqlite3_open() or sqlite3_open_v2(). Otherwise, various features that require the use of temporary files may fail.</source>
          <target state="translated">&lt;b&gt;Windows 런타임 사용자 참고 사항 :&lt;/b&gt; sqlite3_open () 또는 sqlite3_open_v2 ()를 호출하기 전에 임시 디렉토리를 설정해야합니다. 그렇지 않으면 임시 파일을 사용해야하는 다양한 기능이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="748ba4196717e6b0faea9113baafb8df3689d540" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note to Windows users:&lt;/b&gt; The encoding used for the filename argument of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever codepage is currently defined. Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open() or sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;Windows 사용자 참고 사항 :&lt;/b&gt; sqlite3_open () 및 sqlite3_open_v2 ()의 파일 이름 인수에 사용 된 인코딩은 현재 정의 된 코드 페이지가 아닌 UTF-8이어야합니다. 국제 문자를 포함하는 파일 이름은 sqlite3_open () 또는 sqlite3_open_v2 ()로 전달하기 전에 UTF-8로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="769f55a4b93dc322f7b3d455d8397df48f2f2d0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note: This command is experimental. It may be removed or the interface modified in incompatible ways at some point in the future. &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;참고 :이 명령은 실험용입니다. 나중에 언젠가는 호환되지 않는 방식으로 제거되거나 인터페이스가 수정 될 수 있습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b47027741958234097e78403aae1058c44d5b08b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; This document was written in 2004 as a guide to helping programmers move from using SQLite version 2 to SQLite version 3. The information in this document is still essentially correct, however there have been many changes and enhancements over the years. We recommend that the following documents be used instead:</source>
          <target state="translated">&lt;b&gt;참고 :&lt;/b&gt; 이 문서는 2004 년 프로그래머가 SQLite 버전 2 사용에서 SQLite 버전 3으로 전환하는 데 도움을주기위한 안내서로 작성되었습니다 &lt;b&gt;.&lt;/b&gt; 이 문서의 정보는 본질적으로 여전히 정확하지만 수년 동안 많은 변경 및 개선이있었습니다. 대신 다음 문서를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="24750d4eb9662e4a4957cb5bb183a86e47a49973" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;OFF&lt;/b&gt; (0)</source>
          <target state="translated">&lt;b&gt;OFF&lt;/b&gt; (0)</target>
        </trans-unit>
        <trans-unit id="13a53904d88ef25254e29ff8b9c1d8fa9cd6298b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Old school&lt;/b&gt; &amp;rarr; Nobody is completely immune to trends and fads, but the SQLite developers work hard to avoid being sucked into the latest programming fashion. Our aim is to produce timeless code that will be readable, understandable, and maintainable by programmers who have not yet been born.</source>
          <target state="translated">&lt;b&gt;올드 스쿨&lt;/b&gt; &amp;rarr; 아무도 추세와 유행에 완전히 면역되지는 않지만 SQLite 개발자는 최신 프로그래밍 방식에 빠지지 않도록 열심히 노력합니다. 우리의 목표는 아직 태어나지 않은 프로그래머가 읽고 이해하고 유지 보수 할 수있는 영원한 코드를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd300fad70a8d19900bdcefb0940dc55c37c7edd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Open access.&lt;/b&gt; Pluggable SQLite extensions or even the application itself can access to the same underlying memory allocation routines used by SQLite through the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;b&gt;오픈 액세스. &lt;/b&gt;플러그 가능한 SQLite 확장 또는 응용 프로그램 자체는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 인터페이스를 통해 SQLite에서 사용하는 동일한 기본 메모리 할당 루틴에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c71ee46b045a02f63debd958100626f5bab2581a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Optimization note:&lt;/b&gt; In the discussion above, statements like &quot;insert the row into the recursive table&quot; should be understood conceptually, not literally. It sounds as if SQLite is accumulating a huge table containing one million rows, then going back and scanning that table from top to bottom to generate the result. What really happens is that the query optimizer sees that values in the &quot;cnt&quot; recursive table are only used once. So as each row is added to the recursive table, that row is immediately returned as a result of the main SELECT statement and then discarded. SQLite does &lt;em&gt;not&lt;/em&gt; accumulate a temporary table containing a million rows. Very little memory is needed to run the above example. However, if the example had used UNION instead of UNION ALL, then SQLite would have had to keep around all previously generated content in order to check for duplicates. For this reason, programmers should strive to use UNION ALL instead of UNION when feasible.</source>
          <target state="translated">&lt;b&gt;최적화 참고 사항 :&lt;/b&gt; 위의 논의에서 &quot;행을 재귀 테이블에 삽입&quot;과 같은 명령문은 말 그대로가 아니라 개념적으로 이해해야합니다. SQLite가 백만 개의 행을 포함하는 거대한 테이블을 누적 한 다음 돌아가서 해당 테이블을 위에서 아래로 스캔하여 결과를 생성하는 것처럼 들립니다. 실제로 발생하는 것은 쿼리 최적화 프로그램이 &quot;cnt&quot;재귀 테이블의 값이 한 번만 사용된다는 것을 알게됩니다. 따라서 각 행이 재귀 테이블에 추가되면 해당 행은 기본 SELECT 문의 결과로 즉시 반환 된 다음 삭제됩니다. SQLite는하지 &lt;em&gt;않습니다&lt;/em&gt;백만 개의 행을 포함하는 임시 테이블을 누적하십시오. 위의 예제를 실행하는 데 필요한 메모리는 거의 없습니다. 그러나 예제에서 UNION ALL 대신 UNION을 사용한 경우 SQLite는 중복을 확인하기 위해 이전에 생성 된 모든 내용을 유지해야했습니다. 따라서 프로그래머는 가능한 경우 UNION 대신 UNION ALL을 사용하도록 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="651a8131253a7773af15b8271556354505a88d30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Other changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;다른 변경 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="836c9c79cbdb56ad11a3f7b8eb289c6fcd3b3e97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Other miscellaneous bug fixes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;기타 기타 버그 수정 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b78f4234d48fb6b6bfa15c9a34247d7bdf65943f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Otherwise &amp;rarr; choose SQLite!&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;그렇지 않으면 &amp;rarr; SQLite를 선택하십시오!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a4e6ea5132ac1b592b0a12cf67526ca006118c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83b30075940fcb452bed2180f81dc10eba7f6711" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA automatic_index; &lt;br/&gt;PRAGMA automatic_index = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA automatic_index; &lt;br/&gt;PRAGMA automatic_index =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="34bc85d6a4d45772aad879e55a7ac5e80222398c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA busy_timeout; &lt;br/&gt;PRAGMA busy_timeout = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA busy_timeout; &lt;br/&gt;PRAGMA busy_timeout =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ba56744c8180a6fc97f0a1a8617742a0585aaec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA cache_spill; &lt;br/&gt;PRAGMA cache_spill=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA cache_spill; &lt;br/&gt;PRAGMA cache_spill =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="046b46c5f39805112cd910d3ff11e39ab8424cce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA case_sensitive_like = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA case_sensitive_like = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="565bea357204f845f61325d13e5aa1cfcd799e07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA cell_size_check &lt;br/&gt;PRAGMA cell_size_check = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA cell_size_check &lt;br/&gt;PRAGMA cell_size_check =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9615bff993393e92f6f3ae3d404400a4b65a5687" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA checkpoint_fullfsync &lt;br/&gt;PRAGMA checkpoint_fullfsync = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA checkpoint_fullfsync &lt;br/&gt;PRAGMA checkpoint_fullfsync =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e46aa40c6380c795a8260154cbaec7c9506c4d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA collation_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA collation_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6474234e180c118606d9cf5796987f9b1142da9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA compile_options;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA compile_options;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a23692d2499f7b3484cb758082a7deaf51e9cf7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA count_changes; &lt;br/&gt;PRAGMA count_changes = &lt;/b&gt;boolean&lt;b&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA count_changes; &lt;br/&gt;PRAGMA count_changes =&lt;/b&gt; 부울 &lt;b&gt;;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3657d382c17092acaa136470f8043718e1e91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA data_store_directory; &lt;br/&gt;PRAGMA data_store_directory = '&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA data_store_directory; &lt;br/&gt;PRAGMA data_store_directory = '&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="450721fa2a666abef3200f3d173451ff5c7661af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA database_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA database_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="794ea8d4d27624136baf8c5ea0c9d9f3ac26ba94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA defer_foreign_keys &lt;br/&gt;PRAGMA defer_foreign_keys = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA defer_foreign_keys &lt;br/&gt;PRAGMA defer_foreign_keys =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668dd102f6d9b948c3f5c70f4e29347d03f041b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA empty_result_callbacks; &lt;br/&gt;PRAGMA empty_result_callbacks = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA empty_result_callbacks; &lt;br/&gt;PRAGMA empty_result_callbacks =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e34407929970c720bcf37acb067c6d902cae8b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA encoding; &lt;br/&gt;PRAGMA encoding = 'UTF-8'; &lt;br/&gt;PRAGMA encoding = 'UTF-16'; &lt;br/&gt;PRAGMA encoding = 'UTF-16le'; &lt;br/&gt;PRAGMA encoding = 'UTF-16be';&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA 인코딩; &lt;br/&gt;PRAGMA 인코딩 = 'UTF-8'; &lt;br/&gt;PRAGMA 인코딩 = 'UTF-16'; &lt;br/&gt;PRAGMA 인코딩 = 'UTF-16le'; &lt;br/&gt;PRAGMA 인코딩 = 'UTF-16be';&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68d7b463e4c3d04462621119087178aef2ea372a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA foreign_key_list(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA foreign_key_list (&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f1a523f2bdc8d90e07205dea18552c1854287a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA foreign_keys; &lt;br/&gt;PRAGMA foreign_keys = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA foreign_keys; &lt;br/&gt;PRAGMA foreign_keys =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="069e90959dff0b0144700f439333db94c4234af0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA full_column_names; &lt;br/&gt;PRAGMA full_column_names = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA full_column_names; &lt;br/&gt;PRAGMA full_column_names =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c191dc47ff1ccf9e34d591b33df93a26965f6dce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA fullfsync &lt;br/&gt;PRAGMA fullfsync = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA fullfsync &lt;br/&gt;PRAGMA fullfsync =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ec6500e351a87577bfec53d117f2d532325eafc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA function_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA function_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d207d1a089498b74f456f544036449e4c0d7ca81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA ignore_check_constraints = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA ignore_check_constraints = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c744529af3729b3db46137681b8a4149686477f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA legacy_alter_table; &lt;br/&gt;PRAGMA legacy_alter_table = &lt;i&gt;boolean&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA legacy_alter_table; &lt;br/&gt;PRAGMA legacy_alter_table = &lt;i&gt;부울&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48e6cf340be98da512dd51fd9b58fa0495affa32" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA legacy_file_format; &lt;br/&gt;PRAGMA legacy_file_format = &lt;i&gt;boolean&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA legacy_file_format; &lt;br/&gt;PRAGMA legacy_file_format = &lt;i&gt;부울&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0f7d30a633b0f798cf089bd9af23c6222ddd0dab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA module_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA module_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b04f91057153bfe385a2ca682291b546a585a7cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA optimize; &lt;br/&gt;PRAGMA optimize(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA 최적화; &lt;br/&gt;PRAGMA optimize (&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68a98ab10e998a482c646076b2f2e29e38965f44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA parser_trace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA parser_trace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bc9c8c6ac16923ab9c3f0f704b3e9b2f909b480" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA pragma_list;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA pragma_list;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="36a70f23f79ebdba5909e7d79bedd59f47a5f025" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA query_only; &lt;br/&gt;PRAGMA query_only = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA query_only; &lt;br/&gt;PRAGMA query_only =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="077bcb499c2f1bcbd541b7d149710ac3780529ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA read_uncommitted; &lt;br/&gt;PRAGMA read_uncommitted = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA read_uncommitted; &lt;br/&gt;PRAGMA read_uncommitted =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc2ac8724db764e8cbbbf84aa7d8c0e1d82780a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA recursive_triggers; &lt;br/&gt;PRAGMA recursive_triggers = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA recursive_triggers; &lt;br/&gt;PRAGMA recursive_triggers =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f68cbf752672c0b1b34391729c4c9eced4aa618d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA reverse_unordered_selects; &lt;br/&gt;PRAGMA reverse_unordered_selects = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA reverse_unorder_selects; &lt;br/&gt;PRAGMA reverse_unorder_selects =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf06b921c7f02a57d88e677cc690f4c67d4edfec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA short_column_names; &lt;br/&gt;PRAGMA short_column_names = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA short_column_names; &lt;br/&gt;PRAGMA short_column_names =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="825ba246cc1b1a97c03ffc7bff5ff770578b70ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA shrink_memory&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA shrink_memory&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f581b3dd4770c7e81c9a4d70f0c732a0cb847aa5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA soft_heap_limit&lt;br/&gt; PRAGMA soft_heap_limit=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA soft_heap_limit &lt;br/&gt;PRAGMA soft_heap_limit =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="993cb0e48d44665f1a1fdde50480e34a4564b7e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA stats;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA 통계;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f3e58baf9ac87756f2ff64608cb4491760e167a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA temp_store; &lt;br/&gt;PRAGMA temp_store = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA temp_store; &lt;br/&gt;PRAGMA temp_store =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="70135cb7f05b7e917151aa514833c9748b5db620" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA temp_store_directory; &lt;br/&gt;PRAGMA temp_store_directory = '&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA temp_store_directory; &lt;br/&gt;PRAGMA temp_store_directory = '&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05825927b748ed604749ba6c5a353f57d9c33904" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA threads; &lt;br/&gt;PRAGMA threads = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA 스레드; &lt;br/&gt;PRAGMA 스레드 =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d97a389f3a5dd4b156c1ff3a61d3ce94dae20880" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_addoptrace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_addoptrace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8957c1b89b58509b9ad2ededda1ea95812f93cb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_debug = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_debug = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf418203dd77144a23b6f4fd5e0373826f599d82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_listing = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_listing = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2996e771be9c4129bca39778d9d000122105ece7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA vdbe_trace = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA vdbe_trace = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3372b23ddf217d83224ec50e4fe828229dc15429" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA wal_autocheckpoint;&lt;br/&gt; PRAGMA wal_autocheckpoint=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA wal_autocheckpoint; &lt;br/&gt;PRAGMA wal_autocheckpoint =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2fdecfa5636d000c5d0c05b22630a29e3e0aef7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;PRAGMA writable_schema = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;PRAGMA writable_schema = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3174396d4cc0cecbb14882932592933a55f4ab7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance Enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;성능 향상 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d5bcadce029aa3c9c7af1fde80e52286840c575b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;성능 향상 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8d853aa960d2241e2de78be03a3ec37df9aea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance.&lt;/b&gt; In many cases, an SQLite application file format will be &lt;a href=&quot;fasterthanfs&quot;&gt;faster than a pile-of-files format&lt;/a&gt; or a custom format. In addition to being faster for raw read and writes, SQLite can often dramatically improves start-up times because instead of having to read and parse the entire document into memory, the application can do queries to extract only the information needed for the initial screen. As the application progresses, it only needs to load as much material as is needed to draw the next screen, and can discard information from prior screens that is no longer in use. This helps keep the memory footprint of the application under control.</source>
          <target state="translated">&lt;b&gt;공연.&lt;/b&gt; 대부분의 경우 SQLite 응용 프로그램 파일 형식은 파일 &lt;a href=&quot;fasterthanfs&quot;&gt;더미 형식&lt;/a&gt; 또는 사용자 지정 형식 보다 빠릅니다 . 원시 읽기 및 쓰기 속도가 더 빠를뿐만 아니라 SQLite는 전체 문서를 메모리로 읽고 구문 분석하는 대신 초기 화면에 필요한 정보 만 추출하기 위해 쿼리를 수행 할 수 있기 때문에 시작 시간을 크게 향상시킬 수 있습니다. 응용 프로그램이 진행됨에 따라 다음 화면을 그리는 데 필요한만큼의 재료 만로드하면되고 더 이상 사용하지 않는 이전 화면의 정보를 버릴 수 있습니다. 이를 통해 응용 프로그램의 메모리 사용량을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13e3777e4274771f6f8ab0c2f57839a313e28e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Performance:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Performance:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46a6192a108d9e7b8cb029df33550613a9110a7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Phrase queries&lt;/b&gt;. A phrase query is a query that retrieves all documents that contain a nominated set of terms or term prefixes in a specified order with no intervening tokens. Phrase queries are specified by enclosing a space separated sequence of terms or term prefixes in double quotes (&quot;). For example:</source>
          <target state="translated">&lt;b&gt;구문 쿼리&lt;/b&gt; . 구문 쿼리는 중재 토큰없이 지정된 순서로 지정된 용어 또는 용어 접두사를 포함하는 모든 문서를 검색하는 쿼리입니다. 구문 쿼리는 공백으로 구분 된 용어 또는 용어 접두사를 큰 따옴표 ( &quot;)로 묶어 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22d3e7c367a141aec26eeffb7c6081a38bc54795" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Pile-of-Files Formats.&lt;/b&gt; Sometimes the application state is stored as a hierarchy of files. Git is a prime example of this, though the phenomenon occurs frequently in one-off and bespoke applications. A pile-of-files format essentially uses the filesystem as a key/value database, storing small chunks of information into separate files. This gives the advantage of making the content more accessible to common utility programs such as text editors or &quot;awk&quot; or &quot;grep&quot;. But even if many of the files in a pile-of-files format are easily readable, there are usually some files that have their own custom format (example: Git &quot;Packfiles&quot;) and are hence &quot;opaque blobs&quot; that are not readable or writable without specialized tools. It is also much less convenient to move a pile-of-files from one place or machine to another, than it is to move a single file. And it is hard to make a pile-of-files document into an email attachment, for example. Finally, a pile-of-files format breaks the &quot;document metaphor&quot;: there is no one file that a user can point to that is &quot;the document&quot;.</source>
          <target state="translated">&lt;b&gt;파일 더미 형식.&lt;/b&gt;때때로 응용 프로그램 상태는 파일의 계층 구조로 저장됩니다. Git이 대표적인 예이지만,이 현상은 일회성 및 맞춤형 애플리케이션에서 자주 발생합니다. 파일 더미 형식은 본질적으로 파일 시스템을 키 / 값 데이터베이스로 사용하여 작은 정보 덩어리를 별도의 파일에 저장합니다. 이는 텍스트 편집기 나 &quot;awk&quot;또는 &quot;grep&quot;과 같은 일반적인 유틸리티 프로그램에보다 쉽게 ​​액세스 할 수있는 이점을 제공합니다. 그러나 파일 더미 형식의 많은 파일을 쉽게 읽을 수 있더라도 일반적으로 자체 사용자 지정 형식 (예 : Git &quot;Packfiles&quot;)을 가지고 있거나 읽을 수없는 &quot;불투명 한 얼룩&quot;인 일부 파일이 있습니다. 특별한 도구없이 쓸 수 있습니다. 파일 더미를 한 장소 나 기계에서 다른 장소로 옮기는 것이 훨씬 덜 편리합니다.단일 파일을 이동하는 것보다. 예를 들어, 파일 더미 문서를 전자 메일 첨부 파일로 만드는 것은 어렵습니다. 마지막으로 파일 더미 형식은 &quot;문서 비유&quot;를 손상시킵니다. 사용자가 가리킬 수있는 파일은 &quot;문서&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="06e1ef37e925aec595836f976814c7b5716fb8ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Plays well with memory debuggers.&lt;/b&gt; Memory allocation in SQLite is structured so that standard third-party memory debuggers (such as &lt;a href=&quot;http://dmalloc.com&quot;&gt;dmalloc&lt;/a&gt; or &lt;a href=&quot;http://valgrind.org&quot;&gt;valgrind&lt;/a&gt;) can be used to verify correct memory allocation behavior.</source>
          <target state="translated">&lt;b&gt;메모리 디버거와 잘 어울립니다. &lt;/b&gt;SQLite의 메모리 할당은 표준 타사 메모리 디버거 (예 : &lt;a href=&quot;http://dmalloc.com&quot;&gt;dmalloc&lt;/a&gt; 또는 &lt;a href=&quot;http://valgrind.org&quot;&gt;valgrind&lt;/a&gt; )를 사용하여 올바른 메모리 할당 동작을 확인할 수 있도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="39951f449e5ceec6f9a022225faab5c19101b3de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Policy Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;정책 변경 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2863a854f7569042d7772c825bca3bf981195c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Portability enhancements:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;이식성 향상 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="80049d6fbf18722eba9cb49ab1cc1bbd73558530" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Portability&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Portability&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4c96fb6c7dab84d62ed86f4a23baec2f8c0d10eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Possible Enhancements&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;가능한 향상&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68538fd5cb8fea275b4992c2b729e378880943ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Potentially Disruptive Change:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;잠재적으로 파괴적인 변화 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18f89a0b4c42a90efdb28e7e3e5ef1be9872e99b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Proof against breakdown and fragmentation.&lt;/b&gt; SQLite can be configured so that, subject to certain usage constraints detailed below, it is guaranteed to never fail a memory allocation or fragment the heap. This property is important to long-running, high-reliability embedded systems where a memory allocation error could contribute to an overall system failure.</source>
          <target state="translated">&lt;b&gt;고장 및 조각화에 대한 증거. &lt;/b&gt;아래에 설명 된 특정 사용 제한 조건에 따라 메모리 할당에 실패하거나 힙을 조각화하지 않도록 SQLite를 구성 할 수 있습니다. 이 속성은 메모리 할당 오류가 전체 시스템 오류에 영향을 줄 수있는 장기 실행 고 신뢰성 임베디드 시스템에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ac8f710182b5d046c627cafbd710d5a4b76712b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Public domain&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;공개 도메인&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5f4e98a2bc425605ca9ae67429cb81a244edf06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Query by rowid&lt;/b&gt;. If the WHERE clause of the SELECT statement contains a sub-clause of the form &quot;rowid = ?&quot;, where ? is an SQL expression, FTS is able to retrieve the requested row directly using the equivalent of an SQLite &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; index.</source>
          <target state="translated">&lt;b&gt;rowid로 쿼리하십시오&lt;/b&gt; . SELECT 문의 WHERE 절에 &quot;rowid =?&quot;형식의 하위 절이 포함되어 있으면 여기서? SQL 표현식이며, FTS는 SQLite &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 인덱스 와 동등한 것을 사용하여 요청 된 행을 직접 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c87196f9621ee8cab25b7ddca397f6aebb7dd5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RANGE &amp;rarr;&lt;/b&gt; For this form, the ORDER BY clause of the window-defn must have a single term. Call that ORDER BY term &quot;X&quot;. Let X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; be the value of the X expression for the i-th row in the partition and let X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; be the value of X for the current row. Informally, a RANGE bound is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; is within the &amp;lt;expr&amp;gt; of X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;. More precisely:</source>
          <target state="translated">&lt;b&gt;범위 &amp;rarr;&lt;/b&gt; 이 양식의 경우 window-defn의 ORDER BY 절에 단일 용어가 있어야합니다. ORDER BY 용어를 &quot;X&quot;라고합니다. X &lt;sub&gt;&lt;small&gt;i를&lt;/small&gt;&lt;/sub&gt; 파티션의 i 번째 행에 대한 X 표현식의 값으로, X &lt;sub&gt;&lt;small&gt;c를&lt;/small&gt;&lt;/sub&gt; 현재 행에 대한 X의 값으로 설정하십시오. 공식적으로, RANGE 경계는 X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; 가 X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; 의 &amp;lt;expr&amp;gt; 내에있는 첫 번째 행입니다 . 더 정확하게:</target>
        </trans-unit>
        <trans-unit id="f148886a2921d230cf2a13f933e1a32a3ada6d4c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RANGE&lt;/b&gt;: The RANGE frame type requires that the ORDER BY clause of the window have exactly one term. Call that term &quot;X&quot;. With the RANGE frame type, the elements of the frame are determined by computing the value of expression X for all rows in the partition and framing those rows for which the value of X is within a certain range of the value of X for the current row. See the description in the &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt;&quot; boundary specification below for details.</source>
          <target state="translated">&lt;b&gt;RANGE&lt;/b&gt; : RANGE 프레임 유형을 사용하려면 창의 ORDER BY 절에 정확히 하나의 용어가 있어야합니다. 이 용어를 &quot;X&quot;라고합니다. RANGE 프레임 유형을 사용하면 파티션의 모든 행에 대해 식 X의 값을 계산하고 X 값이 현재 행에 대한 X 값의 특정 범위 내에있는 행을 프레이밍하여 프레임의 요소를 결정합니다. . 자세한 내용은 아래 &quot; &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt; &quot;경계 사양의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="80ac38949c365f3e6967f3b57e43c758b0bd0074" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU Update operations&lt;/b&gt;. An &lt;a href=&quot;rbu#rbu_updates&quot;&gt;RBU Update&lt;/a&gt; is a bulk update of a database file that may include many insert, update and delete operations on one or more tables.</source>
          <target state="translated">&lt;b&gt;RBU 업데이트 작업&lt;/b&gt; . &lt;a href=&quot;rbu#rbu_updates&quot;&gt;RBU 업데이트는&lt;/a&gt; 많은 삽입, 업데이트 및 하나 개 이상의 테이블에 삭제 작업을 포함 할 수있는 데이터베이스 파일의 대량 업데이트입니다.</target>
        </trans-unit>
        <trans-unit id="b3e90d620642f9f1b13a8d79ab7f5ebf814e1ee2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU Vacuum operations&lt;/b&gt;. An &lt;a href=&quot;rbu#rbu_vacuum&quot;&gt;RBU Vacuum&lt;/a&gt; optimizes and rebuilds an entire database file, with results similar to SQLite's native VACUUM command.</source>
          <target state="translated">&lt;b&gt;RBU 진공 작업&lt;/b&gt; . &lt;a href=&quot;rbu#rbu_vacuum&quot;&gt;RBU는 진공&lt;/a&gt; SQLite는의 기본 VACUUM 명령과 유사 결과, 최적화하고 전체 데이터베이스 파일을 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3fb84bb6a81a53e7beaf8eba1959d7978c9fa592" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU may be more efficient&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU가 더 효율적일 수 있습니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="534b078b65236f5fb856d2b9635b23b17d44a80a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU runs in the background&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU는 백그라운드에서 실행됩니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="698e51407e465d0e304762b117a916981e0fecec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RBU runs incrementally&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;RBU는 점진적으로 실행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ba35125f15a716954fed100209c8e617a8adc611" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REAL&lt;/b&gt; as Julian day numbers, the number of days since noon in Greenwich on November 24, 4714 B.C. according to the proleptic Gregorian calendar.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;기원전 4714 년 11 월 24 일 그리니치에서 정오 이후의 일수 인 줄리안 일수는 &lt;b&gt;실제&lt;/b&gt; 그레고리력 (Gregorian calendar)에 따른 것입니다.</target>
        </trans-unit>
        <trans-unit id="05e01e432f196ae91813f817e48ac2893edada51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REAL&lt;/b&gt;. The value is a floating point value, stored as an 8-byte IEEE floating point number.</source>
          <target state="translated">&lt;b&gt;진짜&lt;/b&gt; . 값은 8 바이트 IEEE 부동 소수점 숫자로 저장된 부동 소수점 값입니다.</target>
        </trans-unit>
        <trans-unit id="72a1aec4b000b724faf3e2dce2df47fdc044f0e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;REPLACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;REPLACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cea249bacf17bdcc200de4331dc5afa32b20686" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RESTRICT&lt;/b&gt;: The &quot;RESTRICT&quot; action means that the application is prohibited from deleting (for ON DELETE RESTRICT) or modifying (for ON UPDATE RESTRICT) a parent key when there exists one or more child keys mapped to it. The difference between the effect of a RESTRICT action and normal foreign key constraint enforcement is that the RESTRICT action processing happens as soon as the field is updated - not at the end of the current statement as it would with an immediate constraint, or at the end of the current transaction as it would with a deferred constraint. Even if the foreign key constraint it is attached to is deferred, configuring a RESTRICT action causes SQLite to return an error immediately if a parent key with dependent child keys is deleted or modified.</source>
          <target state="translated">&lt;b&gt;RESTRICT&lt;/b&gt; : &quot;RESTRICT&quot;조치는 맵핑 된 하나 이상의 하위 키가있을 때 애플리케이션이 상위 키를 삭제 (ON DELETE RESTRICT)하거나 수정 (ON UPDATE RESTRICT)하는 것을 금지합니다. RESTRICT 조치와 일반 외래 키 제한 조건 적용의 효과의 차이점은 RESTRICT 조치 처리가 필드가 업데이트되는 즉시 발생한다는 것입니다. 즉, 현재 명령문의 끝이 아닌 즉각적인 제한 조건의 경우가 아닙니다. 지연된 제약 조건과 마찬가지로 현재 트랜잭션의 첨부 된 외부 키 제한 조건이 지연 되더라도 RESTRICT 조치를 구성하면 종속 하위 키가있는 상위 키가 삭제되거나 수정되는 경우 SQLite가 즉시 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff3caed40a2a7601b4cc8c41862c43dae15801b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROLLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ROLLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6b6540ce45b70728693b5f961b3a0c4d151f4ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROWS &amp;rarr;&lt;/b&gt; The frame boundary is the row that is &amp;lt;expr&amp;gt; rows before the current row, or the first row of the partition if there are fewer than &amp;lt;expr&amp;gt; rows before the current row. &amp;lt;expr&amp;gt; must be an integer.</source>
          <target state="translated">&lt;b&gt;ROWS &amp;rarr;&lt;/b&gt; 프레임 경계는 현재 행 앞의 &amp;lt;expr&amp;gt; 행인 행 또는 현재 행 앞의 &amp;lt;expr&amp;gt; 행 미만인 경우 파티션의 첫 번째 행입니다. &amp;lt;expr&amp;gt;은 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7085652850f337f1292781b03c80d52166e2b0db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ROWS&lt;/b&gt;: The ROWS frame type means that the starting and ending boundaries for the frame are determined by counting individual rows relative to the current row.</source>
          <target state="translated">&lt;b&gt;ROWS&lt;/b&gt; : ROWS 프레임 유형은 프레임의 시작 및 끝 경계가 현재 행을 기준으로 개별 행을 계산하여 결정됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cfbbf924262e1a960882f1c8318fdffdb65fb290" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;RTRIM&lt;/b&gt; - The same as binary, except that trailing space characters are ignored.</source>
          <target state="translated">&lt;b&gt;RTRIM-&lt;/b&gt; 후행 공백 문자가 무시된다는 점을 제외하면 2 &lt;b&gt;진과&lt;/b&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c8987ec8d449abc8fe9709de818ab14d807212ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Read content from the database and WAL as part of a transaction&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;트랜잭션의 일부로 데이터베이스 및 WAL에서 컨텐츠 읽기&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9f049da3ffd93dd209c35732fa0f0e1ebda56a14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Readable source code&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;읽을 수있는 소스 코드&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c292627528bb82684b411ccd58e38f7f789c1262" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reconstruct the global shared WAL-index during &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;동안 글로벌 공유 WAL-인덱스 재구성 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31363531301f2d3466de9930ba452b0df0dbb623" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Recursion limit on foreign key actions.&lt;/b&gt; The &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; settings determine the maximum allowable depth of trigger program recursion. For the purposes of these limits, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are considered trigger programs. The &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; setting does not affect the operation of foreign key actions. It is not possible to disable recursive foreign key actions.</source>
          <target state="translated">&lt;b&gt;외래 키 동작에 대한 재귀 제한. &lt;/b&gt;&lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; 설정은 트리거 프로그램 재귀의 최대 허용 깊이를 결정합니다. 이러한 제한을 위해 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 동작&lt;/a&gt; 은 트리거 프로그램으로 간주됩니다. &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA RECURSIVE_TRIGGERS&lt;/a&gt; 설정은 외래 키 조치의 작동에는 영향을 미치지 않습니다. 재귀 외래 키 동작을 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="294b87e6ed53158c02a9241c192d4bc0c7b5a44c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reduced application cost and complexity&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;애플리케이션 비용 및 복잡성 감소&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1512b5f805325fc9a62b2f5f69951fc71245aa4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reliability&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Reliability&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f2056282af938ba0160e81e148e7c1753145d69" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Replacement for &lt;i&gt;ad hoc&lt;/i&gt; disk files&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;i&gt;애드혹&lt;/i&gt; 디스크 파일 교체&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c0e67e4fde91da154b9be4c31cb9cd64d6ded3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Reset the WAL file&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL 파일 재설정&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96047c6ef3195ac1b96321749d11246af960cb46" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Robust against allocation failures.&lt;/b&gt; If a memory allocation ever fails (that is to say, if malloc() or realloc() ever return NULL) then SQLite will recover gracefully. SQLite will first attempt to free memory from unpinned cache pages then retry the allocation request. Failing that, SQLite will either stop what it is doing and return the &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error code back up to the application or it will make do without the requested memory.</source>
          <target state="translated">&lt;b&gt;할당 실패에 강하다. &lt;/b&gt;메모리 할당이 실패하면 (즉, malloc () 또는 realloc ()이 NULL을 반환하는 경우) SQLite는 정상적으로 복구됩니다. SQLite는 먼저 고정 해제 캐시 페이지에서 메모리를 확보하려고 시도한 후 할당 요청을 재 시도합니다. 실패하면 SQLite는 수행중인 작업을 중지하고 &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 오류 코드를 응용 프로그램에 다시 반환 하거나 요청 된 메모리없이 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6079c1697e8a6442575a964d330a78ba38bec07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Run a checkpoint&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;체크 포인트 실행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8947ef2bec239716ae0db33a2b920924684d2b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SET DEFAULT&lt;/b&gt;: The &quot;SET DEFAULT&quot; actions are similar to &quot;SET NULL&quot;, except that each of the child key columns is set to contain the columns default value instead of NULL. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details on how default values are assigned to table columns.</source>
          <target state="translated">&lt;b&gt;SET DEFAULT&lt;/b&gt; : &quot;SET DEFAULT&quot;작업은 &quot;SET NULL&quot;과 유사하지만 각 자식 키 열이 NULL 대신 열 기본값을 포함하도록 설정되어 있습니다. 기본값이 테이블 열에 지정되는 방법에 대한 자세한 내용 은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="33b91f3630ca4ab746765602396efa572d3094a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SET NULL&lt;/b&gt;: If the configured action is &quot;SET NULL&quot;, then when a parent key is deleted (for ON DELETE SET NULL) or modified (for ON UPDATE SET NULL), the child key columns of all rows in the child table that mapped to the parent key are set to contain SQL NULL values.</source>
          <target state="translated">&lt;b&gt;SET NULL&lt;/b&gt; : 구성된 조치가 &quot;SET NULL&quot;인 경우 상위 키가 삭제 (ON DELETE SET NULL의 경우)되거나 수정 될 때 (ON UPDATE SET NULL의 경우), 맵핑 된 하위 테이블의 모든 행의 하위 키 열 부모 키는 SQL NULL 값을 포함하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="76be85ce351bcd022dfc21628e13b422efb53a23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQL language extensions&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQL 언어 확장&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4b14f80a5a266a69df239ded6632d913a87a00a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQL statements compile into virtual machine code&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQL 문은 가상 머신 코드로 컴파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83c0c487d93dc334f8c302e295ed7938423066bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3aa723b4ca5a3e0f908a87dd06720f76499a803d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f93c111578aad97e0a49efe448bf05ad58e312b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7115d3b8d179eabb10343181c396bb71e9528d1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87d2e963d002664b9641ea35fee9f4be4af1d3d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_APICALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_APICALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="45844421048f1fe03ce743ccddcc45d28b903411" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_BYTEORDER=&lt;i&gt;(0|1234|4321)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_BYTEORDER=&lt;i&gt;(0|1234|4321)&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="81a33fa84c2772b37cd9cf1742e61a9b26cffebf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d487c4778cc7399d3ed400d70b24d3224d6c900" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca8bc702a0ab56ee63a0f508cfed6679268a020f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_CDECL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_CDECL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="055d8a144a29467bf25fe8fd58a953d8d39a84e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99071bbb25358764662a16ba481391de6386a6ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b822ada3607d9e4a3417e9b6688f31eb62d742a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_AUTOVACUUM=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_AUTOVACUUM = &lt;i&gt;&amp;lt;0 또는 1 또는 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43ecdb65cd38b77a57c5c5315e9d3cb506b4d93e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_CACHE_SIZE=&lt;i&gt;&amp;lt;N&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_CACHE_SIZE=&lt;i&gt;&amp;lt;N&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d961c346273a9c1750541784f8ed1fcf52f30923" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FILE_FORMAT=&lt;i&gt;&amp;lt;1 or 4&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FILE_FORMAT = &lt;i&gt;&amp;lt;1 또는 4&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c5c7318f455d9e86512b271a46ebc152f3cc07d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FILE_PERMISSIONS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FILE_PERMISSIONS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8854f3260e6de1c5bc538a21e49e7c4d6ecb1370" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_FOREIGN_KEYS=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_FOREIGN_KEYS = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd62f813164104a4a8dace6a9fb8d384ba9a27a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7dc1ce2a4b2e8db810f32d21156412bbed8e0f7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_LOCKING_MODE=&lt;i&gt;&amp;lt;1 or 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_LOCKING_MODE = &lt;i&gt;&amp;lt;1 또는 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19cf7c4c2794ec95ba5fea9ffe72ae6d604f2189" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f47ddaa680cfc53714d3dc1be4264584592d7e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_MEMSTATUS=&lt;i&gt;&amp;lt;1 or 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_MEMSTATUS = &lt;i&gt;&amp;lt;1 또는 0&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="36ce382183b4de0c5612dfcc98537f87d51f8cd9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e65bc393f4fb1826409f09b5a3bd23eca3ed4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_PAGE_SIZE=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_PAGE_SIZE=&lt;i&gt;&amp;lt;bytes&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="29c7e07d19c64c72d94c4234ebb35d0155c95b1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_PCACHE_INITSZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_PCACHE_INITSZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2c797fd4625193c1b96565a3ef27f80da9bfec4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f53a79ce09a0fb9d64e5120c32baaded6a35694" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT=&lt;i&gt;&amp;lt;pages&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT=&lt;i&gt;&amp;lt;pages&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43fc152a5d74616e6bb14cdef7755867f249ffc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS=&lt;i&gt;&amp;lt;0-3&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="267fce3dc954776d41c9549141844c9525bd5ca0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DEFAULT_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DEFAULT_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b0d6df2dfe3254fb8ada64ce2610060f996ebb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe774070f0c5c60df1652e7a9bf25e55d43f9484" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_DIRSYNC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_DIRSYNC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad90c2cd9b3c9e9ad1923c1b58b05476f888e913" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_FTS3_UNICODE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_FTS3_UNICODE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3ac65ff44396720fbbe185ffa52b572404994c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7dbe88c8699c03655a129fb63f7f3c4fb866f908" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_INTRINSIC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_INTRINSIC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2cbe1ffe001595f46022d06cd2a027d53e0c08be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DISABLE_LFS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DISABLE_LFS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d3f52b1c42784d95687ae89d3a11bb3734220862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="551b883f5de8b21941883d216c74ab7c3c05072a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_8_3_NAMES=&lt;i&gt;&amp;lt;1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_8_3_NAMES = &lt;i&gt;&amp;lt;1 또는 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a28faa4e4504f8ca28667e6ce37e99f30e6745b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_API_ARMOR&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_API_ARMOR&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bed29376ce20d920bb1b1133dec7a10be041cf6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="92b48ac312580ef48db8a01e6a99045ac0c33bd3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c7b0d6431f49e6bf24765ed171474b60da4b6f7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b2e2dfbadc7daaf12dcf0f4ae9559406be61667" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="020fd35f0bf4b2316e6efd2b506ed67303cb238f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="17c8dc66408aa1c3909df52aca12f92605481017" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_DESERIALIZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_DESERIALIZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="973a36b7666be8ac3ec6d5a963ef55fe792299cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68b8eb9074c3cee849d29ae97e0ac1d8fef4b515" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="620b6f70b569c5c847648263e8bda1d1814eaaef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4033dbb6b68eede2da9ec9639dc59521855a2a40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fee3e2b47cd366e63b674ce5d8854685a0ee627" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd7224abedc2d1f6de23bbe56e687f922a5e27bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_FTS5&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_FTS5&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46eb1c96aaf24b76dc4073d011dc991646d05843" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_GEOPOLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_GEOPOLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bcac5312082e20cee3c423c5e945a8fae19e4b96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_ICU&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_ICU&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf9ed42c29ced5eb0918cd4f2526cca3b091e45f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_IOTRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_IOTRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cd26c6f3bcb6452d1761b1c3cde0b2e849b7b1b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_JSON1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_JSON1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4101cc723ca06d4f28f7f4af8fc174a289cc5a30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_LOCKING_STYLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_LOCKING_STYLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2c505a1f02c04aa3726f859aa9aab2d19a175d87" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="53de3c45119fbb85e6e306c8ef673329ce547bc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMSYS3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMSYS3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dee81eafae0d4aea8e3a9e54e7f51d78c86aa2e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_MEMSYS5&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_MEMSYS5&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2500c9c2e2e28fafbb17a1137edf0b22c762f19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_NULL_TRIM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_NULL_TRIM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="210b5c9d01b428603304b06ceb94d16df27f957c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddb51545e0bebfa7340c6cac3885e03fbb94fa35" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e39e596eb481fbc8bc498aa1eb115a9dbd791bf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_QPSG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_QPSG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aff785ec1400a7959c2d910171f7d36af168d741" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_RBU&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_RBU&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d7312a16f85346b92777f81548b126126f2a9ce9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_RTREE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_RTREE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf2789a3dfac2aec0ce73567ef591f88c395a4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8abf674d55e555f734817a21ddcd5e21c3015707" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fbcbad5bbf055acd0b8cb0f65883a99e15403389" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="050fd9347aba0613e41edd6d9163428b913cee4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0204d4bbf2c54d3a1ed06e32f0d2fbfba810aaf2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc060831fa345f0a6eab149e614a038d39d92be3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aadb411eed6a3e5c2d4eea8759254437ad95f39e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="faf2c9cc0d944bfbdb7cc148d522d3051abfdcf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95df966b12c5979c6c37cfbb73acce4de4031b52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8c43e0af9e63a24260b1237ffafa9382ffcb8eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="10ad0ef0211ad8e21498cf3f4662f8bcc6ba15cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd992a7384df4b2049382d0b4180b642a115bd15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e01ddc96bb53d6b852d1690bde30ccdb2f85dafe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cedadab65ac150d458ca8e13ba1611fb33b07ce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="253b5d9f8f32fa07fef6dbd123f4ce91b701c1d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6a286554137726a245c1b95b8192b6c3bbd3251" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9db0cb11222acab74db65c807eff63f7f55c2ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05591c0534904e32ca8cdac4b25cbb9d60a573b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9c352c0861967ddc2df753cc4bbcd4bcba3f2f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5ceb830bc9fd789f4fa5f7fcc0cabfaf48496306" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b03ae772584c2d2a9e11d0dc7338890a0357eb9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99e4b045bc420fa97a94b4105d7f761fb24049c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9c354011c14318ca6d262f2573fba28199396470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a401e4995f5551e362e32c54e2ba19071ea64e48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acb2a8063accd6b8beb78cacc0a648a21d40a870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b462c3d40d420240b9032bbae35bd514d016567b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99a1ffd86d48620ac9d92bbfacc8dd600f0161cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a4e92305244c1ce6fd0f4cd7269789b8529f373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3334e6a6da5c866bd89fe950d2c9b62e97f7ceb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9ecdc843e92293dcb6abf6daf54b6c3b4881468" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bfe038e385667f427bfaba3d91a9af26eba94450" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d6d0848efb00b356cb9465d9f109e2147210b9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7fdef8c2a9c01031f943ed79f514a8156d673500" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d8960215ae00abd7ebb1925d984e4b874f7c871" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aaf355948028ec514c8e85609b52d8ff903f1574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a1d498df4dd274ff01a03900ec4b34dda79009c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6a54eaef40777e126f4002faabd672a7e9f7e91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc2f291f887ee161ef88691303623ca2effb8629" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31a30cf46373dc5197f8e3344abb93ca02b039ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7e8d3c023e1a4ccad20b87139d88b7081b6817b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cff423655eb39b2c748dff51e94300e8f28ba4e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b62e20033dec22257f890ac30be31c4cd927192f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a4c5907c936567c2b7b9fa6bc346c059d43fc957" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5633de952d476b5d96fee010583ad94474595fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6fc3ef0b372de46a78bc829d1b0ac42417cbe60e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42dd6fec81e49f75f5ff85d610101a339b93346" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52d61fa2500d572bc3c2f61bc09133f36d87d7a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffebea17346fc66899b100e42dde64847ae162ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02a8ebfb8c51bfa8f5f04b211a7d7ff033ad0d12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00568160f62e1e2f3c85a4ec68228a6d706532ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d35796e3c6ab5d85720734a37998a6ce92535777" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03eb1718823b671bd128fc3257e8b9065c569dd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b059b5b58e6147c9da00dc4a5c50c89efee3912a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389e2542bf1d776bda49aa816f7acb08834bd6cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="707057fed5f688f9208bf46ef4426a605d5f09df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc82fd2191660ac807469076e0f7a404c356a0be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0905065083397f185f42d644502785ba7c6069f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e27ca5135fcc6a84108dc0ffc11de226b7192e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2d75578c65599befa260ca475b0a32c3620f002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14ef2bd88a85199b30182a69235817a3b5204f1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77f3d1be3901c085b4a5db58cfdd2f9aaa6ceeca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="136a7594d2f3c6161370dbd3a5755699a0f58d29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3dc23714e6733b26ba59900b7bd7b338d8e9f8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5afb0b5eb77dd513826c4b386ca2f26d1f287909" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bf04e411ffa329ca1466479098e23ff67d50730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c059cfc62627b1886e1ca9f2629fb0b673e1d368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ed3f9bfbb996093381267996d7d33c4f934eb7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d0281a47c9f5f4c349fb5ba928eb8bf37efa960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="be2660af6ab813539e2a8692aa5c050fd19d360c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668be95a6a3f50c7a5a63db473a408745e328f6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4eaaca938ecabc5c4dc11eaf9e065917dc70e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="78dab73ee3da96b8c7ec1553d7f97a1d26d45cc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e59c47d4c6184784743e4358c78e436ed302c8d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f0e56325b2afaf6793e05912f440ee78e1e06f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b5feca8b64e60e028e2dbdb4dce97b1428f8b10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="273973ea2fa452aa7255dd76283f67114dc7bc9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b844869cbb137b3f5aae65d9fc2124a7f75df280" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14def5836843dc064ff211faf4a1e5d1c19a5fc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8c7a3f7709d5ca48aa62de5b3a866714d6593cfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bff9bf2bc1a52aebb220f94954f92e1545ac1446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abef01fc3e06b07aafa25fb3d9e477bfd22cef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6336b6b7d8d57c2d7a777490e28348a06393d36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="059e2862fefd88c744b1377dc92f308d73cc50bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebb08208b1feeb2e4092b776ed5ddb8063c890ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6542f591162b1fac32afa54f47fc6731f33601c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="04514e40f182ad456b5245a466634fbd7e92daf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3932897bd040e95c1eb9739b7659d68beda3ea49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2fad4f7fe54b95701a39ee8feb95777319a60e90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OS_OTHER=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OS_OTHER = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56ee3d0e684b44b8675f52b13d0096d23504a7af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6463226645ffe362c178bbe7f828d660c275a442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6885cb8516f8377a9c28e855cb70b63504e6e435" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3a0235475a7827d68e0c1bb73ea4b44f4d323a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cec139681f0df7f780a39dbfc2f329845e7c650b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d94d24b874c2c537a6ea7780b2a6592350047905" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7713ed7ab2f2f1c55f8fdb3ab145f3b1b932345b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc3bed687fc846b37c550cd3cddfd9155cb90685" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d310d3f3bd739c56f040cc79192496e87ececfd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a23171b43aabf136109acb20d220b99d3e9da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0aba06a9fc72c1f03ecfc53abd7d244a52e61ce7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="857f1d4b039067e7938f0fbe3cd9dacc12a3cc3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TEMP_STORE=&lt;i&gt;&amp;lt;0 through 3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TEMP_STORE = &lt;i&gt;&amp;lt;&lt;/i&gt; 0-3 &lt;i&gt;&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="763974a69da7c357391024b037f2ff65866c1c72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_THREADSAFE=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_THREADSAFE = &lt;i&gt;&amp;lt;0 또는 1 또는 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db798c4c2b06b4515c31c3444478572466898eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="88ec24333763838d2b35e7775950f2196c7691af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08dfc4ddda00225d961592ced42dcb85aa2a6b68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b2c678e1824f51e764911d1d97afa9303106537c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f442370983bde912aeaa8688fb8696ae2e052aae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa939f2dbd402ef231f0ab3788a92497d3d84650" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1343ce5771a0eb9359ec0df9e37c4cc2874c8ebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="382b47f1f3b8cd49c3216efbc6c7a391dd57252d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55cb4273e62d90804c53d091b40902649ec6153d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de509a166760f395e8d9ff623bc5c20f291203f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하여 확장로드를 사용 안함으로 설정하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 사용 불가능하게 유지됩니다. 이렇게하면 SQL 삽입으로 공격자가 확장로드 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="77d070aba76c9c45f3f4dfb8cb2c0f7b57ceed06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하여 확장로드를 사용 안함으로 설정하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 사용 불가능하게 유지됩니다. 이렇게하면 SQL 삽입으로 공격자가 확장로드 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c39a9a8ee0c9f06fa3f477352418d833d84efb0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 만 사용 하려면 &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하는 것이 좋습니다 . &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스 사용을 피해야합니다. 이렇게하면 SQL 함수 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()이&lt;/a&gt; 비활성화되고 SQL 주입으로 인해 공격자가 확장 기능에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="85bcf242d91006a6e47ad703972cc780357bae6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 만 사용 하려면 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하는 것이 좋습니다 . &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스 사용을 피해야합니다. 이렇게하면 SQL 함수 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()이&lt;/a&gt; 비활성화되고 SQL 주입으로 인해 공격자가 확장 기능에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="cef37acd0e58d7484bc210c3874856e993d57c42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Self-documentation.&lt;/b&gt; Self-documenting digital objects contain basic descriptive, technical, and other administrative metadata.</source>
          <target state="translated">&lt;b&gt;자기 문서화. &lt;/b&gt;자체 문서화 디지털 개체에는 기본 설명, 기술 및 기타 관리 메타 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="67039928069e29c2b8fc9b97ed6661597211b7d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serialized&lt;/b&gt;. In serialized mode, SQLite can be safely used by multiple threads with no restriction.</source>
          <target state="translated">&lt;b&gt;직렬화&lt;/b&gt; . 직렬화 모드에서 SQLite는 제한없이 여러 스레드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6c18085190b76c91a8135185e5040fe095bb489" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Server-side database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;서버 측 데이터베이스&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a71e55c9e2165337c5f26b98320364c9a71fa32b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serverless&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Serverless&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d28078da99c520e2ece9e2e044a1e465058479f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Bare columns in an aggregate queries.&lt;/b&gt; The usual case is that all column names in an aggregate query are either arguments to &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; or else appear in the GROUP BY clause. A result column which contains a column name that is not within an aggregate function and that does not appear in the GROUP BY clause (if one exists) is called a &quot;bare&quot; column. Example:</source>
          <target state="translated">&lt;b&gt;참고 사항 : 집계 쿼리에서 맨손 열입니다.&lt;/b&gt; 일반적으로 집계 쿼리의 모든 열 이름은 &lt;a href=&quot;lang_aggfunc&quot;&gt;함수&lt;/a&gt; 를 집계 하는 인수 이거나 GROUP BY 절에 나타납니다. 집계 함수 내에 있지 않고 GROUP BY 절 (없는 경우)에 나타나지 않는 열 이름을 포함하는 결과 열을 &quot;베어&quot;열이라고합니다. 예:</target>
        </trans-unit>
        <trans-unit id="9a2bd3e845310e3146f075b7477b9a77fd861938" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Special handling of CROSS JOIN.&lt;/b&gt; There is no difference between the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; join operators. They are completely interchangeable in SQLite. The &quot;CROSS JOIN&quot; join operator produces the same result as the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; operators, but is &lt;a href=&quot;optoverview#crossjoin&quot;&gt;handled differently by the query optimizer&lt;/a&gt; in that it prevents the query optimizer from reordering the tables in the join. An application programmer can use the CROSS JOIN operator to directly influence the algorithm that is chosen to implement the SELECT statement. Avoid using CROSS JOIN except in specific situations where manual control of the query optimizer is desired. Avoid using CROSS JOIN early in the development of an application as doing so is a &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;premature optimization&lt;/a&gt;. The special handling of CROSS JOIN is an SQLite-specific feature and is not a part of standard SQL.</source>
          <target state="translated">&lt;b&gt;참고 : CROSS JOIN의 특수 처리.&lt;/b&gt; &quot;INNER JOIN&quot;, &quot;JOIN&quot;및 &quot;,&quot;조인 연산자에는 차이가 없습니다. 그것들은 SQLite에서 완전히 호환됩니다. &quot;CROSS JOIN&quot;조인 연산자는 &quot;INNER JOIN&quot;, &quot;JOIN&quot;및 &quot;,&quot;연산자와 동일한 결과를 생성하지만 쿼리 옵티마이 저가 조인의 테이블을 재정렬하지 못하도록 &lt;a href=&quot;optoverview#crossjoin&quot;&gt;쿼리 옵티 마이저&lt;/a&gt; 에서 다르게 처리됩니다 . 응용 프로그램 프로그래머는 CROSS JOIN 연산자를 사용하여 SELECT 문을 구현하기 위해 선택한 알고리즘에 직접 영향을 줄 수 있습니다. 쿼리 최적화 프로그램의 수동 제어가 필요한 특정 상황을 제외하고 CROSS JOIN을 사용하지 마십시오.&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;조기 최적화 는 애플리케이션 개발 초기에 CROSS JOIN을 사용하지 마십시오.&lt;/a&gt;. CROSS JOIN의 특수 처리는 SQLite 관련 기능이며 표준 SQL의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ded659eb85771f35ee1281ea75f0b58206ff5892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Simplified Application Development.&lt;/b&gt; No new code is needed for reading or writing the application file. One has merely to link against the SQLite library, or include the &lt;a href=&quot;amalgamation&quot;&gt;single &quot;sqlite3.c&quot; source file&lt;/a&gt; with the rest of the application C code, and SQLite will take care of all of the application file I/O. This can reduce application code size by many thousands of lines, with corresponding saving in development and maintenance costs.</source>
          <target state="translated">&lt;b&gt;단순화 된 응용 프로그램 개발. &lt;/b&gt;응용 프로그램 파일을 읽거나 쓰는 데 새로운 코드가 필요하지 않습니다. 하나는 단지 SQLite 라이브러리에 연결하거나 &lt;a href=&quot;amalgamation&quot;&gt;단일 &quot;sqlite3.c&quot;소스 파일&lt;/a&gt; 을 나머지 응용 프로그램 C 코드와 함께 포함하면 SQLite는 모든 응용 프로그램 파일 I / O를 처리합니다. 따라서 개발 및 유지 관리 비용을 절약하면서 애플리케이션 코드 크기를 수천 줄 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1a07cced5f47f7259b19ba37568ce82cb769c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;단일 데이터베이스 파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3366f819b02e356be2c09f8db154e11cec6006c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-File Documents.&lt;/b&gt; An SQLite database is contained in a single file, which is easily copied or moved or attached. The &quot;document&quot; metaphor is preserved.</source>
          <target state="translated">&lt;b&gt;단일 파일 문서. &lt;/b&gt;SQLite 데이터베이스는 단일 파일에 포함되어 있으며 쉽게 복사하거나 이동하거나 첨부 할 수 있습니다. &quot;문서&quot;은유는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="68d21fce42cee774794d3e89752dc4c799a36e13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-thread&lt;/b&gt;. In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.</source>
          <target state="translated">&lt;b&gt;단일 스레드&lt;/b&gt; . 이 모드에서는 모든 뮤텍스가 비활성화되고 SQLite는 한 번에 하나 이상의 스레드에서 사용하기에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b814fcbadf45ac4a5e2cf73ad790b7ea7575388b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stable Cross-Platform Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;안정적인 크로스 플랫폼 데이터베이스 파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4b6d0729d61e68af9be12dd919ff6d4508e9058a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in For An Enterprise RDBMS.&lt;/b&gt; SQLite is often used as a surrogate for an enterprise RDBMS for demonstration purposes or for testing. SQLite is fast and requires no setup, which takes a lot of the hassle out of testing and which makes demos perky and easy to launch.</source>
          <target state="translated">&lt;b&gt;Enterprise RDBMS를위한 스탠드 인. &lt;/b&gt;SQLite는 종종 데모 목적 또는 테스트를 위해 엔터프라이즈 RDBMS의 대리자로 사용됩니다. SQLite는 빠르며 설정이 필요하지 않으므로 테스트 과정에서 많은 번거 로움이 발생하여 데모가 거칠고 시작하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="49211ca87490fc949777a3fa6df7da5023e3e641" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in for an enterprise database during demos or testing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데모 또는 테스트 중 엔터프라이즈 데이터베이스를위한 스탠드 인&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e613e33621af0e53400119bdd08e80a1c293ae5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Startup is slow.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;시작이 느립니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f8a8cb97bdf26af3f7bcb45031e40198e438d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Summary:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Summary:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b838b6a7626f1106767937cfe090ef328a06b3c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;T&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;T&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cc92e1072d6f0803cf0720093c61b6114a74aff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt; as ISO8601 strings (&quot;YYYY-MM-DD HH:MM:SS.SSS&quot;).</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;ISO8601 문자열 인 &lt;b&gt;텍스트&lt;/b&gt; ( &quot;YYYY-MM-DD HH : MM : SS.SSS&quot;).</target>
        </trans-unit>
        <trans-unit id="51b499bb47a4b816c200573bc1654699b3396326" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt;. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).</source>
          <target state="translated">&lt;b&gt;TEXT&lt;/b&gt; . 값은 데이터베이스 인코딩 (UTF-8, UTF-16BE 또는 UTF-16LE)을 사용하여 저장된 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1175f4dc14e4a992c9182cfb85c0229a4412adea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Table name&lt;/b&gt;. The name of the component table within its database.</source>
          <target state="translated">&lt;b&gt;표 이름&lt;/b&gt; . 데이터베이스 내 구성 요소 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cce6f2ddbb90e75814b5925f282a337f2a6222d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Technical Protection Mechanisms.&lt;/b&gt; Implementation of mechanisms such as encryption that prevent the preservation of content by a trusted repository.</source>
          <target state="translated">&lt;b&gt;기술 보호 메커니즘. &lt;/b&gt;신뢰할 수있는 리포지토리가 콘텐츠를 보존하지 못하게하는 암호화와 같은 메커니즘 구현</target>
        </trans-unit>
        <trans-unit id="8b8491e1f95ab90350e3e533b25fcfd87b3e25b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Test, Debug, and Analysis Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;테스트, 디버그 및 분석 변경 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e053a51d81e6a2c72b1bc41555611b2f50e7a8c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &quot;DROP TABLE&quot; Exception&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;DROP TABLE&quot;예외&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7ee9ee9b8b34c217caeb5704b148f23d252d528" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental blob I/O&lt;/a&gt; mechanism does not work for WITHOUT ROWID tables.&lt;/b&gt; Incremental BLOB I/O uses the rowid to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for doing the direct I/O. However, WITHOUT ROWID tables do not have a rowid, and so there is no way to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for a WITHOUT ROWID table.</source>
          <target state="translated">&lt;b&gt;WITHOUT ROWID 테이블 에는 &lt;a href=&quot;c3ref/blob_open&quot;&gt;증분 Blob I / O&lt;/a&gt; 메커니즘이 작동하지 않습니다. &lt;/b&gt;증분 BLOB I / O는 rowid를 사용 하여 직접 I / O를 수행하기위한 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 객체 를 만듭니다 . 그러나 WITHOUT ROWID 테이블에는 rowid가 없으므로 WITHOUT ROWID 테이블에 대한 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 오브젝트 를 작성할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9333e7627a2d8956128f8661c8ce6d0c01b3a38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function does not work for WITHOUT ROWID tables.&lt;/b&gt; Inserts into a WITHOUT ROWID do not change the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. The &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; SQL function is also unaffected since it is just a wrapper around &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수는 ROWID 테이블없이 작동하지 않습니다. &lt;/b&gt;WITHOUT ROWID에 삽입해도 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수가 리턴 한 값은 변경되지 않습니다 . &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;LAST_INSERT_ROWID ()&lt;/a&gt; 는 주변 단지 래퍼이기 때문에 SQL의 기능은 영향을받지 않습니다 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid은 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d83b61d9f4987dc0f941ad211863bc9aa49f3be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface does not fire callbacks for changes to a WITHOUT ROWID table.&lt;/b&gt; Part of the callback from &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; is the rowid of the table row that has changed. However, WITHOUT ROWID tables do not have a rowid. Hence, the update hook is not invoked when a WITHOUT ROWID table changes.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스는 ROWID 테이블이없는 변경에 대한 콜백을 발생하지 않습니다. &lt;/b&gt;&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 의 콜백 중 일부 는 변경된 테이블 행의 rowid입니다. 그러나 WITHOUT ROWID 테이블에는 rowid가 없습니다. 따라서 WITHOUT ROWID 테이블이 변경 될 때 업데이트 후크가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d6305d6204c7fa058d43a6412f44de76568442f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The pthreads API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;pthreads API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2445d1d7779f00615aec27dcadb26e02eae2a0fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The special behaviors associated &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; do not apply on WITHOUT ROWID tables.&lt;/b&gt; In an ordinary table, &quot;INTEGER PRIMARY KEY&quot; means that the column is an alias for the rowid. But since there is no rowid in a WITHOUT ROWID table, that special meaning no longer applies. An &quot;INTEGER PRIMARY KEY&quot; column in a WITHOUT ROWID table works like an &quot;INT PRIMARY KEY&quot; column in an ordinary table: It is a PRIMARY KEY that has integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &quot; 와 관련된 특수 동작 은 WITHOUT ROWID 테이블에 적용되지 않습니다. &lt;/b&gt;일반 테이블에서 &quot;INTEGER PRIMARY KEY&quot;는 열이 rowid의 별명임을 의미합니다. 그러나 WITHOUT ROWID 테이블에는 rowid가 없으므로 해당 특수 의미는 더 이상 적용되지 않습니다. WITHOUT ROWID 테이블의 &quot;INTEGER PRIMARY KEY&quot;열은 일반 테이블의 &quot;INT PRIMARY KEY&quot;열처럼 작동합니다. 정수 &lt;a href=&quot;datatype3#affinity&quot;&gt;친화도&lt;/a&gt; 를 갖는 PRIMARY KEY입니다 .</target>
        </trans-unit>
        <trans-unit id="dca5135672aa5896d1934aec89434fccdee88668" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_config() interface is not threadsafe. The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config() is running.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_config () 인터페이스는 스레드 세이프가 아닙니다. 응용 프로그램은 sqlite3_config ()가 실행되는 동안 다른 스레드가 다른 SQLite 인터페이스를 호출하지 않도록해야합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c710e5ea2792e8eded22905b82d87b3dcd213e68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_unlock_notify() API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_unlock_notify () API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4617744409076bb539fa2b6bcbc61a76f81045ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This pragma is deprecated&lt;/b&gt; and exists for backwards compatibility only. New applications should avoid using this pragma. Older applications should discontinue use of this pragma at the earliest opportunity. This pragma may be omitted from the build when SQLite is compiled using &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;이 pragma는 더 이상 사용되지 않으며&lt;/b&gt; 이전 버전과의 호환성을 위해서만 존재합니다. 새로운 응용 프로그램은이 pragma를 사용하지 않아야합니다. 오래된 응용 프로그램은 가능한 빨리이 pragma의 사용을 중단해야합니다. 이 pragma는 SQLite가 &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED를&lt;/a&gt; 사용하여 컴파일 될 때 빌드에서 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58398df6716c7ad104ead532e8557ae487862fcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Token or token prefix queries&lt;/b&gt;. An FTS table may be queried for all documents that contain a specified term (the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple case&lt;/a&gt; described above), or for all documents that contain a term with a specified prefix. As we have seen, the query expression for a specific term is simply the term itself. The query expression used to search for a term prefix is the prefix itself with a '*' character appended to it. For example:</source>
          <target state="translated">&lt;b&gt;토큰 또는 토큰 접두사 쿼리&lt;/b&gt; . FTS 테이블은 지정된 용어가 포함 된 모든 문서 ( 위에서 설명한 &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;간단한 경우&lt;/a&gt; ) 또는 지정된 접두사가있는 용어가 포함 된 모든 문서에 대해 쿼리 할 수 ​​있습니다 . 우리가 보았 듯이, 특정 용어에 대한 쿼리 표현식은 단순히 용어 자체입니다. 용어 접두사를 검색하는 데 사용되는 쿼리 식은 접두사 자체에 '*'문자가 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35470c2e36b5d89ec0e5e0b5a16713ad8751938f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transition into and out of WAL-mode&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL 모드로 및 외부에서 전환&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e85cc4d69fe87371b922680953209fdf60a9693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transparency.&lt;/b&gt; Degree to which the digital representation is open to direct analysis with basic tools, such as human readability using a text-only editor.</source>
          <target state="translated">&lt;b&gt;투명도. &lt;/b&gt;텍스트 전용 편집기를 사용한 사람의 가독성과 같은 기본 도구를 사용하여 직접 분석하기 위해 디지털 표현을 여는 정도.</target>
        </trans-unit>
        <trans-unit id="6a1fef7ef2345014e787011b548dc8376d0bc1e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Truncate file&lt;/b&gt; operations. SQLite may truncate existing files by invoking the xTruncate() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 작업을 &lt;b&gt;자릅니다&lt;/b&gt; . SQLite는 sqlite3_file 객체의 xTruncate () 메서드를 호출하여 기존 파일을자를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4145432e1ccc1ea44b70a3377b44f8258ea4c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED FOLLOWING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;언 바운드 추종&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d68f4761ba65c695e8f710308c336949cdcf89a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED PRECEDING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;바운딩되지 않은 선행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f890ba61b6934cda1714e413c59c0c5a42dc7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Ubuntu&lt;/b&gt;: Desktop built from Intel i7-4770K at 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS</source>
          <target state="translated">&lt;b&gt;Ubuntu&lt;/b&gt; : Intel i7-4770K에서 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS로 구축 된 데스크탑</target>
        </trans-unit>
        <trans-unit id="8085a5307e375e1a3cc4d8ecb812cae7fed22ef8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Uninitialized memory.&lt;/b&gt; The instrumented memory allocator initializes each memory allocation to a nonsense bit pattern to help ensure that the user makes no assumptions about the content of allocation memory.</source>
          <target state="translated">&lt;b&gt;초기화되지 않은 메모리. &lt;/b&gt;인스트루먼트 된 메모리 할당자는 사용자가 할당 메모리의 내용에 대한 가정을하지 않도록하기 위해 각 메모리 할당을 넌센스 비트 패턴으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3925f9c7cd97c1b3f5e29f1be80c33e589fe5fd4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update on 2018-05-39:&lt;/b&gt; Our goal of supporting SQLite long-term have apparently come to the notice of the preservationist at the &lt;a href=&quot;https://www.loc.gov&quot;&gt;US Library Of Congress&lt;/a&gt; who have identified SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for the preservation of digital content.</source>
          <target state="translated">&lt;b&gt;2018-05-39 업데이트 :&lt;/b&gt; SQLite 장기 지원 목표 는 디지털 컨텐츠 보존을 위해 SQLite를 &lt;a href=&quot;locrsf&quot;&gt;권장 저장 형식으로&lt;/a&gt; 지정한 &lt;a href=&quot;https://www.loc.gov&quot;&gt;미국 의회 도서관의&lt;/a&gt; 보존 주의자에게 통지 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bd99662722847f47c9d95c77023462c53957fe12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update:&lt;/b&gt; As of SQLite version 3.7.0 (2010-07-21), all of SQLite memory allocation interfaces are considered stable and will be supported in future releases.</source>
          <target state="translated">&lt;b&gt;업데이트 :&lt;/b&gt; SQLite 버전 3.7.0 (2010-07-21)부터 모든 SQLite 메모리 할당 인터페이스는 안정적인 것으로 간주되며 이후 릴리스에서 지원 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4a17f9a5725b7ea7266f7211279b754186bbd337" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions.&lt;/b&gt; SQLite normally assumes that terms in the WHERE clause that cannot be used by indexes have a strong probability of being true. If this assumption is incorrect, it could lead to a suboptimal query plan. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions can be used to provide hints to the query planner about WHERE clause terms that are probably not true, and thus aid the query planner in selecting the best possible plan.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;가능성 ()&lt;/a&gt; 과 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성 ()&lt;/a&gt; SQL 함수. &lt;/b&gt;SQLite는 일반적으로 인덱스에서 사용할 수없는 WHERE 절의 용어가 참일 가능성이 높다고 가정합니다. 이 가정이 올바르지 않으면 차선의 쿼리 계획으로 이어질 수 있습니다. &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;가능성 ()&lt;/a&gt; 과 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성 ()&lt;/a&gt; SQL 함수를 따라서 아마 사실이 아니다, 그리고 절 용어는 최적의 계획을 선택하는 쿼리 계획을 돕기 WHERE에 대한 쿼리 계획에 대한 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb5521088e750b2b0996ab4ac8d5d78ce99b3974" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use compile-time options to enable debugging features.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;컴파일 시간 옵션을 사용하여 디버깅 기능을 활성화하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="624e8c505d78662928c531469f8c4839dcd31815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use of memory after freeing.&lt;/b&gt; When each block of memory is freed, every byte is overwritten with a nonsense bit pattern. This helps to ensure that no memory is ever used after having been freed.</source>
          <target state="translated">&lt;b&gt;해제 후 메모리 사용. &lt;/b&gt;각 메모리 블록이 해제되면 모든 바이트는 넌센스 비트 패턴으로 덮어 씁니다. 이를 통해 해제 된 후 메모리가 사용되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60df967df8dc96a687fd1c6e5298ea7d5de4825c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &quot;.eqp full&quot; option on the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &quot;.eqp full&quot;옵션을 사용하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee77fa4780771a6f5280fc94a682c4c8900c4945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; syntax to enforce the selection of particular indexes on problem queries.&lt;/b&gt; As with the previous two bullets, avoid this step if possible, and especially avoid doing this early in development as it is clearly a premature optimization.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;lang_indexedby&quot;&gt;에 의해 색인을&lt;/a&gt; 문제 쿼리에 특정 인덱스의 선택을 적용하는 구문. &lt;/b&gt;앞의 두 글 머리표와 마찬가지로 가능한 경우이 단계를 피하고 특히 조기 최적화이므로 개발 초기에이 단계를 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bba7254595e9a630fbbef9f9fef16a316097697a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt; syntax to enforce a particular loop nesting order on queries that might use low-quality indexes in an unanalyzed database.&lt;/b&gt; SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;treats the CROSS JOIN operator specially&lt;/a&gt;, forcing the table to the left to be an outer loop relative to the table on the right.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;optoverview#crossjoin&quot;&gt;가입 CROSS을&lt;/a&gt; unanalyzed 데이터베이스에 낮은 품질의 인덱스를 사용할 수있는 쿼리의 특정 루프 중첩 순서를 적용하는 구문을. &lt;/b&gt;SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;는 CROSS JOIN 연산자를 특수하게 처리하여&lt;/a&gt; 테이블을 왼쪽으로 강제하여 오른쪽 테이블과 관련하여 외부 루프가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fa98b891b98a769270b4431b060723a6be69cc3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use unary &quot;+&quot; operators to disqualify WHERE clause terms.&lt;/b&gt; If the query planner insists on selecting a poor-quality index for a particular query when a much higher-quality index is available, then &lt;a href=&quot;optoverview#uplus&quot;&gt;careful use of unary &quot;+&quot; operators&lt;/a&gt; in the WHERE clause can force the query planner away from the poor-quality index. Avoid using this trick if at all possible, and especially avoid it early in the application development cycle. Beware that adding a unary &quot;+&quot; operator to an equality expression might change the result of that expression if &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is involved.</source>
          <target state="translated">&lt;b&gt;단항 &quot;+&quot;연산자를 사용하여 WHERE 절 용어를 실격하십시오. &lt;/b&gt;쿼리 플래너가 훨씬 더 높은 품질의 인덱스를 사용할 수있을 때 특정 쿼리에 대해 열악한 인덱스를 선택 &lt;a href=&quot;optoverview#uplus&quot;&gt;해야하는&lt;/a&gt; 경우 WHERE 절에서 단항 &quot;+&quot;연산자 를 주의해서 사용 하면 쿼리 플래너가 열악한 품질에서 벗어날 수 있습니다. 인덱스. 가능하면이 트릭을 사용하지 말고 특히 애플리케이션 개발주기 초기에 사용하지 마십시오. 항등식에 단항 &quot;+&quot;연산자를 추가하면 &lt;a href=&quot;datatype3#affinity&quot;&gt;형식 선호도&lt;/a&gt; 가 관련된 경우 해당 식의 결과가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cca9bf8bd8b6e185263dc550b7207fcabdfc778b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.breakpoint&quot; shell command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;.breakpoint&quot;셸 명령 사용&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="185e070273e5254ad642967181d8c3d2a28284dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; shell commands&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;.selecttrace&quot;및 &quot;.wheretrace&quot;쉘 명령 사용&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f9397605fb07688bb69ea9f7536e70930b36524" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Variable-length records&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;가변 길이 레코드&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a6e556c10ec550463c045d14c122976ce8b5d00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large datasets&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;매우 큰 데이터 세트&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97000c025a0125f099ec23dce5e3ca08c6acd95e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large write transactions.&lt;/b&gt; A checkpoint can only complete when no other transactions are running, which means the WAL file cannot be reset in the middle of a write transaction. So a large change to a large database might result in a large WAL file. The WAL file will be checkpointed once the write transaction completes (assuming there are no other readers blocking it) but in the meantime, the file can grow very big.</source>
          <target state="translated">&lt;b&gt;매우 큰 쓰기 트랜잭션. &lt;/b&gt;검사 점은 다른 트랜잭션이 실행되고 있지 않을 때만 완료 할 수 있으므로 쓰기 트랜잭션 도중 WAL 파일을 재설정 할 수 없습니다. 따라서 큰 데이터베이스를 크게 변경하면 WAL 파일이 커질 수 있습니다. WAL 파일은 쓰기 트랜잭션이 완료되면 (이를 차단하는 다른 독자가 없다고 가정 할 때) 체크 포인트되지만 그 동안 파일이 매우 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d515fde87203051ec78c69e20ed524f4de5793a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad6d56d4428a77145ca6242e596a7fa2c1803531" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5d110f0b82f62dd2f5a0794e764ea8169257175" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f158b1754a80661dff694e137aecc3b2f6efb345" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="888483948ca68cc0b0af34e4a9b2b453974882ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; Misuse of this pragma can result in &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;database corruption&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; 이 pragma를 잘못 사용하면 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;데이터베이스가 손상&lt;/a&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0030ed0fd53893377f5547815043278fa13ee8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The data returned by the EXPLAIN QUERY PLAN command is intended for interactive debugging only. The output format may change between SQLite releases. Applications should not depend on the output format of the EXPLAIN QUERY PLAN command.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; EXPLAIN QUERY PLAN 명령으로 리턴 된 데이터는 대화식 디버깅 전용입니다. 출력 형식은 SQLite 릴리스간에 변경 될 수 있습니다. 응용 프로그램은 EXPLAIN QUERY PLAN 명령의 출력 형식에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3df3036875341edb9f8fc3a8acb1f8bcea071d37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 객체 는 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체입니다. 멀티 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로&lt;a href=&quot;#sqlite3_create_function&quot;&gt;&lt;/a&gt;최상위 응용 프로그램 코드 내에 있지 않은 응용 프로그램 정의 SQL 함수 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e113677f8631906939d48925646a6301748cade3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 객체 는 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체입니다. 멀티 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로&lt;a href=&quot;create_function&quot;&gt;&lt;/a&gt;최상위 응용 프로그램 코드 내에 있지 않은 응용 프로그램 정의 SQL 함수 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c159c6aeb388ae4e30b7b7f4145c9b703dbe4dfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; writing to the SQLITE_DBPAGE virtual table can very easily cause unrecoverably database corruption. Do not allow untrusted components to access the SQLITE_DBPAGE table. Use appropriate care while using the SQLITE_DBPAGE table. Back up important data prior to experimenting with the SQLITE_DBPAGE table. Writes to the SQLITE_DBPAGE virtual table are disabled when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; SQLITE_DBPAGE 가상 테이블에 쓰면 복구 할 수없는 데이터베이스 손상이 매우 쉽게 발생할 수 있습니다. 신뢰할 수없는 구성 요소가 SQLITE_DBPAGE 테이블에 액세스하도록 허용하지 마십시오. SQLITE_DBPAGE 테이블을 사용하는 동안 적절한주의를 기울이십시오. SQLITE_DBPAGE 테이블을 실험하기 전에 중요한 데이터를 백업하십시오. &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 설정 되면 SQLITE_DBPAGE 가상 테이블에 대한 쓰기가 사용 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="4f374c63735201c6cdaca2e4426827ae4ba2ca2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Website Database.&lt;/b&gt; Because it requires no configuration and stores information in ordinary disk files, SQLite is a popular choice as the database to back small to medium-sized websites.</source>
          <target state="translated">&lt;b&gt;웹 사이트 데이터베이스. &lt;/b&gt;구성이 필요하지 않고 일반 디스크 파일에 정보를 저장하기 때문에 SQLite는 중소 규모 웹 사이트를 백업하는 데이터베이스로 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e075eb30727f1c365f2bc04efc0a16da3a863f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Websites&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Websites&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da1e82610dd7e1bffc89ad32ea03dfb074479e2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win10&lt;/b&gt;: A 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</source>
          <target state="translated">&lt;b&gt;Win10&lt;/b&gt; : 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</target>
        </trans-unit>
        <trans-unit id="ea8bed047d5529263f89a6ee40214f46592fa94e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win7&lt;/b&gt;: A circa-2009 Dell Inspiron laptop, Pentium dual-core at 2.30GHz, 4GiB RAM, Windows7.</source>
          <target state="translated">&lt;b&gt;Win7&lt;/b&gt; : 2009 년경 Dell Inspiron 노트북, 2.30GHz의 Pentium 듀얼 코어, 4GiB RAM, Windows7.</target>
        </trans-unit>
        <trans-unit id="e68611734bd3e7ab106c3521f7c655f4756a046c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Wrapped Pile-of-Files Formats.&lt;/b&gt; Some applications use a Pile-of-Files that is then encapsulated into some kind of single-file container, usually a ZIP archive. EPUB, ODT,and ODP are examples of this approach. An EPUB book is really just a ZIP archive that contains various XHTML files for the text of book chapters, GIF and JPEG images for the artwork, and a specialized catalog file that tells the eBook reader how all the XML and image files fit together. OpenOffice documents (ODT and ODP) are also ZIP archives containing XML and images that represent their content as well as &quot;catalog&quot; files that show the interrelationships between the component parts.</source>
          <target state="translated">&lt;b&gt;래핑 된 파일 더미 형식.&lt;/b&gt; 일부 응용 프로그램은 파일 더미를 사용하여 일종의 단일 파일 컨테이너 (일반적으로 ZIP 아카이브)로 캡슐화합니다. EPUB, ODT 및 ODP가이 방법의 예입니다. EPUB 서적은 실제로 책 장의 텍스트를위한 다양한 XHTML 파일, 아트 워크를위한 GIF 및 JPEG 이미지, eBook 리더에게 모든 XML 및 이미지 파일이 어떻게 어울리는지를 알려주는 특화된 카탈로그 파일을 포함하는 ZIP 아카이브입니다. OpenOffice 문서 (ODT 및 ODP)는 구성 요소 부분 간의 상호 관계를 나타내는 &quot;카탈로그&quot;파일뿐만 아니라 해당 내용을 나타내는 XML 및 이미지를 포함하는 ZIP 아카이브입니다.</target>
        </trans-unit>
        <trans-unit id="e80e6ef180f77a11e4ad718760489bfd6c1d3980" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Write file&lt;/b&gt; operations. SQLite may modify the contents and increase the size of a file by files by invoking the xWrite() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;파일 쓰기&lt;/b&gt; 작업. SQLite는 sqlite3_file 객체의 xWrite () 메서드를 호출하여 파일의 내용을 수정하고 파일 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93a8e5c6820d5cb61b30e7580636cac841de035" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Writer Starvation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;작가 기아&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d5d06edcd682d757dc164e732a60c0964a20210" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ccba30872e5a56e0c69301bb6c07bd4a14eedd1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9774ec4279042a099a60de1ddc091ef4d042e40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-Configuration&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Zero-Configuration&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d787411914cc50b14089e0d3d1dd388e2edc91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-malloc option.&lt;/b&gt; The application can optionally provide SQLite with several buffers of bulk memory at startup and SQLite will then use those provided buffers for all of its memory allocation needs and never call system malloc() or free().</source>
          <target state="translated">&lt;b&gt;멀록 제로 옵션. &lt;/b&gt;응용 프로그램은 시작시 SQLite에 여러 벌크 메모리 버퍼를 선택적으로 제공 할 수 있으며 SQLite는 모든 메모리 할당 요구에 대해 제공된 버퍼를 사용하고 시스템 malloc () 또는 free ()를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f2b743bcbe285635e0463a315a493eb37176373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33dcc6c87c822c07ebff240814a228ff607b0b40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
