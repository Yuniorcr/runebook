<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="598464a1b17e0cdd4775fa1d87fe9e6f6f313e36" translate="yes" xml:space="preserve">
          <source>The possibly null unexecuted modification list.</source>
          <target state="translated">실행되지 않은 null 수정 목록입니다.</target>
        </trans-unit>
        <trans-unit id="701dd4005bf758fa7ad450f4118b0095191d7b33" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by &lt;code&gt;combiner&lt;/code&gt;, a second method handle. Of the arguments passed to the adapter, the first &lt;code&gt;N&lt;/code&gt; arguments are copied to the combiner, which is then called. (Here, &lt;code&gt;N&lt;/code&gt; is defined as the parameter count of the combiner.) After this, control passes to the target, with any result from the combiner inserted before the original &lt;code&gt;N&lt;/code&gt; incoming arguments.</source>
          <target state="translated">전처리 는 제 2 방법 핸들 인 &lt;code&gt;combiner&lt;/code&gt; 에 의해 수행된다 . 어댑터에 전달 된 인수 중 첫 번째 &lt;code&gt;N&lt;/code&gt; 인수가 결합기에 복사 된 후 호출됩니다. (여기서 &lt;code&gt;N&lt;/code&gt; 은 컴 바이 너의 매개 변수 수로 정의됩니다.)이 후 제어는 대상에 전달되고 컴 바이 너의 결과는 원래 &lt;code&gt;N&lt;/code&gt; 개의 수신 인수 앞에 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c240ae7a898a6847f515e8d7157c3336476bbff" translate="yes" xml:space="preserve">
          <source>The pre-processing is performed by one or more method handles, specified in the elements of the &lt;code&gt;filters&lt;/code&gt; array. The first element of the filter array corresponds to the &lt;code&gt;pos&lt;/code&gt; argument of the target, and so on in sequence.</source>
          <target state="translated">사전 처리는 &lt;code&gt;filters&lt;/code&gt; 배열 의 요소에 지정된 하나 이상의 메소드 핸들로 수행됩니다 . 필터 배열의 첫 번째 요소 는 대상 의 &lt;code&gt;pos&lt;/code&gt; 인수 등에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="54fba175e25513934ae6e0c928d834995d59017b" translate="yes" xml:space="preserve">
          <source>The precedence of character-class operators is as follows, from highest to lowest:</source>
          <target state="translated">문자 클래스 연산자의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1662793d099b9cf5e31bcba731e92de7d3a9c837" translate="yes" xml:space="preserve">
          <source>The precise definition of &quot;equality&quot; used in comparing attribute values is defined by the underlying directory service. It might use the &lt;code&gt;Object.equals&lt;/code&gt; method, for example, or might use a schema to specify a different equality operation. For matching based on operations other than equality (such as substring comparison) use the version of the &lt;code&gt;search&lt;/code&gt; method that takes a filter argument.</source>
          <target state="translated">속성 값을 비교하는 데 사용되는 &quot;평등&quot;의 정확한 정의는 기본 디렉토리 서비스에 의해 정의됩니다. 그것은 사용할 수 있습니다 &lt;code&gt;Object.equals&lt;/code&gt; 예를 들어, 방법, 또는 다른 동등 조작을 지정하는 스키마를 사용할 수 있습니다. 등호 이외의 연산 (예 : 하위 문자열 비교)을 기준으로 일치 시키려면 필터 인수를 사용하는 &lt;code&gt;search&lt;/code&gt; 메소드 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb4614fd577d896554af4208ae33226e3eddd8ad" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, a path that does not contain &lt;em&gt;redundant&lt;/em&gt; name elements. In many file systems, the &quot;&lt;code&gt;.&lt;/code&gt;&quot; and &quot;&lt;code&gt;..&lt;/code&gt;&quot; are special names used to indicate the current directory and parent directory. In such file systems all occurrences of &quot;&lt;code&gt;.&lt;/code&gt;&quot; are considered redundant. If a &quot;&lt;code&gt;..&lt;/code&gt;&quot; is preceded by a non-&quot;&lt;code&gt;..&lt;/code&gt;&quot; name then both names are considered redundant (the process to identify such names is repeated until it is no longer applicable).</source>
          <target state="translated">이 방법의 정확한 정의는 구현에 따라 다르지만 일반적으로 &lt;em&gt;중복&lt;/em&gt; 이름 요소를 포함하지 않는 경로 인이 경로에서 파생됩니다 . 많은 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;및 &quot; &lt;code&gt;..&lt;/code&gt; &quot;은 현재 디렉토리 및 상위 디렉토리를 나타내는 데 사용되는 특수 이름입니다. 이러한 파일 시스템에서 &quot; &lt;code&gt;.&lt;/code&gt; &quot;은 모두 중복 된 것으로 간주됩니다. 는 &quot;경우 &lt;code&gt;..&lt;/code&gt; &quot;비 &quot;로 시작됩니다 &lt;code&gt;..&lt;/code&gt; &quot;이름을 다음 두 이름이 고려 중복 (더 이상 적용 할 때까지 같은 이름을 식별 할 수있는 프로세스가 반복되지 않는다).</target>
        </trans-unit>
        <trans-unit id="f156f4742b28783fc176e2435a927cffa5913867" translate="yes" xml:space="preserve">
          <source>The precise definition of this method is implementation dependent but in general it derives from this path, an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path that locates the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as this path, but with name elements that represent the actual name of the directories and the file. For example, where filename comparisons on a file system are case insensitive then the name elements represent the names in their actual case. Additionally, the resulting path has redundant name elements removed.</source>
          <target state="translated">이 메소드의 정확한 정의는 구현에 따라 다르지만 일반적으로이 경로 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 을 찾는 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 인 이 경로에서 파생 되지만 디렉토리 및 파일의 실제 이름을 나타내는 이름 요소가 있습니다. 예를 들어, 파일 시스템에서 파일 이름 비교가 대소 문자를 구분하지 않는 경우 name 요소는 실제 대소 문자 이름을 나타냅니다. 또한 결과 경로에 중복 이름 요소가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f29514735dff4eb9875c567e3c77c10d0798a36a" translate="yes" xml:space="preserve">
          <source>The precise meaning of &quot;copy&quot; may depend on the class of the &lt;code&gt;CertStoreParameters&lt;/code&gt; object. A typical implementation performs a &quot;deep copy&quot; of this object, but this is not an absolute requirement. Some implementations may perform a &quot;shallow copy&quot; of some or all of the fields of this object.</source>
          <target state="translated">&quot;복사&quot;의 정확한 의미는 &lt;code&gt;CertStoreParameters&lt;/code&gt; 객체 의 클래스에 따라 달라질 수 있습니다 . 일반적인 구현은이 객체의 &quot;딥 카피&quot;를 수행하지만 반드시 필요한 것은 아닙니다. 일부 구현은이 객체의 일부 또는 모든 필드의 &quot;얕은 복사&quot;를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a518f78db20ec1e8e63802d6b81b3e5afc2d6f" translate="yes" xml:space="preserve">
          <source>The precise string returned is unspecified, although the following example can be considered typical:</source>
          <target state="translated">다음 예제는 일반적인 것으로 간주 될 수 있지만 반환 된 정확한 문자열은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc7760cf2ead29811d5a4f7919c808536944042d" translate="yes" xml:space="preserve">
          <source>The precision</source>
          <target state="translated">정밀도</target>
        </trans-unit>
        <trans-unit id="7f3d6ffd25563b48e926ec811735bc2c49c338dd" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b627f68a8d6aaaef844dc471dec6b871f7b4415" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73c2e0008148d7f138652dae3090ecc94203eec5" translate="yes" xml:space="preserve">
          <source>The precision is not applicable. If the precision is specified then an &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">정밀도는 적용되지 않습니다. 정밀도가 지정되면 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f948c10e382d2f7768291cb8552af2625096c3e" translate="yes" xml:space="preserve">
          <source>The precision is the maximum number of characters to be written to the output. The precision is applied before the width, thus the output will be truncated to &lt;code&gt;precision&lt;/code&gt; characters even if the width is greater than the precision. If the precision is not specified then there is no explicit limit on the number of characters.</source>
          <target state="translated">정밀도는 출력에 쓸 수있는 최대 문자 수입니다. 너비보다 정밀도가 적용되므로 너비가 정밀도보다 큰 경우에도 출력이 &lt;code&gt;precision&lt;/code&gt; 문자 로 잘립니다 . 정밀도를 지정하지 않으면 문자 수에 대한 명시적인 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="011a0b906162939e49578d08e8c1662e56c9f51a" translate="yes" xml:space="preserve">
          <source>The precision of a zero value is 1.</source>
          <target state="translated">0 값의 정밀도는 1입니다.</target>
        </trans-unit>
        <trans-unit id="4f4b2728c2d9fd894664edd48acbeb413a1af02a" translate="yes" xml:space="preserve">
          <source>The predicate which can be used for matching on a string</source>
          <target state="translated">문자열에서 일치시키는 데 사용할 수있는 술어</target>
        </trans-unit>
        <trans-unit id="93d5400fe79116558dbb225fbe571b21c4ae79c8" translate="yes" xml:space="preserve">
          <source>The preference node that emitted the event.</source>
          <target state="translated">이벤트를 생성 한 환경 설정 노드.</target>
        </trans-unit>
        <trans-unit id="795459da550b399518e8f16108cfa6f315f51f3c" translate="yes" xml:space="preserve">
          <source>The preferred form is the official IANA primary name for an encoding. Applications which stream text data should always specify the charset in the mime type, which necessitates obtaining the encoding of the host platform for data (eg files) stored in that platform's encoding. A CharSet which corresponds to this and is suitable for use in a mime-type for a DocFlavor can be obtained from &lt;a href=&quot;docflavor#hostEncoding&quot;&gt;&lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt;&lt;/a&gt; This may not always be the primary IANA name but is guaranteed to be understood by this VM. For common flavors, the pre-defined *HOST DocFlavors may be used.</source>
          <target state="translated">선호되는 형식은 인코딩의 공식 IANA 기본 이름입니다. 텍스트 데이터를 스트리밍하는 응용 프로그램은 항상 MIME 유형으로 문자 집합을 지정해야하며, 이로 인해 해당 플랫폼의 인코딩에 저장된 데이터 (예 : 파일)에 대한 호스트 플랫폼의 인코딩이 필요합니다. 이에 대응로부터 얻어 질 수 DocFlavor에 대한 마임 타입에서의 사용에 적절한 CharSet &lt;a href=&quot;docflavor#hostEncoding&quot;&gt; &lt;code&gt;DocFlavor.hostEncoding&lt;/code&gt; &lt;/a&gt; 항상 주 IANA 이름 않을 수도 있지만,이 VM에 의해 이해 될 것이 보장된다. 일반적인 풍미의 경우 사전 정의 된 * HOST DocFlavors를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1623642ae83456ebc262cddb280ef298b22cf43d" translate="yes" xml:space="preserve">
          <source>The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows:</source>
          <target state="translated">접두사 개념은 다음과 같이 UNIX 플랫폼에서 루트 디렉토리를 처리하고 Microsoft Windows 플랫폼에서 지정자, 루트 디렉토리 및 UNC 경로 이름을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e1c1be1011e46771e6c940b6b8fa6d5e62a87e1" translate="yes" xml:space="preserve">
          <source>The prefixes, suffixes, and various symbols used for infinity, digits, thousands separators, decimal separators, etc. may be set to arbitrary values, and they will appear properly during formatting. However, care must be taken that the symbols and strings do not conflict, or parsing will be unreliable. For example, either the positive and negative prefixes or the suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able to distinguish positive from negative values. (If they are identical, then &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was specified.) Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.</source>
          <target state="translated">무한대, 숫자, 천 단위 구분 기호, 소수점 구분 기호 등에 사용되는 접두사, 접미사 및 다양한 기호는 임의의 값으로 설정 될 수 있으며 서식을 지정할 때 올바르게 나타납니다. 그러나 기호와 문자열이 충돌하지 않거나 구문 분석을 신뢰할 수 없도록주의해야합니다. 예를 들어 &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; 에서 양수와 음수를 구분 하려면 양수와 음수 접두사 또는 접미사를 구분해야 합니다. (동일한 경우 &lt;code&gt;DecimalFormat&lt;/code&gt; 은 음의 하위 패턴이 지정되지 않은 것처럼 작동합니다.) 또 다른 예는 소수점 구분 기호와 천 단위 구분 기호가 고유 한 문자이거나 구문 분석이 불가능하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfe9500d76701215dda5f0694197cf9ce7cabc59" translate="yes" xml:space="preserve">
          <source>The preprocessing operations &lt;code&gt;\l&lt;/code&gt;&lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt;.</source>
          <target state="translated">전처리 작업 &lt;code&gt;\l&lt;/code&gt; &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c9b0afc43dff8f62f02bd5e510a84044b62add" translate="yes" xml:space="preserve">
          <source>The presence of a &quot;throws TooManyListenersException&quot; clause on any given concrete implementation of the normally multicast &quot;void addXyzEventListener&quot; event listener registration pattern is used to annotate that interface as implementing a unicast Listener special case, that is, that one and only one Listener may be registered on the particular event listener source concurrently.</source>
          <target state="translated">일반적으로 멀티 캐스트 &quot;void addXyzEventListener&quot;이벤트 리스너 등록 패턴의 특정 구현에 &quot;throws TooManyListenersException&quot;절이 존재하면 해당 인터페이스에 유니 캐스트 리스너 특수 케이스를 구현하는 것으로 즉, 하나의 리스너 만 구현할 수 있습니다. 특정 이벤트 리스너 소스에 동시에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfe2fa218fb85c049078854e31cba9eb33712aa" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;setProduct&lt;/code&gt; method now means that the &lt;code&gt;Product&lt;/code&gt; attribute is read/write. As before, the value of this attribute is an &lt;code&gt;ObjectName&lt;/code&gt;. When the attribute is set, the &lt;code&gt;ObjectName&lt;/code&gt; must be converted into the &lt;code&gt;ProductMXBean&lt;/code&gt; object that the &lt;code&gt;setProduct&lt;/code&gt; method expects. This object will be an MXBean proxy for the given &lt;code&gt;ObjectName&lt;/code&gt; in the same MBean Server.</source>
          <target state="translated">&lt;code&gt;setProduct&lt;/code&gt; 메소드가 존재 한다는 것은 이제 &lt;code&gt;Product&lt;/code&gt; 속성이 읽기 / 쓰기 임을 의미합니다 . 이전과 &lt;code&gt;ObjectName&lt;/code&gt; 속성의 값은 ObjectName 입니다. 속성이 설정되면 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;setProduct&lt;/code&gt; 메소드가 예상 하는 &lt;code&gt;ProductMXBean&lt;/code&gt; 오브젝트 로 변환되어야합니다 . 이 객체는 같은 MBean Server 내의 지정된 &lt;code&gt;ObjectName&lt;/code&gt; 의 MXBean 프록시가 됩니다.</target>
        </trans-unit>
        <trans-unit id="f7113d8eb1505536f0ceef50cb4ab773d8857fa3" translate="yes" xml:space="preserve">
          <source>The previously-attached object, if any, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이전에 연결된 객체 (있는 경우), 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ab68026a150f7949b7b1dc414949fb8e8e07d81" translate="yes" xml:space="preserve">
          <source>The primary alternative to using this interface throughout your application is as follows.</source>
          <target state="translated">응용 프로그램 전체에서이 인터페이스를 사용하는 주요 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf540bb867becf7faa8d8a8f6a3aafda966d70ed" translate="yes" xml:space="preserve">
          <source>The primary distinction of an &lt;code&gt;SSLEngine&lt;/code&gt; is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the &lt;code&gt;SSLEngine&lt;/code&gt; user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS abstraction from the I/O transport mechanism, the &lt;code&gt;SSLEngine&lt;/code&gt; can be used for a wide variety of I/O types, such as &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt;&lt;code&gt;non-blocking I/O (polling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt;&lt;code&gt;selectable non-blocking I/O&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; and the traditional Input/OutputStreams, local &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; or byte arrays, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt; future asynchronous I/O models &lt;/a&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 의 주요 차이점은 전송 메커니즘과 무관하게 인바운드 및 아웃 바운드 바이트 스트림에서 작동한다는 것입니다. 피어로의 안정적인 I / O 전송을 준비 하는 것은 &lt;code&gt;SSLEngine&lt;/code&gt; 사용자 의 책임입니다 . SSL / TLS 추상화를 I / O 전송 메커니즘에서 분리함으로써 &lt;code&gt;SSLEngine&lt;/code&gt; 은 &lt;a href=&quot;../../../java/nio/channels/spi/abstractselectablechannel#configureBlocking-boolean-&quot;&gt; &lt;code&gt;non-blocking I/O (polling)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/nio/channels/selector&quot;&gt; &lt;code&gt;selectable non-blocking I/O&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 및 기존 입력 / 출력 스트림, 로컬 &lt;a href=&quot;../../../java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; 또는 바이트 배열, &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=203&quot;&gt;향후 비동기 I / O 모델&lt;/a&gt; 등</target>
        </trans-unit>
        <trans-unit id="5aa8250cbbb0c762aa091de1f6729c7a726f2772" translate="yes" xml:space="preserve">
          <source>The primary method for awaiting completion and extracting results of a task is &lt;a href=&quot;forkjointask#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, but there are several variants: The &lt;a href=&quot;future#get--&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt; methods support interruptible and/or timed waits for completion and report results using &lt;code&gt;Future&lt;/code&gt; conventions. Method &lt;a href=&quot;forkjointask#invoke--&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; is semantically equivalent to &lt;code&gt;fork(); join()&lt;/code&gt; but always attempts to begin execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method &lt;code&gt;invokeAll&lt;/code&gt; (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all.</source>
          <target state="translated">완료를 기다리고 작업의 결과를 추출하는 기본 방법은 &lt;a href=&quot;forkjointask#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 이지만 몇 가지 변형이 있습니다. &lt;a href=&quot;future#get--&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; 메서드는 인터럽트 가능 및 / 또는 시간 초과 된 대기를 지원하고 &lt;code&gt;Future&lt;/code&gt; 규칙을 사용하여 결과를보고합니다 . &lt;a href=&quot;forkjointask#invoke--&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; 메소드 는 의미 적으로 &lt;code&gt;fork(); join()&lt;/code&gt; 와 같습니다 . join () 이지만 항상 현재 스레드에서 실행을 시작하려고합니다. 이러한 메소드 의 &quot; &lt;em&gt;조용한&lt;/em&gt; &quot;형식은 결과를 추출하거나 예외를보고하지 않습니다. 이는 일련의 작업이 실행될 때 유용 할 수 있으며 모든 작업이 완료 될 때까지 결과 또는 예외 처리를 지연시켜야합니다. 메소드 &lt;code&gt;invokeAll&lt;/code&gt; (여러 버전에서 사용 가능) 가장 일반적인 형태의 병렬 호출을 수행합니다. 일련의 작업을 분기하고 모든 작업을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="e7ff3a60b668a9b4f8ca3f3d80ba5d198b1e81f9" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제는 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99d4de701d15e3c0f3d5abd8f5d765bb2d14afb5" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathBuilder&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bfe43c7ad82b7b062c6a1e827670b3dcd56247c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to allow callers to specify additional input parameters and options specific to revocation checking. See the class description of &lt;code&gt;CertPathValidator&lt;/code&gt; for an example.</source>
          <target state="translated">이 방법의 주요 목적은 호출자가 해지 확인과 관련된 추가 입력 매개 변수 및 옵션을 지정할 수 있도록하는 것입니다. 예제 는 &lt;code&gt;CertPathValidator&lt;/code&gt; 의 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f492c04efa6c01604221d247f621ebc339b6f64" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83fc8baed5ef78ca23821a13e04a9d8ddd10f762" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">프리미티브 유형 &lt;code&gt;byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f471c30cb2c84f70470f03c585738bdc64b599e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">원시 형 &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44aee72206b87354d815ff88a92f784a937e888" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">원시 타입은 &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd515036f97bf6ba858fdf01810f65a40a4f0c9c" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3a71348ea0fed210633648dce17501818f0109" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">원시적 형태 &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbfb61247c4fbf66782c11b9ea7234fee3f4c1e" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">기본 유형은 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbd45dce2a86e7713945fe9ae4375a42101fb99a" translate="yes" xml:space="preserve">
          <source>The primitive type &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">기본 유형 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13f1d1c5a513be9280a101289705bc830feffc07" translate="yes" xml:space="preserve">
          <source>The principal methods are defined to allow the throwing of an exception. In normal use, no exceptions will be thrown, however one possible implementation would be to obtain the time from a central time server across the network. Obviously, in this case the lookup could fail, and so the method is permitted to throw an exception.</source>
          <target state="translated">주요 메소드는 예외 발생을 허용하도록 정의됩니다. 정상적인 사용에서는 예외가 발생하지 않지만 네트워크를 통해 중앙 시간 서버에서 시간을 얻는 것이 가능합니다. 분명히이 경우 조회가 실패 할 수 있으므로 메소드에서 예외가 발생하도록 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="00414fce4c7455a893959b39576e22c2ae5eafaa" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuffer&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the buffer; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuffer&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법이며, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 버퍼에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 버퍼의 끝에서 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8d9eb8cbf18b97db213dc84e3622468146efcc16" translate="yes" xml:space="preserve">
          <source>The principal operations on a &lt;code&gt;StringBuilder&lt;/code&gt; are the &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;insert&lt;/code&gt; methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder. The &lt;code&gt;append&lt;/code&gt; method always adds these characters at the end of the builder; the &lt;code&gt;insert&lt;/code&gt; method adds the characters at a specified point.</source>
          <target state="translated">&lt;code&gt;StringBuilder&lt;/code&gt; 의 주요 작업 은 &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 방법으로, 모든 유형의 데이터를 허용하도록 오버로드됩니다. 각각은 주어진 데이텀을 효과적으로 문자열로 변환 한 다음 해당 문자열의 문자를 문자열 빌더에 추가하거나 삽입합니다. &lt;code&gt;append&lt;/code&gt; 방법은 항상 빌더의 끝 부분에 이러한 문자를 추가; &lt;code&gt;insert&lt;/code&gt; 방법은 지정된 지점에 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdd711677992dcb1524f6e2386709d058ae3ac67" translate="yes" xml:space="preserve">
          <source>The principal purpose of these additions is to allow the specification of tables to use in encoding abbreviated streams. The built-in JPEG writer will also accept an ordinary &lt;code&gt;ImageWriteParam&lt;/code&gt;, in which case the writer will construct the necessary tables internally.</source>
          <target state="translated">이러한 추가의 주요 목적은 테이블 지정이 축약 된 스트림을 인코딩하는 데 사용할 수 있도록하는 것입니다. 내장 JPEG 라이터는 일반적인 &lt;code&gt;ImageWriteParam&lt;/code&gt; 을 수용하며 ,이 경우 라이터는 필요한 테이블을 내부적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="79e1de7f953be5214dc8046cee3435b263a6bc9b" translate="yes" xml:space="preserve">
          <source>The print data and the processing instructions are separate entities. This means that:</source>
          <target state="translated">인쇄 데이터와 처리 지침은 별도의 엔터티입니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87fa994137d2af295902c75d6d1e468277e6adf3" translate="yes" xml:space="preserve">
          <source>The print data format is unspecified (just an octet stream)</source>
          <target state="translated">인쇄 데이터 형식이 지정되지 않았습니다 (옥텟 스트림 만).</target>
        </trans-unit>
        <trans-unit id="87d74c41b031f63a36b535b9f8f87b980e7f4993" translate="yes" xml:space="preserve">
          <source>The print service indicates that a - possibly transient - problem may require external intervention before the print service can continue. One example of an event that can generate this message is when the printer runs out of paper.</source>
          <target state="translated">인쇄 서비스는 일시적인 문제로 인해 인쇄 서비스를 계속하기 전에 외부 개입이 필요할 수 있음을 나타냅니다. 이 메시지를 생성 할 수있는 이벤트의 한 예는 프린터에 용지가 부족한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="6ffca2a80baec343c1fe37408ec848806e832a04" translate="yes" xml:space="preserve">
          <source>The print service reports that the job cannot be completed. The application must resubmit the job.</source>
          <target state="translated">인쇄 서비스에서 작업을 완료 할 수 없다고보고합니다. 응용 프로그램은 작업을 다시 제출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee3379a27f4d6bd5aea086e7d040f37f1b4e28e0" translate="yes" xml:space="preserve">
          <source>The printable area is specified to be a rectangle, within the overall dimensions of a media.</source>
          <target state="translated">인쇄 가능한 영역은 용지의 전체 크기 내에서 사각형으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a424ad159a01af0ae87f7797a6b6f5420eea6d5" translate="yes" xml:space="preserve">
          <source>The printer attempts to make the external job attribute values take precedence over embedded instructions in the documents' print data, however there is no guarantee.</source>
          <target state="translated">프린터가 외부 작업 속성 값을 문서의 인쇄 데이터에 포함 된 지시 사항보다 우선하게하려고하지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="420689a193f1513253aa8f7350cd70790dfdb9dd" translate="yes" xml:space="preserve">
          <source>The printer decides how to interpret the print data; the way this &quot;autosensing&quot; works is implementation dependent. In general, preformatted autosense print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">프린터는 인쇄 데이터 해석 방법을 결정합니다. 이 &quot;자동 감지&quot;작동 방식은 구현에 따라 다릅니다. 일반적으로 미리 포맷 된 자동 감지 인쇄 데이터는 바이트 지향 표현 클래스 (바이트 배열, InputStream, URL)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d27c6ece8fd59adc7c9db5b4829fd7026afa41" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer has not finished accessing or accepting all the print data yet.</source>
          <target state="translated">프린터가 인쇄 작업을 만들었지 만 프린터가 아직 모든 인쇄 데이터에 액세스하거나 수락하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2c6e9c3b42f4bb17ba7645de0aa8f126f95272d5" translate="yes" xml:space="preserve">
          <source>The printer has created the Print Job, but the printer is expecting additional print data before it can move the job into the PROCESSING state. If a printer starts processing before it has received all data, the printer removes the JOB_DATA_INSUFFICIENT reason, but the JOB_INCOMING reason remains. If a printer starts processing after it has received all data, the printer removes the JOB_DATA_INSUFFICIENT and JOB_INCOMING reasons at the same time.</source>
          <target state="translated">프린터가 인쇄 작업을 생성했지만 프린터가 작업을 처리 중 상태로 옮기기 전에 추가 인쇄 데이터가 필요합니다. 프린터가 모든 데이터를 받기 전에 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 이유를 제거하지만 JOB_INCOMING 이유는 남아 있습니다. 프린터가 모든 데이터를 수신 한 후 처리를 시작하면 프린터는 JOB_DATA_INSUFFICIENT 및 JOB_INCOMING 이유를 동시에 제거합니다.</target>
        </trans-unit>
        <trans-unit id="26f86c1fd10f95e2e1ce6d73964c40d138b16512" translate="yes" xml:space="preserve">
          <source>The printer has detected an error other than ones listed below.</source>
          <target state="translated">프린터가 아래 나열된 오류 이외의 오류를 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="ee4d72184cd18cc72c7888278ace0c6fd62b60fb" translate="yes" xml:space="preserve">
          <source>The printer has made the job ready for printing, but the output device is not yet printing it, either because the job hasn't reached the output device or because the job is queued in the output device or some other spooler, awaiting the output device to print it.</source>
          <target state="translated">프린터가 작업을 인쇄 준비 상태로 만들었지 만 작업이 출력 장치에 도달하지 않았거나 출력 장치 또는 다른 스풀러에서 작업이 대기하여 출력 장치를 대기 중이기 때문에 출력 장치가 아직 인쇄하지 않습니다 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bb06ac1489baa54ea2bee8733b418deb9986e56c" translate="yes" xml:space="preserve">
          <source>The printer has scheduled a job on the output device and is in the process of connecting to a shared network output device (and might not be able to actually start printing the job for an arbitrarily long time depending on the usage of the output device by other servers on the network).</source>
          <target state="translated">프린터가 출력 장치에서 작업을 예약했으며 공유 네트워크 출력 장치에 연결하는 중입니다 (다른 장치의 출력 장치 사용에 따라 실제로 장시간 인쇄 작업을 시작하지 못할 수 있음) 네트워크상의 서버).</target>
        </trans-unit>
        <trans-unit id="8e0bf3607b8e2970cff88cf552730d6f2d8d625d" translate="yes" xml:space="preserve">
          <source>The printer is capable of some type of color printing, such as highlight color or full process color.</source>
          <target state="translated">프린터는 밝은 색상 또는 전체 프로세스 색상과 같은 일부 유형의 컬러 인쇄가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c005cdea131511c73720a6f53d9a8366cf1ca01d" translate="yes" xml:space="preserve">
          <source>The printer is currently accepting jobs.</source>
          <target state="translated">프린터가 현재 작업을 수락하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c387e9c6647fb266c1648f1dc120f6cc016ad4" translate="yes" xml:space="preserve">
          <source>The printer is currently rejecting any jobs sent to it.</source>
          <target state="translated">프린터가 현재 전송 된 작업을 거부하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b0ff98c2f13c970471be7702bd134d6dbdc6cc" translate="yes" xml:space="preserve">
          <source>The printer is in the process of stopping the device and will be stopped in a while. When the device is stopped, the printer will change the &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; to STOPPED. The STOPPING reason is never an error, even for a printer with a single output device. When an output device ceases accepting jobs, the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; will have this reason while the output device completes printing.</source>
          <target state="translated">프린터가 장치를 중지하는 중이며 잠시 후에 중지됩니다. 장치가 중지되면 프린터는 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 를 STOPPED로 변경합니다 . 단일 출력 장치가있는 프린터의 경우에도 STOPPING 이유는 오류가 아닙니다. 출력 장치가 작업 수락을 중단 하면 출력 장치가 인쇄를 완료하는 동안 프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 에이 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f62f72799c6d5e9a37cf0c00f4e1b535987780" translate="yes" xml:space="preserve">
          <source>The printer is not capable of any type of color printing.</source>
          <target state="translated">프린터는 어떤 유형의 컬러 인쇄도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a76ccbd08fd7ed213da23153a2832c1f11f3ddb7" translate="yes" xml:space="preserve">
          <source>The printer is off-line and accepting no jobs. All PENDING jobs are put into the PENDING_HELD state. This situation could be true if the service's or document transform's input is impaired or broken.</source>
          <target state="translated">프린터가 오프라인 상태이며 작업을 수락하지 않습니다. 모든 PENDING 작업은 PENDING_HELD 상태가됩니다. 서비스 또는 문서 변환의 입력이 손상되었거나 손상된 경우이 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ea5b5a51cabfc6ce87f4bba805d145bf23c69d" translate="yes" xml:space="preserve">
          <source>The printer is transmitting the job to the output device.</source>
          <target state="translated">프린터가 작업을 출력 장치로 전송하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1b431e7082d79aa73c78295a787c0420e076b7" translate="yes" xml:space="preserve">
          <source>The printer makes no attempt to make the external job attribute values take precedence over embedded instructions in the documents' print data.</source>
          <target state="translated">프린터는 문서의 인쇄 데이터에 포함 된 지시 사항보다 외부 작업 속성 값을 우선시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc15b2e767f5374c6b094a0dfd57a256c58156f6" translate="yes" xml:space="preserve">
          <source>The printer should make reasonable attempts to print the job, even if it cannot print it exactly as specified.</source>
          <target state="translated">프린터는 지정된대로 정확하게 인쇄 할 수 없더라도 작업 인쇄를 합리적으로 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="e18a8686bb628a68a2eaf4c30403e4349bfe5fcd" translate="yes" xml:space="preserve">
          <source>The printer state is unknown.</source>
          <target state="translated">프린터 상태를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08bc056d9ef081c3233d58a84e37a59beef78d75" translate="yes" xml:space="preserve">
          <source>The printwriter associated with this console</source>
          <target state="translated">이 콘솔과 관련된 인쇄기</target>
        </trans-unit>
        <trans-unit id="97a7ef6f1e3cb3a0aaedfb170ff09b511361e6da" translate="yes" xml:space="preserve">
          <source>The priority of the newly created thread is set equal to the priority of the thread creating it, that is, the currently running thread. The method &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; may be used to change the priority to a new value.</source>
          <target state="translated">새로 작성된 스레드의 우선 순위는 스레드를 작성하는 스레드의 우선 순위, 즉 현재 실행중인 스레드와 동일하게 설정됩니다. &lt;a href=&quot;thread#setPriority-int-&quot;&gt;setPriority&lt;/a&gt; 메소드 는 우선 순위를 새로운 값으로 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c66994c2e5565d62182013ffae28875f5cf6f391" translate="yes" xml:space="preserve">
          <source>The probe result is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string must be parsable according to the grammar in the RFC 2045.</source>
          <target state="translated">프로브 결과는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC 2045의 문법에 따라 문자열을 구문 분석 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="880dec8515b711c27c013e6c9697d99218ffed43" translate="yes" xml:space="preserve">
          <source>The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the &lt;code&gt;Set&lt;/code&gt; interface (for instance, the add method must not permit addition of multiple instances of an object to a set).</source>
          <target state="translated">이 클래스를 확장하여 세트를 구현하는 프로세스는이 클래스의 서브 클래스에있는 모든 메소드 및 생성자가 &lt;code&gt;Set&lt;/code&gt; 인터페이스 에 의해 부과 된 추가 제한 조건을 준수해야한다는 점을 제외하면 AbstractCollection을 확장하여 Collection을 구현하는 프로세스와 동일합니다 . add 메소드는 오브젝트의 여러 인스턴스를 세트에 추가 할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1ec3b94c22e460ebbbb042de3db1027d96793ab" translate="yes" xml:space="preserve">
          <source>The process of normalization is specific to each calendar system. For example, in the ISO calendar system, the years and months are normalized but the days are not, such that &quot;15 months&quot; would be normalized to &quot;1 year and 3 months&quot;.</source>
          <target state="translated">정규화 프로세스는 각 달력 시스템에 따라 다릅니다. 예를 들어, ISO 달력 시스템에서 연도와 월은 정규화되지만 요일은 그렇지 않으므로 &quot;15 개월&quot;은 &quot;1 년 3 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="455f1746aa3e2b37c23f02cccc11f1194c2bd1f7" translate="yes" xml:space="preserve">
          <source>The processing instruction does not specify how the print job processes the request; each processing instruction is only a description of the results of a print job. The print job determines the manner in which it achieves the results specified by the processing instructions. Representing processing instructions as descriptive items provides more flexibility for implementing print jobs.</source>
          <target state="translated">처리 명령은 인쇄 작업이 요청을 처리하는 방법을 지정하지 않습니다. 각 처리 명령은 인쇄 작업 결과에 대한 설명 일뿐입니다. 인쇄 작업에 따라 처리 지침에 지정된 결과를 얻는 방식이 결정됩니다. 처리 지침을 설명 항목으로 표시하면 인쇄 작업을보다 유연하게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21468901598e18762161fbe3cf811efedaec007" translate="yes" xml:space="preserve">
          <source>The program</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="76dfc7088829bdbf1569fb6f72d786a2251045f0" translate="yes" xml:space="preserve">
          <source>The program number is zero-based (expressed from 0 to 127). Note that MIDI hardware displays and literature about MIDI typically use the range 1 to 128 instead. It is possible that the underlying synthesizer does not support a specific program. In order to verify that a call to &lt;code&gt;programChange&lt;/code&gt; was successful, use &lt;code&gt;getProgram&lt;/code&gt;.</source>
          <target state="translated">프로그램 번호는 0부터 시작합니다 (0에서 127까지 표시). MIDI에 대한 MIDI 하드웨어 디스플레이 및 문헌은 일반적으로 1-128 범위를 사용합니다. 기본 신디사이저가 특정 프로그램을 지원하지 않을 수 있습니다. &lt;code&gt;programChange&lt;/code&gt; 호출 이 성공 했는지 확인 하려면 &lt;code&gt;getProgram&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4155d56e171215de9c7037e45d7bce8a1282da2c" translate="yes" xml:space="preserve">
          <source>The program number of the instrument that this voice is currently using. The value ranges from 0 to 127 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 현재 사용중인 악기의 프로그램 번호입니다. 음성이 활성화 된 경우 값의 범위는 0-127이며 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1be1f5399b975af8c707420333db180e0981d19" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property that was changed. May be null if multiple properties have changed.</source>
          <target state="translated">변경된 속성의 프로그래밍 방식 이름입니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad93de22f765c96c57d8527107c09122268deb2d" translate="yes" xml:space="preserve">
          <source>The programmatic name of the property/method/event</source>
          <target state="translated">속성 / 방법 / 이벤트의 프로그래밍 이름</target>
        </trans-unit>
        <trans-unit id="4a4ca8c0566e76e0bda81fc2154a3dd169f21dfd" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and &lt;code&gt;Collection&lt;/code&gt; constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 &lt;code&gt;Collection&lt;/code&gt; 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61075cdab1eeb6f09db5bfab67efc96a9fe1b4d1" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="37e4fc3e466260a434320ff485db7412afec1305" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;code&gt;Collection&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 컬렉션 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92e053e057575398190a0ac956a5817f3e0304d3" translate="yes" xml:space="preserve">
          <source>The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the &lt;code&gt;Map&lt;/code&gt; interface specification.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;Map&lt;/code&gt; 인터페이스 사양 의 권장 사항에 따라 void (인수 없음) 및 맵 생성자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="391c694a427ff64d8dedbc35ef6300a0d16bfa8a" translate="yes" xml:space="preserve">
          <source>The proleptic year, such as 2012.</source>
          <target state="translated">2012 년과 같은 다산의 해.</target>
        </trans-unit>
        <trans-unit id="2f8941a3eade121ced3151a4fbe9a184aa501fb3" translate="yes" xml:space="preserve">
          <source>The proleptic-month based, counting months sequentially from year 0.</source>
          <target state="translated">0 년부터 순차적으로 월을 계산하는 proleptic-month based.</target>
        </trans-unit>
        <trans-unit id="4a56a02d5a817b1dc30304481e16ea69bcff2062" translate="yes" xml:space="preserve">
          <source>The properties for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.</source>
          <target state="translated">로거 및 핸들러의 특성은 이름이 핸들러 또는 로거의 점으로 구분 된 이름으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="daa8bdb84e81154bc80370cc5e9727f554ff3e32" translate="yes" xml:space="preserve">
          <source>The properties-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;unmodifiable&lt;/a&gt;.</source>
          <target state="translated">속성은 전용 형식 &lt;code&gt;List&lt;/code&gt; 포함 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; . 이 &lt;code&gt;List&lt;/code&gt; 은 &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;수정할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ef13d5a715c58badd6aeb3009b5ac9131a03a4" translate="yes" xml:space="preserve">
          <source>The property map may contain pre-defined implementation specific and default properties. Users are encouraged to read the information and fully understand the implications, before modifying pre-existing properties.</source>
          <target state="translated">특성 맵에는 사전 정의 된 구현 특정 및 기본 특성이 포함될 수 있습니다. 기존 속성을 수정하기 전에 정보를 읽고 그 의미를 완전히 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a44166bbcf01d577f1354b0551d5aad5a3ef464" translate="yes" xml:space="preserve">
          <source>The property resource defining the &lt;code&gt;{ID}&lt;/code&gt; variant</source>
          <target state="translated">&lt;code&gt;{ID}&lt;/code&gt; 변형을 정의하는 특성 자원</target>
        </trans-unit>
        <trans-unit id="af5b082804d7c2dde6ea05c46a90e42cc6381e7f" translate="yes" xml:space="preserve">
          <source>The property resource is located with the &lt;code&gt;calendars.properties&lt;/code&gt; file</source>
          <target state="translated">등록 정보 자원은 &lt;code&gt;calendars.properties&lt;/code&gt; 파일 과 함께 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb305a13af061bdafc684dce06c7fea083824a3c" translate="yes" xml:space="preserve">
          <source>The property value as a human editable string.</source>
          <target state="translated">사람이 편집 할 수있는 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="928506a8e906ccfdc133220356a75d90280830ec" translate="yes" xml:space="preserve">
          <source>The property value as a string suitable for presentation to a human to edit.</source>
          <target state="translated">사람이 편집 할 수 있도록 적합한 문자열 인 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="73101b28e30a36efb57859ac5d834112bb90605f" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the device name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/midideviceprovider&quot;&gt;&lt;code&gt;MIDI device provider&lt;/code&gt;&lt;/a&gt; class. The device name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;MidiDevice.Info&lt;/code&gt;. Either the class name, or the device name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 장치 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 프로 바이더 클래스 이름은 구체적인 &lt;a href=&quot;spi/midideviceprovider&quot;&gt; &lt;code&gt;MIDI device provider&lt;/code&gt; &lt;/a&gt; 클래스 의 정규화 된 이름입니다 . 장치 이름은 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치 합니다 . 클래스 이름 또는 장치 이름이 생략 될 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="0fda51bd535de894365d52df1f5e4d52b33dd40e" translate="yes" xml:space="preserve">
          <source>The property value consists of the provider class name and the mixer name, separated by the hash mark (&quot;#&quot;). The provider class name is the fully-qualified name of a concrete &lt;a href=&quot;spi/mixerprovider&quot;&gt;&lt;code&gt;mixer provider&lt;/code&gt;&lt;/a&gt; class. The mixer name is matched against the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt; method of &lt;code&gt;Mixer.Info&lt;/code&gt;. Either the class name, or the mixer name may be omitted. If only the class name is specified, the trailing hash mark is optional.</source>
          <target state="translated">속성 값은 공급자 클래스 이름과 믹서 이름으로 구성되며 해시 표시 ( &quot;#&quot;)로 구분됩니다. 제공자 클래스 이름은 콘크리트 &lt;a href=&quot;spi/mixerprovider&quot;&gt; &lt;code&gt;mixer provider&lt;/code&gt; &lt;/a&gt; 클래스 의 완전한 이름입니다 . 믹서 이름은 &lt;code&gt;Mixer.Info&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;String&lt;/code&gt; 과 일치합니다 . 클래스 이름 또는 믹서 이름을 생략 할 수 있습니다. 클래스 이름 만 지정하면 후미 해시 마크는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="8bca8021794336ac922184238ff13cedd04b4c6c" translate="yes" xml:space="preserve">
          <source>The protocol handler calls this method after a resource has been retrieved, and the ResponseCache must decide whether or not to store the resource in its cache. If the resource is to be cached, then put() must return a CacheRequest object which contains an OutputStream that the protocol handler will use to write the resource into the cache. If the resource is not to be cached, then put must return null.</source>
          <target state="translated">프로토콜 핸들러는 리소스가 검색된 후이 메소드를 호출하며 ResponseCache는 리소스를 캐시에 저장할지 여부를 결정해야합니다. 자원을 캐시하려면 put ()은 프로토콜 핸들러가 자원을 캐시에 쓰는 데 사용할 OutputStream을 포함하는 CacheRequest 객체를 반환해야합니다. 자원이 캐시되지 않으면 put은 널을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="4be2401bbc033d02d77ae8d018dde89f5a6c5180" translate="yes" xml:space="preserve">
          <source>The protocol part of the Service URL.</source>
          <target state="translated">서비스 URL의 프로토콜 부분.</target>
        </trans-unit>
        <trans-unit id="37c5465d2ff8a6fe16f37629d0bc86289e7d279a" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by &lt;code&gt;getSupportedProtocols()&lt;/code&gt; as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 &lt;code&gt;getSupportedProtocols()&lt;/code&gt; 에 의해 지원되는 것으로 나열되어 있어야합니다 . 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceb4dc01f774ca073a268387a29e005c274c187" translate="yes" xml:space="preserve">
          <source>The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the &lt;code&gt;protocols&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">프로토콜은 getSupportedProtocols ()에 의해 지원되는 것으로 나열되어 있어야합니다. 이 메소드를 성공적으로 호출하면 &lt;code&gt;protocols&lt;/code&gt; 매개 변수에 나열된 프로토콜 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b819aa1e87112cebc844a816e2d9cca7e54bfec7" translate="yes" xml:space="preserve">
          <source>The provider package list is a string that is interpreted as a list of non-empty Java package names separated by vertical bars (&lt;code&gt;|&lt;/code&gt;). If the string is empty, then so is the provider package list. If the provider package list is not a String, or if it contains an element that is an empty string, a &lt;a href=&quot;jmxproviderexception&quot;&gt;&lt;code&gt;JMXProviderException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">제공자 패키지 목록은 비어 있지 않은 Java 패키지 이름의 목록으로 해석되는 문자열이며 세로 막대 ( &lt;code&gt;|&lt;/code&gt; )로 구분됩니다 . 문자열이 비어 있으면 공급자 패키지 목록도 비어 있습니다. 프로 바이더 패키지리스트가 String가 아닌 경우, 또는 비어있는 캐릭터 라인의 요소가 포함되어있는 경우, &lt;a href=&quot;jmxproviderexception&quot;&gt; &lt;code&gt;JMXProviderException&lt;/code&gt; &lt;/a&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="81ff5f0c2ed16bdcde6df10f629ec05f4f76b747" translate="yes" xml:space="preserve">
          <source>The provider properties each specify the name and location of a particular service implemented by the provider. By granting this permission, you let code replace the service specification with another one, thereby specifying a different implementation.</source>
          <target state="translated">공급자 속성은 각각 공급자가 구현 한 특정 서비스의 이름과 위치를 지정합니다. 이 권한을 부여하면 코드가 서비스 스펙을 다른 것으로 바꾸도록하여 다른 구현을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfdec86c531152b897fae56fc5431156beb1192" translate="yes" xml:space="preserve">
          <source>The provider relies on a &lt;code&gt;CallbackHandler&lt;/code&gt; to obtain authentication information from the caller (a PIN, for example). If the caller passes a &lt;code&gt;null&lt;/code&gt; handler to this method, the provider uses the handler set in the &lt;code&gt;setCallbackHandler&lt;/code&gt; method. If no handler was set in that method, the provider queries the</source>
          <target state="translated">공급자는 &lt;code&gt;CallbackHandler&lt;/code&gt; 를 사용하여 발신자 (예 : PIN)로부터 인증 정보를 얻습니다. 호출자 가이 메소드에 &lt;code&gt;null&lt;/code&gt; 핸들러를 전달 하면 제공자는 &lt;code&gt;setCallbackHandler&lt;/code&gt; 메소드에 설정된 핸들러를 사용합니다 . 해당 메소드에 핸들러가 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="1c17253044a3e06989e7d90ee41703431073eb01" translate="yes" xml:space="preserve">
          <source>The provider resource file (&lt;code&gt;jndiprovider.properties&lt;/code&gt;) for the context being operated on.</source>
          <target state="translated">작동중인 컨텍스트에 대한 제공자 자원 파일 ( &lt;code&gt;jndiprovider.properties&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e7c1d350031806c332b9c24a137dd3c90b8b811" translate="yes" xml:space="preserve">
          <source>The provider that created this channel</source>
          <target state="translated">이 채널을 만든 제공 업체</target>
        </trans-unit>
        <trans-unit id="77a39cfcc4e9fe4e8ca3afc28026bfc41ca77e69" translate="yes" xml:space="preserve">
          <source>The provider that created this channel group</source>
          <target state="translated">이 채널 그룹을 만든 공급자</target>
        </trans-unit>
        <trans-unit id="bd0273ec6d54c15dbfb4d880d2bc546ddaf6772d" translate="yes" xml:space="preserve">
          <source>The provider that created this file system.</source>
          <target state="translated">이 파일 시스템을 만든 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="e97bc8d34251d21b62200936e722253994322277" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore as a basis for making trust decisions.</source>
          <target state="translated">제공자는 일반적으로 신뢰 결정을 내리기위한 기준으로 KeyStore를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8eb1ab0ca4032f625e2e248a88d341a2ea149e6e" translate="yes" xml:space="preserve">
          <source>The provider typically uses a KeyStore for obtaining key material for use during secure socket negotiations. The KeyStore is generally password-protected.</source>
          <target state="translated">공급자는 일반적으로 보안 소켓 협상 중에 사용할 키 자료를 얻기 위해 KeyStore를 사용합니다. KeyStore는 일반적으로 비밀번호로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ee7c51b3de3d00b80da9b5d57be36f861ae7af" translate="yes" xml:space="preserve">
          <source>The provider uses this handler if one is not passed to the &lt;code&gt;login&lt;/code&gt; method. The provider also uses this handler if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers. In either case if a handler is not set via this method, the provider queries the</source>
          <target state="translated">프로 바이더가 &lt;code&gt;login&lt;/code&gt; 메소드에 전달되지 않으면이 핸들러를 사용합니다 . 공급자는 발신자를 대신하여 &lt;code&gt;login&lt;/code&gt; 을 호출하는 경우에도이 핸들러를 사용합니다 . 두 경우 모두 핸들러가이 메소드를 통해 설정되지 않은 경우 제공자는</target>
        </trans-unit>
        <trans-unit id="6cbb75c3c1cc6c2af9021f9f5e045df931d8ccd5" translate="yes" xml:space="preserve">
          <source>The pseudo-type corresponding to the keyword &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;void&lt;/code&gt; 에 해당하는 의사 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f1c0bbc66bdb6ee141f8f29a8594a0f7f7c26d71" translate="yes" xml:space="preserve">
          <source>The public exponent-value F4 = 65537.</source>
          <target state="translated">공개 지수 값 F4 = 65537.</target>
        </trans-unit>
        <trans-unit id="f26be22251f1ffca01d91cc5cb358dc14cdbbb9d" translate="yes" xml:space="preserve">
          <source>The public key or the signature algorithm has been constrained.</source>
          <target state="translated">공개 키 또는 서명 알고리즘이 제한되었습니다.</target>
        </trans-unit>
        <trans-unit id="c28eb2aa6086a8572e42d5f820ee00606327026e" translate="yes" xml:space="preserve">
          <source>The public methods of all &lt;code&gt;CertStoreSpi&lt;/code&gt; objects must be thread-safe. That is, multiple threads may concurrently invoke these methods on a single &lt;code&gt;CertStoreSpi&lt;/code&gt; object (or more than one) with no ill effects. This allows a &lt;code&gt;CertPathBuilder&lt;/code&gt; to search for a CRL while simultaneously searching for further certificates, for instance.</source>
          <target state="translated">모든 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 의 공개 메소드는 스레드로부터 안전해야합니다. 즉, 여러 스레드가 동시에 단일 &lt;code&gt;CertStoreSpi&lt;/code&gt; 객체 (또는 둘 이상)에서 이러한 효과를 발생시키지 않으면 서 이러한 메서드를 호출 할 수 있습니다 . 이를 통해 &lt;code&gt;CertPathBuilder&lt;/code&gt; 는 예를 들어 추가 인증서를 동시에 검색하면서 CRL을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a02308f567fb58540f6ccefee2675e6a72ad544b" translate="yes" xml:space="preserve">
          <source>The public-exponent value F0 = 3.</source>
          <target state="translated">공개 지수 값 F0 = 3</target>
        </trans-unit>
        <trans-unit id="58212aee8e35283834dfaea45dcaab9b066bc5e9" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all &lt;code&gt;CertStore&lt;/code&gt; parameter specifications. All &lt;code&gt;CertStore&lt;/code&gt; parameter specifications must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 &lt;code&gt;CertStore&lt;/code&gt; 파라미터 사양 을 그룹화 (및 형태 안전성을 제공)하는 것입니다. 모든 &lt;code&gt;CertStore&lt;/code&gt; 매개 변수 스펙은이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f81245615bb3902dc0ddd73189d74b0875c911f" translate="yes" xml:space="preserve">
          <source>The purpose of this interface is to group (and provide type safety for) all certification path validator results. All results returned by the &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt;&lt;code&gt;CertPathValidator.validate&lt;/code&gt;&lt;/a&gt; method must implement this interface.</source>
          <target state="translated">이 인터페이스의 목적은 모든 인증 경로 유효성 검사기 결과를 그룹화하고 형식 안전성을 제공하는 것입니다. &lt;a href=&quot;certpathvalidator#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-&quot;&gt; &lt;code&gt;CertPathValidator.validate&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 모든 결과는 이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f40bfb04d6225f59e5f6ed15eef633d42be0d88d" translate="yes" xml:space="preserve">
          <source>The pushback buffer.</source>
          <target state="translated">푸시 백 버퍼.</target>
        </trans-unit>
        <trans-unit id="c4aab08f812dbdbd1e2f17d2f57df09ad2f9651a" translate="yes" xml:space="preserve">
          <source>The quality of implementation specifications concern two properties, accuracy of the returned result and monotonicity of the method. Accuracy of the floating-point &lt;code&gt;Math&lt;/code&gt; methods is measured in terms of</source>
          <target state="translated">구현 사양의 품질은 반환 된 결과의 정확성과 메서드의 단일성이라는 두 가지 속성과 관련됩니다. 부동 소수점 &lt;code&gt;Math&lt;/code&gt; 방법 의 정확도 는</target>
        </trans-unit>
        <trans-unit id="f5cb0e2e965fe133bfc4b502b0d3bcf943a71b82" translate="yes" xml:space="preserve">
          <source>The quarter-of-year can only be calculated if the month-of-year is available.</source>
          <target state="translated">해당 연도는 해당 월을 사용할 수있는 경우에만 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddac52873ee50d0b150f5774b33d3171bd12498" translate="yes" xml:space="preserve">
          <source>The query can be used as follows:</source>
          <target state="translated">쿼리는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70bb5883a481eb39ca30783c6a7918ebefc04d35" translate="yes" xml:space="preserve">
          <source>The query component of a URI, if defined, only contains legal URI characters.</source>
          <target state="translated">URI의 쿼리 구성 요소는 정의 된 경우 유효한 URI 문자 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e864d8346a749cfdd6a77c410e2c3f6c279670bc" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalDate&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6043cc3fa8c882b0feedaeddf7526a1d1132efc5" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;LocalTime&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b5e706d8394f50472ebf16e28898a8a1e6a58887" translate="yes" xml:space="preserve">
          <source>The query implementation examines the &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; field and uses it to create a &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">쿼리 구현은 &lt;a href=&quot;chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 필드를 검사하고 이를 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b701fffe515ad54c8901b8edcc958e95fc0863c4" translate="yes" xml:space="preserve">
          <source>The quotes surrounding a quoted value, and any backslashes within that value, are considered to be part of the value.</source>
          <target state="translated">따옴표로 묶은 따옴표와 해당 값 내의 백 슬래시는 값의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a7d974dd7e85a61e651a1f194908d0947c9c72a3" translate="yes" xml:space="preserve">
          <source>The radix is either smaller than &lt;a href=&quot;character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or larger than &lt;a href=&quot;character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수는 하나보다 작은 &lt;a href=&quot;character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; 보다 작거나 큰 &lt;a href=&quot;character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aff07d7777d5b73265b5ea3b6fd0d12004a2b97" translate="yes" xml:space="preserve">
          <source>The range is never null. For example, the 'Year' field is shorthand for 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.</source>
          <target state="translated">범위는 null이 아닙니다. 예를 들어 'Year'필드는 'YearOfForever'의 줄임말입니다. 따라서 '년'단위와 '영원히'범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c3676b410b66174f1db5ce3adf03537f612813" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜는 반환 범위의 정확성을 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 인해 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3be0f1078a3bff28a13de38bf87eb44d5f6cfd7c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This date-time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 날짜-시간은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91574718820af02ba334ca5d2fcaa8ec6eaea0fc" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This day-of-week is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 요일은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49564c5fdd906eee0231c2e097092a4591ff74b8" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This era is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시대는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7949501ac98f64cd52d82177d9b4791e0d319f3" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This instant is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 순간은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a75a30588e66efcb4e03e0edc195ee3a6dc4a14" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e107332e6198f288dc13a1a398312820086bba7b" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This month-day is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 달은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="014329a030e2ab6f6b560564601eb56834e5e981" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This offset is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 오프셋은 반환 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8e7e158ec4085c5caa0000a57a4cf2e6742dd0c" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This time is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 이 시간은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="735932a1888a19dccb3e713207eb70618d6c1110" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해는 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="461a26e4d72a556581a55b26af7476b03a89d671" translate="yes" xml:space="preserve">
          <source>The range object expresses the minimum and maximum valid values for a field. This year-month is used to enhance the accuracy of the returned range. If it is not possible to return the range, because the field is not supported or for some other reason, an exception is thrown.</source>
          <target state="translated">범위 객체는 필드의 최소 및 최대 유효 값을 나타냅니다. 올해의 월은 반환 범위의 정확도를 높이는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85b6f271b8e9dbcfec00b32e847d50024b09f127" translate="yes" xml:space="preserve">
          <source>The range of a duration requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The model is of a directed duration, meaning that the duration may be negative.</source>
          <target state="translated">기간의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초와 나노초를 나타내는 &lt;code&gt;int&lt;/code&gt; 를 저장하며 , 항상 0에서 999,999,999 사이입니다. 모델의 지속 시간은 지속 시간이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32e38d37e14ca58b0618d587028515e73e2533f4" translate="yes" xml:space="preserve">
          <source>The range of an instant requires the storage of a number larger than a &lt;code&gt;long&lt;/code&gt;. To achieve this, the class stores a &lt;code&gt;long&lt;/code&gt; representing epoch-seconds and an &lt;code&gt;int&lt;/code&gt; representing nanosecond-of-second, which will always be between 0 and 999,999,999. The epoch-seconds are measured from the standard Java epoch of &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; where instants after the epoch have positive values, and earlier instants have negative values. For both the epoch-second and nanosecond parts, a larger value is always later on the time-line than a smaller value.</source>
          <target state="translated">인스턴트의 범위에는 &lt;code&gt;long&lt;/code&gt; 보다 큰 수의 저장이 필요합니다 . 이를 달성하기 위해 클래스는 &lt;code&gt;long&lt;/code&gt; 을 나타내는 초 (epoch-seconds)와 &lt;code&gt;int&lt;/code&gt; ( 초)를 나타내며, 항상 0에서 999,999,999 사이입니다. 신기원 초는 신기원 이후의 순간은 양수 값을 가지며 초기 순간은 음수 값 을 갖는 표준 Java 신기원 &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; 에서 측정 됩니다. 에포크 초 및 나노초 부분 모두에 대해, 더 큰 값은 항상 더 작은 값보다 타임 라인에서 늦습니다.</target>
        </trans-unit>
        <trans-unit id="679d54d91b72b6e361f360707cfcab80ec107617" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;TemporalField.getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d54476f03a91c05aa619016f50c3163119ec639" translate="yes" xml:space="preserve">
          <source>The range of the field is the period that the field varies within. For example, in the field 'MonthOfYear', the range is 'Years'. See also &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt;&lt;code&gt;getBaseUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 범위는 필드가 변하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 범위는 'Years'입니다. &lt;a href=&quot;temporalfield#getBaseUnit--&quot;&gt; &lt;code&gt;getBaseUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb9262661e91ed7bef2f4dcc6a38ba0c83ed604f" translate="yes" xml:space="preserve">
          <source>The range of valid Japanese eras can change over time due to the nature of the Japanese calendar system.</source>
          <target state="translated">유효한 일본 시대의 범위는 일본 달력 시스템의 특성으로 인해 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bed82254a2488e57b5e72ee8db8066e750b8a42" translate="yes" xml:space="preserve">
          <source>The range of valid values for a date-time field.</source>
          <target state="translated">날짜-시간 필드에 유효한 값의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="f74c7503d6071b30c8c61a8b75f2f1ec45dd13e0" translate="yes" xml:space="preserve">
          <source>The raw authority component of this URI, or &lt;code&gt;null&lt;/code&gt; if the authority is undefined</source>
          <target state="translated">이 URI의 원시 권한 컴퍼넌트. 또는 권한이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0f93a7d9b2a593cc73021049a4babe847f8e5a" translate="yes" xml:space="preserve">
          <source>The raw fragment component of this URI, or &lt;code&gt;null&lt;/code&gt; if the fragment is undefined</source>
          <target state="translated">이 URI의 raw fragment 컴퍼넌트 . 프래그먼트가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08a189753abac31378f32795de3236540870ae3b" translate="yes" xml:space="preserve">
          <source>The raw query component of this URI, or &lt;code&gt;null&lt;/code&gt; if the query is undefined</source>
          <target state="translated">이 URI의 원시 쿼리 컴퍼넌트 . 쿼리가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05172f64d4d3b180d734e94e231efb1e5ba69223" translate="yes" xml:space="preserve">
          <source>The raw scheme-specific part of this URI (never &lt;code&gt;null&lt;/code&gt;)</source>
          <target state="translated">이 URI의 미가공 스킴 특정 부분 ( &lt;code&gt;null&lt;/code&gt; 은 아님)</target>
        </trans-unit>
        <trans-unit id="5e87c817a622606571e558fb125257b7d14ba713" translate="yes" xml:space="preserve">
          <source>The raw user-information component of this URI, or &lt;code&gt;null&lt;/code&gt; if the user information is undefined</source>
          <target state="translated">이 URI의 원시의 사용자 정보 컴퍼넌트 . 사용자 정보가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f41303d8fd6ce5aa0821756418e069b981b7b161" translate="yes" xml:space="preserve">
          <source>The read end of a pipe</source>
          <target state="translated">파이프의 읽기 끝</target>
        </trans-unit>
        <trans-unit id="2f625a725ca986b919f09071c8736ca180edd0b0" translate="yes" xml:space="preserve">
          <source>The read lock and write lock both support interruption during lock acquisition.</source>
          <target state="translated">읽기 잠금 및 쓰기 잠금은 잠금 획득 중 중단을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1910ace8ec568ce21c0234fca6b9fc966c9cfd9a" translate="yes" xml:space="preserve">
          <source>The read lock does not support a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;readLock().newCondition()&lt;/code&gt; throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">읽기 잠금 장치가 지원하지 않는 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;readLock().newCondition()&lt;/code&gt; 발생 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가가 .</target>
        </trans-unit>
        <trans-unit id="2ef8ece400c68c93f9421b6ba44a9c57dd5cbaa4" translate="yes" xml:space="preserve">
          <source>The read lock is acquired by the current thread; or</source>
          <target state="translated">읽기 잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="c9ea905530375593b0c66214e6790341afceb692" translate="yes" xml:space="preserve">
          <source>The read operation may read up to</source>
          <target state="translated">읽기 작업은 최대</target>
        </trans-unit>
        <trans-unit id="2865a10b019911b5946864d5522b0a72162698af" translate="yes" xml:space="preserve">
          <source>The read position of the input stream is positioned to the next available byte after the encoded distinguished name.</source>
          <target state="translated">입력 스트림의 읽기 위치는 인코딩 된 식별 이름 다음에 사용 가능한 다음 바이트에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="634db75a4e5ec4659af37c3e0e8afa693c0276b7" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading and restoring the state of the object for its particular class using data written to the stream by the corresponding writeObject method. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput.</source>
          <target state="translated">readObject 메소드는 해당 writeObject 메소드로 스트림에 기록 된 데이터를 사용하여 특정 클래스의 오브젝트 상태를 읽고 복원합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. 개별 필드에 대한 ObjectInputStream에서 데이터를 읽고 오브젝트의 해당 필드에 지정하여 상태를 복원합니다. 기본 데이터 유형 읽기는 DataInput에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d20e6c840d9627a8eaa7891d9565907ed4a7abbb" translate="yes" xml:space="preserve">
          <source>The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">readObject 메소드는 스트림에서 읽고 클래스 필드를 복원합니다. 객체의 비 정적 및 비 일시적 필드를 복원하기위한 기본 메커니즘을 호출하기 위해 in.defaultReadObject를 호출 할 수 있습니다. defaultReadObject 메소드는 스트림의 정보를 사용하여 스트림에 저장된 오브젝트의 필드를 현재 오브젝트의 해당 이름이 지정된 필드에 지정합니다. 이것은 클래스가 새로운 필드를 추가하도록 진화 한 경우를 처리합니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput이 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a89c7b63eeec0e71ccea53ce7c51271148781b8" translate="yes" xml:space="preserve">
          <source>The readObjectNoData method is responsible for initializing the state of the object for its particular class in the event that the serialization stream does not list the given class as a superclass of the object being deserialized. This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version. This may also occur if the serialization stream has been tampered; hence, readObjectNoData is useful for initializing deserialized objects properly despite a &quot;hostile&quot; or incomplete source stream.</source>
          <target state="translated">readObjectNoData 메소드는 직렬화 스트림이 지정된 클래스를 직렬화 해제중인 오브젝트의 수퍼 클래스로 나열하지 않는 경우 특정 클래스의 오브젝트 상태를 초기화합니다. 이는 수신 측이 전송 측과 다른 버전의 직렬화 해제 인스턴스 클래스를 사용하고 수신자의 버전이 송신자 버전이 확장하지 않은 클래스를 확장하는 경우에 발생할 수 있습니다. 직렬화 스트림이 변조 된 경우에도 발생할 수 있습니다. 따라서 readObjectNoData는 &quot;적대적&quot;또는 불완전한 소스 스트림에도 불구하고 역 직렬화 된 객체를 올바르게 초기화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f02ead4cd4d703a4fc4aec1b89640970265ef72c" translate="yes" xml:space="preserve">
          <source>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers. It reads and verifies the magic number and version number.</source>
          <target state="translated">readStreamHeader 메소드는 서브 클래스가 자체 스트림 헤더를 읽고 확인할 수 있도록 제공됩니다. 마법 번호와 버전 번호를 읽고 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b8970b91121ef6350ebd73016d3cfaeca16ee503" translate="yes" xml:space="preserve">
          <source>The reader associated with this console</source>
          <target state="translated">이 콘솔과 관련된 독자</target>
        </trans-unit>
        <trans-unit id="6c69219580471766868b9f3ba0f7605623a45c33" translate="yes" xml:space="preserve">
          <source>The reader must not be operated on during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">터미널 스트림 작업을 실행하는 동안 리더를 작동시키지 않아야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9d32ae3ca8a166a78d846fc7aad0c5b1d696a11" translate="yes" xml:space="preserve">
          <source>The reason string</source>
          <target state="translated">이유 문자열</target>
        </trans-unit>
        <trans-unit id="343e073c1a04a45f15bfaa37758a836c0b9ae1dd" translate="yes" xml:space="preserve">
          <source>The reason that listeners created with &lt;code&gt;EventHandler&lt;/code&gt; have such a small footprint is that the &lt;code&gt;Proxy&lt;/code&gt; class, on which the &lt;code&gt;EventHandler&lt;/code&gt; relies, shares implementations of identical interfaces. For example, if you use the &lt;code&gt;EventHandler&lt;/code&gt;&lt;code&gt;create&lt;/code&gt; methods to make all the &lt;code&gt;ActionListener&lt;/code&gt;s in an application, all the action listeners will be instances of a single class (one created by the &lt;code&gt;Proxy&lt;/code&gt; class). In general, listeners based on the &lt;code&gt;Proxy&lt;/code&gt; class require one listener class to be created per &lt;em&gt;listener type&lt;/em&gt; (interface), whereas the inner class approach requires one class to be created per &lt;em&gt;listener&lt;/em&gt; (object that implements the interface).</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 로 작성된 리스너의 공간이 작은 이유 는 &lt;code&gt;EventHandler&lt;/code&gt; 가 의존 하는 &lt;code&gt;Proxy&lt;/code&gt; 클래스 가 동일한 인터페이스의 구현을 공유하기 때문입니다. 예를 들어, &lt;code&gt;EventHandler&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; 메소드를 사용 하여 애플리케이션에서 모든 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성 하는 경우 모든 조치 리스너는 단일 클래스 ( &lt;code&gt;Proxy&lt;/code&gt; 클래스에 의해 작성된 것)의 인스턴스가 됩니다. 일반적으로 &lt;code&gt;Proxy&lt;/code&gt; 클래스를 기반으로하는 리스너는 &lt;em&gt;리스너 유형&lt;/em&gt; (인터페이스) 당 하나의 리스너 클래스를 작성 해야하지만 내부 클래스 접근 방식은 &lt;em&gt;리스너&lt;/em&gt; 당 하나의 클래스를 작성해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; (인터페이스를 구현하는 객체).</target>
        </trans-unit>
        <trans-unit id="4bcf2d174d6450c449f0d4b03a4ca6b52b25a266" translate="yes" xml:space="preserve">
          <source>The reason the validation algorithm failed.</source>
          <target state="translated">유효성 검증 알고리즘이 실패한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="fad799b782c71b721e74eb716a062272a08611cd" translate="yes" xml:space="preserve">
          <source>The reason to deny access can vary. For example, the requested permission might be of an incorrect type, contain an invalid value, or request access that is not allowed according to the security policy. Such information should be given whenever possible at the time the exception is thrown.</source>
          <target state="translated">액세스를 거부하는 이유는 다양 할 수 있습니다. 예를 들어 요청 된 권한의 유형이 잘못되었거나 유효하지 않은 값을 포함하거나 보안 정책에 따라 허용되지 않은 요청 액세스가있을 수 있습니다. 그러한 정보는 예외가 발생했을 때 가능할 때마다 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b540068386b3455f296a75095372235296b6e2b" translate="yes" xml:space="preserve">
          <source>The recommended usage is to use &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; to identify resources, then convert it into a &lt;a href=&quot;url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; when it is time to access the resource. From that URL, you can either get the &lt;a href=&quot;urlconnection&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt; for fine control, or get directly the InputStream.</source>
          <target state="translated">권장되는 사용법은 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자원을 식별 한 다음 자원 에 액세스 할 때 &lt;a href=&quot;url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 로 변환하는 것입니다. 해당 URL에서 세부 제어를 위해 &lt;a href=&quot;urlconnection&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; &lt;/a&gt; 을 가져 오거나 InputStream을 직접 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02d456a5b72dc15bc50cf4cbcbe8e2427ba00e2" translate="yes" xml:space="preserve">
          <source>The rectangular printable area is defined thus: The (x,y) origin is positioned at the top-left of the paper in portrait mode regardless of the orientation specified in the requesting context. For example a printable area for A4 paper in portrait or landscape orientation will have height &amp;gt; width.</source>
          <target state="translated">직사각형 인쇄 가능 영역은 다음과 같이 정의됩니다. (x, y) 원점은 요청 컨텍스트에 지정된 방향에 관계없이 세로 모드에서 용지의 왼쪽 상단에 배치됩니다. 예를 들어 세로 또는 가로 방향의 A4 용지의 인쇄 가능 영역은 높이&amp;gt; 너비를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6cf742cf21d433441fd0b0bc61621152f8db92ae" translate="yes" xml:space="preserve">
          <source>The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재정의는 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재정의는 필드 나 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6f19c83b6a43c97e8d1cefd627e0b3c8dadfded2" translate="yes" xml:space="preserve">
          <source>The reference &lt;code&gt;x&lt;/code&gt; must be convertible to the first parameter type of the target.</source>
          <target state="translated">참조 &lt;code&gt;x&lt;/code&gt; 는 대상의 첫 번째 매개 변수 유형으로 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c96b6a18efdd8f02c853b851fa382edd202cc59" translate="yes" xml:space="preserve">
          <source>The reference is parsed into the scheme, authority, path, query and fragment parts. If the path component is empty and the scheme, authority, and query components are undefined, then the new URL is a reference to the current document. Otherwise, the fragment and query parts present in the spec are used in the new URL.</source>
          <target state="translated">참조는 체계, 권한, 경로, 쿼리 및 조각 부분으로 구문 분석됩니다. 경로 구성 요소가 비어 있고 구성표, 권한 및 조회 구성 요소가 정의되지 않은 경우 새 URL은 현재 문서에 대한 참조입니다. 그렇지 않으면 사양에있는 조각 및 쿼리 부분이 새 URL에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27a0672b9281e7b40b24731935d7c4c815d57f66" translate="yes" xml:space="preserve">
          <source>The referral context is created using &lt;code&gt;env&lt;/code&gt; as its environment properties. This method should be used instead of the no-arg overloaded form when the caller needs to use different environment properties for the referral context. It might need to do this, for example, when it needs to supply different authentication information to the referred server in order to create the referral context.</source>
          <target state="translated">참조 컨텍스트는 환경 특성으로 &lt;code&gt;env&lt;/code&gt; 를 사용하여 작성 됩니다. 호출자가 참조 컨텍스트에 대해 다른 환경 속성을 사용해야하는 경우 인수가없는 오버로드 된 양식 대신이 메소드를 사용해야합니다. 예를 들어, 참조 컨텍스트를 작성하기 위해 참조 된 서버에 다른 인증 정보를 제공해야하는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0ee23ed794b80c251d3a1fe843993862775ce5a" translate="yes" xml:space="preserve">
          <source>The region of the image to be written is determined by first intersecting the actual bounds of the image with the rectangle specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any. If the resulting rectangle has a width or height of zero, the writer will throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is non-empty, writing will commence with the first subsampled pixel and include additional pixels within the intersected bounds according to the horizontal and vertical subsampling factors specified by &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기록 될 이미지의 영역은 이미지의 실제 경계를 &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt; 에 의해 지정된 사각형 (있는 경우)과 먼저 교차시킴으로써 결정됩니다 . 결과 사각형의 너비 또는 높이가 0이면 작성기는 &lt;code&gt;IIOException&lt;/code&gt; 을 발생 시킵니다. 교차점이 비어 있지 않으면 쓰기는 첫 번째 서브 샘플링 된 픽셀로 시작하고 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 의해 지정된 수평 및 수직 서브 샘플링 요소에 따라 교차 된 경계 내에 추가 픽셀을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="412cd087a882e3390f6eb99cb3444e0f99865817" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The two-argument &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. If a lock that overlaps the requested region is already held by this Java virtual machine, or this method has been invoked to lock an overlapping region and that operation has not completed, then this method throws &lt;a href=&quot;overlappingfilelockexception&quot;&gt;&lt;code&gt;OverlappingFileLockException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 2 인수 &lt;a href=&quot;asynchronousfilechannel#lock-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;lock(Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다.. 요청 된 영역과 겹치는 잠금이이 Java 가상 머신에 의해 이미 보유되어 있거나 겹치는 영역을 잠그기 위해이 메소드가 호출되었고 조작이 완료되지 않은 경우이 메소드는 &lt;a href=&quot;overlappingfilelockexception&quot;&gt; &lt;code&gt;OverlappingFileLockException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="813d5453cbb41f59eb6e5e97b38357b9ea00bdde" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#lock--&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#lock--&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="617ac4e34e018358f5e81a33f698a400aa0685af" translate="yes" xml:space="preserve">
          <source>The region specified by the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; parameters need not be contained within, or even overlap, the actual underlying file. Lock regions are fixed in size; if a locked region initially contains the end of the file and the file grows beyond the region then the new portion of the file will not be covered by the lock. If a file is expected to grow in size and a lock on the entire file is required then a region starting at zero, and no smaller than the expected maximum size of the file, should be locked. The zero-argument &lt;a href=&quot;filechannel#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method simply locks a region of size &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt;&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 매개 변수로 지정된 영역 이 실제 기본 파일 내에 포함되거나 중첩 될 필요는 없습니다. 잠금 영역은 크기가 고정되어 있습니다. 잠긴 영역에 처음에 파일의 끝이 포함되어 있고 파일이 영역을 넘어 확장되면 파일의 새 부분이 잠금에 포함되지 않습니다. 파일 크기가 커지고 전체 파일에 대한 잠금이 필요한 경우 파일의 예상 최대 크기보다 작지 않은 0에서 시작하는 영역을 잠 가야합니다. 인수가 0 인 &lt;a href=&quot;filechannel#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드는 단순히 &lt;a href=&quot;../../lang/long#MAX_VALUE&quot;&gt; &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 크기의 영역을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="3d0fc73493ecda447bb85c445c6e4f953b759f7f" translate="yes" xml:space="preserve">
          <source>The registration/deregistration methods accept an instance of &lt;code&gt;NamingListener&lt;/code&gt;. There are subinterfaces of &lt;code&gt;NamingListener&lt;/code&gt; for different of event types of &lt;code&gt;NamingEvent&lt;/code&gt;. For example, the &lt;code&gt;ObjectChangeListener&lt;/code&gt; interface is for the &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; event type. To register interest in multiple event types, the listener implementation should implement multiple &lt;code&gt;NamingListener&lt;/code&gt; subinterfaces and use a single invocation of &lt;code&gt;addNamingListener()&lt;/code&gt;. In addition to reducing the number of method calls and possibly the code size of the listeners, this allows some service providers to optimize the registration.</source>
          <target state="translated">등록 / 파기 메소드는 &lt;code&gt;NamingListener&lt;/code&gt; 의 인스턴스를 받아들 입니다. &lt;code&gt;NamingEvent&lt;/code&gt; 의 다른 이벤트 타입에 대한 &lt;code&gt;NamingListener&lt;/code&gt; 의 서브 인터페이스가 있습니다 . 예를 들어, &lt;code&gt;ObjectChangeListener&lt;/code&gt; 인터페이스는 &lt;code&gt;NamingEvent.OBJECT_CHANGED&lt;/code&gt; 이벤트 유형에 대한 것입니다. 여러 이벤트 유형에 관심을 등록하려면 리스너 구현에서 여러 &lt;code&gt;NamingListener&lt;/code&gt; 서브 인터페이스를 구현 하고 &lt;code&gt;addNamingListener()&lt;/code&gt; 의 단일 호출을 사용해야합니다 . 메소드 호출 수와 리스너의 코드 크기를 줄이는 것 외에도 일부 서비스 제공 업체는 등록을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b28ceb290f94f79d557bc3e4312d5d5404a206" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;.&lt;/code&gt; matches any character except a line terminator unless the &lt;a href=&quot;pattern#DOTALL&quot;&gt;&lt;code&gt;DOTALL&lt;/code&gt;&lt;/a&gt; flag is specified.</source>
          <target state="translated">정규식 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;pattern#DOTALL&quot;&gt; &lt;code&gt;DOTALL&lt;/code&gt; &lt;/a&gt; 플래그가 지정 되지 않은 경우 줄 종결자를 제외한 모든 문자와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6e4b1af8982753fca149df2aa7452224b647d528" translate="yes" xml:space="preserve">
          <source>The relation objects of that type will be removed from the Relation Service.</source>
          <target state="translated">해당 유형의 관계 개체는 관계 서비스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="aa44fb4b73ba3a7eb0fa699a55544e1d6fb4e2cf" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;floorDiv&lt;/code&gt; and &lt;code&gt;floorMod&lt;/code&gt; is such that:</source>
          <target state="translated">&lt;code&gt;floorDiv&lt;/code&gt; 와 &lt;code&gt;floorMod&lt;/code&gt; 의 관계는 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1d34477c420fd977fd8f945aedd832fb3f7c9dfd" translate="yes" xml:space="preserve">
          <source>The relative URL need not specify all the components of a URL. If the protocol, host name, or port number is missing, the value is inherited from the fully specified URL. The file component must be specified. The optional fragment is not inherited.</source>
          <target state="translated">상대 URL은 URL의 모든 구성 요소를 지정할 필요는 없습니다. 프로토콜, 호스트 이름 또는 포트 번호가 누락되면 값은 완전히 지정된 URL에서 상속됩니다. 파일 구성 요소를 지정해야합니다. 선택적 조각은 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5c5f181f6e29a7276bf6337e3a4edd8b847077a" translate="yes" xml:space="preserve">
          <source>The relativization of the given URI against this URI is computed as follows:</source>
          <target state="translated">이 URI에 대한 지정된 URI의 상대 성화는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e707cc2158f347f5aab8350d2339ff22d2e3b87b" translate="yes" xml:space="preserve">
          <source>The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends &lt;code&gt;Proxy&lt;/code&gt;.</source>
          <target state="translated">이 방법의 안정성은 보안 결정을 내리는 데 사용하기에 중요하므로 구현시 해당 클래스가 &lt;code&gt;Proxy&lt;/code&gt; 를 확장하는지 테스트하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b7ae0cdf8ad17c67c6a33deb5e3ca85d6e010c4" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="e82e7847d0c5f7329094a894a4727d5cc71d2c00" translate="yes" xml:space="preserve">
          <source>The remainder is given by &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor,
 mc).multiply(divisor))&lt;/code&gt;. Note that this is not the modulo operation (the result can be negative).</source>
          <target state="translated">나머지는 &lt;code&gt;this.subtract(this.divideToIntegralValue(divisor, mc).multiply(divisor))&lt;/code&gt; 됩니다. 이것은 모듈로 연산이 아닙니다 (결과는 음수 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="47da9e589f25b7bfcd11328b7b51fd360a0d60ec" translate="yes" xml:space="preserve">
          <source>The remaining SPI methods &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt; have more complicated exception behavior. They are not specified to throw &lt;code&gt;BackingStoreException&lt;/code&gt;, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to &lt;a href=&quot;preferences#flush--&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;preferences#sync--&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;. Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, all subsequent invocations of &lt;code&gt;flush()&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;, as returning &lt;code&gt;true&lt;/code&gt; would imply that all previous operations had successfully been made permanent.</source>
          <target state="translated">나머지 SPI 메소드 &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt; 에는 더 복잡한 예외 동작이 있습니다. &lt;code&gt;BackingStoreException&lt;/code&gt; 을 던지도록 지정되어 있지 않습니다. 일반적으로 백업 저장소를 사용할 수없는 경우에도 계약을 따를 수 있습니다. 이는 정보를 반환하지 않으며, &lt;a href=&quot;preferences#flush--&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;preferences#sync--&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; &lt;/a&gt; 대한 후속 호출까지 그 효과가 영구적이 될 필요가 없기 때문에 사실입니다.. 일반적으로 이러한 SPI 메소드는 예외를 발생시키지 않아야합니다. 일부 구현들에서, 이러한 호출들이 추후 처리를 위해 요청 된 동작을 큐에 넣을 수없는 상황이있을 수있다. 이러한 상황에서도 일반적으로 예외를 던지기보다는 단순히 호출과 반환을 무시하는 것이 좋습니다. 그러나 이러한 상황에서 &lt;code&gt;flush()&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 의 모든 후속 호출은 &lt;code&gt;false&lt;/code&gt; 를 리턴해야합니다. &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 이전의 모든 조작이 모두 영구적으로 완료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="04a436b0f38850e482765bfe8b244ada2271191c" translate="yes" xml:space="preserve">
          <source>The remaining characters of the result represent the magnitude of the first argument. If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character. The following ASCII characters are used as digits:</source>
          <target state="translated">결과의 나머지 문자는 첫 번째 인수의 크기를 나타냅니다. 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 ASCII 문자는 숫자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b031f20190ca11166d6c7b1f498a8021f1fd8160" translate="yes" xml:space="preserve">
          <source>The remaining details of the &lt;code&gt;MBeanInfo&lt;/code&gt; for a Standard MBean are not specified. This includes the description of any contained constructors, and notifications; the names of parameters to constructors and operations; and the descriptions of constructor parameters.</source>
          <target state="translated">표준 MBean 에 대한 &lt;code&gt;MBeanInfo&lt;/code&gt; 의 나머지 세부 사항이 지정되지 않았습니다. 여기에는 포함 된 생성자에 대한 설명 및 알림이 포함됩니다. 생성자와 오퍼레이션에 대한 매개 변수 이름; 생성자 매개 변수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="c7f4b12e2049eb0d2dbae4e0935da9f089467437" translate="yes" xml:space="preserve">
          <source>The remaining unresolved portion of the name. Cannot be null but empty OK.</source>
          <target state="translated">이름의 나머지 해결되지 않은 부분. null 일 수는 없지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc31c724cb4c9ebbaec1ed20f6acbd3909843172" translate="yes" xml:space="preserve">
          <source>The remote address; &lt;code&gt;null&lt;/code&gt; if the channel's socket is not connected</source>
          <target state="translated">원격 주소 채널의 소켓이 접속되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e7bc56b939ee7935299e6e6d043373f7df2f25b" translate="yes" xml:space="preserve">
          <source>The remote object becomes available. The header fields and the contents of the remote object can be accessed.</source>
          <target state="translated">원격 객체를 사용할 수있게됩니다. 원격 객체의 헤더 필드와 내용에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e100a0f6c2f94294ad6e3cd0c330ac89e4c13e0" translate="yes" xml:space="preserve">
          <source>The removal is not guaranteed to be persistent until the &lt;code&gt;flush&lt;/code&gt; method is called on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 제거가 지속되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a80e61fbbbe10c51d6c88507a5031484ad5e8f17" translate="yes" xml:space="preserve">
          <source>The removal may or may not cause a reduction in the actual file size.</source>
          <target state="translated">제거하면 실제 파일 크기가 줄어들거나 줄어들지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d723447722497695e77f4caccb3c9a5c643a12a5" translate="yes" xml:space="preserve">
          <source>The removal of a node needn't become persistent until the &lt;code&gt;flush&lt;/code&gt; method is invoked on this node (or an ancestor).</source>
          <target state="translated">이 노드 (또는 상위 노드) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 노드 제거가 지속될 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b282c26f23a8ff63876d094fed5b0b9dceb07331" translate="yes" xml:space="preserve">
          <source>The remove operation is not supported by this implementation of &lt;code&gt;Iterator&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Iterator&lt;/code&gt; 구현에서는 remove 오퍼레이션이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4efa145e520c4a7598346c393df2dbbefdc968" translate="yes" xml:space="preserve">
          <source>The removed value.</source>
          <target state="translated">제거 된 값.</target>
        </trans-unit>
        <trans-unit id="7ee9a68c9011522398b40024ebeb43b4a5fda590" translate="yes" xml:space="preserve">
          <source>The reordering array need not specify an actual permutation. An incoming argument will be duplicated if its index appears more than once in the array, and an incoming argument will be dropped if its index does not appear in the array. As in the case of &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt;&lt;code&gt;dropArguments&lt;/code&gt;&lt;/a&gt;, incoming arguments which are not mentioned in the reordering array are may be any type, as determined only by &lt;code&gt;newType&lt;/code&gt;.</source>
          <target state="translated">재정렬 배열은 실제 순열을 지정할 필요가 없습니다. 인덱스가 배열에 두 번 이상 나타나면 들어오는 인수가 복제되고 인덱스가 배열에 나타나지 않으면 들어오는 인수가 삭제됩니다. &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt; &lt;code&gt;dropArguments&lt;/code&gt; &lt;/a&gt; 의 경우와 같이 , 재정렬 배열에서 언급되지 않은 들어오는 인수는 &lt;code&gt;newType&lt;/code&gt; 에 의해서만 결정되는 모든 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11b366ce3d5519585e67264e9f68f215e953b69e" translate="yes" xml:space="preserve">
          <source>The replacement string may contain references to subsequences captured during the previous match: Each occurrence of &lt;code&gt;${&lt;/code&gt;</source>
          <target state="translated">대체 문자열에는 이전 일치 중 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다. 각 &lt;code&gt;${&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b778106af4a2d34f18fd72da9905b02ac996017" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Double.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Double.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="58244bdf257d357f8d92e2421ad210e0d7962bd1" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Float.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Float.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="ded2585e0b6c084c04a4f0859a53141f76d123ae" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Integer.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Integer.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="6aab087f6a2f2da33d64c153ee96c99fa034a1e7" translate="yes" xml:space="preserve">
          <source>The representation is exactly the one returned by the &lt;code&gt;Long.toString&lt;/code&gt; method of one argument.</source>
          <target state="translated">표현은 정확히 하나의 인수 의 &lt;code&gt;Long.toString&lt;/code&gt; 메소드에 의해 리턴되는 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="0d60a9c0e70768f0432c0076bb2b850f773e5a83" translate="yes" xml:space="preserve">
          <source>The request controls supplied to the initial context constructor are &lt;em&gt;not&lt;/em&gt; used as the context request controls for subsequent context operations such as searches and lookups. Context request controls are set and updated by using &lt;code&gt;setRequestControls()&lt;/code&gt;.</source>
          <target state="translated">초기 컨텍스트 생성자에 제공된 요청 컨트롤은 검색 및 조회와 같은 후속 컨텍스트 작업에 대한 컨텍스트 요청 컨트롤로 사용 &lt;em&gt;되지 않습니다&lt;/em&gt; . 컨텍스트 요청 컨트롤은 &lt;code&gt;setRequestControls()&lt;/code&gt; 를 사용하여 설정 및 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c538826a3a1f2f420e3436c5b667643e5f793cd" translate="yes" xml:space="preserve">
          <source>The request-host is a HDN (not IP address) and has the form HD, where D is the value of the Domain attribute, and H is a string that contains one or more dots.</source>
          <target state="translated">요청 호스트는 IP 주소가 아닌 HDN이며 HD 형식입니다. 여기서 D는 도메인 속성 값이고 H는 하나 이상의 점이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a57362ff710e86a82bac45526ef9e2b2169857b3" translate="yes" xml:space="preserve">
          <source>The requested &lt;code&gt;Locale&lt;/code&gt; may contain an &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt; extension&lt;/a&gt; for specifying the desired numbering system. For example, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (in the BCP 47 language tag form) specifies Arabic with the Arabic-Indic digits and symbols, while &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; specifies Arabic with the Latin digits and symbols. Refer to the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification for numbering systems.</source>
          <target state="translated">요청 된 &lt;code&gt;Locale&lt;/code&gt; 에는 원하는 번호 시스템을 지정하기 위한 &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;확장자&lt;/a&gt; 가 포함될 수 있습니다 . 예를 들어, &lt;code&gt;&quot;ar-u-nu-arab&quot;&lt;/code&gt; (BCP 47 언어 태그 형식)은 아랍어-인도 숫자 및 기호로 아랍어를 지정하고 &lt;code&gt;&quot;ar-u-nu-latn&quot;&lt;/code&gt; 은 라틴 숫자 및 기호로 아랍어를 지정합니다. . 번호 시스템에 대해서는 &lt;em&gt;LDML (Unicode Locale Data Markup Language)&lt;/em&gt; 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4313d8db2408961b8c6e4e788b166da71d191f7" translate="yes" xml:space="preserve">
          <source>The requested coder-result object</source>
          <target state="translated">요청 된 코더 결과 객체</target>
        </trans-unit>
        <trans-unit id="248e76eb2ee596cc71b6a4da144a1ff22287b387" translate="yes" xml:space="preserve">
          <source>The requested type must have a return type of &lt;code&gt;void&lt;/code&gt;. (This is consistent with the JVM's treatment of constructor type descriptors.)</source>
          <target state="translated">요청 된 유형의 반환 유형은 &lt;code&gt;void&lt;/code&gt; 입니다. (이것은 JVM이 생성자 유형 설명자를 처리하는 것과 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="516805460907e538d55b063de2a7d8a474251df4" translate="yes" xml:space="preserve">
          <source>The requester has canceled the job or the printer has aborted the job, but the printer is still performing some actions on the job until a specified stop point occurs or job termination/cleanup is completed.</source>
          <target state="translated">요청자가 작업을 취소했거나 프린터가 작업을 중단했지만 지정된 중지 지점이 발생하거나 작업 종료 / 정리가 완료 될 때까지 프린터는 여전히 작업에 대해 일부 작업을 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f22f6979881830731d65c0765a1fe0d7c814e17" translate="yes" xml:space="preserve">
          <source>The required</source>
          <target state="translated">필요한</target>
        </trans-unit>
        <trans-unit id="745e1e490c53f8464a11eebd65e0f35408648502" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;hashCode&lt;/code&gt; behavior for Permission Objects is the following:</source>
          <target state="translated">권한 객체에 필요한 &lt;code&gt;hashCode&lt;/code&gt; 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55d02efa54b09ebdcdd937fdc51b7ffc1d272c16" translate="yes" xml:space="preserve">
          <source>The requirement of lookup object matching provides a &quot;fast fail&quot; behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt;&lt;/a&gt; to override this limitation.</source>
          <target state="translated">조회 오브젝트 일치 요구 사항은 예상치 못한 범위의 기호 정보 (또는 호출자 바인딩)가있는 메소드 핸들의 잘못된 계시를 신뢰할 수있는 프로그램에 대해 &quot;빠른 실패&quot;동작을 제공합니다. 이 제한을 무시 하려면 &lt;a href=&quot;methodhandles#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;MethodHandles.reflectAs(java.lang.Class&amp;lt;T&amp;gt;, java.lang.invoke.MethodHandle)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88faedd860fdc4cb6207174dad3840e3bf7612c6" translate="yes" xml:space="preserve">
          <source>The reserved method name &quot;new&quot; may be used to call a class's constructor as if all classes defined static &quot;new&quot; methods. Constructor invocations are typically considered &lt;code&gt;Expression&lt;/code&gt;s rather than &lt;code&gt;Statement&lt;/code&gt;s as they return a value.</source>
          <target state="translated">예약 된 메소드 이름 &quot;new&quot;는 모든 클래스가 정적 &quot;new&quot;메소드를 정의한 것처럼 클래스의 생성자를 호출하는 데 사용될 수 있습니다. 생성자 호출은 일반적으로 값을 반환 할 때 &lt;code&gt;Statement&lt;/code&gt; 가 아닌 &lt;code&gt;Expression&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1022ae785514449efe40f2c8963abb11d2504058" translate="yes" xml:space="preserve">
          <source>The resolve phase is controlled by two parameters, set on this class.</source>
          <target state="translated">확인 단계는이 클래스에서 설정 한 두 개의 매개 변수로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a61f04ea30a79177449a58b04a28b104802818" translate="yes" xml:space="preserve">
          <source>The resolved type descriptor at the call site of &lt;code&gt;invoke&lt;/code&gt; must be a valid argument to the receivers &lt;code&gt;asType&lt;/code&gt; method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity collector&lt;/a&gt;.</source>
          <target state="translated">의 호출 사이트에서 확인 된 유형 설명 &lt;code&gt;invoke&lt;/code&gt; 수신기에 대한 유효한 인수해야 &lt;code&gt;asType&lt;/code&gt; 의 방법. 특히, 수신자가 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity 콜렉터&lt;/a&gt; 가 아닌 경우 호출자는 수신자 유형과 동일한 인수 arity를 ​​지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="99b6d2884fc55c38d82210c2985b9069bbb9d028" translate="yes" xml:space="preserve">
          <source>The result code. A zero value indicates success.</source>
          <target state="translated">결과 코드 값이 0이면 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8613290fff9e558c87a48402abefab9874ccc8e4" translate="yes" xml:space="preserve">
          <source>The result does not depend on the local time zone.</source>
          <target state="translated">결과는 현지 시간대에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="921d7223769295c006da8a5575b7156fcaa03cc8" translate="yes" xml:space="preserve">
          <source>The result from JDK classes implementing &lt;code&gt;TemporalAccessor&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;TemporalAccessor&lt;/code&gt; 를 구현하는 JDK 클래스의 결과 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17e6a87b8d0781fae57ea50faf6f5b7a370d70bb" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;FileTime&lt;/code&gt; that represents the same time. This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">결과는 &lt;code&gt;true&lt;/code&gt; 인수가 아닌 경우에만 경우 &lt;code&gt;null&lt;/code&gt; 과이다 &lt;code&gt;FileTime&lt;/code&gt; 같은 시간을 나타냅니다. 이 메소드는 &lt;code&gt;Object.equals&lt;/code&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="b0dee0b193f5269aef268cfda1e03af61caf65f1" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; only if two cookies come from same domain (case-insensitive), have same name (case-insensitive), and have same path (case-sensitive).</source>
          <target state="translated">결과는 두 개의 쿠키가 동일한 도메인 (대소 문자 구분)에서 왔으며 동일한 이름 (대소 문자 구분)이없고 동일한 경로 (대소 문자 구분) 가있는 &lt;code&gt;true&lt;/code&gt; 에만 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="838dc70d106c3ae54e71b7f7448a352db88afffd" translate="yes" xml:space="preserve">
          <source>The result is a Unicode character</source>
          <target state="translated">결과는 유니 코드 문자입니다</target>
        </trans-unit>
        <trans-unit id="35b56830c2c27888962f73364e19ecf38d296dd4" translate="yes" xml:space="preserve">
          <source>The result is a literal &lt;code&gt;'%'&lt;/code&gt; (&lt;code&gt;'\u0025'&lt;/code&gt;)</source>
          <target state="translated">결과는 리터럴 &lt;code&gt;'%'&lt;/code&gt; ( &lt;code&gt;'\u0025'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="ef02a3668d69ce2348a1bc4508f08e4804908b1b" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="50a9d6bfa24192970ed8fb8258874aefd0c97173" translate="yes" xml:space="preserve">
          <source>The result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt;. The formatting of the magnitude</source>
          <target state="translated">결과는 인수의 부호와 크기 (절대 값)를 나타내는 문자열입니다. 부호의 형식은 &lt;a href=&quot;#L10nAlgorithm&quot;&gt;현지화 알고리즘에&lt;/a&gt; 설명되어 있습니다. 크기의 서식</target>
        </trans-unit>
        <trans-unit id="f2cfd2a95bfe92fd8ecc073d54de4e5f2a29bf7c" translate="yes" xml:space="preserve">
          <source>The result is associated with the first type that successfully parses. Normally, applications will use &lt;code&gt;instanceof&lt;/code&gt; to check the result. For example:</source>
          <target state="translated">결과는 성공적으로 구문 분석 한 첫 번째 유형과 연관됩니다. 일반적으로 응용 프로그램은 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 하여 결과를 확인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c479cf3264a2832bd0cd79a44afc9492a7822f3" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal integer</source>
          <target state="translated">결과는 십진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="1baf7d104748e0c4f8533df16bd664f663e30ad1" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number</source>
          <target state="translated">결과는 10 진수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5f14b19f3b75abbc59e057304d121d6548d56189" translate="yes" xml:space="preserve">
          <source>The result is formatted as a decimal number in computerized scientific notation</source>
          <target state="translated">결과는 컴퓨터 공학 표기법에서 10 진수로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ab4d798c9eeb9edc29f6dcdd7b9bd66fea5cc6a" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal floating-point number with a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported for the &lt;code&gt;BigDecimal&lt;/code&gt; type despite the latter's being in the</source>
          <target state="translated">결과는 유효하고 지수가있는 16 진수 부동 소수점 숫자로 형식이 지정됩니다. &lt;code&gt;BigDecimal&lt;/code&gt; 유형은 후자에 &lt;b&gt;있지만&lt;/b&gt; 이 변환은 지원 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="42563538eaee038d859706aa7ad8dd76aaba6a51" translate="yes" xml:space="preserve">
          <source>The result is formatted as a hexadecimal integer</source>
          <target state="translated">결과는 16 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="5e4dac5beac66ef686eb3d95b633320454953615" translate="yes" xml:space="preserve">
          <source>The result is formatted as an octal integer</source>
          <target state="translated">결과는 8 진 정수로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="b924acf7a536ce1992d3ebe1342457a6f36dca7a" translate="yes" xml:space="preserve">
          <source>The result is formatted using computerized scientific notation or decimal format, depending on the precision and the value after rounding.</source>
          <target state="translated">결과는 반올림 후의 정밀도와 값에 따라 컴퓨터 화 된 과학적 표기법 또는 10 진수 형식을 사용하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb45f182258a186b18790c8b6cad368f2f9319d" translate="yes" xml:space="preserve">
          <source>The result is returned in an enumeration of &lt;code&gt;SearchResult&lt;/code&gt;s. Each &lt;code&gt;SearchResult&lt;/code&gt; contains the name of the object and other information about the object (see SearchResult). The name is either relative to the target context of the search (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or it is a URL string. If the target context is included in the enumeration (as is possible when &lt;code&gt;cons&lt;/code&gt; specifies a search scope of &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;), its name is the empty string. The &lt;code&gt;SearchResult&lt;/code&gt; may also contain attributes of the matching object if the &lt;code&gt;cons&lt;/code&gt; argument specified that attributes be returned.</source>
          <target state="translated">결과는 &lt;code&gt;SearchResult&lt;/code&gt; 의 열거로 리턴됩니다 . 각 &lt;code&gt;SearchResult&lt;/code&gt; 에는 객체 이름과 객체에 대한 기타 정보가 포함됩니다 (SearchResult 참조). 이름은 검색의 대상 컨텍스트 ( &lt;code&gt;name&lt;/code&gt; 매개 변수로 이름 지정)에 상대적 이거나 URL 문자열입니다. 대상 컨텍스트가 열거에 포함 된 경우 ( &lt;code&gt;cons&lt;/code&gt; 가 &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; 또는 &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt; 의 검색 범위를 지정할 때 가능한 것처럼 ) 해당 이름은 빈 문자열입니다. &lt;code&gt;SearchResult&lt;/code&gt; 경우도 일치하는 객체의 속성을 포함 할 수있다 &lt;code&gt;cons&lt;/code&gt; 인수는 속성이 반환되도록 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="06f5e6bd8fe2e41c0946b6e4854fa774421e66fe" translate="yes" xml:space="preserve">
          <source>The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;/code&gt; method).</source>
          <target state="translated">결과적으로 두 스레드가 동시에 실행됩니다. 현재 스레드 ( &lt;code&gt;start&lt;/code&gt; 메소드 호출에서 리턴 )와 다른 스레드 ( &lt;code&gt;run&lt;/code&gt; 메소드 실행 ).</target>
        </trans-unit>
        <trans-unit id="d28d29bf955a0a2e562abe4616fe55325dd93e91" translate="yes" xml:space="preserve">
          <source>The result is the platform-specific line separator</source>
          <target state="translated">결과는 플랫폼 별 행 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="058151d93a1ffc55deb73095cbeeabd4b91f7162" translate="yes" xml:space="preserve">
          <source>The result may be the same object or a different object. If the requested target view isn't available then the given bean is returned.</source>
          <target state="translated">결과는 동일한 객체이거나 다른 객체 일 수 있습니다. 요청 된 대상 뷰를 사용할 수 없으면 지정된 Bean이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d71f2225914f95f63b3119e8410020da3a87b63a" translate="yes" xml:space="preserve">
          <source>The result must be a concrete subclass of StartTlsResponse and must have a public zero-argument constructor.</source>
          <target state="translated">결과는 StartTlsResponse의 구체적인 서브 클래스 여야하며 인수없는 공용 인수 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="77ef281b848eda832ef63d0cbb4b3167978fdaff" translate="yes" xml:space="preserve">
          <source>The result of a match operation.</source>
          <target state="translated">일치 작업의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="86cbe802aaee405937142c5c8477e8e564f921ce" translate="yes" xml:space="preserve">
          <source>The result of applying this method to these arguments.</source>
          <target state="translated">이 방법을 이러한 인수에 적용한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5429cf36c8fd7a2562aad20c9d7f000fb4661122" translate="yes" xml:space="preserve">
          <source>The result of invoking &lt;code&gt;toString()&lt;/code&gt; on the destination for the output</source>
          <target state="translated">출력 대상에서 &lt;code&gt;toString()&lt;/code&gt; 을 호출 한 결과</target>
        </trans-unit>
        <trans-unit id="44e206b266ba20a6d4c2e1a04be2e9225595f101" translate="yes" xml:space="preserve">
          <source>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</source>
          <target state="translated">주어진 입력을 처리 한 결과는 다른 입력의 존재 또는 부재 (직교성)의 함수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="53dcb69ac17959659b0334122a358f8985fa05ac" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. In most cases, the positive/negative sign will be the same in each of the supported fields.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 대부분의 경우 양수 / 음수 부호는 지원되는 각 필드에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7daa711ab9261153416c162a0aec24648bdcf12b" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="84fc9d37222c832e8afbf150d8f6699253efda20" translate="yes" xml:space="preserve">
          <source>The result of this method can be a negative period if the end is before the start. To guarantee to obtain a positive duration call &lt;a href=&quot;duration#abs--&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; on the result.</source>
          <target state="translated">이 방법의 결과는 끝이 시작하기 전에 음수 기간이 될 수 있습니다. 결과에 대해 긍정적 인 지속 시간을 얻기 위해 &lt;a href=&quot;duration#abs--&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fdc023462e3c1d38fa0fae3a92e16cba6d2639d7" translate="yes" xml:space="preserve">
          <source>The result of this method is &lt;code&gt;TemporalAccessor&lt;/code&gt; which represents the data as seen in the input. Values are not validated, thus parsing a date string of '2012-00-65' would result in a temporal with three fields - year of '2012', month of '0' and day-of-month of '65'.</source>
          <target state="translated">이 메소드의 결과 는 입력에 표시된대로 데이터를 나타내는 &lt;code&gt;TemporalAccessor&lt;/code&gt; 입니다. 값의 유효성이 검사되지 않으므로 '2012-00-65'날짜 문자열을 구문 분석하면 '2012'연도, '0'월 및 '65'월의 세 필드로 된 시간이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52fc7eddd6f4fde58aa8d10634dec95344d469b7" translate="yes" xml:space="preserve">
          <source>The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute.</source>
          <target state="translated">이 URI가 절대이거나 지정된 URI가 절대 인 경우에만이 메소드의 결과는 절대입니다.</target>
        </trans-unit>
        <trans-unit id="33f42a4bb7c7ad421307948fd84808d9ca5b7265" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuffer#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e72a2494b9f2adf3a9c829328a4201155a935ee8" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this object's &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;(dstOffset, s, 0, s.length()) method.</source>
          <target state="translated">이 메소드의 결과는이 오브젝트의 &lt;a href=&quot;stringbuilder#insert-int-java.lang.CharSequence-int-int-&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; (dstOffset, s, 0, s.length ()) 메소드를 호출 한 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8aac06f8f47a270c52f5af0438f30546f8c15210" translate="yes" xml:space="preserve">
          <source>The result of this method is exactly the same as if it were an invocation of this.append(s, 0, s.length());</source>
          <target state="translated">이 메소드의 결과는 this.append (s, 0, s.length ())의 호출 인 경우와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7b7539ebe1108c837cb3ebf5e22050282d869cda" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the default keytab file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트를 기본 키탭 파일 에만 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7001452e9a69f2ce57bba98f6683a9cf75e695fd" translate="yes" xml:space="preserve">
          <source>The result of this method is never null. This method only associates the returned &lt;code&gt;KeyTab&lt;/code&gt; object with the file and does not read it.</source>
          <target state="translated">이 메소드의 결과는 결코 null이 아닙니다. 이 메소드는 리턴 된 &lt;code&gt;KeyTab&lt;/code&gt; 오브젝트 만 파일과 연관시키고 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c493abfdae35894af24f4901c426e667b33769ca" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;../temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="c9079bf22411247394dc7e14291f74d7e689d317" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt;&lt;/a&gt; method on the specified adjuster passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporaladjuster#adjustInto-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAdjuster.adjustInto(Temporal)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 조정기에 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="ed9634345d8412156512a42500e34a894cf4c2f5" translate="yes" xml:space="preserve">
          <source>The result of this method is obtained by invoking the &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; method on the specified query passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">이 방법의 결과를 호출하여 얻어지는 &lt;a href=&quot;temporal/temporalquery#queryFrom-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;TemporalQuery.queryFrom(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 를 통과하는 특정 쿼리 방법 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="9b7fc7cadcbbb563002dfc29694594763d5fe98f" translate="yes" xml:space="preserve">
          <source>The result of this method will make up the contents of the SASL buffer as defined in RFC 2222 without the leading four octet field that represents the length. &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; specify the portion of &lt;code&gt;outgoing&lt;/code&gt; to use.</source>
          <target state="translated">이 방법의 결과는 길이를 나타내는 선행 4 옥텟 필드없이 RFC 2222에 정의 된대로 SASL 버퍼의 내용을 구성합니다. &lt;code&gt;offset&lt;/code&gt; 과 &lt;code&gt;len&lt;/code&gt; 은 사용할 &lt;code&gt;outgoing&lt;/code&gt; 부분을 ​​지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9369d2fab7f01eadc45cae17b70a104674f355e1" translate="yes" xml:space="preserve">
          <source>The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void.</source>
          <target state="translated">호출이 리턴 한 결과는 기본 인 경우 상자로 표시되거나 리턴 유형이 void 인 경우 강제로 널로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="806535d76174a264f9b4ff6d7c99faca08eddf1e" translate="yes" xml:space="preserve">
          <source>The result returned by the hook must be a method handle of exactly the same type as the call site.</source>
          <target state="translated">후크가 리턴 한 결과는 호출 사이트와 정확히 동일한 유형의 메소드 핸들이어야합니다.</target>
        </trans-unit>
        <trans-unit id="59d025c7c37030729df1da6ef20378d1c89b991c" translate="yes" xml:space="preserve">
          <source>The result should use a conversion-dependent alternate form</source>
          <target state="translated">결과는 변환 종속 대체 양식을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="8f5827a90eb65856b4b89ffb933882240c216cc7" translate="yes" xml:space="preserve">
          <source>The result type of a &lt;a href=&quot;filevisitor&quot;&gt;&lt;code&gt;FileVisitor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;filevisitor&quot;&gt; &lt;code&gt;FileVisitor&lt;/code&gt; &lt;/a&gt; 의 결과 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2d7644c465280fb43e327f5847a1469aaa7aec19" translate="yes" xml:space="preserve">
          <source>The result will always include a sign</source>
          <target state="translated">결과는 항상 부호를 포함합니다</target>
        </trans-unit>
        <trans-unit id="c5f0ab9813b2497b6aace9d0a659cb51a7b9e650" translate="yes" xml:space="preserve">
          <source>The result will be left-justified.</source>
          <target state="translated">결과는 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd03f8040d572a14698fa4790b45d2dea79538f" translate="yes" xml:space="preserve">
          <source>The result will be null if it is called on the root Logger in the namespace.</source>
          <target state="translated">네임 스페이스의 루트 로거에서 호출 된 경우 결과는 null입니다.</target>
        </trans-unit>
        <trans-unit id="eebffb3b7f508dfd870235eaedb8bd617c34fb42" translate="yes" xml:space="preserve">
          <source>The result will be zero-padded</source>
          <target state="translated">결과는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="ac5d38a04d258f50b2e728006d792d84ec797c12" translate="yes" xml:space="preserve">
          <source>The result will enclose negative numbers in parentheses</source>
          <target state="translated">결과는 괄호 안에 음수를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="b60dbdb0c739a0db71280a2d5057407b2907dcbf" translate="yes" xml:space="preserve">
          <source>The result will include a leading space for positive values</source>
          <target state="translated">결과는 양수 값을위한 선행 공간을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="86565ee42252b8d90b6fc4f6a7e56b8ff7846015" translate="yes" xml:space="preserve">
          <source>The result will include locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separators&lt;/a&gt;</source>
          <target state="translated">결과는 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;그룹 구분 기호를 포함합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da36d6b79c4c033f7a27b28c533a4819c6e58026" translate="yes" xml:space="preserve">
          <source>The resultant byte array</source>
          <target state="translated">결과 바이트 배열</target>
        </trans-unit>
        <trans-unit id="094bc7c12af1c9c170e626d26c061113ab22168d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Class&lt;/code&gt; object</source>
          <target state="translated">결과 &lt;code&gt;Class&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="04d7e541442907c4718e4aa6df8cb95ea6facb8b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Path&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;Path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d9cee928349ecad8207afb80abfb3ac1e49b7c6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eb30aecd9ce3fd342fd1fb862917adbede7e62" translate="yes" xml:space="preserve">
          <source>The resulting Class object.</source>
          <target state="translated">결과 Class 객체.</target>
        </trans-unit>
        <trans-unit id="64fd0e638650ed8a264bb09d0464e8bdf66b1c52" translate="yes" xml:space="preserve">
          <source>The resulting URI</source>
          <target state="translated">결과 URI</target>
        </trans-unit>
        <trans-unit id="7419fc69db0c5232d5bde59115b8e8bbc2a129ee" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor and then invoking the &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt;&lt;code&gt;parseServerAuthority()&lt;/code&gt;&lt;/a&gt; method upon the result; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">결과 URI 문자열은 마치 &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출 한 다음 결과에 따라 &lt;a href=&quot;uri#parseServerAuthority--&quot;&gt; &lt;code&gt;parseServerAuthority()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것처럼 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a50f9807a1fa543061a71bf50d779ccfe528067" translate="yes" xml:space="preserve">
          <source>The resulting URI string is then parsed in order to create the new URI instance as if by invoking the &lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt;&lt;code&gt;URI(String)&lt;/code&gt;&lt;/a&gt; constructor; this may cause a &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">&lt;a href=&quot;uri#URI-java.lang.String-&quot;&gt; &lt;code&gt;URI(String)&lt;/code&gt; &lt;/a&gt; 생성자를 호출하는 것처럼 새 URI 인스턴스를 작성하기 위해 결과 URI 문자열이 구문 분석됩니다 . 이로 인해 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1cbbe9ae02dde33f88ed9dbc263ec8e5ac65206" translate="yes" xml:space="preserve">
          <source>The resulting adapter is the same type as the target, except that the first parameter type is dropped, if it corresponds to the result of the combiner.</source>
          <target state="translated">결과 어댑터는 첫 번째 매개 변수 유형이 결합기의 결과에 해당하는 경우 삭제되는 것을 제외하고 대상과 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c786abb2aba329e942d81e1d06f1d11b97967b9" translate="yes" xml:space="preserve">
          <source>The resulting array is of exactly the same class as the original array.</source>
          <target state="translated">결과 배열은 원래 배열과 정확히 같은 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c5a1157b9f760855069d2f10df624ea637e64ca4" translate="yes" xml:space="preserve">
          <source>The resulting asynchronous channel group reuses a fixed number of threads. At any point, at most &lt;code&gt;nThreads&lt;/code&gt; threads will be active processing tasks that are submitted to handle I/O events and dispatch completion results for operations initiated on asynchronous channels in the group.</source>
          <target state="translated">결과 비동기 채널 그룹은 고정 된 수의 스레드를 재사용합니다. 어느 시점에서나 최대 &lt;code&gt;nThreads&lt;/code&gt; 스레드는 I / O 이벤트를 처리하고 그룹의 비동기 채널에서 시작된 작업에 대한 완료 결과를 디스패치하기 위해 제출되는 활성 처리 작업입니다.</target>
        </trans-unit>
        <trans-unit id="2e1c0df7b54fbf773f3c4b5bcdbc4bfa62115cb7" translate="yes" xml:space="preserve">
          <source>The resulting attribute has the set difference of its prior value set and the specified value set. If no values are specified, deletes the entire attribute. If the attribute does not exist, or if some or all members of the specified value set do not exist, this absence may be ignored and the operation succeeds, or a NamingException may be thrown to indicate the absence. Removal of the last value will remove the attribute if the attribute is required to have at least one value.</source>
          <target state="translated">결과 속성에는 이전 값 세트와 지정된 값 세트의 차이가 설정됩니다. 값을 지정하지 않으면 전체 속성을 삭제합니다. 속성이 존재하지 않거나 지정된 값 세트의 일부 또는 모든 멤버가 존재하지 않으면이 부재가 무시되고 조작이 성공하거나 부재를 표시하기 위해 NamingException이 발생 될 수 있습니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8b051c029a9cb257557ce55a86701099f33ad0" translate="yes" xml:space="preserve">
          <source>The resulting channel is associated with default thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the result of asynchronous operations performed on the resulting channel.</source>
          <target state="translated">결과 채널은 I / O 이벤트를 처리하고 결과 채널에서 수행 된 비동기 작업의 결과를 사용하는 완료 핸들러로 디스패치하기 위해 태스크가 제출되는 기본 스레드 풀과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0477159a435eb4c7b6e87913d4947dad931600" translate="yes" xml:space="preserve">
          <source>The resulting channel will not be buffered; it will simply redirect its I/O operations to the given stream. Closing the channel will in turn cause the stream to be closed.</source>
          <target state="translated">결과 채널은 버퍼링되지 않습니다. 단순히 I / O 작업을 지정된 스트림으로 리디렉션합니다. 채널을 닫으면 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="2e7f4afa7fa2b1530937581bdba920189b54b7a0" translate="yes" xml:space="preserve">
          <source>The resulting context is for resolving URLs of the scheme &lt;code&gt;scheme&lt;/code&gt;. The resulting context is not tied to a specific URL. It is able to handle arbitrary URLs with the specified scheme.</source>
          <target state="translated">결과 컨텍스트는 체계 &lt;code&gt;scheme&lt;/code&gt; URL을 확인하기위한 것 입니다. 결과 컨텍스트는 특정 URL에 연결되지 않습니다. 지정된 체계로 임의의 URL을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ed36145c18184a4c0192876b36f57186eb11b9" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of file in this directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to the file in the directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 디렉토리에서 파일의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상 디렉토리의 파일에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d791ce15a89946bb449aad309d10e2028011d0e0" translate="yes" xml:space="preserve">
          <source>The resulting file attribute view can be used to read or update the attributes of this (open) directory. The &lt;code&gt;type&lt;/code&gt; parameter specifies the type of the attribute view and the method returns an instance of that type if supported. Invoking this method to obtain a &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; always returns an instance of that class that is bound to this open directory.</source>
          <target state="translated">결과 파일 속성보기를 사용하여이 (열린) 디렉토리의 속성을 읽거나 업데이트 할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 파라미터 속성보기 유형을 지정하고 지원하는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 얻기 위해이 메소드를 호출하면 항상이 열린 디렉토리에 바인드 된 해당 클래스의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1c0268e4ebd731468a02d197d2029a7d6d6cfbfc" translate="yes" xml:space="preserve">
          <source>The resulting file names must match exactly as strings with their occurrences in the JAR file.</source>
          <target state="translated">결과 파일 이름은 JAR 파일에서 발생하는 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1dd0222947bfa0316d9b432e87769219a094695" translate="yes" xml:space="preserve">
          <source>The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt;&lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">결과 형식화 된 문자열에는 일반적으로 현지화 된 형식의 LogRecord 메시지 필드 버전이 포함됩니다. 메시지 필드를 현지화하고 형식화하려면 &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt; &lt;code&gt;formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 편의 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f9b393261c3425d386d8251817252af6f14e85a9" translate="yes" xml:space="preserve">
          <source>The resulting instance of the required type will respond to invocation of the type's uniquely named method by calling the given target on the incoming arguments, and returning or throwing whatever the target returns or throws. The invocation will be as if by &lt;code&gt;target.invoke&lt;/code&gt;. The target's type will be checked before the instance is created, as if by a call to &lt;code&gt;asType&lt;/code&gt;, which may result in a &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.</source>
          <target state="translated">필요한 형식의 결과 인스턴스는 들어오는 인수에서 지정된 대상을 호출하고 대상이 반환하거나 던지는 모든 것을 반환하거나 던져서 형식의 고유 한 명명 된 메서드 호출에 응답합니다. &lt;code&gt;target.invoke&lt;/code&gt; 에 의한 호출이됩니다 . 인스턴스가 생성되기 전에 목표의 유형 것처럼 호출하여 체크한다 &lt;code&gt;asType&lt;/code&gt; A의 발생할 수 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de4b752490153330ced19eb1636ec25661fe14d" translate="yes" xml:space="preserve">
          <source>The resulting list is &lt;code&gt;[a, c, d, b, e]&lt;/code&gt;.</source>
          <target state="translated">결과 목록은 &lt;code&gt;[a, c, d, b, e]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1884f6b5e1183ba90dbd15f7cef2ddc5936af5e3" translate="yes" xml:space="preserve">
          <source>The resulting metadata object is only responsible for returning documents in the format named by &lt;code&gt;formatName&lt;/code&gt;. Within any documents that are returned, only nodes whose names are members of &lt;code&gt;nodeNames&lt;/code&gt; are required to be returned. In this way, the amount of metadata processing done by the reader may be kept to a minimum, based on what information is actually needed.</source>
          <target state="translated">결과 메타 데이터 개체는 &lt;code&gt;formatName&lt;/code&gt; 으로 명명 된 형식의 문서 만 반환합니다 . 리턴 된 문서 내에서 이름이 &lt;code&gt;nodeNames&lt;/code&gt; 의 구성원 인 노드 만 리턴 해야합니다. 이러한 방식으로, 판독기에 의해 수행되는 메타 데이터 처리량은 실제로 필요한 정보에 기초하여 최소로 유지 될 수있다.</target>
        </trans-unit>
        <trans-unit id="9c5c220cd80df632d39ecb3d8b6a70f850252346" translate="yes" xml:space="preserve">
          <source>The resulting period will be day-based, with the amount of days equal to the number of weeks multiplied by 7. The years and months units will be zero.</source>
          <target state="translated">결과 기간은 일 수를 기준으로하며 일 수는 주 수에 7을 곱한 값입니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="a6b95edf4e81e9e6b6619e37b7ddbb8faf120000" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified days. The years and months units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 요일이 있습니다. 연도 및 월 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="9ed86d9dd063303868aa5b67521032ff19d3dd44" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified months. The years and days units will be zero.</source>
          <target state="translated">결과 기간에는 지정된 월이 있습니다. 년과 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="29d3631062d098fb17c4652fb16c3cf33dfe26c4" translate="yes" xml:space="preserve">
          <source>The resulting period will have the specified years. The months and days units will be zero.</source>
          <target state="translated">결과 기간은 지정된 연도입니다. 월 및 일 단위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="95444b5a8c83dcd2572f1e1d42e1076adc4c44ce" translate="yes" xml:space="preserve">
          <source>The resulting proxy class must not exceed any limits imposed on classes by the virtual machine. For example, the VM may limit the number of interfaces that a class may implement to 65535; in that case, the size of the &lt;code&gt;interfaces&lt;/code&gt; array must not exceed 65535.</source>
          <target state="translated">결과 프록시 클래스는 가상 머신에 의해 클래스에 부과 된 제한을 초과 할 수 없습니다. 예를 들어, VM은 클래스가 구현할 수있는 인터페이스 수를 65535로 제한 할 수 있습니다. 이 경우, 크기 &lt;code&gt;interfaces&lt;/code&gt; 배열 65535을 초과하지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="6387f721ca72aada5ca623b823df6496720b727a" translate="yes" xml:space="preserve">
          <source>The resulting reader will start reading at the given &lt;code&gt;offset&lt;/code&gt;. The total number of &lt;code&gt;char&lt;/code&gt; values that can be read from this reader will be either &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;buf.length-offset&lt;/code&gt;, whichever is smaller.</source>
          <target state="translated">결과 판독기는 주어진 &lt;code&gt;offset&lt;/code&gt; 에서 읽기 시작 합니다. 이 리더에서 읽을 수있는 총 &lt;code&gt;char&lt;/code&gt; 값 수는 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;buf.length-offset&lt;/code&gt; 중 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="ebf284259891b966795d0320eaa89a9efa9f184a" translate="yes" xml:space="preserve">
          <source>The resulting region is then subsampled according to the factors given in &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt;&lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt;&lt;/a&gt;. The first pixel, the number of pixels per row, and the number of rows all depend on the subsampling settings. Call the minimum X and Y coordinates of the resulting rectangle (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;), its width &lt;code&gt;w&lt;/code&gt; and its height &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">결과 영역은 &lt;a href=&quot;iioparam#setSourceSubsampling-int-int-int-int-&quot;&gt; &lt;code&gt;IIOParam.setSourceSubsampling&lt;/code&gt; 에&lt;/a&gt; 주어진 요소에 따라 서브 샘플링됩니다 . 첫 번째 픽셀, 행당 픽셀 수 및 행 수는 모두 서브 샘플링 설정에 따라 다릅니다. 결과 사각형의 최소 X 및 Y 좌표 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; ), 너비 &lt;code&gt;w&lt;/code&gt; 및 높이 &lt;code&gt;h&lt;/code&gt; 를호출 합니다.</target>
        </trans-unit>
        <trans-unit id="7927acc85bf7485dc11e63b36c81bfd277412443" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal input buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;read&lt;/code&gt; methods will, as needed, fill the buffer by reading bytes from the underlying channel; if the channel is in non-blocking mode when bytes are to be read then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered, and it will not support the &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/reader#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">생성 된 스트림은 적어도 내부 입력 버퍼 포함 &lt;code&gt;minBufferCap&lt;/code&gt; 가 바이트. 스트림의 &lt;code&gt;read&lt;/code&gt; 방법은, 필요에 따라 기본 채널의 바이트를 판독하여 버퍼를 채울 것이다; 채널은 다음 바이트가 판독 할 때 비 블록 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 발생한다. 생성 된 스트림은 별도로 버퍼되지 않고,지지되지 &lt;a href=&quot;../../io/reader#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/reader#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 방법. 스트림을 닫는 것은 채널 원인 차례로 폐쇄 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d580035bd2b566457432a5e4d925677447d221a" translate="yes" xml:space="preserve">
          <source>The resulting stream will contain an internal output buffer of at least &lt;code&gt;minBufferCap&lt;/code&gt; bytes. The stream's &lt;code&gt;write&lt;/code&gt; methods will, as needed, flush the buffer by writing bytes to the underlying channel; if the channel is in non-blocking mode when bytes are to be written then an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; will be thrown. The resulting stream will not otherwise be buffered. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림에는 최소한 &lt;code&gt;minBufferCap&lt;/code&gt; 바이트 의 내부 출력 버퍼가 포함 됩니다. 스트림의 &lt;code&gt;write&lt;/code&gt; 메소드는 필요에 따라 기본 채널에 바이트를 써서 버퍼를 플러시합니다. 바이트를 쓸 때 채널이 비 블로킹 모드에 있으면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그렇지 않으면 결과 스트림이 버퍼링되지 않습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b5709861225c7ba3b6865800d13497f86bd85df6" translate="yes" xml:space="preserve">
          <source>The resulting string</source>
          <target state="translated">결과 문자열</target>
        </trans-unit>
        <trans-unit id="65db06e467299c29537ab9336bf47bbbf5cdbd84" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없으며 일반적으로 사용하지 않는 것이 좋습니다. &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 아래의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbb3bb7280c618deda0717f345ca0d0a3e5a617a" translate="yes" xml:space="preserve">
          <source>The results of this constructor can be somewhat unpredictable. One might assume that writing &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; in Java creates a &lt;code&gt;BigDecimal&lt;/code&gt; which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a &lt;code&gt;double&lt;/code&gt; (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed</source>
          <target state="translated">이 생성자의 결과는 다소 예측할 수 없습니다. 하나는 쓰는 것을 가정 할 수 &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; 자바 것은 생성 &lt;code&gt;BigDecimal&lt;/code&gt; (1의 규모로, 1의 스케일 없음의 값) 0.1 정확하게 일치이지만, 실제로 0.1000000000000000055511151231257827021181583404541015625 같음. 이는 0.1을 정확히 &lt;code&gt;double&lt;/code&gt; 로 표현할 수 없기 때문입니다 (또는이 문제의 경우 유한 길이의 이진 분수). 따라서 전달되는 가치</target>
        </trans-unit>
        <trans-unit id="72b26f2b5e9e76c38d5206ceaa707fac001defe0" translate="yes" xml:space="preserve">
          <source>The results should be the same as obtaining all the PrintServices and querying each one individually on its support for the specified attributes and flavors, but the process can be more efficient by taking advantage of the capabilities of lookup services for the print services.</source>
          <target state="translated">결과는 모든 PrintService를 가져 와서 지정된 속성 및 특징에 대한 지원에 대해 각각 개별적으로 쿼리하는 것과 동일해야하지만 인쇄 서비스에 대한 조회 서비스 기능을 활용하면 프로세스가 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2a2d456b1fe7f946cf6afcde99facfbb1b054d" translate="yes" xml:space="preserve">
          <source>The retransformation may change method bodies, the constant pool and attributes. The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">재 변환은 메소드 본문, 상수 풀 및 속성을 변경할 수 있습니다. 재 변환은 필드 또는 메소드를 추가, 제거 또는 이름 변경하거나 메소드의 서명을 변경하거나 상속을 변경해서는 안됩니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다. 변환이 적용될 때까지 클래스 파일 바이트는 확인, 확인 및 설치되지 않습니다. 결과 바이트에 오류가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ca960eb615ad53bc0b3135b373d2036434995b22" translate="yes" xml:space="preserve">
          <source>The return type Rt is void, or the return type Ra is not void and is adaptable to Rt</source>
          <target state="translated">반환 유형 Rt가 비어 있거나 반환 유형 Ra가 비어 있지 않으며 Rt에 적용 가능</target>
        </trans-unit>
        <trans-unit id="92c09d015f75e8bee39bac035a68343e43b9f9d8" translate="yes" xml:space="preserve">
          <source>The return type of the filter replaces the return type of the target in the resulting adapted method handle. The argument type of the filter (if any) must be identical to the return type of the target.</source>
          <target state="translated">필터의 리턴 유형은 결과로 적용된 메소드 핸들에서 대상의 리턴 유형을 대체합니다. 필터의 인수 유형 (있는 경우)은 대상의 리턴 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6a026e7ef017e49a86ae81d83b570e4f3b988ce" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(Reader, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="d250b67419c015be49448c5b2b4064b04039b13f" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;eval(String, ScriptContext)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval(String, ScriptContext)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="18c586324069b76d67cca48a59dcffb8f32f65de" translate="yes" xml:space="preserve">
          <source>The return value from the script execution</source>
          <target state="translated">스크립트 실행의 반환 값</target>
        </trans-unit>
        <trans-unit id="d7e61cce8a603e1ed7dd41104b64452e72191f66" translate="yes" xml:space="preserve">
          <source>The return value indicates whether the deadline has elapsed, which can be used as follows:</source>
          <target state="translated">반환 값은 최종 기한이 지 났는지 여부를 나타내며 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b117098b5c546c14491ff8cf89569aadc8a2ea4" translate="yes" xml:space="preserve">
          <source>The return value is a constant for the lifetime of the implementing instance</source>
          <target state="translated">반환 값은 구현 인스턴스의 수명 동안 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4219f41ab6bb669a3af2e1f70f85e439bc1d24f1" translate="yes" xml:space="preserve">
          <source>The return value of this method is the string form of the value of a Multipurpose Internet Mail Extension (MIME) content type as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according to the grammar in the RFC.</source>
          <target state="translated">이 메소드의 리턴 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC 2045 : MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식에&lt;/i&gt;&lt;/a&gt; 정의 된 MIME (Multipurpose Internet Mail Extension) 컨텐츠 유형 값의 문자열 형식입니다 . RFC의 문법에 따라 문자열을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d6884c96ab13575074a3fd88c171169562433f" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to read a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an IllegalArgumentException.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 비 적분 수의 샘플 프레임을 나타내는 다수의 바이트 읽기 요청은 이행 될 수 없으며 IllegalArgumentException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bab3d5729e7a670151bb1fa0f6d52b4a1a2b1601" translate="yes" xml:space="preserve">
          <source>The return value will always meet this requirement. A request to write a number of bytes representing a non-integral number of sample frames cannot be fulfilled and may result in an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상이 요구 사항을 충족합니다. 정수가 아닌 샘플 프레임을 나타내는 바이트 수 쓰기 요청을 이행 할 수 없으며 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6bfc96df054b19c8bae5f8772d6621a71f8e532" translate="yes" xml:space="preserve">
          <source>The return values of navigation methods may be ambiguous in implementations that permit &lt;code&gt;null&lt;/code&gt; elements. However, even in this case the result can be disambiguated by checking &lt;code&gt;contains(null)&lt;/code&gt;. To avoid such issues, implementations of this interface are encouraged to &lt;em&gt;not&lt;/em&gt; permit insertion of &lt;code&gt;null&lt;/code&gt; elements. (Note that sorted sets of &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; elements intrinsically do not permit &lt;code&gt;null&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 요소 를 허용하는 구현에서는 탐색 메서드의 반환 값이 모호 할 수 있습니다 . 그러나이 경우에도 &lt;code&gt;contains(null)&lt;/code&gt; 을 확인하여 결과를 명확하게 할 수 있습니다 . 이러한 문제를 피하기 위해이 인터페이스의 구현 은 &lt;code&gt;null&lt;/code&gt; 요소의 삽입을 허용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 정렬 된 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 요소 세트는 본질적으로 &lt;code&gt;null&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c185003fa3929e25d997e006634131e9b1d47337" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to a resolved &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 형식 을 지정하고 해결 된 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; 로&lt;/a&gt; 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="b4d4661665beda529a4501a1035be4de025066b7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../text/format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; instance will format any &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and parses to the type specified. The type must be one that is supported by &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt;&lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../../text/format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 인스턴스는 모든 &lt;a href=&quot;../temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 의 형식을 지정하고 지정된 형식으로 구문 분석합니다. 유형은 &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-&quot;&gt; &lt;code&gt;parse(java.lang.CharSequence)&lt;/code&gt; &lt;/a&gt; 가 지원하는 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5dd44d28dfbc6bc47cbc61187f37930a55da27" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance supports the same usages as do the &lt;a href=&quot;../../../lang/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; monitor methods (&lt;a href=&quot;../../../lang/object#wait--&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../lang/object#notify--&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt;) when used with the built-in monitor lock.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스는 내장 모니터 잠금과 함께 사용될 때 &lt;a href=&quot;../../../lang/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 모니터 메소드 ( &lt;a href=&quot;../../../lang/object#wait--&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../lang/object#notify--&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notifyAll--&quot;&gt; &lt;code&gt;notifyAll&lt;/code&gt; &lt;/a&gt; ) 와 동일한 사용법을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="1bc1730d912a2f1b769dce259c025673a7214e32" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 삽입 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7e9e01d3dfa3cb980421cf908b620f48d72c26" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용 하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43da3d7de62b7245f65cab710cfb2f032f89515e" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the &lt;code&gt;Map&lt;/code&gt; in encounter order, using &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator, Supplier)&lt;/code&gt; &lt;/a&gt; 사용 하면 결과가 발생 순서대로 &lt;code&gt;Map&lt;/code&gt; 에 병합 될 필요가없는 경우 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cbd679a1ec8205268de13a97a9624457c2a964" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting &lt;code&gt;Map&lt;/code&gt; collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 결과 &lt;code&gt;Map&lt;/code&gt; 콜렉터 에 요소가 나타나는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function)&lt;/code&gt; &lt;/a&gt; 사용하면 병렬 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac6dd6552e8a0aeddbedc87ca5a64e77ba22719" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시가 아닙니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 다운 스트림 콜렉터에 요소가 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Supplier, Collector)&lt;/code&gt; &lt;/a&gt; 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf8d671c4e4b5aa32fa0703a9603589a87b608" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Collector&lt;/code&gt; is not concurrent. For parallel stream pipelines, the &lt;code&gt;combiner&lt;/code&gt; function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt;&lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt;&lt;/a&gt; may offer better parallel performance.</source>
          <target state="translated">리턴 된 &lt;code&gt;Collector&lt;/code&gt; 가 동시 적이 지 않습니다. 병렬 스트림 파이프 라인의 경우 &lt;code&gt;combiner&lt;/code&gt; 기능은 한 맵에서 다른 맵으로 키를 병합하여 작동하므로 비용이 많이 드는 작업 일 수 있습니다. 요소가 다운 스트림 콜렉터에 표시되는 순서를 보존 할 필요가없는 경우 &lt;a href=&quot;collectors#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-&quot;&gt; &lt;code&gt;groupingByConcurrent(Function, Collector)&lt;/code&gt; &lt;/a&gt; 사용하면 더 나은 병렬 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ddc39787057b4a5d98836cd1d91a3011cd8509" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 의해 지원됩니다 . 반환에 대한 모든 변경 &lt;code&gt;Set&lt;/code&gt; 내부에 영향을 미치는 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 은 물론입니다.</target>
        </trans-unit>
        <trans-unit id="5d4e1626c242857a248f0940fc4963421f11cce0" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal private Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="92eab9cfd3076bb306b67853f4acd835335f8a36" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. Any modification to the returned &lt;code&gt;Set&lt;/code&gt; affects the internal public Credential &lt;code&gt;Set&lt;/code&gt; as well.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 의해 지원됩니다 . 반환 된 &lt;code&gt;Set&lt;/code&gt; 을 수정 하면 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="615020d8b91ea3150d89b8eb5df521518f2bf0e3" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal &lt;code&gt;Principal&lt;/code&gt;&lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject 내부의 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 에 대한 수정 은 내부 &lt;code&gt;Principal&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60e6e37a29504c686a29d93cf1b8a805cadab51b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal private Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal private Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 비공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 개인 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a692bd81d1139698e9955f1301dc1ea4476c6cb" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Set&lt;/code&gt; is not backed by this Subject's internal public Credential &lt;code&gt;Set&lt;/code&gt;. A new &lt;code&gt;Set&lt;/code&gt; is created and returned for each method invocation. Modifications to the returned &lt;code&gt;Set&lt;/code&gt; will not affect the internal public Credential &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 &lt;code&gt;Set&lt;/code&gt; 는이 Subject의 내부 공개 자격 &lt;code&gt;Set&lt;/code&gt; 근거하지 않습니다 . 각 메소드 호출에 대해 새 &lt;code&gt;Set&lt;/code&gt; 가 작성되어 리턴됩니다. 반환 된 &lt;code&gt;Set&lt;/code&gt; 수정 해도 내부 공개 자격 증명 &lt;code&gt;Set&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ee6fed903cbcc5abb5de7f51ad1081371937c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;SourceDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;SourceDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e5de58fd5281c7858b3f0d4c85924e449e2f2d" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TargetDataLine&lt;/code&gt;'s default audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;TargetDataLine&lt;/code&gt; 의 기본 오디오 형식은 형식으로 초기화 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fd9c231706d0da0d4eddb1a0ac608bee0a7ed4e" translate="yes" xml:space="preserve">
          <source>The returned SecureRandom object has not been seeded. To seed the returned object, call the &lt;code&gt;setSeed&lt;/code&gt; method. If &lt;code&gt;setSeed&lt;/code&gt; is not called, the first call to &lt;code&gt;nextBytes&lt;/code&gt; will force the SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">리턴 된 SecureRandom 오브젝트가 시드되지 않았습니다. 리턴 된 오브젝트를 시드하려면 &lt;code&gt;setSeed&lt;/code&gt; 메소드를 호출하십시오 . 경우 &lt;code&gt;setSeed&lt;/code&gt; 호출되지 않습니다, 최초의 호출 &lt;code&gt;nextBytes&lt;/code&gt; 자신을 배정하는 SecureRandom 오브젝트를 강제 할 것이다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4f45b323d8e60fb385aaaddf4bf5212cf5012ca" translate="yes" xml:space="preserve">
          <source>The returned array comprises all the code signers that have signed this entry.</source>
          <target state="translated">리턴 된 배열은이 항목에 서명 한 모든 코드 서명자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="90a2eb89a967b2512d9881060ad43029b93df120" translate="yes" xml:space="preserve">
          <source>The returned array contains the MIDI controller numbers for which the listener will now receive events. Some sequencers might not support controller event notification, in which case the array has a length of 0. Other sequencers might support notification for some controllers but not all. This method may be invoked repeatedly. Each time, the returned array indicates all the controllers that the listener will be notified about, not only the controllers requested in that particular invocation.</source>
          <target state="translated">반환 된 배열에는 리스너가 이제 이벤트를 수신 할 MIDI 컨트롤러 번호가 포함됩니다. 일부 시퀀서는 컨트롤러 이벤트 알림을 지원하지 않을 수 있으며,이 경우 어레이의 길이는 0입니다. 다른 시퀀서는 일부 컨트롤러에 대한 알림을 지원하지만 일부는 지원하지 않을 수 있습니다. 이 메소드는 반복적으로 호출 될 수 있습니다. 매번 반환 된 배열은 특정 호출에서 요청 된 컨트롤러뿐만 아니라 리스너에게 통보 할 모든 컨트롤러를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3624c3e8b713f9750ee56a62c2997bd2cc1b21d9" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanConstructorInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fcde0250fbd9f37a68a63dc986de2a345538306" translate="yes" xml:space="preserve">
          <source>The returned array is a shallow copy of the internal array, which means that it is a copy of the internal array of references to the &lt;code&gt;MBeanParameterInfo&lt;/code&gt; objects but that each referenced &lt;code&gt;MBeanParameterInfo&lt;/code&gt; object is not copied.</source>
          <target state="translated">리턴 된 배열은 내부 배열의 얕은 사본입니다. 즉, &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트 에 대한 내부 참조 배열의 사본 이지만 참조 된 각 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 오브젝트는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6c37647bf61a5b5c430747eb2b5e030dc0e7ee8" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 컬렉션에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 다시 말해서,이 메소드는이 콜렉션이 배열에 의해 지원 되더라도 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7b12233cde488615989699afe78dcad6ed4384" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 배열에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b26c8c7a310fbb9e54174ebdb2dbcf36348363" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드가이 목록을 배열로 지원하더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9957755e8c40fe5adbd7d7d8d5843d2e55923750" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 목록에 대한 참조가 유지되지 않으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e282460816c42a0ccd3dcea485b9239559bb18e" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 큐에 의해 참조되는 배열이 없으므로 &quot;안전&quot;합니다. 즉,이 메소드는 새로운 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e87afccdc8466069c7b753215ae2cacd201fd10" translate="yes" xml:space="preserve">
          <source>The returned array will be &quot;safe&quot; in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array.</source>
          <target state="translated">반환 된 배열은이 세트에 의해 참조되는 배열이 없기 때문에 &quot;안전&quot;합니다. 즉,이 메소드가 배열에 의해 지원 되더라도이 메소드는 새 배열을 할당해야합니다. 따라서 호출자는 반환 된 배열을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8651aa449d701f684570ddf36fba5191566388d6" translate="yes" xml:space="preserve">
          <source>The returned attribute information is limited to runs that contain the current character.</source>
          <target state="translated">리턴 된 속성 정보는 현재 문자가 포함 된 실행으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3d33c31d474f6dd046417604a6a9ae4803e6b9" translate="yes" xml:space="preserve">
          <source>The returned certificate array comprises all the signer certificates that were used to verify this entry. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain are ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).</source>
          <target state="translated">리턴 된 인증 배열은이 항목을 확인하는 데 사용 된 모든 서명자 인증으로 구성됩니다. 각 서명자 인증서 뒤에는 지원 인증서 체인 (비어있을 수 있음)이옵니다. 각 서명자 인증서 및 지원 인증서 체인은 맨 아래에서 순서대로 주문됩니다 (즉, 서명자 인증서가 먼저 있고 (루트) 인증 기관이 마지막에 있음).</target>
        </trans-unit>
        <trans-unit id="61c3a6711385606db98b86cc4dc71d68bdea4436" translate="yes" xml:space="preserve">
          <source>The returned clip must be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioInputStream)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 클립은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioInputStream)&lt;/code&gt; 메서드로 열어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ceb417aa63a35568772d2ba08459a4d0f57ffbee" translate="yes" xml:space="preserve">
          <source>The returned collection does</source>
          <target state="translated">반환 된 컬렉션은</target>
        </trans-unit>
        <trans-unit id="b07c416f52316fbf6c7d40a634719186c13469b3" translate="yes" xml:space="preserve">
          <source>The returned collection will be serializable if the specified collection is serializable.</source>
          <target state="translated">지정된 콜렉션이 직렬화 가능한 경우, 리턴 된 콜렉션은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3be1f1672220475d8271f6e01c1f720a84f08e5b" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable (assuming the specified comparator is also serializable or &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다 (지정된 비교기가 직렬화 가능 또는 &lt;code&gt;null&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="2812de92165ec02fbb836f9148b615e9ccc3b5b2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">반환 된 비교기는 직렬화 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; &lt;code&gt;null&lt;/code&gt; 를 비교할 때 NullPointerException을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77a6f4be0bfa1c8aa5aedc5a42831ad20378a870" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with a null key.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널 키와 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="22bf28f66c9f612e083df0a59239e3c46c04c933" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable and throws &lt;a href=&quot;../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; when comparing an entry with null values.</source>
          <target state="translated">리턴 된 비교기는 직렬화 가능하며 항목을 널값과 비교할 때 &lt;a href=&quot;../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="51644083b4b8fda187f5a628a6258b22d611a598" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is also serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능한 경우, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d69bb8caf8d86905d98a11aab0d0a3baa774bad3" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified comparator is serializable.</source>
          <target state="translated">지정된 비교기가 직렬화 가능하면, 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f0576c7aa360de3b65d8c8efe158571eec213ab2" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function and comparator are both serializable.</source>
          <target state="translated">지정된 함수와 비교기가 모두 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ba917226177854af620439263d809c330c5d69cf" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable if the specified function is also serializable.</source>
          <target state="translated">지정된 함수도 직렬화 가능하면 리턴 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0334b290d5844794dff470460f3065bc09010f74" translate="yes" xml:space="preserve">
          <source>The returned comparator is serializable.</source>
          <target state="translated">반환 된 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c5d33135e5a1f395b41fad98d6b20e99dae320a6" translate="yes" xml:space="preserve">
          <source>The returned era will be a singleton capable of being compared with the constants in &lt;a href=&quot;chrono/isochronology&quot;&gt;&lt;code&gt;IsoChronology&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">반환 된 시대는 &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;chrono/isochronology&quot;&gt; &lt;code&gt;IsoChronology&lt;/code&gt; &lt;/a&gt; 의 상수와 비교할 수있는 싱글 톤 입니다.</target>
        </trans-unit>
        <trans-unit id="685a6e900daf413e8d8765bf083707c3fc12c8e0" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c7747f70640f1e4a45424ed0c1270bbc9549330f" translate="yes" xml:space="preserve">
          <source>The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 다른 달력 시스템의 날짜가 올바르게 변환되도록 ISO의 연대기가 설정되어 있습니다. 재정의 영역이 없으며 &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c3dda27b1c2af94aa2edb7b9c334041c2040aee1" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses &lt;a href=&quot;resolverstyle#SMART&quot;&gt;&lt;code&gt;SMART&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#SMART&quot;&gt; &lt;code&gt;SMART&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="65f23c4bdba155d972d5a5c334ace90811627c2f" translate="yes" xml:space="preserve">
          <source>The returned formatter has no override chronology or zone. It uses the &lt;a href=&quot;resolverstyle#STRICT&quot;&gt;&lt;code&gt;STRICT&lt;/code&gt;&lt;/a&gt; resolver style.</source>
          <target state="translated">반환 된 포맷터에는 재정의 연대기 또는 영역이 없습니다. &lt;a href=&quot;resolverstyle#STRICT&quot;&gt; &lt;code&gt;STRICT&lt;/code&gt; &lt;/a&gt; 리졸버 스타일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="93e620ed0c6b2f581405e4ca186e0d0c26a039f0" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt; providing that the base clock is.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; , 기본 클록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ebf894963bb17de1c19228a9892a378efc764d2" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16aec74c31404fdf24dbc2481edc9947ae28ae7f" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 그것은 동등 &lt;code&gt;system(ZoneId.systemDefault())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e83331df05c75aa0965f68cf383b4fa1ce4775" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. &lt;code&gt;system(ZoneOffset.UTC)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="39695b971886168cd9e28cf54007c2987d52ae31" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofMinutes(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d8edb2d119f60ce6b547f8aeea62c8bb10250e" translate="yes" xml:space="preserve">
          <source>The returned implementation is immutable, thread-safe and &lt;code&gt;Serializable&lt;/code&gt;. It is equivalent to &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt;.</source>
          <target state="translated">돌려 주어진 구현은 불변, thread 세이프 및 &lt;code&gt;Serializable&lt;/code&gt; 입니다. 이것은와 등가이다 &lt;code&gt;tick(system(zone), Duration.ofSeconds(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab8e6a2c1e29941612774d35818b8817f708321" translate="yes" xml:space="preserve">
          <source>The returned index is the largest value</source>
          <target state="translated">반환 된 인덱스는 가장 큰 값입니다</target>
        </trans-unit>
        <trans-unit id="1010f5a375a5d3f29e20face9e80371d4a90f440" translate="yes" xml:space="preserve">
          <source>The returned index is the smallest value</source>
          <target state="translated">반환 된 인덱스는 가장 작은 값입니다</target>
        </trans-unit>
        <trans-unit id="30fb35855f9641f7209a86fa609966716cae03af" translate="yes" xml:space="preserve">
          <source>The returned indexes are limited to the range of the iterator.</source>
          <target state="translated">반환 된 인덱스는 반복자의 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e45bc891e1f438dd01ea7196d9842b794781ae4f" translate="yes" xml:space="preserve">
          <source>The returned instants from &lt;code&gt;Clock&lt;/code&gt; work on a time-scale that ignores leap seconds, as described in &lt;a href=&quot;instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt;. If the implementation wraps a source that provides leap second information, then a mechanism should be used to &quot;smooth&quot; the leap second. The Java Time-Scale mandates the use of UTC-SLS, however clock implementations may choose how accurate they are with the time-scale so long as they document how they work. Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 에서 반환 된 인스턴트 는 &lt;a href=&quot;instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 윤초를 무시하는 시간 단위로 작동합니다 . 구현이 윤초 정보를 제공하는 소스를 래핑하는 경우 윤초를 &quot;부드럽게&quot;하기 위해 메커니즘을 사용해야합니다. Java Time-Scale은 UTC-SLS의 사용을 의무화하지만 시계 구현은 작동 방식을 문서화하는 한 시간 단위로 얼마나 정확한지 선택할 수 있습니다. 따라서 실제로 UTC-SLS 회전을 수행하거나 윤초를 인식 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dfea46346d425f47431ab48a0b9973f65d3a3d0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;빠른 속도입니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d825a47643cf28fa3b87aadae1a13cf5b1f8bb0" translate="yes" xml:space="preserve">
          <source>The returned iterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 반복자는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이 있습니다.&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ef6fd11db72e67c90473d6e296ebd844318cf20" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="dd06f34d84c884510eb2daefd756631c982e6784" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt; methods.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;add&lt;/code&gt; 를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="6c8995a19beeeaa38d931dd04ead46af4bf6aeaf" translate="yes" xml:space="preserve">
          <source>The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">리턴 된 반복자는 반복자가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 반복자를 통과하는 동안 동기화가 필요하지 않습니다. 반복자는 &lt;code&gt;remove&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="b28ef914634dbd42c57b4fb798bc270a1b137343" translate="yes" xml:space="preserve">
          <source>The returned line should be opened with the &lt;code&gt;open(AudioFormat)&lt;/code&gt; or &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.</source>
          <target state="translated">반환 된 줄은 &lt;code&gt;open(AudioFormat)&lt;/code&gt; 또는 &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; 메서드로 합니다.</target>
        </trans-unit>
        <trans-unit id="603df59fcea4e98e66008bfad2caba193eee7e62" translate="yes" xml:space="preserve">
          <source>The returned list consists of language ranges from the given &lt;code&gt;ranges&lt;/code&gt; and their equivalents found in the IANA Language Subtag Registry. For example, if the given &lt;code&gt;ranges&lt;/code&gt; is &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt;, the elements in the list to be returned are:</source>
          <target state="translated">리턴 된 목록은 주어진 &lt;code&gt;ranges&lt;/code&gt; 의 언어 범위 와 IANA 언어 서브 태그 레지스트리에있는 해당 범위로 구성됩니다 . 예를 들어, 주어진 &lt;code&gt;ranges&lt;/code&gt; 가 &lt;code&gt;&quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;&lt;/code&gt; 인 경우 반환되는 목록의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afce95588c0380c39f79771261da47a2d309e9a8" translate="yes" xml:space="preserve">
          <source>The returned list is modifiable so as to facilitate changes to the existing ACL. The &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt;&lt;code&gt;setAcl&lt;/code&gt;&lt;/a&gt; method is used to update the file's ACL attribute.</source>
          <target state="translated">리턴 된 목록은 기존 ACL을 쉽게 변경할 수 있도록 수정할 수 있습니다. &lt;a href=&quot;aclfileattributeview#setAcl-java.util.List-&quot;&gt; &lt;code&gt;setAcl&lt;/code&gt; &lt;/a&gt; 방법은 파일의 ACL 속성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c503093f4e0ea3beb8f9f47ec55e6810f3e4744d" translate="yes" xml:space="preserve">
          <source>The returned list is not necessarily exhaustive. That is, the MBean may have a public constructor that is not in the list. In this case, the MBean server can construct another instance of this MBean's class using that constructor, even though it is not listed here.</source>
          <target state="translated">반환 된 목록이 반드시 완전한 것은 아닙니다. 즉, MBean에는 목록에없는 공용 생성자가있을 수 있습니다. 이 경우, MBean 서버는 여기에 나열되어 있지 않더라도 해당 생성자를 사용하여이 MBean 클래스의 다른 인스턴스를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4ba1a6fc0e1176884c27c61e7f3010f2b892f0" translate="yes" xml:space="preserve">
          <source>The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 목록 반복자가 &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;실패했습니다.&lt;/i&gt;&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca9df76291579b501b3fdfee2f39774c2720a485" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b51e7cf95fea371d30e6037819047e729ec2ba1c" translate="yes" xml:space="preserve">
          <source>The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; if the specified list does.</source>
          <target state="translated">지정된 목록이 직렬화 가능하면 리턴 된 목록은 직렬화 가능합니다. 마찬가지로 반환 된 목록은 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 를 구현합니다. 지정된 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="04550933f42e1b20dd67a722e85a83b892d29e8b" translate="yes" xml:space="preserve">
          <source>The returned map and its collection views may not obey the general contract of the &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">리턴 된 맵 및 해당 콜렉션보기는 &lt;a href=&quot;object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 의 일반 계약을 준수하지 않을 수 있습니다. 메소드 .</target>
        </trans-unit>
        <trans-unit id="bd8d64063c7ed0ea19647d547170466cdf6c7ae7" translate="yes" xml:space="preserve">
          <source>The returned map does not permit null keys or values. Attempting to insert or query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵은 널 키 또는 값을 허용하지 않습니다. null 키 또는 값이 있는지 삽입하거나 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de626c9a4a06c5beb2eb08bc7e1023f6785c4bcc" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="47af6d18a03dd37ca75973b55abf606e91a20528" translate="yes" xml:space="preserve">
          <source>The returned map has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; returns a view of &lt;code&gt;m&lt;/code&gt; essentially equivalent to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">반환 된 맵의 순서는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동일합니다 . &lt;code&gt;m.descendingMap().descendingMap()&lt;/code&gt; 표현식 은 기본적으로 &lt;code&gt;m&lt;/code&gt; 과 동등한 &lt;code&gt;m&lt;/code&gt; 의 뷰를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6919fc63dffbd2b665571fbe3d0e62befa5d6f" translate="yes" xml:space="preserve">
          <source>The returned map implements all optional &lt;a href=&quot;../sortedmap&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; operations</source>
          <target state="translated">리턴 된 맵은 모든 선택적 &lt;a href=&quot;../sortedmap&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; 조작을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e60ce6cdb39e55f6aea0270ae6050c5d468141c" translate="yes" xml:space="preserve">
          <source>The returned map is typically case-sensitive on all platforms.</source>
          <target state="translated">리턴 된 맵은 일반적으로 모든 플랫폼에서 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ebb8ac95b0820624300e6c51aa32adf9bf40ac27" translate="yes" xml:space="preserve">
          <source>The returned map will be serializable if the specified map is serializable.</source>
          <target state="translated">지정된 맵이 직렬화 가능하면 리턴 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3580abdef3f87a6bd80d4bea2b490670bec97aa7" translate="yes" xml:space="preserve">
          <source>The returned map will never contain null keys or values. Attempting to query the presence of a null key or value will throw a &lt;a href=&quot;nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;. Attempting to query the presence of a key or value which is not of type &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;classcastexception&quot;&gt;&lt;code&gt;ClassCastException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 맵에는 널 키 또는 값이 포함되지 않습니다. null 키 또는 값이 있는지 쿼리하려고하면 &lt;a href=&quot;nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형이 아닌 키 또는 값의 존재를 쿼리하려고 하면 &lt;a href=&quot;classcastexception&quot;&gt; &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="186b57fc3142be2ab7c06b068233e86af34426e7" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside its range.</source>
          <target state="translated">돌려 주어지는 맵은 그 범위 외의 키를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="38495ee31c82f624af115d8608382ab49eee4275" translate="yes" xml:space="preserve">
          <source>The returned map will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.</source>
          <target state="translated">돌려 주어진 맵은 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 범위를 벗어난 키를 삽입하거나 엔드 포인트가 범위 밖에있는 서브맵을 구성하려는 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf341b930019b986feaa3025d94588cbf0b07082" translate="yes" xml:space="preserve">
          <source>The returned method handle is equivalent to &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt;.</source>
          <target state="translated">리턴 된 메소드 핸들은 &lt;code&gt;identity(type).bindTo(value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf12e977e77f8c538e96bf14109eaad3316041c8" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the constructor's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">생성자의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 반환 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b84ac4232d79eefcfa3e985c888ae7cb52f78ae" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument. (If the trailing array argument is the only argument, the given receiver value will be bound to it.)</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정 &lt;em&gt;되고&lt;/em&gt; 후행 배열 인수가 유일한 인수가 아닌 경우에만 리턴 된 메소드 핸들은 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 를 갖습니다 . 후행 배열 인수가 유일한 인수이면 지정된 수신자 값이 바인딩됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdb52f5efb367c3a0c6f85b8e5a561c3fd955c91" translate="yes" xml:space="preserve">
          <source>The returned method handle will have &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt; if and only if the method's variable arity modifier bit (&lt;code&gt;0x0080&lt;/code&gt;) is set.</source>
          <target state="translated">메소드의 변수 arity 수정 자 비트 ( &lt;code&gt;0x0080&lt;/code&gt; )가 설정된 경우에만 리턴 된 메소드 핸들에 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;변수 arity&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b799c087978df49d2fe6286478b6ecedece7b2a8" translate="yes" xml:space="preserve">
          <source>The returned navigable map will be serializable if the specified navigable map is serializable.</source>
          <target state="translated">지정된 탐색 가능한지도가 직렬화 가능한 경우 반환 된 탐색 가능한지도는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="63e22369ffd2f4700f3d4c6318fbd029fc94516b" translate="yes" xml:space="preserve">
          <source>The returned navigable set will be serializable if the specified navigable set is serializable.</source>
          <target state="translated">지정된 탐색 가능 세트가 직렬화 가능하면 리턴 된 탐색 가능 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="22109190c7021a569021e7447b7b84963fc23137" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37078f56cceda1a46ec4284d20998d8403b393be" translate="yes" xml:space="preserve">
          <source>The returned number of available bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of usable bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this Java virtual machine.</source>
          <target state="translated">반환 된 사용 가능한 바이트 수는 힌트이지만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 사용 가능한 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 Java 가상 머신 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ec8ab1c6179c271d12fffbe706c3b736240a28" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after the space attributes are obtained. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는 공간 속성을 얻은 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4abb292a819da63fe264f4077cd386242fe657dd" translate="yes" xml:space="preserve">
          <source>The returned number of unallocated bytes is a hint, but not a guarantee, that it is possible to use most or any of these bytes. The number of unallocated bytes is most likely to be accurate immediately after this call. It is likely to be made inaccurate by any external I/O operations including those made on the system outside of this virtual machine. This method makes no guarantee that write operations to this file system will succeed.</source>
          <target state="translated">반환 된 할당되지 않은 바이트 수는 힌트 일 뿐이지 만 이러한 바이트의 대부분 또는 일부를 사용할 수 있다는 보장은 없습니다. 할당되지 않은 바이트 수는이 호출 직후에 정확할 가능성이 높습니다. 이 가상 시스템 외부의 시스템에서 수행 된 작업을 포함하여 외부 I / O 작업으로 인해 정확하지 않을 수 있습니다. 이 방법은이 파일 시스템에 대한 쓰기 작업이 성공한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0e131d9f7c12cd49d0e3def257a8126d1849784" translate="yes" xml:space="preserve">
          <source>The returned object may be modified using ordinary &lt;a href=&quot;../util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; operations. These modifications will be visible to subprocesses started via the &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Two &lt;code&gt;ProcessBuilder&lt;/code&gt; instances always contain independent process environments, so changes to the returned map will never be reflected in any other &lt;code&gt;ProcessBuilder&lt;/code&gt; instance or the values returned by &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt;&lt;code&gt;System.getenv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 일반 &lt;a href=&quot;../util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 수정할 수 있습니다 . 이러한 수정 사항은 &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시작된 하위 프로세스에 표시됩니다 . 두 개의 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스는 항상 독립적 인 프로세스 환경을 포함하므로 리턴 된 맵에 대한 변경 사항은 다른 &lt;code&gt;ProcessBuilder&lt;/code&gt; 인스턴스 또는 &lt;a href=&quot;system#getenv-java.lang.String-&quot;&gt; &lt;code&gt;System.getenv&lt;/code&gt; 가&lt;/a&gt; 리턴 한 값에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10758f1a6b50ea2e6c130aeb5c0b77e0c66fbab0" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메서드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6661a89d64621663c740fc5bd7a203767c62c2b9" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/serversocket&quot;&gt;&lt;code&gt;ServerSocket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/serversocket&quot;&gt; &lt;code&gt;ServerSocket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4f4ca2ce4cf8222c87458553d37b2d17a03fa4b" translate="yes" xml:space="preserve">
          <source>The returned object will not declare any public methods that are not declared in the &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 클래스 에서 선언되지 않은 공개 메소드를 선언하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0472b263351c4d126d5ea013a83e7af5df81b296" translate="yes" xml:space="preserve">
          <source>The returned parameter object must be initialized via a call to &lt;code&gt;init&lt;/code&gt;, using an appropriate parameter specification or parameter encoding.</source>
          <target state="translated">리턴 된 매개 변수 오브젝트는 적절한 매개 변수 스펙 또는 매개 변수 인코딩을 사용하여 &lt;code&gt;init&lt;/code&gt; 호출을 통해 초기화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4df3bd992ed9cf08b8043aa23cc9ef35cfb0d899" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 암호를 초기화하는 데 사용 된 것과 동일하거나이 암호에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 암호 구현에 의해 사용되는 기본 및 무작위 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752ffb538b7e9750a71c7c4cf9e60e4eee90c425" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature engine, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature engine requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명 엔진을 초기화하는 데 사용 된 것과 동일하거나,이 서명 엔진에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45bd612510ae15a9437f55deeaebac11cc09c8c" translate="yes" xml:space="preserve">
          <source>The returned parameters may be the same that were used to initialize this signature, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature requires algorithm parameters but was not initialized with any.</source>
          <target state="translated">리턴 된 매개 변수는이 서명을 초기화하는 데 사용 된 것과 동일하거나,이 서명에 알고리즘 매개 변수가 필요하지만 초기화되지 않은 경우 기본 서명 구현에서 사용되는 기본 및 무작위로 생성 된 매개 변수 값의 조합을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a706d9a79d6d8447286cc51c0dbac2857f3fb0" translate="yes" xml:space="preserve">
          <source>The returned path string uses the default name &lt;a href=&quot;filesystem#getSeparator--&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt; to separate names in the path.</source>
          <target state="translated">반환 된 경로 문자열은 기본 이름 &lt;a href=&quot;filesystem#getSeparator--&quot;&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로에서 이름을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="adf31a0a552eb3e572f95b3b75985ef817599500" translate="yes" xml:space="preserve">
          <source>The returned period is immutable and thread-safe.</source>
          <target state="translated">반환 된 기간은 변경 불가능하고 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1b4afe410c4184d3ee0067023a81a530b2ac3" translate="yes" xml:space="preserve">
          <source>The returned queue will be serializable if the specified queue is serializable.</source>
          <target state="translated">지정된 큐가 직렬화 가능하면 리턴 된 큐는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4e3b490a0b68921e5f2d54982954ae5db0e3015e" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;a href=&quot;../collections#reverseOrder-java.util.Comparator-&quot;&gt; &lt;code&gt;Collections.reverseOrder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3e0a450b88e9e02addbc6c115aa54b248453093" translate="yes" xml:space="preserve">
          <source>The returned set has an ordering equivalent to &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt;. The expression &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; returns a view of &lt;code&gt;s&lt;/code&gt; essentially equivalent to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;&lt;a href=&quot;collections#reverseOrder-java.util.Comparator-&quot;&gt;&lt;code&gt;Collections.reverseOrder&lt;/code&gt;&lt;/a&gt;(comparator())&lt;/code&gt; 와 동등한 순서를 갖습니다 . 식 &lt;code&gt;s.descendingSet().descendingSet()&lt;/code&gt; 의 뷰를 반환 &lt;code&gt;s&lt;/code&gt; 과 본질적으로 동등한 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220883a1d6410f4ba7ef330e4aa7ccfbc79da085" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the flags.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 플래그 사본입니다.</target>
        </trans-unit>
        <trans-unit id="c5cb0f1cda390591cbbfdd982f4f651a475f6f50" translate="yes" xml:space="preserve">
          <source>The returned set is a modifiable copy of the permissions.</source>
          <target state="translated">리턴 된 세트는 수정 가능한 권한의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="130457322e83b65d75a40390b0669abbd4a7d5d4" translate="yes" xml:space="preserve">
          <source>The returned set is not backed by the &lt;code&gt;Properties&lt;/code&gt; object. Changes to this &lt;code&gt;Properties&lt;/code&gt; are not reflected in the set, or vice versa.</source>
          <target state="translated">리턴 된 세트는 &lt;code&gt;Properties&lt;/code&gt; 오브젝트에 의해 지원되지 않습니다 . 이 &lt;code&gt;Properties&lt;/code&gt; 대한 변경 사항 은 세트에 반영되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3e9bbc6259b7b305420033286153988e609e2dfe" translate="yes" xml:space="preserve">
          <source>The returned set will be serializable if the specified set is serializable.</source>
          <target state="translated">지정된 세트가 직렬화 가능한 경우, 리턴 된 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6add43a3d565273146ff21959e52c46e37133f8b" translate="yes" xml:space="preserve">
          <source>The returned set will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; on an attempt to insert an element outside its range.</source>
          <target state="translated">돌려 주어진 세트는 그 범위 외의 요소를 삽입하려고 하면 (자) &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="36ef4c7e56e059e7cc6ecb7f25266519a33c9874" translate="yes" xml:space="preserve">
          <source>The returned socket is configured using the socket options established for this factory, and is set to use server mode when handshaking (see &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt;&lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">리턴 된 소켓은이 팩토리에 대해 설정된 소켓 옵션을 사용하여 구성되며 핸드 쉐이킹시 서버 모드를 사용하도록 설정됩니다 ( &lt;a href=&quot;sslsocket#setUseClientMode-boolean-&quot;&gt; &lt;code&gt;SSLSocket.setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f90f95fa6a4a814b30bb64a73971367f5cea036" translate="yes" xml:space="preserve">
          <source>The returned sorted map will be serializable if the specified sorted map is serializable.</source>
          <target state="translated">지정된 정렬 맵이 직렬화 가능하면 리턴 된 정렬 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b2dfe035ba12d83875affd06b6d4712350f778" translate="yes" xml:space="preserve">
          <source>The returned sorted set will be serializable if the specified sorted set is serializable.</source>
          <target state="translated">지정된 정렬 세트가 직렬화 가능하면 리턴 된 정렬 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0daff3577dae1f88c6b38a7fd8e4b3abd97adeb1" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify &lt;code&gt;IMMUTABLE&lt;/code&gt;; if the array data is considered to have an an encounter order, specify &lt;code&gt;ORDERED&lt;/code&gt;). The method &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt; can often be used instead, which returns a spliterator that reports &lt;code&gt;SIZED&lt;/code&gt;, &lt;code&gt;SUBSIZED&lt;/code&gt;, &lt;code&gt;IMMUTABLE&lt;/code&gt;, and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator 항상 특성 보고서 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. 예를 들어, 배열이 더 이상 수정되지 않는 것으로 알려진 경우 &lt;code&gt;IMMUTABLE&lt;/code&gt; 을 지정 하십시오. 배열 데이터가 발생 순서로 간주되는 경우 &lt;code&gt;ORDERED&lt;/code&gt; 를 지정 하십시오. 메소드 &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; spliterator보고 그 반환 자주 대신 사용할 수 있습니다, &lt;code&gt;SIZED&lt;/code&gt; , &lt;code&gt;SUBSIZED&lt;/code&gt; , &lt;code&gt;IMMUTABLE&lt;/code&gt; 는 한 &lt;code&gt;ORDERED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1d245446dcb633ef538a6c950f3a6bc13a27b6" translate="yes" xml:space="preserve">
          <source>The returned spliterator always reports the characteristics &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify &lt;code&gt;IMMUTABLE&lt;/code&gt; and &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">반환 spliterator은 항상 특성을보고 &lt;code&gt;SIZED&lt;/code&gt; 및 &lt;code&gt;SUBSIZED&lt;/code&gt; . 호출자는 스플리터가보고 할 추가 특성을 제공 할 수 있습니다. &lt;code&gt;IMMUTABLE&lt;/code&gt; 및 &lt;code&gt;ORDERED&lt;/code&gt; 를 추가로 지정하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="448ee2ba55f195d0baa345b55208a1fe5ff52b70" translate="yes" xml:space="preserve">
          <source>The returned spliterator is &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 스플리터는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;약하게 일관성이&lt;/i&gt;&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f6fef10c7c1d7faa5f4bb6d1cad19315fbac4b" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;../../io/reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the try-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">반환 된 스트림은 &lt;a href=&quot;../../io/reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; 를&lt;/a&gt; 캡슐화합니다. . 파일 시스템 자원을 적시에 폐기해야하는 경우 , 스트림 조작이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 try-with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddd602fbd78f0cc6b843db33e616208261076d4" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates a &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed.</source>
          <target state="translated">리턴 된 스트림은 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화합니다 . 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d94964406c818caac85b35a4e7cb8afabde4f74" translate="yes" xml:space="preserve">
          <source>The returned stream encapsulates one or more &lt;a href=&quot;directorystream&quot;&gt;&lt;code&gt;DirectoryStream&lt;/code&gt;&lt;/a&gt;s. If timely disposal of file system resources is required, the &lt;code&gt;try&lt;/code&gt;-with-resources construct should be used to ensure that the stream's &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked after the stream operations are completed. Operating on a closed stream will result in an &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 스트림은 하나 이상의 &lt;a href=&quot;directorystream&quot;&gt; &lt;code&gt;DirectoryStream&lt;/code&gt; 을&lt;/a&gt; 캡슐화 합니다. 파일 시스템 자원을 적시에 폐기 해야하는 경우 , 스트림 작업이 완료된 후 스트림의 &lt;a href=&quot;../../util/stream/basestream#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되도록 &lt;code&gt;try&lt;/code&gt; -with-resources 구문을 사용해야합니다 . 닫힌 스트림에서 작동하면 &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3477259359f64c96ff7a386ac7319ab96e368d" translate="yes" xml:space="preserve">
          <source>The returned string corresponds to the single-string representation of a Kerberos Principal name as specified in Section 2.1 of &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964&lt;/a&gt;.</source>
          <target state="translated">리턴 된 문자열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1964.txt&quot;&gt;RFC 1964의&lt;/a&gt; 2.1 절에 지정된 Kerberos 프린시 펄 이름의 단일 문자열 표현에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="655c3437b11ed617a579abf2fa9ff34b511b4b98" translate="yes" xml:space="preserve">
          <source>The returned value consists of a quote ('&quot;'), a sequence of characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;, and another quote. Characters in &lt;code&gt;s&lt;/code&gt; appear unchanged within the returned value except:</source>
          <target state="translated">반환 된 값은 &lt;code&gt;s&lt;/code&gt; 의 문자에 해당하는 일련의 문자 인 따옴표 ( ' &quot;')로 구성됩니다. 및 다른 따옴표로 구성됩니다. &lt;code&gt;s&lt;/code&gt; 의 문자는 다음을 제외하고 반환 된 값 내에서 변경되지 않은 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e492071d6dc92885ae84e7ac0ea668a268c3161b" translate="yes" xml:space="preserve">
          <source>The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of the buffer's data by the time that an invocation of this method returns.</source>
          <target state="translated">기본 오퍼레이팅 시스템이이 메소드 호출이 리턴 될 때까지 일부 버퍼 데이터를 페이징 아웃했을 수 있으므로 리턴 된 값은 보증이 아니라 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="87f3edcf1a031a34eab7ff35463ec7ac1c19de38" translate="yes" xml:space="preserve">
          <source>The returned value may be unmodifiable. If it is modifiable, changing it has no effect on this ObjectName.</source>
          <target state="translated">반환 된 값을 수정할 수 없습니다. 수정 가능한 경우 변경해도이 ObjectName에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ea1bfc4ee9b99c8f427dd634732ade255abe11d" translate="yes" xml:space="preserve">
          <source>The returned value may or may not be identical to &lt;code&gt;name&lt;/code&gt;. Calling this method twice with the same parameters may return the same object or two equal but not identical objects.</source>
          <target state="translated">반환 값은 &lt;code&gt;name&lt;/code&gt; 과 같거나 같지 않을 수 있습니다 . 동일한 매개 변수를 사용하여이 메소드를 두 번 호출하면 동일한 오브젝트 또는 동일하지만 동일하지 않은 두 오브젝트를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40fbf63a5d2b277e35cf6ac3daf6ae7ec5474ac" translate="yes" xml:space="preserve">
          <source>The returned versions remain available and valid for the lifetime of the application. A dynamic provider may increase the set of versions as more data becomes available.</source>
          <target state="translated">반환 된 버전은 응용 프로그램 수명 동안 유효하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 버전 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fa82a55b240bd660f3e3d8cef39a1191e27f3f" translate="yes" xml:space="preserve">
          <source>The returned zone IDs remain available and valid for the lifetime of the application. A dynamic provider may increase the set of IDs as more data becomes available.</source>
          <target state="translated">반환 된 영역 ID는 응용 프로그램 수명 동안 사용 가능하고 유효합니다. 더 많은 데이터를 사용할 수있게되면 동적 공급자가 ID 집합을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5b7000f5b21a055cbac4854384a1e8094660e0" translate="yes" xml:space="preserve">
          <source>The returns a normalized &lt;code&gt;ZoneId&lt;/code&gt; that can be used in place of this ID. The result will have &lt;code&gt;ZoneRules&lt;/code&gt; equivalent to those returned by this object, however the ID returned by &lt;code&gt;getId()&lt;/code&gt; may be different.</source>
          <target state="translated">이 ID 대신 사용할 수 있는 정규화 된 &lt;code&gt;ZoneId&lt;/code&gt; 를 반환합니다 . 결과는 이 객체가 리턴 한 것과 동일한 &lt;code&gt;ZoneRules&lt;/code&gt; 를 가지지 만 &lt;code&gt;getId()&lt;/code&gt; 가 리턴 한 ID는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bbd913f2a35dc1f4e96953ef2e235b576a9f17" translate="yes" xml:space="preserve">
          <source>The reverberation parameters provided by &lt;code&gt;ReverbType&lt;/code&gt; consist of the delay time and intensity of early reflections, the delay time and intensity of late reflections, and an overall decay time. Early reflections are the initial individual low-order reflections of the direct signal off the surfaces in the room. The late Reflections are the dense, high-order reflections that characterize the room's reverberation. The delay times for the start of these two reflection types give the listener a sense of the overall size and complexity of the room's shape and contents. The larger the room, the longer the reflection delay times. The early and late reflections' intensities define the gain (in decibels) of the reflected signals as compared to the direct signal. These intensities give the listener an impression of the absorptive nature of the surfaces and objects in the room. The decay time defines how long the reverberation takes to exponentially decay until it is no longer perceptible (&quot;effective zero&quot;). The larger and less absorbent the surfaces, the longer the decay time.</source>
          <target state="translated">에 의해 제공되는 잔향 파라미터 &lt;code&gt;ReverbType&lt;/code&gt; 이초기 반사의 지연 시간 및 강도, 늦은 반사의 지연 시간 및 강도 및 전체 감쇠 시간으로 구성됩니다. 초기 반사는 실내 표면에서 직접 신호의 초기 개별 하위 반사입니다. 늦은 반사는 방의 잔향을 특징 짓는 조밀하고 고차 반사입니다. 이 두 가지 반사 유형의 시작에 대한 지연 시간은 청취자에게 방의 모양과 내용의 전체 크기와 복잡성을 감지합니다. 방이 클수록 반사 지연 시간이 길어집니다. 초기 및 후기 반사 강도는 직접 신호와 비교하여 반사 된 신호의 게인 (데시벨)을 정의합니다. 이러한 강도는 청취자에게 방의 표면과 물체의 흡수성에 대한 인상을줍니다.감쇠 시간은 잔향이 더 이상 감지 할 수 없을 때까지 ( &quot;유효 제로&quot;) 지수 적으로 감쇠하는 데 걸리는 시간을 정의합니다. 표면의 흡수가 클수록 감쇠 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="2c7630f4923d39844ce7c44d0bac8d9004f68f3b" translate="yes" xml:space="preserve">
          <source>The reverse mapping is illustrated by the following change to the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface:</source>
          <target state="translated">리버스 맵핑은 &lt;code&gt;ModuleMXBean&lt;/code&gt; 인터페이스 에 대한 다음 변경으로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="4492356e6ba71c3c852cf9939e4f74a8d7a573fe" translate="yes" xml:space="preserve">
          <source>The revocation status of the certificate could not be determined.</source>
          <target state="translated">인증서의 해지 상태를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="315fe5d039365e7227ec2a4b72b363b039df2bd0" translate="yes" xml:space="preserve">
          <source>The root class from which all event state objects shall be derived.</source>
          <target state="translated">모든 이벤트 상태 객체가 파생되는 루트 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e57f0a87b56114c25a3425b649a0fc72c9816ae3" translate="yes" xml:space="preserve">
          <source>The root interface in the</source>
          <target state="translated">의 루트 인터페이스</target>
        </trans-unit>
        <trans-unit id="59bb7a92b878735bfc6bdf6731b3391ad71122f8" translate="yes" xml:space="preserve">
          <source>The root node has a node name of the empty string (&quot;&quot;). Every other node has an arbitrary node name, specified at the time it is created. The only restrictions on this name are that it cannot be the empty string, and it cannot contain the slash character ('/').</source>
          <target state="translated">루트 노드에는 빈 문자열 ( &quot;&quot;)의 노드 이름이 있습니다. 다른 모든 노드에는 생성시 지정된 임의의 노드 이름이 있습니다. 이 이름에 대한 유일한 제한 사항은 빈 문자열이 될 수 없으며 슬래시 문자 ( '/')를 포함 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c4a2a95c5adac20299823e2ab805439c46a7560" translate="yes" xml:space="preserve">
          <source>The root node has an absolute path name of &lt;code&gt;&quot;/&quot;&lt;/code&gt;. Children of the root node have absolute path names of &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</source>
          <target state="translated">루트 노드의 절대 경로 이름은 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 입니다. 루트 노드의 자식에는 절대 경로 이름이 &lt;code&gt;&quot;/&quot; + &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6f015d10efdbb0ad4a1e372a60c869566bb49e0" translate="yes" xml:space="preserve">
          <source>The root object is completely restored when all of its fields and the objects it references are completely restored. At this point the object validation callbacks are executed in order based on their registered priorities. The callbacks are registered by objects (in the readObject special methods) as they are individually restored.</source>
          <target state="translated">루트 오브젝트는 모든 필드와 참조하는 오브젝트가 완전히 복원되면 완전히 복원됩니다. 이 시점에서 객체 유효성 검사 콜백은 등록 된 우선 순위에 따라 순서대로 실행됩니다. 콜백은 개별적으로 복원 될 때 객체 (readObject 특수 메소드에서)에 의해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="638fc291740e16e3557281ff224cfb954c40e4a5" translate="yes" xml:space="preserve">
          <source>The rules about the first class defined in a package determining the set of certificates for the package, and the restrictions on class names are identical to those specified in the documentation for &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지에 대한 인증서 세트를 결정하는 패키지에 정의 된 첫 번째 클래스에 대한 규칙 및 클래스 이름에 대한 제한은 &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-java.security.ProtectionDomain-&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int, ProtectionDomain)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 지정된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6d45a10a6e24eaa7c3cdfde29bd66f6b11f5bc37" translate="yes" xml:space="preserve">
          <source>The rules are loaded via &lt;a href=&quot;zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt; using a &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. The same rules may be shared internally between multiple zone IDs.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 를 통해로드됩니다 . 여러 구역 ID간에 ​​동일한 규칙이 내부적으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c558d54ff2e89b5ae0559dc27450ddadbb740a9" translate="yes" xml:space="preserve">
          <source>The rules are supplied by &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. An advanced provider may support dynamic updates to the rules without restarting the Java Runtime. If so, then the result of this method may change over time. Each individual call will be still remain thread-safe.</source>
          <target state="translated">규칙은 &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; 에서&lt;/a&gt; 제공합니다 . 고급 공급자는 Java 런타임을 다시 시작하지 않고도 규칙에 대한 동적 업데이트를 지원할 수 있습니다. 그렇다면이 방법의 결과는 시간이 지남에 따라 변경 될 수 있습니다. 각 개별 통화는 여전히 스레드 안전 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1bccb89406bfb2d00bc457815b4e62d2470b7af9" translate="yes" xml:space="preserve">
          <source>The rules defining how the zone offset varies for a single time-zone.</source>
          <target state="translated">단일 시간대에 대한 영역 오프셋의 변화를 정의하는 규칙.</target>
        </trans-unit>
        <trans-unit id="1b49d1af7b23bfa9889a2696229a5d15447e0c34" translate="yes" xml:space="preserve">
          <source>The rules for &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; collectively define the notion of a &lt;em&gt;getter&lt;/em&gt;. The rule for &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; defines the notion of a &lt;em&gt;setter&lt;/em&gt;.</source>
          <target state="translated">규칙은 &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 하고 &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 집합 적 개념 정의 &lt;em&gt;게터를&lt;/em&gt; . 의 규칙 &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; a의 개념 정의 &lt;em&gt;세터&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="23679fbbad04df1e812f689c70ce1d6ec4726cea" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field retaining the week-of-week-based-year and day-of-week, unless the week number it too large for the target year. In that case, the week is set to the last week of the year with the same day-of-week.</source>
          <target state="translated">더하기 규칙은 주 번호가 너무 크지 않은 한 주별 요일 및 요일을 유지하는 주별 필드의 기존 값에 요일 수를 추가합니다. 목표 연도. 이 경우주는 같은 요일을 사용하여 마지막 주로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe755e8390c62eea10e1546677bdab04050afb0" translate="yes" xml:space="preserve">
          <source>The rules for addition add the number of week-based-years to the existing value for the week-based-year field. If the resulting week-based-year only has 52 weeks, then the date will be in week 1 of the following week-based-year.</source>
          <target state="translated">추가 규칙은 주별 연도 수를 주별 연도 필드의 기존 값에 추가합니다. 결과 주별 연도에 52 주만있는 경우 날짜는 다음 주 기반 연도의 1 주일입니다.</target>
        </trans-unit>
        <trans-unit id="b8227871731be6c3964a85ded8d67582566b32f1" translate="yes" xml:space="preserve">
          <source>The rules for using quotes within message format patterns unfortunately have shown to be somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle source files) which strings will be processed by &lt;code&gt;MessageFormat&lt;/code&gt;. Note that localizers may need to use single quotes in translated strings where the original version doesn't have them.</source>
          <target state="translated">불행히도 메시지 형식 패턴 내에서 따옴표를 사용하는 규칙은 다소 혼란스러운 것으로 나타났습니다. 특히 작은 따옴표를 두 배로 늘릴 필요가 있는지 여부는 로컬 라이저에게 분명하지 않습니다. 로컬 라이저에게 규칙에 대해 알리고 (예를 들어, 자원 번들 소스 파일에 주석을 사용하여) &lt;code&gt;MessageFormat&lt;/code&gt; 에서 처리 할 문자열을 알려 주십시오. 로컬 라이저는 번역본에 작은 따옴표를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38de80f84a46f228ca25c1f0d5e10459bf313f19" translate="yes" xml:space="preserve">
          <source>The rules model all the historic and future transitions for a time-zone. &lt;a href=&quot;zoneoffsettransition&quot;&gt;&lt;code&gt;ZoneOffsetTransition&lt;/code&gt;&lt;/a&gt; is used for known transitions, typically historic. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt;&lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt;&lt;/a&gt; is used for future transitions that are based on the result of an algorithm.</source>
          <target state="translated">규칙은 시간대에 대한 모든 과거 및 미래 전환을 모델링합니다. &lt;a href=&quot;zoneoffsettransition&quot;&gt; &lt;code&gt;ZoneOffsetTransition&lt;/code&gt; &lt;/a&gt; 은 일반적으로 기록 된 알려진 전환에 사용됩니다. &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt; &lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt; &lt;/a&gt; 은 알고리즘 결과를 기반으로하는 향후 전환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dca1ae5cccdb05f3a9c9df600b491c9af1bbd005" translate="yes" xml:space="preserve">
          <source>The rules on special characters and quoting apply regardless of which constructor is used to make an ObjectName.</source>
          <target state="translated">특수 문자 및 인용에 대한 규칙은 ObjectName을 만드는 데 사용되는 생성자에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1083994538afe151cee646e2eddf1109ecd48eef" translate="yes" xml:space="preserve">
          <source>The rules provide the functionality associated with a time-zone, such as finding the offset for a given instant or local date-time.</source>
          <target state="translated">규칙은 특정 인스턴트 또는 현지 날짜-시간의 오프셋 찾기와 같은 시간대와 관련된 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a48b9196407480649d1d001e180f9ae21afeae3" translate="yes" xml:space="preserve">
          <source>The rules used to interpret an &lt;code&gt;ObservedAttribute&lt;/code&gt; like &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; are as follows. Suppose the string is</source>
          <target state="translated">&lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 와 같은 &lt;code&gt;ObservedAttribute&lt;/code&gt; 를 해석하는 데 사용되는 규칙 은 다음과 같습니다. 문자열이</target>
        </trans-unit>
        <trans-unit id="b9da9e1a0bb979727268d68de18fe949fd2aa76a" translate="yes" xml:space="preserve">
          <source>The rules will always return this offset when queried. The implementation class is immutable, thread-safe and serializable.</source>
          <target state="translated">규칙은 쿼리시 항상이 오프셋을 반환합니다. 구현 클래스는 변경 불가능하고 스레드로부터 안전하며 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a0b7df0e9c02bba95c1b1a33d5e13601bd0ce3f8" translate="yes" xml:space="preserve">
          <source>The same call site may be used in several places at once.</source>
          <target state="translated">동일한 통화 사이트를 한 번에 여러 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28bec6c576b1271de1ae3d70fc04df24e271a729" translate="yes" xml:space="preserve">
          <source>The same conversions are allowed as for &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandle.asType&lt;/code&gt;&lt;/a&gt;, and some additional conversions are also applied if those conversions fail. Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied if possible, before or instead of any conversions done by &lt;code&gt;asType&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandle.asType&lt;/code&gt; &lt;/a&gt; 과 동일한 변환이 허용되며 이러한 변환이 실패하면 일부 추가 변환도 적용됩니다. &lt;em&gt;T0&lt;/em&gt; , &lt;em&gt;T1&lt;/em&gt; 유형이 주어지면 가능한 경우 &lt;code&gt;asType&lt;/code&gt; 으로 수행되는 변환 전에 또는 대신 다음 변환 중 하나가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3156cf800cbaf487594e90d4f19f68e8ba277657" translate="yes" xml:space="preserve">
          <source>The same listener object may be added more than once, and will be called as many times as it is added. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너 객체는 두 번 이상 추가 될 수 있으며 추가 된 횟수만큼 호출됩니다. &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="791680086f6d9e78094100fb9300338027ea15fa" translate="yes" xml:space="preserve">
          <source>The same naming conventions are applied to the methods in an MXBean as in a Standard MBean:</source>
          <target state="translated">표준 MBean에서와 동일한 이름 지정 규칙이 MXBean의 메소드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="681f3cced20ba9e0fb93240854ee9634fa1a6146" translate="yes" xml:space="preserve">
          <source>The same output can be generated with this code, which uses a regular expression to parse all four tokens at once:</source>
          <target state="translated">이 코드를 사용하여 동일한 출력을 생성 할 수 있습니다. 정규식을 사용하여 4 개의 토큰을 한 번에 모두 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7706c997f0206204d48e6784227fbc2dcd70a39c" translate="yes" xml:space="preserve">
          <source>The same rules are used for locating the configuration properties as are used at startup. So normally the logging properties will be re-read from the same file that was used at startup.</source>
          <target state="translated">시작시 사용되는 것과 동일한 규칙이 구성 특성을 찾는 데 사용됩니다. 따라서 일반적으로 로깅 특성은 시작시 사용한 동일한 파일에서 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="40c696d758a9065648ff0c79befb43bf73945edb" translate="yes" xml:space="preserve">
          <source>The same value</source>
          <target state="translated">같은 가치</target>
        </trans-unit>
        <trans-unit id="66abdaa3d456aeedbf328a69ececa50ab9fd015c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default chrominance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 색차 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 색차 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="1cb7bb906bae31a02cfce6b8aa3fb45b84e3040c" translate="yes" xml:space="preserve">
          <source>The sample chrominance quantization table given in the JPEG specification, table K.2. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.2에 주어진 샘플 색차 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e37dceb33c264c204dc116d8ce75114c90f4c7a3" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1, with all elements divided by 2. According to the specification, these values produce &quot;very good&quot; quality output. This is the table usually used for &quot;visually lossless&quot; encoding, and is the default luminance table used if the default tables and quality settings are used.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블은 모든 요소를 ​​2로 나눈 값입니다. 사양에 따라이 값은 &quot;매우 우수한&quot;품질 출력을 생성합니다. 이 테이블은 일반적으로 &quot;시각적 손실없는&quot;인코딩에 사용되는 테이블이며 기본 테이블 및 품질 설정을 사용하는 경우 사용되는 기본 광도 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="41d6745b125ca8d196d6a79815800d21e82cdffb" translate="yes" xml:space="preserve">
          <source>The sample luminance quantization table given in the JPEG specification, table K.1. According to the specification, these values produce &quot;good&quot; quality output.</source>
          <target state="translated">JPEG 사양, 표 K.1에 주어진 샘플 휘도 양자화 테이블. 사양에 따르면이 값은 &quot;양호한&quot;품질 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b999ec10517f908ef6af8dfcfecb7806f54e48fb" translate="yes" xml:space="preserve">
          <source>The scale of the returned &lt;code&gt;BigDecimal&lt;/code&gt; will be the number of digits in the fraction, or zero if the string contains no decimal point, subject to adjustment for any exponent; if the string contains an exponent, the exponent is subtracted from the scale. The value of the resulting scale must lie between &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; and &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, inclusive.</source>
          <target state="translated">리턴 된 &lt;code&gt;BigDecimal&lt;/code&gt; 의 스케일은 분수의 자릿수이거나 문자열에 소수점이없는 경우 0이됩니다. 지수에 따라 조정됩니다. 문자열에 지수가 포함되어 있으면 지수에서 지수를 뺍니다. 결과 스케일의 값은 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; ~ &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 사이 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="7396cf813336a30d0a1bab52aed3246ae5a6aefb" translate="yes" xml:space="preserve">
          <source>The scanner can also use delimiters other than whitespace. This example reads several items in from a string:</source>
          <target state="translated">스캐너는 공백 이외의 구분 기호를 사용할 수도 있습니다. 이 예제는 문자열에서 여러 항목을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a4947ea8b0c611076ba187f044654968e3ab9ec3" translate="yes" xml:space="preserve">
          <source>The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All &quot;try&quot; methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any &quot;try&quot; method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed.</source>
          <target state="translated">StampedLock의 스케쥴링 정책은 독자보다 독자를 선호하지 않으며 그 반대도 마찬가지입니다. 모든 &quot;시도&quot;방법은 최선의 노력이며 일정이나 공정성 정책을 반드시 준수하지는 않습니다. 잠금을 획득하거나 변환하기위한 &quot;시도&quot;방법에서 0을 반환해도 잠금 상태에 대한 정보는 없습니다. 후속 호출이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb86dfd7dd2cb7c7dabbe5b9afa0ca86ee85837" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding.</source>
          <target state="translated">URI의 스킴 구성 요소는 이스케이프 된 옥텟을 포함 할 수 없으므로이 메소드는 디코딩을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03f4421d79610120278b2b05c4ad70853ae92f0a" translate="yes" xml:space="preserve">
          <source>The scheme component of a URI, if defined, only contains characters in the</source>
          <target state="translated">URI의 스킴 구성 요소 (정의 된 경우)에는</target>
        </trans-unit>
        <trans-unit id="552a02db11e3a965b8192d8915eaba47a77bf1a7" translate="yes" xml:space="preserve">
          <source>The scheme component of this URI, or &lt;code&gt;null&lt;/code&gt; if the scheme is undefined</source>
          <target state="translated">이 URI 스킴 컴퍼넌트 . 스킴이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347507e3914af1d8c1191601bb5aa53cb19b0fe4" translate="yes" xml:space="preserve">
          <source>The scheme-specific part of a URI only contains legal URI characters.</source>
          <target state="translated">URI의 체계 별 부분에는 유효한 URI 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="786e33a9934f50290255272a6f6e5a002f9a8ca7" translate="yes" xml:space="preserve">
          <source>The scope that is printed out may be a filename, in which case it may convey local system information. For example, here's a sample printout of an identity named &quot;carol&quot;, who is marked not trusted in the user's identity database:</source>
          <target state="translated">인쇄되는 범위는 파일 이름 일 수 있으며,이 경우 로컬 시스템 정보를 전달할 수 있습니다. 예를 들어, 다음은 사용자의 신원 데이터베이스에서 신뢰할 수없는 것으로 표시된 &quot;carol&quot;이라는 신원의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b44f515dc7972f5ec50a61a5a4b5d182cf8f1fa1" translate="yes" xml:space="preserve">
          <source>The scope, returningObj flag, and returningAttributes flag from the search controls &lt;code&gt;ctls&lt;/code&gt; are used to control the selection of objects that the listener is interested in, and determines what information is returned in the eventual &lt;code&gt;NamingEvent&lt;/code&gt; object. Note that the requested information to be returned might not be present in the &lt;code&gt;NamingEvent&lt;/code&gt; object if they are unavailable or could not be obtained by the service provider or service.</source>
          <target state="translated">검색 제어 &lt;code&gt;ctls&lt;/code&gt; 에서 scope, returningObj 플래그 및 returningAttributes 플래그 는 리스너가 관심있는 오브젝트의 선택을 제어하고 최종 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 리턴되는 정보를 판별하는 데 사용됩니다 . 요청 된 정보 가 사용 불가능하거나 서비스 제공 업체 또는 서비스에서 확보 할 수없는 경우 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7ec0bc18757e2695eb1c71f854b0d45664eafa" translate="yes" xml:space="preserve">
          <source>The script code, or the empty string if none is defined.</source>
          <target state="translated">스크립트 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="ef23874ea1d91d27f386b1f20ccc288696d91d71" translate="yes" xml:space="preserve">
          <source>The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names accepted and defined by &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt;&lt;code&gt;UnicodeScript.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 스크립트 이름은 &lt;a href=&quot;../../lang/character.unicodescript#forName-java.lang.String-&quot;&gt; &lt;code&gt;UnicodeScript.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 스크립트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="afafae7f294d0de7bc87bb9a26199785990e9648" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9c43eef002cb23064cdf0bd61ad8d93fd63d843" translate="yes" xml:space="preserve">
          <source>The scripting API consists of interfaces and classes that define Java &lt;sup&gt;TM&lt;/sup&gt; Scripting Engines and provides a framework for their use in Java applications. This API is intended for use by application programmers who wish to execute programs written in scripting languages in their Java applications. The scripting language programs are usually provided by the end-users of the applications.</source>
          <target state="translated">스크립팅 API는 Java &lt;sup&gt;TM&lt;/sup&gt; 스크립팅 엔진 을 정의 하고 Java 응용 프로그램에서 사용하기위한 프레임 워크를 제공하는 인터페이스와 클래스로 구성됩니다 . 이 API는 Java 응용 프로그램에서 스크립팅 언어로 작성된 프로그램을 실행하려는 응용 프로그램 프로그래머가 사용하기위한 것입니다. 스크립팅 언어 프로그램은 일반적으로 응용 프로그램의 최종 사용자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6cbe5e391a79ef4fb56cc4fe90eb28db84ba088c" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;../lang/classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a9f3a688129049dc155e8aa96211ff37a84c5a" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1a2e358f079002238a405e9b7e93cabc439a00" translate="yes" xml:space="preserve">
          <source>The search order is described in the documentation for &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt;&lt;code&gt;getSystemResource(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">검색 순서는 &lt;a href=&quot;classloader#getSystemResource-java.lang.String-&quot;&gt; &lt;code&gt;getSystemResource(String)&lt;/code&gt; &lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a60b10d749f6decd1a4f3bf2354bd215518658a" translate="yes" xml:space="preserve">
          <source>The search scope of this SearchControls.</source>
          <target state="translated">이 SearchControls의 검색 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8c894820daeb9009f19e3e0e441e8caf2831e1c8" translate="yes" xml:space="preserve">
          <source>The search will not cross naming system boundaries.</source>
          <target state="translated">검색은 이름 지정 시스템 경계를 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71dac0f2a283224db1975250180f8302d951ec94" translate="yes" xml:space="preserve">
          <source>The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.</source>
          <target state="translated">검색된 클래스 정의는 현재 실행중인 클래스가 컴파일 될 때 존재하지만 정의를 더 이상 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19f0094b2e54dfb70b25925659062cdceddabfdd" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. A &lt;code&gt;Long&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or null.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Long&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 공백 또는 null의 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fd52e585e241819acf494d6ce4e0623d9e9bbc2" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. An &lt;code&gt;Integer&lt;/code&gt; object that represents the value of the second argument is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. &lt;code&gt;Integer&lt;/code&gt; 지정된 이름의 속성이없는 경우, 해당 건물이 적절한 수치 형식이 아닌 경우, 또는 지정된 이름이 비어 있거나 경우 두 번째 인수의 값을 나타내는 개체가 반환됩니다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f48b892ab5983e62a64c20f51aeb4852a6d40d4" translate="yes" xml:space="preserve">
          <source>The second argument is the default value. The default value is returned if there is no property of the specified name, if the property does not have the correct numeric format, or if the specified name is empty or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 기본값입니다. 지정된 이름의 속성이 없거나 속성에 올바른 숫자 형식이 없거나 지정된 이름이 비어 있거나 &lt;code&gt;null&lt;/code&gt; 인 경우 기본값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="846dd73201fada82f56344da711130e328206130" translate="yes" xml:space="preserve">
          <source>The second is a completion signal that allows the driver to wait until all workers have completed.</source>
          <target state="translated">두 번째는 운전자가 모든 작업자가 완료 할 때까지 기다릴 수있는 완료 신호입니다.</target>
        </trans-unit>
        <trans-unit id="9c74ca16e8df45ce54eac3795a7c789ada4f5436" translate="yes" xml:space="preserve">
          <source>The second model is that attributes are associated with a name (typically an atomic name) in a DirContext. In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name of the parent DirContext of the named object, followed by the attribute operation invoked on the parent in which the caller supplies the terminal atomic name. The attributes can be viewed as being stored in the parent DirContext (again, this does not imply that the implementation must do so). Objects that are not DirContexts can have attributes, as long as their parents are DirContexts.</source>
          <target state="translated">두 번째 모델은 속성이 DirContext의 이름 (일반적으로 원자 이름)과 연관되어 있다는 것입니다. 이 모델에서, 명명 된 객체의 속성 연산은 명명 된 객체의 부모 DirContext의 이름을 조회 한 다음 호출자가 터미널 원자 이름을 제공하는 상위에서 호출 된 속성 연산과 거의 같습니다. 속성은 부모 DirContext에 저장된 것으로 볼 수 있습니다 (다시 말해 구현이 그렇게해야 함을 의미하지는 않습니다). DirContext가 아닌 객체는 부모가 DirContext 인 한 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a191dfba3988b37aebbbf772bf95fd6c7c5ef5" translate="yes" xml:space="preserve">
          <source>The second-of-day.</source>
          <target state="translated">둘째 날.</target>
        </trans-unit>
        <trans-unit id="0e870041b0c18ce21d4cc73d1cbae5e1e2aeb07b" translate="yes" xml:space="preserve">
          <source>The second-of-minute.</source>
          <target state="translated">두 번째 분.</target>
        </trans-unit>
        <trans-unit id="f6efcc10b579d40e24ab34cc216d6d80435a8d31" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified milliseconds.</source>
          <target state="translated">지정된 밀리 초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23a2616566fd816bf2a993165e25281f4a18c7b6" translate="yes" xml:space="preserve">
          <source>The seconds and nanoseconds are extracted from the specified nanoseconds.</source>
          <target state="translated">지정된 나노초에서 초와 나노초가 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0383fffb7779acd5ef652edbc25f76897e0327" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a day, where each day is 86400 seconds which implies a 24 hour day. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 하루의 표준 정의에 따라 계산되며, 여기서 하루는 86400 초이며 24 시간의 하루를 의미합니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18dafaf48750adbb9e664a9c182377f5852b8936" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of a minute, where each minute is 60 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 분의 표준 정의에 따라 계산되며, 각 분은 60 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bdf17cabd8f715fb436e568230500a070a9d89b" translate="yes" xml:space="preserve">
          <source>The seconds are calculated based on the standard definition of an hour, where each hour is 3600 seconds. The nanosecond in second field is set to zero.</source>
          <target state="translated">초는 시간의 표준 정의에 따라 계산되며, 각 시간은 3600 초입니다. 두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a48467f35f4c20748fa3acc00c4bb7c44e6d23fb" translate="yes" xml:space="preserve">
          <source>The secure communications modes include:</source>
          <target state="translated">보안 통신 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb1ed30a436bf227420125540bd43fdab515b945" translate="yes" xml:space="preserve">
          <source>The security consideration is important with respect to internationalization domain name support. For example, English domain names may be</source>
          <target state="translated">국제화 도메인 이름 지원과 관련하여 보안 고려 사항이 중요합니다. 예를 들어 영어 도메인 이름은</target>
        </trans-unit>
        <trans-unit id="8754c4a5e5f52f313c5ec7c42a10eeb348a2de09" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f541439356895d1a7b18c9420f1d7b1125db20e" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. Granting the setSecurityManager permission would allow code to change which security manager is used by installing a different, possibly less restrictive security manager, thereby bypassing checks that would have been enforced by the original security manager.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. setSecurityManager 권한을 부여하면 코드가 덜 제한적인 다른 보안 관리자를 설치하여 사용되는 보안 관리자를 변경하여 원래 보안 관리자가 시행 한 검사를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea632fc690ffe8730861707a2c56b33a9b6867d2" translate="yes" xml:space="preserve">
          <source>The security manager is a class that allows applications to implement a security policy. It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed. The application can allow or disallow the operation.</source>
          <target state="translated">보안 관리자는 응용 프로그램이 보안 정책을 구현할 수 있도록하는 클래스입니다. 응용 프로그램은 안전하지 않거나 민감한 작업을 수행하기 전에 작업이 무엇인지, 작업을 수행 할 수있는 보안 컨텍스트에서 작업이 시도되고 있는지 여부를 확인할 수 있습니다. 응용 프로그램은 작업을 허용하거나 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ed1fb6cefbd737d506d963693aa54fe70100ed" translate="yes" xml:space="preserve">
          <source>The security manager is thereby given an opportunity to prevent completion of the operation by throwing an exception. A security manager routine simply returns if the operation is permitted, but throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not permitted. The only exception to this convention is &lt;code&gt;checkTopLevelWindow&lt;/code&gt;, which returns a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">이로써 보안 관리자는 예외를 던져서 작업 완료를 막을 수있는 기회가 주어집니다. 보안 관리자 루틴은 조작이 허용되면 단순히 리턴하지만 조작이 허용 되지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 을 발생시킵니다. 이 규칙에 대한 유일한 예외는 &lt;code&gt;checkTopLevelWindow&lt;/code&gt; 이며 &lt;code&gt;boolean&lt;/code&gt; 값 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a67c38f887b66e32ea2617d5a99442f063242dfe" translate="yes" xml:space="preserve">
          <source>The security provider framework uses this method with some types of services to quickly exclude non-matching implementations for consideration. Applications will typically not need to call it.</source>
          <target state="translated">보안 제공자 프레임 워크는 일부 서비스 유형과 함께이 방법을 사용하여 일치하지 않는 구현을 신속하게 제외시킵니다. 응용 프로그램은 일반적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="980a17db139f93c4be1dbeca6c1ec98c6a583f36" translate="yes" xml:space="preserve">
          <source>The selected-key set is &lt;a href=&quot;#ksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">선택한 키 세트는 &lt;a href=&quot;#ksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee377636b8b2866aeab5296e00c6c54b19e71ed5" translate="yes" xml:space="preserve">
          <source>The selection criteria are represented by a map. Each map entry represents a selection criterion. A provider is selected iff it satisfies all selection criteria. The key for any entry in such a map must be in one of the following two formats:</source>
          <target state="translated">선택 기준은지도로 표시됩니다. 각 맵 항목은 선택 기준을 나타냅니다. 모든 선택 기준을 충족하면 제공자가 선택됩니다. 이러한 맵에서 항목의 키는 다음 두 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e44ffedc1f376eadaacdab4f99049fa47e9e98b9" translate="yes" xml:space="preserve">
          <source>The selection criterion must be specified in one of the following two formats:</source>
          <target state="translated">선택 기준은 다음 두 형식 중 하나로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b8e52c4dc1170658ac68079e913b9282a57c2c8" translate="yes" xml:space="preserve">
          <source>The selection operations synchronize on the selector itself, on the key set, and on the selected-key set, in that order. They also synchronize on the cancelled-key set during steps (1) and (3) above.</source>
          <target state="translated">선택 작업은 선택기 자체, 키 세트 및 선택한 키 세트에서 순서대로 동기화됩니다. 또한 위의 1 단계와 3 단계에서 취소 된 키 세트를 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="95202ca438f08b9e0031b9c4bfdeb9b4df852c33" translate="yes" xml:space="preserve">
          <source>The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="453d2ffd1b3b134c5fd9217f7532df9b822182d8" translate="yes" xml:space="preserve">
          <source>The semantics of the beanName parameter are defined by java.beans.Beans.instantiate.</source>
          <target state="translated">beanName 매개 변수의 의미는 java.beans.Beans.instantiate에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="384632fa38dae55d93e0e907e62e3a2804bb5387" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is</source>
          <target state="translated">지원 목록 (즉,이 목록)이 다음과 같은 경우이 메소드가 리턴 한 목록의 의미가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6eb76390f1c14aef2312c3b26cdfb1a9faf1c0d3" translate="yes" xml:space="preserve">
          <source>The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.</source>
          <target state="translated">지원 목록 (즉,이 목록)이 반환 된 목록을 통하지 않고 다른 방식으로 수정되면이 메소드가 반환 한 목록의 의미가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8513f09b48ac39c6481ad6003d15d1ff8cbf1f1" translate="yes" xml:space="preserve">
          <source>The semantics of this method may differ from those of the other &lt;code&gt;read&lt;/code&gt; methods in several ways. First, any destination image and/or image type set in the &lt;code&gt;ImageReadParam&lt;/code&gt; may be ignored. Second, the usual listener calls are not guaranteed to be made, or to be meaningful if they are. This is because the returned image may not be fully populated with pixel data at the time it is returned, or indeed at any time.</source>
          <target state="translated">이 방법의 의미는 몇 가지면에서 다른 &lt;code&gt;read&lt;/code&gt; 방법 의 의미와 다를 수 있습니다 . 먼저 &lt;code&gt;ImageReadParam&lt;/code&gt; 에 설정된 대상 이미지 및 / 또는 이미지 유형 이 무시 될 수 있습니다. 둘째, 일반적인 청취자 호출이 이루어 지거나 의미가있는 것은 아닙니다. 반환 된 이미지가 반환 될 때나 실제로는 픽셀 데이터로 완전히 채워지지 않을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="161693ca410ae026e19d3b93be91d521d736f95e" translate="yes" xml:space="preserve">
          <source>The separator between a keystore name prefix and an entry name. When specified, it applies to all the entries in a domain. Its default value is a space.</source>
          <target state="translated">키 저장소 이름 접 두부와 항목 이름 사이의 구분 기호입니다. 지정하면 도메인의 모든 항목에 적용됩니다. 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="fddaff8ebac1c2c5c7b43da5bf7781d174bd01f1" translate="yes" xml:space="preserve">
          <source>The sequence number of the earliest notification still in the buffer.</source>
          <target state="translated">버퍼에 여전히 가장 빠른 알림의 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a4b01bb88787366b6d9e829887a4ae25a588e430" translate="yes" xml:space="preserve">
          <source>The sequence number of the next notification available for querying. This will be the starting sequence number for the next notification query.</source>
          <target state="translated">쿼리에 사용할 수있는 다음 알림의 시퀀스 번호입니다. 다음 알림 쿼리의 시작 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="ed0c9428f6e0126963f745de2465f141332a6026" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Byte.parseByte&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 나오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Byte.parseByte&lt;/code&gt; 메서드로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c063e5411741f160ae6a46bec35b7a73c1e07d1" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Integer.parseInt&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Integer.parseInt&lt;/code&gt; 메서드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ce5c427a4177226515b1b8cfab424168d32e788" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Long.parseLong&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 다음에 오는 문자 시퀀스는 &lt;code&gt;Long.parseLong&lt;/code&gt; 메소드에 의해 표시된 기수 (10, 16 또는 8 )로 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4974fa4ef44b513af1028ff49c4b453f94609bd" translate="yes" xml:space="preserve">
          <source>The sequence of characters following an optional sign and/or radix specifier (&quot;&lt;code&gt;0x&lt;/code&gt;&quot;, &quot;&lt;code&gt;0X&lt;/code&gt;&quot;, &quot;&lt;code&gt;#&lt;/code&gt;&quot;, or leading zero) is parsed as by the &lt;code&gt;Short.parseShort&lt;/code&gt; method with the indicated radix (10, 16, or 8). This sequence of characters must represent a positive value or a &lt;a href=&quot;numberformatexception&quot;&gt;&lt;code&gt;NumberFormatException&lt;/code&gt;&lt;/a&gt; will be thrown. The result is negated if first character of the specified &lt;code&gt;String&lt;/code&gt; is the minus sign. No whitespace characters are permitted in the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">선택적 부호 및 / 또는 기수 지정자 ( &quot; &lt;code&gt;0x&lt;/code&gt; &quot;, &quot; &lt;code&gt;0X&lt;/code&gt; &quot;, &quot; &lt;code&gt;#&lt;/code&gt; &quot;또는 선행 0) 뒤에 오는 문자 시퀀스는 표시된 기수 (10, 16 또는 8)를 사용 하여 &lt;code&gt;Short.parseShort&lt;/code&gt; 메소드에 의해 구문 분석됩니다. ). 이 문자 순서는 양수 값을 나타내야합니다. 그렇지 않으면 &lt;a href=&quot;numberformatexception&quot;&gt; &lt;code&gt;NumberFormatException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 지정된 &lt;code&gt;String&lt;/code&gt; 의 첫 문자 가 빼기 부호 이면 결과가 무시됩니다 . &lt;code&gt;String&lt;/code&gt; 에는 공백 문자가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e434dd3150cc80ca7cae2f8b8eaeb4038c9e904c" translate="yes" xml:space="preserve">
          <source>The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the</source>
          <target state="translated">후보 로케일의 순서는 또한 런타임 자원 검색 경로 (</target>
        </trans-unit>
        <trans-unit id="f7e487534567beaaaf886a79c2a34b214dbcb31b" translate="yes" xml:space="preserve">
          <source>The sequence property will be initialized with a new unique value. These sequence values are allocated in increasing order within a VM.</source>
          <target state="translated">시퀀스 속성은 새로운 고유 값으로 초기화됩니다. 이 시퀀스 값은 VM 내에서 순서대로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c00ff75511a0de0a28d3c3e6f1b65b2b2cd9a528" translate="yes" xml:space="preserve">
          <source>The serial version of the class does not match that of the class descriptor read from the stream</source>
          <target state="translated">클래스의 직렬 버전이 스트림에서 읽은 클래스 디스크립터의 버전과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd73bf37e348582139983df9cefa4606f813c326" translate="yes" xml:space="preserve">
          <source>The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender's class, then deserialization will result in an &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;. A serializable class can declare its own serialVersionUID explicitly by declaring a field named &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; that must be static, final, and of type &lt;code&gt;long&lt;/code&gt;:</source>
          <target state="translated">직렬화 런타임은 직렬화 가능 오브젝트의 송신자 및 수신자가 직렬화와 호환되는 해당 오브젝트에 대해 클래스를로드했는지 검증하기 위해 직렬화 해제 중에 사용되는 직렬 버전 UID라고하는 버전 번호를 각 직렬화 가능 클래스와 연관시킵니다. 수신자가 해당 송신자의 클래스와 다른 serialVersionUID를 가진 객체에 대한 클래스를로드 한 경우 역 직렬화로 인해 &lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 . 직렬화 가능 클래스는 정적, 최종 및 &lt;code&gt;long&lt;/code&gt; 유형이어야하는 &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; 라는 필드를 선언하여 고유 한 serialVersionUID를 명시 적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6b7ba8d6780756feb02181d1f3b8e6bc1232ed3" translate="yes" xml:space="preserve">
          <source>The server was able to connect to the output device (or is always connected), but was unable to get a response from the output device.</source>
          <target state="translated">서버가 출력 장치에 연결할 수 있었거나 항상 연결되어 있었지만 출력 장치에서 응답을받을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="7fc00d2c6bd145d9268cc5b5645d6faef5160f5c" translate="yes" xml:space="preserve">
          <source>The server-side sort control's assigned object identifier is 1.2.840.113556.1.4.473.</source>
          <target state="translated">서버 측 정렬 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.473입니다.</target>
        </trans-unit>
        <trans-unit id="683960c5bca78c73afa4105fa8def718cb10bbd7" translate="yes" xml:space="preserve">
          <source>The server-side sort response control's assigned object identifier is 1.2.840.113556.1.4.474.</source>
          <target state="translated">서버 측 정렬 응답 제어의 지정된 오브젝트 ID는 1.2.840.113556.1.4.474입니다.</target>
        </trans-unit>
        <trans-unit id="339bce1745ff0ddf550af41337f79c273e458f7f" translate="yes" xml:space="preserve">
          <source>The service named has been registered. getService requests for this service may now be made.</source>
          <target state="translated">이름이 지정된 서비스가 등록되었습니다. 이 서비스에 대한 getService 요청이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df31dfe1040963f739d9dbd1f8945217536f695" translate="yes" xml:space="preserve">
          <source>The service named has been revoked. getService requests for this service will no longer be satisfied.</source>
          <target state="translated">이름이 지정된 서비스가 취소되었습니다. 이 서비스에 대한 getService 요청은 더 이상 충족되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2312f997c09c219c1c3cc983985a51f259efd5c0" translate="yes" xml:space="preserve">
          <source>The service principal name is the canonical name of the &lt;code&gt;KerberosPrincipal&lt;/code&gt; supplying the service, that is the KerberosPrincipal represents a Kerberos service principal. This name is treated in a case sensitive manner. An asterisk may appear by itself, to signify any service principal.</source>
          <target state="translated">서비스 주체 이름은 서비스를 제공하는 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 의 정식 이름입니다. 즉, KerberosPrincipal은 Kerberos 서비스 주체를 나타냅니다. 이 이름은 대소 문자를 구분하여 처리됩니다. 서비스 주체를 나타 내기 위해 별표 만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6747b4a2a337f04bdc6c20288be6a874d897923c" translate="yes" xml:space="preserve">
          <source>The service provider classes are intended to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드 할 수 있도록 고안되었습니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f444b1559da4e9d86d6d648069e2d0a6eeb225b7" translate="yes" xml:space="preserve">
          <source>The service provider classes should be to be lightweight and quick to load. Implementations of these interfaces should avoid complex dependencies on other classes and on native code. The usual pattern for more complex services is to register a lightweight proxy for the heavyweight service.</source>
          <target state="translated">서비스 제공 업체 클래스는 가볍고 빠르게로드되어야합니다. 이러한 인터페이스의 구현은 다른 클래스와 기본 코드에 대한 복잡한 종속성을 피해야합니다. 보다 복잡한 서비스의 일반적인 패턴은 헤비급 서비스를위한 경량 프록시를 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39722a75ad6a5d7f9c535e0c0bae2bb029dadcb9" translate="yes" xml:space="preserve">
          <source>The service provider for &lt;code&gt;ctx&lt;/code&gt; uses a state factory to obtain the state of &lt;code&gt;printer&lt;/code&gt; for binding into its namespace. A state factory for the &lt;code&gt;Printer&lt;/code&gt; type object might return a more compact object for storage in the naming system.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 의 서비스 공급자 는 상태 팩토리를 사용하여 네임 스페이스에 바인딩하기위한 &lt;code&gt;printer&lt;/code&gt; 상태를 얻습니다 . &lt;code&gt;Printer&lt;/code&gt; 유형 개체 의 상태 팩토리 는 이름 지정 시스템에 저장하기 위해 더 컴팩트 한 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38127cd4aa0815400585c455d9b08bc1a04388ab" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="1f43b817f684f623aff5dad130484f2da8b725fa" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageInputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageInputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a256fe03be1948fb7463bd5c25f91b70d8bb367" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 .</target>
        </trans-unit>
        <trans-unit id="baa871f87fb50e99d06890cf145ed5a968d9d468" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageOutputStream&lt;/code&gt;s. For more information on service provider interfaces, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageOutputStream&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)입니다 . 서비스 제공자 인터페이스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="237770f3170d2d602f3c067509f29ea8083b1e81" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="45ed743b0330766c9e4bf1587f45b4bca8c763dd" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageReader&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdf130a89b8ecdd0fc56c8841a6256d234f7b1d5" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 .</target>
        </trans-unit>
        <trans-unit id="4e56bbbc7919ab4d22d10e83ee3380885f3821d8" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageTranscoder&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 의 SPI (Service Provider Interface)입니다 . 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="967704522c5f16add19f7f3f928885832f2dc066" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI)</target>
        </trans-unit>
        <trans-unit id="59d3345b89b02c0a3b5eb368b40b37277fb4680d" translate="yes" xml:space="preserve">
          <source>The service provider interface (SPI) for &lt;code&gt;ImageWriter&lt;/code&gt;s. For more information on service provider classes, see the class comment for the &lt;code&gt;IIORegistry&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;ImageWriter&lt;/code&gt; 의 서비스 프로 바이더 인터페이스 (SPI) 서비스 제공자 클래스에 대한 자세한 정보는 &lt;code&gt;IIORegistry&lt;/code&gt; 클래스 의 클래스 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81e08ce13e4bc1e787c03d053631be4ab8564f41" translate="yes" xml:space="preserve">
          <source>The service provider.</source>
          <target state="translated">서비스 제공자.</target>
        </trans-unit>
        <trans-unit id="37af36e76b9cf4fce8d917861e80abd5df5d0dad" translate="yes" xml:space="preserve">
          <source>The service type &lt;code&gt;Provider&lt;/code&gt; is reserved for use by the security framework. Services of this type cannot be added, removed, or modified by applications. The following attributes are automatically placed in each Provider object:</source>
          <target state="translated">서비스 유형 &lt;code&gt;Provider&lt;/code&gt; 는 보안 프레임 워크에서 사용하도록 예약되어 있습니다. 이 유형의 서비스는 응용 프로그램에서 추가, 제거 또는 수정할 수 없습니다. 다음 속성은 각 제공자 오브젝트에 자동으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="3e064776c20c4d1bdfca5a291b86a1d978043bc3" translate="yes" xml:space="preserve">
          <source>The service will throw a PrintException if the cancellation did not succeed. A job which has not yet been submitted for printing should throw this exception. Cancelling an already successfully cancelled Print Job is not considered an error and will always succeed.</source>
          <target state="translated">취소에 실패하면 서비스에서 PrintException이 발생합니다. 아직 인쇄를 위해 제출되지 않은 작업은이 예외를 발생시켜야합니다. 이미 성공적으로 취소 된 인쇄 작업을 취소하는 것은 오류로 간주되지 않으며 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="939369237a0093ae8b76203fbafeae8ecee1df1c" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과는 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08401de134cf52abcaf1f8af2a1683d7c74313a4" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation, or through the &lt;code&gt;setValue&lt;/code&gt; operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 반복자 자신의 &lt;code&gt;remove&lt;/code&gt; 작업 또는 반복자가 반환 한 맵 항목 의 &lt;code&gt;setValue&lt;/code&gt; 작업을 제외하고 집합에 대한 반복이 진행되는 동안 맵이 수정되면 반복 결과가 정의되지 않습니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="852ef9de08250d48c0d0fc367b3fbed7a9bf4099" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 작업을 통해 맵에서 해당 매핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="335b178dce95c35bddb6f9a6dfbb5dbd684f0d11" translate="yes" xml:space="preserve">
          <source>The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt;, and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">세트는 맵에 의해 지원되므로 맵에 대한 변경 사항이 세트에 반영되며 그 반대도 마찬가지입니다. 이 세트는 &lt;code&gt;Iterator.remove&lt;/code&gt; , &lt;code&gt;Set.remove&lt;/code&gt; , &lt;code&gt;removeAll&lt;/code&gt; , &lt;code&gt;retainAll&lt;/code&gt; 및 &lt;code&gt;clear&lt;/code&gt; 오퍼레이션을 통해 맵에서 해당 맵핑을 제거하는 요소 제거를 지원 합니다. &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;addAll&lt;/code&gt; 조작을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f4f2cfd47ef65402bf2cd171ee3694a2946949e" translate="yes" xml:space="preserve">
          <source>The set is created the first time this method is called, and returned in response to all subsequent calls. No synchronization is performed, so there is a slight chance that multiple calls to this method will not all return the same set.</source>
          <target state="translated">이 메소드는이 메소드가 처음 호출 될 때 작성되며 모든 후속 호출에 대한 응답으로 리턴됩니다. 동기화가 수행되지 않으므로이 메소드에 대한 여러 호출이 모두 동일한 세트를 리턴하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c6dbb0140fcb03f42d68d9b039f3ccf70fab2f5" translate="yes" xml:space="preserve">
          <source>The set of Unicode locale keys, or the empty set if this locale has no Unicode locale keywords.</source>
          <target state="translated">유니 코드 로캘 키 집합이거나이 로캘에 유니 코드 로캘 키워드가없는 경우 빈 집합입니다.</target>
        </trans-unit>
        <trans-unit id="03d9f1bf0b7313c94bfc617aaf5a0c81cfb6185f" translate="yes" xml:space="preserve">
          <source>The set of all legal URI characters consists of the</source>
          <target state="translated">모든 유효한 URI 문자 세트는</target>
        </trans-unit>
        <trans-unit id="621a29c69b103747e0b5a4f9c4564c47401600b9" translate="yes" xml:space="preserve">
          <source>The set of attributes.</source>
          <target state="translated">속성 세트</target>
        </trans-unit>
        <trans-unit id="3f9639f8c60c46f82dff9817fb5e46940cb7b600" translate="yes" xml:space="preserve">
          <source>The set of available chronologies can be extended by applications. Adding a new calendar system requires the writing of an implementation of &lt;code&gt;Chronology&lt;/code&gt;, &lt;code&gt;ChronoLocalDate&lt;/code&gt; and &lt;code&gt;Era&lt;/code&gt;. The majority of the logic specific to the calendar system will be in the &lt;code&gt;ChronoLocalDate&lt;/code&gt; implementation. The &lt;code&gt;Chronology&lt;/code&gt; implementation acts as a factory.</source>
          <target state="translated">사용 가능한 연대기 세트는 애플리케이션에 의해 확장 될 수 있습니다. 새 달력 시스템을 추가하려면 &lt;code&gt;Chronology&lt;/code&gt; , &lt;code&gt;ChronoLocalDate&lt;/code&gt; 및 &lt;code&gt;Era&lt;/code&gt; 를 구현해야합니다 . 달력 시스템과 관련된 대부분의 논리는 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 구현에 있습니다. &lt;code&gt;Chronology&lt;/code&gt; 구현은 공장 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="b989013791c04777bdc8434807fe06cb2e6445b2" translate="yes" xml:space="preserve">
          <source>The set of classes that make up the package may implement a particular specification and if so the specification title, version number, and vendor strings identify that specification. An application can ask if the package is compatible with a particular version, see the &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt;&lt;code&gt;isCompatibleWith&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">패키지를 구성하는 클래스 세트는 특정 사양을 구현할 수 있으므로 사양 제목, 버전 번호 및 공급 업체 문자열이 해당 사양을 식별합니다. 응용 프로그램은 패키지가 특정 버전과 호환되는지 묻습니다 . 자세한 내용은 &lt;a href=&quot;package#isCompatibleWith-java.lang.String-&quot;&gt; &lt;code&gt;isCompatibleWith&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8566d5bad5a6af80ccaae4ebc526f12877ada443" translate="yes" xml:space="preserve">
          <source>The set of delimiters (the characters that separate tokens) may be specified either at creation time or on a per-token basis.</source>
          <target state="translated">구분자 세트 (토큰을 분리하는 문자)는 작성시 또는 토큰별로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bdff17e6129a79d93316f1c821db4d8f82ede91" translate="yes" xml:space="preserve">
          <source>The set of destination bands to be used, as an array of &lt;code&gt;int&lt;/code&gt;s. By default, the value is &lt;code&gt;null&lt;/code&gt;, indicating all destination bands should be written in order.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 배열로서 사용되는 목적지 밴드 세트입니다 . 기본적으로 값은 &lt;code&gt;null&lt;/code&gt; 이며 모든 대상 밴드를 순서대로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="729a1180bc7c2901cd889e8f040bc5045cacfb92" translate="yes" xml:space="preserve">
          <source>The set of events may include additional implementation specific event that are not defined by the enum &lt;a href=&quot;standardwatcheventkinds&quot;&gt;&lt;code&gt;StandardWatchEventKinds&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트 세트에는 열거 형 &lt;a href=&quot;standardwatcheventkinds&quot;&gt; &lt;code&gt;StandardWatchEventKinds&lt;/code&gt; 에&lt;/a&gt; 의해 정의되지 않은 추가 구현 특정 이벤트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c728dd3ce97aa1a197697a57af717e73be26f0b" translate="yes" xml:space="preserve">
          <source>The set of extension keys, or the empty set if this locale has no extensions.</source>
          <target state="translated">확장 키 세트 또는이 로케일에 확장이없는 경우 비어있는 세트.</target>
        </trans-unit>
        <trans-unit id="1ca105b2eec11893f8655aa15ad8f33d78fa091c" translate="yes" xml:space="preserve">
          <source>The set of formats may differ according to the particular images being read or written; this method should indicate all the additional formats supported by the plug-in under any circumstances.</source>
          <target state="translated">형식 세트는 읽거나 쓰는 특정 이미지에 따라 다를 수 있습니다. 이 방법은 어떤 상황에서도 플러그인이 지원하는 모든 추가 형식을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="10d94f3aa7e712fbe40291f913b08a2062951f72" translate="yes" xml:space="preserve">
          <source>The set of parameters defined here may not include all aspects of reverberation as specified by some systems. For example, the Midi Manufacturer's Association (MMA) has an Interactive Audio Special Interest Group (IASIG), which has a 3-D Working Group that has defined a Level 2 Spec (I3DL2). I3DL2 supports filtering of reverberation and control of reverb density. These properties are not included in the JavaSound 1.0 definition of a reverb control. In such a case, the implementing system should either extend the defined reverb control to include additional parameters, or else interpret the system's additional capabilities in a way that fits the model described here.</source>
          <target state="translated">여기에 정의 된 파라미터 세트는 일부 시스템에 의해 지정된 잔향의 모든 측면을 포함하지 않을 수 있습니다. 예를 들어 MMA (Midi Manufacturer 's Association)에는 IASL2 (Interactive Audio Special Interest Group)가 있으며,이 그룹에는 I2DL2 (Level 2 Spec)를 정의한 3D 작업 그룹이 있습니다. I3DL2는 잔향 필터링 및 잔향 밀도 제어를 지원합니다. 이러한 속성은 리버브 컨트롤의 JavaSound 1.0 정의에 포함되어 있지 않습니다. 이 경우 구현 시스템은 정의 된 리버브 컨트롤을 확장하여 추가 파라미터를 포함 시키거나 여기에 설명 된 모델에 맞는 방식으로 시스템의 추가 기능을 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="68d403ff4ac7d3e26edbaf2a349d84bb408ad098" translate="yes" xml:space="preserve">
          <source>The set of permissions evaluated is a function of whether the ProtectionDomain was constructed with a static set of permissions or it was bound to a dynamically mapped set of permissions.</source>
          <target state="translated">평가 된 권한 집합은 ProtectionDomain이 정적 권한 집합으로 구성되었는지 또는 동적으로 매핑 된 권한 집합에 바인딩되었는지 여부의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0b9b26c8c7dd24de7fa7e0a2e0ee1b1f709f4d4b" translate="yes" xml:space="preserve">
          <source>The set of permissions granted to the principal is then calculated using the simple rule that individual permissions always override the group permissions. That is, the principal's individual negative permission set (specific denial of permissions) overrides the group positive permission set, and the principal's individual positive permission set overrides the group negative permission set.</source>
          <target state="translated">그런 다음 보안 주체에게 부여 된 권한 집합은 개별 권한이 항상 그룹 권한보다 우선한다는 간단한 규칙을 사용하여 계산됩니다. 즉, 주체의 개별 부정적 권한 집합 (특정 권한 거부)이 그룹 긍정적 권한 집합을 재정의하고 주체의 개별 긍정적 인 권한 집합이 그룹 부정적 권한 집합을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="1c5e4eed3c1a6ad50555dc5a120636aac05d2d14" translate="yes" xml:space="preserve">
          <source>The set of source bands to be read and destination bands to be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;. If the lengths of the arrays returned by these methods differ, the set of source bands contains an index larger that the largest available source index, or the set of destination bands contains an index larger than the largest legal destination index, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">읽을 소스 밴드 세트와 기록 할 대상 밴드 는 제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에서 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 를 호출하여 결정됩니다 . 이러한 메소드에 의해 리턴 된 배열의 길이가 다른 경우, 소스 밴드 세트에 사용 가능한 가장 큰 소스 인덱스보다 큰 인덱스가 포함되거나 목적지 밴드 세트가 가장 큰 유효한 대상 인덱스보다 큰 인덱스를 포함하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6c7711952ed69b023e8f9dad86209b75e9faa4e" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date and time fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 및 시간 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="17f958194f63b45fb85cee1d1ff860e19a4ebff9" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; date fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="7b87b275acd5b0bbff5b52b9d09fd971743dbb82" translate="yes" xml:space="preserve">
          <source>The set of supported fields is defined by the chronology and normally includes all &lt;code&gt;ChronoField&lt;/code&gt; fields.</source>
          <target state="translated">지원되는 필드 세트는 시간 순서대로 정의되며 일반적으로 모든 &lt;code&gt;ChronoField&lt;/code&gt; 필드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="0cd5b52cb97e9595d03bfd112aa6100ad3af1552" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; date units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 날짜 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="cf91e64de9db3a085379dbaade3e6f6c15d84327" translate="yes" xml:space="preserve">
          <source>The set of supported units is defined by the chronology and normally includes all &lt;code&gt;ChronoUnit&lt;/code&gt; units except &lt;code&gt;FOREVER&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위 집합은 시간 순서대로 정의되며 일반적으로 &lt;code&gt;FOREVER&lt;/code&gt; 를 제외한 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 단위를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="fe5205d619c2546cedc0aae80e2949df5b42d127" translate="yes" xml:space="preserve">
          <source>The set of warnings that are to be suppressed by the compiler in the annotated element. Duplicate names are permitted. The second and successive occurrences of a name are ignored. The presence of unrecognized warning names is</source>
          <target state="translated">어노테이션이있는 요소에서 컴파일러가 억제 할 경고 세트입니다. 중복 된 이름이 허용됩니다. 두 번째로 그리고 연속적으로 나타나는 이름은 무시됩니다. 인식 할 수없는 경고 이름이 있습니다</target>
        </trans-unit>
        <trans-unit id="cf50745559139179ac02ea11a6006ec30ea95b4e" translate="yes" xml:space="preserve">
          <source>The set of zone IDs can increase over time, although in a typical application the set of IDs is fixed. Each call to this method is thread-safe.</source>
          <target state="translated">일반적인 응용 프로그램에서는 ID 집합이 고정되어 있지만 영역 ID 집합은 시간이 지남에 따라 증가 할 수 있습니다. 이 메소드에 대한 각 호출은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b28e0ecb07f1416bf310fc7c1fb31a72ea753196" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 또한 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를보고합니다.&lt;/a&gt; 키 순서를 오름차순으로 만나는 발생 순서와 함께 .</target>
        </trans-unit>
        <trans-unit id="499442b22634bbf31c6cc45cc4b266d5e35f872c" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the entries in ascending key order. The sets's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order.</source>
          <target state="translated">세트의 반복자는 오름차순 키 순서로 항목을 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="4685b0d5732f702ab85c0ed76d92a22ff9945c14" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the map's comparator (see &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 또한 키 순서를 오름차순으로 만나는 발생 순서와 함께 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고합니다 . 맵의 비교기 ( &lt;a href=&quot;concurrentskiplistmap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기가 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="46790b7f24e0bc5b45cc4e19d698ecf9c001e4f2" translate="yes" xml:space="preserve">
          <source>The set's iterator returns the keys in ascending order. The set's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;Spliterator.SORTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending key order. The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree map's comparator (see &lt;a href=&quot;treemap#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator.</source>
          <target state="translated">세트의 반복자는 키를 오름차순으로 반환합니다. 세트의 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 이며, 키 순서가 오름차순 인 발생 순서로 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;Spliterator.SORTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 를 추가로보고합니다 . 트리 맵의 비교 자 ( &lt;a href=&quot;treemap#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 맵의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="f060c2185618cf2a6c32ef4425c5bbd1f9463f3a" translate="yes" xml:space="preserve">
          <source>The setup parameters and general request properties are manipulated.</source>
          <target state="translated">설정 매개 변수 및 일반 요청 특성이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45a6b9c2d290d870eaa0f880a9a918246e71542" translate="yes" xml:space="preserve">
          <source>The setup parameters are modified using the following methods:</source>
          <target state="translated">설정 매개 변수는 다음 방법을 사용하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd13c7488ba25ddcfcc26fab92f485990ee6b61" translate="yes" xml:space="preserve">
          <source>The seven one-argument public constructors provided by this class ensure that the assertion error returned by the invocation:</source>
          <target state="translated">이 클래스에서 제공하는 7 개의 1 인수 공용 생성자는 호출에서 반환 된 어설 션 오류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8d1d146216a151be9f0ea1c3654e3497f9a52dbb" translate="yes" xml:space="preserve">
          <source>The severity of this notification. It can be 0 to mean unknown severity or a value from 1 to 6 representing decreasing levels of severity. It can be represented as a decimal string or an &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">이 알림의 심각도 알 수없는 심각도를 나타내는 0 또는 심각도 감소 레벨을 나타내는 1-6의 값일 수 있습니다. 10 진수 문자열 또는 &lt;code&gt;Integer&lt;/code&gt; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a66fafeb6fbab36159ed0d7cb6e57d97215745bd" translate="yes" xml:space="preserve">
          <source>The short at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 단락</target>
        </trans-unit>
        <trans-unit id="576f2f40fa40978110faae7dddc7b0f100fba9e6" translate="yes" xml:space="preserve">
          <source>The short at the given index</source>
          <target state="translated">주어진 색인에서 짧은</target>
        </trans-unit>
        <trans-unit id="66f18505d5b42c405be6d263a2a68a91ad1ba54c" translate="yes" xml:space="preserve">
          <source>The short value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="445cdd9d7081047dd595fe2a9c000aec02dddce0" translate="yes" xml:space="preserve">
          <source>The short value at the given index</source>
          <target state="translated">주어진 인덱스에서 짧은 값</target>
        </trans-unit>
        <trans-unit id="d44b2f7b9945d3e00f503b32d73edd3c18066dda" translate="yes" xml:space="preserve">
          <source>The shorts between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the short at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 단락 (있는 경우)이 버퍼의 시작 부분에 복사됩니다. 즉, 지수 부족</target>
        </trans-unit>
        <trans-unit id="e6144db94e8f968200473ae365392fcfc5ce0cb6" translate="yes" xml:space="preserve">
          <source>The should be of the format 'BaseOfRange', such as 'MonthOfYear', unless the field has a range of &lt;code&gt;FOREVER&lt;/code&gt;, when only the base unit is mentioned, such as 'Year' or 'Era'.</source>
          <target state="translated">'Year'또는 'Era'와 같이 기본 단위 만 언급 된 경우 필드에 &lt;code&gt;FOREVER&lt;/code&gt; 범위가 없으면 'MonthOfYear'와 같은 'BaseOfRange'형식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3add085de9aaf5d9e08da4a23124aa74c77dac0e" translate="yes" xml:space="preserve">
          <source>The side input tray.</source>
          <target state="translated">측면 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="32380dd36b39ecdac95d6475271f9fd1eac8171d" translate="yes" xml:space="preserve">
          <source>The sign of the hours and minutes components must match. Thus, if the hours is negative, the minutes must be negative or zero. If the hours is zero, the minutes may be positive, negative or zero.</source>
          <target state="translated">시간 및 분 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분은 음수이거나 0이어야합니다. 시간이 0이면 분은 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2a7170814ac7bf2d717ef435fa78b42211f6f7" translate="yes" xml:space="preserve">
          <source>The sign of the hours, minutes and seconds components must match. Thus, if the hours is negative, the minutes and seconds must be negative or zero.</source>
          <target state="translated">시간, 분 및 초 구성 요소의 부호가 일치해야합니다. 따라서 시간이 음수이면 분과 초는 음수 또는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee96bcfbe6567e84f1f76ed99e4ecc836a96fca7" translate="yes" xml:space="preserve">
          <source>The sign of the years and months units will be the same after normalization. For example, a period of &quot;1 year and -25 months&quot; will be normalized to &quot;-1 year and -1 month&quot;.</source>
          <target state="translated">연도 및 월 단위의 부호는 정규화 후에 동일합니다. 예를 들어 &quot;1 년 -25 개월&quot;기간은 &quot;-1 년 -1 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="63a67b56142738f69b16820d1365a14f5a4ee3f6" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The DSA algorithm using the SHA-1 message digest algorithm can be specified as &lt;code&gt;SHA1withDSA&lt;/code&gt;. In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &lt;code&gt;MD2withRSA&lt;/code&gt;, &lt;code&gt;MD5withRSA&lt;/code&gt;, or &lt;code&gt;SHA1withRSA&lt;/code&gt;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 &lt;code&gt;SHA1withDSA&lt;/code&gt; 로 지정할 수 있습니다 . RSA의 경우 메시지 요약 알고리즘에 대해 여러 가지 선택이 있으므로 서명 알고리즘은 예를 들어 &lt;code&gt;MD2withRSA&lt;/code&gt; , &lt;code&gt;MD5withRSA&lt;/code&gt; 또는 &lt;code&gt;SHA1withRSA&lt;/code&gt; 로 지정할 수 있습니다 . 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3f13d175903d19542fafe1776e926f2289f74d" translate="yes" xml:space="preserve">
          <source>The signature algorithm can be, among others, the NIST standard DSA, using DSA and SHA-1. The algorithm is specified using the same convention as that for signatures. The DSA algorithm using the SHA-1 message digest algorithm can be specified, for example, as &quot;SHA/DSA&quot; or &quot;SHA-1/DSA&quot; (they are equivalent). In the case of RSA, there are multiple choices for the message digest algorithm, so the signing algorithm could be specified as, for example, &quot;MD2/RSA&quot;, &quot;MD5/RSA&quot; or &quot;SHA-1/RSA&quot;. The algorithm name must be specified, as there is no default.</source>
          <target state="translated">서명 알고리즘은 특히 DSA 및 SHA-1을 사용하는 NIST 표준 DSA 일 수 있습니다. 알고리즘은 서명과 동일한 규칙을 사용하여 지정됩니다. SHA-1 메시지 요약 알고리즘을 사용하는 DSA 알고리즘은 예를 들어 &quot;SHA / DSA&quot;또는 &quot;SHA-1 / DSA&quot;로 지정할 수 있습니다 (동일 함). RSA의 경우 메시지 다이제스트 알고리즘에 대한 여러 선택이 있으므로 서명 알고리즘은 예를 들어 &quot;MD2 / RSA&quot;, &quot;MD5 / RSA&quot;또는 &quot;SHA-1 / RSA&quot;로 지정할 수 있습니다. 기본값이 없으므로 알고리즘 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff39bceb78bb23fcbbe70e1f5873034144eb781f" translate="yes" xml:space="preserve">
          <source>The signature algorithm name must be a standard Java Security name (such as &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;, and so on). See Appendix A in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt; Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a&gt; for information about standard algorithm names.</source>
          <target state="translated">서명 알고리즘 이름은 표준 Java 보안 이름 (예 : &quot;SHA1withRSA&quot;, &quot;SHA256withECDSA&quot;등)이어야합니다. 표준 알고리즘 이름에 대한 정보 는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt;Java Cryptography Architecture API 스펙 및 참조 서&lt;/a&gt; 의 부록 A를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abb3f7329a67b3d4fbdda3d73c3b635eb5d93e29" translate="yes" xml:space="preserve">
          <source>The signature implementation is reset to its initial state (the state it was in after a call to one of the &lt;code&gt;engineInitSign&lt;/code&gt; methods) and can be reused to generate further signatures with the same private key. This method should be abstract, but we leave it concrete for binary compatibility. Knowledgeable providers should override this method.</source>
          <target state="translated">서명 구현은 초기 상태 ( &lt;code&gt;engineInitSign&lt;/code&gt; 메소드 중 하나를 호출 한 후의 상태)로 재설정되며 동일한 개인 키로 추가 서명을 생성하기 위해 재사용 할 수 있습니다. 이 방법은 추상적이어야하지만 바이너리 호환성을 위해 구체적으로 남겨둔다. 지식이 풍부한 공급자는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="045f0d9e22ad722e6aac3627bd8e3b08a1c1d73b" translate="yes" xml:space="preserve">
          <source>The signature is invalid.</source>
          <target state="translated">서명이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ded27c36fe5ab7411d3e61933f2340152846415" translate="yes" xml:space="preserve">
          <source>The signed object is a &quot;deep copy&quot; (in serialized form) of an original object. Once the copy is made, further manipulation of the original object has no side effect on the copy.</source>
          <target state="translated">서명 된 객체는 원본 객체의 &quot;딥 카피&quot;(직렬화 된 형태)입니다. 복사가 완료되면 원본 개체를 추가로 조작해도 복사본에 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0a59c44048f0e255610b14982004df77ebcfed2" translate="yes" xml:space="preserve">
          <source>The simple name of an array is the simple name of the component type with &quot;[]&quot; appended. In particular the simple name of an array whose component type is anonymous is &quot;[]&quot;.</source>
          <target state="translated">배열의 단순 이름은 &quot;[]&quot;가 추가 된 구성 요소 유형의 단순 이름입니다. 특히 구성 요소 유형이 익명 인 배열의 단순 이름은 &quot;[]&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4856758e2bc679598150b5beb9072d5658f18a73" translate="yes" xml:space="preserve">
          <source>The simplest implementation of this interface is just:</source>
          <target state="translated">이 인터페이스의 가장 간단한 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7601d63e6d779f847c6607714e8ec53d040dbbd9" translate="yes" xml:space="preserve">
          <source>The simplest type of ID is that from &lt;code&gt;ZoneOffset&lt;/code&gt;. This consists of 'Z' and IDs starting with '+' or '-'.</source>
          <target state="translated">가장 간단한 유형의 ID는 &lt;code&gt;ZoneOffset&lt;/code&gt; 의 ID입니다 . 'Z'와 '+'또는 '-'로 시작하는 ID로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4705f5b2ef8f72b3f9ee11b55f079122ada80e7" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to install a listener that calls a method on the target object with no arguments. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that invokes the &lt;code&gt;toFront&lt;/code&gt; method on an instance of &lt;code&gt;javax.swing.JFrame&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 가장 간단한 사용은 인수없이 대상 오브젝트에서 메소드를 호출하는 리스너를 설치하는 것입니다. 다음 예제에서는 &lt;code&gt;javax.swing.JFrame&lt;/code&gt; 인스턴스 에서 &lt;code&gt;toFront&lt;/code&gt; 메소드 를 호출 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e33d8bb98b0a97976f391846111c47207f038c46" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Heisei' era (1989-01-08 - current) which has the value 2.</source>
          <target state="translated">값이 2 인 'Heisei'시대 (1989-01-08-현재)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="2ad53a43c41fc711e9fc765c7a76f4717f283334" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Meiji' era (1868-01-01 - 1912-07-29) which has the value -1.</source>
          <target state="translated">값이 -1 인 'Meiji'시대 (1868-01-01-1912-07-29)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d90af347fd6251915ffab61ea28205da8ea6f749" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Showa' era (1926-12-25 - 1989-01-07) which has the value 1.</source>
          <target state="translated">값이 1 인 'Showa'시대 (1926-12-25-1989-01-07)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="374b989066c6a8b313cd532f43d4978a478afb4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the 'Taisho' era (1912-07-30 - 1926-12-24) which has the value 0.</source>
          <target state="translated">값이 0 인 'Taisho'시대 (1912-07-30-1926-12-24)의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d1b649d3aca82f1b585114b89db8e7c3dce97afa" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Anno Hegirae', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 단일 인스턴스 인 'Anno Hegirae'는 숫자 값 1을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="33553f68eda534c6d7ec7b5b2097412f8aa169ef" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Buddhist Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '불교 시대 (Buddhist Era)'에 대한 싱글 톤 인스턴스. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="18e0a9282dc09dc3f8d780bd88319f70049b3bc8" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Current Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 싱글 톤 인스턴스 인 'Current Era'. 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="a9078c5f2b2fb0c83101cd2aab438d63e4d37967" translate="yes" xml:space="preserve">
          <source>The singleton instance for the current era, 'Republic of China Era', which has the numeric value 1.</source>
          <target state="translated">현재 시대의 '중화 민국 시대'의 단일 인스턴스이며 숫자 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="831fb5e46d4c1ddc036d82d37411d75aecf60668" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Friday. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">금요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="854466f9d7677acbef6b426929908eeaea0c0ac9" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Monday. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">월요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6eec5084ed707e201918c7bb81e4ef4045f48ec1" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Saturday. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">토요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec410919ffc74e6ed0841570a165d1ab4f8518b3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Sunday. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">일요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b47f4c269ae66d8d89624e16dab12fae314b4ae" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Thursday. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">목요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8710ed5941f516f24bb8dc09854d8cbc78a468d6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Tuesday. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">화요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74f5d636b9653c07ec4dfb5343c1209f6f45dee7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the day-of-week of Wednesday. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">수요일 요일의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7713ef876ec0d0ff70d52271f9980dec01c333d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Buddhist Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '불교 전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b7f42f3144aa34fcb5eacd6614462e8933d9e7c5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Current Era', which has the numeric value 0.</source>
          <target state="translated">현재 값 이전의 'Before Current Era'이전의 싱글 톤 인스턴스이며 숫자 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4b5ed684b1759647e9750f9a4982ba3a88602d2a" translate="yes" xml:space="preserve">
          <source>The singleton instance for the era before the current one, 'Before Republic of China Era', which has the numeric value 0.</source>
          <target state="translated">숫자 값이 0 인 현재 '중국 이전 시대'이전 시대의 싱글 톤 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3498e33856b3bc1fa91dfe207455e4d516871a4f" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of April with 30 days. This has the numeric value of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 4 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0dc754b17787f96f2b3260ec04194b05222744d" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of August with 31 days. This has the numeric value of &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 8 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="afeded1a61c1256c947b92fd91be8f38f688ade2" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of December with 31 days. This has the numeric value of &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 12 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;12&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58ce16c9d66eb0950d2e8d8a844af1f67a40ea2b" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of February with 28 days, or 29 in a leap year. This has the numeric value of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">28 일 또는 윤년 29 일의 2 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbbaed2d99f6b4a91bd5a263c15920ce26db8422" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of January with 31 days. This has the numeric value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 1 월 달의 싱글 톤 인스턴스입니다. 숫자 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbf8150d5e374559752b5a4144a24f8a49cc43d5" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of July with 31 days. This has the numeric value of &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 7 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="171ab07a731170963fee5c54879a243aba461820" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of June with 30 days. This has the numeric value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 6 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c44b47253f5146f50a56c9c4736034ad855145f6" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of March with 31 days. This has the numeric value of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 3 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="695b98cf8bd88f36fe7a8d59e7b014104eb39c42" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of May with 31 days. This has the numeric value of &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 5 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e6f9285c59d2cfa11644efd29aaef36209c76e3" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of November with 30 days. This has the numeric value of &lt;code&gt;11&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 11 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;11&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="77d17e30353cc1d8703e4ac383dfbcf24f64b2d7" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of October with 31 days. This has the numeric value of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">31 일이있는 10 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd70f2cccb7c35228c39eb4016b4bd39aab9ea64" translate="yes" xml:space="preserve">
          <source>The singleton instance for the month of September with 30 days. This has the numeric value of &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">30 일이있는 9 월의 단일 인스턴스입니다. 숫자 값은 &lt;code&gt;9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af1f4f7f642c922c1567312119a5e4ad52a0724a" translate="yes" xml:space="preserve">
          <source>The size of a doc is computed based on the print data representation class as specified by the doc's &lt;a href=&quot;../../docflavor&quot;&gt;&lt;code&gt;DocFlavor&lt;/code&gt;&lt;/a&gt;, as shown in the table below.</source>
          <target state="translated">문서의 크기는 아래 표에 표시된 것처럼 문서의 &lt;a href=&quot;../../docflavor&quot;&gt; &lt;code&gt;DocFlavor&lt;/code&gt; 에&lt;/a&gt; 지정된 인쇄 데이터 표현 클래스를 기반으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="2b33100b39966e88e8e151f1b8c55dcbceae0f08" translate="yes" xml:space="preserve">
          <source>The size of each frame, in bytes.</source>
          <target state="translated">각 프레임의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="8f9034f1b6e8e551c9315d1f020fa1ede6c673ba" translate="yes" xml:space="preserve">
          <source>The size of each segment is estimated by counting the size of each input file to be transmitted in the segment, along with the size of its name and other transmitted properties.</source>
          <target state="translated">각 세그먼트의 크기는 이름 및 기타 전송 된 속성의 크기와 함께 세그먼트에서 전송 될 각 입력 파일의 크기를 계산하여 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="6945db6b9aaec59e9a237996f6de7fd4d6e01473" translate="yes" xml:space="preserve">
          <source>The size of the attribute value, in bytes.</source>
          <target state="translated">속성 값의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="aef354301526547b65cbdbff808019ed00981550" translate="yes" xml:space="preserve">
          <source>The size of the locked region</source>
          <target state="translated">잠긴 영역의 크기</target>
        </trans-unit>
        <trans-unit id="ffd49f5a54a05c0e211000f48c06808a4e45ab2a" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer</source>
          <target state="translated">소켓 수신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="b93eb1ff5703dad725f268be21bfebee369e1241" translate="yes" xml:space="preserve">
          <source>The size of the socket receive buffer.</source>
          <target state="translated">소켓 수신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ac94f9348a7ec8ca8eb5a0577c7a3672cb67beac" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer</source>
          <target state="translated">소켓 송신 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="afb9a30fb21697b87a94f349ade50c4c64721e5a" translate="yes" xml:space="preserve">
          <source>The size of the socket send buffer.</source>
          <target state="translated">소켓 송신 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f546bdf38de152c096164ced3cb3faeef1188d54" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the partition or &lt;code&gt;0L&lt;/code&gt; if this abstract pathname does not name a partition</source>
          <target state="translated">파티션의 크기 (바이트) 또는 이 추상 경로명이 파티션 이름을 지정하지 않는 경우 &lt;code&gt;0L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eccc9011507e2f8d69cd68d30db124741a00ce17" translate="yes" xml:space="preserve">
          <source>The smallest integer in this set-of-integer attribute that is greater than &lt;code&gt;x&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; if no integer in this set-of-integer attribute is greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보다 큰 정수형 세트의 특성에 작은 정수 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 정수형 세트의 속성에는 정수를 초과하지 않는 경우 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3e306f7c43f12a0cd31a1e11f56ee1c06bddfe" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0. When &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, various methods may throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; on an attempt to access data associate with an image having a lower index.</source>
          <target state="translated">판독 할 때의 최소 유효 인덱스는 초기에 0 &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; , 다양한 방법은 던질 수 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 화상 낮은 인덱스를 갖는 데이터 액세스 연관시킬 시도.</target>
        </trans-unit>
        <trans-unit id="d34a10ed96641b907e1eb213e81431652411700a" translate="yes" xml:space="preserve">
          <source>The socket address that the socket is bound to, or &lt;code&gt;null&lt;/code&gt; if the channel's socket is not bound</source>
          <target state="translated">소켓이 바인드 된 소켓 주소 또는 채널의 소켓이 바인드되지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004c4bf3ac859ce08e79a8b3e914c8cf5426cb22" translate="yes" xml:space="preserve">
          <source>The socket channel for the new connection, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no connection is available to be accepted</source>
          <target state="translated">새로운 접속의 소켓 채널. 이 채널이 비 블로킹 모드에있어 접속 가능한 접속이없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72330096ca60d13bfb3300d243f2b2b77e32b537" translate="yes" xml:space="preserve">
          <source>The socket channel returned by this method, if any, will be in blocking mode regardless of the blocking mode of this channel.</source>
          <target state="translated">이 메소드에 의해 돌려 주어진 소켓 채널은,이 채널의 블록킹 모드에 관계없이 차단 모드에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="0916495727f93025eff6a66cbf7b722521e11aa1" translate="yes" xml:space="preserve">
          <source>The socket factories are used when creating sockets for secure https URL connections.</source>
          <target state="translated">소켓 팩토리는 안전한 https URL 연결을위한 소켓을 만들 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b1dacea19873875bd394d1604a0e5a5d30890d" translate="yes" xml:space="preserve">
          <source>The sockets returned to the application can be subclasses of java.net.Socket, so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.</source>
          <target state="translated">애플리케이션에 리턴 된 소켓은 java.net.Socket의 서브 클래스 일 수 있으므로 압축, 보안, 레코드 표시, 통계 콜렉션 또는 방화벽 터널링과 같은 기능에 대한 새 API를 직접 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e877bbc8bfc38843765b0308b8332044317fbf2a" translate="yes" xml:space="preserve">
          <source>The sole constructor.</source>
          <target state="translated">유일한 생성자.</target>
        </trans-unit>
        <trans-unit id="d5d133be61491e0ac1417ab0eba748b3aa345615" translate="yes" xml:space="preserve">
          <source>The sole purpose of these additions is to allow the specification of tables for use in decoding abbreviated streams. The built-in JPEG reader will also accept an ordinary &lt;code&gt;ImageReadParam&lt;/code&gt;, which is sufficient for decoding non-abbreviated streams.</source>
          <target state="translated">이러한 추가의 유일한 목적은 축약 된 스트림을 디코딩하는 데 사용하기위한 테이블 지정을 허용하는 것입니다. 내장 JPEG 리더는 일반 &lt;code&gt;ImageReadParam&lt;/code&gt; 을 수용하므로 단축되지 않은 스트림을 디코딩하는 데 충분합니다.</target>
        </trans-unit>
        <trans-unit id="38844e94f41cc1969fb62e4894696634a14fe20b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="75b2a84749a330a1c0b895e2bdf2312622f71cb8" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a31ccdaba6cb746cb91c886a84a8c2d7c538b7" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="48b9a8628a4883f257650b1adf775491c8f08839" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="d3cac5983cf37dcfe292291f746e0459fd7e8669" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="08eda0222f2f9308c70c208bbdafe98a9e736807" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="1b5efb4aa3ea50144cc0394f060b745aadbd838e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b9ac2ce61dcea76b147223bff87472496593df2a" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 하위 배열은 적절한&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ff09cbb5362e1360ac15f00a55f46a71d4e41ca1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="edc68fa2b5db74746879cf023d506ffd46c30425" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="839592e0ded3d9de75771fbf4886b637ea10acea" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="614e7b8df8741ffaa018e919714cf7473694c642" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="648b93b50bbd09b1605688594b8660ecbbb90d1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="0247ed33cde4f71d592e6d7daa37c7760b936d47" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 작은 최소 단위보다 긴 경우, 그것은 적절한하여 정렬 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="777d40468912737a83340f22bc67c6f77af71aaf" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="e41f68150d548775a312ef7c6bad1b753c9c647c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. 그만큼&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="368f0e5364e526b1a62ff1d9e84b032a4799d112" translate="yes" xml:space="preserve">
          <source>The source address if this membership key is source-specific, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이 멤버쉽 키가 소스 별 인 경우 소스 주소 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c54b79003a5eb4cba89a06459605f65bd7f13fd" translate="yes" xml:space="preserve">
          <source>The source bean is used as the source of events for the property changes. This source should be used for information purposes only and should not be modified by the PropertyEditor.</source>
          <target state="translated">소스 Bean은 특성 변경에 대한 이벤트 소스로 사용됩니다. 이 소스는 정보 용으로 만 사용해야하며 PropertyEditor에서 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d614f9d4f31f56431b30829db0ada88a1526496a" translate="yes" xml:space="preserve">
          <source>The source cannot be structurally interfered with.</source>
          <target state="translated">소스는 구조적으로 방해 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61689ca13fa0754b0dac1fef1851f1593b2946cb" translate="yes" xml:space="preserve">
          <source>The source format represents the format of the incoming audio data, which will be converted.</source>
          <target state="translated">소스 형식은 들어오는 오디오 데이터의 형식을 나타내며 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="46df136cd9cc4668c308b326cb05d7ed6808c192" translate="yes" xml:space="preserve">
          <source>The source increases the likelihood of throwing &lt;code&gt;ConcurrentModificationException&lt;/code&gt; since the window of potential interference is larger.</source>
          <target state="translated">잠재적 인 간섭의 창이 더 크기 때문에 소스는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 던질 가능성을 높입니다 .</target>
        </trans-unit>
        <trans-unit id="c1f61cf74a08642c4ff7ee4b8bc3cda7829bff8b" translate="yes" xml:space="preserve">
          <source>The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</source>
          <target state="translated">소스는 구성 후에 감지되지 않은 간섭이 발생할 수 있으므로 임의의 비 결정적 동작의 위험을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="7f5e35322fb74527344b994cfeb8d4a21c655439" translate="yes" xml:space="preserve">
          <source>The source manages concurrent modifications.</source>
          <target state="translated">소스는 동시 수정을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="8a5d1008eaa1af299fb1410c7693c63aa92311bc" translate="yes" xml:space="preserve">
          <source>The source object is the Relation Service itself.</source>
          <target state="translated">소스 오브젝트는 관계 서비스 자체입니다.</target>
        </trans-unit>
        <trans-unit id="ba472d8058ce42e7759745b4cd537b6da4c0628f" translate="yes" xml:space="preserve">
          <source>The source of this event is the SSLSocket on which handshaking just completed.</source>
          <target state="translated">이 이벤트의 소스는 핸드 쉐이킹이 완료된 SSLSocket입니다.</target>
        </trans-unit>
        <trans-unit id="34b28226ae9b0c9b05be3b2b72d0f78f8a72db57" translate="yes" xml:space="preserve">
          <source>The source of this pattern</source>
          <target state="translated">이 패턴의 근원</target>
        </trans-unit>
        <trans-unit id="9d040b79148889dda3be3cace827402195b26754" translate="yes" xml:space="preserve">
          <source>The source region of interest specified by this method will be clipped as needed to fit within the source bounds, as well as the destination offsets, width, and height at the time of actual I/O.</source>
          <target state="translated">이 방법으로 지정된 소스 관심 영역은 실제 I / O시 대상 오프셋, 너비 및 높이뿐만 아니라 소스 경계 내에 맞추기 위해 필요에 따라 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6c425edd2b72c5bd49ce0000e1e9c0d010d1b680" translate="yes" xml:space="preserve">
          <source>The source region, on &lt;code&gt;null&lt;/code&gt; if none is set.</source>
          <target state="translated">소스 영역 . 설정되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79992770a23d8083e338e39d04240948297bfa86" translate="yes" xml:space="preserve">
          <source>The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</source>
          <target state="translated">간섭이 감지되지 않기 때문에 통과가 시작된 후 소스는 임의의 비 결정적 동작의 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7900bed2b0d5a0428294adba3589eaef49b81ef4" translate="yes" xml:space="preserve">
          <source>The space character &quot; &quot; is converted into a plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot;.</source>
          <target state="translated">공백 문자 &quot;&quot;는 더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="507149f00d63c959176bee1f4d30e062fc83fdd7" translate="yes" xml:space="preserve">
          <source>The special characters &quot;&lt;code&gt;.&lt;/code&gt;&quot;, &quot;&lt;code&gt;-&lt;/code&gt;&quot;, &quot;&lt;code&gt;*&lt;/code&gt;&quot;, and &quot;&lt;code&gt;_&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">특수 문자 &quot; &lt;code&gt;.&lt;/code&gt; &quot;, &quot; &lt;code&gt;-&lt;/code&gt; &quot;, &quot; &lt;code&gt;*&lt;/code&gt; &quot;및 &quot; &lt;code&gt;_&lt;/code&gt; &quot;는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d1df01fb5b8d33027995ef22465c9c621f1abe" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">특수 메소드 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt; 은 지정된 권한으로 표시된 액세스 요청을 승인할지 거부 할지를 결정합니다. 기본 구현 호출</target>
        </trans-unit>
        <trans-unit id="32010eba7b4259d4453391d1922bfa0e43808b88" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt; 와 같은 의미로 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다 . 이를 통해 사용자는 클래스 압축없이 특정 속성을 거부, 제거 또는 비트 단위로 전달하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a13bd69809d0a0a05735ac36655ba584ce36412" translate="yes" xml:space="preserve">
          <source>The special value 0 instructs the packer to copy through the original JAR file directly, with no compression. The JSR 200 standard requires any unpacker to understand this special case as a pass-through of the entire archive.</source>
          <target state="translated">특수 값 0은 압축하지 않고 패커가 원본 JAR 파일을 직접 복사하도록 지시합니다. JSR 200 표준은 압축 풀기 사용자가이 특수 사례를 전체 아카이브의 통과로 이해하도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="bb3de17aa29974030176e4818ff90fa588d4cccd" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next--&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#next--&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt; 상자 기본 값 의 특수 하위 유형 기본 구현은 해당 랩퍼 클래스의 인스턴스에 적용됩니다. 이러한 복싱은 원시 전문화를 사용할 때 얻는 모든 이점을 상쇄 할 수 있습니다. 복싱을 피하려면 해당하는 기본 기반 방법을 사용해야합니다. 예를 들어 &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;) 보다 우선적으로 사용해야합니다. 소비자) .</target>
        </trans-unit>
        <trans-unit id="d6f9034bc2b0e9e47c35477b9b0c1050884a6e58" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and Double.</source>
          <target state="translated">&lt;a href=&quot;#floatDWidth&quot;&gt;너비&lt;/a&gt; 와 &lt;a href=&quot;#floatDPrec&quot;&gt;정밀도&lt;/a&gt; 의 지정은 Float 및 Double에 정의 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa9ee937f65b438b3e28d90ed076c5fb130b0ebe" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as defined for Byte, Short, Integer, and Long.</source>
          <target state="translated">의 사양 &lt;a href=&quot;#intWidth&quot;&gt;폭은&lt;/a&gt; Byte, Short, Integer, 및 Long로 정의 된 사양과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a10ca3cba79e422f1740bb3e0934c522a4f1925b" translate="yes" xml:space="preserve">
          <source>The specification of the &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/a&gt; class describes the naming conventions for character encodings as well as the set of standard encodings that must be supported by every implementation of the Java platform.</source>
          <target state="translated">&lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;java.nio.charset.Charset&lt;/code&gt; &lt;/a&gt; 클래스 의 스펙은 문자 인코딩의 이름 지정 규칙과 Java 플랫폼의 모든 구현에서 지원해야하는 표준 인코딩 세트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5bc479f4b94e6ed3adb52c78855a8eaf971be4f5" translate="yes" xml:space="preserve">
          <source>The specifications of these methods enable implementations to employ efficient machine-level atomic instructions that are available on contemporary processors. However on some platforms, support may entail some form of internal locking. Thus the methods are not strictly guaranteed to be non-blocking -- a thread may block transiently before performing the operation.</source>
          <target state="translated">이러한 방법의 사양을 통해 구현시 최신 프로세서에서 사용할 수있는 효율적인 기계 수준의 원자 명령어를 사용할 수 있습니다. 그러나 일부 플랫폼에서는 일부 형태의 내부 잠금이 지원 될 수 있습니다. 따라서이 방법은 비 차단임을 반드시 보장하지는 않습니다. 작업을 수행하기 전에 스레드가 일시적으로 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62478b55800b13e9edc844048f06d81a5395c823" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;SecretKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;SecretKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce6192f33f7b86e9ead09fddf2eb53ecad7d96e2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="d471977883e3ea29098c508c72fa94025049aa80" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; are cloned before they are stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 과 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 개체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="feecfb1f75d3f2369d375a91acbc68cab6f7dc08" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 은 새로운 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="91787ab6a545bac8438e8b3009f062a3b8a33372" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;name&lt;/code&gt; cannot begin with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, since all classes in the &quot;&lt;code&gt;java.*&lt;/code&gt; packages can only be defined by the bootstrap class loader. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &quot;&lt;code&gt;b&lt;/code&gt;&quot;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&quot; &lt;code&gt;java.*&lt;/code&gt; 패키지 의 모든 클래스 는 부트 스트랩 클래스 로더로만 정의 할 수 있으므로 지정된 &lt;code&gt;name&lt;/code&gt; 은&quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작할 수 없습니다 . &lt;code&gt;name&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 지정된 클래스 의 &lt;a href=&quot;#name&quot;&gt;이진 이름&lt;/a&gt; 과 같아야합니다. 바이트 배열 &quot; &lt;code&gt;b&lt;/code&gt; &quot;, 그렇지 않으면 &lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eaef74f38f0fefbf6b797c4d769b36b62a96e610" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PasswordProtection&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;password&lt;/code&gt; 는 새 &lt;code&gt;PasswordProtection&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18dc4bf1e553fd51a6ef779b53c94ede909086a" translate="yes" xml:space="preserve">
          <source>The specified MBean does not exist in the repository.</source>
          <target state="translated">지정된 MBean이 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="1da5f575f6552b129ebced03a3fcca62b2e49042" translate="yes" xml:space="preserve">
          <source>The specified MBean listener does not exist in the repository.</source>
          <target state="translated">지정된 MBean 리스너가 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="190c4561e923b6d02247206d09c8f34b9f935a7d" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 금액은 일반적으로 &lt;code&gt;Period&lt;/code&gt; 인스턴스입니다 . 다른 유형은 &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f3bf406b8fb479bb6ba897f4dfcf1ddc3eae351" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. If &lt;code&gt;timeout&lt;/code&gt; is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</source>
          <target state="translated">지정된 실시간 시간이 다소 경과했습니다. 그러나 &lt;code&gt;timeout&lt;/code&gt; 가 0이면 실시간이 고려되지 않고 스레드가 통지 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="2fb0d14ec3b91bd96d9fc6ab5161cd7aea17ba63" translate="yes" xml:space="preserve">
          <source>The specified attribute does not exist or cannot be retrieved.</source>
          <target state="translated">지정된 속성이 존재하지 않거나 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b8d3e0653b6d1561f69a4fc51247490be2c9fff" translate="yes" xml:space="preserve">
          <source>The specified deadline elapses; or</source>
          <target state="translated">지정된 마감 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="dfc1facec1624a9e49107544937a16179ab58cc9" translate="yes" xml:space="preserve">
          <source>The specified deadline passes; or</source>
          <target state="translated">지정된 마감일이 지났습니다. 또는</target>
        </trans-unit>
        <trans-unit id="5247131e5691f2b17d264ef1c3dfc670058c9a69" translate="yes" xml:space="preserve">
          <source>The specified default value.</source>
          <target state="translated">지정된 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="310ae4a82260e2743fd9957091b33702914d499e" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching MediaSize instance from amongst all the standard MediaSize instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">지정된 차원은 모든 표준 MediaSize 인스턴스에서 일치하는 MediaSize 인스턴스를 찾는 데 사용됩니다. 정확히 일치하는 것이 없으면 가장 가까운 일치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="104dce0f8cf047aa941594c95f88524f18e28ce2" translate="yes" xml:space="preserve">
          <source>The specified list must be modifiable, but need not be resizable.</source>
          <target state="translated">지정된 목록은 수정 가능해야하지만 크기를 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f09ffd7e81a93fd6948e5a765fff32edb59db61" translate="yes" xml:space="preserve">
          <source>The specified map contains the current state of the parse. The map is mutable and must be mutated to resolve the field and any related fields. This method will only be invoked during parsing if the map contains this field, and implementations should therefore assume this field is present.</source>
          <target state="translated">지정된 맵에는 구문 분석의 현재 상태가 포함됩니다. 맵은 변경 가능하며 필드 및 관련 필드를 해결하려면 변경해야합니다. 이 메소드는 맵에이 필드가 포함 된 경우 구문 분석 중에 만 호출되므로 구현시이 필드가 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="493032b220120145406a2c95c31eb22182fdc14e" translate="yes" xml:space="preserve">
          <source>The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:</source>
          <target state="translated">지정된 맵은이 메소드가 호출 될 때 비어 있어야하며이 메소드가 리턴 된 후 직접 액세스해서는 안됩니다. 다음 코드 조각에 표시된대로 맵이 비어 있고이 메소드에 직접 전달되고 맵에 대한 참조가 유지되지 않으면 이러한 조건이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d2949ab1852b4adf83258648df2f3d3aea9bdc" translate="yes" xml:space="preserve">
          <source>The specified number of bytes have been read,</source>
          <target state="translated">지정된 바이트 수를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="04268be0844ec6f86b3371c45be5d6b167be71f6" translate="yes" xml:space="preserve">
          <source>The specified number of characters have been read,</source>
          <target state="translated">지정된 수의 문자를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="8b6cc3dc228a55bbb5be0ad0c4aa456b38c93c73" translate="yes" xml:space="preserve">
          <source>The specified stream is closed after this method returns.</source>
          <target state="translated">이 메소드가 반환 된 후 지정된 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="51786fb87bcf180e4b0079696fd451f32baf2367" translate="yes" xml:space="preserve">
          <source>The specified stream remains open after this method returns.</source>
          <target state="translated">지정된 스트림은이 메서드가 반환 된 후에도 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7526737a0fdb5c1ec28cb0f7e645a738da9f21ee" translate="yes" xml:space="preserve">
          <source>The specified string</source>
          <target state="translated">지정된 문자열</target>
        </trans-unit>
        <trans-unit id="2615e62cfbfda5abfd51b12dbda35048bb40079b" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units added.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위가 추가 된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="157250d9b4b02aeb6925cbf93c8ae0c1bd6e00ac" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units subtracted.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위를 뺀 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc9a505a8f5c31216ff0ecff5662a313bc10a9ec" translate="yes" xml:space="preserve">
          <source>The specified temporal objects must support the &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt; unit. For full accuracy, either the &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt; unit or the &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; field should be supported.</source>
          <target state="translated">지정된 임시 오브젝트는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 단위를 지원해야합니다 . 정확성을 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 려면 NANOS 장치 또는 &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 필드가 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9126ea58e2571bc036db8beb3f6e7cb81714d752" translate="yes" xml:space="preserve">
          <source>The specified timeout elapses; or</source>
          <target state="translated">지정된 시간이 초과되었습니다. 또는</target>
        </trans-unit>
        <trans-unit id="b837498e4f5bfb7ecf362b5a40901bb42bb72876" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses</source>
          <target state="translated">지정된 대기 시간이 경과합니다</target>
        </trans-unit>
        <trans-unit id="2e16f4e41d2bec157ff32585a40c8df18c39455f" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses.</source>
          <target state="translated">지정된 대기 시간이 경과합니다.</target>
        </trans-unit>
        <trans-unit id="f6172c989e04cb91e71e97089eeadbcfd41054bf" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses; or</source>
          <target state="translated">지정된 대기 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="358fe8f4c03c65db9f92645925be98830ef03da4" translate="yes" xml:space="preserve">
          <source>The spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되고 컬렉션 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하도록 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="5c3d939c98fbccf6b0709b1993b6b3ad3fbfd412" translate="yes" xml:space="preserve">
          <source>The spliterator is not &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되지 않고 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하기 위해 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="c89136b191a7ef1fb716259822efc70d2b8982ba" translate="yes" xml:space="preserve">
          <source>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</source>
          <target state="translated">스플리터는 스트림 파이프 라인의 터미널 작업이 시작된 후 예상 크기에 대해서만 순회, 스플릿 또는 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="2e796cc75190234b6abcae4603bbe835004bc5ff" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6fc47357accd5ef236f3f5c242ba1b0d8c1cb4" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c63ef1d32be1189c32d967974dfe2fc9a2f274a" translate="yes" xml:space="preserve">
          <source>The spliterator reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt;&lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스플리터는 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt; &lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt; 을보고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c0e1fd6ad7e570320cb5c4dec58534b0c8203896" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the set's comparator (see &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the set's comparator.</source>
          <target state="translated">세트의 비교 자 ( &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면, 스플리터의 비교기는 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="48dde829f5e209bbf80a37d8886c87c609c3d85b" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;treeset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">트리 세트의 비교 자 ( &lt;a href=&quot;treeset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="5d0a078e5e6eab06b16fc00059f9764476f503fd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;sortedset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">정렬 된 세트의 비교기 ( &lt;a href=&quot;sortedset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 이어야합니다 . 그렇지 않으면 스플리터의 비교기가 정렬 된 세트의 비교기와 동일하거나 동일한 총 순서를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="81c6f54339613405ef47fa4cf7fd2cfc6963fe4e" translate="yes" xml:space="preserve">
          <source>The spliterators for &lt;code&gt;Collection&lt;/code&gt; classes in the JDK that implement &lt;a href=&quot;navigableset&quot;&gt;&lt;code&gt;NavigableSet&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; report &lt;code&gt;SORTED&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;navigableset&quot;&gt; &lt;code&gt;NavigableSet&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; &lt;/a&gt; 보고서 를 구현하는 JDK의 &lt;code&gt;Collection&lt;/code&gt; 클래스에 대한 스플리터는 &lt;code&gt;SORTED&lt;/code&gt; 를 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="cd697bf3371b30cc43133d20204f9b133ffb8c0e" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 및 추가로 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f5421d4c1a6fd2ddf5564c1dd18506c0df41358" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are created from the iterators of the corresponding collections.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 대응하는 콜렉션의 반복자로부터 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ec658a969bcb92aa1baad080b6a1974cf0ea66e2" translate="yes" xml:space="preserve">
          <source>The standard AC chrominance Huffman table.</source>
          <target state="translated">표준 AC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="de7f2a4797f9371ba730de4782f10f7289878bf4" translate="yes" xml:space="preserve">
          <source>The standard AC luminance Huffman table.</source>
          <target state="translated">표준 AC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="c018ce1af2d766ca3e1a4abc0ceaf42164f207ce" translate="yes" xml:space="preserve">
          <source>The standard DC chrominance Huffman table.</source>
          <target state="translated">표준 DC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="a329f8b4144b879c7b6f5ae550949bccdbf73f49" translate="yes" xml:space="preserve">
          <source>The standard DC luminance Huffman table.</source>
          <target state="translated">표준 DC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="db8c6341d94f5edfcecbdce8b46d6840a2f9998a" translate="yes" xml:space="preserve">
          <source>The standard MultipleDocumentHandling values are:</source>
          <target state="translated">표준 MultipleDocumentHandling 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92cab317859f368c1aae7d7671cb740196644a9d" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, thus 3.25 would represent the time 18:00, since days start at midday. This implementation uses an integer and days starting at midnight. The integer value for the Julian Day Number is the astronomical Julian Day value at midday of the date in question. This amounts to the astronomical Julian Day, rounded to an integer &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt;.</source>
          <target state="translated">표준 천문학적 정의는 분수를 사용하여 하루 중 시간을 나타내므로 하루가 정오에 시작하므로 3.25는 18:00 시간을 나타냅니다. 이 구현은 자정에 시작하는 정수와 요일을 사용합니다. Julian Day Number의 정수 값은 해당 날짜의 정오에 천문학적 Julian Day 값입니다. 이것은 천문학적 줄리안 데이에 해당하며 정수 &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt; 반올림됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebd97f6234307a116f96853fd3903e56b9d40331" translate="yes" xml:space="preserve">
          <source>The standard default domain name is &lt;code&gt;DefaultDomain&lt;/code&gt;.</source>
          <target state="translated">표준 기본 도메인 이름은 &lt;code&gt;DefaultDomain&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef55295fde5154a258f26679975fa232098fcdbf" translate="yes" xml:space="preserve">
          <source>The standard file manager serves two purposes:</source>
          <target state="translated">표준 파일 관리자는 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7ea3f0338f77cf538431691011f031baff3b34" translate="yes" xml:space="preserve">
          <source>The standard file manager will be automatically reopened if it is accessed after calls to &lt;code&gt;flush&lt;/code&gt; or &lt;code&gt;close&lt;/code&gt;. The standard file manager must be usable with other tools.</source>
          <target state="translated">표준 파일 관리자는 &lt;code&gt;flush&lt;/code&gt; 또는 &lt;code&gt;close&lt;/code&gt; 호출 후 액세스되면 자동으로 다시 열립니다 . 표준 파일 관리자는 다른 도구와 함께 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8f169d2bb832c35eba59bc410c0b85f0003b6f8" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="be4242d6a22a82129b32c761e9b997ab8bdb7b76" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다. DSA (Digital Signature Algorithm)는 NIST의 FIPS-186에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c927c0ada9cba1ad53c2c1bf1aa34f20c5ec2c56" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이들은 &lt;code&gt;YEAR&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="552969cac10043f5eb1e8db38405b389d7505393" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이지도는 &lt;code&gt;YEAR&lt;/code&gt; 에 &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a269f562c7ddcb5223b4c729ca3aacff15045f7" translate="yes" xml:space="preserve">
          <source>The standard set of non-localized decimal style symbols.</source>
          <target state="translated">현지화되지 않은 10 진수 스타일 기호의 표준 세트입니다.</target>
        </trans-unit>
        <trans-unit id="085376bdd00c3589b2477d9a9b7e25e5aa764bdf" translate="yes" xml:space="preserve">
          <source>The standard text outputting methods use the localized text in the JDK. This method allows that text to be specified directly. The supplied map is not validated by the builder to ensure that formatting or parsing is possible, thus an invalid map may throw an error during later use.</source>
          <target state="translated">표준 텍스트 출력 방법은 JDK에서 지역화 된 텍스트를 사용합니다. 이 방법을 사용하면 해당 텍스트를 직접 지정할 수 있습니다. 제공된 맵은 형식화 또는 구문 분석이 가능한지 확인하기 위해 빌더에 의해 유효성 검증되지 않으므로 유효하지 않은 맵은 나중에 사용하는 동안 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace8ff3c243593fda8f90cc8a3f288d71a11483d" translate="yes" xml:space="preserve">
          <source>The standard value of the propertyName as fired from a BeanContext or other source of PropertyChangeEvents.</source>
          <target state="translated">BeanContext 또는 다른 PropertyChangeEvents 소스로부터 시작된 propertyName의 표준치입니다.</target>
        </trans-unit>
        <trans-unit id="f3bed9164e92a7973b9cbcd9ad79594c005f0947" translate="yes" xml:space="preserve">
          <source>The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3c2d246e90e00803aeb29283b1b8bc16d249d5bc" translate="yes" xml:space="preserve">
          <source>The start argument must be nonnegative, and not greater than &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">start 인수는 음이 아니어야하고 &lt;code&gt;end&lt;/code&gt; 보다 크지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ddf7bb81f0c34d9260c89803dda3e7e413e128" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then normalized into years and months based on a 12 month year. A month is considered to be complete if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is &quot;1 year, 2 months and 3 days&quot;.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 완전한 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 연도 및 월로 정규화됩니다. 월말이 시작일보다 크거나 같으면 한 달이 완료된 것으로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 &quot;1 년, 2 개월 및 3 일&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6620cb9be5fc56436fc3a7c1b18ff6874dd29e0c" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then split into years and months based on a 12 month year. A month is considered if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is one year, two months and three days.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 전체 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 년과 월로 분할됩니다. 월말이 시작일보다 크거나 같은 경우 한 달로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 1 년, 2 개월 3 일입니다.</target>
        </trans-unit>
        <trans-unit id="9238c2af9e0839f3491092fc2fe2b2c12cadecf1" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 사용하여 계산됩니다 . 따라서 계산은 시간순으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2264eaa8f12a8a3d18c204a6414263d50eec329f" translate="yes" xml:space="preserve">
          <source>The starting point of this matcher's region</source>
          <target state="translated">이 매처 지역의 시작점</target>
        </trans-unit>
        <trans-unit id="711145c27ccf3166aa36ebb810ced05b44da407a" translate="yes" xml:space="preserve">
          <source>The state factories tried must each implement either &lt;code&gt;StateFactory&lt;/code&gt; or &lt;code&gt;DirStateFactory&lt;/code&gt;. If it implements &lt;code&gt;DirStateFactory&lt;/code&gt;, then &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; is called; otherwise, &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; is called.</source>
          <target state="translated">시도한 상태 팩토리는 각각 &lt;code&gt;StateFactory&lt;/code&gt; 또는 &lt;code&gt;DirStateFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirStateFactory&lt;/code&gt; 다음을, &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; 라고합니다; 그렇지 않으면 &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b4593a62342b2b46d5d7ee91609ae7dd334526" translate="yes" xml:space="preserve">
          <source>The state maintained by an instance of &lt;code&gt;ImageReadParam&lt;/code&gt; is independent of any particular image being decoded. When actual decoding takes place, the values set in the read param are combined with the actual properties of the image being decoded from the stream and the destination &lt;code&gt;BufferedImage&lt;/code&gt; that will receive the decoded pixel data. For example, the source region set using &lt;code&gt;setSourceRegion&lt;/code&gt; will first be intersected with the actual valid source area. The result will be translated by the value returned by &lt;code&gt;getDestinationOffset&lt;/code&gt;, and the resulting rectangle intersected with the actual valid destination area to yield the destination area that will be written.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 의 인스턴스에 의해 유지되는 상태 는 디코딩되는 특정 이미지와 무관합니다. 실제 디코딩이 수행 될 때, 판독 파라미터에 설정된 값은 스트림으로부터 디코딩되는 이미지의 실제 속성 및 디코딩 된 픽셀 데이터를 수신 할 목적지 &lt;code&gt;BufferedImage&lt;/code&gt; 와 결합된다 . 예를 들어, &lt;code&gt;setSourceRegion&lt;/code&gt; 을 사용하여 설정된 소스 영역 을 은 먼저 실제 유효한 소스 영역과 교차합니다. 결과는 &lt;code&gt;getDestinationOffset&lt;/code&gt; 에서 반환 한 값으로 변환되고 결과 사각형은 실제 유효한 대상 영역과 교차하여 작성 될 대상 영역을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31371db7bcedb5e6ef0fa2a822080261021c1cbf" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 파일 속성보기가 작성 될 때 파일이 존재하지 않아도되지만 호출 될 때 파일의 속성을 읽거나 업데이트하는 메소드가 실패하고 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e75ea05d69038d832d8131b3848e4927b08478a" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd113847fce5d615aef061976b5b5490ed246b1" translate="yes" xml:space="preserve">
          <source>The static methods of this class are also guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0f94f9998daea410fa7e45671e8cee561746d9" translate="yes" xml:space="preserve">
          <source>The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af2436810c570bd5737c0e2bb02a5d795441443" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add-E-&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">위의 규정은 세트가 모든 요소를 ​​수용해야 함을 의미하지는 않습니다. set은 &lt;a href=&quot;collection#add-E-&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt; 사양에 설명 된대로 &lt;code&gt;null&lt;/code&gt; 을 포함한 특정 요소 추가를 거부 하고 예외를 throw 할 수 있습니다. 개별 집합 구현에는 포함될 수있는 요소에 대한 제한 사항이 명확하게 문서화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="18eb68b1ed315d63fa4df9e04e256a50303f9665" translate="yes" xml:space="preserve">
          <source>The stored chain is cloned before being returned.</source>
          <target state="translated">저장된 체인은 반환되기 전에 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="284a200aa5c754806caf07fbf13e99a88b0c7015" translate="yes" xml:space="preserve">
          <source>The stream is</source>
          <target state="translated">스트림은</target>
        </trans-unit>
        <trans-unit id="0f4127d1899727942c90922302e4fcbdc49bed7d" translate="yes" xml:space="preserve">
          <source>The stream is parallel;</source>
          <target state="translated">스트림은 평행하다.</target>
        </trans-unit>
        <trans-unit id="18c2dad420890c0c93e56bc71847c1ffc91d517a" translate="yes" xml:space="preserve">
          <source>The stream is written using the ISO 8859-1 character encoding.</source>
          <target state="translated">스트림은 ISO 8859-1 문자 인코딩을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40953f480e1f2608bd2829d4c5ca6a88b49f29cb" translate="yes" xml:space="preserve">
          <source>The stream of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">이 패턴의 일치 항목 주위에 입력을 분할하여 계산 된 문자열 스트림</target>
        </trans-unit>
        <trans-unit id="0278f0c3b2832857f3b5d471e56fa1f750974135" translate="yes" xml:space="preserve">
          <source>The stream position is left at its prior position upon exit from this method.</source>
          <target state="translated">이 방법에서 나갈 때 스트림 위치는 이전 위치에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c88da049e966b7fa1b0336d227d0469c10d044c" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream.</source>
          <target state="translated">이 메소드에 의해 리턴 된 스트림은이 패턴과 일치하는 다른 서브 시퀀스에 의해 종료되거나 입력 시퀀스의 끝에 의해 종료되는 입력 시퀀스의 각 서브 스트링을 포함합니다. 스트림의 하위 문자열은 입력에서 발생하는 순서입니다. 후행 빈 문자열은 버리고 스트림에서 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8035d3c148eb320bea2a1229c6025747c0adc1f8" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않습니다 . 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="bc7063010775a8a4dfbf6ea7c3f4fd8168851da4" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않습니다. 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="08ace5725b5a326d5041f65d175699034a1c1db6" translate="yes" xml:space="preserve">
          <source>The string &quot;error&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;error&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfc3fe82f3ff5835f163f82fa9c6c4dba766b9ab" translate="yes" xml:space="preserve">
          <source>The string &quot;false&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;false&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e30c0643390c5dc7ebd25358b9755769e7551051" translate="yes" xml:space="preserve">
          <source>The string &quot;keep&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;keep&quot;은 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="1f0cf467ff107c2e23c66f6d76abd1c756e88c98" translate="yes" xml:space="preserve">
          <source>The string &quot;latest&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;latest&quot;문자열</target>
        </trans-unit>
        <trans-unit id="108f1155e473064ee5869a10046f49c5f28678dc" translate="yes" xml:space="preserve">
          <source>The string &quot;pass&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;pass&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="558ef0c8eaf4af89eed40f1773ec89e05db3ff2d" translate="yes" xml:space="preserve">
          <source>The string &quot;strip&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;strip&quot;, 특정 속성에 가능한 값.</target>
        </trans-unit>
        <trans-unit id="465f99ea7628c0edb2cf953567db0aafbc5f0067" translate="yes" xml:space="preserve">
          <source>The string &quot;true&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;true&quot;문자열</target>
        </trans-unit>
        <trans-unit id="b7d2fbb70acb3059d5c5bbd79c4294963cdbf352" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;IOException&lt;/code&gt; 유형을 제외하고 전체 팩 조작이 실패 함을 의미합니다 . 문자열 &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 는 속성이 삭제됨을 의미합니다. 문자열 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 는 적절한 경고와 함께 전체 클래스 파일이 압축없이 (리소스 파일 인 것처럼) 전달됨을 의미합니다. 이것이이 속성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ad02c3d243be4e9c61737e03ba9c0bf8b38dbb60" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these expressions:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 표현식으로 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0a75a6f894f0ae1c44cee0d9fcd6514b9f78e1dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these parameters:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 매개 변수를 사용하여 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6550e9f9888c201023a4fc7c4d06f985451147bf" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; , 바로 뒤에 &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt; 메서드에서 생성 된 것처럼 정밀도 설정 값이 숫자 문자열로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="62905723a8ac431fa9dccaf628bb9c07af02e5dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt;, immediately followed by the value of the &lt;code&gt;roundingMode&lt;/code&gt; setting as a word. This word will be the same as the name of the corresponding public constant in the &lt;a href=&quot;roundingmode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt; , 바로 뒤에 &lt;code&gt;roundingMode&lt;/code&gt; 설정 값이 단어로 표시됩니다. 이 단어는 &lt;a href=&quot;roundingmode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; 열거 형 의 해당 공용 상수 이름과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a056f3c02b144a1272485d342c4c2a38f8a60c41" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean is an &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly with the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">이 MBean에 따른 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 는 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다. MBean Server에 직접 등록되거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 작성된 표준 MBean 또는 MXBean 은이 필드를 MBeanInfo 디스크립터에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fa3bdb340e93ffe54892a6e3894a1d8cb94a703a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean's MBeanInfo is &lt;em&gt;immutable&lt;/em&gt;. When this field is true, the MBeanInfo for the given MBean is guaranteed not to change over the lifetime of the MBean. Hence, a client can read it once and cache the read value. When this field is false or absent, there is no such guarantee, although that does not mean that the MBeanInfo will necessarily change. See also the &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; notification.</source>
          <target state="translated">이 MBean MBeanInfo로서의 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 캐릭터 라인 은 &lt;em&gt;불변&lt;/em&gt; 입니다. 이 필드가 true 인 경우, 지정된 MBean의 MBeanInfo는 MBean의 수명 동안 변경되지 않도록 보장됩니다. 따라서 클라이언트는 한 번 읽고 읽은 값을 캐시 할 수 있습니다. 이 필드가 false 또는없는 경우, MBeanInfo가 반드시 변경되는 것은 아닙니다만, 그러한 보증은 없습니다. &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 알림 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58cf603470519c5b5e195c25d45c63e85fd34cc0" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this item is enabled. When an attribute or operation is not enabled, it exists but cannot currently be accessed. A user interface might present it as a greyed-out item. For example, an attribute might only be meaningful after the &lt;code&gt;start()&lt;/code&gt; method of an MBean has been called, and is otherwise disabled. Likewise, a notification might be disabled if it cannot currently be emitted but could be in other circumstances.</source>
          <target state="translated">이 항목에 따라 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 가 활성화됩니다. 속성 또는 조작이 사용 가능하지 않으면 존재하지만 현재 액세스 할 수 없습니다. 사용자 인터페이스는이를 회색으로 표시 할 수 있습니다. 예를 들어, 속성은 MBean 의 &lt;code&gt;start()&lt;/code&gt; 메소드가 호출 된 후에 만 의미 가 있으며, 그렇지 않으면 비활성화됩니다. 마찬가지로 현재 알림을 생성 할 수 없지만 다른 상황에있을 수있는 경우 알림이 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631ed054c3067658cc3a118e7936d64f51bfad09" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; is used to suppress unchecked warnings. Compiler vendors should document the additional warning names they support in conjunction with this annotation type. They are encouraged to cooperate to ensure that the same names work across multiple compilers.</source>
          <target state="translated">&lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; 문자열 은 확인되지 않은 경고를 억제하는 데 사용됩니다. 컴파일러 공급 업체는이 주석 유형과 함께 지원하는 추가 경고 이름을 문서화해야합니다. 동일한 이름이 여러 컴파일러에서 작동하도록 협력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69491b7b47334ee084c1c31f631a979ba7599e82" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s&lt;/code&gt; is processed from left to right, looking for data of interest. Any material in &lt;code&gt;s&lt;/code&gt; that is within the ASCII parenthesis characters &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; is ignored. Parentheses may be nested. Otherwise, the only characters permitted within &lt;code&gt;s&lt;/code&gt; are these ASCII characters:</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 는 왼쪽에서 오른쪽으로 처리되어 관심있는 데이터를 찾습니다. ASCII 괄호 문자 &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 내에있는 &lt;code&gt;s&lt;/code&gt; 의 모든 자료 는 무시됩니다. 괄호는 중첩 될 수 있습니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; 내에 허용되는 유일한 문자 는 다음 ASCII 문자입니다.</target>
        </trans-unit>
        <trans-unit id="919c5615e88a8576efe725aa5581160688478bfe" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">문자열 속성 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 형식의 RDN 문자열 로 해석되지 않습니다 . 즉, 값은 문자 그대로 (구문 분석되지 않음) 사용되며 이스케이프 처리되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fad0ec093c3f0998c8bdd918a0718e5eab967d10" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">일치하는 각 서브 시퀀스를 교체 스트링으로 교체하고 필요에 따라 캡처 된 서브 시퀀스를 대체하여 구성된 스트링</target>
        </trans-unit>
        <trans-unit id="c64ffe780cf31db4996cccb5e0b7a94f8f71ac12" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">첫 번째로 일치하는 하위 시퀀스를 대체 문자열로 바꾸고 캡처 된 하위 시퀀스를 필요에 따라 대체하여 구성된 문자열</target>
        </trans-unit>
        <trans-unit id="c31beff83674da5e332dc00712cbbbdd5562206f" translate="yes" xml:space="preserve">
          <source>The string form of the compound name follows the syntax described above. When the components of the compound name are turned into their string representation, the reserved syntax rules described above are applied (e.g. embedded separators are escaped or quoted) so that when the same string is parsed, it will yield the same components of the original compound name.</source>
          <target state="translated">복합 이름의 문자열 형식은 위에서 설명한 구문을 따릅니다. 복합 이름의 구성 요소가 문자열 표시로 바뀌면, 위에서 설명한 예약 구문 규칙이 적용되어 (예 : 내장 분리자가 이스케이프 또는 인용) 동일한 문자열이 구문 분석 될 때 원래 복합의 동일한 구성 요소가 생성됩니다 이름.</target>
        </trans-unit>
        <trans-unit id="f10938b9c9c0c8797b9503b58353064a7df27786" translate="yes" xml:space="preserve">
          <source>The string form of this URI</source>
          <target state="translated">이 URI의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="2fdc4bee66cbffe9f8926f8d8bb6b3ff409dbcc9" translate="yes" xml:space="preserve">
          <source>The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset</source>
          <target state="translated">이 URI의 문자열 형식으로 US-ASCII 문자 집합의 문자 만 포함하도록 필요에 따라 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="04761903fd7cc565bcc1b3b493f9a4d9ad183aaa" translate="yes" xml:space="preserve">
          <source>The string form of this abstract pathname</source>
          <target state="translated">이 추상 경로명의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="a6a48b95d9bb03c06186693a1e56c1d93fae2d7c" translate="yes" xml:space="preserve">
          <source>The string from which bytes are read.</source>
          <target state="translated">바이트를 읽는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2361fc0fcc98f34cf7707bd58c3a48311a40b445" translate="yes" xml:space="preserve">
          <source>The string must match exactly the name of the era. (Extraneous whitespace characters are not permitted.)</source>
          <target state="translated">문자열은 시대의 이름과 정확히 일치해야합니다. (공백 공백 문자는 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="528b474b80585c5bde4792fd2aaffc2f3fc1d745" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜를 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a92bea7fe20a26d29fc02f1b18cfeb4a64f2befc" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9546955f3024f065c5daeea861e41048af02e3a1" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea655be45604489e8a988f1f62775445f297e35d" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b639943db6958d9063503c47072cf422d9417cda" translate="yes" xml:space="preserve">
          <source>The string must represent a valid instant in UTC and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 인스턴트를 UTC로 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2f552261c78dde5773d5eb748ea70d7ae99393" translate="yes" xml:space="preserve">
          <source>The string must represent a valid month-day. The format is &lt;code&gt;--MM-dd&lt;/code&gt;.</source>
          <target state="translated">문자열은 유효한 월일을 나타내야합니다. 형식은 &lt;code&gt;--MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f5fc471abeddd2fc10059070b03a26ea0e4f0e6" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4834d95eb10fdeb7855ef1f3b7f1815cd5f315de" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="522d37a5cb0dea2932c0223382f776eae3acb124" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year-month. The format must be &lt;code&gt;uuuu-MM&lt;/code&gt;. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 형식은 &lt;code&gt;uuuu-MM&lt;/code&gt; 이어야합니다 . 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="68fe36aa287218182684aa7a85b5b9b1977bc3ca" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="abbf179f85853b351778a26629eb5657fc8e8fab" translate="yes" xml:space="preserve">
          <source>The string produced for a given number is always the same; it is not affected by locale. This means that it can be used as a canonical string representation for exchanging decimal data, or as a key for a Hashtable, etc. Locale-sensitive number formatting and parsing is handled by the &lt;a href=&quot;../text/numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt; class and its subclasses.</source>
          <target state="translated">주어진 숫자에 대해 생성 된 문자열은 항상 같습니다. 로케일의 영향을받지 않습니다. 이는 10 진수 데이터 교환을위한 표준 문자열 표현 또는 해시 테이블 등의 키로 사용될 수 있음을 의미합니다. 로케일 구분 숫자 형식화 및 구문 분석은 &lt;a href=&quot;../text/numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt; 클래스 및 해당 서브 클래스에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe8bf77d08eee400f8eacfe6cb5d936ae0a4f48" translate="yes" xml:space="preserve">
          <source>The string representation consists of a list of the array's elements, enclosed in square brackets (&lt;code&gt;&quot;[]&quot;&lt;/code&gt;). Adjacent elements are separated by the characters &lt;code&gt;&quot;, &quot;&lt;/code&gt; (a comma followed by a space). Elements are converted to strings as by &lt;code&gt;String.valueOf(Object)&lt;/code&gt;, unless they are themselves arrays.</source>
          <target state="translated">문자열 표현은 배열의 요소 목록으로 구성되며 대괄호 ( &lt;code&gt;&quot;[]&quot;&lt;/code&gt; )로 묶습니다 . 인접한 요소는 문자 &lt;code&gt;&quot;, &quot;&lt;/code&gt; (쉼표 뒤에 공백)로 구분됩니다. 요소 자체가 배열이 아닌 경우 요소는 &lt;code&gt;String.valueOf(Object)&lt;/code&gt; 의해 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b44741f71d142966f86ccc32acede59a84d445d" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, and the tabular type of this instance.</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름과이 인스턴스의 테이블 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="53d83a239c2a7be1cb8fe5f1423384d5522b995b" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름,이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce6c605327807271ff809bf8c3e33f72c8d71fb" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt;), the type name, the dimension, the elements' open type and the primitive array flag defined for this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt; ), 유형 이름, 차원, 요소의 열린 유형 및이 인스턴스에 대해 정의 된 기본 배열 플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2883eec75a628ef99c332dc7e2aaea10651f3902" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="8a2464b0766b9e81e51253aa84918715aa0cd068" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="9b6002a9339d22eed93f555f1481a07a002e5091" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt;), the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt; ),이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="789eed41269dc56a9082ac2a97089c1d128afaf4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt;), the type name for this instance, and the list of the items names and types string representation of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt; ),이 인스턴스의 유형 이름 및이 인스턴스의 항목 이름 및 유형 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e6ec5ac6aa3e0627edbc16f7c6430eb6a8d1d8" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt;), the string representation of the name and open type of the described attribute, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt; ), 설명 된 속성의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 유효한 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b716744f9ffc637689b371f05e304eff7af2a9" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt;), and the name and signature of the described constructor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt; )과 설명 된 생성자의 이름 및 서명으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad27ad5ebd129c3ea4d4956977533104d272e95" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ), 설명 된 생성자의 이름 및 서명, 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56f0f9a9629656eb5921de1b1b2280b717218bf7" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt;), the MBean class name, and the string representation of infos on attributes, constructors, operations and notifications of the described MBean.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt; ), MBean 클래스 이름 및 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d79b194f6330817e69226b3c9fd464f3f27be2" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt;), the MBean class name, the string representation of infos on attributes, constructors, operations and notifications of the described MBean and the string representation of the descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt; ), MBean 클래스 이름, 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현 및 설명 자의 문자열 표현으로 구성됩니다. .</target>
        </trans-unit>
        <trans-unit id="4ab6a7c24f824a223fbd8a3831c0c3e6970b8c12" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt;), and the name, signature, return open type and impact of the described operation.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt; )과 이름, 서명, 리턴 열기 유형 및 설명 된 조작의 영향으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="640c583f5e5f932dc18d233947e5f9f45c18d88c" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; )과 설명 된 조작의 이름, 서명, 리턴 열기 유형 및 영향 및 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56372f3341ed9c622ba1dff09dfa80ed9847d82f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt;), the string representation of the name and open type of the described parameter, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현 및 기본값, 최소, 최대 및 올바른 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e847596a7e03c71180c8216bb4f964ac80c8ce4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt;) and the type name for this instance (which is the java class name of the values this &lt;code&gt;SimpleType&lt;/code&gt; instance represents).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt; )과이 인스턴스의 유형 이름 (이 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스가 나타내는 값의 Java 클래스 이름 )으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="574dc6c379e8e51bf167c7fea2d4d1304ca21c2f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ),이 인스턴스의 표 형식 유형의 문자열 표현 및 내용의 문자열 표현으로 구성됩니다 (즉, 키 = 값 매핑을 반환) 를 호출 &lt;code&gt;dataMap.&lt;/code&gt; &lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="807fbdd5da5244bfb18ce040224682952e87d826" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;), the type name for this instance, the row type string representation of this instance, and the index names of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt; ),이 인스턴스의 유형 이름,이 인스턴스의 행 유형 문자열 표현 및이 인스턴스의 색인 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc5fe65d5ab420dbf5b6b9fae291dad1f8925ed" translate="yes" xml:space="preserve">
          <source>The string representation for this &lt;code&gt;X500Principal&lt;/code&gt; can be obtained by calling the &lt;code&gt;getName&lt;/code&gt; methods.</source>
          <target state="translated">이 &lt;code&gt;X500Principal&lt;/code&gt; 의 캐릭터 라인 표현 은 &lt;code&gt;getName&lt;/code&gt; 메소드 를 호출하는 것으로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b612d9c02babd7e1408d7e8d784cf99d9d55260" translate="yes" xml:space="preserve">
          <source>The string representation of the LdapName.</source>
          <target state="translated">LdapName의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="a420c385cddda341e69db0764ebb091c11a4a7be" translate="yes" xml:space="preserve">
          <source>The string representation of the Rdn.</source>
          <target state="translated">Rdn의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="6de482475e09c2eeff30bcc77f9f20ef06b16b86" translate="yes" xml:space="preserve">
          <source>The string representation of this SearchResult. Cannot be null.</source>
          <target state="translated">이 SearchResult의 캐릭터 라인 표현 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19b1dc6e3c56c1f7d2c94a2810b048ff86117b35" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL. If the value returned by this method is supplied to the &lt;code&gt;JMXServiceURL&lt;/code&gt; constructor, the resultant object is equal to this one.</source>
          <target state="translated">이 서비스 URL의 캐릭터 라인 표현 이 메소드에 의해 리턴 된 값이 &lt;code&gt;JMXServiceURL&lt;/code&gt; 생성자에 제공되면 결과 오브젝트는이 오브젝트와 같습니다.</target>
        </trans-unit>
        <trans-unit id="16f1d37b61e149769d5bb45d2d6b123bd696fbda" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification. This string is meant for debugging and not mean to be interpreted programmatically.</source>
          <target state="translated">이 예외의 문자열 표현은 오류가 발생한 위치 및 실행되지 않은 첫 번째 수정에 대한 정보로 구성됩니다. 이 문자열은 디버깅을위한 것이며 프로그래밍 방식으로 해석되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7de16e9df6affa420db9ce81302405c1dfefd55" translate="yes" xml:space="preserve">
          <source>The string representation of this matcher</source>
          <target state="translated">이 정규 표현 엔진의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="09eba65afc610d538d65c263d07c4a3212fcfe45" translate="yes" xml:space="preserve">
          <source>The string representation of this name/class pair.</source>
          <target state="translated">이 이름 / 클래스 쌍의 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="053f914091e9887aaa58bf39744d8861af29fc0d" translate="yes" xml:space="preserve">
          <source>The string representation of this pattern</source>
          <target state="translated">이 패턴의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c2acdbf9130b5c1f31215890014846c808d3f0b0" translate="yes" xml:space="preserve">
          <source>The string representation of this scanner</source>
          <target state="translated">이 스캐너의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="0428783f6a2a4ed333a95d1448a2bc32086c9f46" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawAuthority--&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 문자열에 의해 리턴 된 것과 동일하다 &lt;a href=&quot;uri#getRawAuthority--&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; 의&lt;/a&gt; 탈출 옥텟의 모든 서열이된다는 점을 제외하고 방법 &lt;a href=&quot;#decode&quot;&gt;복호&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99f4ef96c814a7c3937663953ec5ac06f173ebb2" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawFragment--&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawFragment--&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a732cb50bbec78c973952b48ad9babe398c8380c" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawPath--&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawPath--&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ddd6a70f437a36a8a334d3aa1a18560bd5c5720e" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawQuery--&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawQuery--&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1a87d2cf19c437c64a305afdb85f728af90351" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4374f3d0ad6e121222206c9e637bf592e8f4f3" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="15003a859c5ec3a6cdfdb74230384f43324ebc22" translate="yes" xml:space="preserve">
          <source>The string returned by this method is not a JNDI composite name and should not be passed directly to context methods.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 JNDI 컴포지트 이름이 아니므로 컨텍스트 메소드에 직접 전달해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d86e2c12a8b526574d8ed3d4f0ad084aa1496f" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString--&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 &lt;a href=&quot;../../lang/object#toString--&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 문자열과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a98b16691a6548a5f40d785a69cfe7819a08aa9f" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. At least one of the four sections must be present. The sections have suffixes in ASCII of &quot;Y&quot;, &quot;M&quot;, &quot;W&quot; and &quot;D&quot; for years, months, weeks and days, accepted in upper or lower case. The suffixes must occur in order. The number part of each section must consist of ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number must parse to an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 네 섹션 중 하나 이상이 있어야합니다. 이 섹션에는 ASCII의 &quot;Y&quot;, &quot;M&quot;, &quot;W&quot;및 &quot;D&quot;접미사가 있습니다. 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. 각 섹션의 숫자 부분은 ASCII 숫자로 구성되어야합니다. 숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 숫자는 &lt;code&gt;int&lt;/code&gt; 로 구문 분석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="89a747d82990c6aea3987f68f6f2f3b3b15c1eff" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to an &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to an &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 이 섹션에는 ASCII로 &quot;D&quot;, &quot;H&quot;, &quot;M&quot;및 &quot;S&quot;의 접미사가 있으며 소문자, 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. ASCII 문자 &quot;T&quot;는 첫 번째 항목 (있는 경우), 1 분, 2 분 또는 2 초 전에 발생해야합니다. 네 개의 섹션 중 하나 이상이 있어야하며 &quot;T&quot;가 있으면 &quot;T&quot;뒤에 하나 이상의 섹션이 있어야합니다. 각 섹션의 숫자 부분은 하나 이상의 ASCII 숫자로 구성되어야합니다.숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 일, 시간 및 분의 수는 &lt;code&gt;long&lt;/code&gt; . 초는 선택적 분수 를 사용하여 &lt;code&gt;long&lt;/code&gt; 으로 구문 분석해야합니다 . 소수점은 점 또는 쉼표 일 수 있습니다. 소수 부분은 0-9 자리입니다.</target>
        </trans-unit>
        <trans-unit id="4685a9bbdb9380ea8c94c58ff588b3c8fbe09edf" translate="yes" xml:space="preserve">
          <source>The string that appears after a negative number (may be empty),</source>
          <target state="translated">음수 뒤에 나오는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="121fd276daa28030f6a820cb1573874d3a75d6c9" translate="yes" xml:space="preserve">
          <source>The string that appears after a positive number (may be empty),</source>
          <target state="translated">양수 뒤에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="5bdb1009de16112ed78878cf54efa430f792f9b9" translate="yes" xml:space="preserve">
          <source>The string that appears before a negative number (may be empty),</source>
          <target state="translated">음수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="ca10167dd9b711a6fe69878b203a07e7493844d5" translate="yes" xml:space="preserve">
          <source>The string that appears before a positive number (may be empty),</source>
          <target state="translated">양수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="1230518d13d5910243029a9e67f1cba26841e687" translate="yes" xml:space="preserve">
          <source>The string that represents infinity for floating-point values,</source>
          <target state="translated">부동 소수점 값의 무한대를 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="0ef60f4fe5623badec9511506d8c3e9aab99fce8" translate="yes" xml:space="preserve">
          <source>The string that represents not-a-number for floating-point values,</source>
          <target state="translated">부동 소수점 값의 숫자가 아님을 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="a78a098297ed979ec8fd87a13cc391ae93c8972a" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens.</source>
          <target state="translated">문자열 토크 나이저 클래스는 애플리케이션이 문자열을 토큰으로 나눌 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="04fb2cffb71f257048052d20b8fe56a4f66e790f" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens. The tokenization method is much simpler than the one used by the &lt;code&gt;StreamTokenizer&lt;/code&gt; class. The &lt;code&gt;StringTokenizer&lt;/code&gt; methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.</source>
          <target state="translated">문자열 토크 나이저 클래스를 사용하면 응용 프로그램에서 문자열을 토큰으로 나눌 수 있습니다. 토큰 화 방법은 &lt;code&gt;StreamTokenizer&lt;/code&gt; 클래스에서 사용하는 방법보다 훨씬 간단합니다 . &lt;code&gt;StringTokenizer&lt;/code&gt; 방법은 식별자, 숫자, 인용 된 문자열을 구분 없으며 인식하고 설명을 생략하지 않는다.</target>
        </trans-unit>
        <trans-unit id="53fa55c105fb0b4c765bc0d34087bf552da7b9c4" translate="yes" xml:space="preserve">
          <source>The string used to display the String in the syntax of the scripting language.</source>
          <target state="translated">스크립트 언어의 구문으로 문자열을 표시하는 데 사용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">문자열 값</target>
        </trans-unit>
        <trans-unit id="f11c947d653626328bad48f1c4cdf9159acc0a3b" translate="yes" xml:space="preserve">
          <source>The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).</source>
          <target state="translated">이 클래스의 인스턴스에서 숫자로 구문 분석 할 수있는 문자열은 다음 정규식 문법으로 지정됩니다. 여기서 Rmax는 사용되는 기수에서 가장 높은 자릿수입니다 (예 : 밑 10의 경우 Rmax는 9).</target>
        </trans-unit>
        <trans-unit id="192956733edd06bdd0c654a6ba995e1bcee04c0f" translate="yes" xml:space="preserve">
          <source>The structure and contents of the &quot;native&quot; metadata format are defined by the plug-in that created this &lt;code&gt;IIOMetadata&lt;/code&gt; object. Plug-ins for simple formats will usually create a dummy node for the root, and then a series of child nodes representing individual tags, chunks, or keyword/value pairs. A plug-in may choose whether or not to document its native format.</source>
          <target state="translated">&quot;네이티브&quot;메타 데이터 형식의 구조와 내용은이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 를 생성 한 플러그인에 의해 정의됩니다 . 간단한 형식의 플러그인은 일반적으로 루트에 대한 더미 노드를 만든 다음 개별 태그, 청크 또는 키워드 / 값 쌍을 나타내는 일련의 자식 노드를 만듭니다. 플러그인은 고유 형식을 문서화할지 여부를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c5dc909eef768d7f9cd7e34bb554bcaaaebaa" translate="yes" xml:space="preserve">
          <source>The structure is a return type accompanied by any number of parameter types. The types (primitive, &lt;code&gt;void&lt;/code&gt;, and reference) are represented by &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; objects. (For ease of exposition, we treat &lt;code&gt;void&lt;/code&gt; as if it were a type. In fact, it denotes the absence of a return type.)</source>
          <target state="translated">구조는 여러 매개 변수 유형과 함께 리턴 유형입니다. 유형 (primitive, &lt;code&gt;void&lt;/code&gt; 및 reference)은 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 객체 로 표시됩니다 . (노출을 쉽게하기 위해 &lt;code&gt;void&lt;/code&gt; 를 타입처럼 취급 합니다. 실제로는 리턴 타입이 없음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="fdfbb9e2e84d666d2a855ee7c1631508d148c17f" translate="yes" xml:space="preserve">
          <source>The structures that may be described by this class are a subset of those expressible using XML document type definitions (DTDs), with the addition of some basic information on the datatypes of attributes and the ability to store an &lt;code&gt;Object&lt;/code&gt; reference within a node. In the future, XML Schemas could be used to represent these structures, and many others.</source>
          <target state="translated">이 클래스에서 설명 할 수있는 구조는 속성의 데이터 유형에 대한 몇 가지 기본 정보와 노드 내에 &lt;code&gt;Object&lt;/code&gt; 참조 를 저장하는 기능과 함께 XML 문서 유형 정의 (DTD)를 사용하여 표현할 수있는 구조의 서브 세트입니다 . 미래에는 XML 스키마를 사용하여 이러한 구조 및 기타 여러 구조를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a232a3677fbba52c761d261392a47c4a403e95f0" translate="yes" xml:space="preserve">
          <source>The stub might not yet be connected to the ORB. The stub will be serializable only if it is connected to the ORB.</source>
          <target state="translated">스텁이 아직 ORB에 연결되지 않았을 수 있습니다. 스텁은 ORB에 연결된 경우에만 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e5c879c6bdae17e077ece202d05c591a659999bb" translate="yes" xml:space="preserve">
          <source>The subclass may supply a different base name for the resource bundles using the &lt;code&gt;setResourceBaseName&lt;/code&gt; method.</source>
          <target state="translated">서브 클래스는 &lt;code&gt;setResourceBaseName&lt;/code&gt; 메소드를 사용하여 자원 번들에 다른 기본 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bac1d40c541f2bc78282b5fcf04be8326df2e993" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">리턴되는 서브 클래스는 &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt; 의 값과 구문 분석되는 문자열에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b79749f58cf1bfcecb1d563bcce417c79a3f48ee" translate="yes" xml:space="preserve">
          <source>The subclass's &lt;code&gt;set(int, E)&lt;/code&gt;, &lt;code&gt;get(int)&lt;/code&gt;, &lt;code&gt;add(int, E)&lt;/code&gt;, &lt;code&gt;remove(int)&lt;/code&gt;, &lt;code&gt;addAll(int,
 Collection)&lt;/code&gt; and &lt;code&gt;removeRange(int, int)&lt;/code&gt; methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The &lt;code&gt;addAll(Collection c)&lt;/code&gt; method merely returns &lt;code&gt;addAll(size,
 c)&lt;/code&gt;.</source>
          <target state="translated">서브 클래스의 &lt;code&gt;set(int, E)&lt;/code&gt; , &lt;code&gt;get(int)&lt;/code&gt; , &lt;code&gt;add(int, E)&lt;/code&gt; , &lt;code&gt;remove(int)&lt;/code&gt; , &lt;code&gt;addAll(int, Collection)&lt;/code&gt; 및 &lt;code&gt;removeRange(int, int)&lt;/code&gt; 메소드는 모두 기본 초록의 해당 메소드에 위임됩니다. 인덱스의 경계를 확인하고 오프셋을 조정 한 후 목록. &lt;code&gt;addAll(Collection c)&lt;/code&gt; 방법은 단순히 반환 &lt;code&gt;addAll(size, c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41754262853cd8dda8e7145fb4fe6436a4d4ac99" translate="yes" xml:space="preserve">
          <source>The subprocess is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the subprocess continues executing asynchronously.</source>
          <target state="translated">&lt;code&gt;Process&lt;/code&gt; 오브젝트에 대한 참조가 더 이상 없을 때 서브 프로세스가 종료되지 않고 서브 프로세스가 비동기 적으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="24df0de55c6e5cbab8a446a4d7da62cab861430c" translate="yes" xml:space="preserve">
          <source>The subsequence of the argument &lt;code&gt;s&lt;/code&gt; specified by &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by &lt;code&gt;end - start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 로 지정된 인수 &lt;code&gt;s&lt;/code&gt; 하위 시퀀스는 지정된 대상 오프셋에서이 시퀀스에 순서대로 삽입되어 원래 해당 위치 위에있는 문자를 위로 이동합니다. 이 시퀀스의 길이는 &lt;code&gt;end - start&lt;/code&gt; 증가 합니다 .</target>
        </trans-unit>
        <trans-unit id="9bb649597713d07a6a3f68ef4b622114bd9bb42f" translate="yes" xml:space="preserve">
          <source>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the sum will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">반환되는 합계는 크기가 다른 값의 누적 반올림 오차로 인해 값이 기록되는 순서에 따라 달라질 수 있습니다. 절대 크기를 늘리면 정렬 된 값이 더 정확한 결과를 얻는 경향이 있습니다. 기록 된 값이 &lt;code&gt;NaN&lt;/code&gt; 이거나 합계가 &lt;code&gt;NaN&lt;/code&gt; 이면 합계는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b4fd272478c2bf5755a6c3fbfac56931cb9665d" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">선언 된 유형의 수퍼 타입 ​​(클래스 및 인터페이스 유형 모두)은 &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 찾을 수 있습니다 . 타입 인수가 치환 된 슈퍼 타입을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="6acd237472bddb6f88b28a9f2fd993ab87094ddb" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">제공된 어큐뮬레이터 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Double::max&lt;/code&gt; 를 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 와 함께 ID로 제공 할 수 있습니다. 스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않습니다. 따라서 수치 안정성이 필요한 경우, 특히 실질적으로 다른 차수의 값을 결합 할 때이 등급을 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b84e7dcea201cffacdcbf9be7a2353ff95d845a5" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer should generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 작성자는 내부에서 축소판 그림을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="753904bcbd3964af858d18cda3d913205d84b5e6" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer will generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 기록기는 내부에서 축소판 그림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cc15d8eee723cd7e4ccfbd5a0f0bd59ce88d1002" translate="yes" xml:space="preserve">
          <source>The supported &lt;code&gt;ChronoField&lt;/code&gt; instances are:</source>
          <target state="translated">지원되는 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2cd39555d2c728a665b32d4100c19f45b92402" translate="yes" xml:space="preserve">
          <source>The supported calendar systems includes:</source>
          <target state="translated">지원되는 캘린더 시스템에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83bd48a0eac4e9b358a53d73d8f0c393f28dcfbc" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">지원되는 범주는 &lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 클래스에서 지정한 버전 의 &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; 범주 입니다. 범주 이름은 규범 및 유익한 표준에서 정의 된 이름입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1f2e9acf0920ea9550ff69da281e2ea26f2481f3" translate="yes" xml:space="preserve">
          <source>The supported syntax is:</source>
          <target state="translated">지원되는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d6a5bc82895e1be1c598d816a928419e077fb62" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt;. They are returned in the order seconds, nanos.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 몇 초, 나노 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50995038a878ce286701de766382bef69778b604" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in the order years, months, days.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 년, 월, 일 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7618ee46d4016ebcae2e5cbf1a065473c760968b" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Requesting an unsupported unit will throw an exception.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 지원되지 않는 유닛을 요청하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b30d06d3ef729bd157ab81214e7e89bcf4f23fd7" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in order from largest to smallest.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 가장 큰 것부터 가장 작은 것까지 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="612ea5ebf89d96a0eba935a9ea4b0154afc481ad" translate="yes" xml:space="preserve">
          <source>The supported units of a period are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. All three fields are always present, but may be set to zero.</source>
          <target state="translated">지원되는 기간의 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 세 필드는 모두 항상 존재하지만 0으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5be801d8d7c141429eb2a06d10b0aef903302c4" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;생성자를 통해&lt;/a&gt; 비활성화 &lt;em&gt;하지 않으면&lt;/em&gt; 억제 동작이 활성화 &lt;em&gt;됩니다&lt;/em&gt; . 억제를 무효로하면 (자),이 메소드는 인수를 검증하는 것 외에는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e55e499a6fc5c1dbd4e8b7511cc0424a80a9f71" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt; , where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">주석이 나타날 수있는 구문 적 위치는 &lt;em&gt;선언 컨텍스트 (&lt;/em&gt; 주석이 선언에 적용되는 경우)와 &lt;em&gt;유형 컨텍스트 (&lt;/em&gt; 주석이 선언 및 표현식에 사용 된 형식에 적용되는) 로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="00a77c038c4619155739ddefe087cb77c766d025" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">의 구문 &lt;code&gt;URL&lt;/code&gt; 은 에 의해 정의되는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;범용 리소스 식별자 (URI) : 일반 구문 RFC 2396&lt;/i&gt;&lt;/a&gt; 에 의해 개정 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732 : URL에 리터럴 IPv6 주소 형식&lt;/i&gt;&lt;/a&gt; . 리터럴 IPv6 주소 형식은 scope_id도 지원합니다. scope_ids의 구문과 사용법은 &lt;a href=&quot;inet6address#scoped&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="449145cc99d61f1de8faac0f36747e42eeda60f0" translate="yes" xml:space="preserve">
          <source>The syntax of a JAR URL is:</source>
          <target state="translated">JAR URL의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08fb1f0d6774918d6dc928c999a8c810bc3e1cf4" translate="yes" xml:space="preserve">
          <source>The syntax of a compound name is specified using a set of properties:</source>
          <target state="translated">복합 이름의 구문은 일련의 속성을 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="74f5647e4732b56055ffb73b5ef679c9f6b0e018" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt; for delegation, or &lt;code&gt;null&lt;/code&gt; if none</source>
          <target state="translated">위 임용 시스템 &lt;code&gt;ClassLoader&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="74a5a2feb3472fb9649c9e133c6a12917cacd2aa" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">시스템 클래스 로더는 &lt;code&gt;java.lang.String&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드를 구현하는 경우 검색 할 JAR 파일 추가를 지원합니다 . 이 방법은 &lt;code&gt;public&lt;/code&gt; 액세스 권한 이 필요하지 않습니다 . JAR 파일의 이름은 &lt;code&gt;jarfile&lt;/code&gt; 에서 &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻을 수 있으며 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드에 매개 변수로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7007628b7373da2f3acc46dea4b6fc181e177f3" translate="yes" xml:space="preserve">
          <source>The system console, if any, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 시스템 콘솔, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7923449f8c0c0791eb5aa081bc5a65fcb2555819" translate="yes" xml:space="preserve">
          <source>The system will return a keystore implementation for the default type.</source>
          <target state="translated">시스템은 기본 유형에 대한 키 저장소 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="00bc1824cf3bd5ca4947f7d237f20eddafbb842c" translate="yes" xml:space="preserve">
          <source>The system will return the most preferred implementation of the specified keystore type available in the environment.</source>
          <target state="translated">시스템은 환경에서 사용 가능한 지정된 키 저장소 유형의 가장 선호되는 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="db9af4ad444ca84eeeac9fb19764f73c768a1db0" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="06c823441fa92d743c30c7c0a19a1d4b758a3865" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;file.separator&lt;/code&gt;. On UNIX systems the value of this field is &lt;code&gt;'/'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;'\\'&lt;/code&gt;.</source>
          <target state="translated">시스템에 따른 기본 이름 구분 문자입니다. 이 필드는 시스템 특성 &lt;code&gt;file.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . UNIX 시스템에서이 필드의 값은 &lt;code&gt;'/'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;'\\'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a67c3801f69a10a5f6ee1400db51f1a4d991731c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="79dc28fe296e6f9a3e10386e77dffcce367aaf90" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;path.separator&lt;/code&gt;. This character is used to separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;. On UNIX systems, this character is &lt;code&gt;':'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;';'&lt;/code&gt;.</source>
          <target state="translated">시스템 종속 경로 구분 문자 이 필드는 시스템 특성 &lt;code&gt;path.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . 이 문자는 &lt;em&gt;경로 목록으로&lt;/em&gt; 지정된 파일 시퀀스에서 파일 이름을 구분하는 데 사용됩니다 . UNIX 시스템에서이 문자는 &lt;code&gt;':'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;';'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="518a2fc9a68e3f3d5382e5d1a00ce498fcc2e594" translate="yes" xml:space="preserve">
          <source>The system-wide default AsynchronousChannel provider</source>
          <target state="translated">시스템 전체의 기본 AsynchronousChannel 제공자</target>
        </trans-unit>
        <trans-unit id="7e7874d4b84773bdddf3caf1a22fc6b1ddcdb68c" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open--&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open--&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open--&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open--&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open--&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">시스템 전체의 기본 제공자는 &lt;a href=&quot;../datagramchannel#open--&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../pipe#open--&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../selector#open--&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../serversocketchannel#open--&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../socketchannel#open--&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메소드에서 사용됩니다 . &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt; 메서드 에서도 사용됩니다 . 프로그램은 해당 제공자를 인스턴스화 한 다음 이 클래스에 정의 된 &lt;code&gt;open&lt;/code&gt; 메소드 를 직접 호출하여 기본 제공자 이외의 제공자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1854b090241392edcc60935113761df6965da7c2" translate="yes" xml:space="preserve">
          <source>The system-wide default selector provider</source>
          <target state="translated">시스템 전체 기본 선택기 공급자</target>
        </trans-unit>
        <trans-unit id="a1045e7af40ef3b112d277437311ac29c399a948" translate="yes" xml:space="preserve">
          <source>The tab character (&lt;code&gt;'\u0009'&lt;/code&gt;)</source>
          <target state="translated">탭 문자 ( &lt;code&gt;'\u0009'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="956c09a6d0ea87af6414b81e63f37ed614bbe89f" translate="yes" xml:space="preserve">
          <source>The table below lists all the printing attributes. The table shows the tagging interfaces each attribute class implements in addition to interface &lt;a href=&quot;../attribute&quot;&gt; Attribute&lt;/a&gt;, thus indicating how each attribute is used in the API. For each doc attribute and print request attribute, the column marked &quot;SupportedValuesAttribute&quot; lists the supported-values attribute class, if any, with which a print service indicates the supported values for that attribute category.</source>
          <target state="translated">아래 표에는 모든 인쇄 속성이 나열되어 있습니다. 이 테이블은 &lt;a href=&quot;../attribute&quot;&gt;Attribute 속성&lt;/a&gt; 외에도 각 속성 클래스가 구현하는 태깅 인터페이스를 보여줍니다. 따라서 각 속성이 API에서 사용되는 방식을 나타냅니다. 각 doc 속성 및 인쇄 요청 속성에 대해 &quot;SupportedValuesAttribute&quot;로 표시된 열은 지원되는 값 속성 클래스를 나열합니다 (있는 경우). 인쇄 서비스가 해당 속성 범주에 대해 지원되는 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93b17809af88bed6b165bc41c7cce6b651c3dd33" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;chromaticity#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">아래 표 는 단색 또는 컬러 문서에 대해 &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;chromaticity#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt; 의 색도 속성을 지정하는 효과를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6550573ca0506c03709606c1bdd17da7666522cf" translate="yes" xml:space="preserve">
          <source>The table below summarizes which kind of annotation presence different methods in this interface examine.</source>
          <target state="translated">아래 표는이 인터페이스에서 어떤 종류의 주석이 다른 방법으로 검사되는지 요약합니다.</target>
        </trans-unit>
        <trans-unit id="abdfbcd8569ed822dbb9b0566e80bdcdfb0ce663" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">충돌이 너무 많으면 (예 : 별개의 해시 코드가 있지만 테이블 크기가 같은 슬롯에 해당하는 키) 테이블이 동적으로 확장됩니다 (매핑 당 약 2 개의 빈을 유지하는 예상 평균 효과 (0.75로드에 해당) 크기 조정을위한 요인 임계 값). 매핑이 추가 및 제거 될 때이 평균 주위에 많은 차이가있을 수 있지만 전반적으로 해시 테이블에 대해 일반적으로 허용되는 시간 / 공간 균형을 유지합니다. 그러나이 또는 다른 종류의 해시 테이블 크기를 조정하면 작업 속도가 느려질 수 있습니다. 가능한 경우 크기 추정값을 선택적 &lt;code&gt;initialCapacity&lt;/code&gt; 생성자 인수 로 제공하는 것이 좋습니다 . 추가 옵션 인 &lt;code&gt;loadFactor&lt;/code&gt; 생성자 인수는 주어진 요소 수에 할당 할 공간의 양을 계산하는 데 사용할 테이블 밀도를 지정하여 초기 테이블 용량을 사용자 정의하는 추가 수단을 제공합니다. 또한이 클래스의 이전 버전과의 호환성을 위해 생성자는 내부 크기 조정에 대한 추가 힌트로 예상되는 &lt;code&gt;concurrencyLevel&lt;/code&gt; 수준을 선택적으로 지정할 수 있습니다 . 정확히 같은 &lt;code&gt;hashCode()&lt;/code&gt; 가진 많은 키를 사용 하는 것은 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="807c7f2278f08fd9a560612599a053ac4a77aa0b" translate="yes" xml:space="preserve">
          <source>The table of key properties.</source>
          <target state="translated">주요 속성 테이블.</target>
        </trans-unit>
        <trans-unit id="e3034177648d7a592ed4b995252076ff2a379e97" translate="yes" xml:space="preserve">
          <source>The tag values for this property. May be null if this property cannot be represented as a tagged value.</source>
          <target state="translated">이 프로퍼티의 태그 치입니다. 이 속성을 태그 값으로 나타낼 수없는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02cefdef6f6fd1cf2781c5dd156f06c3b67ffe8b" translate="yes" xml:space="preserve">
          <source>The target and fallback must be of exactly the same method type, and the resulting combined method handle will also be of this type.</source>
          <target state="translated">대상과 폴백은 정확히 동일한 메소드 유형이어야하며 결과 결합 된 메소드 핸들도이 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="cfe18dce3e23910cc798ebbf8a13a2dd958ea48f" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">핸들러가 후행 인수를 생략 할 수 있다는 점을 제외하고 대상 및 핸들러는 동일한 해당 인수 및 리턴 유형을 &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; &lt;/a&gt; 의 술어와 유사 ). 또한 핸들러에는 &lt;code&gt;exType&lt;/code&gt; 또는 supertype 의 추가 선행 매개 변수가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="44e11701adb06063c652521aa85aae71912799bf" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">핸들러가 항상 발생하더라도 대상과 핸들러는 동일한 유형을 리턴해야합니다. (예를 들어, 핸들러가 &lt;code&gt;finally&lt;/code&gt; 절을 시뮬레이션하기 때문에 이런 일이 발생할 수 있습니다 ). 이러한 처리 핸들러를 작성 하려면 올바른 리턴 유형의 메소드 핸들을 작성하기 위해 처리기 작성 로직을 &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt; 으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="294becfa926713ae4f4611aad1c89088d4f17efe" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">목표 데이터 라인은 호출하여 믹서로부터 얻어 질 수 &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 방법 &lt;code&gt;Mixer&lt;/code&gt; 적절한으로 &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 의 개체.</target>
        </trans-unit>
        <trans-unit id="2e92be738dd320065c504e7c597383304da41f9b" translate="yes" xml:space="preserve">
          <source>The target format represents the format of the processed, converted audio data. This is the format of the data that can be read from the stream returned by one of the &lt;code&gt;getAudioInputStream&lt;/code&gt; methods.</source>
          <target state="translated">대상 형식은 처리 된 변환 된 오디오 데이터의 형식을 나타냅니다. &lt;code&gt;getAudioInputStream&lt;/code&gt; 메소드 중 하나가 리턴 한 스트림에서 읽을 수있는 데이터 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="61ee1882c6fbd7985ddaac74fcc91b429f418e8c" translate="yes" xml:space="preserve">
          <source>The target name is of the form &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is optional. It must not be empty or null.</source>
          <target state="translated">대상 이름은 &quot; &lt;code&gt;className#member[objectName]&lt;/code&gt; &quot;형식이며 각 부분은 선택 사항입니다. 비어 있거나 null이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="7928d48cbde0bd5806a16e749b843ab056e2bff2" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the AuthPermission object is used to guard access to the Policy, Subject, LoginContext, and Configuration objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 AuthPermission 오브젝트는 Policy, Subject, LoginContext 및 Configuration 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2890f709a91749b2fe10e52fd580bddb149e0444" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the SecurityPermission object is used to guard access to the Policy, Security, Provider, Signer, and Identity objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 SecurityPermission 오브젝트는 Policy, Security, Provider, Signer 및 Identity 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e139ec2f3c65e0160a69e0966a9e12f3721fc07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the Serializable permission (see below).</source>
          <target state="translated">대상 이름은 Serializable 권한의 이름입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="1d4510b6174912a740c895643371245def2a4d9e" translate="yes" xml:space="preserve">
          <source>The target name is the name of the audio permission (see the table below). The names follow the hierarchical property-naming convention. Also, an asterisk can be used to represent all the audio permissions.</source>
          <target state="translated">대상 이름은 오디오 권한의 이름입니다 (아래 표 참조). 이름은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표를 사용하여 모든 오디오 권한을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8645249d279e7c3cf29a83a9b3bb1e507d282b4" translate="yes" xml:space="preserve">
          <source>The target name is the name of the authorization principal classname followed by a period and the authorization principal name, that is &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">대상 이름은 권한 부여 주체 클래스 이름의 이름 뒤에 마침표와 권한 부여 주체 이름 ( &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1de21a429ece939c67b7e50829885099ad2d45eb" translate="yes" xml:space="preserve">
          <source>The target name is the name of the network permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;foo.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*foo&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 네트워크 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;foo. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* foo&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35aa664b77bc8ac5af633fd3abfe001e77f837cd" translate="yes" xml:space="preserve">
          <source>The target name is the name of the runtime permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;loadLibrary.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*loadLibrary&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 런타임 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;loadLibrary. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* loadLibrary&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d958abd00740d8b81aa7e7e8a7237d717e401b13" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a Credential class name, and a Set of Principals. The only valid value for this Permission's actions is, &quot;read&quot;. The target name must abide by the following syntax:</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 자격 증명 클래스 이름과 프린시 펄 세트를 지정합니다. 이 권한 작업에 유효한 값은 &quot;읽기&quot;뿐입니다. 대상 이름은 다음 구문을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="91a399d1980f8a6ccc96217289bf0be48ee37eb6" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a pair of kerberos service principals. The first is the subordinate service principal being entrusted to use the TGT. The second service principal designates the target service the subordinate service principal is to interact with on behalf of the initiating KerberosPrincipal. This latter service principal is specified to restrict the use of a proxiable ticket.</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 한 쌍의 Kerberos 서비스 주체를 지정합니다. 첫 번째는 TGT를 사용하도록 위임 된 하위 서비스 주체입니다. 두 번째 서비스 주체는 하위 서비스 주체가 시작 KerberosPrincipal을 대신하여 상호 작용할 대상 서비스를 지정합니다. 후자의 서비스 주체는 프록시 가능한 티켓의 사용을 제한하도록 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a69bc10fa3486dc0c871c21c9260fdc72fa60465" translate="yes" xml:space="preserve">
          <source>The target of the symbolic link</source>
          <target state="translated">심볼릭 링크의 대상</target>
        </trans-unit>
        <trans-unit id="0fba2a96aca3512f3b2fa2ec8c997febf4ea99a4" translate="yes" xml:space="preserve">
          <source>The target property may also be &quot;qualified&quot; with an arbitrary number of property prefixs delimited with the &quot;.&quot; character. For example, the following action listener:</source>
          <target state="translated">대상 속성은 &quot;.&quot;로 구분 된 임의의 수의 속성 접두사를 사용하여 &quot;자격을 갖춘&quot;것일 수도 있습니다. 캐릭터. 예를 들어, 다음 조치 리스너 :</target>
        </trans-unit>
        <trans-unit id="8a356eae8e68f37248d1a45a231f374ef9c3a79c" translate="yes" xml:space="preserve">
          <source>The target string buffer</source>
          <target state="translated">대상 문자열 버퍼</target>
        </trans-unit>
        <trans-unit id="ac13bf867264e56e3d64038eb74fe1bea028918f" translate="yes" xml:space="preserve">
          <source>The tc &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= tc &amp;lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.</source>
          <target state="translated">tc &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= tc &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="351d171d0044484a95b6580add4a8d56a0b09177" translate="yes" xml:space="preserve">
          <source>The tempo-based timing type, for which the resolution is expressed in pulses (ticks) per quarter note.</source>
          <target state="translated">해상도가 1/4 음당 펄스 (틱)로 표시되는 템포 기반 타이밍 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f2ec5ccb70e544f59fa930934598819b7960048f" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;directly present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;, &lt;em&gt;present&lt;/em&gt;, and &lt;em&gt;associated&lt;/em&gt; are used throughout this interface to describe precisely which annotations are returned by methods:</source>
          <target state="translated">용어 &lt;em&gt;직접 본&lt;/em&gt; , &lt;em&gt;간접적으로 본&lt;/em&gt; , &lt;em&gt;본&lt;/em&gt; 과 &lt;em&gt;연관된은&lt;/em&gt; 정확하게 주석 방법에 의해 반환되는 기술이 인터페이스에 걸쳐 사용된다 :</target>
        </trans-unit>
        <trans-unit id="5e5bbe231cb2211cfe2a7c06f4bc2ee771bc88c2" translate="yes" xml:space="preserve">
          <source>The text boundary returned from the above methods, first or last text boundary.</source>
          <target state="translated">위 방법에서 반환 된 텍스트 경계, 첫 번째 또는 마지막 텍스트 경계.</target>
        </trans-unit>
        <trans-unit id="1899b3e37537fc1d6b9f560d72d02ead7717a9d2" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date-time.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 날짜-시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="119fbb383bccf4eac0375adfb016d1b3f8304e40" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하고 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc611f16d1b6999b1ff7fa074c651bc88768faa1" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a month-day.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 한 달 동안 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2408a1b2fa16fded0ccd21134505f7a2dfa87a20" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a time.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하여 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8aa28741c1cf5a7ab0d06ececd2ac50c4950d93d" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year-month.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1700b19da145b2d61543e5a3e6060e9ee5311e75" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="714efd5fdbdc7a0051ac3528e30febfdfcc4d3b6" translate="yes" xml:space="preserve">
          <source>The text of the field will be output during a format. The value must be within the valid range of the field. If the value cannot be obtained then an exception will be thrown. If the field has no textual representation, then the numeric value will be used.</source>
          <target state="translated">필드의 텍스트는 포맷 중에 출력됩니다. 값은 필드의 유효한 범위 내에 있어야합니다. 값을 얻을 수 없으면 예외가 발생합니다. 필드에 텍스트 표현이 없으면 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="994a75acb429e80d94201f4b7fd1307dd3c02908" translate="yes" xml:space="preserve">
          <source>The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is the same that would be returned by</source>
          <target state="translated">반환 된 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 의 텍스트 는 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8d32f65f9358481d68c26733468e9f5827be3bb9" translate="yes" xml:space="preserve">
          <source>The text range that the attribute is applied to is critical to the semantics of the range. That means, the attribute cannot be applied to subranges of the text range that it applies to, and, if two adjacent text ranges have the same value for this attribute, the attribute still cannot be applied to the combined range as a whole with this value.</source>
          <target state="translated">속성이 적용되는 텍스트 범위는 해당 범위의 의미에 중요합니다. 즉, 속성을 적용 할 텍스트 범위의 하위 범위에 속성을 적용 할 수 없으며, 인접한 두 텍스트 범위에이 속성 값이 동일한 경우이 값을 사용하여 속성을 결합 된 범위에 계속 적용 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="1b53d1b9f2d6a1ffec39094319a28b6fff2de1b3" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">각 상수 UnicodeBlock 식별자의 텍스트 표현입니다. 예를 들어,이 메소드는 &quot;BASIC_LATIN&quot;이름이 제공된 경우 &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt; 블록 을 리턴합니다 . 이 형식은 표준 이름의 모든 공백과 하이픈을 밑줄로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="77b9d7619830528efce6f7817705037fc5acc9d6" translate="yes" xml:space="preserve">
          <source>The text substituted for the individual format elements is derived from the current subformat of the format element and the &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index as indicated by the first matching line of the following table. An argument is</source>
          <target state="translated">개별 형식 요소로 대체 ​​된 텍스트는 형식 요소의 현재 하위 형식과 다음 표의 첫 번째 일치 행으로 표시되는 형식 요소의 인수 색인에 있는 &lt;code&gt;arguments&lt;/code&gt; 요소에서 파생됩니다 . 논쟁은</target>
        </trans-unit>
        <trans-unit id="9207fb7b3a8409b78131b80ed0af5df70aca6d6f" translate="yes" xml:space="preserve">
          <source>The text will be parsed from the specified start &lt;code&gt;ParsePosition&lt;/code&gt;. The entire length of the text does not have to be parsed, the &lt;code&gt;ParsePosition&lt;/code&gt; will be updated with the index at the end of parsing.</source>
          <target state="translated">지정된 시작 &lt;code&gt;ParsePosition&lt;/code&gt; 에서 텍스트가 구문 분석됩니다 . 텍스트의 전체 길이를 구문 분석 할 필요는 없습니다 . 구문 분석 종료시 &lt;code&gt;ParsePosition&lt;/code&gt; 이 색인으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1448b4199b12055b6e038925f7a2322eace6c39d" translate="yes" xml:space="preserve">
          <source>The textual representation of IPv6 addresses as described above can be extended to specify IPv6 scoped addresses. This extension to the basic addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].</source>
          <target state="translated">위에서 설명한 IPv6 주소의 텍스트 표현을 확장하여 IPv6 범위 주소를 지정할 수 있습니다. 기본 주소 지정 아키텍처에 대한이 확장은 [draft-ietf-ipngwg-scoping-arch-04.txt]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="619857d696535395d9a9e6e85c75cbda308cd69b" translate="yes" xml:space="preserve">
          <source>The textual representation of an IP address is address family specific.</source>
          <target state="translated">IP 주소의 텍스트 표현은 주소 패밀리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a243b35a93201c218afa01a0732e236f52dc54db" translate="yes" xml:space="preserve">
          <source>The third rule means for example that if the attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; is a &lt;code&gt;MemoryUsage&lt;/code&gt;, monitoring &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; will obtain the observed value by calling &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt;.</source>
          <target state="translated">세 번째 규칙은 예를 들어 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 속성 이 &lt;code&gt;MemoryUsage&lt;/code&gt; 인 경우 &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 를 모니터링 하면 &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt; 를 호출하여 관찰 된 값을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="cd8c7b9c1c14ab7ee8912062724df6f9139f499d" translate="yes" xml:space="preserve">
          <source>The third type of ID are region-based IDs. A region-based ID must be of two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'. Region-based IDs are defined by configuration, see &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. The configuration focuses on providing the lookup from the ID to the underlying &lt;code&gt;ZoneRules&lt;/code&gt;.</source>
          <target state="translated">세 번째 유형의 ID는 지역 기반 ID입니다. 지역 기반 ID는 2 자 이상이어야하며 'UTC', 'GMT', 'UT' '+'또는 '-'로 시작하지 않아야합니다. 지역 기반 ID는 구성에 따라 정의됩니다 ( &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 참조) . 구성은 ID에서 기본 &lt;code&gt;ZoneRules&lt;/code&gt; 로 조회를 제공하는 데 중점을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="798fb3ab3b700a8b0974f49f646feb0adf6c0b98" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 가이 오브젝트의 대기 세트에서 제거되고 스레드 스케줄링을 위해 다시 사용 가능합니다. 그런 다음 일반적인 방식으로 다른 스레드와 경쟁하여 개체에서 동기화 할 수 있습니다. 일단 객체의 제어권을 얻은 후에는 객체에 대한 모든 동기화 클레임이 현재 상태 즉, &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 된 시점의 상황으로 복원 됩니다. 그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는 &lt;code&gt;wait&lt;/code&gt; 메소드 호출에서 리턴합니다 . 따라서 &lt;code&gt;wait&lt;/code&gt; 메소드 에서 리턴 될 때 오브젝트와 스레드 &lt;code&gt;T&lt;/code&gt; 의 동기화 상태 는 &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 되었을 때와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3886d03f704e9f4661772e22e536d051a2540f61" translate="yes" xml:space="preserve">
          <source>The thread ID property will be initialized with a unique ID for the current thread.</source>
          <target state="translated">스레드 ID 속성은 현재 스레드의 고유 ID로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9cc25b45a652d2428c1ca7ad40c7f0ae634fb0" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">스레드가 &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt; 상태에 있으며 &lt;code&gt;synchronized&lt;/code&gt; 명령문 또는 메소드 를 입력하려고 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="77e59a24e2fff88b3f72bac70df76f307ccbec5b" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 스레드가 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다. 동기화 오브젝트는 &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 오브젝트입니다 . 일반적으로 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 가능한 동기화 기&lt;/a&gt; 또는 &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b971951034e25a9cbf8c4a7520b71c76ce7c9c" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../object#wait-long-&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드는 &lt;a href=&quot;../object#wait-long-&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="1cae8d80c59d4da83095fa5ad01a12ad0e9b0377" translate="yes" xml:space="preserve">
          <source>The thread represented by this thread is forced to stop whatever it is doing abnormally and to throw a newly created &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</source>
          <target state="translated">이 스레드로 표시되는 스레드는 비정상적으로 수행중인 작업을 중지하고 새로 작성된 &lt;code&gt;ThreadDeath&lt;/code&gt; 오브젝트를 예외로 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0b3e60ed90635a926c08dd344792b7dde7c9298f" translate="yes" xml:space="preserve">
          <source>The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</source>
          <target state="translated">그런 다음 스레드는 모니터 소유권을 다시 얻을 수있을 때까지 기다렸다가 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="25b717a3fa1cf9d27360f778068bc0905b1e3681" translate="yes" xml:space="preserve">
          <source>The threads may be executing while this method is called. The stack trace of each thread only represents a snapshot and each stack trace may be obtained at different time. A zero-length array will be returned in the map value if the virtual machine has no stack trace information about a thread.</source>
          <target state="translated">이 메소드가 호출되는 동안 스레드가 실행 중일 수 있습니다. 각 스레드의 스택 추적은 스냅 샷 만 나타내며 각 스택 추적은 다른 시간에 얻을 수 있습니다. 가상 머신에 스레드에 대한 스택 추적 정보가없는 경우 길이가 0 인 배열이 맵 값으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e3ff0b6b3a8faf4f1e95b0c706e80d227c4311" translate="yes" xml:space="preserve">
          <source>The three aspects of &lt;code&gt;collect&lt;/code&gt; -- supplier, accumulator, and combiner -- are tightly coupled. We can use the abstraction of a &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; to capture all three aspects. The above example for collecting strings into a &lt;code&gt;List&lt;/code&gt; can be rewritten using a standard &lt;code&gt;Collector&lt;/code&gt; as:</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; , 공급기, 축 압기 및 결합기 의 세 가지 측면 은 밀접하게 연결되어 있습니다. &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 의 추상화를 사용하여 세 가지 측면을 모두 캡처 할 수 있습니다 . 문자열을 &lt;code&gt;List&lt;/code&gt; 로 수집하는 위의 예제는 다음과 같이 표준 &lt;code&gt;Collector&lt;/code&gt; 를 사용하여 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccdf2eb66d2e71f34a919a596f65bb338f795c35" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">3 가지 형태의 &lt;code&gt;park&lt;/code&gt; 각각 &lt;code&gt;blocker&lt;/code&gt; 객체 매개 변수를 지원합니다 . 이 오브젝트는 스레드가 차단되는 동안 기록되어 모니터링 및 진단 도구가 스레드가 차단 된 이유를 식별 할 수 있습니다. (이러한 도구는 &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 블로커에 액세스 할 수 있습니다 .)이 매개 변수가없는 원래 양식 대신 이러한 양식을 사용하는 것이 좋습니다. 잠금 구현 내에서 &lt;code&gt;blocker&lt;/code&gt; 로 제공하는 일반적인 인수 는 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df00dd95000e60bd282d65d477e94c0a82461152" translate="yes" xml:space="preserve">
          <source>The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.</source>
          <target state="translated">대기 중, 중단 불가능 및 시간 지정의 세 가지 조건 대기 조건은 일부 플랫폼에서의 구현 용이성과 성능 특성이 다를 수 있습니다. 특히, 이러한 기능을 제공하고 주문 보장과 같은 특정 의미를 유지하는 것이 어려울 수 있습니다. 또한 스레드의 실제 서스펜션을 방해하는 기능이 모든 플랫폼에서 항상 구현 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db29ad82518a2ee6d7ddfaf1a9c7b34c8ecf4057" translate="yes" xml:space="preserve">
          <source>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; acquisition of a lock may not be available in a given &lt;code&gt;Lock&lt;/code&gt; class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</source>
          <target state="translated">3 가지 형태의 잠금 획득 (인터럽터 블, 인터럽터 블 및 타임 드)은 성능 특성, 순서 보증 또는 기타 구현 품질이 다를 수 있습니다. 또한, 잠금 의 &lt;em&gt;진행중인&lt;/em&gt; 획득 을 방해하는 기능 은 주어진 &lt;code&gt;Lock&lt;/code&gt; 에서 사용 가능하지 않을 수 있습니다수업. 결과적으로, 구현은 세 가지 형태의 잠금 획득 모두에 대해 정확히 동일한 보장 또는 의미를 정의 할 필요가 없으며, 진행중인 잠금 획득의 중단을 지원할 필요도 없다. 각 잠금 방법이 제공하는 의미 및 보증을 명확하게 문서화하려면 구현이 필요합니다. 또한 잠금 획득 중단이 지원되는 정도까지이 인터페이스에 정의 된 중단 시맨틱을 준수해야합니다. 이는 완전히 또는 메소드 입력에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1243cf17aa93cee91f50c4b5f0c4dfc5e1efee1" translate="yes" xml:space="preserve">
          <source>The three values for decomposition mode are:</source>
          <target state="translated">분해 모드의 세 가지 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eca35f7b2afddf8594835c4c8f46728d1529fce5" translate="yes" xml:space="preserve">
          <source>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step. We could re-cast the simple sum-of-weights example using the more general form as follows:</source>
          <target state="translated">3 인수 형식은 매핑 단계를 누적 단계에 통합 한 2 인수 형식의 일반화입니다. 다음과 같이보다 일반적인 형식을 사용하여 간단한 가중치 합계 예제를 다시 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e826b013ebf5d13455251fda42b4b52a0a40d6" translate="yes" xml:space="preserve">
          <source>The threshold high or threshold low are not of the same type as the gauge (gauge monitors).</source>
          <target state="translated">임계 값 상한 또는 임계 값 하한은 게이지 (게이지 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="618cf78884b8f69aa1ff4f548c236bef8d448a10" translate="yes" xml:space="preserve">
          <source>The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).</source>
          <target state="translated">임계 값 또는 오프셋 또는 계수는 카운터 (카운터 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b761c49c0df6550fd9288c6d950a41463038892" translate="yes" xml:space="preserve">
          <source>The threshold value for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 MBean가 관찰 된 MBean 세트에있는 경우, 지정된 MBean의 임계 값 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4abbaad922146601ba46b4fe49f8e578a3e9883a" translate="yes" xml:space="preserve">
          <source>The threshold value of the specified object.</source>
          <target state="translated">지정된 객체의 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="93ccc78354f36ab6014746446d9124e4c9a55c8e" translate="yes" xml:space="preserve">
          <source>The threshold value.</source>
          <target state="translated">임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8421d23d14f7481a0d1af497cd30f15efc9c681" translate="yes" xml:space="preserve">
          <source>The tick duration must be positive. If it has a part smaller than a whole millisecond, then the whole duration must divide into one second without leaving a remainder. All normal tick durations will match these criteria, including any multiple of hours, minutes, seconds and milliseconds, and sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.</source>
          <target state="translated">틱 기간은 양수 여야합니다. 전체 밀리 초보다 작은 부분이 있으면 나머지 시간을 남기지 않고 전체 지속 시간을 1 초로 나누어야합니다. 모든 일반 틱 기간은 시간, 분, 초 및 밀리 초의 배수 및 20ns, 250,000ns 및 500,000ns와 같은 합리적인 나노초 기간을 포함하여 이러한 기준과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3d7a7f884123f38061b4f01b40f6fca44848eb92" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cf65733067f037d5f7c0913c18befc5a4452eae3" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c06ad7fab5af0cf4e31869a72aaa8c0967814aa" translate="yes" xml:space="preserve">
          <source>The time does not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4106b4f9e69339c1872abca12ca2da7faed9666a" translate="yes" xml:space="preserve">
          <source>The time in milli-seconds that the MBeanInfo can reasonably be expected to be unchanged. The value can be a &lt;code&gt;Long&lt;/code&gt; or a decimal string. This provides a hint from a DynamicMBean or any MBean that does not define &lt;code&gt;immutableInfo&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; that the MBeanInfo is not likely to change within this period and therefore can be cached. When this field is missing or has the value zero, it is not recommended to cache the MBeanInfo unless it has the &lt;code&gt;immutableInfo&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; or it has &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; in its &lt;a href=&quot;mbeannotificationinfo&quot;&gt;&lt;code&gt;MBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; array.</source>
          <target state="translated">MBeanInfo가 합리적으로 변경 될 것으로 예상되는 시간 (밀리 초)입니다. 값은 &lt;code&gt;Long&lt;/code&gt; 또는 10 진수 문자열 일 수 있습니다 . 이는 MBeanInfo가이 기간 내에 변경되지 않아 캐시 될 수 있다는 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;immutableInfo&lt;/code&gt; 를 true 로 정의하지 않은 DynamicMBean 또는 MBean의 힌트를 제공합니다 . 이 필드가 없거나 값이 0 인 경우, &lt;code&gt;immutableInfo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있거나 &lt;a href=&quot;mbeannotificationinfo&quot;&gt; &lt;code&gt;MBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 배열 에 &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 MBeanInfo를 캐시하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="acbf0fbbf2519547cc43bc06b63a9e4515272ec9" translate="yes" xml:space="preserve">
          <source>The time is converted into an instant using the time definition.</source>
          <target state="translated">시간은 시간 정의를 사용하여 순간으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5996955378dd36992f5dee7922b6ee64c4396fe3" translate="yes" xml:space="preserve">
          <source>The time limit of these SearchControls in milliseconds.</source>
          <target state="translated">이러한 SearchControl의 시간 제한 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="526444c169e427c129c525d4df96c1420c7a51f7" translate="yes" xml:space="preserve">
          <source>The time of midnight at the start of the day, '00:00'.</source>
          <target state="translated">시작 시간의 자정 시간, '00 : 00 '.</target>
        </trans-unit>
        <trans-unit id="8f833517ae6c82bdf28f4d07f70897fd379d4f67" translate="yes" xml:space="preserve">
          <source>The time of noon in the middle of the day, '12:00'.</source>
          <target state="translated">정오의 시간, '12 : 00 '.</target>
        </trans-unit>
        <trans-unit id="8f963cde5781a47df760ad32650d381c8f0dbe75" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">일광 절약 시간 제가 시작되거나 끝나는 시간은 하루 내의 밀리 초 값으로 지정됩니다. 시간을 지정하는 세 가지 종류의 &lt;em&gt;모드&lt;/em&gt; 가 있습니다 : &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt; . 예를 들어, 일광 절약 시간이 벽시계 시간으로 오전 2시에 종료되면 &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; 모드 에서 7200000 밀리 초로 지정할 수 있습니다 . 이 경우 &lt;em&gt;종료 규칙의&lt;/em&gt; 벽시계 시간 은 일광 절약 시간과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="422a6a0727efc668eadfab588f39e7901af76990" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for disabling the expiration control for loaded resource bundle instances in the cache.</source>
          <target state="translated">캐시에로드 된 자원 번들 인스턴스에 대한 만료 제어를 사용하지 않도록 설정하기위한 지속 시간 상수</target>
        </trans-unit>
        <trans-unit id="c09406968aca987adec6afd3d870562c13c5226c" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for not caching loaded resource bundle instances.</source>
          <target state="translated">로드 된 자원 번들 인스턴스를 캐싱하지 않는 지속 시간 상수.</target>
        </trans-unit>
        <trans-unit id="2948afa6c507e96db7157cef9cbb050870dbd00b" translate="yes" xml:space="preserve">
          <source>The time-zone offset for UTC, with an ID of 'Z'.</source>
          <target state="translated">ID가 'Z'인 UTC의 시간대 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="1dfd324cfb41000f9d3aba1f9dad090939b1b93f" translate="yes" xml:space="preserve">
          <source>The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has elapsed.</source>
          <target state="translated">시간 &lt;code&gt;timeout&lt;/code&gt; 밀리 초와 &lt;code&gt;nanos&lt;/code&gt; 나노초 인수로 지정된 시간 초과 기간 이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="e87dd73958b4c331aa3b482b31ba9b3bb70f0291" translate="yes" xml:space="preserve">
          <source>The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">시간 초과 값 (밀리 초)은 시도에 걸리는 최대 시간을 나타냅니다. 응답을 받기 전에 작업 시간이 초과되면 호스트에 연결할 수없는 것으로 간주됩니다. 값이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a3c7016b356d85ab2005993ec546da2021f5da3" translate="yes" xml:space="preserve">
          <source>The timer notification detailed message or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 상세 메세지. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 맵되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="e45c48a5b2ba20c62b4614e6273292d7390eb1e1" translate="yes" xml:space="preserve">
          <source>The timer notification type or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 형. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="23967f54cac8eb8b003d2fc196f922e43be03fd3" translate="yes" xml:space="preserve">
          <source>The timer notification user data object or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 사용자 데이터 객체. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="d238facacd1f3d07587721542ed70d70cb4c4775" translate="yes" xml:space="preserve">
          <source>The timer notification will be handled once at the specified date.</source>
          <target state="translated">타이머 알림은 지정된 날짜에 한 번 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="414f37292531292150b0ccb1cad0625336e616e7" translate="yes" xml:space="preserve">
          <source>The timer notification will repeat continuously using the timer period using a</source>
          <target state="translated">타이머 알림은 a를 사용하여 타이머 기간을 사용하여 계속 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="315f63d583a4676ef18933ae7199a0ed0f9a00e4" translate="yes" xml:space="preserve">
          <source>The timer notifications are created and handled by the timer MBean.</source>
          <target state="translated">타이머 통지는 타이머 MBean에 의해 작성되어 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cd191085be187917516f28d90bc41b5e0e055de2" translate="yes" xml:space="preserve">
          <source>The timer service relies on the system date of the host where the &lt;code&gt;Timer&lt;/code&gt; class is loaded. Listeners may receive untimely notifications if their host has a different system date. To avoid such problems, synchronize the system date of all host machines where timing is needed.</source>
          <target state="translated">타이머 서비스는 &lt;code&gt;Timer&lt;/code&gt; 클래스가로드 된 호스트의 시스템 날짜에 의존합니다 . 호스트의 시스템 날짜가 다른 경우 리스너가시기 적절하지 않은 알림을받을 수 있습니다. 이러한 문제를 피하려면 타이밍이 필요한 모든 호스트 시스템의 시스템 날짜를 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="60a7b8fc73dec0735c0c82b6db258aba41d55181" translate="yes" xml:space="preserve">
          <source>The timestamp of this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">이것의 타임 스탬프 &lt;code&gt;UUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d91c8abe6606f2a3d89bcf82e749e9e60f3b44c" translate="yes" xml:space="preserve">
          <source>The timestamp or &lt;code&gt;null&lt;/code&gt; if none is present.</source>
          <target state="translated">타임 스탬프 . 존재하지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a65048c31509f7e0113cb6ea8961ee3f79f086" translate="yes" xml:space="preserve">
          <source>The timestamp value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 시간 소인 값입니다.</target>
        </trans-unit>
        <trans-unit id="77858a6a5789b904ad06d6e90ad129b1b4ed75fb" translate="yes" xml:space="preserve">
          <source>The timestamp value is only meaningful in a time-based UUID, which has version type 1. If this &lt;code&gt;UUID&lt;/code&gt; is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">시간 소인 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 &lt;code&gt;UUID&lt;/code&gt; 가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="562d9979ad13d306cfdc69375e27b692b4c4e6be" translate="yes" xml:space="preserve">
          <source>The timestamp's date and time.</source>
          <target state="translated">타임 스탬프의 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="2f99efc0a5831891f40ab823d3bf06354b6d699f" translate="yes" xml:space="preserve">
          <source>The timing division type of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 분할 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d0374fbf6438fbc3467dbf34b4e05683b94595c3" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">트랙의 타이밍 정보 및 해상도는 트랙을 포함하는 시퀀스에 의해 제어되고 저장됩니다. 주어진 &lt;code&gt;Track&lt;/code&gt; 은 타이밍을 유지 하는 특정 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 에 속하는 것으로 간주됩니다 . 이러한 이유로 &lt;code&gt;Track&lt;/code&gt; 생성자를 직접 호출하지 않고 &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메서드 를 호출하여 새 (빈) 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e6d3880f415cd4ec5def31690bbd751de4d2179" translate="yes" xml:space="preserve">
          <source>The timing resolution of the MIDI file.</source>
          <target state="translated">MIDI 파일의 타이밍 해상도</target>
        </trans-unit>
        <trans-unit id="94d8255f666f78ba91e4c0653d1ddca333f07432" translate="yes" xml:space="preserve">
          <source>The timing resolution of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 해상도.</target>
        </trans-unit>
        <trans-unit id="46bd53fc951ee54ff26208f7f7d6b401775175dc" translate="yes" xml:space="preserve">
          <source>The tool environment is not required to support annotation processors that access environmental resources, either &lt;a href=&quot;roundenvironment&quot;&gt;per round&lt;/a&gt; or &lt;a href=&quot;processingenvironment&quot;&gt;cross-round&lt;/a&gt;, in a multi-threaded fashion.</source>
          <target state="translated">이 도구 환경을 지원 주석 프로세서에 필요하지 않습니다 대한 액세스 환경 자원, 중 &lt;a href=&quot;roundenvironment&quot;&gt;라운드 당&lt;/a&gt; 또는 &lt;a href=&quot;processingenvironment&quot;&gt;크로스 라운드&lt;/a&gt; 멀티 스레드 방식으로 .</target>
        </trans-unit>
        <trans-unit id="475033ec07ec172731d36e8e1a8c4e34cb1c0c10" translate="yes" xml:space="preserve">
          <source>The tool uses a</source>
          <target state="translated">이 도구는</target>
        </trans-unit>
        <trans-unit id="6ee07dce8496ccc8327ec779a3d953aaa0190c20" translate="yes" xml:space="preserve">
          <source>The top input tray in the printer.</source>
          <target state="translated">프린터의 상단 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="42a671ce68c829c9c3682af0e642fe256fbef14d" translate="yes" xml:space="preserve">
          <source>The top-level error handler that reacts to otherwise uncaught exceptions does not print out a message or otherwise notify the application if the uncaught exception is an instance of &lt;code&gt;ThreadDeath&lt;/code&gt;.</source>
          <target state="translated">캐치되지 않은 예외에 반응하는 최상위 레벨 오류 처리기는 캐치되지 않은 예외가 &lt;code&gt;ThreadDeath&lt;/code&gt; 의 인스턴스 인 경우 메시지를 인쇄하거나 애플리케이션에 알리지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46f6d47ae13aad5695f239448bb57766c13e2aa1" translate="yes" xml:space="preserve">
          <source>The total length of the message in bytes (the status byte plus any data bytes)</source>
          <target state="translated">메시지의 총 길이 (바이트) (상태 바이트 + 모든 데이터 바이트)</target>
        </trans-unit>
        <trans-unit id="7ad0ea114ec1ddf71f5fe2d46d0cb9e7197a57a0" translate="yes" xml:space="preserve">
          <source>The total number of significant digits in</source>
          <target state="translated">유효 유효 자릿수의 총계</target>
        </trans-unit>
        <trans-unit id="5fa423bbef1d4f0ed7a551ce1858b400fcccf4df" translate="yes" xml:space="preserve">
          <source>The transition may be represented as occurring at 24:00.</source>
          <target state="translated">전환은 24:00에 발생하는 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6f791fb336426f0b5c534f66eae3384f79ccf9" translate="yes" xml:space="preserve">
          <source>The trigger.</source>
          <target state="translated">방아쇠</target>
        </trans-unit>
        <trans-unit id="19d46a2a9ae7b495f51fc356027feaf3becd628d" translate="yes" xml:space="preserve">
          <source>The truth value returned by this method is equivalent to: &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt;</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 진실 &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt; 다음과 같습니다. getAnnotation (annotationClass)! = null</target>
        </trans-unit>
        <trans-unit id="2485bd279a135141b31dd6331097ba469508ddf1" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;은 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. TTL &lt;code&gt;0&lt;/code&gt; 으로 전송 된 멀티 캐스트 패킷 은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6940391f4a3596501f2f3676ceed69996fe5b256" translate="yes" xml:space="preserve">
          <source>The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt;.</source>
          <target state="translated">ttl은 &lt;b&gt; 부호없는&lt;/b&gt; 8 비트 수량이므로 &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt; 범위에 &lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="969fb09f0d47cbd4ef59365982ee80f259c1e668" translate="yes" xml:space="preserve">
          <source>The twelve methods described above are summarized in the following table:</source>
          <target state="translated">위에서 설명한 12 가지 방법이 다음 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3593155b51237a7085bf75da2140fc0fe3e8c66" translate="yes" xml:space="preserve">
          <source>The two calls have the same effect.</source>
          <target state="translated">두 통화의 효과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b92a8d153cce49ff845ddf50531191cd3a963be7" translate="yes" xml:space="preserve">
          <source>The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially, see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.</source>
          <target state="translated">두 경우 ( &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) 및 ( &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;)는 특수하게 처리 됩니다. 자세한 내용 은 &lt;a href=&quot;#special_cases_constructor&quot;&gt;특수 사례&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
