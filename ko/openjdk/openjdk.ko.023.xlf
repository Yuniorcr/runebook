<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="69e6051986f502b35b40f12341fca7ee231dbb2f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ImageWriteParam&lt;/code&gt; allows tiling grid offset parameters to be set. By default, the value is &lt;code&gt;false&lt;/code&gt;. Subclasses must set the value manually.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 이 경우 &lt;code&gt;ImageWriteParam&lt;/code&gt; 로는 그리드 오프셋 매개 변수를 바둑판 수를 설정할 수 있습니다. 기본적으로 값은 &lt;code&gt;false&lt;/code&gt; 입니다. 서브 클래스는 값을 수동으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8334a88bf0f77348a41e079c994d353ef7e14ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this writer can write images using compression. By default, the value is &lt;code&gt;false&lt;/code&gt;. Subclasses must set the value manually.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 이 작가가 압축을 사용하여 이미지를 기록 할 수있는 경우. 기본적으로 값은 &lt;code&gt;false&lt;/code&gt; 입니다. 서브 클래스는 값을 수동으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="af783e5ccce67dac2defe55ca956bd446858f68b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if tiling parameters have been specified.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 타일링 파라미터가 지정되고있는 경우.</target>
        </trans-unit>
        <trans-unit id="298b6d38fd53ceb77f5afd16627685f8849adc99" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; value that may be updated atomically.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 원자적인 갱신 값.</target>
        </trans-unit>
        <trans-unit id="c101afa2aedde90937ffa8c036550e520ca97ed0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; value that may be updated atomically. See the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; package specification for description of the properties of atomic variables. An &lt;code&gt;AtomicBoolean&lt;/code&gt; is used in applications such as atomically updated flags, and cannot be used as a replacement for a &lt;a href=&quot;../../../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 원자적인 갱신 값. 원자 변수의 특성에 대한 설명은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; &lt;/a&gt; 패키지 스펙을 참조하십시오 . &lt;code&gt;AtomicBoolean&lt;/code&gt; 는 같은 원자 적으로 갱신 플래그와 같은 응용 프로그램에서 사용되며, 대체로 사용할 수 없습니다 &lt;a href=&quot;../../../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20da1027223eab2ad2c66e79d10dc8ff1024234e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; value, therefore, represents Basic Multilingual Plane (BMP) code points, including the surrogate code points, or code units of the UTF-16 encoding. An &lt;code&gt;int&lt;/code&gt; value represents all Unicode code points, including supplementary code points. The lower (least significant) 21 bits of &lt;code&gt;int&lt;/code&gt; are used to represent Unicode code points and the upper (most significant) 11 bits must be zero. Unless otherwise specified, the behavior with respect to supplementary characters and surrogate &lt;code&gt;char&lt;/code&gt; values is as follows:</source>
          <target state="translated">따라서 &lt;code&gt;char&lt;/code&gt; 값은 서로 게이트 코드 포인트 또는 UTF-16 인코딩의 코드 단위를 포함하여 BMP (Basic Multilingual Plane) 코드 포인트를 나타냅니다. &lt;code&gt;int&lt;/code&gt; 값은 보조 코드 포인트를 포함한 모든 Unicode 코드 포인트를 나타냅니다. &lt;code&gt;int&lt;/code&gt; 의 하위 (최하위) 21 비트 는 유니 코드 코드 포인트를 나타내는 데 사용되며 상위 (가장 중요한) 11 비트는 0이어야합니다. 별도로 지정하지 않는 한 보충 문자 및 서로 게이트 &lt;code&gt;char&lt;/code&gt; 값에 대한 동작 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eda7397702e8e699a3d9cd248aa7777f6f0ea18d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;count&lt;/code&gt; value of 0 disables looping: playback will continue at the loop end point, and it will not loop back to the loop start point. This is a sequencer's default.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 루핑 0 비활성화 값 : 재생이 루프의 끝 지점에서 계속됩니다, 그것은 루프 시작점 루프 다시하지 않습니다. 이것이 시퀀서의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cd82d12abe21bb169705776073d69b7b82dee223" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;count&lt;/code&gt; value of 0 indicates that any current looping should cease and playback should continue to the end of the clip. The behavior is undefined when this method is invoked with any other value during a loop operation.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 0의 값은 현재의 루프를 정지 해 클립의 끝까지 재생을 계속하는 것을 나타냅니다. 루프 조작 중이 값을 다른 값으로 호출하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="002c59e83944aa5f0541632ce7cc87a21431c134" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;float&lt;/code&gt; containing the current compression quality setting. The initial value is &lt;code&gt;1.0F&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 현재의 압축 품질 설정을 함유. 초기 값은 &lt;code&gt;1.0F&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1479a5979c4c5293d1e73493a144c501a4ed3832" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;getDecoder&lt;/code&gt; method is defined similarly.</source>
          <target state="translated">&lt;code&gt;getDecoder&lt;/code&gt; 의 방법은 유사하게 정의된다.</target>
        </trans-unit>
        <trans-unit id="a0ef54338e3f5fd740d5848f5642a2c1ccb5cf6e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; array in which elements may be updated atomically.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 배열 요소의 원자 갱신 될 수있다.</target>
        </trans-unit>
        <trans-unit id="88aeee4d95787893e3688fea4c58f90d49ca8c99" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; array in which elements may be updated atomically. See the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; package specification for description of the properties of atomic variables.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 배열 요소의 원자 갱신 될 수있다. 원자 변수의 특성에 대한 설명은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; &lt;/a&gt; 패키지 스펙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03ee3984a4ce41f61a957ded4535f07488a6735b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; argument counts (for purposes of arity limits) as two argument slots.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 개의 인수 슬롯 등 (arity에 제한의 목적을 위해) 인수 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a04b66b2d94cf4ae8fbc24d6ec5f4a83902cb97c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; value representing the time the file was last modified, measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970), or &lt;code&gt;0L&lt;/code&gt; if the file does not exist or if an I/O error occurs</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 시간을 나타내는 값은 파일이 마지막 시대부터의 시간, 밀리 초 단위로 측정, 수정 된 (1970 년 1 월 1 일 00:00:00 GMT) 또는 &lt;code&gt;0L&lt;/code&gt; 파일이 존재 또는 I / O 에러가 발생했을 경우하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="bc909250cbeae60993a8740b7bb550fbcd052167" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; value that may be updated atomically.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 원자적인 갱신 값.</target>
        </trans-unit>
        <trans-unit id="192854d39ccd972a8265120efc645d14fb105c7c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;long&lt;/code&gt; value that may be updated atomically. See the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; package specification for description of the properties of atomic variables. An &lt;code&gt;AtomicLong&lt;/code&gt; is used in applications such as atomically incremented sequence numbers, and cannot be used as a replacement for a &lt;a href=&quot;../../../lang/long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt;. However, this class does extend &lt;code&gt;Number&lt;/code&gt; to allow uniform access by tools and utilities that deal with numerically-based classes.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 원자적인 갱신 값. 원자 변수의 특성에 대한 설명은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; &lt;/a&gt; 패키지 스펙을 참조하십시오 . &lt;code&gt;AtomicLong&lt;/code&gt; 는 , 원자 조작 적으로 증분되는 일련 번호 등의 어플리케이션으로 사용됩니다과의 대체로서 사용할 수 없습니다 &lt;a href=&quot;../../../lang/long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; . 그러나이 클래스는 숫자 기반 클래스를 처리하는 도구 및 유틸리티로 균일하게 액세스 할 수 있도록 &lt;code&gt;Number&lt;/code&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="e9fc1df4b7ac98eebfc4971379d3682ab28fb645" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;named-capturing group&lt;/code&gt; is still numbered as described in &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;named-capturing group&lt;/code&gt; 에 설명 된대로 계속된다 번째 &lt;a href=&quot;#gnumber&quot;&gt;그룹 번호&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddc816003f98669f500647d38c58eeab0e8488b6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;null&lt;/code&gt; address will assign the</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 주소가 할당합니다</target>
        </trans-unit>
        <trans-unit id="dcb60d8ba30e7b319805196a1f0ba9444c9c5ea9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;null&lt;/code&gt; value indicates that all destination bands will be used.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 값은 모든 목적지 밴드가 사용되고있는 것을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="5aee2cf861557c088e548f762214d97ee16bebd1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;null&lt;/code&gt; value indicates that all source bands will be used.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 값은 모든 소스 밴드가 사용되고있는 것을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="f673ebe2d5c5810c50da61a00a4c5064ab7d452e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Dynamic MBean&lt;/em&gt; is an MBean that defines its management interface at run-time. For example, a configuration MBean could determine the names and types of the attributes it exposes by parsing an XML file.</source>
          <target state="translated">&lt;em&gt;동적 MBean는,&lt;/em&gt; 실행시에 관리 인터페이스를 정의하는 MBean입니다. 예를 들어, 구성 MBean은 XML 파일을 구문 분석하여 표시하는 속성의 이름 및 유형을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1adf451901eb2b128ac5f178878235f9536b4ce" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Model MBean&lt;/em&gt; is a kind of Dynamic MBean that acts as a bridge between the management interface and the underlying managed resource. Both the management interface and the managed resource are specified as Java objects. The same Model MBean implementation can be reused many times with different management interfaces and managed resources, and it can provide common functionality such as persistence and caching. Model MBeans are defined by the package &lt;a href=&quot;modelmbean/package-summary&quot;&gt;&lt;code&gt;
        javax.management.modelmbean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;모델은 MBean의&lt;/em&gt; 관리 인터페이스와 부하 관리 자원 사이의 다리 역할을 동적 MBean의 한 종류이다. 관리 인터페이스와 관리 자원 모두 Java 오브젝트로 지정됩니다. 동일한 관리 인터페이스 및 관리 자원으로 동일한 Model MBean 구현을 여러 번 재사용 할 수 있으며 지속성 및 캐싱과 같은 공통 기능을 제공 할 수 있습니다. 모델 MBean은 &lt;a href=&quot;modelmbean/package-summary&quot;&gt; &lt;code&gt; javax.management.modelmbean&lt;/code&gt; &lt;/a&gt; 패키지에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="38f817f1bc8c8c30eeb708b79191fff2439cfeee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;URL context factory&lt;/em&gt; is a special ObjectFactory that creates contexts for resolving URLs or objects whose locations are specified by URLs. The &lt;code&gt;getObjectInstance()&lt;/code&gt; method of a URL context factory will obey the following rules.</source>
          <target state="translated">&lt;em&gt;URL 문맥 팩토리는&lt;/em&gt; URL 또는 URL가 위치를 지정하는 객체를 해결하는 컨텍스트를 생성하는 특별한 ObjectFactory를합니다. URL 컨텍스트 팩토리 의 &lt;code&gt;getObjectInstance()&lt;/code&gt; 메소드는 다음 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="bae7e79736ca0e41eec88bd1fbd34a7b4e497cc6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;direct method handle&lt;/em&gt; represents a method, constructor, or field without any intervening argument bindings or other transformations. The method, constructor, or field referred to by a direct method handle is called its &lt;em&gt;underlying member&lt;/em&gt;. Direct method handles may be obtained in any of these ways:</source>
          <target state="translated">&lt;em&gt;직접법 핸들&lt;/em&gt; 어떤 개재 인자 바인딩 또는 다른 변형없이있어서, 생성자 또는 필드를 나타낸다. 직접 메소드 핸들이 참조하는 메소드, 생성자 또는 필드를 &lt;em&gt;기본 멤버&lt;/em&gt; 라고합니다 . 직접 메소드 핸들은 다음과 같은 방법으로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c977c205f5d1a10d0c80e98d23945f1f5b0892" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles, when the creation requires access checking.</source>
          <target state="translated">&lt;em&gt;룩업 객체&lt;/em&gt; 생성 액세스 검사를 필요로하는 경우에있어서의 핸들을 생성하는 팩토리이다.</target>
        </trans-unit>
        <trans-unit id="22cf7fb007bf2d5fe1f35768641f433f636d2570" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles, when the creation requires access checking. Method handles do not perform access checks when they are called, but rather when they are created. Therefore, method handle access restrictions must be enforced when a method handle is created. The caller class against which those restrictions are enforced is known as the &lt;a href=&quot;methodhandles.lookup#lookupClass&quot;&gt;lookup class&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;룩업 객체&lt;/em&gt; 생성 액세스 검사를 필요로하는 경우에있어서의 핸들을 생성하는 팩토리이다. 메소드 핸들은 호출 될 때 액세스 점검을 수행하지 않고 작성 될 때 액세스 점검을 수행합니다. 따라서, 메소드 핸들이 작성 될 때 메소드 핸들 액세스 제한이 적용되어야합니다. 이러한 제한이 적용되는 호출자 클래스를 &lt;a href=&quot;methodhandles.lookup#lookupClass&quot;&gt;조회 클래스라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="03d5c0b02f91cd438ce51f0976c6a1b93c530e9a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutable reduction operation&lt;/em&gt; accumulates input elements into a mutable result container, such as a &lt;code&gt;Collection&lt;/code&gt; or &lt;code&gt;StringBuilder&lt;/code&gt;, as it processes the elements in the stream.</source>
          <target state="translated">&lt;em&gt;가변 감소 동작은&lt;/em&gt; 같은 결과로서 가변 용기 내로 입력 요소 축적 &lt;code&gt;Collection&lt;/code&gt; 또는 &lt;code&gt;StringBuilder&lt;/code&gt; 는 스트림의 요소가 처리.</target>
        </trans-unit>
        <trans-unit id="9e8fc7fd60302cc0d2d564d3cd78710e4bca9017" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;notification&lt;/em&gt; is an instance of the &lt;a href=&quot;notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; class or a subclass. In addition to its Java class, it has a &lt;em&gt;type&lt;/em&gt; string that can distinguish it from other notifications of the same class.</source>
          <target state="translated">&lt;em&gt;알림&lt;/em&gt; 의 인스턴스 &lt;a href=&quot;notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 클래스 또는 서브 클래스. Java 클래스 외에도 동일한 클래스의 다른 알림과 구별 할 수 있는 &lt;em&gt;유형&lt;/em&gt; 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c81f57a687d236a9823553d443d7c7bfc4f429" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;platform MBeanServer&lt;/em&gt; can be accessed with the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;getPlatformMBeanServer&lt;/code&gt;&lt;/a&gt; method. On the first call to this method, it creates the platform MBeanServer and registers all platform MXBeans including &lt;a href=&quot;platformmanagedobject&quot;&gt;platform MXBeans&lt;/a&gt;. Each platform MXBean is registered with a unique name defined in the specification of the management interface. This is a single MBeanServer that can be shared by different managed components running within the same Java virtual machine.</source>
          <target state="translated">&lt;em&gt;플랫폼의 MBeanServer&lt;/em&gt; 액세스 할 수 있습니다 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;getPlatformMBeanServer&lt;/code&gt; &lt;/a&gt; 방법. 이 방법에의 최초의 호출로 플랫폼 MBeanServer에를 만들고 포함한 모든 플랫폼 MXBean 등록 &lt;a href=&quot;platformmanagedobject&quot;&gt;플랫폼 MXBean을&lt;/a&gt; . 각 플랫폼 MXBean은 관리 인터페이스 스펙에 정의 된 고유 이름으로 등록됩니다. 이것은 동일한 Java 가상 머신 내에서 실행중인 다른 관리 구성 요소가 공유 할 수있는 단일 MBeanServer입니다.</target>
        </trans-unit>
        <trans-unit id="32bec0eef41ca07d26cedc2089260b4548d59027" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;provider package list&lt;/em&gt; is searched for as follows:</source>
          <target state="translated">&lt;em&gt;바이더 패키지 목록은&lt;/em&gt; 다음과 같이 검색된다 :</target>
        </trans-unit>
        <trans-unit id="385a385274a30bf632664dbb24d9c18b767194e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;quoted value&lt;/em&gt; consists of a quote (&lt;code&gt;&quot;&lt;/code&gt;), followed by a possibly empty string of characters, followed by another quote. Within the string of characters, the backslash (&lt;code&gt;\&lt;/code&gt;) has a special meaning. It must be followed by one of the following characters:</source>
          <target state="translated">&lt;em&gt;인용 값은&lt;/em&gt; 따옴표 (구성 &lt;code&gt;&quot;&lt;/code&gt; 다른 따옴표로 공 문자열의 가능성이, 다음). 문자의 문자열 내에서 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 특별한 의미를 가지고있다. 그것은 다음 중 하나가 와야합니다 문자 :</target>
        </trans-unit>
        <trans-unit id="881652b1aaf32556529fd976baa7d3f05a31e6a9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reduction&lt;/em&gt; operation (also called a &lt;em&gt;fold&lt;/em&gt;) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The streams classes have multiple forms of general reduction operations, called &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;reduce()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as well as multiple specialized reduction forms such as &lt;a href=&quot;intstream#sum--&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;intstream#max--&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;intstream#count--&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;감소&lt;/em&gt; (도 불리는 동작 &lt;em&gt;배량&lt;/em&gt; ) 같은리스트에 숫자 또는 집적 소자들의 세트의 합 또는 최대 값을 찾는 등의 결합 동작의 반복 적용에 의해 단일 요약 결과에 입력 요소와 콤바인들을 시퀀스를 취 . 스트림 클래스에는 &lt;a href=&quot;intstream#sum--&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;intstream#max--&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;intstream#count--&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt; 와 같은 여러 특수 축소 형식뿐만 아니라 &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;reduce()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라는 여러 일반 축소 연산 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b091889df96c828d757f4c394d0df7407841cf1e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relation type&lt;/em&gt; defines a relationship between MBeans. It contains &lt;em&gt;roles&lt;/em&gt; that the MBeans play in the relationship. Usually there are at least two roles in a relation type.</source>
          <target state="translated">&lt;em&gt;관계 유형은&lt;/em&gt; MBean의 관계를 정의한다. MBean이 관계에서 &lt;em&gt;수행&lt;/em&gt; 하는 &lt;em&gt;역할&lt;/em&gt; 을 포함 &lt;em&gt;합니다&lt;/em&gt; . 일반적으로 관계 유형에는 둘 이상의 역할이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3899aa8cc676171703dc878529f50a9965979186" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relation&lt;/em&gt; is a named instance of a relation type, where specific MBeans appear in the roles, represented by their &lt;a href=&quot;../objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;em&gt;관계는&lt;/em&gt; 그들에 의해 표현 롤 내의 특정의 MBean는 관계 유형의 명명 된 인스턴스 &lt;a href=&quot;../objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 의.</target>
        </trans-unit>
        <trans-unit id="1944d9900738e576ae4fce116ef62f21ef3a291b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;run with respect to a set of attributes&lt;/em&gt; is a maximum text range for which this condition is met for each member attribute.</source>
          <target state="translated">&lt;em&gt;속성 세트에 대한 실행은&lt;/em&gt; 이 조건이 각 회원의 특성에 대해 성립하는 최대 텍스트 범위입니다.</target>
        </trans-unit>
        <trans-unit id="0d67170b41f46f2a54ffcedc832e8521fdb9e0ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;run with respect to an attribute&lt;/em&gt; is a maximum text range for which:</source>
          <target state="translated">&lt;em&gt;속성에 대한 실행&lt;/em&gt; 의 최대 텍스트 범위 :</target>
        </trans-unit>
        <trans-unit id="806b08b4e8ef62277d75b5f1cd9e89140a50a7ed" translate="yes" xml:space="preserve">
          <source>A Base64 decoder.</source>
          <target state="translated">Base64 디코더</target>
        </trans-unit>
        <trans-unit id="38879c33dc00c52c03ee4ebf16cfa8fb6c4bb7f9" translate="yes" xml:space="preserve">
          <source>A Base64 encoder.</source>
          <target state="translated">Base64 인코더.</target>
        </trans-unit>
        <trans-unit id="7effbb868774fa7201da24bfa7e98891f4622fad" translate="yes" xml:space="preserve">
          <source>A BasicAttributes instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single BasicAttributes instance should lock the object.</source>
          <target state="translated">BasicAttributes 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. 단일 BasicAttributes 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="d9247c27ac2f78a7a463f4f28a7e2b80d016da76" translate="yes" xml:space="preserve">
          <source>A BeanContextServiceProvider implementor who wishes to provide explicit information about the services their bean may provide shall implement a BeanInfo class that implements this BeanInfo subinterface and provides explicit information about the methods, properties, events, etc, of their services.</source>
          <target state="translated">Bean이 제공 할 수있는 서비스에 대한 명시 적 정보를 제공하려는 BeanContextServiceProvider 구현자는이 BeanInfo 서브 인터페이스를 구현하고 해당 서비스의 메소드, 특성, 이벤트 등에 대한 명시 적 정보를 제공하는 BeanInfo 클래스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8f23324906add1f310a590417b0abed83b70cce" translate="yes" xml:space="preserve">
          <source>A BeanDescriptor provides global information about a &quot;bean&quot;, including its Java class, its displayName, etc.</source>
          <target state="translated">BeanDescriptor는 Java 클래스, displayName 등을 포함하여 &quot;bean&quot;에 대한 글로벌 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21e115ffee0fc95123c0feadd52121e72a12c44f" translate="yes" xml:space="preserve">
          <source>A BeanInfo object describing the target bean.</source>
          <target state="translated">대상 Bean을 설명하는 BeanInfo 오브젝트</target>
        </trans-unit>
        <trans-unit id="6c41a3a1a268cf77e426b305da1dbb801de9ddc8" translate="yes" xml:space="preserve">
          <source>A Bidi object provides information on the bidirectional reordering of the text used to create it. This is required, for example, to properly display Arabic or Hebrew text. These languages are inherently mixed directional, as they order numbers from left-to-right while ordering most other text from right-to-left.</source>
          <target state="translated">Bidi 오브젝트는 오브젝트를 작성하는 데 사용 된 텍스트의 양방향 순서 변경에 대한 정보를 제공합니다. 예를 들어 아랍어 또는 히브리어 텍스트를 올바르게 표시하려면이 작업이 필요합니다. 이 언어는 본질적으로 혼합 된 방향입니다. 숫자는 왼쪽에서 오른쪽으로 정렬하고 다른 텍스트는 오른쪽에서 왼쪽으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="29e791cb5cdd134f853346aba38560632c6426be" translate="yes" xml:space="preserve">
          <source>A BinaryRefAddr consists of a type that describes the communication mechanism and an opaque buffer containing the address description specific to that communication mechanism. The format and interpretation of the address type and the contents of the opaque buffer are based on the agreement of three parties: the client that uses the address, the object/server that can be reached using the address, and the administrator or program that creates the address.</source>
          <target state="translated">BinaryRefAddr는 통신 메커니즘을 설명하는 유형과 해당 통신 메커니즘에 특정한 주소 설명이 포함 된 불투명 버퍼로 구성됩니다. 주소 유형의 형식과 해석 및 불투명 버퍼의 내용은 주소를 사용하는 클라이언트, 주소를 사용하여 도달 할 수있는 오브젝트 / 서버 및 작성하는 관리자 또는 프로그램의 세 당사자의 동의를 기반으로합니다. 주소.</target>
        </trans-unit>
        <trans-unit id="39a6848d4b9b5cac97a7e4fd4b3cf19f03c74e59" translate="yes" xml:space="preserve">
          <source>A Binding instance is not synchronized against concurrent access by multiple threads. Threads that need to access a Binding concurrently should synchronize amongst themselves and provide the necessary locking.</source>
          <target state="translated">바인딩 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않습니다. 바인딩에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fcf840c5e0ee43714bd210d1b1ab35679b18b25" translate="yes" xml:space="preserve">
          <source>A CannotProceedException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify CannotProceedException should lock the object.</source>
          <target state="translated">CannotProceedException 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. CannotProceedException에 액세스하고 수정하려는 여러 스레드가 오브젝트를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="bb4e740e5333b7ab4af49fd927ba5c0f79ed5bfd" translate="yes" xml:space="preserve">
          <source>A CipherInputStream is composed of an InputStream and a Cipher so that read() methods return data that are read in from the underlying InputStream but have been additionally processed by the Cipher.</source>
          <target state="translated">CipherInputStream은 InputStream과 Cipher로 구성되어 read () 메소드는 기본 InputStream에서 읽지 만 Cipher에 의해 추가로 처리 된 데이터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="605214ba078d3fc48b5059183bf76aec5c86bd39" translate="yes" xml:space="preserve">
          <source>A CipherInputStream is composed of an InputStream and a Cipher so that read() methods return data that are read in from the underlying InputStream but have been additionally processed by the Cipher. The Cipher must be fully initialized before being used by a CipherInputStream.</source>
          <target state="translated">CipherInputStream은 InputStream과 Cipher로 구성되어 read () 메소드는 기본 InputStream에서 읽지 만 Cipher에 의해 추가로 처리 된 데이터를 리턴합니다. CipherInputStream에서 사용하기 전에 암호를 완전히 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f692652cfd014a1551d5de7afae9ef2f769afe87" translate="yes" xml:space="preserve">
          <source>A CipherOutputStream is composed of an OutputStream and a Cipher so that write() methods first process the data before writing them out to the underlying OutputStream.</source>
          <target state="translated">CipherOutputStream은 OutputStream과 Cipher로 구성되어 있으므로 write () 메소드가 기본 OutputStream에 데이터를 쓰기 전에 먼저 데이터를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fdab3de9abf820203ceaf09327cc721a7901d721" translate="yes" xml:space="preserve">
          <source>A CipherOutputStream is composed of an OutputStream and a Cipher so that write() methods first process the data before writing them out to the underlying OutputStream. The cipher must be fully initialized before being used by a CipherOutputStream.</source>
          <target state="translated">CipherOutputStream은 OutputStream과 Cipher로 구성되어 있으므로 write () 메소드가 기본 OutputStream에 데이터를 쓰기 전에 먼저 데이터를 처리합니다. CipherOutputStream에서 사용하기 전에 암호를 완전히 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c41e56ee0d72ad167ee0d749b8fbdd54ce445e6" translate="yes" xml:space="preserve">
          <source>A Comparator that orders &lt;code&gt;String&lt;/code&gt; objects as by &lt;code&gt;compareToIgnoreCase&lt;/code&gt;. This comparator is serializable.</source>
          <target state="translated">비교기는 주문 것을 &lt;code&gt;String&lt;/code&gt; 로로 객체 &lt;code&gt;compareToIgnoreCase&lt;/code&gt; . 이 비교기는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a88c7751045f06ed8e90b4b1167c2d52e5b7889f" translate="yes" xml:space="preserve">
          <source>A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using &lt;a href=&quot;atomic/longadder&quot;&gt;&lt;code&gt;LongAdder&lt;/code&gt;&lt;/a&gt; values and initializing via &lt;a href=&quot;concurrenthashmap#computeIfAbsent-K-java.util.function.Function-&quot;&gt;&lt;code&gt;computeIfAbsent&lt;/code&gt;&lt;/a&gt;. For example, to add a count to a &lt;code&gt;ConcurrentHashMap&amp;lt;String,LongAdder&amp;gt; freqs&lt;/code&gt;, you can use &lt;code&gt;freqs.computeIfAbsent(k -&amp;gt; new LongAdder()).increment();&lt;/code&gt;</source>
          <target state="translated">ConcurrentHashMap의 확장을 이용하여 주파수 맵 (또는 MULTISET 히스토그램의 형태)로서 사용될 수있다 &lt;a href=&quot;atomic/longadder&quot;&gt; &lt;code&gt;LongAdder&lt;/code&gt; 의&lt;/a&gt; 값을 초기화하고 통해 &lt;a href=&quot;concurrenthashmap#computeIfAbsent-K-java.util.function.Function-&quot;&gt; &lt;code&gt;computeIfAbsent&lt;/code&gt; &lt;/a&gt; . 예를 들어 &lt;code&gt;ConcurrentHashMap&amp;lt;String,LongAdder&amp;gt; freqs&lt;/code&gt; 카운트를 추가 하려면 &lt;code&gt;freqs.computeIfAbsent(k -&amp;gt; new LongAdder()).increment();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0f5b492e5e79e1dd49d103d07a9725793440ef" translate="yes" xml:space="preserve">
          <source>A Configuration object is responsible for specifying which LoginModules should be used for a particular application, and in what order the LoginModules should be invoked.</source>
          <target state="translated">Configuration 객체는 특정 응용 프로그램에 사용해야하는 LoginModules와 LoginModules를 어떤 순서로 호출해야하는지 지정합니다.</target>
        </trans-unit>
        <trans-unit id="74d36f2b93f37113d35e86b570595f7563d7d60a" translate="yes" xml:space="preserve">
          <source>A Context instance is not guaranteed to be synchronized against concurrent access by multiple threads. Threads that need to access a single Context instance concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating a different Context instance need not synchronize. Note that the &lt;a href=&quot;context#lookup-javax.naming.Name-&quot;&gt;&lt;code&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method, when passed an empty name, will return a new Context instance representing the same naming context.</source>
          <target state="translated">컨텍스트 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않을 수 있습니다. 단일 컨텍스트 인스턴스에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다. 각각 다른 컨텍스트 인스턴스를 조작하는 여러 스레드는 동기화 할 필요가 없습니다. 점을 유의 &lt;a href=&quot;context#lookup-javax.naming.Name-&quot;&gt; &lt;code&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 방법은 빈 이름을 통과 할 때, 같은 네이밍 문맥을 나타내는 새로운 컨텍스트 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b29cc8def858a24b7c7f09750b3ab466a9bfce1" translate="yes" xml:space="preserve">
          <source>A CookieHandler object provides a callback mechanism to hook up a HTTP state management policy implementation into the HTTP protocol handler.</source>
          <target state="translated">CookieHandler 객체는 HTTP 상태 관리 정책 구현을 HTTP 프로토콜 핸들러에 연결하는 콜백 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e14cec95df0f08d9bad153498b207b612469b68" translate="yes" xml:space="preserve">
          <source>A CookieHandler object provides a callback mechanism to hook up a HTTP state management policy implementation into the HTTP protocol handler. The HTTP state management mechanism specifies a way to create a stateful session with HTTP requests and responses.</source>
          <target state="translated">CookieHandler 객체는 HTTP 상태 관리 정책 구현을 HTTP 프로토콜 핸들러에 연결하는 콜백 메커니즘을 제공합니다. HTTP 상태 관리 메커니즘은 HTTP 요청 및 응답으로 상태 저장 세션을 작성하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="79ca6a09288e0d8b71c28a349bae374ffee24a89" translate="yes" xml:space="preserve">
          <source>A CookieStore object represents a storage for cookie.</source>
          <target state="translated">CookieStore 객체는 쿠키의 스토리지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="283551993d847395f826933009f09ddcd3e07680" translate="yes" xml:space="preserve">
          <source>A CookieStore object represents a storage for cookie. Can store and retrieve cookies.</source>
          <target state="translated">CookieStore 객체는 쿠키의 스토리지를 나타냅니다. 쿠키를 저장하고 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b58e7c6e736957a773f6daa4515fd1439a70f91" translate="yes" xml:space="preserve">
          <source>A CountedCompleter that does not itself have a completer (i.e., one for which &lt;a href=&quot;countedcompleter#getCompleter--&quot;&gt;&lt;code&gt;getCompleter()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;) can be used as a regular ForkJoinTask with this added functionality. However, any completer that in turn has another completer serves only as an internal helper for other computations, so its own task status (as reported in methods such as &lt;a href=&quot;forkjointask#isDone--&quot;&gt;&lt;code&gt;ForkJoinTask.isDone()&lt;/code&gt;&lt;/a&gt;) is arbitrary; this status changes only upon explicit invocations of &lt;a href=&quot;countedcompleter#complete-T-&quot;&gt;&lt;code&gt;complete(T)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;forkjointask#cancel-boolean-&quot;&gt;&lt;code&gt;ForkJoinTask.cancel(boolean)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;forkjointask#completeExceptionally-java.lang.Throwable-&quot;&gt;&lt;code&gt;ForkJoinTask.completeExceptionally(Throwable)&lt;/code&gt;&lt;/a&gt; or upon exceptional completion of method &lt;code&gt;compute&lt;/code&gt;. Upon any exceptional completion, the exception may be relayed to a task's completer (and its completer, and so on), if one exists and it has not otherwise already completed. Similarly, cancelling an internal CountedCompleter has only a local effect on that completer, so is not often useful.</source>
          <target state="translated">자체가 완전하지 않은 CountedCompleter (즉, &lt;a href=&quot;countedcompleter#getCompleter--&quot;&gt; &lt;code&gt;getCompleter()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;null&lt;/code&gt; 을 리턴 하는 것) 는 이 추가 된 기능을 가진 일반 ForkJoinTask로 사용될 수 있습니다. 그러나 다른 완료자를 갖는 완료 자는 다른 계산을위한 내부 도우미 역할 &lt;a href=&quot;forkjointask#isDone--&quot;&gt; &lt;code&gt;ForkJoinTask.isDone()&lt;/code&gt; &lt;/a&gt; 때문에 자체 작업 상태 ( ForkJoinTask.isDone () 와 같은 메소드에보고 됨 )는 임의적입니다. 이 상태는 &lt;a href=&quot;countedcompleter#complete-T-&quot;&gt; &lt;code&gt;complete(T)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;forkjointask#cancel-boolean-&quot;&gt; &lt;code&gt;ForkJoinTask.cancel(boolean)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;forkjointask#completeExceptionally-java.lang.Throwable-&quot;&gt; &lt;code&gt;ForkJoinTask.completeExceptionally(Throwable)&lt;/code&gt; &lt;/a&gt; 명시 적 호출 또는 예외적 인 메소드 &lt;code&gt;compute&lt;/code&gt; 완료시 에만 변경됩니다. 예외적으로 완료되면 예외가 작업 완료 자 (및 완료 자 등)로 전달되고 이미 완료되지 않은 경우에는 예외가 완료 될 수 있습니다. 마찬가지로 내부 CountedCompleter를 취소하면 해당 완성기에 로컬 효과 만 있으므로 종종 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e06695bbc72ff1b5ce51b060c69b0b7a40f516e3" translate="yes" xml:space="preserve">
          <source>A DocAttributeSet is just an &lt;a href=&quot;attributeset&quot;&gt;&lt;code&gt;AttributeSet&lt;/code&gt;&lt;/a&gt; whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the DocAttributeSet must be instances of interface &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;docattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;docattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt;&lt;code&gt;addAll(AttributeSet)&lt;/code&gt;&lt;/a&gt; operations are respecified below to guarantee this additional invariant.</source>
          <target state="translated">해, DocAttributeSet 단지입니다 &lt;a href=&quot;attributeset&quot;&gt; &lt;code&gt;AttributeSet&lt;/code&gt; 에&lt;/a&gt; 그 생성자와 돌연변이의 조작 해, DocAttributeSet의 모든 속성 값은 인터페이스의 인스턴스해야합니다 즉 것을 추가 불변 보장 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; 를&lt;/a&gt; . &lt;a href=&quot;docattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;docattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt; &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; &lt;/a&gt; 작업이 추가 불변을 보장하기 위해 아래 respecified된다.</target>
        </trans-unit>
        <trans-unit id="dca67a6c4e0325cfb67cd9c03877cb0ceaed02e9" translate="yes" xml:space="preserve">
          <source>A Filter can be used to provide fine grain control over what is logged, beyond the control provided by log levels.</source>
          <target state="translated">필터를 사용하면 로그 수준에서 제공하는 제어를 넘어서 기록 된 내용을 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb63af3753ed032809d47c9dac0e904126fcbc0" translate="yes" xml:space="preserve">
          <source>A Format</source>
          <target state="translated">형식</target>
        </trans-unit>
        <trans-unit id="bbcc0a1f7b91d484f43961c41f2b9e4a4e5bee04" translate="yes" xml:space="preserve">
          <source>A Formatter provides support for formatting LogRecords.</source>
          <target state="translated">포맷터는 LogRecord의 포맷을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3608d52e4dbd328bc721e5e2b9946b7f8c5348fb" translate="yes" xml:space="preserve">
          <source>A Future representing the result of the operation</source>
          <target state="translated">작업 결과를 나타내는 미래</target>
        </trans-unit>
        <trans-unit id="457cb135519bf29ef81b844625f7d44dfa89268c" translate="yes" xml:space="preserve">
          <source>A Graphic Control Extension block is written to the output stream only if image metadata containing a GraphicControlExtension element is supplied to the writer, or no image metadata is supplied and the local color table generated from the image requires a transparent index. Application, Plain Text, and Comment Extension blocks are written only if they are supplied to the writer via image metadata.</source>
          <target state="translated">GraphicControlExtension 요소를 포함하는 이미지 메타 데이터가 기록기에 제공되거나 이미지 메타 데이터가 제공되지 않고 이미지에서 생성 된 로컬 색상 표에 투명한 인덱스가 필요한 경우에만 그래픽 제어 확장 블록이 출력 스트림에 기록됩니다. 응용 프로그램, 일반 텍스트 및 주석 확장명 블록은 이미지 메타 데이터를 통해 기록기에 제공되는 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="af50eb5591ce520db7166060578eb5119637a841" translate="yes" xml:space="preserve">
          <source>A GuardedObject encapsulates a target object and a Guard object, such that access to the target object is possible only if the Guard object allows it. Once an object is encapsulated by a GuardedObject, access to that object is controlled by the &lt;code&gt;getObject&lt;/code&gt; method, which invokes the &lt;code&gt;checkGuard&lt;/code&gt; method on the Guard object that is guarding access. If access is not allowed, an exception is thrown.</source>
          <target state="translated">GuardedObject는 대상 개체와 Guard 개체를 캡슐화하여 Guard 개체가 허용하는 경우에만 대상 개체에 액세스 할 수 있도록합니다. GuardedObject에 의해 객체가 캡슐화되면 해당 객체에 대한 액세스는 &lt;code&gt;getObject&lt;/code&gt; 메소드에 의해 제어되며, 액세스를 보호하는 Guard 객체 에서 &lt;code&gt;checkGuard&lt;/code&gt; 메소드 를 호출합니다 . 액세스가 허용되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d2351b4772e9dd16b7c18f880f43463fbe76dff" translate="yes" xml:space="preserve">
          <source>A GuardedObject is an object that is used to protect access to another object.</source>
          <target state="translated">GuardedObject는 다른 개체에 대한 액세스를 보호하는 데 사용되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="a8cab0413a630393329d2147838049ef36d1f63c" translate="yes" xml:space="preserve">
          <source>A High Level API</source>
          <target state="translated">고급 API</target>
        </trans-unit>
        <trans-unit id="ff73ce0cbe8e77a9a813ec78bb01ad5e71852504" translate="yes" xml:space="preserve">
          <source>A JMX API connector server that creates RMI-based connections from remote clients.</source>
          <target state="translated">원격 클라이언트에서 RMI 기반 연결을 작성하는 JMX API 커넥터 서버.</target>
        </trans-unit>
        <trans-unit id="ae6c98f065b6700b78cceaae125cd30aa4ee675a" translate="yes" xml:space="preserve">
          <source>A JMX API connector server that creates RMI-based connections from remote clients. Usually, such connector servers are made using &lt;a href=&quot;../jmxconnectorserverfactory&quot;&gt;&lt;code&gt;JMXConnectorServerFactory&lt;/code&gt;&lt;/a&gt;. However, specialized applications can use this class directly, for example with an &lt;a href=&quot;rmiserverimpl&quot;&gt;&lt;code&gt;RMIServerImpl&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">원격 클라이언트에서 RMI 기반 연결을 작성하는 JMX API 커넥터 서버. 일반적으로 이러한 커넥터 서버는 &lt;a href=&quot;../jmxconnectorserverfactory&quot;&gt; &lt;code&gt;JMXConnectorServerFactory&lt;/code&gt; 를&lt;/a&gt; 사용하여 작성됩니다 . 그러나 특수 응용 프로그램은이 클래스를 &lt;a href=&quot;rmiserverimpl&quot;&gt; &lt;code&gt;RMIServerImpl&lt;/code&gt; &lt;/a&gt; 객체 와 같이 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7e6c2614e2f71adc4152c814a2dce219bcaa2a4" translate="yes" xml:space="preserve">
          <source>A Jar directory</source>
          <target state="translated">Jar 디렉토리</target>
        </trans-unit>
        <trans-unit id="6dc19b4c0c9bf7e2c340017f908ce07b36d720a9" translate="yes" xml:space="preserve">
          <source>A Jar entry</source>
          <target state="translated">항아리 항목</target>
        </trans-unit>
        <trans-unit id="33f576854d1202217500a73131dc51de90b4477a" translate="yes" xml:space="preserve">
          <source>A Jar file</source>
          <target state="translated">Jar 파일</target>
        </trans-unit>
        <trans-unit id="1da6827faf9d07ac2f0b35aead3537d4219ce887" translate="yes" xml:space="preserve">
          <source>A Java Print Service instance is allowed to support any other doc flavors (or none) in addition to the above mandatory ones, at the implementation's choice.</source>
          <target state="translated">Java Print Service 인스턴스는, 구현의 선택에 의해, 위의 필수의 것 외에, 다른 doc 플레이버를 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66aee2d7211302980680b8958d4f89d8a39a52b" translate="yes" xml:space="preserve">
          <source>A Java Print Service instance is not &lt;b&gt;&lt;i&gt;required&lt;/i&gt;&lt;/b&gt; to support the following print data formats and print data representation classes. In fact, a developer using this class should &lt;b&gt;never&lt;/b&gt; assume that a particular print service supports the document types corresponding to these pre-defined doc flavors. Always query the print service to determine what doc flavors it supports. However, developers who have print services that support these doc flavors are encouraged to refer to the predefined singleton instances created here.</source>
          <target state="translated">다음 인쇄 데이터 형식 및 인쇄 데이터 표현 클래스를 지원하기 위해 Java 인쇄 서비스 인스턴스가 &lt;b&gt;&lt;i&gt;필요&lt;/i&gt;&lt;/b&gt; 하지 않습니다 . 실제로이 클래스를 사용하는 개발자 는 특정 인쇄 서비스가 이러한 사전 정의 된 문서 종류에 해당하는 문서 유형을 지원한다고 가정 해서는 &lt;b&gt;안됩니다&lt;/b&gt; . 지원하는 doc 플레이버를 결정하려면 항상 인쇄 서비스에 문의하십시오. 그러나 이러한 문서 형태를 지원하는 인쇄 서비스를 보유한 개발자는 여기에서 생성 된 사전 정의 된 싱글 톤 인스턴스를 참조하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8d892ffdda46a2fc60c6a1d8a7c68c1f25ce0467" translate="yes" xml:space="preserve">
          <source>A Java class can implement this interface to indicate how it is to be converted into a &lt;code&gt;CompositeData&lt;/code&gt; by the MXBean framework.</source>
          <target state="translated">Java 클래스는이 인터페이스를 구현 하여 MXBean 프레임 워크 에서 &lt;code&gt;CompositeData&lt;/code&gt; 로 변환하는 방법을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6edf0111df61af6dbdeb9ee50bfaf78d76b3ee69" translate="yes" xml:space="preserve">
          <source>A Java method call expression naming &lt;code&gt;invokeExact&lt;/code&gt; or &lt;code&gt;invoke&lt;/code&gt; can invoke a method handle from Java source code. From the viewpoint of source code, these methods can take any arguments and their result can be cast to any return type. Formally this is accomplished by giving the invoker methods &lt;code&gt;Object&lt;/code&gt; return types and variable arity &lt;code&gt;Object&lt;/code&gt; arguments, but they have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt; which connects this freedom of invocation directly to the JVM execution stack.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 또는 &lt;code&gt;invoke&lt;/code&gt; 라는 Java 메소드 호출 표현식 은 Java 소스 코드에서 메소드 핸들을 호출 할 수 있습니다. 소스 코드의 관점에서 이러한 메소드는 인수를 사용할 수 있으며 결과는 모든 리턴 유형으로 캐스트 될 수 있습니다. 공식적으로 이것은 호출자 메소드 &lt;code&gt;Object&lt;/code&gt; 리턴 유형 및 변수 arity &lt;code&gt;Object&lt;/code&gt; 인수 를 제공하여 수행 되지만, 이러한 호출의 자유를 JVM 실행 스택에 직접 연결하는 &lt;em&gt;시그니처 다형성&lt;/em&gt; 이라는 추가 품질 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e91acafe8fe67ec2c2ccabb641a8ae3f696d06" translate="yes" xml:space="preserve">
          <source>A Java object cannot be registered in the MBeanServer unless it is a JMX compliant MBean. By instantiating a RequiredModelMBean, resources are guaranteed that the MBean is valid. MBeanException and RuntimeOperationsException must be thrown on every public method. This allows for wrapping exceptions from distributed communications (RMI, EJB, etc.)</source>
          <target state="translated">JMX 호환 MBean이 아닌 경우 MBeanServer에 Java 오브젝트를 등록 할 수 없습니다. RequiredModelMBean을 인스턴스화함으로써 자원은 MBean이 유효 함을 보장합니다. 모든 공용 메소드에서 MBeanException 및 RuntimeOperationsException이 발생해야합니다. 이를 통해 분산 통신 (RMI, EJB 등)의 예외를 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c03aa680d8c3910bd52a6133e2ef98635461ef" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the following management interfaces:</source>
          <target state="translated">Java 가상 머신에는 다음 관리 인터페이스의 단일 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c8f67671b8966ac11b075966365897c84518be" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getClassLoadingMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getClassLoadingMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getClassLoadingMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getClassLoadingMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="347e8813cc60d56413338a44f31ad5ee9c2fa302" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getCompilationMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getCompilationMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getCompilationMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getCompilationMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="5fa8db4ab567a59fc5f60ec01c6e824fe7c05a22" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getMemoryMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getMemoryMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getMemoryMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getMemoryMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="67d5e334705bccf69af8d75f22e7f727e30e55d9" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getOperatingSystemMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getOperatingSystemMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getOperatingSystemMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getOperatingSystemMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="afc0758b2e4f293302644dac2a4656ff98d653c2" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getRuntimeMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getRuntimeMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getRuntimeMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getRuntimeMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="cde8a42465b0560c9bd42d46d1f0eabb338a9d89" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has a single instance of the implementation class of this interface. This instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getThreadMXBean--&quot;&gt;&lt;code&gt;ManagementFactory.getThreadMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 단일 인스턴스가 있습니다. 이 인터페이스를 구현하는이 인스턴스 는 &lt;a href=&quot;managementfactory#getThreadMXBean--&quot;&gt; &lt;code&gt;ManagementFactory.getThreadMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="5cdd50ff313fa53fb85c54c49e1ba0d35d26a61b" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has one or more instances of the implementation class of this interface. An instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getMemoryPoolMXBeans--&quot;&gt;&lt;code&gt;ManagementFactory.getMemoryPoolMXBeans()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스 인스턴스가 하나 이상 있습니다. 이 인터페이스를 구현하는 인스턴스 는 &lt;a href=&quot;managementfactory#getMemoryPoolMXBeans--&quot;&gt; &lt;code&gt;ManagementFactory.getMemoryPoolMXBeans()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="8a6b48dc53a0805d7177ee1ae5c3d1d720dd2b4d" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has one or more memory managers. An instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getMemoryManagerMXBeans--&quot;&gt;&lt;code&gt;ManagementFactory.getMemoryManagerMXBeans()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는 하나 이상의 메모리 관리자가 있습니다. 이 인터페이스를 구현하는 인스턴스 는 &lt;a href=&quot;managementfactory#getMemoryManagerMXBeans--&quot;&gt; &lt;code&gt;ManagementFactory.getMemoryManagerMXBeans()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7690649d409fc24f67e4adade638be6ff2f11b9b" translate="yes" xml:space="preserve">
          <source>A Java virtual machine has zero or a single instance of the following management interfaces.</source>
          <target state="translated">Java 가상 머신에는 다음 관리 인터페이스의 인스턴스가 없거나 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="3643080b6a5df5b46e7094eca6936cb87018df88" translate="yes" xml:space="preserve">
          <source>A Java virtual machine implementation may add its platform extension to the management interface by defining platform-dependent interfaces that extend the standard management interfaces to include platform-specific metrics and management operations. The static factory methods in the &lt;code&gt;ManagementFactory&lt;/code&gt; class will return the MXBeans with the platform extension.</source>
          <target state="translated">Java 가상 머신 구현에서는 플랫폼 별 메트릭 및 관리 작업을 포함하도록 표준 관리 인터페이스를 확장하는 플랫폼 종속 인터페이스를 정의하여 플랫폼 확장을 관리 인터페이스에 추가 할 수 있습니다. &lt;code&gt;ManagementFactory&lt;/code&gt; 클래스 의 정적 팩토리 메소드 는 플랫폼 확장이있는 MXBean을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0fdebaa2381914e0bb13323b3f7999aa8c1d3f43" translate="yes" xml:space="preserve">
          <source>A Java virtual machine implementation may not support the boot class path mechanism for the bootstrap class loader to search for class files. The &lt;a href=&quot;runtimemxbean#isBootClassPathSupported--&quot;&gt;&lt;code&gt;isBootClassPathSupported()&lt;/code&gt;&lt;/a&gt; method can be used to determine if the Java virtual machine supports this method.</source>
          <target state="translated">JVM (Java Virtual Machine) 구현은 부트 스트랩 클래스 로더가 클래스 파일을 검색하기위한 부트 클래스 경로 메커니즘을 지원하지 않을 수 있습니다. &lt;a href=&quot;runtimemxbean#isBootClassPathSupported--&quot;&gt; &lt;code&gt;isBootClassPathSupported()&lt;/code&gt; &lt;/a&gt; 메소드는 자바 가상 머신이 방법을 지원하는지 여부를 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="cbbf7263ee3ada105d25e3a25dac19fb977c0afe" translate="yes" xml:space="preserve">
          <source>A Java virtual machine implementation may support measuring the CPU time for the current thread, for any thread, or for no threads.</source>
          <target state="translated">JVM (Java Virtual Machine) 구현은 현재 스레드, 모든 스레드 또는 스레드가없는 CPU 시간 측정을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd238169eb9f786a282e184b0797c3100026965" translate="yes" xml:space="preserve">
          <source>A Java virtual machine may disable CPU time measurement by default. The &lt;a href=&quot;threadmxbean#isThreadCpuTimeEnabled--&quot;&gt;&lt;code&gt;isThreadCpuTimeEnabled()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadmxbean#setThreadCpuTimeEnabled-boolean-&quot;&gt;&lt;code&gt;setThreadCpuTimeEnabled(boolean)&lt;/code&gt;&lt;/a&gt; methods can be used to test if CPU time measurement is enabled and to enable/disable this support respectively. Enabling thread CPU measurement could be expensive in some Java virtual machine implementations.</source>
          <target state="translated">Java 가상 머신은 기본적으로 CPU 시간 측정을 비활성화 할 수 있습니다. &lt;a href=&quot;threadmxbean#isThreadCpuTimeEnabled--&quot;&gt; &lt;code&gt;isThreadCpuTimeEnabled()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;threadmxbean#setThreadCpuTimeEnabled-boolean-&quot;&gt; &lt;code&gt;setThreadCpuTimeEnabled(boolean)&lt;/code&gt; &lt;/a&gt; CPU 시간 측정이 가능하고,이 지지체를 각각 활성화 / 비활성화하는 경우, 방법은 시험에 사용될 수있다. 일부 Java 가상 머신 구현에서 스레드 CPU 측정을 사용하면 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af48488aaddcec098475db597e0b2ea17a79281" translate="yes" xml:space="preserve">
          <source>A Java virtual machine may have one or more instances of the following management interfaces.</source>
          <target state="translated">Java 가상 머신에는 다음 관리 인터페이스의 인스턴스가 하나 이상있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95203d6db041687aade0c2be196517a165b0adcb" translate="yes" xml:space="preserve">
          <source>A Java virtual machine may have one or more instances of the implementation class of this interface. An instance implementing this interface is an &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;managementfactory#getGarbageCollectorMXBeans--&quot;&gt;&lt;code&gt;ManagementFactory.getGarbageCollectorMXBeans()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신에는이 인터페이스의 구현 클래스의 인스턴스가 하나 이상있을 수 있습니다. 이 인터페이스를 구현하는 인스턴스 는 &lt;a href=&quot;managementfactory#getGarbageCollectorMXBeans--&quot;&gt; &lt;code&gt;ManagementFactory.getGarbageCollectorMXBeans()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 메소드 에서 얻을 수 있는 &lt;a href=&quot;managementfactory#MXBean&quot;&gt;MXBean&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="efb1cbd2f64596a7e895a5a7b43612a96af7c59d" translate="yes" xml:space="preserve">
          <source>A Java virtual machine performs collection usage threshold checking on a memory pool basis. This checking is enabled if the collection usage threshold is set to a positive value. If the collection usage threshold is set to zero, this checking is disabled on this memory pool. Default value is zero. The Java virtual machine performs the collection usage threshold checking at garbage collection time.</source>
          <target state="translated">Java 가상 머신은 메모리 풀 단위로 콜렉션 사용 임계 값 확인을 수행합니다. 콜렉션 사용 임계 값이 양수 값으로 설정된 경우이 점검이 사용 가능합니다. 콜렉션 사용 임계 값이 0으로 설정되면이 메모리 풀에서이 점검이 사용 불가능합니다. 기본값은 0입니다. Java 가상 머신은 가비지 콜렉션 시간에 콜렉션 사용 임계 값 점검을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a8b2b51d16e2e228fa4a5cbcce2fb6267e261d1e" translate="yes" xml:space="preserve">
          <source>A Java virtual machine performs usage threshold crossing checking on a memory pool basis at its best appropriate time, typically, at garbage collection time. Each memory pool maintains a &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;usage threshold count&lt;/code&gt;&lt;/a&gt; that will get incremented every time when the Java virtual machine detects that the memory pool usage is crossing the threshold.</source>
          <target state="translated">Java 가상 머신은 최적의 적절한 시간, 일반적으로 가비지 수집 시간에 메모리 풀 단위로 사용량 임계 값 교차 확인을 수행합니다. 각 메모리 풀 은 Java 가상 머신이 메모리 풀 사용량이 임계 값을 넘고 있음을 감지 할 때마다 증가 하는 &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt; 를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="657273352ec0c0d17b18a655ec31ad2fce7306d4" translate="yes" xml:space="preserve">
          <source>A JavaBean nested within a BeanContext, may ask that BeanContext to provide an instance of a &quot;service&quot;, based upon a reference to a Java Class object that represents that service.</source>
          <target state="translated">BeanContext 내에 중첩 된 JavaBean은 해당 서비스를 나타내는 Java 클래스 오브젝트에 대한 참조를 기반으로 BeanContext에 &quot;서비스&quot;의 인스턴스를 제공하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3abf2e9662154c3360ad9e12084989fccc02c4fc" translate="yes" xml:space="preserve">
          <source>A Kerberos JAAS login module that obtains long term secret keys from a keytab file should use this class. The login module will store an instance of this class in the private credential set of a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; during the commit phase of the authentication process.</source>
          <target state="translated">키탭 파일에서 장기 비밀 키를 얻는 Kerberos JAAS 로그인 모듈은이 클래스를 사용해야합니다. 로그인 모듈은 인증 프로세스의 커밋 단계 동안 이 클래스의 인스턴스를 &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 의 개인 자격 증명 세트에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="447d01d458e313cec32a02eaa5cecaa0a26e2112" translate="yes" xml:space="preserve">
          <source>A Kerberos service using a keytab to read secret keys should use the &lt;a href=&quot;keytab&quot;&gt;&lt;code&gt;KeyTab&lt;/code&gt;&lt;/a&gt; class, where latest keys can be read when needed.</source>
          <target state="translated">키탭을 사용하여 비밀 키를 읽는 Kerberos 서비스는 &lt;a href=&quot;keytab&quot;&gt; &lt;code&gt;KeyTab&lt;/code&gt; &lt;/a&gt; 클래스를 사용해야하며 , 필요한 경우 최신 키를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4eb7d3eddf9e5cdd73c01e702fff914c37ea87" translate="yes" xml:space="preserve">
          <source>A Key pair generator for a particular algorithm creates a public/private key pair that can be used with this algorithm. It also associates algorithm-specific parameters with each of the generated keys.</source>
          <target state="translated">특정 알고리즘의 키 페어 생성기는이 알고리즘과 함께 사용할 수있는 공개 / 개인 키 페어를 생성합니다. 또한 알고리즘 특정 매개 변수를 생성 된 각 키와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="096673ba135366e0327920d2953045ffc1a73dc8" translate="yes" xml:space="preserve">
          <source>A Key should use KeyRep as its serialized representation. Note that a serialized Key may contain sensitive information which should not be exposed in untrusted environments. See the  Security Appendix of the Serialization Specification for more information.</source>
          <target state="translated">키는 직렬화 된 표현으로 KeyRep을 사용해야합니다. 직렬화 된 키에는 신뢰할 수없는 환경에 노출되어서는 안되는 민감한 정보가 포함될 수 있습니다. 자세한 내용은 직렬화 사양의 보안 부록을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3465d18f7c958f4eeced04692ba85e06b354c9ec" translate="yes" xml:space="preserve">
          <source>A KeyAlreadyExistsException with a detail message.</source>
          <target state="translated">세부 메시지가있는 KeyAlreadyExistsException</target>
        </trans-unit>
        <trans-unit id="e37b2fbff6d8ebf1d7b8bd7d21ae02fa2e660373" translate="yes" xml:space="preserve">
          <source>A KeyAlreadyExistsException with no detail message.</source>
          <target state="translated">세부 메시지가없는 KeyAlreadyExistsException</target>
        </trans-unit>
        <trans-unit id="f9cb9d5595a420716375bdc90a99c076fa50ccbc" translate="yes" xml:space="preserve">
          <source>A Latin script character (&lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt;)</source>
          <target state="translated">라틴 문자 ( &lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3df86ed1a5c5d9a4c4287bba1036f7e47b615722" translate="yes" xml:space="preserve">
          <source>A LinkException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single LinkException instance should lock the object.</source>
          <target state="translated">LinkException 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. 단일 LinkException 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="b68abbabb6e97ad8331f3d5518e74f7c062df9f1" translate="yes" xml:space="preserve">
          <source>A LinkRef contains a single StringRefAddr, whose type is &quot;LinkAddress&quot;, and whose contents is the link name. The class name field of the Reference is that of this (LinkRef) class.</source>
          <target state="translated">LinkRef에는 유형이 &quot;LinkAddress&quot;이고 내용이 링크 이름 인 단일 StringRefAddr이 포함됩니다. 참조의 클래스 이름 필드는이 (LinkRef) 클래스의 클래스 이름 필드입니다.</target>
        </trans-unit>
        <trans-unit id="84f7678a14a9b51bae97ebf4cbbebc77f8fd09e2" translate="yes" xml:space="preserve">
          <source>A LinkRef instance is not synchronized against concurrent access by multiple threads. Threads that need to access a LinkRef instance concurrently should synchronize amongst themselves and provide the necessary locking.</source>
          <target state="translated">LinkRef 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않습니다. LinkRef 인스턴스에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a22a9eae003d2fd4d91b57b9501d9c8bd8e05f4" translate="yes" xml:space="preserve">
          <source>A Locale.</source>
          <target state="translated">로케일.</target>
        </trans-unit>
        <trans-unit id="6779005abde1a1d41736e7235a71052354ae112b" translate="yes" xml:space="preserve">
          <source>A Logger object is used to log messages for a specific system or application component.</source>
          <target state="translated">로거 개체는 특정 시스템 또는 응용 프로그램 구성 요소에 대한 메시지를 기록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c499d734d095b4b498a4bc777509de20cc1569e0" translate="yes" xml:space="preserve">
          <source>A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create &quot;anonymous&quot; Loggers that are not stored in the Logger namespace.</source>
          <target state="translated">로거 개체는 특정 시스템 또는 응용 프로그램 구성 요소에 대한 메시지를 기록하는 데 사용됩니다. 로거는 일반적으로 점으로 구분 된 계층 네임 스페이스를 사용하여 이름이 지정됩니다. 로거 이름은 임의의 문자열 일 수 있지만 일반적으로 java.net 또는 javax.swing과 같은 로그 된 구성 요소의 패키지 이름 또는 클래스 이름을 기반으로해야합니다. 또한 Logger 네임 스페이스에 저장되지 않은 &quot;익명&quot;Logger를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3004083b41f7279bccf2d376054f13365417107a" translate="yes" xml:space="preserve">
          <source>A LoginContext should not be used to authenticate more than one Subject. A separate LoginContext should be used to authenticate each different Subject.</source>
          <target state="translated">LoginContext를 사용하여 둘 이상의 주제를 인증해서는 안됩니다. 각기 다른 주제를 인증하려면 별도의 LoginContext를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d08eeb72c55f5def07e0edd5465431aea0a4bae5" translate="yes" xml:space="preserve">
          <source>A Low Level API</source>
          <target state="translated">저수준 API</target>
        </trans-unit>
        <trans-unit id="0e4bee990e5dd51f412e4e4f387a0961aa4345bb" translate="yes" xml:space="preserve">
          <source>A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, e.g., MD5 or SHA-1, in combination with a secret shared key. HMAC is specified in RFC 2104.</source>
          <target state="translated">암호화 해시 기능을 기반으로하는 MAC 메커니즘을 HMAC라고합니다. HMAC는 비밀 공유 키와 함께 모든 암호화 해시 기능 (예 : MD5 또는 SHA-1)과 함께 사용할 수 있습니다. HMAC는 RFC 2104에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23eefafff3c08d819fbb5e313f435090a8297a6" translate="yes" xml:space="preserve">
          <source>A MAC provides a way to check the integrity of information transmitted over or stored in an unreliable medium, based on a secret key. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties.</source>
          <target state="translated">MAC은 비밀 키를 기반으로 신뢰할 수없는 매체로 전송되거나 신뢰할 수없는 매체에 저장된 정보의 무결성을 검사하는 방법을 제공합니다. 일반적으로 비밀 키를 공유하는 두 당사자간에 메시지 인증 코드가 사용되어 당사자간에 전송 된 정보의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="d41c3f0b35e054811d0849376f58a811e7f00a9f" translate="yes" xml:space="preserve">
          <source>A MIDI track is an independent stream of MIDI events (time-stamped MIDI data) that can be stored along with other tracks in a standard MIDI file.</source>
          <target state="translated">MIDI 트랙은 표준 MIDI 파일에 다른 트랙과 함께 저장할 수있는 독립적 인 MIDI 이벤트 스트림 (타임 스탬프 된 MIDI 데이터)입니다.</target>
        </trans-unit>
        <trans-unit id="d2a10cf14dbd436a9cd345369966e488cc6b0cd9" translate="yes" xml:space="preserve">
          <source>A MIDI track is an independent stream of MIDI events (time-stamped MIDI data) that can be stored along with other tracks in a standard MIDI file. The MIDI specification allows only 16 channels of MIDI data, but tracks are a way to get around this limitation. A MIDI file can contain any number of tracks, each containing its own stream of up to 16 channels of MIDI data.</source>
          <target state="translated">MIDI 트랙은 표준 MIDI 파일에 다른 트랙과 함께 저장할 수있는 독립적 인 MIDI 이벤트 스트림 (타임 스탬프 된 MIDI 데이터)입니다. MIDI 사양은 16 채널의 MIDI 데이터 만 허용하지만 트랙은이 한계를 극복 할 수있는 방법입니다. MIDI 파일에는 여러 개의 트랙이 포함될 수 있으며 각 트랙에는 최대 16 개 채널의 MIDI 데이터 스트림이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f511a1ae137bb74e5a438fa8768396bf4ae4f0" translate="yes" xml:space="preserve">
          <source>A Media object is constructed with a value which represents one of the ways in which the Media attribute can be specified.</source>
          <target state="translated">Media 객체는 Media 속성을 지정할 수있는 방법 중 하나를 나타내는 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="955576c5a5581056e12e98e515200ac2a050d292" translate="yes" xml:space="preserve">
          <source>A MessageDigest object starts out initialized. The data is processed through it using the &lt;a href=&quot;messagedigest#update-byte-&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt; methods. At any point &lt;a href=&quot;messagedigest#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; can be called to reset the digest. Once all the data to be updated has been updated, one of the &lt;a href=&quot;messagedigest#digest--&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt; methods should be called to complete the hash computation.</source>
          <target state="translated">MessageDigest 객체가 초기화됩니다. 데이터는 &lt;a href=&quot;messagedigest#update-byte-&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt; 방법을 사용하여 처리됩니다 . 어떤 점에서 &lt;a href=&quot;messagedigest#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 다이제스트를 다시 호출 할 수 있습니다. 업데이트 할 모든 데이터가 업데이트 되면 해시 계산을 완료하기 위해 &lt;a href=&quot;messagedigest#digest--&quot;&gt; &lt;code&gt;digest&lt;/code&gt; &lt;/a&gt; 메서드 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="803d83c43dc480618586a553a4b522b5a0ec2e04" translate="yes" xml:space="preserve">
          <source>A MethodDescriptor describes a particular method that a Java Bean supports for external access from other components.</source>
          <target state="translated">MethodDescriptor는 Java Bean이 다른 구성 요소의 외부 액세스를 지원하는 특정 메소드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="91d72defe3fc764893ef27e5b33b5fbfd41ea16c" translate="yes" xml:space="preserve">
          <source>A Model MBean implements the &lt;a href=&quot;modelmbean&quot;&gt;&lt;code&gt;ModelMBean&lt;/code&gt;&lt;/a&gt; interface. It is a &lt;a href=&quot;../dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; whose &lt;a href=&quot;../dynamicmbean#getMBeanInfo--&quot;&gt;&lt;code&gt;getMBeanInfo&lt;/code&gt;&lt;/a&gt; method returns an object implementing &lt;a href=&quot;modelmbeaninfo&quot;&gt;&lt;code&gt;ModelMBeanInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Model MBean은 &lt;a href=&quot;modelmbean&quot;&gt; &lt;code&gt;ModelMBean&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 그것은이다 &lt;a href=&quot;../dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; 를&lt;/a&gt; 그 &lt;a href=&quot;../dynamicmbean#getMBeanInfo--&quot;&gt; &lt;code&gt;getMBeanInfo&lt;/code&gt; 메소드의&lt;/a&gt; 방법을 구현하는 객체 반환 &lt;a href=&quot;modelmbeaninfo&quot;&gt; &lt;code&gt;ModelMBeanInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fa4459bcc5c002c0889ae2582fb13f8b72d3392" translate="yes" xml:space="preserve">
          <source>A ModificationItem instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single ModificationItem instance should lock the object.</source>
          <target state="translated">ModificationItem 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. 단일 ModificationItem 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="749c912382df2f74f77f5f7b63be25733a99d8a9" translate="yes" xml:space="preserve">
          <source>A NameClassPair instance is not synchronized against concurrent access by multiple threads. Threads that need to access a NameClassPair concurrently should synchronize amongst themselves and provide the necessary locking.</source>
          <target state="translated">NameClassPair 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않습니다. NameClassPair에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e7295790c1a5d3bd815dd25f033a68bd2490d77" translate="yes" xml:space="preserve">
          <source>A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object.</source>
          <target state="translated">NamingException 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. 단일 NamingException 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="164b36b7d4fc68ee83c3981d6470a16a12b3861e" translate="yes" xml:space="preserve">
          <source>A NamingException or null if the result code indicates success.</source>
          <target state="translated">NamingException. 결과 코드가 성공을 나타내는 경우는 null</target>
        </trans-unit>
        <trans-unit id="8f45b936b6c00effd5463dc498cdf2a68178fb76" translate="yes" xml:space="preserve">
          <source>A Number representing the value of the number parsed.</source>
          <target state="translated">파싱 ​​된 숫자의 값을 나타내는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="9135000054431edfc163866d6964d598cbae6906" translate="yes" xml:space="preserve">
          <source>A PKIX &lt;code&gt;CertPathBuilder&lt;/code&gt; uses these parameters to &lt;a href=&quot;certpathbuilder#build-java.security.cert.CertPathParameters-&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;CertPath&lt;/code&gt; which has been validated according to the PKIX certification path validation algorithm.</source>
          <target state="translated">PKIX &lt;code&gt;CertPathBuilder&lt;/code&gt; 는이 매개 변수를 사용 하여 PKIX 인증 경로 유효성 검증 알고리즘에 따라 유효성이 검증 된 &lt;code&gt;CertPath&lt;/code&gt; 를 &lt;a href=&quot;certpathbuilder#build-java.security.cert.CertPathParameters-&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="1c49f7526051c142ee0dd56661e95608920ec388" translate="yes" xml:space="preserve">
          <source>A PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; uses these parameters to validate a &lt;code&gt;CertPath&lt;/code&gt; according to the PKIX certification path validation algorithm.</source>
          <target state="translated">PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; 는이 매개 변수를 사용 하여 PKIX 인증 경로 유효성 검증 알고리즘에 따라 &lt;code&gt;CertPath&lt;/code&gt; 의 유효성을 검증합니다.</target>
        </trans-unit>
        <trans-unit id="854617ae48663537c49b436fc3d7da84f4484169" translate="yes" xml:space="preserve">
          <source>A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers. The deployment applications can use &quot;Accept-Encoding=pack200-gzip&quot;. This indicates to the server that the client application desires a version of the file encoded with Pack200 and further compressed with gzip. Please refer to &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment-guide/pack200.html&quot;&gt;Java Deployment Guide&lt;/a&gt; for more details and techniques.</source>
          <target state="translated">gzip으로 압축 된 Pack200 파일은 HTTP / 1.1 웹 서버에서 호스팅 될 수 있습니다. 배포 응용 프로그램은 &quot;Accept-Encoding = pack200-gzip&quot;을 사용할 수 있습니다. 이것은 클라이언트 응용 프로그램이 Pack200으로 인코딩되고 gzip으로 추가로 압축 된 파일 버전을 원한다는 것을 서버에 나타냅니다. 를 참조하십시오 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment-guide/pack200.html&quot;&gt;자바 배포 가이드&lt;/a&gt; 자세한 내용과 기술을 위해.</target>
        </trans-unit>
        <trans-unit id="84cb7411320ac8ed87b1f652e437833252a4f096" translate="yes" xml:space="preserve">
          <source>A Permission to perform actions related to MBeanServers.</source>
          <target state="translated">MBeanServer와 관련된 조치를 수행 할 수있는 권한</target>
        </trans-unit>
        <trans-unit id="5a50af10f0548cc284f1921ca0fb4100116c9960" translate="yes" xml:space="preserve">
          <source>A Permission to perform actions related to MBeanServers. The &lt;em&gt;name&lt;/em&gt; of the permission specifies the operation requested or granted by the permission. For a granted permission, it can be &lt;code&gt;*&lt;/code&gt; to allow all of the MBeanServer operations specified below. Otherwise, for a granted or requested permission, it must be one of the following:</source>
          <target state="translated">MBeanServer와 관련된 조치를 수행 할 수있는 권한 권한 의 &lt;em&gt;이름&lt;/em&gt; 은 권한에 의해 요청되거나 부여 된 작업을 지정합니다. 부여 된 허가를 들어, 할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 이 아래의 모든 MBeanServer 오퍼레이션을 허용 할 수 있습니다. 그렇지 않으면 부여되거나 요청 된 권한에 대해 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9ba3cf2463264b9d3d582745ac8e03f1e41d35e3" translate="yes" xml:space="preserve">
          <source>A Policy object is responsible for determining whether code executing in the Java runtime environment has permission to perform a security-sensitive operation.</source>
          <target state="translated">정책 객체는 Java 런타임 환경에서 실행되는 코드에 보안에 민감한 작업을 수행 할 권한이 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="788dd3b9cb5575680ee8b91fc4a7829f040d4177" translate="yes" xml:space="preserve">
          <source>A Print Job's attribute set includes zero instances or one instance of a JobMessageFromOperator attribute, not more than one instance. A new JobMessageFromOperator attribute replaces an existing JobMessageFromOperator attribute, if any. In other words, JobMessageFromOperator is not intended to be a history log. If it wishes, the client can detect changes to a Print Job's JobMessageFromOperator attribute and maintain the client's own history log of the JobMessageFromOperator attribute values.</source>
          <target state="translated">인쇄 작업의 속성 세트에는 인스턴스가 0 개 또는 JobMessageFromOperator 속성의 인스턴스가 하나 이상 포함됩니다. 새 JobMessageFromOperator 속성이 기존 JobMessageFromOperator 속성 (있는 경우)을 대체합니다. 즉, JobMessageFromOperator는 히스토리 로그가 아닙니다. 원하는 경우 클라이언트는 인쇄 작업의 JobMessageFromOperator 속성에 대한 변경 사항을 감지하고 JobMessageFromOperator 속성 값의 클라이언트 자체 히스토리 로그를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3fbfe61d65c959def5e9c362257b887a2cb544e" translate="yes" xml:space="preserve">
          <source>A Print Service's attribute set includes zero instances or one instance of a PrinterMessageFromOperator attribute, not more than one instance. A new PrinterMessageFromOperator attribute replaces an existing PrinterMessageFromOperator attribute, if any. In other words, PrinterMessageFromOperator is not intended to be a history log. If it wishes, the client can detect changes to a Print Service's PrinterMessageFromOperator attribute and maintain the client's own history log of the PrinterMessageFromOperator attribute values.</source>
          <target state="translated">인쇄 서비스의 속성 세트에는 인스턴스가 0 개 또는 PrinterMessageFromOperator 속성의 인스턴스 하나가 포함됩니다. 새 PrinterMessageFromOperator 속성이 기존 PrinterMessageFromOperator 속성 (있는 경우)을 대체합니다. 즉, PrinterMessageFromOperator는 히스토리 로그가 아닙니다. 원하는 경우 클라이언트는 인쇄 서비스의 PrinterMessageFromOperator 속성에 대한 변경 사항을 감지하고 PrinterMessageFromOperator 속성 값의 클라이언트 자체 히스토리 로그를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00809d2345c35d6032f2b3d9c3d237d721951fd9" translate="yes" xml:space="preserve">
          <source>A PrintJobAttributeSet is just an &lt;a href=&quot;attributeset&quot;&gt;&lt;code&gt;AttributeSet&lt;/code&gt;&lt;/a&gt; whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the PrintJobAttributeSet must be instances of interface &lt;a href=&quot;printjobattribute&quot;&gt;&lt;code&gt;PrintJobAttribute&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;printjobattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;printjobattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt;&lt;code&gt;&amp;gt;addAll(AttributeSet)&lt;/code&gt;&lt;/a&gt; operations are respecified below to guarantee this additional invariant.</source>
          <target state="translated">해, PrintJobAttributeSet 단지입니다 &lt;a href=&quot;attributeset&quot;&gt; &lt;code&gt;AttributeSet&lt;/code&gt; 에&lt;/a&gt; 그 생성자와 돌연변이의 조작 해, PrintJobAttributeSet의 모든 속성 값은 인터페이스의 인스턴스해야합니다 즉 것을 추가 불변 보장 &lt;a href=&quot;printjobattribute&quot;&gt; &lt;code&gt;PrintJobAttribute&lt;/code&gt; 을&lt;/a&gt; . &lt;a href=&quot;printjobattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;printjobattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt; &lt;code&gt;&amp;gt;addAll(AttributeSet)&lt;/code&gt; &lt;/a&gt; 작업이 추가 불변을 보장하기 위해 아래 respecified된다.</target>
        </trans-unit>
        <trans-unit id="aded721603c3407f5fe76e7ae0854d15518d503d" translate="yes" xml:space="preserve">
          <source>A PrintServiceAttributeSet is just an &lt;a href=&quot;attributeset&quot;&gt;&lt;code&gt;AttributeSet&lt;/code&gt;&lt;/a&gt; whose constructors and mutating operations guarantee an additional invariant, namely that all attribute values in the PrintServiceAttributeSet must be instances of interface &lt;a href=&quot;printserviceattribute&quot;&gt;&lt;code&gt;PrintServiceAttribute&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;printserviceattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;printserviceattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt;&lt;code&gt;addAll(AttributeSet)&lt;/code&gt;&lt;/a&gt; operations are respecified below to guarantee this additional invariant.</source>
          <target state="translated">해, PrintServiceAttributeSet 단지입니다 &lt;a href=&quot;attributeset&quot;&gt; &lt;code&gt;AttributeSet&lt;/code&gt; 에&lt;/a&gt; 그 생성자와 돌연변이의 조작 해, PrintServiceAttributeSet의 모든 속성 값은 인터페이스의 인스턴스해야합니다 즉 것을 추가 불변 보장 &lt;a href=&quot;printserviceattribute&quot;&gt; &lt;code&gt;PrintServiceAttribute&lt;/code&gt; 을&lt;/a&gt; . &lt;a href=&quot;printserviceattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;printserviceattributeset#addAll-javax.print.attribute.AttributeSet-&quot;&gt; &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; &lt;/a&gt; 작업이 추가 불변을 보장하기 위해 아래 respecified된다.</target>
        </trans-unit>
        <trans-unit id="d18341003dec13cb3f1d230f871b24a6e72ee60b" translate="yes" xml:space="preserve">
          <source>A PrintServiceLookup implementor is recommended to check for the SecurityManager.checkPrintJobAccess() to deny access to untrusted code. Following this recommended policy means that untrusted code may not be able to locate any print services. Downloaded applets are the most common example of untrusted code.</source>
          <target state="translated">신뢰할 수없는 코드에 대한 액세스를 거부하려면 SecurityManager.checkPrintJobAccess ()를 확인하기 위해 PrintServiceLookup 구현자가 권장됩니다. 이 권장 정책을 따르면 신뢰할 수없는 코드가 인쇄 서비스를 찾지 못할 수 있습니다. 다운로드 된 애플릿은 신뢰할 수없는 코드의 가장 일반적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="10b040397443e35ff9a1b4b3fb6ab446d6ad464b" translate="yes" xml:space="preserve">
          <source>A PropertyChangeEvent describing the vetoed change.</source>
          <target state="translated">거부 된 변경 사항을 설명하는 PropertyChangeEvent입니다.</target>
        </trans-unit>
        <trans-unit id="ab73ff36dfb487a2f44f83849e1b4b10be50fd68" translate="yes" xml:space="preserve">
          <source>A PropertyChangeEvent will be fired after the properties are read.</source>
          <target state="translated">속성을 읽은 후 PropertyChangeEvent가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="210fdaae95a7097543fc846ccda7b63eb7c4f1e2" translate="yes" xml:space="preserve">
          <source>A PropertyDescriptor describes one property that a Java Bean exports via a pair of accessor methods.</source>
          <target state="translated">PropertyDescriptor는 Java Bean이 한 쌍의 접근 자 메소드를 통해 내보내는 하나의 특성을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1464e97af59354fbd845d53627b8278e9c59294d" translate="yes" xml:space="preserve">
          <source>A PropertyEditor class provides support for GUIs that want to allow users to edit a property value of a given type.</source>
          <target state="translated">PropertyEditor 클래스는 사용자가 주어진 유형의 특성 값을 편집 할 수있게하려는 GUI를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bc13a76e8f1c594363edc02c7a10b439d47023e5" translate="yes" xml:space="preserve">
          <source>A PropertyEditor may choose to make available a full custom Component that edits its property value. It is the responsibility of the PropertyEditor to hook itself up to its editor Component itself and to report property value changes by firing a PropertyChange event.</source>
          <target state="translated">PropertyEditor는 속성 값을 편집하는 완전한 사용자 정의 구성 요소를 제공하도록 선택할 수 있습니다. PropertyEditor는 편집기 컴포넌트 자체에 연결하고 PropertyChange 이벤트를 발생시켜 속성 값 변경을보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="44ea1cd4419c757f6d11083ec4202002c7a9e613" translate="yes" xml:space="preserve">
          <source>A PropertyEditor may chose to make available a full custom Component that edits its property value. It is the responsibility of the PropertyEditor to hook itself up to its editor Component itself and to report property value changes by firing a PropertyChange event.</source>
          <target state="translated">PropertyEditor는 속성 값을 편집하는 완전한 사용자 정의 구성 요소를 제공하도록 선택할 수 있습니다. PropertyEditor는 편집기 컴포넌트 자체에 연결하고 PropertyChange 이벤트를 발생시켜 속성 값 변경을보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f2e8c8f1f59cc189f5bb0901bb99e8d1a07215" translate="yes" xml:space="preserve">
          <source>A PropertyVetoException is thrown when a proposed change to a property represents an unacceptable value.</source>
          <target state="translated">제안 된 속성 변경이 허용 할 수없는 값을 나타내는 경우 PropertyVetoException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6df0896862f9934ca74f436ed4ffa6672430f1df" translate="yes" xml:space="preserve">
          <source>A ProtectionParameter encapsulating a CallbackHandler.</source>
          <target state="translated">CallbackHandler를 캡슐화하는 ProtectionParameter</target>
        </trans-unit>
        <trans-unit id="8d0b3b6eaa138860768bfa20636e6a955c42c7d3" translate="yes" xml:space="preserve">
          <source>A QueryExp that represents the constraint. The returned object will be serialized as an instance of the non-public class  javax.management.InQueryExp.</source>
          <target state="translated">제약 조건을 나타내는 QueryExp 리턴 된 오브젝트는 비 공용 클래스 javax.management.InQueryExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="52905c2d1fd8ebf284d91b93183febbbf5b93aa3" translate="yes" xml:space="preserve">
          <source>A Red-Black tree based &lt;a href=&quot;navigablemap&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">레드-블랙 트리 기반 &lt;a href=&quot;navigablemap&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt; 구현.</target>
        </trans-unit>
        <trans-unit id="2790240116df87dc3724e9b84e65f5cd4d285f7c" translate="yes" xml:space="preserve">
          <source>A Red-Black tree based &lt;a href=&quot;navigablemap&quot;&gt;&lt;code&gt;NavigableMap&lt;/code&gt;&lt;/a&gt; implementation. The map is sorted according to the &lt;a href=&quot;../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; of its keys, or by a &lt;a href=&quot;comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; provided at map creation time, depending on which constructor is used.</source>
          <target state="translated">레드-블랙 트리 기반 &lt;a href=&quot;navigablemap&quot;&gt; &lt;code&gt;NavigableMap&lt;/code&gt; &lt;/a&gt; 구현. 맵 은 사용 된 생성자에 따라 키 의 &lt;a href=&quot;../lang/comparable&quot;&gt;자연 순서&lt;/a&gt; 에 따라 또는 맵 생성시 제공된 &lt;a href=&quot;comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="de24db46360a144e5972237ad65900278ca0e818" translate="yes" xml:space="preserve">
          <source>A RefAddr is contained within a Reference.</source>
          <target state="translated">RefAddr은 참조 내에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="db17f35dc3353169ebcd282698b849c67f5cfba3" translate="yes" xml:space="preserve">
          <source>A Reference also contains information to assist in creating an instance of the object to which this Reference refers. It contains the class name of that object, and the class name and location of the factory to be used to create the object. The class factory location is a space-separated list of URLs representing the class path used to load the factory. When the factory class (or any class or resource upon which it depends) needs to be loaded, each URL is used (in order) to attempt to load the class.</source>
          <target state="translated">참조에는이 참조가 참조하는 객체의 인스턴스를 만드는 데 도움이되는 정보도 포함되어 있습니다. 여기에는 해당 객체의 클래스 이름과 객체를 만드는 데 사용할 팩토리의 클래스 이름 및 위치가 포함됩니다. 클래스 팩토리 위치는 팩토리를로드하는 데 사용되는 클래스 경로를 나타내는 공백으로 구분 된 URL 목록입니다. 팩토리 클래스 (또는 종속 클래스 또는 자원)를로드해야하는 경우 클래스를로드하기 위해 각 URL이 (순서대로) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8440e1f50dc257e8c791e88363c2bc8840c48660" translate="yes" xml:space="preserve">
          <source>A Reference consists of an ordered list of addresses and class information about the object being referenced. Each address in the list identifies a communications endpoint for the same conceptual object. The &quot;communications endpoint&quot; is information that indicates how to contact the object. It could be, for example, a network address, a location in memory on the local machine, another process on the same machine, etc. The order of the addresses in the list may be of significance to object factories that interpret the reference.</source>
          <target state="translated">참조는 순서가 지정된 주소 목록과 참조되는 객체에 대한 클래스 정보로 구성됩니다. 목록의 각 주소는 동일한 개념적 개체에 대한 통신 끝점을 식별합니다. &quot;통신 끝점&quot;은 개체에 연결하는 방법을 나타내는 정보입니다. 예를 들어 네트워크 주소, 로컬 시스템의 메모리 위치, 동일한 시스템의 다른 프로세스 등일 수 있습니다. 목록의 주소 순서는 참조를 해석하는 오브젝트 팩토리에 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d09a0ffc22c477d525609b2de8a150f2e3869fd" translate="yes" xml:space="preserve">
          <source>A Reference instance is not synchronized against concurrent access by multiple threads. Threads that need to access a single Reference concurrently should synchronize amongst themselves and provide the necessary locking.</source>
          <target state="translated">참조 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않습니다. 단일 참조에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6db43dcfd60566c1dccf7a3e8ecca2a4da050eb1" translate="yes" xml:space="preserve">
          <source>A Reference represents a way of recording address information about objects which themselves are not directly bound to the naming system. Such objects can implement the Referenceable interface as a way for programs that use that object to determine what its Reference is. For example, when binding a object, if an object implements the Referenceable interface, getReference() can be invoked on the object to get its Reference to use for binding.</source>
          <target state="translated">참조는 이름 지정 시스템에 직접 바인딩되지 않은 객체에 대한 주소 정보를 기록하는 방법을 나타냅니다. 이러한 오브젝트는 해당 오브젝트를 사용하는 프로그램이 참조가 무엇인지 판별하는 방법으로 참조 가능 인터페이스를 구현할 수 있습니다. 예를 들어, 객체를 바인딩 할 때 객체가 Referenceable 인터페이스를 구현하는 경우 객체에서 getReference ()를 호출하여 바인딩에 사용할 Reference를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4264db3c7ee124c340e610e7ebefdc1a8451fa89" translate="yes" xml:space="preserve">
          <source>A RelationNotification notification is sent, its type being:</source>
          <target state="translated">RelationNotification 알림이 전송되며 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ac61035063a73b282ef8ef40f44e455f0e65bf7" translate="yes" xml:space="preserve">
          <source>A RelationNotification, with type RELATION_BASIC_CREATION, is sent.</source>
          <target state="translated">유형이 RELATION_BASIC_CREATION 인 RelationNotification이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9bfca27e3cf3e160da5442cef2903f856d3a0a9d" translate="yes" xml:space="preserve">
          <source>A RelationSupport object is used internally by the Relation Service to represent simple relations (only roles, no properties or methods), with an unlimited number of roles, of any relation type.</source>
          <target state="translated">RelationSupport 오브젝트는 관계 서비스에 의해 내부적으로 사용되어 모든 관계 유형의 역할 수에 제한이없는 단순한 관계 (역할 또는 특성이없는 역할 만)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2b5afc0ac78c2cf646952eec6da6199ce1326de0" translate="yes" xml:space="preserve">
          <source>A RelationSupport object is used internally by the Relation Service to represent simple relations (only roles, no properties or methods), with an unlimited number of roles, of any relation type. As internal representation, it is not exposed to the user.</source>
          <target state="translated">RelationSupport 오브젝트는 관계 서비스에 의해 내부적으로 사용되어 모든 관계 유형의 역할 수에 제한이없는 단순한 관계 (역할 또는 특성이없는 역할 만)를 나타냅니다. 내부 표현으로는 사용자에게 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b629caa896430c731614690866acaa67f23a1984" translate="yes" xml:space="preserve">
          <source>A RelationTypeSupport object implements the RelationType interface.</source>
          <target state="translated">RelationTypeSupport 객체는 RelationType 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="93cdea27087d9b8a8a0a537fb17f4e431c836a31" translate="yes" xml:space="preserve">
          <source>A ResolveResult instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single ResolveResult instance should lock the object.</source>
          <target state="translated">ResolveResult 인스턴스는 동시 다중 스레드 액세스와 동기화되지 않습니다. 단일 ResolveResult 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="d6ace36ae9882cf1b5bf51c8fccd0fb9fe4684da" translate="yes" xml:space="preserve">
          <source>A Retention meta-annotation has effect only if the meta-annotated type is used directly for annotation. It has no effect if the meta-annotated type is used as a member type in another annotation type.</source>
          <target state="translated">보존 메타 주석은 메타 주석 유형이 주석에 직접 사용되는 경우에만 적용됩니다. 메타 주석 유형이 다른 주석 유형의 멤버 유형으로 사용되는 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed104d8e87a3d8da6b36e28ccb0aec3193af8db7" translate="yes" xml:space="preserve">
          <source>A RoleInfo object summarises a role in a relation type.</source>
          <target state="translated">RoleInfo 객체는 관계 유형의 역할을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="ec0a32da937a776c1063eab47ab7ca3cd55d6864" translate="yes" xml:space="preserve">
          <source>A RoleList represents a list of roles (Role objects).</source>
          <target state="translated">RoleList는 역할 (역할 객체) 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="791805f3afacc64ffc2d229168541451185927aa" translate="yes" xml:space="preserve">
          <source>A RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.</source>
          <target state="translated">RoleList는 역할 (역할 객체) 목록을 나타냅니다. 관계를 작성할 때 및 관계에서 여러 역할을 설정하려고 할 때 ( 'setRoles ()'메소드를 통해) 매개 변수로 사용됩니다. 성공적으로 검색된 역할을 제공하기 위해 RoleResult의 일부로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="777446281cfb44efc3a7765d7980e9e852336293" translate="yes" xml:space="preserve">
          <source>A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write) the roles.</source>
          <target state="translated">RoleUnresolvedList는 역할에 액세스 (읽기 또는 쓰기) 할 때 발생하는 문제로 인해 관계에서 검색되지 않은 역할을 나타내는 RoleUnresolved 객체 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbe07bcb178ca907bd1ca81ab707c31bcf66f7a6" translate="yes" xml:space="preserve">
          <source>A SSL socket must choose to operate in the client or server mode. This will determine who begins the handshaking process, as well as which messages should be sent by each party. Each connection must have one client and one server, or handshaking will not progress properly. Once the initial handshaking has started, a socket can not switch between client and server modes, even when performing renegotiations.</source>
          <target state="translated">SSL 소켓은 클라이언트 또는 서버 모드에서 작동하도록 선택해야합니다. 그러면 핸드 셰이 킹 프로세스를 시작한 사람과 각 당사자가 어떤 메시지를 보내야하는지 결정됩니다. 각 연결에는 하나의 클라이언트와 하나의 서버가 있어야합니다. 그렇지 않으면 핸드 쉐이킹이 제대로 진행되지 않습니다. 초기 핸드 쉐이킹이 시작되면 소켓은 재협상을 수행하더라도 클라이언트와 서버 모드간에 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbb4f8e610bbe24f131ded77d36352e5f9cdd1df" translate="yes" xml:space="preserve">
          <source>A SearchControls instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single SearchControls instance should lock the object.</source>
          <target state="translated">SearchControls 인스턴스는 동시 멀티 스레드 액세스와 동기화되지 않습니다. 단일 SearchControls 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="1679714a37191663024ae5020a1a32e147d2158f" translate="yes" xml:space="preserve">
          <source>A SearchResult instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single SearchResult instance should lock the object.</source>
          <target state="translated">SearchResult 인스턴스는 동시 멀티 스레드 액세스와 동기화되지 않습니다. 단일 SearchResult 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="29f771aa9fe09756354550c2ac62170658a3b899" translate="yes" xml:space="preserve">
          <source>A ServicePermission contains a service principal name and a list of actions which specify the context the credential can be used within.</source>
          <target state="translated">ServicePermission에는 서비스 사용자 이름과 자격 증명을 사용할 수있는 컨텍스트를 지정하는 작업 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ba48579f134d97906faffaf9f6e57bf973f9875" translate="yes" xml:space="preserve">
          <source>A Set-Cookie2 from request-host example for Domain=.local will be accepted, because the effective host name for the request- host is example.local, and example.local domain-matches .local.</source>
          <target state="translated">요청 호스트의 유효 호스트 이름은 example.local이고 example.local domain-matches는 .local이므로 Domain = .local에 대한 요청 호스트 예제의 Set-Cookie2가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6895bf828873767919772735d8c4d1094678e223" translate="yes" xml:space="preserve">
          <source>A Set-Cookie2 from request-host x.foo.com for Domain=.foo.com would be accepted.</source>
          <target state="translated">Domain = .foo.com에 대한 요청 호스트 x.foo.com의 Set-Cookie2가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f2144bbbd723933bf48da180bed425d06939a0b" translate="yes" xml:space="preserve">
          <source>A Set-Cookie2 from request-host y.x.foo.com for Domain=.foo.com would be rejected, because H is y.x and contains a dot.</source>
          <target state="translated">H는 yx이고 점이 포함되어 있기 때문에 Domain = .foo.com에 대한 요청 호스트 yxfoo.com의 Set-Cookie2는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb58c1fb8b4e8eee8655028b90b8e904f3c7f2e" translate="yes" xml:space="preserve">
          <source>A Set-Cookie2 with Domain=.com or Domain=.com., will always be rejected, because there is no embedded dot.</source>
          <target state="translated">Domain = .com 또는 Domain = .com. 인 Set-Cookie2는 포함 된 점이 없으므로 항상 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b858838aeabfa1457392741cd815a016065affc6" translate="yes" xml:space="preserve">
          <source>A Signature object can be used to generate and verify digital signatures.</source>
          <target state="translated">서명 개체를 사용하여 디지털 서명을 생성하고 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6248ef2d830cf1c3f13c7471c9dc229c171552bb" translate="yes" xml:space="preserve">
          <source>A Spliterator also reports a set of &lt;a href=&quot;spliterator#characteristics--&quot;&gt;&lt;code&gt;characteristics()&lt;/code&gt;&lt;/a&gt; of its structure, source, and elements from among &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#DISTINCT&quot;&gt;&lt;code&gt;DISTINCT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;SORTED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#NONNULL&quot;&gt;&lt;code&gt;NONNULL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt;&lt;code&gt;IMMUTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#CONCURRENT&quot;&gt;&lt;code&gt;CONCURRENT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;SUBSIZED&lt;/code&gt;&lt;/a&gt;. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; would report &lt;code&gt;SIZED&lt;/code&gt;, a Spliterator for a &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; would report &lt;code&gt;DISTINCT&lt;/code&gt;, and a Spliterator for a &lt;a href=&quot;sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; would also report &lt;code&gt;SORTED&lt;/code&gt;. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if &lt;code&gt;ORDERED&lt;/code&gt;, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values.</source>
          <target state="translated">Spliterator 또한 집합보고 &lt;a href=&quot;spliterator#characteristics--&quot;&gt; &lt;code&gt;characteristics()&lt;/code&gt; &lt;/a&gt; 구조, 소스, 그리고 요소들 중 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#DISTINCT&quot;&gt; &lt;code&gt;DISTINCT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;SORTED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;SIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#NONNULL&quot;&gt; &lt;code&gt;NONNULL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt; &lt;code&gt;IMMUTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#CONCURRENT&quot;&gt; &lt;code&gt;CONCURRENT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;SUBSIZED&lt;/code&gt; &lt;/a&gt; . 이는 Spliterator 클라이언트가 계산을 제어, 전문화 또는 단순화하기 위해 사용할 수 있습니다. 예를 들어,에 대한 Spliterator &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 보고 할 것 &lt;code&gt;SIZED&lt;/code&gt; 에 대한 Spliterator, &lt;a href=&quot;set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 보고 할 &lt;code&gt;DISTINCT&lt;/code&gt; , 그리고에 대한 Spliterator &lt;a href=&quot;sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; &lt;/a&gt; 도보고 할 것 &lt;code&gt;SORTED&lt;/code&gt; 을. 특성은 단순 통합 비트 세트로보고됩니다. 일부 특성은 메소드 작동을 추가로 제한합니다. 예를 들어 &lt;code&gt;ORDERED&lt;/code&gt; 인 경우 순회 메소드는 문서화 된 순서를 준수해야합니다. 미래에 새로운 특성이 정의 될 수 있으므로 구현자는 목록에없는 값에 의미를 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f6a0c6465be108c334cf628409a3ad690f8f7b" translate="yes" xml:space="preserve">
          <source>A Spliterator may also partition off some of its elements (using &lt;a href=&quot;spliterator#trySplit--&quot;&gt;&lt;code&gt;trySplit()&lt;/code&gt;&lt;/a&gt;) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.</source>
          <target state="translated">Spliterator는 &lt;a href=&quot;spliterator#trySplit--&quot;&gt; &lt;code&gt;trySplit()&lt;/code&gt; &lt;/a&gt; 사용하여 일부 요소 를 다른 Spliterator로 분할하여 병렬 작업에 사용할 수 있습니다. 분할이 불가능하거나 불균형 또는 비효율적 인 방식으로 분할기를 사용하는 작업은 병렬 처리의 이점을 얻지 못할 수 있습니다. 순회 및 분할 배기 요소; 각 Spliterator는 단일 벌크 계산에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9e6ecfecbfb5711aba7a9b40c9f235874d4a36ff" translate="yes" xml:space="preserve">
          <source>A Spliterator may traverse elements individually (&lt;a href=&quot;spliterator#tryAdvance-java.util.function.Consumer-&quot;&gt;&lt;code&gt;tryAdvance()&lt;/code&gt;&lt;/a&gt;) or sequentially in bulk (&lt;a href=&quot;spliterator#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;forEachRemaining()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Spliterator는 요소를 개별적으로 ( &lt;a href=&quot;spliterator#tryAdvance-java.util.function.Consumer-&quot;&gt; &lt;code&gt;tryAdvance()&lt;/code&gt; &lt;/a&gt; ) 또는 순차적으로 일괄 적으로 ( &lt;a href=&quot;spliterator#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;forEachRemaining()&lt;/code&gt; &lt;/a&gt; ) 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7d4efb72039f9c4f8f7a5d8d0153ab18c6bbe28" translate="yes" xml:space="preserve">
          <source>A Spliterator specialized for &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값에 특화된 Spliterator입니다 .</target>
        </trans-unit>
        <trans-unit id="ee9833694647b182022aea939627acec11e77f90" translate="yes" xml:space="preserve">
          <source>A Spliterator specialized for &lt;code&gt;int&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값에 특화된 Spliterator입니다 .</target>
        </trans-unit>
        <trans-unit id="d75cf90e20587284a83f9f86eeabb428d03d4edb" translate="yes" xml:space="preserve">
          <source>A Spliterator specialized for &lt;code&gt;long&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 값에 특화된 스플리터입니다 .</target>
        </trans-unit>
        <trans-unit id="67268317020c1926976403229b9b1887973879f6" translate="yes" xml:space="preserve">
          <source>A Spliterator specialized for primitive values.</source>
          <target state="translated">프리미티브 값에 특화된 스플리터.</target>
        </trans-unit>
        <trans-unit id="ca86126b3a78cfaba2bff794833a4eed9c92e384" translate="yes" xml:space="preserve">
          <source>A Spliterator that does not report &lt;code&gt;SIZED&lt;/code&gt; as required by &lt;code&gt;SUBSIZED&lt;/code&gt; is inconsistent and no guarantees can be made about any computation using that Spliterator.</source>
          <target state="translated">보고하지 않는 Spliterator &lt;code&gt;SIZED&lt;/code&gt; 에서 요구하는 &lt;code&gt;SUBSIZED&lt;/code&gt; 은 일관성이없고 보장 Spliterator 것을 사용하는 계산에 대해 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3d62906e8da82ee77e8b2f4c0973f7fd498db04" translate="yes" xml:space="preserve">
          <source>A Spliterator that reports &lt;code&gt;SORTED&lt;/code&gt; must also report &lt;code&gt;ORDERED&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SORTED&lt;/code&gt; 를보고하는 Spliterator는 &lt;code&gt;ORDERED&lt;/code&gt; 도보고 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="05ee8b03530406302bf575aa5044154d110cfecb" translate="yes" xml:space="preserve">
          <source>A Stream Protocol Version.</source>
          <target state="translated">스트림 프로토콜 버전.</target>
        </trans-unit>
        <trans-unit id="d8cf2e470f091b5c07da8eea4c11ca61ccf46934" translate="yes" xml:space="preserve">
          <source>A String consisting of the ObjectNames separated by newlines (\n).</source>
          <target state="translated">개행 (\ n)으로 구분 된 ObjectName으로 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a69696403e137dac0fd6dabe54afedd9ef18c862" translate="yes" xml:space="preserve">
          <source>A String containing the contents of the line, not including any &lt;a href=&quot;#lt&quot;&gt;line termination characters&lt;/a&gt;, or &lt;code&gt;null&lt;/code&gt; if the end of the stream has been reached</source>
          <target state="translated">&lt;a href=&quot;#lt&quot;&gt;행 종료 문자를&lt;/a&gt; 포함하지 않고 행의 내용을 포함하는 문자열 또는 스트림 끝에 도달 한 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db6d1021028e3cbf16df11dca2fd2f2666ebbd60" translate="yes" xml:space="preserve">
          <source>A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached</source>
          <target state="translated">행 종료 문자를 포함하지 않고 행의 내용을 포함하는 문자열이거나 스트림의 끝에 도달 한 경우 null</target>
        </trans-unit>
        <trans-unit id="8b2bdd600c04329d16ed051f51385b7261b43223" translate="yes" xml:space="preserve">
          <source>A String containing the name of the attribute.</source>
          <target state="translated">속성 이름이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3cde810521bbbdbb0180b17cab5426000e0d4345" translate="yes" xml:space="preserve">
          <source>A String containing the resulting Base64 encoded characters</source>
          <target state="translated">결과 Base64 인코딩 문자를 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="8fe1847821681223cea518f8aa25b33656ee96f0" translate="yes" xml:space="preserve">
          <source>A String containing the type of the attribute.</source>
          <target state="translated">속성 유형을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fd57db6a7931be2d9006628a23d2fcc5acc407dc" translate="yes" xml:space="preserve">
          <source>A String identifying this object.</source>
          <target state="translated">이 객체를 식별하는 String</target>
        </trans-unit>
        <trans-unit id="08477f881587328d65b47e64452e3918f1b048f3" translate="yes" xml:space="preserve">
          <source>A String representation of this notification.</source>
          <target state="translated">이 통지의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c5ccd1cc097e027dc844e7f01ac67691287abb3b" translate="yes" xml:space="preserve">
          <source>A String representing the host operating system encoding. This will follow the conventions documented in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt; &lt;i&gt;RFC 2278: IANA Charset Registration Procedures&lt;/i&gt;&lt;/a&gt; except where historical names are returned for compatibility with previous versions of the Java platform. The value returned from method is valid only for the VM which returns it, for use in a DocFlavor. This is the charset for all the &quot;HOST&quot; pre-defined DocFlavors in the executing VM.</source>
          <target state="translated">호스트 운영 체제 인코딩을 나타내는 문자열입니다. 이는 이전 버전의 Java 플랫폼과의 호환성을 위해 히스토리 이름이 리턴되는 경우를 제외하고 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278 : IANA 문자 세트 등록 절차에&lt;/i&gt;&lt;/a&gt; 문서화 된 규칙을 따릅니다 . method에서 반환 된 값은 DocFlavor에서 사용하기 위해 VM을 반환하는 VM에만 유효합니다. 실행중인 VM에서 모든 &quot;HOST&quot;사전 정의 된 DocFlavors의 문자 집합입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="c1623ad3e0ba0f38c19e3766c7458e7310d27f8d" translate="yes" xml:space="preserve">
          <source>A SubjectDelegationPermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">SubjectDelegationPermission은 이름 ( &quot;대상 이름&quot;이라고도 함)을 포함하지만 조치 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46172656d648db0ec18759d51f5eabcbde6598f3" translate="yes" xml:space="preserve">
          <source>A URI equivalent to this URI, but whose path is in normal form</source>
          <target state="translated">이 URI에 해당하지만 경로가 정상적인 형식 인 URI</target>
        </trans-unit>
        <trans-unit id="a4305f044aa66375e2cc03aeddd3d88bf93aaf85" translate="yes" xml:space="preserve">
          <source>A URI for this file object.</source>
          <target state="translated">이 파일 객체의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="154269b7e32c514b5b1642379b1e1117058a96da" translate="yes" xml:space="preserve">
          <source>A URI is a uniform resource</source>
          <target state="translated">URI는 균일 한 자원입니다</target>
        </trans-unit>
        <trans-unit id="9367949ffb8f452862af1ba00ea6c875ca3f9707" translate="yes" xml:space="preserve">
          <source>A URI is absolute if, and only if, it has a scheme component.</source>
          <target state="translated">URI는 구성 요소가있는 경우에만 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="94345fc265e9b24959e3d1ed9134dad6dc7e8e04" translate="yes" xml:space="preserve">
          <source>A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.</source>
          <target state="translated">URI는 절대적이며 스키마 특정 부분이 슬래시 문자 ( '/')로 시작하지 않는 경우에만 불투명합니다. 불투명 한 URI에는 체계, 체계 특정 부분 및 가능하면 조각이 있습니다. 다른 모든 구성 요소는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0e3fa5f67754d2e9848e74d28feb8d7ca0cc28c" translate="yes" xml:space="preserve">
          <source>A URI whose authority field has been parsed as a server-based authority</source>
          <target state="translated">권한 필드가 서버 기반 권한으로 구문 분석 된 URI</target>
        </trans-unit>
        <trans-unit id="2fcf4a492d36b6af7584282a3e866b529a8ee186" translate="yes" xml:space="preserve">
          <source>A URL Connection to a Java ARchive (JAR) file or an entry in a JAR file.</source>
          <target state="translated">JAR (Java ARchive) 파일 또는 JAR 파일의 항목에 대한 URL 연결</target>
        </trans-unit>
        <trans-unit id="7b36cd88efa53b8fd8140df198b49bbe4ab1f7ce" translate="yes" xml:space="preserve">
          <source>A URL can optionally specify a &quot;port&quot;, which is the port number to which the TCP connection is made on the remote host machine. If the port is not specified, the default port for the protocol is used instead. For example, the default port for &lt;code&gt;http&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt;. An alternative port could be specified as:</source>
          <target state="translated">URL은 선택적으로 &quot;포트&quot;를 지정할 수 있으며, 이는 원격 호스트 시스템에서 TCP 연결이 수행되는 포트 번호입니다. 포트를 지정하지 않으면 프로토콜의 기본 포트가 대신 사용됩니다. 예를 들어 &lt;code&gt;http&lt;/code&gt; 의 기본 포트 는 &lt;code&gt;80&lt;/code&gt; 입니다. 대체 포트는 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa5301852c56aba73f775bfa7a5b22d2603450d5" translate="yes" xml:space="preserve">
          <source>A URL connection can be used for input and/or output. Set the DoInput flag to true if you intend to use the URL connection for input, false if not. The default is true.</source>
          <target state="translated">입력 및 / 또는 출력에 URL 연결을 사용할 수 있습니다. 입력에 URL 연결을 사용하려면 DoInput 플래그를 true로 설정하고, 그렇지 않으면 false를 설정하십시오. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="5244de89744fc5c25c418eba65578cda558ff54b" translate="yes" xml:space="preserve">
          <source>A URL connection can be used for input and/or output. Set the DoOutput flag to true if you intend to use the URL connection for output, false if not. The default is false.</source>
          <target state="translated">입력 및 / 또는 출력에 URL 연결을 사용할 수 있습니다. 출력에 URL 연결을 사용하려면 DoOutput 플래그를 true로 설정하고, 그렇지 않으면 false를 설정하십시오. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="766c723594f236c4538ccfb762a210a591498917" translate="yes" xml:space="preserve">
          <source>A URL connection can be used for input and/or output. Setting the &lt;code&gt;doInput&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; indicates that the application intends to read data from the URL connection.</source>
          <target state="translated">입력 및 / 또는 출력에 URL 연결을 사용할 수 있습니다. &lt;code&gt;doInput&lt;/code&gt; 플래그를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 애플리케이션이 URL 연결에서 데이터를 읽으려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1a7da67c471a96ebf79df397de1637daa0bc78b3" translate="yes" xml:space="preserve">
          <source>A URL connection can be used for input and/or output. Setting the &lt;code&gt;doOutput&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; indicates that the application intends to write data to the URL connection.</source>
          <target state="translated">입력 및 / 또는 출력에 URL 연결을 사용할 수 있습니다. &lt;code&gt;doOutput&lt;/code&gt; 플래그를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 애플리케이션이 URL 연결에 데이터를 쓰려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fbebfef446b244f3203c437b814094e77364922" translate="yes" xml:space="preserve">
          <source>A URL constructed from this URI</source>
          <target state="translated">이 URI로 구성된 URL</target>
        </trans-unit>
        <trans-unit id="9d10a2603b4e208793c8c68d9fdac790148d2841" translate="yes" xml:space="preserve">
          <source>A URL context for &lt;code&gt;name&lt;/code&gt; or the cached initial context. The result cannot be null.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 또는 캐시 된 초기 컨텍스트에 대한 URL 컨텍스트입니다 . 결과는 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35e31bbbe45e6238bb463b154a7d9ec5a91fb8b1" translate="yes" xml:space="preserve">
          <source>A URL may have appended to it a &quot;fragment&quot;, also known as a &quot;ref&quot; or a &quot;reference&quot;. The fragment is indicated by the sharp sign character &quot;#&quot; followed by more characters. For example,</source>
          <target state="translated">URL에는 &quot;조각&quot;이라고도하며 &quot;ref&quot;또는 &quot;reference&quot;라고도합니다. 조각은 날카로운 기호 문자 &quot;#&quot;다음에 더 많은 문자가 표시됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2039d67b96f857326c2ff123c85b3a8a95404175" translate="yes" xml:space="preserve">
          <source>A URL object representing the equivalent file URL</source>
          <target state="translated">동등한 파일 URL을 나타내는 URL 객체</target>
        </trans-unit>
        <trans-unit id="686d1942f27451f39cf3f8eb1804e867663d839a" translate="yes" xml:space="preserve">
          <source>A URLConnection with support for HTTP-specific features.</source>
          <target state="translated">HTTP 관련 기능을 지원하는 URLConnection입니다.</target>
        </trans-unit>
        <trans-unit id="9af20c4c1e6ff5245b9204d42ad98ee746d95004" translate="yes" xml:space="preserve">
          <source>A URLConnection with support for HTTP-specific features. See &lt;a href=&quot;http://www.w3.org/pub/WWW/Protocols/&quot;&gt; the spec &lt;/a&gt; for details.</source>
          <target state="translated">HTTP 관련 기능을 지원하는 URLConnection입니다. 자세한 내용 &lt;a href=&quot;http://www.w3.org/pub/WWW/Protocols/&quot;&gt;은 사양&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f38ebc1a2646d495dcc65b799102891c80b966a" translate="yes" xml:space="preserve">
          <source>A Unicode character can also be represented in a regular-expression by using its &lt;b&gt;Hex notation&lt;/b&gt;(hexadecimal code point value) directly as described in construct &lt;code&gt;\x{...}&lt;/code&gt;, for example a supplementary character U+2011F can be specified as &lt;code&gt;\x{2011F}&lt;/code&gt;, instead of two consecutive Unicode escape sequences of the surrogate pair &lt;code&gt;\uD840&lt;/code&gt;&lt;code&gt;\uDD1F&lt;/code&gt;.</source>
          <target state="translated">구성 &lt;code&gt;\x{...}&lt;/code&gt; 설명 된대로 16 &lt;b&gt;진 표기법&lt;/b&gt; (16 &lt;b&gt;진&lt;/b&gt; 코드 포인트 값)을 직접 사용하여 유니 코드 문자를 정규식으로 표현할 수도 있습니다. 예를 들어 보충 문자 U + 2011F는 &lt;code&gt;\x{2011F}&lt;/code&gt; 로 지정할 수 있습니다. {2011 년} , 대신 서로 게이트 쌍의 두 개의 연속 유니 코드 이스케이프 시퀀스 &lt;code&gt;\uD840&lt;/code&gt; &lt;code&gt;\uDD1F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9a3d6f9767ce3a5ff8e8a2ee12bc9bad41f8362" translate="yes" xml:space="preserve">
          <source>A ValueExp object containing the argument. The returned object will be serialized as an instance of the non-public class  javax.management.BooleanValueExp.</source>
          <target state="translated">인수가 포함 된 ValueExp 객체 리턴 된 오브젝트는 비 공용 클래스 javax.management.BooleanValueExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac069999aacbbba7fe0c87a4e7cd0b23e05b604" translate="yes" xml:space="preserve">
          <source>A ValueExp object containing the argument. The returned object will be serialized as an instance of the non-public class  javax.management.NumericValueExp.</source>
          <target state="translated">인수가 포함 된 ValueExp 객체 리턴 된 오브젝트는 비 공용 클래스 javax.management.NumericValueExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="e009f231e6128eed9dd899a26aad65683e5ff76e" translate="yes" xml:space="preserve">
          <source>A ValueExp object containing the string argument.</source>
          <target state="translated">문자열 인수를 포함하는 ValueExp 객체.</target>
        </trans-unit>
        <trans-unit id="de22c6e9990da5a49747707bdd019ef158c6a772" translate="yes" xml:space="preserve">
          <source>A ValueExp representing the difference between two arguments. The returned object will be serialized as an instance of the non-public class  javax.management.BinaryOpValueExp with an &lt;code&gt;op&lt;/code&gt; equal to &lt;a href=&quot;query#MINUS&quot;&gt;&lt;code&gt;MINUS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 인수의 차이를 나타내는 ValueExp 리턴 된 오브젝트는 &lt;code&gt;op&lt;/code&gt; 가 &lt;a href=&quot;query#MINUS&quot;&gt; &lt;code&gt;MINUS&lt;/code&gt; 인&lt;/a&gt; 비 공용 클래스 javax.management.BinaryOpValueExp의 인스턴스로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="dac970aefa6859b648a0490bbf81cfc0c56fbaf3" translate="yes" xml:space="preserve">
          <source>A ValueExp representing the product. The returned object will be serialized as an instance of the non-public class  javax.management.BinaryOpValueExp with an &lt;code&gt;op&lt;/code&gt; equal to &lt;a href=&quot;query#TIMES&quot;&gt;&lt;code&gt;TIMES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제품을 나타내는 ValueExp. 리턴 된 오브젝트는 &lt;code&gt;op&lt;/code&gt; 가 &lt;a href=&quot;query#TIMES&quot;&gt; &lt;code&gt;TIMES&lt;/code&gt; 인&lt;/a&gt; 비 공용 클래스 javax.management.BinaryOpValueExp의 인스턴스로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb2307ebe7608266981f5807bc8dca0e01ae2792" translate="yes" xml:space="preserve">
          <source>A ValueExp representing the quotient of two arguments. The returned object will be serialized as an instance of the non-public class  javax.management.BinaryOpValueExp with an &lt;code&gt;op&lt;/code&gt; equal to &lt;a href=&quot;query#DIV&quot;&gt;&lt;code&gt;DIV&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 인수의 몫을 나타내는 ValueExp 리턴 된 오브젝트는 &lt;code&gt;op&lt;/code&gt; 가 &lt;a href=&quot;query#DIV&quot;&gt; &lt;code&gt;DIV&lt;/code&gt; 인&lt;/a&gt; 비 공용 클래스 javax.management.BinaryOpValueExp의 인스턴스로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e478ed03b6fed397fd38511cec48ee079619762f" translate="yes" xml:space="preserve">
          <source>A ValueExp representing the sum or concatenation of the two arguments. The returned object will be serialized as an instance of the non-public class  javax.management.BinaryOpValueExp with an &lt;code&gt;op&lt;/code&gt; equal to &lt;a href=&quot;query#PLUS&quot;&gt;&lt;code&gt;PLUS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 인수의 합 또는 연결을 나타내는 ValueExp 리턴 된 오브젝트는 &lt;code&gt;op&lt;/code&gt; 가 &lt;a href=&quot;query#PLUS&quot;&gt; &lt;code&gt;PLUS&lt;/code&gt; 인&lt;/a&gt; 비 공용 클래스 javax.management.BinaryOpValueExp의 인스턴스로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="aac5e0222272bb261720ffcaaeeb78590ccfa9eb" translate="yes" xml:space="preserve">
          <source>A VetoableChange event gets fired whenever a bean changes a &quot;constrained&quot; property.</source>
          <target state="translated">Bean이 &quot;제한된&quot;특성을 변경할 때마다 VetoableChange 이벤트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="47e1ca5f54a2d9b2109e0fe47cb06e0eeb891d55" translate="yes" xml:space="preserve">
          <source>A VetoableChange event gets fired whenever a bean changes a &quot;constrained&quot; property. You can register a VetoableChangeListener with a source bean so as to be notified of any constrained property updates.</source>
          <target state="translated">Bean이 &quot;제한된&quot;특성을 변경할 때마다 VetoableChange 이벤트가 시작됩니다. 제한된 특성 업데이트를 통지하기 위해 소스 Bean에 VetoableChangeListener를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2aa3bd8fd31cdb2a0f7b728153dcf915cbfbbcf" translate="yes" xml:space="preserve">
          <source>A a String representation of this EventObject.</source>
          <target state="translated">이 EventObject의 String 표현입니다.</target>
        </trans-unit>
        <trans-unit id="11757ec3e3827cf92d351ba865dfed39ea1240a9" translate="yes" xml:space="preserve">
          <source>A backslash ('\') is replaced by two backslashes.</source>
          <target state="translated">백 슬래시 ( '\')는 두 개의 백 슬래시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="85a695e0a1b18958abe873386285f1bdbac52158" translate="yes" xml:space="preserve">
          <source>A base type for primitive specializations of &lt;code&gt;Iterator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 의 기본 특수화를위한 기본 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="dee3cc77f71740db72c16054028dc7ae130310d3" translate="yes" xml:space="preserve">
          <source>A base type for primitive specializations of &lt;code&gt;Iterator&lt;/code&gt;. Specialized subtypes are provided for &lt;a href=&quot;primitiveiterator.ofint&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;primitiveiterator.oflong&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;primitiveiterator.ofdouble&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 의 기본 특수화를위한 기본 유형입니다 . &lt;a href=&quot;primitiveiterator.ofint&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;primitiveiterator.oflong&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofdouble&quot;&gt; &lt;code&gt;double&lt;/code&gt; &lt;/a&gt; 값에 특수 하위 유형이 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="757c0088402967d24f23a8035cef98a04f349e45" translate="yes" xml:space="preserve">
          <source>A bean may have a default event typically applied when this bean is used.</source>
          <target state="translated">Bean은이 Bean이 사용될 때 일반적으로 적용되는 기본 이벤트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2a15aefed6017824efeac0412e782440b3a0c35" translate="yes" xml:space="preserve">
          <source>A bean may have a default property commonly updated when this bean is customized.</source>
          <target state="translated">Bean은이 Bean이 사용자 정의 될 때 일반적으로 업데이트되는 기본 특성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4648940a25187a7ad9c93ab3e21a7689feb5c6d2" translate="yes" xml:space="preserve">
          <source>A binary reference address is immutable in the sense that its fields once created, cannot be replaced. However, it is possible to access the byte array used to hold the opaque buffer. Programs are strongly recommended against changing this byte array. Changes to this byte array need to be explicitly synchronized.</source>
          <target state="translated">이진 참조 주소는 필드를 만든 후에는 바꿀 수 없다는 점에서 변경할 수 없습니다. 그러나 불투명 버퍼를 보유하는 데 사용되는 바이트 배열에 액세스 할 수 있습니다. 이 바이트 배열을 변경하지 않도록 프로그램을 강력히 권장합니다. 이 바이트 배열에 대한 변경 사항은 명시 적으로 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="28756260cab42ed3fc29c2fd2d2d202118fb38c6" translate="yes" xml:space="preserve">
          <source>A black and white only printer must not include the PagesPerMinuteColor attribute in its attribute set or service registration. If this attribute is present, then the &lt;a href=&quot;colorsupported&quot;&gt;&lt;code&gt;ColorSupported&lt;/code&gt;&lt;/a&gt; printer description attribute must also be present and have a value of SUPPORTED.</source>
          <target state="translated">흑백 전용 프린터는 속성 세트 또는 서비스 등록에 PagesPerMinuteColor 속성을 포함하지 않아야합니다. 이 속성이 있으면 &lt;a href=&quot;colorsupported&quot;&gt; &lt;code&gt;ColorSupported&lt;/code&gt; &lt;/a&gt; 프린터 설명 속성도 존재해야하며 SUPPORTED 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="53259515a896c061e25a9ed15f463634c03f56e2" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether the concrete subclass supports the standard metadata format, set via the constructor.</source>
          <target state="translated">구체적 하위 클래스가 생성자를 통해 설정된 표준 메타 데이터 형식을 지원하는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="d9477ca049b88489d2b38149a23433afe1bc4eed" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether this plug-in supports the standard metadata format for image metadata, initially &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 플러그인이 이미지 메타 데이터에 대한 표준 메타 데이터 형식을 지원하는지 여부를 나타내는 부울 (처음 &lt;code&gt;false&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="b83ab706b6e17d09a40ff25d34c822ad27c15d07" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether this plug-in supports the standard metadata format for stream metadata, initially &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 플러그인이 스트림 메타 데이터에 대한 표준 메타 데이터 형식을 지원하는지 여부를 나타내는 부울 (처음 &lt;code&gt;false&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="b39ce668b8a6a89fc32432670ce35ae52e61bcc0" translate="yes" xml:space="preserve">
          <source>A bounded &lt;a href=&quot;blockingqueue&quot;&gt;blocking queue&lt;/a&gt; backed by an array.</source>
          <target state="translated">어레이가 지원 하는 바운드 &lt;a href=&quot;blockingqueue&quot;&gt;블로킹 대기열&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62ef4090491b3f77e59b611b48659dc0dcd37310" translate="yes" xml:space="preserve">
          <source>A bounded &lt;a href=&quot;blockingqueue&quot;&gt;blocking queue&lt;/a&gt; backed by an array. This queue orders elements FIFO (first-in-first-out). The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the queue the longest time. The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.</source>
          <target state="translated">어레이가 지원 하는 바운드 &lt;a href=&quot;blockingqueue&quot;&gt;블로킹 대기열&lt;/a&gt; . 이 대기열은 FIFO (선입 선출) 요소를 주문합니다. 큐 의 &lt;em&gt;헤드&lt;/em&gt; 는 큐에 가장 오래 있었던 요소입니다. 대기열 의 &lt;em&gt;꼬리&lt;/em&gt; 는 대기열에 가장 짧은 시간에 있었던 요소입니다. 새 요소가 큐의 끝에 삽입되고 큐 검색 조작이 큐의 헤드에서 요소를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b4abeac083bd93bc54fb7b00d129de9a377831f0" translate="yes" xml:space="preserve">
          <source>A break iterator for character breaks</source>
          <target state="translated">문자 나누기를위한 나누기 반복자</target>
        </trans-unit>
        <trans-unit id="51a9a46286d79ded1086a034d58ac0c2a8978838" translate="yes" xml:space="preserve">
          <source>A break iterator for line breaks</source>
          <target state="translated">줄 바꿈을위한 나누기 반복기</target>
        </trans-unit>
        <trans-unit id="617aea254f35f926f8aa9dc19969e3dc93afda12" translate="yes" xml:space="preserve">
          <source>A break iterator for sentence breaks</source>
          <target state="translated">문장 나누기를위한 나누기 반복자</target>
        </trans-unit>
        <trans-unit id="bd76fb690012655da975ab2cbf26de08e24283dd" translate="yes" xml:space="preserve">
          <source>A break iterator for word breaks</source>
          <target state="translated">단어 나누기를위한 나누기 반복자</target>
        </trans-unit>
        <trans-unit id="7dc94e24dcfe5c7b1314267497f1ff31df1b8d99" translate="yes" xml:space="preserve">
          <source>A buffer is a linear, finite sequence of elements of a specific primitive type. Aside from its content, the essential properties of a buffer are its capacity, limit, and position:</source>
          <target state="translated">버퍼는 특정 기본 유형의 선형의 유한 요소 시퀀스입니다. 내용 외에 버퍼의 필수 속성은 용량, 한계 및 위치입니다.</target>
        </trans-unit>
        <trans-unit id="324c6bf038720a465066054397d4264a929bfa20" translate="yes" xml:space="preserve">
          <source>A buffer's</source>
          <target state="translated">버퍼</target>
        </trans-unit>
        <trans-unit id="a38d36a5171b52d9f4d2d9a4cc3e0cd798f3a0e0" translate="yes" xml:space="preserve">
          <source>A buffered character-input stream that keeps track of line numbers.</source>
          <target state="translated">행 번호를 추적하는 버퍼 된 문자 입력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="127c3edf2b5b53a296ab7ff8b00ca59e412aef0d" translate="yes" xml:space="preserve">
          <source>A buffered character-input stream that keeps track of line numbers. This class defines methods &lt;a href=&quot;linenumberreader#setLineNumber-int-&quot;&gt;&lt;code&gt;setLineNumber(int)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;linenumberreader#getLineNumber--&quot;&gt;&lt;code&gt;getLineNumber()&lt;/code&gt;&lt;/a&gt; for setting and getting the current line number respectively.</source>
          <target state="translated">행 번호를 추적하는 버퍼 된 문자 입력 스트림입니다. 이 클래스는 각각 현재 행 번호를 설정하고 가져 오기 위해 &lt;a href=&quot;linenumberreader#setLineNumber-int-&quot;&gt; &lt;code&gt;setLineNumber(int)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;linenumberreader#getLineNumber--&quot;&gt; &lt;code&gt;getLineNumber()&lt;/code&gt; &lt;/a&gt; 메소드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe1209556db202095f679c78205318316cc3c7f" translate="yes" xml:space="preserve">
          <source>A builder of &lt;a href=&quot;aclentry&quot;&gt;&lt;code&gt;AclEntry&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;aclentry&quot;&gt; &lt;code&gt;AclEntry&lt;/code&gt; &lt;/a&gt; 객체 의 빌더 .</target>
        </trans-unit>
        <trans-unit id="30c3cd71c2aa594ef9ceaa865aafe8177481a872" translate="yes" xml:space="preserve">
          <source>A byte array containing the complete message</source>
          <target state="translated">완전한 메시지를 포함하는 바이트 배열</target>
        </trans-unit>
        <trans-unit id="cbc9cc88f9018e37e4137ac516b27f389f5eccd6" translate="yes" xml:space="preserve">
          <source>A byte buffer can be allocated as a &lt;a href=&quot;bytebuffer#direct&quot;&gt; &lt;i&gt;direct&lt;/i&gt;&lt;/a&gt; buffer, in which case the Java virtual machine will make a best effort to perform native I/O operations directly upon it.</source>
          <target state="translated">바이트 버퍼는 &lt;a href=&quot;bytebuffer#direct&quot;&gt;&lt;i&gt;직접&lt;/i&gt;&lt;/a&gt; 버퍼 로 할당 될 수 있으며 ,이 경우 Java 가상 머신은 직접 네이티브 I / O 작업을 수행하기 위해 최선의 노력을 다할 것입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="3c5f814251ab0cac9e1798c421a7d52224d57054" translate="yes" xml:space="preserve">
          <source>A byte buffer can be created by &lt;a href=&quot;channels/filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt;&lt;code&gt;&lt;i&gt;mapping&lt;/i&gt;&lt;/code&gt;&lt;/a&gt; a region of a file directly into memory, in which case a few additional file-related operations defined in the &lt;a href=&quot;mappedbytebuffer&quot;&gt;&lt;code&gt;MappedByteBuffer&lt;/code&gt;&lt;/a&gt; class are available.</source>
          <target state="translated">파일 영역을 메모리에 직접 &lt;a href=&quot;channels/filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt; &lt;code&gt;&lt;i&gt;mapping&lt;/i&gt;&lt;/code&gt; &lt;/a&gt; 하여 바이트 버퍼를 만들 수 있습니다 .이 경우 &lt;a href=&quot;mappedbytebuffer&quot;&gt; &lt;code&gt;MappedByteBuffer&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 몇 가지 추가 파일 관련 작업 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae5d7e92a952c9f183b9ac23cef0349767f9c4d" translate="yes" xml:space="preserve">
          <source>A byte buffer containing the encoded characters</source>
          <target state="translated">인코딩 된 문자를 포함하는 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="2b25d877daf83d19cc13a61ba16bd3ff131bbe6a" translate="yes" xml:space="preserve">
          <source>A byte buffer is either</source>
          <target state="translated">바이트 버퍼는</target>
        </trans-unit>
        <trans-unit id="8fe357f9c74421b793e6def02c6dd8e017a504dd" translate="yes" xml:space="preserve">
          <source>A byte buffer is not comparable to any other type of object.</source>
          <target state="translated">바이트 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c8399125540b20bdb02f8e90db06eefe52cd4ac" translate="yes" xml:space="preserve">
          <source>A byte buffer is not equal to any other type of object.</source>
          <target state="translated">바이트 버퍼는 다른 유형의 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="928e7d1b2622daaff3134713be2904a81648a760" translate="yes" xml:space="preserve">
          <source>A byte buffer mapped to a file</source>
          <target state="translated">파일에 매핑 된 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="0b52ba3ab4c5d7deeda40a8723f5b43184feaa37" translate="yes" xml:space="preserve">
          <source>A byte buffer provides access to its content as either a heterogeneous or homogeneous sequence of &lt;a href=&quot;bytebuffer#bin&quot;&gt;binary data&lt;/a&gt; of any non-boolean primitive type, in either big-endian or little-endian &lt;a href=&quot;byteorder&quot;&gt;byte order&lt;/a&gt;.</source>
          <target state="translated">바이트 버퍼는 빅 엔디안 또는 리틀 엔디안 &lt;a href=&quot;byteorder&quot;&gt;바이트 순서로&lt;/a&gt; 비 부울 프리미티브 유형 의 &lt;a href=&quot;bytebuffer#bin&quot;&gt;이진&lt;/a&gt; 또는 이진 시퀀스의 이진 데이터 시퀀스로 컨텐츠에 대한 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="89b17475be8ed8b74d9824ee945925183e8c4b46" translate="yes" xml:space="preserve">
          <source>A byte buffer.</source>
          <target state="translated">바이트 버퍼.</target>
        </trans-unit>
        <trans-unit id="88bcbe82898f6c96d90acd1c56b5987f6f08ad0f" translate="yes" xml:space="preserve">
          <source>A byte channel that maintains a current</source>
          <target state="translated">전류를 유지하는 바이트 채널</target>
        </trans-unit>
        <trans-unit id="845ad2cb4762b64991c6e2d6e95d59612deaf435" translate="yes" xml:space="preserve">
          <source>A calendar system is defined by the &lt;a href=&quot;chronology&quot;&gt;&lt;code&gt;Chronology&lt;/code&gt;&lt;/a&gt; interface, while a date in a calendar system is defined by the &lt;a href=&quot;chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">달력 시스템은 &lt;a href=&quot;chronology&quot;&gt; &lt;code&gt;Chronology&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 정의되고 달력 시스템 의 날짜는 &lt;a href=&quot;chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce4b54aff35ccf9905033e61ef22da804a259a1e" translate="yes" xml:space="preserve">
          <source>A calendar system, used to organize and identify dates.</source>
          <target state="translated">날짜를 구성하고 식별하는 데 사용되는 달력 시스템.</target>
        </trans-unit>
        <trans-unit id="b8c17792b7dc5b2e841edb56de9cd4dc47f658c5" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;checkPermission&lt;/code&gt; with &lt;code&gt;java.security.AllPermission&lt;/code&gt; does not result in a SecurityException.</source>
          <target state="translated">&lt;code&gt;java.security.AllPermission&lt;/code&gt; 을 사용하여 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출 해도 SecurityException이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0153f14fc38bde22e0a2e72d882599272b17331f" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;forName(&quot;X&quot;)&lt;/code&gt; causes the class named &lt;code&gt;X&lt;/code&gt; to be initialized.</source>
          <target state="translated">의 호출 &lt;code&gt;forName(&quot;X&quot;)&lt;/code&gt; 클래스라는 이름의 원인이 &lt;code&gt;X&lt;/code&gt; 를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc6dca760accd0b2d5c4147af5d2b22b5e1ceaa" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;nn.getNumber()&lt;/code&gt; will then return &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;nn.getNumber()&lt;/code&gt; 호출하면 &lt;b&gt;5&lt;/b&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9747712d9c7476a00f6fa1bc5816c855acb2f5" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;start&lt;/code&gt; on a thread</source>
          <target state="translated">스레드 에서 &lt;code&gt;start&lt;/code&gt; 하는 호출</target>
        </trans-unit>
        <trans-unit id="a1273885f9474307edbb63fe4336b5043edf79d1" translate="yes" xml:space="preserve">
          <source>A call to plain &lt;code&gt;invoke&lt;/code&gt; works the same as a call to &lt;code&gt;invokeExact&lt;/code&gt;, if the symbolic type descriptor specified by the caller exactly matches the method handle's own type. If there is a type mismatch, &lt;code&gt;invoke&lt;/code&gt; attempts to adjust the type of the receiving method handle, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;, to obtain an exactly invokable method handle &lt;code&gt;M2&lt;/code&gt;. This allows a more powerful negotiation of method type between caller and callee.</source>
          <target state="translated">호출자가 지정한 기호 유형 설명자가 메소드 핸들의 자체 유형과 정확히 일치하는 경우 일반 &lt;code&gt;invoke&lt;/code&gt; 대한 호출은 &lt;code&gt;invokeExact&lt;/code&gt; 호출과 동일하게 작동합니다 . 형식 불일치가 있으면, &lt;code&gt;invoke&lt;/code&gt; 의 수신 방법 손잡이의 형태를 조절하는 호출하여 마치 시도 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; , 정확히 호출 가능한 메소드 핸들 수득 &lt;code&gt;M2&lt;/code&gt; 는 . 이를 통해 호출자와 수신자 사이의 메소드 유형을보다 강력하게 협상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="634085829af74ce806f9f2d387d3f5c712eaf824" translate="yes" xml:space="preserve">
          <source>A call to this method resets this &lt;code&gt;Mac&lt;/code&gt; object to the state it was in when previously initialized via a call to &lt;code&gt;init(Key)&lt;/code&gt; or &lt;code&gt;init(Key, AlgorithmParameterSpec)&lt;/code&gt;. That is, the object is reset and available to generate another MAC from the same key, if desired, via new calls to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;doFinal&lt;/code&gt;. (In order to reuse this &lt;code&gt;Mac&lt;/code&gt; object with a different key, it must be reinitialized via a call to &lt;code&gt;init(Key)&lt;/code&gt; or &lt;code&gt;init(Key, AlgorithmParameterSpec)&lt;/code&gt;.</source>
          <target state="translated">이 메소드에의 호출은,이 &lt;code&gt;Mac&lt;/code&gt; 객체를 &lt;code&gt;init(Key)&lt;/code&gt; 또는 &lt;code&gt;init(Key, AlgorithmParameterSpec)&lt;/code&gt; 호출을 사용해, 이전에 초기화되었을 때의 상태로 리셋합니다 . 즉, 객체는 재설정되고 원하는 경우 &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;doFinal&lt;/code&gt; 에 대한 새 호출을 통해 동일한 키에서 다른 MAC을 생성 할 수 있습니다 . 이 &lt;code&gt;Mac&lt;/code&gt; 객체를 다른 키로 재사용 하려면 &lt;code&gt;init(Key)&lt;/code&gt; 또는 &lt;code&gt;init(Key, AlgorithmParameterSpec)&lt;/code&gt; 호출을 통해 다시 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4886ead2dadc8153d8df2ce75f91333caf2a6224" translate="yes" xml:space="preserve">
          <source>A call to this method resets this signature object to the state it was in when previously initialized for signing via a call to &lt;code&gt;initSign(PrivateKey)&lt;/code&gt;. That is, the object is reset and available to generate another signature from the same signer, if desired, via new calls to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;sign&lt;/code&gt;.</source>
          <target state="translated">이 메소드를 호출하면 (자),이 서명 오브젝트를 &lt;code&gt;initSign(PrivateKey)&lt;/code&gt; 호출을 사용해 , 서명하기 위해서 이전에 초기화 된 상태로 리셋합니다 . 즉, 원하는 경우 &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;sign&lt;/code&gt; 을위한 새 호출을 통해 동일한 서명자에서 다른 서명을 생성하기 위해 오브젝트가 재설정되고 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="76fc154e54203ae305cc7d9a3ee179a09214b472" translate="yes" xml:space="preserve">
          <source>A call to this method resets this signature object to the state it was in when previously initialized for verification via a call to &lt;code&gt;initVerify(PublicKey)&lt;/code&gt;. That is, the object is reset and available to verify another signature from the identity whose public key was specified in the call to &lt;code&gt;initVerify&lt;/code&gt;.</source>
          <target state="translated">이 메소드를 호출하면 (자),이 서명 오브젝트를 &lt;code&gt;initVerify(PublicKey)&lt;/code&gt; 호출을 사용해 검증 용으로 초기화 할 때의 상태로 리셋합니다 . 즉, 객체가 재설정되어 &lt;code&gt;initVerify&lt;/code&gt; 호출에 공개 키가 지정된 ID의 다른 서명을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c3f413a455df6c2e8fd25015d50c0b20ad9ebe5" translate="yes" xml:space="preserve">
          <source>A call to this method will return each outstanding task exactly once.</source>
          <target state="translated">이 메소드를 호출하면 각 미해결 작업이 정확히 한 번만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="73594faaa9514a1c74b8c1749cd461ade7dd464c" translate="yes" xml:space="preserve">
          <source>A callback that will be called exactly once after the Spi class has been instantiated and registered in a &lt;code&gt;ServiceRegistry&lt;/code&gt;. This may be used to verify that the environment is suitable for this service, for example that native libraries can be loaded. If the service cannot function in the environment where it finds itself, it should deregister itself from the registry.</source>
          <target state="translated">Spi 클래스가 인스턴스화되고 &lt;code&gt;ServiceRegistry&lt;/code&gt; 에 등록 된 후 정확히 한 번 호출되는 콜백입니다 . 이는 환경이이 서비스에 적합한 지 (예 : 기본 라이브러리를로드 할 수 있는지) 확인하는 데 사용될 수 있습니다. 서비스가있는 환경에서 서비스가 작동하지 않으면 레지스트리에서 자신을 등록 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9e488bdf35f09c0f0d09e9364cbcf74bf1848b2" translate="yes" xml:space="preserve">
          <source>A callback that will be whenever the Spi class has been deregistered from a &lt;code&gt;ServiceRegistry&lt;/code&gt;.</source>
          <target state="translated">Spi 클래스가 &lt;code&gt;ServiceRegistry&lt;/code&gt; 에서 등록 취소 될 때마다 발생하는 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="0862bd54496a4757c9e9f164297b979e3e8f8ea7" translate="yes" xml:space="preserve">
          <source>A caller can be marked as being &quot;privileged&quot; (see &lt;a href=&quot;accesscontroller#doPrivileged-java.security.PrivilegedAction-&quot;&gt;&lt;code&gt;doPrivileged&lt;/code&gt;&lt;/a&gt; and below). When making access control decisions, the &lt;code&gt;checkPermission&lt;/code&gt; method stops checking if it reaches a caller that was marked as &quot;privileged&quot; via a &lt;code&gt;doPrivileged&lt;/code&gt; call without a context argument (see below for information about a context argument). If that caller's domain has the specified permission and at least one limiting permission argument (if any) implies the requested permission, no further checking is done and &lt;code&gt;checkPermission&lt;/code&gt; returns quietly, indicating that the requested access is allowed. If that domain does not have the specified permission, an exception is thrown, as usual. If the caller's domain had the specified permission but it was not implied by any limiting permission arguments given in the call to &lt;code&gt;doPrivileged&lt;/code&gt; then the permission checking continues until there are no more callers or another &lt;code&gt;doPrivileged&lt;/code&gt; call matches the requested permission and returns normally.</source>
          <target state="translated">발신자는 &quot;권한 있음&quot;으로 표시 될 수 있습니다 ( &lt;a href=&quot;accesscontroller#doPrivileged-java.security.PrivilegedAction-&quot;&gt; &lt;code&gt;doPrivileged&lt;/code&gt; &lt;/a&gt; 및 아래 참조). 액세스 제어 결정을 수행 할 때 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 는 컨텍스트 인수없이 &lt;code&gt;doPrivileged&lt;/code&gt; 호출을 통해 &quot;권한&quot;으로 표시된 호출자에 도달하는지 확인을 중지 합니다 (컨텍스트 인수에 대한 정보는 아래 참조). 호출자의 도메인에 지정된 권한이 있고 하나 이상의 제한 권한 인수 (있는 경우)가 요청 된 권한을 암시하는 경우 추가 점검이 수행되지 않으며 &lt;code&gt;checkPermission&lt;/code&gt; 요청 된 액세스가 허용됨을 나타내는 자동으로 리턴합니다. 해당 도메인에 지정된 권한이 없으면 평소와 같이 예외가 발생합니다. 호출자의 도메인에 지정된 권한이 있지만 &lt;code&gt;doPrivileged&lt;/code&gt; 에 대한 호출에 제공된 제한 권한 인수에 의해 암시되지 않은 경우, 더 이상의 호출자가 없거나 다른 &lt;code&gt;doPrivileged&lt;/code&gt; 호출이 요청 된 권한과 일치하고 정상적으로 리턴 될 때까지 권한 점검이 계속 됩니다.</target>
        </trans-unit>
        <trans-unit id="4f95088e3230b86cb9b7c79d72fd9093503b3392" translate="yes" xml:space="preserve">
          <source>A caller obtains a SecureRandom instance via the no-argument constructor or one of the &lt;code&gt;getInstance&lt;/code&gt; methods:</source>
          <target state="translated">호출자는 인수가없는 생성자 또는 &lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 통해 SecureRandom 인스턴스를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="3c51b9f09fa6bf9ea50aeda8b949600008199a46" translate="yes" xml:space="preserve">
          <source>A caller requires permissions to access the Credentials in the returned &lt;code&gt;Set&lt;/code&gt;, or to modify the &lt;code&gt;Set&lt;/code&gt; itself. A &lt;code&gt;SecurityException&lt;/code&gt; is thrown if the caller does not have the proper permissions.</source>
          <target state="translated">호출자는 반환 된 &lt;code&gt;Set&lt;/code&gt; 의 자격 증명에 액세스 하거나 &lt;code&gt;Set&lt;/code&gt; 자체 를 수정할 수있는 권한이 필요 합니다. &lt;code&gt;SecurityException&lt;/code&gt; 호출자가 적절한 권한이없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e48b60ad6e578809d6b962cd5312d6a4b206220" translate="yes" xml:space="preserve">
          <source>A cancellable asynchronous computation.</source>
          <target state="translated">취소 가능한 비동기 계산.</target>
        </trans-unit>
        <trans-unit id="8a206c9c1ebd0c5daa3ba1ae87da2f6428b62838" translate="yes" xml:space="preserve">
          <source>A cancellable asynchronous computation. This class provides a base implementation of &lt;a href=&quot;future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the &lt;code&gt;get&lt;/code&gt; methods will block if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or cancelled (unless the computation is invoked using &lt;a href=&quot;futuretask#runAndReset--&quot;&gt;&lt;code&gt;runAndReset()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">취소 가능한 비동기 계산. 이 클래스는 &lt;a href=&quot;future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 의 기본 구현을 제공하며 , 계산을 시작 및 취소하고, 계산이 완료되었는지 확인하고, 계산 결과를 검색하는 메소드를 제공합니다. 계산이 완료된 경우에만 결과를 검색 할 수 있습니다. &lt;code&gt;get&lt;/code&gt; 계산이 아직 완료되지 않은 경우, 방법은 차단된다. 계산이 완료되면 계산을 다시 시작하거나 취소 할 수 없습니다 ( &lt;a href=&quot;futuretask#runAndReset--&quot;&gt; &lt;code&gt;runAndReset()&lt;/code&gt; &lt;/a&gt; 사용하여 계산을 호출하지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="b24dd18062248073c34de95bfbf526897b131dd5" translate="yes" xml:space="preserve">
          <source>A canonical pathname is both absolute and unique. The precise definition of canonical form is system-dependent. This method first converts this pathname to absolute form if necessary, as if by invoking the &lt;a href=&quot;file#getAbsolutePath--&quot;&gt;&lt;code&gt;getAbsolutePath()&lt;/code&gt;&lt;/a&gt; method, and then maps it to its unique form in a system-dependent way. This typically involves removing redundant names such as &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; from the pathname, resolving symbolic links (on UNIX platforms), and converting drive letters to a standard case (on Microsoft Windows platforms).</source>
          <target state="translated">표준 경로 이름은 절대적이고 고유합니다. 정식 형식의 정확한 정의는 시스템에 따라 다릅니다. 이 메소드는 먼저 &lt;a href=&quot;file#getAbsolutePath--&quot;&gt; &lt;code&gt;getAbsolutePath()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것처럼 필요한 경우이 경로 이름을 절대 형식으로 변환 한 다음 시스템 종속 방식으로 고유 한 형식으로 맵핑합니다. 일반적으로 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 와 같은 중복 이름을 제거 합니다. 그리고 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 경로명에서, (UNIX 플랫폼) 심볼릭 링크를 해결하고, (Microsoft Windows 플랫폼에서) 표준 경우에 드라이브 문자를 변환.</target>
        </trans-unit>
        <trans-unit id="81bf709141336beed8f753343474c99206c52e04" translate="yes" xml:space="preserve">
          <source>A capability-based lock with three modes for controlling read/write access.</source>
          <target state="translated">읽기 / 쓰기 액세스를 제어하기위한 세 가지 모드가있는 기능 기반 잠금.</target>
        </trans-unit>
        <trans-unit id="3c2e4112d21cf12f2a7a271b9c964f9ff2328115" translate="yes" xml:space="preserve">
          <source>A capability-based lock with three modes for controlling read/write access. The state of a StampedLock consists of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect to a lock state; &quot;try&quot; versions of these methods may instead return the special value zero to represent failure to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not match the state of the lock. The three modes are:</source>
          <target state="translated">읽기 / 쓰기 액세스를 제어하기위한 세 가지 모드가있는 기능 기반 잠금. StampedLock의 상태는 버전과 모드로 구성됩니다. 잠금 획득 방법은 잠금 상태에 대한 액세스를 나타내는 스탬프를 반환합니다. 이러한 방법의 &quot;시도&quot;버전은 대신 특수 값 0을 반환하여 액세스 획득 실패를 나타낼 수 있습니다. 잠금 해제 및 변환 방법에는 스탬프로 인수가 필요하며 잠금 상태와 일치하지 않으면 실패합니다. 세 가지 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4c23c15c033507b435f0f0a354dbc2b8655d74c" translate="yes" xml:space="preserve">
          <source>A capturing group can also be assigned a &quot;name&quot;, a &lt;code&gt;named-capturing group&lt;/code&gt;, and then be back-referenced later by the &quot;name&quot;. Group names are composed of the following characters. The first character must be a &lt;code&gt;letter&lt;/code&gt;.</source>
          <target state="translated">캡처 그룹에 &quot;이름&quot;, &lt;code&gt;named-capturing group&lt;/code&gt; 할당 한 다음 나중에 &quot;이름&quot;으로 다시 참조 할 수도 있습니다 . 그룹 이름은 다음 문자로 구성됩니다. 첫 번째 문자가 있어야합니다 &lt;code&gt;letter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cff8bffd93ff124f465e2fd1a81f11d6fce23cb2" translate="yes" xml:space="preserve">
          <source>A carriage return (CR) character standing by itself means &quot;go to column 1 of the next line.&quot;</source>
          <target state="translated">캐리지 리턴 (CR) 문자 자체는 &quot;다음 줄의 1 열로 이동&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c9d0a280ee3997ec1b9b09288f8793052e7adc66" translate="yes" xml:space="preserve">
          <source>A carriage-return character followed immediately by a newline character (&lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;),</source>
          <target state="translated">캐리지 리턴 문자 뒤에 바로 줄 바꿈 문자 ( &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; )가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="200e757132c0a25b1d7ddb249bee8390af696aeb" translate="yes" xml:space="preserve">
          <source>A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the &lt;a href=&quot;throwable#initCause-java.lang.Throwable-&quot;&gt;&lt;code&gt;initCause(Throwable)&lt;/code&gt;&lt;/a&gt; method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the &lt;code&gt;Throwable&lt;/code&gt; constructors that takes a cause. Because the &lt;code&gt;initCause&lt;/code&gt; method is public, it allows a cause to be associated with any throwable, even a &quot;legacy throwable&quot; whose implementation predates the addition of the exception chaining mechanism to &lt;code&gt;Throwable&lt;/code&gt;.</source>
          <target state="translated">원인은 두 가지 방법으로 원인을 인수로 사용하는 생성자 또는 &lt;a href=&quot;throwable#initCause-java.lang.Throwable-&quot;&gt; &lt;code&gt;initCause(Throwable)&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 Throwable 과 연관 될 수 있습니다 . 원인을 원인과 연관시킬 수있는 새로운 Throwable 클래스는 원인을 취하는 생성자를 제공하고 원인 을 취하는 &lt;code&gt;Throwable&lt;/code&gt; 생성자 중 하나에 간접적으로 위임 할 수 있습니다. &lt;code&gt;initCause&lt;/code&gt; 메소드는 공용 이기 때문에, 예외 체인 메커니즘을 &lt;code&gt;Throwable&lt;/code&gt; 에 추가하기 전에 구현이 발생하는 &quot;레거시 Throwable&quot;과 같은 원인을 발생 원인과 연관시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb9adaf3b7e2f40fbde1879f520e8811bd797f68" translate="yes" xml:space="preserve">
          <source>A central authority generates parameters and gives them to the two entities seeking to generate a secret key. The parameters are a prime &lt;code&gt;p&lt;/code&gt;, a base &lt;code&gt;g&lt;/code&gt;, and optionally the length in bits of the private value, &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">중앙 권한은 매개 변수를 생성하고 비밀 키를 생성하려는 두 엔티티에 매개 변수를 제공합니다. 매개 변수는 소수 &lt;code&gt;p&lt;/code&gt; , 밑수 &lt;code&gt;g&lt;/code&gt; 및 선택적으로 개인 값 &lt;code&gt;l&lt;/code&gt; 의 비트 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="b15f87ac85c08bc308c57b0713f245a6c447fad2" translate="yes" xml:space="preserve">
          <source>A certificate factory for X.509 must return certificates that are an instance of &lt;code&gt;java.security.cert.X509Certificate&lt;/code&gt;, and CRLs that are an instance of &lt;code&gt;java.security.cert.X509CRL&lt;/code&gt;.</source>
          <target state="translated">X. 509의 증명서 팩토리는의 인스턴스 인 증명서 돌려 줄 필요 &lt;code&gt;java.security.cert.X509Certificate&lt;/code&gt; 의 인스턴스이며, CRL을 &lt;code&gt;java.security.cert.X509CRL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d13204c98a6ed6a0090b39584fbff66ef2fd4ba5" translate="yes" xml:space="preserve">
          <source>A certificate path.</source>
          <target state="translated">인증서 경로.</target>
        </trans-unit>
        <trans-unit id="69bc8c8897a2aaa1567c6f12d93e327556a92e8e" translate="yes" xml:space="preserve">
          <source>A certificate policies extension, if present in an X.509 version 3 certificate, contains a sequence of one or more policy information terms, each of which consists of an object identifier (OID) and optional qualifiers. In an end-entity certificate, these policy information terms indicate the policy under which the certificate has been issued and the purposes for which the certificate may be used. In a CA certificate, these policy information terms limit the set of policies for certification paths which include this certificate.</source>
          <target state="translated">인증서 정책 확장 (X.509 버전 3 인증서에있는 경우)에는 하나 이상의 정책 정보 용어가 포함되어 있으며 각각은 OID (개체 식별자)와 선택적 한정자로 구성됩니다. 엔드 엔티티 인증서에서 이러한 정책 정보 용어는 인증서가 발급 된 정책 및 인증서 사용 목적을 나타냅니다. CA 인증서에서 이러한 정책 정보 용어는이 인증서를 포함하는 인증 경로에 대한 정책 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="12b7e0369567e0a42b4add2191ea7b355c8240c6" translate="yes" xml:space="preserve">
          <source>A change in the value of the nesting BeanContext property of this BeanContextChild may be vetoed by throwing the appropriate exception.</source>
          <target state="translated">이 BeanContextChild의 중첩 BeanContext 프로퍼티의 값의 변경은, 적절한 예외를 throw함으로써 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72d29acf86e7702c32bda0ec435a23e72471262" translate="yes" xml:space="preserve">
          <source>A channel cannot be deregistered directly; instead, the key representing its registration must be</source>
          <target state="translated">채널은 직접 등록 취소 할 수 없습니다. 대신 등록을 나타내는 키는</target>
        </trans-unit>
        <trans-unit id="8d7e774f5d23e83f7b27801d7e8202ecdb67d702" translate="yes" xml:space="preserve">
          <source>A channel for a stream-oriented connecting socket</source>
          <target state="translated">스트림 지향 연결 소켓을위한 채널</target>
        </trans-unit>
        <trans-unit id="9e1601a8223fa155ec20c1df5e38f1e8f95ed05f" translate="yes" xml:space="preserve">
          <source>A channel for reading, writing, mapping, and manipulating a file.</source>
          <target state="translated">파일 읽기, 쓰기, 매핑 및 조작을위한 채널입니다.</target>
        </trans-unit>
        <trans-unit id="9ac0c81f717986b03ee3daf2a9350d01082aa55a" translate="yes" xml:space="preserve">
          <source>A channel is either open or closed. A channel is open upon creation, and once closed it remains closed. Once a channel is closed, any attempt to invoke an I/O operation upon it will cause a &lt;a href=&quot;closedchannelexception&quot;&gt;&lt;code&gt;ClosedChannelException&lt;/code&gt;&lt;/a&gt; to be thrown. Whether or not a channel is open may be tested by invoking its &lt;a href=&quot;channel#isOpen--&quot;&gt;&lt;code&gt;isOpen&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널이 열려 있거나 닫혀 있습니다. 생성시 채널이 열리고 닫히면 채널은 닫혀 있습니다. 채널이 닫히면 I / O 작업을 호출하려고하면 &lt;a href=&quot;closedchannelexception&quot;&gt; &lt;code&gt;ClosedChannelException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 채널이 열려 있는지 여부는 &lt;a href=&quot;channel#isOpen--&quot;&gt; &lt;code&gt;isOpen&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb5a0f968508f5be9958440240f5d1267c99a94" translate="yes" xml:space="preserve">
          <source>A channel may be registered at most once with any particular selector.</source>
          <target state="translated">채널은 특정 선택기로 최대 한 번 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21fb8ef335a3687ca6d6626447bc68cde9a71bdf" translate="yes" xml:space="preserve">
          <source>A channel representing the readable end of a &lt;a href=&quot;pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 의 읽을 수있는 끝을 나타내는 채널 입니다.</target>
        </trans-unit>
        <trans-unit id="d85558a6843581591cf1be190cf66c79e3f828ac" translate="yes" xml:space="preserve">
          <source>A channel representing the writable end of a &lt;a href=&quot;pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 의 쓰기 가능한 끝을 나타내는 채널 입니다.</target>
        </trans-unit>
        <trans-unit id="70dc1aab8c52e3f7d92aa4d0c02a1489f7dbc0ea" translate="yes" xml:space="preserve">
          <source>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</source>
          <target state="translated">채널은 하드웨어 장치, 파일, 네트워크 소켓 또는 하나 이상의 고유 한 I / O 작업 (예 : 읽기 또는 쓰기)을 수행 할 수있는 프로그램 구성 요소와 같은 엔터티에 대한 열린 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b8fef62afdf0975eec2e59fb2c36004534d294f5" translate="yes" xml:space="preserve">
          <source>A channel supports asynchronous closing and interruption if, and only if, it implements this interface. This can be tested at runtime, if necessary, via the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">채널은이 인터페이스를 구현하는 경우에만 비동기 닫기 및 중단을 지원합니다. 필요한 경우 &lt;code&gt;instanceof&lt;/code&gt; 연산자 를 통해 런타임에 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0d5b76afd6f0f29b38f37a05ac0c3b9c5f72e6" translate="yes" xml:space="preserve">
          <source>A channel that can be asynchronously closed and interrupted.</source>
          <target state="translated">비동기 적으로 닫히고 중단 될 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="59b7b7fac8ee9975147807e839aeb8fe38d241bb" translate="yes" xml:space="preserve">
          <source>A channel that can be multiplexed</source>
          <target state="translated">다중화 할 수있는 채널</target>
        </trans-unit>
        <trans-unit id="1214854eb0213a1ff43a9021db015696b91deec7" translate="yes" xml:space="preserve">
          <source>A channel that can be multiplexed via a &lt;a href=&quot;selector&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;selector&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; 를 통해 멀티플렉싱 할 수있는 채널 .</target>
        </trans-unit>
        <trans-unit id="800646be4ec902c097761409c9fd09caafb4a495" translate="yes" xml:space="preserve">
          <source>A channel that can read and write bytes.</source>
          <target state="translated">바이트를 읽고 쓸 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="3a18d46d23ef0ee898d000c7fdbcf8d70cccbb4c" translate="yes" xml:space="preserve">
          <source>A channel that can read and write bytes. This interface simply unifies &lt;a href=&quot;readablebytechannel&quot;&gt;&lt;code&gt;ReadableByteChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;writablebytechannel&quot;&gt;&lt;code&gt;WritableByteChannel&lt;/code&gt;&lt;/a&gt;; it does not specify any new operations.</source>
          <target state="translated">바이트를 읽고 쓸 수있는 채널. 이 인터페이스는 단순히 &lt;a href=&quot;readablebytechannel&quot;&gt; &lt;code&gt;ReadableByteChannel&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;writablebytechannel&quot;&gt; &lt;code&gt;WritableByteChannel&lt;/code&gt; 을&lt;/a&gt; 통합합니다 . 새로운 작업을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42a631ef4c7905c22f79a70339587d209893d713" translate="yes" xml:space="preserve">
          <source>A channel that can read bytes into a sequence of buffers.</source>
          <target state="translated">일련의 버퍼로 바이트를 읽을 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="ecb9b303f470a97f2f08805d8d8c94b642db6ff2" translate="yes" xml:space="preserve">
          <source>A channel that can read bytes.</source>
          <target state="translated">바이트를 읽을 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="95845315fdbf28ed7bd0ae0197a23b2ef4a4b208" translate="yes" xml:space="preserve">
          <source>A channel that can write bytes from a sequence of buffers.</source>
          <target state="translated">일련의 버퍼에서 바이트를 쓸 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="8f098a9ecf20dc34b289410aad7ca21436a5b36f" translate="yes" xml:space="preserve">
          <source>A channel that can write bytes.</source>
          <target state="translated">바이트를 쓸 수있는 채널.</target>
        </trans-unit>
        <trans-unit id="b4efac3fa36ee432ca8226ac9cfe90afc82a7eaa" translate="yes" xml:space="preserve">
          <source>A channel that implements this interface is</source>
          <target state="translated">이 인터페이스를 구현하는 채널은</target>
        </trans-unit>
        <trans-unit id="5b097b4ced43ca741c0e40c7c3e34b41dfce4add" translate="yes" xml:space="preserve">
          <source>A channel that implements this interface is &lt;em&gt;asynchronously closeable&lt;/em&gt;: If an I/O operation is outstanding on the channel and the channel's &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method is invoked, then the I/O operation fails with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스를 구현하는 채널은 &lt;em&gt;비동기 적으로 &lt;/em&gt;&lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 수 있습니다&lt;/em&gt; . I / O 조작이 채널에서 처리되지 않고 채널의 close 메소드가 호출되면 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 예외와 함께 I / O 조작이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="d5b8a450c6a26f4e50db17fd5ebc4459ce7d7949" translate="yes" xml:space="preserve">
          <source>A channel that implements this interface is a channel to a network socket. The &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; method is used to bind the socket to a local &lt;a href=&quot;../../net/socketaddress&quot;&gt;&lt;code&gt;address&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;networkchannel#getLocalAddress--&quot;&gt;&lt;code&gt;getLocalAddress&lt;/code&gt;&lt;/a&gt; method returns the address that the socket is bound to, and the &lt;a href=&quot;networkchannel#setOption-java.net.SocketOption-T-&quot;&gt;&lt;code&gt;setOption&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;networkchannel#getOption-java.net.SocketOption-&quot;&gt;&lt;code&gt;getOption&lt;/code&gt;&lt;/a&gt; methods are used to set and query socket options. An implementation of this interface should specify the socket options that it supports.</source>
          <target state="translated">이 인터페이스를 구현하는 채널은 네트워크 소켓에 대한 채널입니다. &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 방법은 지역에 소켓을 바인딩하는 데 사용되는 &lt;a href=&quot;../../net/socketaddress&quot;&gt; &lt;code&gt;address&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;networkchannel#getLocalAddress--&quot;&gt; &lt;code&gt;getLocalAddress&lt;/code&gt; 의&lt;/a&gt; 방법은 소켓이 바인딩되는 주소 및 반환 &lt;a href=&quot;networkchannel#setOption-java.net.SocketOption-T-&quot;&gt; &lt;code&gt;setOption&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;networkchannel#getOption-java.net.SocketOption-&quot;&gt; &lt;code&gt;getOption&lt;/code&gt; &lt;/a&gt; 방법은 세트와 쿼리 소켓 옵션에 사용됩니다. 이 인터페이스의 구현은 지원하는 소켓 옵션을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b4ffd0b00aae234d34f01c53dd96dc57bf6b6e0" translate="yes" xml:space="preserve">
          <source>A channel that implements this interface is also</source>
          <target state="translated">이 인터페이스를 구현하는 채널도</target>
        </trans-unit>
        <trans-unit id="d9796e052a0f539e5d20f76e2665722b23b84065" translate="yes" xml:space="preserve">
          <source>A channel that supports asynchronous I/O operations.</source>
          <target state="translated">비동기 I / O 작업을 지원하는 채널입니다.</target>
        </trans-unit>
        <trans-unit id="191edb71e4e511906b4a3aabedb3d6703cb5257a" translate="yes" xml:space="preserve">
          <source>A channel that supports asynchronous I/O operations. Asynchronous I/O operations will usually take one of two forms:</source>
          <target state="translated">비동기 I / O 작업을 지원하는 채널입니다. 비동기 I / O 작업은 일반적으로 다음 두 가지 형식 중 하나를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9ed40df29696c88e6c71549b1c57172f2535d2e1" translate="yes" xml:space="preserve">
          <source>A channel to a datagram-oriented socket</source>
          <target state="translated">데이터 그램 지향 소켓에 대한 채널</target>
        </trans-unit>
        <trans-unit id="8dd23ea95fe683f2446dc0f81225ff9c1aa46c49" translate="yes" xml:space="preserve">
          <source>A channel to a network socket</source>
          <target state="translated">네트워크 소켓에 대한 채널</target>
        </trans-unit>
        <trans-unit id="0b7fadce40dec6dc50b0937f58a33b6784464fad" translate="yes" xml:space="preserve">
          <source>A channel to a network socket.</source>
          <target state="translated">네트워크 소켓에 대한 채널.</target>
        </trans-unit>
        <trans-unit id="fba973fb0458ecef3b4ce50b17afa170ef7b7640" translate="yes" xml:space="preserve">
          <source>A channel to a stream-oriented listening socket</source>
          <target state="translated">스트림 지향 청취 소켓에 대한 채널</target>
        </trans-unit>
        <trans-unit id="db20aa88a7238119d3ad50b601b0e37532ec55a6" translate="yes" xml:space="preserve">
          <source>A char buffer containing the decoded characters</source>
          <target state="translated">디코딩 된 문자를 포함하는 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="f83ee77e42e8490f810288c59eb103b9eb63a96e" translate="yes" xml:space="preserve">
          <source>A char buffer is not comparable to any other type of object.</source>
          <target state="translated">char 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc1b6b1c3f1c52066b1cf54b29319071b3f900d3" translate="yes" xml:space="preserve">
          <source>A char buffer is not equal to any other type of object.</source>
          <target state="translated">char 버퍼는 다른 유형의 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c92b2e8ed081e77f9fb1315da995d59a732735d8" translate="yes" xml:space="preserve">
          <source>A char buffer.</source>
          <target state="translated">문자 버퍼</target>
        </trans-unit>
        <trans-unit id="b747af939ee20ee5f1cd9aefd76c5b5096a87a8b" translate="yes" xml:space="preserve">
          <source>A char value is a surrogate code unit if and only if it is either a &lt;a href=&quot;character#isLowSurrogate-char-&quot;&gt;low-surrogate code unit&lt;/a&gt; or a &lt;a href=&quot;character#isHighSurrogate-char-&quot;&gt;high-surrogate code unit&lt;/a&gt;.</source>
          <target state="translated">숯불 값 대리 코드 유닛 인 경우에만 그것이 어느 경우 &lt;a href=&quot;character#isLowSurrogate-char-&quot;&gt;낮은 대리 코드 부&lt;/a&gt; 또는 &lt;a href=&quot;character#isHighSurrogate-char-&quot;&gt;고 대리 코드 유닛&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d41302344e7fbbca3b8d487f3516ee3b89ee120f" translate="yes" xml:space="preserve">
          <source>A character array containing the password or passphrase read from the console, not including any line-termination characters, or &lt;code&gt;null&lt;/code&gt; if an end of stream has been reached.</source>
          <target state="translated">콘솔에서 읽은 비밀번호 또는 비밀번호 문구가 포함 된 문자 배열 (줄 ​​종결 문자는 포함하지 않음) 또는 스트림 끝에 도달 한 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86592acb8a1516339482f65b9fe9fea4d5b1cbbf" translate="yes" xml:space="preserve">
          <source>A character in the Greek block (&lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt;)</source>
          <target state="translated">그리스어 블록의 문자 ( &lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="43025dbde61ef9eae4dedd1a09f0b0781d452fd0" translate="yes" xml:space="preserve">
          <source>A character is</source>
          <target state="translated">캐릭터는</target>
        </trans-unit>
        <trans-unit id="7f4ce8079139a88322f4ae2aba1220448793d458" translate="yes" xml:space="preserve">
          <source>A character is a digit if its general category type, provided by &lt;a href=&quot;character#getType-int-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is &lt;code&gt;DECIMAL_DIGIT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;character#getType-int-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;DECIMAL_DIGIT_NUMBER&lt;/code&gt; 인 경우 문자는 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="fdd1a754889230886d0a4a8fb8d9c2f75250cd5a" translate="yes" xml:space="preserve">
          <source>A character is a digit if its general category type, provided by &lt;code&gt;Character.getType(ch)&lt;/code&gt;, is &lt;code&gt;DECIMAL_DIGIT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Character.getType(ch)&lt;/code&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;DECIMAL_DIGIT_NUMBER&lt;/code&gt; 인 경우 문자는 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="ed0b005fbc298f5a0e45fbdd786dd40107520eed" translate="yes" xml:space="preserve">
          <source>A character is a titlecase character if its general category type, provided by &lt;a href=&quot;character#getType-int-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is &lt;code&gt;TITLECASE_LETTER&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;character#getType-int-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;TITLECASE_LETTER&lt;/code&gt; 인 경우 문자는 제목 케이스 문자 입니다.</target>
        </trans-unit>
        <trans-unit id="40b7e7e298658479c6f67b4c32be450022509975" translate="yes" xml:space="preserve">
          <source>A character is a titlecase character if its general category type, provided by &lt;code&gt;Character.getType(ch)&lt;/code&gt;, is &lt;code&gt;TITLECASE_LETTER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Character.getType(ch)&lt;/code&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;TITLECASE_LETTER&lt;/code&gt; 인 경우 문자는 제목 케이스 문자 입니다.</target>
        </trans-unit>
        <trans-unit id="b3e93e58c4c08afdd56f97246f883396140cfeb6" translate="yes" xml:space="preserve">
          <source>A character is considered to be a letter if its general category type, provided by &lt;a href=&quot;character#getType-int-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is any of the following:</source>
          <target state="translated">&lt;a href=&quot;character#getType-int-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 다음 중 하나 인 경우 문자는 문자로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="cfd74a58d4f3e068c12a4637ed1ea71a70c63fca" translate="yes" xml:space="preserve">
          <source>A character is considered to be a letter if its general category type, provided by &lt;code&gt;Character.getType(ch)&lt;/code&gt;, is any of the following:</source>
          <target state="translated">&lt;code&gt;Character.getType(ch)&lt;/code&gt; 의해 제공되는 일반 카테고리 유형 이 다음 중 하나 인 경우 문자는 문자로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="257a1fc191243a38382ed54b91922f94818951c2" translate="yes" xml:space="preserve">
          <source>A character is considered to be a letter or digit if either &lt;a href=&quot;character#isLetter-int-&quot;&gt;&lt;code&gt;isLetter(codePoint)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;character#isDigit-int-&quot;&gt;&lt;code&gt;isDigit(codePoint)&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; for the character.</source>
          <target state="translated">문자에 대해 &lt;a href=&quot;character#isLetter-int-&quot;&gt; &lt;code&gt;isLetter(codePoint)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;character#isDigit-int-&quot;&gt; &lt;code&gt;isDigit(codePoint)&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 문자 는 문자 또는 숫자로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="56e9e520047941ac231e484f638ee37ff36c4c23" translate="yes" xml:space="preserve">
          <source>A character is considered to be a letter or digit if either &lt;code&gt;Character.isLetter(char ch)&lt;/code&gt; or &lt;code&gt;Character.isDigit(char ch)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the character.</source>
          <target state="translated">&lt;code&gt;Character.isLetter(char ch)&lt;/code&gt; 또는 &lt;code&gt;Character.isDigit(char ch)&lt;/code&gt; 가 문자에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 문자 는 문자 또는 숫자로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1daab1c6e481dada609c883697d804983fd2e80e" translate="yes" xml:space="preserve">
          <source>A character is considered to be alphabetic if its general category type, provided by &lt;a href=&quot;character#getType-int-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is any of the following:</source>
          <target state="translated">&lt;a href=&quot;character#getType-int-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 다음 중 하나 인 경우 문자는 알파벳으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="846ad6665f9e9112c25d9f35739a2d02161fe462" translate="yes" xml:space="preserve">
          <source>A character is defined if at least one of the following is true:</source>
          <target state="translated">다음 중 하나 이상에 해당하면 문자가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4fe37a529ecb9e0094fe32d5a9d41a0084dcdd" translate="yes" xml:space="preserve">
          <source>A character is lowercase if its general category type, provided by &lt;a href=&quot;character#getType-char-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is &lt;code&gt;LOWERCASE_LETTER&lt;/code&gt;, or it has contributory property Other_Lowercase as defined by the Unicode Standard.</source>
          <target state="translated">&lt;a href=&quot;character#getType-char-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;LOWERCASE_LETTER&lt;/code&gt; 이거나 유니 코드 표준에 의해 정의 된 컨트 리뷰 션 특성 Other_Lowercase를 갖는 경우 문자는 소문자 입니다.</target>
        </trans-unit>
        <trans-unit id="770ed3a3b7a1750f819b0f53d78ab4e560573022" translate="yes" xml:space="preserve">
          <source>A character is lowercase if its general category type, provided by &lt;code&gt;Character.getType(ch)&lt;/code&gt;, is &lt;code&gt;LOWERCASE_LETTER&lt;/code&gt;, or it has contributory property Other_Lowercase as defined by the Unicode Standard.</source>
          <target state="translated">&lt;code&gt;Character.getType(ch)&lt;/code&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;LOWERCASE_LETTER&lt;/code&gt; 이거나 유니 코드 표준에 의해 정의 된 컨트 리뷰 션 특성 Other_Lowercase를 갖는 경우 문자는 소문자 입니다.</target>
        </trans-unit>
        <trans-unit id="a03c0a4129a458c83450c7f6d5b8a7d9f5975f99" translate="yes" xml:space="preserve">
          <source>A character is uppercase if its general category type, provided by &lt;a href=&quot;character#getType-int-&quot;&gt;&lt;code&gt;getType(codePoint)&lt;/code&gt;&lt;/a&gt;, is &lt;code&gt;UPPERCASE_LETTER&lt;/code&gt;, or it has contributory property Other_Uppercase as defined by the Unicode Standard.</source>
          <target state="translated">&lt;a href=&quot;character#getType-int-&quot;&gt; &lt;code&gt;getType(codePoint)&lt;/code&gt; &lt;/a&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;UPPERCASE_LETTER&lt;/code&gt; 이거나 유니 코드 표준에 의해 정의 된대로 기여 특성 Other_Uppercase를 갖는 경우 문자는 대문자 입니다.</target>
        </trans-unit>
        <trans-unit id="691356a97a7e1df0d7387885124751d46be64f49" translate="yes" xml:space="preserve">
          <source>A character is uppercase if its general category type, provided by &lt;code&gt;Character.getType(ch)&lt;/code&gt;, is &lt;code&gt;UPPERCASE_LETTER&lt;/code&gt;. or it has contributory property Other_Uppercase as defined by the Unicode Standard.</source>
          <target state="translated">&lt;code&gt;Character.getType(ch)&lt;/code&gt; 의해 제공되는 일반 카테고리 유형 이 &lt;code&gt;UPPERCASE_LETTER&lt;/code&gt; 인 경우문자 는 대문자 입니다. 또는 유니 코드 표준에 의해 정의 된 컨트 리뷰 션 특성 Other_Uppercase를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3e6d561d343a7744b12d7a0fc05b3bcf33b29211" translate="yes" xml:space="preserve">
          <source>A character may be part of a Java identifier if and only if any of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하는 경우에만 문자가 Java 식별자의 일부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac0fb63df90ee768362eb2ea36be06b1c3ba9f2" translate="yes" xml:space="preserve">
          <source>A character may be part of a Java identifier if any of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하면 문자가 Java 식별자의 일부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4c6b2fd3ac5173e7a35051a02bcb5aca73d33c" translate="yes" xml:space="preserve">
          <source>A character may be part of a Unicode identifier if and only if one of the following statements is true:</source>
          <target state="translated">다음 명령문 중 하나에 해당하는 경우에만 문자가 유니 코드 식별자의 일부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6acb9fd8c4c0db766c6d1bcd34828dc2a4ff4f1b" translate="yes" xml:space="preserve">
          <source>A character may start a Java identifier if and only if one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하는 경우에만 문자가 Java 식별자를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fada3cffc279f5988b5a9f5e97628c24a2aa3eb" translate="yes" xml:space="preserve">
          <source>A character may start a Java identifier if and only if one of the following is true:</source>
          <target state="translated">다음 중 하나에 해당하는 경우에만 문자가 Java 식별자를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8765bea07151f2ce322c2b3d88588b5932784a7e" translate="yes" xml:space="preserve">
          <source>A character may start a Unicode identifier if and only if one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하는 경우에만 문자가 유니 코드 식별자를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691511f32534c704fa5a722392a9bc0eb20fb683" translate="yes" xml:space="preserve">
          <source>A character stream that collects its output in a string buffer, which can then be used to construct a string.</source>
          <target state="translated">문자열 버퍼에서 출력을 수집하여 문자열을 구성하는 데 사용할 수있는 문자 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="6e7b08f91b89d317251e96eea88d34f90455c7a7" translate="yes" xml:space="preserve">
          <source>A character stream whose source is a string.</source>
          <target state="translated">소스가 문자열 인 문자 스트림.</target>
        </trans-unit>
        <trans-unit id="d75764e4070dffd8fcb663eb5024c4e2583781ea" translate="yes" xml:space="preserve">
          <source>A character-stream reader that allows characters to be pushed back into the stream.</source>
          <target state="translated">문자를 스트림으로 다시 밀어 넣을 수있는 문자 스트림 판독기입니다.</target>
        </trans-unit>
        <trans-unit id="7e71cb0a066a90cfe9e8b1752b6cfd83166a3957" translate="yes" xml:space="preserve">
          <source>A charset</source>
          <target state="translated">문자셋</target>
        </trans-unit>
        <trans-unit id="d22770c7dbf1fb019d5babc9504c5657e1aba041" translate="yes" xml:space="preserve">
          <source>A charset coder, that is, either a decoder or an encoder, consumes bytes (or characters) from an input buffer, translates them, and writes the resulting characters (or bytes) to an output buffer. A coding process terminates for one of four categories of reasons, which are described by instances of this class:</source>
          <target state="translated">문자 세트 코더, 즉 디코더 또는 인코더는 입력 버퍼에서 바이트 (또는 문자)를 소비하고 변환하여 결과 문자 (또는 바이트)를 출력 버퍼에 씁니다. 코딩 프로세스는 다음과 같은 네 가지 범주 중 하나의 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd0ab276ddc94d3bcc05a6158cfcc333e771240" translate="yes" xml:space="preserve">
          <source>A charset name must begin with either a letter or a digit. The empty string is not a legal charset name. Charset names are not case-sensitive; that is, case is always ignored when comparing charset names. Charset names generally follow the conventions documented in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278: IANA Charset Registration Procedures&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">문자 세트 이름은 문자 나 숫자로 시작해야합니다. 빈 문자열은 유효한 문자셋 이름이 아닙니다. 문자셋 이름은 대소 문자를 구분하지 않습니다. 즉, 문자 세트 이름을 비교할 때 대소 문자는 항상 무시됩니다. 문자 세트 이름은 일반적으로 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278 : IANA 문자 세트 등록 절차에&lt;/i&gt;&lt;/a&gt; 설명 된 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4fe6216b2b6912b763b72e1be7ba9f4eee5aa678" translate="yes" xml:space="preserve">
          <source>A charset object for the default charset</source>
          <target state="translated">기본 캐릭터 셋의 캐릭터 셋 객체</target>
        </trans-unit>
        <trans-unit id="21f8395adeb2457ad7d39af82263c878f2937a8d" translate="yes" xml:space="preserve">
          <source>A charset object for the named charset</source>
          <target state="translated">명명 된 캐릭터 세트의 캐릭터 세트 객체</target>
        </trans-unit>
        <trans-unit id="18bb2c3bab5292ed8acddebeb49d66ce2ec77bbb" translate="yes" xml:space="preserve">
          <source>A charset object for the named charset, or &lt;code&gt;null&lt;/code&gt; if the named charset is not supported by this provider</source>
          <target state="translated">명명 된 캐릭터 세트의 캐릭터 세트 객체. 이 프로 바이더가 명명 된 캐릭터 세트를 지원하지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb32edc10313e3f65dbd9b8601d559d2295da0ed" translate="yes" xml:space="preserve">
          <source>A charset provider identifies itself with a provider-configuration file named &lt;code&gt;java.nio.charset.spi.CharsetProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;. The file should contain a list of fully-qualified concrete charset-provider class names, one per line. A line is terminated by any one of a line feed (&lt;code&gt;'\n'&lt;/code&gt;), a carriage return (&lt;code&gt;'\r'&lt;/code&gt;), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;'\u0023'&lt;/code&gt;); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</source>
          <target state="translated">문자 세트 제공자 는 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에있는 &lt;code&gt;java.nio.charset.spi.CharsetProvider&lt;/code&gt; 라는 제공자 구성 파일로 자신을 식별합니다 . 파일에는 한 줄에 하나씩 정규화 된 구체적 문자셋 공급자 클래스 이름 목록이 포함되어야합니다. 줄 바꿈 ( &lt;code&gt;'\n'&lt;/code&gt; ), 캐리지 리턴 ( &lt;code&gt;'\r'&lt;/code&gt; ) 또는 캐리지 리턴 바로 다음에 줄 바꿈이 있으면 줄이 종료됩니다 . 빈 줄뿐만 아니라 각 이름을 둘러싼 공백과 탭 문자는 무시됩니다. 주석 문자는 &lt;code&gt;'#'&lt;/code&gt; ( &lt;code&gt;'\u0023'&lt;/code&gt; )입니다. 각 줄에서 첫 번째 주석 문자 다음의 모든 문자는 무시됩니다. 파일은 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3bb5f8d2cb453a6dc7cf144db31f427c7be37ff5" translate="yes" xml:space="preserve">
          <source>A charset provider is a concrete subclass of this class that has a zero-argument constructor and some number of associated charset implementation classes. Charset providers may be installed in an instance of the Java platform as extensions, that is, jar files placed into any of the usual extension directories. Providers may also be made available by adding them to the applet or application class path or by some other platform-specific means. Charset providers are looked up via the current thread's &lt;a href=&quot;../../../lang/thread#getContextClassLoader--&quot;&gt;&lt;code&gt;context class
 loader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">캐릭터 세트 프로 바이더는 인수 없음의 생성자 및 관련 캐릭터 세트 구현 클래스를 가지는이 클래스의 구상 서브 클래스입니다. 문자 세트 제공자는 Java 플랫폼의 인스턴스에 확장, 즉 일반적인 확장 디렉토리에 배치 된 jar 파일로 설치 될 수 있습니다. 애플릿이나 응용 프로그램 클래스 경로에 추가하거나 다른 플랫폼 별 수단으로 공급자를 제공 할 수도 있습니다. 문자셋 제공자는 현재 스레드의 &lt;a href=&quot;../../../lang/thread#getContextClassLoader--&quot;&gt; &lt;code&gt;context class loader&lt;/code&gt; &lt;/a&gt; 를 통해 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="ece31ac787ed07fbedfac8cb5253447ae75ba96a" translate="yes" xml:space="preserve">
          <source>A class &lt;code&gt;Foo&lt;/code&gt; wishing to access preferences pertaining to its package can obtain a preference node as follows:</source>
          <target state="translated">패키지와 관련된 환경 설정에 액세스하려는 &lt;code&gt;Foo&lt;/code&gt; 클래스 는 다음과 같이 환경 설정 노드를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fba903462c5e274f857cc56faf41e8e1cdf8504" translate="yes" xml:space="preserve">
          <source>A class attribute expression. The returned object will be serialized as an instance of the non-public class  javax.management.ClassAttributeValueExp.</source>
          <target state="translated">클래스 속성 표현식. 리턴 된 오브젝트는 비 공용 클래스 javax.management.ClassAttributeValueExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="c89a8aacf78b87597462542f12b1287b60ecb678" translate="yes" xml:space="preserve">
          <source>A class can implement the &lt;code&gt;Observer&lt;/code&gt; interface when it wants to be informed of changes in observable objects.</source>
          <target state="translated">클래스는 관찰 가능한 객체의 변경 사항에 대한 정보를 원할 때 &lt;code&gt;Observer&lt;/code&gt; 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba1fcf9735c8794d9553c9de8b9def398f44c4b" translate="yes" xml:space="preserve">
          <source>A class containing static convenience methods for locating &lt;code&gt;ImageReader&lt;/code&gt;s and &lt;code&gt;ImageWriter&lt;/code&gt;s, and performing simple encoding and decoding.</source>
          <target state="translated">&lt;code&gt;ImageReader&lt;/code&gt; 및 &lt;code&gt;ImageWriter&lt;/code&gt; 를 찾고 간단한 인코딩 및 디코딩을 수행 하기위한 정적 편의 메소드가 포함 된 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="317047d47afb67f04ec027478f70d7ecc2962ebb" translate="yes" xml:space="preserve">
          <source>A class describing how a stream is to be decoded.</source>
          <target state="translated">스트림의 디코딩 방법을 설명하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c9b6d1a8dfd34b6a2f783596c581d7bf8cfbfa2a" translate="yes" xml:space="preserve">
          <source>A class describing how a stream is to be decoded. Instances of this class or its subclasses are used to supply prescriptive &quot;how-to&quot; information to instances of &lt;code&gt;ImageReader&lt;/code&gt;.</source>
          <target state="translated">스트림의 디코딩 방법을 설명하는 클래스입니다. 이 클래스 또는 서브 클래스의 인스턴스는 &lt;code&gt;ImageReader&lt;/code&gt; 인스턴스에 규범적인 &quot;방법&quot;정보를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bdb5406053749def02227e1d5e2b473d7e57d6aa" translate="yes" xml:space="preserve">
          <source>A class describing how a stream is to be encoded.</source>
          <target state="translated">스트림의 인코딩 방법을 설명하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="eb7e66efcdb5a0340069e0f95db4d8c40901525c" translate="yes" xml:space="preserve">
          <source>A class describing how a stream is to be encoded. Instances of this class or its subclasses are used to supply prescriptive &quot;how-to&quot; information to instances of &lt;code&gt;ImageWriter&lt;/code&gt;.</source>
          <target state="translated">스트림의 인코딩 방법을 설명하는 클래스입니다. 이 클래스 또는 서브 클래스의 인스턴스는 &lt;code&gt;ImageWriter&lt;/code&gt; 인스턴스에 규범적인 &quot;방법&quot;정보를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4cea7f0cea8b3c4c1d900e2c74bafad3d5dc6b1" translate="yes" xml:space="preserve">
          <source>A class encapsulating a single JPEG Huffman table.</source>
          <target state="translated">단일 JPEG Huffman 테이블을 캡슐화하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="321f8c15f8e226bd6268946f3635814d5dc70788" translate="yes" xml:space="preserve">
          <source>A class encapsulating a single JPEG Huffman table. Fields are provided for the &quot;standard&quot; tables taken from Annex K of the JPEG specification. These are the tables used as defaults.</source>
          <target state="translated">단일 JPEG Huffman 테이블을 캡슐화하는 클래스입니다. JPEG 사양의 부록 K에서 가져온 &quot;표준&quot;테이블에 대한 필드가 제공됩니다. 기본값으로 사용되는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="7d0f9ed539cc05958b0c68b8a54ebd530f7cf999" translate="yes" xml:space="preserve">
          <source>A class encapsulating a single JPEG quantization table.</source>
          <target state="translated">단일 JPEG 양자화 테이블을 캡슐화하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9a5e3d73505c4420c99527a5d829a03a35d0ff9c" translate="yes" xml:space="preserve">
          <source>A class encapsulating a single JPEG quantization table. The elements appear in natural order (as opposed to zig-zag order). Static variables are provided for the &quot;standard&quot; tables taken from Annex K of the JPEG specification, as well as the default tables conventionally used for visually lossless encoding.</source>
          <target state="translated">단일 JPEG 양자화 테이블을 캡슐화하는 클래스입니다. 요소는 지그재그 순서와 달리 자연 순서로 나타납니다. 정적 변수는 JPEG 사양의 부록 K에서 가져온 &quot;표준&quot;테이블과 시각적으로 무손실 인코딩에 일반적으로 사용되는 기본 테이블에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d524dbc67636cae0787b2f597b10cfb1ce326300" translate="yes" xml:space="preserve">
          <source>A class for building certification paths (also known as certificate chains).</source>
          <target state="translated">인증 경로를 구축하기위한 클래스 (인증서 체인이라고도 함).</target>
        </trans-unit>
        <trans-unit id="79a919ed13386b15bc475fe84e9d59954394707e" translate="yes" xml:space="preserve">
          <source>A class for retrieving &lt;code&gt;Certificate&lt;/code&gt;s and &lt;code&gt;CRL&lt;/code&gt;s from a repository.</source>
          <target state="translated">저장소에서 &lt;code&gt;Certificate&lt;/code&gt; 및 &lt;code&gt;CRL&lt;/code&gt; 을 검색하기위한 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="ec4b47f315864b8bfb44767c9e4144c8782ed06e" translate="yes" xml:space="preserve">
          <source>A class for validating certification paths (also known as certificate chains).</source>
          <target state="translated">인증 경로를 확인하기위한 클래스 (인증서 체인이라고도 함).</target>
        </trans-unit>
        <trans-unit id="a4826fac13ffcb96ddcf1d4b8835ded2eb4fc3d3" translate="yes" xml:space="preserve">
          <source>A class implementing this interface is an &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;. A Java virtual machine has one or more implementations of this interface. The &lt;a href=&quot;managementfactory#getPlatformMXBeans-java.lang.Class-&quot;&gt;&lt;code&gt;getPlatformMXBeans&lt;/code&gt;&lt;/a&gt; method can be used to obtain the list of &lt;code&gt;BufferPoolMXBean&lt;/code&gt; objects representing the management interfaces for pools of buffers as follows:</source>
          <target state="translated">이 인터페이스를 구현하는 클래스는 &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다. Java 가상 머신에는이 인터페이스의 구현이 하나 이상 있습니다. &lt;a href=&quot;managementfactory#getPlatformMXBeans-java.lang.Class-&quot;&gt; &lt;code&gt;getPlatformMXBeans&lt;/code&gt; 에&lt;/a&gt; 있어서의리스트 취득 할 수 &lt;code&gt;BufferPoolMXBean&lt;/code&gt; 을 다음과 같이 버퍼 풀의 관리 인터페이스를 나타내는 제품 :</target>
        </trans-unit>
        <trans-unit id="3428d317a441756ed9f2c24a1df7a91726e5d72d" translate="yes" xml:space="preserve">
          <source>A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to indicate to the &lt;a href=&quot;object#clone--&quot;&gt;&lt;code&gt;Object.clone()&lt;/code&gt;&lt;/a&gt; method that it is legal for that method to make a field-for-field copy of instances of that class.</source>
          <target state="translated">클래스는 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하여 &lt;a href=&quot;object#clone--&quot;&gt; &lt;code&gt;Object.clone()&lt;/code&gt; &lt;/a&gt; 메소드에 해당 메소드가 해당 클래스의 인스턴스에 대한 필드 필드 사본을 작성하는 것이 합법적임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9c8b9f339d61d938dcccc73bcd63029bdd10d347" translate="yes" xml:space="preserve">
          <source>A class loader is an object that is responsible for loading classes.</source>
          <target state="translated">클래스 로더는 클래스로드를 담당하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9cff8322dc2f981b7001727324b185bd2894264e" translate="yes" xml:space="preserve">
          <source>A class loader is an object that is responsible for loading classes. The class &lt;code&gt;ClassLoader&lt;/code&gt; is an abstract class. Given the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.</source>
          <target state="translated">클래스 로더는 클래스로드를 담당하는 객체입니다. 클래스의 &lt;code&gt;ClassLoader&lt;/code&gt; 추상 클래스입니다. 클래스 의 &lt;a href=&quot;#name&quot;&gt;이진 이름&lt;/a&gt; 이 주어지면 클래스 로더는 클래스의 정의를 구성하는 데이터를 찾거나 생성해야합니다. 일반적인 전략은 이름을 파일 이름으로 변환 한 다음 파일 시스템에서 해당 이름의 &quot;클래스 파일&quot;을 읽는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ce39fd66531a7a384263f9e859092a5c3c09aed" translate="yes" xml:space="preserve">
          <source>A class name pattern can also be empty or the single character &quot;&lt;code&gt;*&lt;/code&gt;&quot;, both of which grant access to any class.</source>
          <target state="translated">클래스 이름 패턴은 비어 있거나 단일 문자 &quot; &lt;code&gt;*&lt;/code&gt; &quot;일 수 있으며 둘 다 클래스에 대한 액세스 권한을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="e317baf1134b30d7d9e54b8f4adcb3831a0e31b4" translate="yes" xml:space="preserve">
          <source>A class not described by a more specific kind (like &lt;code&gt;ENUM&lt;/code&gt;).</source>
          <target state="translated">보다 구체적인 종류로 설명되지 않은 클래스 (예 : &lt;code&gt;ENUM&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc3cd42645526b63c6b87578e25cc1cecfc66711" translate="yes" xml:space="preserve">
          <source>A class or interface type that could not be resolved.</source>
          <target state="translated">확인할 수없는 클래스 또는 인터페이스 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6a03a390b706ffc95966f4d839f5e6763859f7f2" translate="yes" xml:space="preserve">
          <source>A class or interface type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ceaf0ae9fac66af5c5c71328e5f53e64786f589" translate="yes" xml:space="preserve">
          <source>A class representing a mutable reference to an array of bytes and an offset and length within that array.</source>
          <target state="translated">바이트 배열에 대한 변경 가능한 참조와 해당 배열 내의 오프셋 및 길이를 나타내는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4a48a4b9106cdb7952ce705c7bb7a3668a981ba8" translate="yes" xml:space="preserve">
          <source>A class representing a mutable reference to an array of bytes and an offset and length within that array. &lt;code&gt;IIOByteBuffer&lt;/code&gt; is used by &lt;code&gt;ImageInputStream&lt;/code&gt; to supply a sequence of bytes to the caller, possibly with fewer copies than using the conventional &lt;code&gt;read&lt;/code&gt; methods that take a user-supplied byte array.</source>
          <target state="translated">바이트 배열에 대한 변경 가능한 참조와 해당 배열 내의 오프셋 및 길이를 나타내는 클래스입니다. &lt;code&gt;IIOByteBuffer&lt;/code&gt; 는 &lt;code&gt;ImageInputStream&lt;/code&gt; 에서 호출자에게 바이트 시퀀스를 제공하는 데 사용되며 , 사용자가 제공 한 바이트 배열을 사용하는 일반적인 &lt;code&gt;read&lt;/code&gt; 방법을 사용하는 것보다 적은 수의 사본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e9dd636c411f076fe4378038d5f1703cc19f7d24" translate="yes" xml:space="preserve">
          <source>A class representing a node in a meta-data tree, which implements the  &lt;code&gt;org.w3c.dom.Element&lt;/code&gt; interface and additionally allows for the storage of non-textual objects via the &lt;code&gt;getUserObject&lt;/code&gt; and &lt;code&gt;setUserObject&lt;/code&gt; methods.</source>
          <target state="translated">메타 데이터 트리의 노드를 나타내는 클래스로, &lt;code&gt;org.w3c.dom.Element&lt;/code&gt; 인터페이스 를 구현하고 , &lt;code&gt;getUserObject&lt;/code&gt; 및 &lt;code&gt;setUserObject&lt;/code&gt; 메소드 를 통해 텍스트가 아닌 객체를 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0faaa8cb7ea41080a9897a029d07ba7f64951d59" translate="yes" xml:space="preserve">
          <source>A class should implement this interface if it meets three criteria:</source>
          <target state="translated">클래스가 세 가지 기준을 충족하는 경우이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="92346a2f99faeaaa261517e46da5df7b89aef4c7" translate="yes" xml:space="preserve">
          <source>A class that allows the format of an image (in particular, its &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt;) to be specified in a convenient manner.</source>
          <target state="translated">이미지 형식 (특히 &lt;code&gt;SampleModel&lt;/code&gt; 및 &lt;code&gt;ColorModel&lt;/code&gt; )을 편리한 방식으로 지정할 수있는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="9c8e539dbcfd8560d6896c579d5cc9832b8d9d59" translate="yes" xml:space="preserve">
          <source>A class that can be used to compute the Adler-32 checksum of a data stream.</source>
          <target state="translated">데이터 스트림의 Adler-32 체크섬을 계산하는 데 사용할 수있는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="cdd5cc0c0766766349e5a8df9631efc59ea37f9a" translate="yes" xml:space="preserve">
          <source>A class that can be used to compute the Adler-32 checksum of a data stream. An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed much faster.</source>
          <target state="translated">데이터 스트림의 Adler-32 체크섬을 계산하는 데 사용할 수있는 클래스입니다. Adler-32 체크섬은 CRC-32와 거의 비슷하지만 훨씬 빠르게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c514c4d4229f220cdf94ab33ba1f0e3f329c671" translate="yes" xml:space="preserve">
          <source>A class that can be used to compute the CRC-32 of a data stream.</source>
          <target state="translated">데이터 스트림의 CRC-32를 계산하는 데 사용할 수있는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ca6acaf5f47411e180b6a86f697ad80777c28261" translate="yes" xml:space="preserve">
          <source>A class that represents an immutable universally unique identifier (UUID).</source>
          <target state="translated">불변의 UUID (Universally Unique Identifier)를 나타내는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="eb88a241c9240d74a35296b3eb6f058d620a61af" translate="yes" xml:space="preserve">
          <source>A class that represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.</source>
          <target state="translated">불변의 UUID (Universally Unique Identifier)를 나타내는 클래스입니다. UUID는 128 비트 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bca4de61f3be4e6b7ba61ee56e5ad81c0eec2dcc" translate="yes" xml:space="preserve">
          <source>A class which enables secure communications using protocols such as the Secure Sockets Layer (SSL) or &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt; IETF RFC 2246 &quot;Transport Layer Security&quot; (TLS) &lt;/a&gt; protocols, but is transport independent.</source>
          <target state="translated">SSL (Secure Sockets Layer) 또는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;IETF RFC 2246 &quot;TLS (Transport Layer Security)&quot;&lt;/a&gt; 프로토콜과 같은 프로토콜을 사용하여 보안 통신을 가능하게 하지만 전송에 독립적 인 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="21ca1c378b497afd314ff5f225a2637e9eaa55fe" translate="yes" xml:space="preserve">
          <source>A class which extends the &lt;code&gt;EventListenerProxy&lt;/code&gt; specifically for adding a &lt;code&gt;PropertyChangeListener&lt;/code&gt; with a &quot;bound&quot; property.</source>
          <target state="translated">&quot;바운드&quot;속성 으로 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 를 추가하기 위해 &lt;code&gt;EventListenerProxy&lt;/code&gt; 를 확장하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0f3ca17d6fac572ec6a95c1b55d04d926f20879a" translate="yes" xml:space="preserve">
          <source>A class which extends the &lt;code&gt;EventListenerProxy&lt;/code&gt; specifically for adding a &lt;code&gt;PropertyChangeListener&lt;/code&gt; with a &quot;bound&quot; property. Instances of this class can be added as &lt;code&gt;PropertyChangeListener&lt;/code&gt;s to a bean which supports firing property change events.</source>
          <target state="translated">&quot;바운드&quot;속성 으로 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 를 추가하기 위해 &lt;code&gt;EventListenerProxy&lt;/code&gt; 를 확장하는 클래스입니다 . 이 클래스의 인스턴스는 속성 변경 이벤트 발생을 지원하는 Bean에 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0314ff4c39d100d0f62f503ec1527df57cbde8df" translate="yes" xml:space="preserve">
          <source>A class which extends the &lt;code&gt;EventListenerProxy&lt;/code&gt; specifically for adding a &lt;code&gt;VetoableChangeListener&lt;/code&gt; with a &quot;constrained&quot; property.</source>
          <target state="translated">&quot;제한된&quot;속성 으로 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 를 추가하기 위해 &lt;code&gt;EventListenerProxy&lt;/code&gt; 를 확장하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="08dd04ae093513ff4643c0d0511758136f388009" translate="yes" xml:space="preserve">
          <source>A class which extends the &lt;code&gt;EventListenerProxy&lt;/code&gt; specifically for adding a &lt;code&gt;VetoableChangeListener&lt;/code&gt; with a &quot;constrained&quot; property. Instances of this class can be added as &lt;code&gt;VetoableChangeListener&lt;/code&gt;s to a bean which supports firing vetoable change events.</source>
          <target state="translated">&quot;제한된&quot;속성 으로 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 를 추가하기 위해 &lt;code&gt;EventListenerProxy&lt;/code&gt; 를 확장하는 클래스입니다 . 이 클래스의 인스턴스는 거부 가능한 변경 이벤트 발생을 지원하는 Bean에 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 로 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1e64d61b139a3339ef50761bae5d21d454e68e6" translate="yes" xml:space="preserve">
          <source>A client connection has been closed.</source>
          <target state="translated">클라이언트 연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="7b6c01324c3ee4c5d8a2eca046353dc1ea9bd2ae" translate="yes" xml:space="preserve">
          <source>A client connection has failed unexpectedly.</source>
          <target state="translated">클라이언트 연결이 예기치 않게 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="ebbd35c91f41e39a02ce595327e7d60d48a87106" translate="yes" xml:space="preserve">
          <source>A client connection has potentially lost notifications. This notification only appears on the client side.</source>
          <target state="translated">클라이언트 연결에서 잠재적으로 알림이 유실되었습니다. 이 알림은 클라이언트쪽에 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="321eb78d1a8f4a5ebde928ad8b9f55df945982a9" translate="yes" xml:space="preserve">
          <source>A client usually needs to provide more than one processing instruction when submitting a print job. For example, the client might need to specify a media size of A4 and a landscape orientation. To send more than one processing instruction, the client collects the attributes into an attribute set, which the Java Print Service API represents with the &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; interface.</source>
          <target state="translated">클라이언트는 일반적으로 인쇄 작업을 제출할 때 둘 이상의 처리 명령을 제공해야합니다. 예를 들어 클라이언트는 A4의 용지 크기와 가로 방향을 지정해야합니다. 둘 이상의 처리 명령을 전송하기 위해 클라이언트는 속성 세트로 속성을 수집합니다. 속성 세트는 Java Print Service API가 &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; 인터페이스로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0b3646c8eee79de5884011a641b442d887ea986b" translate="yes" xml:space="preserve">
          <source>A clock providing access to the current instant, date and time using a time-zone.</source>
          <target state="translated">시간대를 사용하여 현재 순간, 날짜 및 시간에 액세스 할 수있는 시계입니다.</target>
        </trans-unit>
        <trans-unit id="411022af40541bd60a70533dd8bb81f330bbe450" translate="yes" xml:space="preserve">
          <source>A clock will typically obtain the current instant and then convert that to a date or time using a time-zone. This method returns a clock with similar properties but using a different time-zone.</source>
          <target state="translated">시계는 일반적으로 현재 순간을 얻은 다음 시간대를 사용하여 날짜 또는 시간으로 변환합니다. 이 메서드는 속성은 비슷하지만 시간대는 다른 시계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d73f130682600c047cfb7bb69f8f3922da7e3c8a" translate="yes" xml:space="preserve">
          <source>A clock will typically obtain the current instant and then convert that to a date or time using a time-zone. This method returns the time-zone used.</source>
          <target state="translated">시계는 일반적으로 현재 순간을 얻은 다음 시간대를 사용하여 날짜 또는 시간으로 변환합니다. 이 메소드는 사용 된 시간대를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d032403b72ab32c0db49ce6607f5c43e7ea0265" translate="yes" xml:space="preserve">
          <source>A close square bracket ']'.</source>
          <target state="translated">닫는 대괄호 ']'.</target>
        </trans-unit>
        <trans-unit id="a3167f8e6fb50dd28fb24a3c88ebe100fe20efca" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#div-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;div(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; expression. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#div-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;div(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 표현식을 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb36ba56666bf2d309a7d849a64f0feb91a1c90" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#eq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;eq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; query. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#eq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;eq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 쿼리를 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f3063b18e6a5262c8d2ca620f2e501fed8e478" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#geq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;geq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; query. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#geq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;geq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 쿼리를 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="76157a29212309c8696c9440a7608cee01f04524" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#gt-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;gt(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; query. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#gt-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;gt(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 쿼리를 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaf590563a128b508138fdcf398112e1e233a859" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#leq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;leq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; query. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#leq-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;leq(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 쿼리를 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3e616c5883d2f276fc5ec2915c117e7e83e390d" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#lt-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;lt(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; query. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#lt-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;lt(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 쿼리를 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f32472a91294d62e6f749d86f189b4cf1130071" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#minus-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;minus(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; expression. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#minus-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;minus(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 표현식을 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="131ebaef4e8f0c0eada9e793b43e33f7c63c1497" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#plus-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;plus(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; expression. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#plus-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;plus(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 표현식을 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="086389d031264f0909b42a38a4d40ccaa6ef304e" translate="yes" xml:space="preserve">
          <source>A code representing the &lt;a href=&quot;query#times-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt;&lt;code&gt;times(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt;&lt;/a&gt; expression. This is chiefly of interest for the serialized form of queries.</source>
          <target state="translated">&lt;a href=&quot;query#times-javax.management.ValueExp-javax.management.ValueExp-&quot;&gt; &lt;code&gt;times(javax.management.ValueExp, javax.management.ValueExp)&lt;/code&gt; &lt;/a&gt; 표현식을 나타내는 코드 입니다. 이것은 직렬화 된 형식의 쿼리에 주로 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e046118fc615d90a21c6a38e709d405bcdb107b" translate="yes" xml:space="preserve">
          <source>A coder-result object describing the reason for termination</source>
          <target state="translated">종료 이유를 설명하는 코더 결과 개체</target>
        </trans-unit>
        <trans-unit id="1bc357c45dad65bdc1abef893fd379bb2a9a1253" translate="yes" xml:space="preserve">
          <source>A coder-result object, either &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt;&lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt;&lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt; &lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt; &lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt; &lt;/a&gt; 중 하나 인 코더 결과 개체</target>
        </trans-unit>
        <trans-unit id="6cb44da210a8abf4eb01f4e0b39fcd31491af613" translate="yes" xml:space="preserve">
          <source>A collection adapter &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; is equivalent to one which first &quot;folds&quot; the affected arguments, and then drops them, in separate steps as follows:</source>
          <target state="translated">콜렉션 어댑터 &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; 는 다음과 같이 영향을받는 인수를 먼저 &quot;접은 후&quot;분리하는 단계와 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d53b7ff736eba16937ab8f02218e094fde7b521" translate="yes" xml:space="preserve">
          <source>A collection designed for holding elements prior to processing.</source>
          <target state="translated">처리 전에 요소를 고정하도록 설계된 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="68b3debc55e51d5e6557af0db3301e3ccdcb6461" translate="yes" xml:space="preserve">
          <source>A collection designed for holding elements prior to processing. Besides basic &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; operations, queues provide additional insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted &lt;code&gt;Queue&lt;/code&gt; implementations; in most implementations, insert operations cannot fail.</source>
          <target state="translated">처리 전에 요소를 유지하도록 설계된 컬렉션입니다. 기본 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 작업 외에도 대기열은 추가 삽입, 추출 및 검사 작업을 제공합니다. 이러한 각 메소드는 두 가지 형태로 존재합니다. 하나는 작업이 실패하면 예외가 발생하고 다른 하나는 특수한 값을 반환합니다 ( 작업에 따라 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; ). 후자의 삽입 조작 양식은 용량 제한 &lt;code&gt;Queue&lt;/code&gt; 구현 에 사용하도록 특별히 설계되었습니다 . 대부분의 구현에서 삽입 작업은 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35eecf8b6bf9de4c11825dba857014a73dae84d7" translate="yes" xml:space="preserve">
          <source>A collection that contains no duplicate elements.</source>
          <target state="translated">중복 요소가없는 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="d9305b926296adf001ad4ca75d6bb83b0e0e24fd" translate="yes" xml:space="preserve">
          <source>A collection that contains no duplicate elements. More formally, sets contain no pair of elements &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; such that &lt;code&gt;e1.equals(e2)&lt;/code&gt;, and at most one null element. As implied by its name, this interface models the mathematical</source>
          <target state="translated">중복 요소가없는 컬렉션입니다. 더 공식적으로, 세트에는 &lt;code&gt;e1.equals(e2)&lt;/code&gt; 와 같은 요소 &lt;code&gt;e1&lt;/code&gt; 및 &lt;code&gt;e2&lt;/code&gt; 쌍이없고 최대 하나의 null 요소가 포함됩니다. 이름에서 알 수 있듯이이 인터페이스는 수학을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="e30d7f9b91d5a7ffab48faee759b58d4ae7bc7c2" translate="yes" xml:space="preserve">
          <source>A colon</source>
          <target state="translated">콜론</target>
        </trans-unit>
        <trans-unit id="a5774fa8d9c069418206ed483e2ca2f3cf35a52d" translate="yes" xml:space="preserve">
          <source>A colon (&lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">콜론 ( &lt;code&gt;:&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3014f21a6bc8bc6dcb869994f59c9558c53b7eb" translate="yes" xml:space="preserve">
          <source>A comma</source>
          <target state="translated">쉼표</target>
        </trans-unit>
        <trans-unit id="58bed6c2bf813dbd5b59b07d5f4ba3ec11ec7f9e" translate="yes" xml:space="preserve">
          <source>A comma-separated list of &lt;code&gt;.jar&lt;/code&gt; file names.</source>
          <target state="translated">&lt;code&gt;.jar&lt;/code&gt; 파일 이름 의 쉼표로 구분 된 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="69b0d2636d902fad23aed7fa5d62125f0203e8ab" translate="yes" xml:space="preserve">
          <source>A common interface for all entities that declare type variables.</source>
          <target state="translated">유형 변수를 선언하는 모든 엔티티에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="7b03fd8af749e1a3ce6657ea29c356afa369685b" translate="yes" xml:space="preserve">
          <source>A common superclass for those exceptions allows a single catch block to have code handling them uniformly.</source>
          <target state="translated">이러한 예외에 대한 공통 수퍼 클래스를 사용하면 단일 catch 블록이 코드를 균일하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2eb4eb16e9b666e1d02dd5dca1670d20c9c93d" translate="yes" xml:space="preserve">
          <source>A common use for this attribute will be applications which want to redirect output to a local disk file : eg.&quot;file:out.prn&quot;. Note that proper construction of &quot;file:&quot; scheme URI instances should be performed using the &lt;code&gt;toURI()&lt;/code&gt; method of class &lt;a href=&quot;../../../../java/io/file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;. See the documentation on that class for more information.</source>
          <target state="translated">이 속성의 일반적인 사용은 출력을 로컬 디스크 파일 (예 : &quot;file : out.prn&quot;)로 리디렉션하려는 응용 프로그램입니다. &quot;file :&quot;스킴 URI 인스턴스의 올바른 구성은 &lt;a href=&quot;../../../../java/io/file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;code&gt;toURI()&lt;/code&gt; 메소드를 사용하여 수행해야합니다 . 자세한 내용은 해당 클래스의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b812460359ac28696c5c53d6194bcc0b4e3e6d4b" translate="yes" xml:space="preserve">
          <source>A comparator that imposes the reverse of the</source>
          <target state="translated">의 반대를 부과하는 비교기</target>
        </trans-unit>
        <trans-unit id="b1069285dcf5aa4a511fd41ed7ca14c6e2a346c9" translate="yes" xml:space="preserve">
          <source>A comparator that imposes the reverse ordering of the specified comparator.</source>
          <target state="translated">지정된 비교기의 역순을 부과하는 비교기.</target>
        </trans-unit>
        <trans-unit id="88cbfaab6cde9461570cfd17bac039d6f107d7c6" translate="yes" xml:space="preserve">
          <source>A comparison function, which imposes a</source>
          <target state="translated">를 비교하는 비교 함수</target>
        </trans-unit>
        <trans-unit id="8611f588b20f634a35201b6faa98a5b6fa04b35e" translate="yes" xml:space="preserve">
          <source>A compiled representation of a regular expression.</source>
          <target state="translated">정규식의 컴파일 된 표현.</target>
        </trans-unit>
        <trans-unit id="507982c243d52965e48c7b0732508c6ac665735a" translate="yes" xml:space="preserve">
          <source>A compiler tool has an associated standard file manager, which is the file manager that is native to the tool (or built-in). The standard file manager can be obtained by calling &lt;a href=&quot;javacompiler#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-&quot;&gt;getStandardFileManager&lt;/a&gt;.</source>
          <target state="translated">컴파일러 도구에는 도구 (또는 기본 제공 도구)의 기본 파일 관리자 인 관련 표준 파일 관리자가 있습니다. 표준 파일 관리자는 &lt;a href=&quot;javacompiler#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-&quot;&gt;getStandardFileManager&lt;/a&gt; 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a22de5f7495f42b8eb96d0161f9be3e98aab30a9" translate="yes" xml:space="preserve">
          <source>A compiler tool must function with any file manager as long as any additional requirements as detailed in the methods below are met. If no file manager is provided, the compiler tool will use a standard file manager such as the one returned by &lt;a href=&quot;javacompiler#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-&quot;&gt;getStandardFileManager&lt;/a&gt;.</source>
          <target state="translated">아래 방법에 설명 된 추가 요구 사항이 충족되는 한 컴파일러 도구는 모든 파일 관리자와 함께 작동해야합니다. 파일 관리자가 제공되지 않으면 컴파일러 도구는 &lt;a href=&quot;javacompiler#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-&quot;&gt;getStandardFileManager가&lt;/a&gt; 리턴 한 것과 같은 표준 파일 관리자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c8340a51d99720fe0c029bc676ff25eb592e4528" translate="yes" xml:space="preserve">
          <source>A compiler-specific value, or &lt;code&gt;null&lt;/code&gt; if no compiler is available</source>
          <target state="translated">컴파일러 고유의 값. 사용 가능한 컴파일러가 &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="679d259c58ee38716564f2caf4e42a4aa66a6aa4" translate="yes" xml:space="preserve">
          <source>A component may be left undefined by passing &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 을 건네 주어 컴퍼넌트는 정의되지 않은 채로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c240d3ac3169c5fa449a090551b1533296f8d47e" translate="yes" xml:space="preserve">
          <source>A composite name consisting of the components at indexes in the range [0,posn).</source>
          <target state="translated">[0, posn) 범위의 인덱스에있는 구성 요소로 구성된 복합 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e307b9d7fcecb7e46cc83b164a05b08703be2f60" translate="yes" xml:space="preserve">
          <source>A composite name consisting of the components at indexes in the range [posn,size()). If posn is equal to size(), an empty composite name is returned.</source>
          <target state="translated">[posn, size ()) 범위의 인덱스에있는 구성 요소로 구성된 복합 이름입니다. posn이 size ()와 같으면 빈 복합 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="388d169a4059ab43399d30021348063b4a944861" translate="yes" xml:space="preserve">
          <source>A compound name consisting of the components at indexes in the range [0,posn).</source>
          <target state="translated">[0, posn) 범위의 색인에있는 구성 요소로 구성된 복합 이름입니다.</target>
        </trans-unit>
        <trans-unit id="76c4e0dce25522531bae9b9e60264ef59857ae2b" translate="yes" xml:space="preserve">
          <source>A compound name consisting of the components at indexes in the range [posn,size()). If posn is equal to size(), an empty compound name is returned.</source>
          <target state="translated">[posn, size ()) 범위의 색인에있는 구성 요소로 구성된 복합 이름입니다. posn이 size ()와 같으면 빈 복합 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="870a4660763c1f34e013dffa68e06e176fa3b5fb" translate="yes" xml:space="preserve">
          <source>A compression quality setting of 0.0 is most generically interpreted as &quot;high compression is important,&quot; while a setting of 1.0 is most generically interpreted as &quot;high image quality is important.&quot;</source>
          <target state="translated">압축 품질 설정 0.0은 가장 일반적으로 &quot;높은 압축이 중요&quot;으로 해석되는 반면, 1.0 설정은 가장 일반적으로 &quot;높은 이미지 품질이 중요&quot;으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e55237d8b1c126bd419cb998c4d2143c21b0a60c" translate="yes" xml:space="preserve">
          <source>A computation to be performed with privileges enabled, that throws one or more checked exceptions.</source>
          <target state="translated">하나 이상의 확인 된 예외를 발생시키는 권한을 사용하여 수행 할 계산입니다.</target>
        </trans-unit>
        <trans-unit id="df5aa60f9378ed72d43eb803f402550168f3ddfe" translate="yes" xml:space="preserve">
          <source>A computation to be performed with privileges enabled, that throws one or more checked exceptions. The computation is performed by invoking &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; on the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; object. This interface is used only for computations that throw checked exceptions; computations that do not throw checked exceptions should use &lt;code&gt;PrivilegedAction&lt;/code&gt; instead.</source>
          <target state="translated">하나 이상의 확인 된 예외를 발생시키는 권한을 사용하여 수행 할 계산입니다. &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 객체 에서 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 를 호출하여 계산을 수행 합니다. 이 인터페이스는 확인 된 예외를 발생시키는 계산에만 사용됩니다. 확인 된 예외를 발생시키지 않는 계산은 &lt;code&gt;PrivilegedAction&lt;/code&gt; 을 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="53d6bfa858b3f3fb8deab95e04cbb70669ba6ea2" translate="yes" xml:space="preserve">
          <source>A computation to be performed with privileges enabled.</source>
          <target state="translated">권한이 활성화 된 상태에서 수행 할 계산입니다.</target>
        </trans-unit>
        <trans-unit id="a84d8847cd9be7eb09312d16b993c90bbee17967" translate="yes" xml:space="preserve">
          <source>A computation to be performed with privileges enabled. The computation is performed by invoking &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; on the &lt;code&gt;PrivilegedAction&lt;/code&gt; object. This interface is used only for computations that do not throw checked exceptions; computations that throw checked exceptions must use &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; instead.</source>
          <target state="translated">권한이 활성화 된 상태에서 수행 할 계산입니다. &lt;code&gt;PrivilegedAction&lt;/code&gt; 객체 에서 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 를 호출하여 계산을 수행 합니다. 이 인터페이스는 확인 된 예외를 발생시키지 않는 계산에만 사용됩니다. 검사 된 예외를 발생시키는 계산은 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 을 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="592ff92d53f5fd5d1113ffb2481eaf8c68991cfb" translate="yes" xml:space="preserve">
          <source>A concrete CountedCompleter class must define method &lt;a href=&quot;countedcompleter#compute--&quot;&gt;&lt;code&gt;compute()&lt;/code&gt;&lt;/a&gt;, that should in most cases (as illustrated below), invoke &lt;code&gt;tryComplete()&lt;/code&gt; once before returning. The class may also optionally override method &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; to perform an action upon normal completion, and method &lt;a href=&quot;countedcompleter#onExceptionalCompletion-java.lang.Throwable-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onExceptionalCompletion(Throwable, CountedCompleter)&lt;/code&gt;&lt;/a&gt; to perform an action upon any exception.</source>
          <target state="translated">구체적인 CountedCompleter 클래스는 대부분의 경우 (아래 그림 참조) 반환하기 전에 &lt;code&gt;tryComplete()&lt;/code&gt; 한 번 호출 해야하는 &lt;a href=&quot;countedcompleter#compute--&quot;&gt; &lt;code&gt;compute()&lt;/code&gt; &lt;/a&gt; 메소드를 정의해야합니다 . 클래스는 선택적으로 &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; 메소드를 대체 하여 정상 완료시 조치를 수행하고 &lt;a href=&quot;countedcompleter#onExceptionalCompletion-java.lang.Throwable-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onExceptionalCompletion(Throwable, CountedCompleter)&lt;/code&gt; &lt;/a&gt; 메소드를 대체 하여 예외에 대한 조치를 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5d3b0a75ab72fca28782e0f37995ed37f00346" translate="yes" xml:space="preserve">
          <source>A concrete channel class must also implement the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in such a way that if it is invoked while another thread is blocked in a native I/O operation upon the channel then that operation will immediately return, either by throwing an exception or by returning normally. If a thread is interrupted or the channel upon which it is blocked is asynchronously closed then the channel's &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method will throw the appropriate exception.</source>
          <target state="translated">또한 구체적인 채널 클래스는 다른 스레드가 호출 될 때 다른 스레드가 채널의 원시 I / O 작업에서 차단 된 경우 예외를 발생 시키거나 정상적으로 반환하여 해당 작업이 즉시 반환 되도록 &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메소드를 구현해야 합니다. . 스레드가 중단되거나 스레드가 차단 된 채널이 비동기 적으로 닫힌 경우 채널의 &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드는 적절한 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f923d4960b765d0c3f8ba0b31067d29761b88f04" translate="yes" xml:space="preserve">
          <source>A concrete class providing a reusable implementation of the &lt;code&gt;IIOMetadataFormat&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 인터페이스 의 재사용 가능한 구현을 제공하는 구체적 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="d282fdf80a823d1b9ce109892a02adada32f1789" translate="yes" xml:space="preserve">
          <source>A concrete class providing a reusable implementation of the &lt;code&gt;IIOMetadataFormat&lt;/code&gt; interface. In addition, a static instance representing the standard, plug-in neutral &lt;code&gt;javax_imageio_1.0&lt;/code&gt; format is provided by the &lt;code&gt;getStandardFormatInstance&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 인터페이스 의 재사용 가능한 구현을 제공하는 구체적 클래스 입니다. 또한 표준 플러그인 중립 &lt;code&gt;javax_imageio_1.0&lt;/code&gt; 형식을 나타내는 정적 인스턴스는 &lt;code&gt;getStandardFormatInstance&lt;/code&gt; 메소드에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="712749aaea88a267414698100643df70c8e94b89" translate="yes" xml:space="preserve">
          <source>A concrete implementation of the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; class can be created to extend the PKIX certification path validation algorithm. For example, an implementation may check for and process a critical private extension of each certificate in a certification path.</source>
          <target state="translated">PKIX 인증 경로 확인 알고리즘을 확장하기 위해 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 클래스 의 구체적인 구현을 작성할 수 있습니다. 예를 들어, 구현시 인증 경로에서 각 인증서의 중요한 개인 확장을 확인하고 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8f023ff523d8ca2174982322b18fc912277484" translate="yes" xml:space="preserve">
          <source>A concrete provider class cannot be instantiated; or</source>
          <target state="translated">구체적 제공자 클래스는 인스턴스화 할 수 없습니다. 또는</target>
        </trans-unit>
        <trans-unit id="cc3f133bae4475dd14d8dd56a065e5893f608a9b" translate="yes" xml:space="preserve">
          <source>A concrete provider class is not a subclass of the service class;</source>
          <target state="translated">구체적 제공자 클래스는 서비스 클래스의 서브 클래스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3f8ded546ab785eb4d9c3cb4e994d57af15e27e9" translate="yes" xml:space="preserve">
          <source>A concrete provider class named in a provider-configuration file cannot be found;</source>
          <target state="translated">제공자 구성 파일에 이름 지정된 구체적 제공자 클래스를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4759012fd2d12d2910e6e9a75125a735e1330fd" translate="yes" xml:space="preserve">
          <source>A connection to a remote RMI connector.</source>
          <target state="translated">원격 RMI 커넥터에 연결</target>
        </trans-unit>
        <trans-unit id="5281da5fc208b5e3d2084885ed1d79b4dffb1e6b" translate="yes" xml:space="preserve">
          <source>A connection to a remote RMI connector. Usually, such connections are made using &lt;a href=&quot;../jmxconnectorfactory&quot;&gt;&lt;code&gt;JMXConnectorFactory&lt;/code&gt;&lt;/a&gt;. However, specialized applications can use this class directly, for example with an &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; stub obtained without going through JNDI.</source>
          <target state="translated">원격 RMI 커넥터에 연결 일반적으로 이러한 연결은 &lt;a href=&quot;../jmxconnectorfactory&quot;&gt; &lt;code&gt;JMXConnectorFactory&lt;/code&gt; 를&lt;/a&gt; 사용하여 이루어집니다 . 그러나 특수 응용 프로그램은이 클래스를 직접 사용할 수 있습니다 (예 : JNDI를 거치지 않고 얻은 &lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; 스텁).</target>
        </trans-unit>
        <trans-unit id="dc1d7a566611a4eca771151edadc407ccf141315" translate="yes" xml:space="preserve">
          <source>A connector client is usually created by supplying the &lt;code&gt;JMXServiceURL&lt;/code&gt; of the connector server to connect to to the &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">커넥터 클라이언트는 일반적으로 &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect&lt;/code&gt; &lt;/a&gt; 메소드 에 연결하기 위해 커넥터 서버 의 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 제공하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="65172dc0939a2899342cf72ef4c3f4d5e6170f30" translate="yes" xml:space="preserve">
          <source>A connector makes an MBean server remotely accessible through a given protocol. The JMX Remote API allows the use of different type of connectors:</source>
          <target state="translated">커넥터는 지정된 프로토콜을 통해 MBean 서버에 원격으로 액세스 할 수있게합니다. JMX Remote API를 사용하면 다양한 유형의 커넥터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b06816216886f3a82230d72723751d319943331" translate="yes" xml:space="preserve">
          <source>A connector server for which this is inappropriate must override this method so that it either implements the appropriate logic or throws &lt;a href=&quot;../../../java/lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부적절한 커넥터 서버는 적절한 로직을 구현하거나 &lt;a href=&quot;../../../java/lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시키도록이 메소드를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc00c2f98497585b47c3192d00eadd75676cea50" translate="yes" xml:space="preserve">
          <source>A connector server is associated with an MBean server either by registering it in that MBean server, or by passing the MBean server to its constructor.</source>
          <target state="translated">커넥터 서버는 MBean 서버에 등록하거나 MBean 서버를 생성자에 전달하여 MBean 서버와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="fd981a4467010ba08d191c25715b89bbb07202d0" translate="yes" xml:space="preserve">
          <source>A connector server is created by constructing an instance of a subclass of &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. Usually, this instance is created using the method &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커넥터 서버는 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스를 구성하여 작성됩니다 . 일반적으로이 인스턴스는 &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="729de493400b8161527e266d3a8c893c12cafa51" translate="yes" xml:space="preserve">
          <source>A connector server is inactive when created. It only starts listening for client connections when the &lt;a href=&quot;jmxconnectorservermbean#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method is called. A connector server stops listening for client connections when the &lt;a href=&quot;jmxconnectorservermbean#stop--&quot;&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/a&gt; method is called or when the connector server is unregistered from its MBean server.</source>
          <target state="translated">커넥터 서버를 만들 때 비활성화됩니다. &lt;a href=&quot;jmxconnectorservermbean#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때만 클라이언트 연결 청취를 시작 합니다. &lt;a href=&quot;jmxconnectorservermbean#stop--&quot;&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/a&gt; 메소드가 호출되거나 커넥터 서버가 MBean 서버에서 등록 취소되면 커넥터 서버는 클라이언트 연결 청취를 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="b4357533106a251a960a61dd27d9689023c47e50" translate="yes" xml:space="preserve">
          <source>A consecutive sequence of decimal digits is treated as a decimal number:</source>
          <target state="translated">연속적인 10 진수 시퀀스는 10 진수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b50e7d81381adb7c96ec61ab5d96776c14c3174c" translate="yes" xml:space="preserve">
          <source>A consecutive sequence of letters is regarded as a word and treated as follows:</source>
          <target state="translated">연속 된 문자 순서는 단어로 간주되며 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c154b2d7544e9e17d7ac9c57de6d6ed0d852b19a" translate="yes" xml:space="preserve">
          <source>A consequence of the use of &lt;code&gt;ScheduledFuture&lt;/code&gt; objects is that &lt;a href=&quot;threadpoolexecutor#afterExecute-java.lang.Runnable-java.lang.Throwable-&quot;&gt;&lt;code&gt;afterExecute&lt;/code&gt;&lt;/a&gt; is always called with a null second &lt;code&gt;Throwable&lt;/code&gt; argument, even if the &lt;code&gt;command&lt;/code&gt; terminated abruptly. Instead, the &lt;code&gt;Throwable&lt;/code&gt; thrown by such a task can be obtained via &lt;a href=&quot;future#get--&quot;&gt;&lt;code&gt;Future.get()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ScheduledFuture&lt;/code&gt; 객체를 사용 하면 &lt;code&gt;command&lt;/code&gt; 이 갑자기 종료 되더라도 &lt;a href=&quot;threadpoolexecutor#afterExecute-java.lang.Runnable-java.lang.Throwable-&quot;&gt; &lt;code&gt;afterExecute&lt;/code&gt; &lt;/a&gt; 가 항상 null Second &lt;code&gt;Throwable&lt;/code&gt; 인수 와 함께 호출됩니다 . 대신, 그러한 작업에 의해 발생되는 &lt;code&gt;Throwable&lt;/code&gt; 은 &lt;a href=&quot;future#get--&quot;&gt; &lt;code&gt;Future.get()&lt;/code&gt; &lt;/a&gt; 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="622ec8aa9696f49b5a1d49f1ec97d4e475ae08b1" translate="yes" xml:space="preserve">
          <source>A constant for a period of zero.</source>
          <target state="translated">기간이 0 인 상수.</target>
        </trans-unit>
        <trans-unit id="408ab1d95aeb7f78d5620b36adb094b5f8e386ed" translate="yes" xml:space="preserve">
          <source>A constant holding a Not-a-Number (NaN) value of type &lt;code&gt;double&lt;/code&gt;. It is equivalent to the value returned by &lt;code&gt;Double.longBitsToDouble(0x7ff8000000000000L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 유형의 NaN (Not-a-Number) 값을 보유하는 상수 입니다. &lt;code&gt;Double.longBitsToDouble(0x7ff8000000000000L)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7a9f41909332598bf0fe8a6b6c7e05fcc54b78f8" translate="yes" xml:space="preserve">
          <source>A constant holding a Not-a-Number (NaN) value of type &lt;code&gt;float&lt;/code&gt;. It is equivalent to the value returned by &lt;code&gt;Float.intBitsToFloat(0x7fc00000)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 NaN (Not-a-Number) 값을 보유하는 상수 입니다. &lt;code&gt;Float.intBitsToFloat(0x7fc00000)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c2370477399c9d24edd4e5ac9a5b7d569b9b314b" translate="yes" xml:space="preserve">
          <source>A constant holding the largest positive finite value of type &lt;code&gt;double&lt;/code&gt;, (2-2&lt;sup&gt;-52&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;1023&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x1.fffffffffffffP+1023&lt;/code&gt; and also equal to &lt;code&gt;Double.longBitsToDouble(0x7fefffffffffffffL)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 형의 최대 양의 유한 유한 값 (2-2 &lt;sup&gt;-52&lt;/sup&gt; ) &amp;middot; 2 &lt;sup&gt;1023을&lt;/sup&gt; 유지하는 상수 입니다. 16 진 부동 소수점 리터럴 &lt;code&gt;0x1.fffffffffffffP+1023&lt;/code&gt; 과 같 &lt;code&gt;Double.longBitsToDouble(0x7fefffffffffffffL)&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1559c3190af98081a3a4166e36cd940881955573" translate="yes" xml:space="preserve">
          <source>A constant holding the largest positive finite value of type &lt;code&gt;float&lt;/code&gt;, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x1.fffffeP+127f&lt;/code&gt; and also equal to &lt;code&gt;Float.intBitsToFloat(0x7f7fffff)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 최대 양의 유한 유한 값 (2-2 &lt;sup&gt;-23&lt;/sup&gt; ) &amp;middot; 2 &lt;sup&gt;127을&lt;/sup&gt; 유지하는 상수 입니다. 16 진 부동 소수점 리터럴 &lt;code&gt;0x1.fffffeP+127f&lt;/code&gt; 와 같고 &lt;code&gt;Float.intBitsToFloat(0x7f7fffff)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="aa45635c3dac94b3e1415bc2816262b93420be17" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value a &lt;code&gt;byte&lt;/code&gt; can have, 2&lt;sup&gt;7&lt;/sup&gt;-1.</source>
          <target state="translated">&lt;code&gt;byte&lt;/code&gt; 가 가질 수 있는 최대 값을 보유하는 상수 는 2 &lt;sup&gt;7&lt;/sup&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="c81538130b7723dffb4e565ca4c43f81ab349db0" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value a &lt;code&gt;long&lt;/code&gt; can have, 2&lt;sup&gt;63&lt;/sup&gt;-1.</source>
          <target state="translated">최대 값을 &lt;code&gt;long&lt;/code&gt; 유지하는 상수 는 2 &lt;sup&gt;63&lt;/sup&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="a20a77b22599d89aa750f87d3b8f6393a31871b6" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value a &lt;code&gt;short&lt;/code&gt; can have, 2&lt;sup&gt;15&lt;/sup&gt;-1.</source>
          <target state="translated">최대 값을 &lt;code&gt;short&lt;/code&gt; 유지하는 상수 는 2 &lt;sup&gt;15&lt;/sup&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="89f6fa143f9ec2f083ee659804ad1b8c50e1db45" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an &lt;code&gt;int&lt;/code&gt; can have, 2&lt;sup&gt;31&lt;/sup&gt;-1.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 가 가질 수 있는 최대 값을 유지하는 상수 는 2 &lt;sup&gt;31&lt;/sup&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="213c983a4885ceaaad32258ba70bcf2aca3ef5ce" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value of weight, 1.0, which indicates that the language range is a good fit for the user.</source>
          <target state="translated">최대 가중치 1.0을 유지하는 상수는 언어 범위가 사용자에게 적합 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="195e5bbc3041eea84adab54a11e575298b1c41cf" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value a &lt;code&gt;byte&lt;/code&gt; can have, -2&lt;sup&gt;7&lt;/sup&gt;.</source>
          <target state="translated">최소값 들고 상수는 &lt;code&gt;byte&lt;/code&gt; 가질 수 -2 &lt;sup&gt;7&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="52acf66e806a2a273588e0eb3f8f800460ba9f69" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value a &lt;code&gt;long&lt;/code&gt; can have, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="translated">최소값을 &lt;code&gt;long&lt;/code&gt; 유지하는 상수 는 -2 &lt;sup&gt;63&lt;/sup&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d88b8661d44e693837e8dcbbb8ad71a38058f36b" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value a &lt;code&gt;short&lt;/code&gt; can have, -2&lt;sup&gt;15&lt;/sup&gt;.</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; 를 가질 수 있는 최소값을 유지하는 상수 는 -2 &lt;sup&gt;15&lt;/sup&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd86206e57defe248bbdbdca1a38c5b7fe7516c3" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an &lt;code&gt;int&lt;/code&gt; can have, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="translated">최소값 들고 상수는 &lt;code&gt;int&lt;/code&gt; 가질 수 -2 &lt;sup&gt;31&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="366d749bc03e21a5730979c744989b2ca9b9b0f7" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value of weight, 0.0, which indicates that the language range is not a good fit for the user.</source>
          <target state="translated">최소 가중치 0.0을 유지하는 상수는 언어 범위가 사용자에게 적합하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03a6d5a6655c2a060db44ef940b07a63cb0d9b15" translate="yes" xml:space="preserve">
          <source>A constant holding the negative infinity of type &lt;code&gt;double&lt;/code&gt;. It is equal to the value returned by &lt;code&gt;Double.longBitsToDouble(0xfff0000000000000L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 형의 부의 무한대를 보관 유지하는 정수 입니다. &lt;code&gt;Double.longBitsToDouble(0xfff0000000000000L)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="562f4fa39e792042eda77256d90f71f667f9cb4d" translate="yes" xml:space="preserve">
          <source>A constant holding the negative infinity of type &lt;code&gt;float&lt;/code&gt;. It is equal to the value returned by &lt;code&gt;Float.intBitsToFloat(0xff800000)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 형의 부의 무한대를 보관 유지하는 정수 입니다. &lt;code&gt;Float.intBitsToFloat(0xff800000)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="89bdfdbbe53820259637babc21d8836fd71ccc85" translate="yes" xml:space="preserve">
          <source>A constant holding the positive infinity of type &lt;code&gt;double&lt;/code&gt;. It is equal to the value returned by &lt;code&gt;Double.longBitsToDouble(0x7ff0000000000000L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 형의 정의 무한대를 보관 유지하는 정수 입니다. &lt;code&gt;Double.longBitsToDouble(0x7ff0000000000000L)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e4edd55348f3bbcf29f947e2199d27f6106b6d21" translate="yes" xml:space="preserve">
          <source>A constant holding the positive infinity of type &lt;code&gt;float&lt;/code&gt;. It is equal to the value returned by &lt;code&gt;Float.intBitsToFloat(0x7f800000)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 형의 정의 무한대를 보관 유지하는 정수 입니다. &lt;code&gt;Float.intBitsToFloat(0x7f800000)&lt;/code&gt; 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="997f769b40571ffd14031483d8e7531f40e5ad0f" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest positive nonzero value of type &lt;code&gt;double&lt;/code&gt;, 2&lt;sup&gt;-1074&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x0.0000000000001P-1022&lt;/code&gt; and also equal to &lt;code&gt;Double.longBitsToDouble(0x1L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 유형의 최소 양수가 아닌 0 , &lt;sup&gt;2-1074&lt;/sup&gt; 값을 보유하는 상수 &lt;sup&gt;입니다&lt;/sup&gt; . 16 진 부동 소수점 리터럴 &lt;code&gt;0x0.0000000000001P-1022&lt;/code&gt; 와 같 &lt;code&gt;Double.longBitsToDouble(0x1L)&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="31f87b77b0b8567fdb51e96a07e699ba219f199a" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest positive nonzero value of type &lt;code&gt;float&lt;/code&gt;, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x0.000002P-126f&lt;/code&gt; and also equal to &lt;code&gt;Float.intBitsToFloat(0x1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 0이 아닌 양수가 아닌 최소값 2 &lt;sup&gt;-149를&lt;/sup&gt; 유지하는 상수 입니다. 16 진 부동 소수점 리터럴 &lt;code&gt;0x0.000002P-126f&lt;/code&gt; 와 같고 &lt;code&gt;Float.intBitsToFloat(0x1)&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="43ac95af04530b21424fe9fe4d0d50cb98b1f66e" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest positive normal value of type &lt;code&gt;double&lt;/code&gt;, 2&lt;sup&gt;-1022&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x1.0p-1022&lt;/code&gt; and also equal to &lt;code&gt;Double.longBitsToDouble(0x0010000000000000L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 유형의 최소 양수 정상 값 2 &lt;sup&gt;-1022를&lt;/sup&gt; 유지하는 상수 입니다. 16 진 부동 소수점 리터럴 &lt;code&gt;0x1.0p-1022&lt;/code&gt; 와 같고 &lt;code&gt;Double.longBitsToDouble(0x0010000000000000L)&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="981c4e581250bfe1199ccc6d949a0d2120c2ca33" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest positive normal value of type &lt;code&gt;float&lt;/code&gt;, 2&lt;sup&gt;-126&lt;/sup&gt;. It is equal to the hexadecimal floating-point literal &lt;code&gt;0x1.0p-126f&lt;/code&gt; and also equal to &lt;code&gt;Float.intBitsToFloat(0x00800000)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 최소 양수 정상 값 2 &lt;sup&gt;-126을&lt;/sup&gt; 유지하는 상수 입니다. 16 진 부동 소수점 리터럴 &lt;code&gt;0x1.0p-126f&lt;/code&gt; 와 같고 &lt;code&gt;Float.intBitsToFloat(0x00800000)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="56d934c7a517e9935eda91929df3ed1fbd67c0e3" translate="yes" xml:space="preserve">
          <source>A constant indicating that a number token has been read.</source>
          <target state="translated">숫자 토큰을 읽었 음을 나타내는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="648ea7585761892bba4a14317322b6419df48f35" translate="yes" xml:space="preserve">
          <source>A constant indicating that a word token has been read.</source>
          <target state="translated">단어 토큰을 읽었 음을 나타내는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b15777e7d884a405608153040cd013c01f5d0b33" translate="yes" xml:space="preserve">
          <source>A constant indicating that the end of the line has been read.</source>
          <target state="translated">행의 끝을 읽었 음을 나타내는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="3e9ce93a619d65834f17595305fc77f97a49324d" translate="yes" xml:space="preserve">
          <source>A constant indicating that the end of the stream has been read.</source>
          <target state="translated">스트림의 끝을 읽었 음을 나타내는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="05fd9daac8cc107ac74022f8e6a431daa3310be1" translate="yes" xml:space="preserve">
          <source>A constant pool index does not refer to a UTF-8 entry</source>
          <target state="translated">상수 풀 인덱스는 UTF-8 항목을 참조하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6b17d0eb335bec84834c46dc6002183dea1ae9ba" translate="yes" xml:space="preserve">
          <source>A constant pool index is out of bounds.</source>
          <target state="translated">상수 풀 인덱스가 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="b83da880fe62fcf431fa2b80b966091f24e6c21a" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeDataType&lt;/code&gt; indicating that the value of an attribute is a general Unicode string.</source>
          <target state="translated">속성 값이 일반 유니 코드 문자열임을 나타내는 &lt;code&gt;getAttributeDataType&lt;/code&gt; 에 의해 리턴되는 상수 .</target>
        </trans-unit>
        <trans-unit id="7e64a1186b69b4d433ea2f6a6e2d5e8963e0b2a9" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeDataType&lt;/code&gt; indicating that the value of an attribute is a string representation of a decimal floating-point number.</source>
          <target state="translated">속성 값이 10 진 부동 소수점 숫자의 문자열 표현임을 나타내는 &lt;code&gt;getAttributeDataType&lt;/code&gt; 에 의해 리턴되는 상수 .</target>
        </trans-unit>
        <trans-unit id="ab34a89f1927a75ce08a7f8cd06fc8745928ab5f" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeDataType&lt;/code&gt; indicating that the value of an attribute is a string representation of a double-precision decimal floating-point number.</source>
          <target state="translated">속성 값이 배정도 십진 부동 소수점 숫자의 문자열 표현임을 나타내는 &lt;code&gt;getAttributeDataType&lt;/code&gt; 에 의해 리턴되는 상수 .</target>
        </trans-unit>
        <trans-unit id="1dc9d55cfd527b1e9a8494e21da70bbc73b4a0ca" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeDataType&lt;/code&gt; indicating that the value of an attribute is a string representation of an integer.</source>
          <target state="translated">속성의 값이 정수의 캐릭터 라인 표현 인 것을 나타내는 &lt;code&gt;getAttributeDataType&lt;/code&gt; 로부터 반환되는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="9c7921138692ad31aed03ed87a2c18d7559fa6f8" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeDataType&lt;/code&gt; indicating that the value of an attribute is one of the boolean values 'true' or 'false'. Attribute values of type DATATYPE_BOOLEAN should be marked as enumerations, and the permitted values should be the string literal values &quot;TRUE&quot; or &quot;FALSE&quot;, although a plugin may also recognise lower or mixed case equivalents.</source>
          <target state="translated">속성의 값이 부울 값 'true'또는 'false'중 하나임을 나타내는 &lt;code&gt;getAttributeDataType&lt;/code&gt; 에 의해 리턴되는 상수 . 유형이 DATATYPE_BOOLEAN 인 속성 값은 열거로 표시되어야하며, 허용되는 값은 문자열 리터럴 값 &quot;TRUE&quot;또는 &quot;FALSE&quot;여야하지만, 플러그인은 대소 문자가 동등한 문자를 인식 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="536b4870053ade20fbb0746b24a7e47d769bbe9e" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set a range of values. Both the minimum and maximum values of the range are exclusive. It is recommended that ranges of integers be inclusive on both ends, and that exclusive ranges be used only for floating-point data.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 값 범위를 설정할 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 범위의 최소값과 최대 값이 모두 배타적입니다. 정수 범위는 양쪽 끝에 포함하고 배타 범위는 부동 소수점 데이터에만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0b757473db53368a2ef12d97dd50853ce089eaf3" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set a range of values. Both the minimum and maximum values of the range are inclusive. It is recommended that ranges of integers be inclusive on both ends, and that exclusive ranges be used only for floating-point data.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 값 범위를 설정할 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 범위의 최소값과 최대 값이 모두 포함됩니다. 정수 범위는 양쪽 끝에 포함하고 배타 범위는 부동 소수점 데이터에만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2983d9a4c8f0070d53ebb95bf9e8a10f5fc81489" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set a single, arbitrary value.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 임의의 단일 값으로 설정 될 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 .</target>
        </trans-unit>
        <trans-unit id="0700eebf90e2b9b27717269ad4daa5ca6eaf8941" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set one of a number of enumerated values. In the case of attributes, these values are &lt;code&gt;String&lt;/code&gt;s; for objects, they are &lt;code&gt;Object&lt;/code&gt;s implementing a given class or interface.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 열거 된 값 중 하나를 설정할 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 속성의 경우 이러한 값은 &lt;code&gt;String&lt;/code&gt; 입니다 . 객체의 경우, 주어진 클래스 또는 인터페이스를 구현하는 &lt;code&gt;Object&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01a4565fe7f6e19d3ab523d52b2e3d4022290f1b" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set to a list or array of values. In the case of attributes, the list will consist of whitespace-separated values within a &lt;code&gt;String&lt;/code&gt;; for objects, an array will be used.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 값의 목록 또는 배열로 설정 될 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 속성의 경우 목록은 &lt;code&gt;String&lt;/code&gt; 내에 공백으로 구분 된 값으로 구성됩니다 . 객체의 경우 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b6629d90c3b11283881b0238ff02a1f68047efe" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set to a range of values. The maximum (but not the minimum) value of the range is inclusive.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 값 범위로 설정 될 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 범위의 최대 값 (최소한은 아님)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="772f7ec75791ea05130b58e948867c25d7e5fe15" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getAttributeValueType&lt;/code&gt; and &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate that the attribute or user object may be set to a range of values. The minimum (but not the maximum) value of the range is inclusive.</source>
          <target state="translated">속성 또는 사용자 오브젝트가 값 범위로 설정 될 수 있음을 표시하기 위해 &lt;code&gt;getAttributeValueType&lt;/code&gt; 및 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 . 범위의 최소값 (최대 값은 아님)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1514659e4abf19076195fdc813b9841606a061a9" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element may not have any children. In other words, it is required to be a leaf node.</source>
          <target state="translated">요소에 자식이 없을 수 있음을 나타 내기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에 의해 리턴되는 상수 . 즉, 리프 노드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0ca721acca6c2ee0f535842aac83a6e8e73d7b2b" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element must have a sequence of instances of any of its legal child elements. In DTD terms, the contents of the element are defined by a sequence &lt;code&gt;(a|b|c|d|...)*&lt;/code&gt;.</source>
          <target state="translated">요소에 유효한 자식 요소의 시퀀스가 ​​있어야 함을 나타 내기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에 의해 반환되는 상수 . DTD 용어에서, 요소의 내용은 시퀀스 &lt;code&gt;(a|b|c|d|...)*&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="25307fe80f331b10c26c8b31d0ddbea83dc5eb8e" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element must have a single instance of each of its legal child elements, in order. In DTD terms, the contents of the element are defined by a sequence &lt;code&gt;a,b,c,d,...&lt;/code&gt;.</source>
          <target state="translated">요소가 유효한 각 하위 요소의 단일 인스턴스를 순서대로 가져야 함을 표시하기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에서 리턴 한 상수 . DTD 용어에서 요소의 내용은 시퀀스 &lt;code&gt;a,b,c,d,...&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2a5ac0abac4124c2691f77efb666b9cd9be6e2f" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element must have zero or more instances of its unique legal child element. In DTD terms, the contents of the element are defined by a starred expression &lt;code&gt;a*&lt;/code&gt;.</source>
          <target state="translated">요소에 고유의 유효한 자식 요소 인스턴스가 0 개 이상 있어야 함을 나타 내기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에서 반환하는 상수 입니다. DTD 용어에서 요소의 내용은 별표 표시된 표현식 &lt;code&gt;a*&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="25a43eb749e0d4acdb5a2d1a97249b39d470bc43" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element must have zero or one children, selected from among its legal child elements. In DTD terms, the contents of the element are defined by a selection &lt;code&gt;a|b|c|d|...&lt;/code&gt;.</source>
          <target state="translated">요소가 합법적 인 자식 요소 중 하나 또는 하나의 자식을 가져야한다는 것을 나타 내기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에 의해 반환되는 상수 . DTD 용어에서, 요소의 내용은 선택 &lt;code&gt;a|b|c|d|...&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="94f4855baee14b64d1efe591ef1cabf5480c75ae" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getChildPolicy&lt;/code&gt; to indicate that an element must have zero or one instance of each of its legal child elements, in order. In DTD terms, the contents of the element are defined by a sequence &lt;code&gt;a?,b?,c?,d?,...&lt;/code&gt;.</source>
          <target state="translated">요소가 유효한 각 하위 요소의 인스턴스를 순서대로 0 개 또는 1 개 가져야 함을 표시하기 위해 &lt;code&gt;getChildPolicy&lt;/code&gt; 에서 리턴 한 상수 . DTD 용어에서 요소의 내용은 시퀀스 &lt;code&gt;a?,b?,c?,d?,...&lt;/code&gt; 로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="d25737fce32883b6c144ed133d1e77a8c2421fac" translate="yes" xml:space="preserve">
          <source>A constant returned by &lt;code&gt;getObjectValueType&lt;/code&gt; to indicate the absence of a user object.</source>
          <target state="translated">사용자 객체가 없음을 나타 내기 위해 &lt;code&gt;getObjectValueType&lt;/code&gt; 에 의해 리턴되는 상수 .</target>
        </trans-unit>
        <trans-unit id="35d4eb9703c2210692f0d6cfb2192f616bfd7eae" translate="yes" xml:space="preserve">
          <source>A constant value that may be passed into methods such as &lt;code&gt;setTilingMode&lt;/code&gt; or &lt;code&gt;setCompressionMode&lt;/code&gt; to enable a feature for future writes. That is, when this mode is set the stream will be tiled or compressed according to additional information supplied to the corresponding &lt;code&gt;set&lt;/code&gt; methods in this class and retrievable from the corresponding &lt;code&gt;get&lt;/code&gt; methods. Note that this mode is not supported for progressive output.</source>
          <target state="translated">나중에 쓸 수있는 기능을 사용하기 위해 &lt;code&gt;setTilingMode&lt;/code&gt; 또는 &lt;code&gt;setCompressionMode&lt;/code&gt; 와 같은 메소드에 전달 될 수있는 상수 값입니다 . 즉,이 모드가 설정되면 이 클래스 의 해당 &lt;code&gt;set&lt;/code&gt; 메소드에 제공되는 추가 정보에 따라 스트림이 타일링되거나 압축 되어 해당 &lt;code&gt;get&lt;/code&gt; 메소드 에서 검색 할 수 있습니다. 점진적 출력에는이 모드가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e3bdadffec9d389f0e6f442f4a8826a156f5a94" translate="yes" xml:space="preserve">
          <source>A constant value that may be passed into methods such as &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;, and &lt;code&gt;setCompressionMode&lt;/code&gt; to disable a feature for future writes. That is, when this mode is set the stream will &lt;b&gt;not&lt;/b&gt; be tiled, progressive, or compressed, and the relevant accessor methods will throw an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">향후 쓰기 기능을 비활성화하기 위해 &lt;code&gt;setTilingMode&lt;/code&gt; , &lt;code&gt;setProgressiveMode&lt;/code&gt; 및 &lt;code&gt;setCompressionMode&lt;/code&gt; 와 같은 메서드에 전달 될 수있는 상수 값입니다 . 즉,이 모드가 설정되면 스트림이 바둑판 식으로 진행되거나 압축 &lt;b&gt;되지 않으며&lt;/b&gt; 관련 액세서 메소드가 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="c8f7898366002f517660648a2793ba433862bbdf" translate="yes" xml:space="preserve">
          <source>A constant value that may be passed into methods such as &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;, and &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for future writes. That is, when this mode is enabled the stream will be tiled, progressive, or compressed according to a sensible default chosen internally by the writer in a plug-in dependent way, and the relevant accessor methods will throw an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">향후 쓰기를 위해 해당 기능을 사용하기 위해 &lt;code&gt;setTilingMode&lt;/code&gt; , &lt;code&gt;setProgressiveMode&lt;/code&gt; 및 &lt;code&gt;setCompressionMode&lt;/code&gt; 와 같은 메소드에 전달 될 수있는 상수 값입니다 . 즉,이 모드를 사용하면, 플러그인에 의해 라이터에 의해 내부적으로 선택된 적절한 디폴트에 따라 스트림이 바둑판 식, 프로그레시브 또는 압축되어 관련 액세서 메소드가 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ee2714f160a481212e68cea2fc3d76b6fb1a8d6a" translate="yes" xml:space="preserve">
          <source>A constant value that may be passed into methods such as &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;, or &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for future writes. That is, when this mode is enabled the stream will be tiled, progressive, or compressed based on the contents of stream and/or image metadata passed into the write operation, and any relevant accessor methods will throw an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">향후 쓰기를 위해 해당 기능을 사용하기 위해 &lt;code&gt;setTilingMode&lt;/code&gt; , &lt;code&gt;setProgressiveMode&lt;/code&gt; 또는 &lt;code&gt;setCompressionMode&lt;/code&gt; 와 같은 메소드에 전달 될 수있는 상수 값입니다 . 즉,이 모드가 활성화되면 쓰기 작업으로 전달 된 스트림 및 / 또는 이미지 메타 데이터의 내용을 기반으로 스트림이 바둑판 식, 프로그레시브 또는 압축되며 관련 액세서 메소드가 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7279f33ba91d89c119cc784b7519e6b9ac4694d5" translate="yes" xml:space="preserve">
          <source>A constructor consumes an extra argument for the object which is being constructed.</source>
          <target state="translated">생성자는 생성중인 객체에 대한 추가 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="57902652588e33d2d2877e5267fcd4fb79931dc7" translate="yes" xml:space="preserve">
          <source>A constructor with a single argument of type &lt;code&gt;Comparator&lt;/code&gt;, which creates an empty sorted map sorted according to the specified comparator.</source>
          <target state="translated">&lt;code&gt;Comparator&lt;/code&gt; 유형의 단일 인수를 가진 생성자 . 지정된 비교 자에 따라 정렬 된 빈 정렬 된 맵을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="25c8b9f747c078b778797b44d629f2869067a88a" translate="yes" xml:space="preserve">
          <source>A constructor with a single argument of type &lt;code&gt;Map&lt;/code&gt;, which creates a new map with the same key-value mappings as its argument, sorted according to the keys' natural ordering.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 유형의 단일 인수를 가진 생성자. 인수 와 동일한 키-값 매핑을 사용하여 키의 자연 순서에 따라 정렬 된 새 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e3fc63f43b8fbf5b83832243411d77bf7df6af1f" translate="yes" xml:space="preserve">
          <source>A constructor with a single argument of type &lt;code&gt;SortedMap&lt;/code&gt;, which creates a new sorted map with the same key-value mappings and the same ordering as the input sorted map.</source>
          <target state="translated">&lt;code&gt;SortedMap&lt;/code&gt; 유형의 단일 인수를 가진 생성자. 입력 정렬 맵과 동일한 키-값 맵핑 및 동일한 순서로 새로운 정렬 맵을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bb2ddb390065f595439cee7ee8032949a41e280e" translate="yes" xml:space="preserve">
          <source>A constructor.</source>
          <target state="translated">생성자</target>
        </trans-unit>
        <trans-unit id="033a41394c724546f3c08acfb5335c17f8e39383" translate="yes" xml:space="preserve">
          <source>A container for data of a specific primitive type.</source>
          <target state="translated">특정 기본 유형의 데이터를위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="d301613cbda6d20a56bf5fe3261d32c8415661bf" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="4ff6f48ffb79030c6e6d4e15b3600b41ee558686" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;double&lt;/code&gt; value. If a value is present, &lt;code&gt;isPresent()&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;getAsDouble()&lt;/code&gt; will return the value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 객체입니다 . 값이 있으면 &lt;code&gt;isPresent()&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 &lt;code&gt;getAsDouble()&lt;/code&gt; 은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="494737a0966b7218e4ec36fd115c3df7489bf2ab" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;int&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="0a04a3c3154a4d845ca222b91180f4f9964d877d" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;int&lt;/code&gt; value. If a value is present, &lt;code&gt;isPresent()&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;getAsInt()&lt;/code&gt; will return the value.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 객체입니다 . 값이 있으면 &lt;code&gt;isPresent()&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하고 &lt;code&gt;getAsInt()&lt;/code&gt; 가 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f4dcdc898b7b16e8f53dc7fbd5332c85cd925ef5" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;long&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="7ba6650f4dd8bcb2a89191e9f85ba776ac9fbf51" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a &lt;code&gt;long&lt;/code&gt; value. If a value is present, &lt;code&gt;isPresent()&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;getAsLong()&lt;/code&gt; will return the value.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 값을 포함하거나 포함하지 않을 수있는 컨테이너 개체입니다 . 값이 있으면 &lt;code&gt;isPresent()&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 하고 &lt;code&gt;getAsLong()&lt;/code&gt; 은 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ea0d5d0324a2c3445923b7e686fe31c2a89e78f7" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a non-null value.</source>
          <target state="translated">널이 아닌 값을 포함하거나 포함하지 않을 수있는 컨테이너 오브젝트.</target>
        </trans-unit>
        <trans-unit id="c89988fd4f74ec363ece708cf6ca9597a2151ab0" translate="yes" xml:space="preserve">
          <source>A container object which may or may not contain a non-null value. If a value is present, &lt;code&gt;isPresent()&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;get()&lt;/code&gt; will return the value.</source>
          <target state="translated">널이 아닌 값을 포함하거나 포함하지 않을 수있는 컨테이너 오브젝트. 값이 있으면 &lt;code&gt;isPresent()&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 &lt;code&gt;get()&lt;/code&gt; 은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31d867731596f79566c79cb5d48b9bcbf97a9cc3" translate="yes" xml:space="preserve">
          <source>A context consists of name-to-object bindings. The Binding class represents such a binding. It consists of a name and an object. The &lt;code&gt;Context.listBindings()&lt;/code&gt; method returns an enumeration of Binding.</source>
          <target state="translated">컨텍스트는 이름 대 오브젝트 바인딩으로 구성됩니다. Binding 클래스는 이러한 바인딩을 나타냅니다. 이름과 객체로 구성됩니다. &lt;code&gt;Context.listBindings()&lt;/code&gt; 메소드는 바인딩의 열거를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="6fe4f651e32a551af03604ca60b8a21ff254ecfc" translate="yes" xml:space="preserve">
          <source>A context consists of name-to-object bindings. The NameClassPair class represents the name and the class of the bound object. It consists of a name and a string representing the package-qualified class name.</source>
          <target state="translated">컨텍스트는 이름 대 오브젝트 바인딩으로 구성됩니다. NameClassPair 클래스는 바인딩 된 개체의 이름과 클래스를 나타냅니다. 패키지로 한정된 클래스 이름을 나타내는 이름과 문자열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1263a6521cddb7203c713b91d8a90e7ac7f9e3" translate="yes" xml:space="preserve">
          <source>A context for resolving URLs with the scheme id &lt;code&gt;scheme&lt;/code&gt;; &lt;code&gt;null&lt;/code&gt; if the factory for creating the context is not found.</source>
          <target state="translated">계획 아이디와 URL을 해결하는 문맥 &lt;code&gt;scheme&lt;/code&gt; ; 컨텍스트를 작성하는 팩토리를 찾을 수 &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="b7377c77308502e8c96858c12fe1aaf5cda4abe1" translate="yes" xml:space="preserve">
          <source>A context instance's connection request controls are retrieved using the method &lt;code&gt;getConnectControls()&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 인스턴스의 연결 요청 제어는 &lt;code&gt;getConnectControls()&lt;/code&gt; 메소드를 사용하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dcb16da6df7e43ac4ec30b2d1186f29508041d6" translate="yes" xml:space="preserve">
          <source>A context instance's request controls are retrieved using the method &lt;code&gt;getRequestControls()&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 인스턴스의 요청 제어는 &lt;code&gt;getRequestControls()&lt;/code&gt; 메소드를 사용하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3986a2d2458e187acf1c4e8bd0f8e686f85ea03" translate="yes" xml:space="preserve">
          <source>A control character: &lt;code&gt;[\x00-\x1F\x7F]&lt;/code&gt;</source>
          <target state="translated">제어 문자 : &lt;code&gt;[\x00-\x1F\x7F]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f98f93af0f8e1282f6442fa10efae582e9be0974" translate="yes" xml:space="preserve">
          <source>A control character: &lt;code&gt;\p{gc=Cc}&lt;/code&gt;</source>
          <target state="translated">제어 문자 : &lt;code&gt;\p{gc=Cc}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03f0ef9add23fa9fe6cf9ea49f54ef4dd6fddc66" translate="yes" xml:space="preserve">
          <source>A control object created using &lt;code&gt;ctl&lt;/code&gt;; or &lt;code&gt;ctl&lt;/code&gt; if a control object cannot be created using the algorithm described above.</source>
          <target state="translated">&lt;code&gt;ctl&lt;/code&gt; 을 사용하여 생성 된 컨트롤 개체 ; 또는 위에서 설명한 알고리즘을 사용하여 컨트롤 개체를 만들 수없는 경우 &lt;code&gt;ctl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8a647654bd9827401aa4fa86ac7705f850e64b2" translate="yes" xml:space="preserve">
          <source>A convenience method equivalent to &lt;code&gt;v.visit(av, null)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v.visit(av, null)&lt;/code&gt; 동일한 편의 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="16a529aa63d7b6f13c0e894161babc3d250fb7d3" translate="yes" xml:space="preserve">
          <source>A convenience method equivalent to &lt;code&gt;v.visit(e, null)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v.visit(e, null)&lt;/code&gt; 동일한 편의 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="ebffac1d76e29602ecbccd02cb486db670466a22" translate="yes" xml:space="preserve">
          <source>A convenience method equivalent to &lt;code&gt;v.visit(t, null)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v.visit(t, null)&lt;/code&gt; 동일한 편의 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="7c27733947ef3a444f59481b63f3bb1fc034a487" translate="yes" xml:space="preserve">
          <source>A convenience method that calls &lt;code&gt;read(b, 0, b.length)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read(b, 0, b.length)&lt;/code&gt; 를 호출하는 편리한 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="b79d96520d2a2823d7650d8196b0afa730e7bde5" translate="yes" xml:space="preserve">
          <source>A convenience method to set the owner's execute permission for this abstract pathname. On some platforms it may be possible to start the Java virtual machine with special privileges that allow it to execute files that are not marked executable.</source>
          <target state="translated">이 추상 경로명에 대한 소유자의 실행 권한을 설정하는 편리한 방법입니다. 일부 플랫폼에서는 실행 가능으로 표시되지 않은 파일을 실행할 수있는 특수 권한으로 Java 가상 머신을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8522c8eecf8c188ae3f5c7af8d515d84ecf53638" translate="yes" xml:space="preserve">
          <source>A convenience method to set the owner's read permission for this abstract pathname. On some platforms it may be possible to start the Java virtual machine with special privileges that allow it to read files that that are marked as unreadable.</source>
          <target state="translated">이 추상 경로명에 대한 소유자의 읽기 권한을 설정하는 편리한 방법입니다. 일부 플랫폼에서는 읽을 수없는 것으로 표시된 파일을 읽을 수있는 특수 권한으로 Java 가상 머신을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70adbfa143948dbfbe2a2079d23a3c700d25e391" translate="yes" xml:space="preserve">
          <source>A convenience method to set the owner's write permission for this abstract pathname. On some platforms it may be possible to start the Java virtual machine with special privileges that allow it to modify files that disallow write operations.</source>
          <target state="translated">이 추상 경로명에 대한 소유자의 쓰기 권한을 설정하는 편리한 방법입니다. 일부 플랫폼에서는 쓰기 조작을 허용하지 않는 파일을 수정할 수있는 특수 권한으로 Java 가상 머신을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8390e30450358a6ea70064ba0435f38800aed856" translate="yes" xml:space="preserve">
          <source>A convenience method to write a formatted string to this console's output stream using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 콘솔의 출력 스트림에 쓰는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f3a608167c200beb78de0abed90f0e9a8f45921d" translate="yes" xml:space="preserve">
          <source>A convenience method to write a formatted string to this output stream using the specified format string and arguments.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여 형식화 된 문자열을이 출력 스트림에 쓰는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8cf3d0db1f2e456a656fc16b71edb621d58b8d0c" translate="yes" xml:space="preserve">
          <source>A convenience method to write a formatted string to this writer using the specified format string and arguments. If automatic flushing is enabled, calls to this method will flush the output buffer.</source>
          <target state="translated">지정된 형식 문자열과 인수를 사용하여이 기록기에 형식화 된 문자열을 작성하는 편리한 방법입니다. 자동 플러시가 활성화 된 경우이 메서드를 호출하면 출력 버퍼가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1a8039aac719e599728c0c27428d151c53c8d8" translate="yes" xml:space="preserve">
          <source>A cookie to store may or may not be associated with an URI. If it is not associated with an URI, the cookie's domain and path attribute will indicate where it comes from. If it is associated with an URI and its domain and path attribute are not specified, given URI will indicate where this cookie comes from.</source>
          <target state="translated">저장할 쿠키는 URI와 연관되거나 연관되지 않을 수 있습니다. URI와 연결되지 않은 경우 쿠키의 도메인 및 경로 속성은 쿠키의 출처를 나타냅니다. URI와 연관되고 해당 도메인 및 경로 속성이 지정되지 않은 경우 제공된 URI는이 쿠키의 출처를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="847e6f4959462c58ea8ac27a4387b6518797a9bd" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;name&lt;/code&gt; is made and stored. Subsequent changes to &lt;code&gt;name&lt;/code&gt; does not affect the copy in this NamingException and vice versa.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 사본 이 만들어져 저장됩니다. 이후의 &lt;code&gt;name&lt;/code&gt; 변경 은이 NamingException의 사본에 영향을 미치지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="2014e4f257019657ca846cfb69be1eedec61a26e" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;newName&lt;/code&gt; is made and stored. Subsequent changes to &lt;code&gt;name&lt;/code&gt; does not affect the copy in this NamingException and vice versa.</source>
          <target state="translated">&lt;code&gt;newName&lt;/code&gt; 의 사본 이 작성되어 저장됩니다. 이후의 &lt;code&gt;name&lt;/code&gt; 변경 은이 NamingException의 사본에 영향을 미치지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d405432971fb5d5bd4d9655c00ba110cf9164761" translate="yes" xml:space="preserve">
          <source>A copy of the certificates array, or null if there is none.</source>
          <target state="translated">증명서 배열의 카피. 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="2c53b1d71e76fb7f9999eb4ea68630428eca0196" translate="yes" xml:space="preserve">
          <source>A copy of the code signer array, or null if there is none.</source>
          <target state="translated">코드 서명자 배열의 사본. 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="d12b5b76ae33b8ff518231f4bdf080025e7d1ecc" translate="yes" xml:space="preserve">
          <source>A copy of the current quantization table.</source>
          <target state="translated">현재 양자화 테이블의 사본.</target>
        </trans-unit>
        <trans-unit id="39726b352731b62ca6b918622ee3ca622b5b8a86" translate="yes" xml:space="preserve">
          <source>A copy of the date or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">날짜의 카피. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 맵되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="95671ff38df1ecf38192edcde87daa005a34113e" translate="yes" xml:space="preserve">
          <source>A copy of the flag indicating whether a periodic notification is executed at</source>
          <target state="translated">정기 알림의 실행 여부를 나타내는 플래그 사본</target>
        </trans-unit>
        <trans-unit id="2d2d2301896bb87bf4110f7f9035139f0077d8a5" translate="yes" xml:space="preserve">
          <source>A copy of the period or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">마침표의 복사본이거나 식별자가이 타이머 MBean에 등록 된 타이머 알림에 매핑되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="7162e1527ed5572f6cb24373b5f74999ffaf9db9" translate="yes" xml:space="preserve">
          <source>A copy of the remaining number of occurrences or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">나머지 발생 횟수의 사본. 또는 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="67421ae13fd23f4c24e8887b04d367966e5e8324" translate="yes" xml:space="preserve">
          <source>A copy of the specified enum set.</source>
          <target state="translated">지정된 열거 세트의 사본</target>
        </trans-unit>
        <trans-unit id="df7838b154197b11591455e756b04860d754eddc" translate="yes" xml:space="preserve">
          <source>A copy of the this LDAP name.</source>
          <target state="translated">이 LDAP 이름의 사본</target>
        </trans-unit>
        <trans-unit id="ef57a052b407fe7cec8a98762eedf987fe6eb85f" translate="yes" xml:space="preserve">
          <source>A copy of this</source>
          <target state="translated">이것의 사본</target>
        </trans-unit>
        <trans-unit id="bfe0b7d026c71e8963a98d7d535863e14aaad2cb" translate="yes" xml:space="preserve">
          <source>A counter monitor sends a &lt;a href=&quot;monitornotification#THRESHOLD_VALUE_EXCEEDED&quot;&gt;&lt;code&gt;threshold
 notification&lt;/code&gt;&lt;/a&gt; when the value of the counter reaches or exceeds a threshold known as the comparison level. The notify flag must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">카운터 모니터는 카운터 값이 비교 수준으로 알려진 임계 값에 도달하거나 초과 할 때 &lt;a href=&quot;monitornotification#THRESHOLD_VALUE_EXCEEDED&quot;&gt; &lt;code&gt;threshold notification&lt;/code&gt; &lt;/a&gt; 보냅니다 . 알림 플래그는 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="e5aa116cd195f41d88b93e7e05e33512e16c94f4" translate="yes" xml:space="preserve">
          <source>A counting semaphore.</source>
          <target state="translated">세마포를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1878569fa082444cb799d4d4472ca8f08f05481f" translate="yes" xml:space="preserve">
          <source>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; blocks if necessary until a permit is available, and then takes it. Each &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the &lt;code&gt;Semaphore&lt;/code&gt; just keeps a count of the number available and acts accordingly.</source>
          <target state="translated">세마포를 계산합니다. 개념적으로 세마포어는 일련의 허가를 유지합니다. 각 &lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 는 필요한 경우 허가가있을 때까지 차단 한 다음 가져옵니다. 각 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 는 허가를 추가하여 잠재적으로 블로킹 획득자를 공개합니다. 그러나 실제 허용 개체는 사용되지 않습니다. &lt;code&gt;Semaphore&lt;/code&gt; 바로 사용할 수있는 수의 수를 유지하고 그에 따라 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="17a6af52f060965e86c67aebd554d45e863130ac" translate="yes" xml:space="preserve">
          <source>A cryptographic service is always associated with a particular algorithm or type. For example, a digital signature service is always associated with a particular algorithm (e.g., DSA), and a CertificateFactory service is always associated with a particular certificate type (e.g., X.509).</source>
          <target state="translated">암호화 서비스는 항상 특정 알고리즘 또는 유형과 연결됩니다. 예를 들어, 디지털 서명 서비스는 항상 특정 알고리즘 (예 : DSA)과 연결되고 CertificateFactory 서비스는 항상 특정 인증서 유형 (예 : X.509)과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3d49d8541edd780589e4ca07657ecf84fd361175" translate="yes" xml:space="preserve">
          <source>A cryptographically strong random number minimally complies with the statistical random number generator tests specified in &lt;a href=&quot;http://csrc.nist.gov/cryptval/140-2.htm&quot;&gt; &lt;i&gt;FIPS 140-2, Security Requirements for Cryptographic Modules&lt;/i&gt;&lt;/a&gt;, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in &lt;a href=&quot;http://www.ietf.org/rfc/rfc1750.txt&quot;&gt; &lt;i&gt;RFC 1750: Randomness Recommendations for Security&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">암호화 적으로 강력한 난수는 &lt;a href=&quot;http://csrc.nist.gov/cryptval/140-2.htm&quot;&gt;&lt;i&gt;FIPS 140-2, 암호화 모듈에 대한 보안 요구 사항&lt;/i&gt;&lt;/a&gt; , 섹션 4.9.1에 지정된 통계적 난수 생성기 테스트를 최소로 준수합니다 . 또한 SecureRandom은 비 결정적 출력을 생성해야합니다. 따라서 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1750.txt&quot;&gt;&lt;i&gt;RFC 1750 : 보안에 대한 임의성 권장 사항에&lt;/i&gt;&lt;/a&gt; 설명 된 &lt;i&gt;대로&lt;/i&gt; SecureRandom 오브젝트에 전달 된 시드 자료는 예측할 수 없어야하며 모든 SecureRandom 출력 순서는 암호화 적으로 강력해야합니다 . &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="fa5deb637528748537e80092135237e4eb9b1b7c" translate="yes" xml:space="preserve">
          <source>A currency symbol</source>
          <target state="translated">통화 기호</target>
        </trans-unit>
        <trans-unit id="0d9a552f1eae9532772ba8a0f5bd21b603f695ba" translate="yes" xml:space="preserve">
          <source>A customizer class provides a complete custom GUI for customizing a target Java Bean.</source>
          <target state="translated">사용자 정의 프로그램 클래스는 대상 Java Bean을 사용자 정의하기위한 완전한 사용자 정의 GUI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2069b8c17d37c31667b7fab19c4856de0cc1f8d1" translate="yes" xml:space="preserve">
          <source>A daemon thread group is automatically destroyed when its last thread is stopped or its last thread group is destroyed.</source>
          <target state="translated">마지막 스레드가 중지되거나 마지막 스레드 그룹이 삭제되면 데몬 스레드 그룹이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="05d0e41569ec35aa65fa2c0237db9083d80b3ecd" translate="yes" xml:space="preserve">
          <source>A dash</source>
          <target state="translated">대시</target>
        </trans-unit>
        <trans-unit id="a33b219dbf7a1c9bcc3067caa4ec245d6a63116b" translate="yes" xml:space="preserve">
          <source>A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way.</source>
          <target state="translated">데이터 입력 스트림을 사용하면 응용 프로그램이 기본 입력 스트림에서 기본 Java 데이터 유형을 기계 독립적 인 방식으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45df3da7223cc3f060b7b0d57ac3b346e061e77" translate="yes" xml:space="preserve">
          <source>A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. An application uses a data output stream to write data that can later be read by a data input stream.</source>
          <target state="translated">데이터 입력 스트림을 사용하면 응용 프로그램이 기본 입력 스트림에서 기본 Java 데이터 유형을 기계 독립적 인 방식으로 읽을 수 있습니다. 응용 프로그램은 데이터 출력 스트림을 사용하여 나중에 데이터 입력 스트림에서 읽을 수있는 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="1de7e80dd13dc68d3168ef0a6e2fe9e3913dcf0a" translate="yes" xml:space="preserve">
          <source>A data line has an internal buffer in which the incoming or outgoing audio data is queued. The &lt;code&gt;&lt;a href=&quot;dataline#drain--&quot;&gt;&lt;code&gt;drain()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method blocks until this internal buffer becomes empty, usually because all queued data has been processed. The &lt;code&gt;&lt;a href=&quot;dataline#flush--&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method discards any available queued data from the internal buffer.</source>
          <target state="translated">데이터 라인에는 수신 또는 발신 오디오 데이터가 대기하는 내부 버퍼가 있습니다. &lt;code&gt;&lt;a href=&quot;dataline#drain--&quot;&gt;&lt;code&gt;drain()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 이 내부 버퍼가 비게 될 때까지 메소드 블록, 모든 큐잉 된 데이터가 처리되어 있기 때문에 보통. &lt;code&gt;&lt;a href=&quot;dataline#flush--&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드는 내부 버퍼로부터 큐잉 된 데이터를 폐기한다.</target>
        </trans-unit>
        <trans-unit id="5c11db064de02f620dcd7062f6e3d3fe8017c28a" translate="yes" xml:space="preserve">
          <source>A data line produces &lt;code&gt;&lt;a href=&quot;lineevent.type#START&quot;&gt;&lt;code&gt;START&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;lineevent.type#STOP&quot;&gt;&lt;code&gt;STOP&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; events whenever it begins or ceases active presentation or capture of data. These events can be generated in response to specific requests, or as a result of less direct state changes. For example, if &lt;code&gt;&lt;a href=&quot;dataline#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; is called on an inactive data line, and data is available for capture or playback, a &lt;code&gt;START&lt;/code&gt; event will be generated shortly, when data playback or capture actually begins. Or, if the flow of data to an active data line is constricted so that a gap occurs in the presentation of data, a &lt;code&gt;STOP&lt;/code&gt; event is generated.</source>
          <target state="translated">데이터 라인은 &lt;code&gt;&lt;a href=&quot;lineevent.type#START&quot;&gt;&lt;code&gt;START&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;lineevent.type#STOP&quot;&gt;&lt;code&gt;STOP&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 이벤트가 시작되거나 활성 프리젠 테이션 또는 데이터 캡처가 중지 될 때마다 생성 됩니다. 이러한 이벤트는 특정 요청에 대한 응답으로 또는 직접적인 상태 변경이 적기 때문에 생성 될 수 있습니다. 예를 들어, 비활성 데이터 라인에서 &lt;code&gt;&lt;a href=&quot;dataline#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 호출되고 데이터를 캡처 또는 재생할 수있는 경우 데이터 재생 또는 캡처가 실제로 시작될 때 곧 &lt;code&gt;START&lt;/code&gt; 이벤트가 생성됩니다. 또는 활성 데이터 라인으로의 데이터 흐름이 제한되어 데이터 표시에 공백이 발생하면 &lt;code&gt;STOP&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ade92fed66a9ea602b46e8ce07d94ae873930c" translate="yes" xml:space="preserve">
          <source>A data output stream lets an application write primitive Java data types to an output stream in a portable way.</source>
          <target state="translated">데이터 출력 스트림을 통해 응용 프로그램은 기본 Java 데이터 유형을 이식 가능한 방식으로 출력 스트림에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e49ad230178e81f14bea1885dc6b952a1a78975" translate="yes" xml:space="preserve">
          <source>A data output stream lets an application write primitive Java data types to an output stream in a portable way. An application can then use a data input stream to read the data back in.</source>
          <target state="translated">데이터 출력 스트림을 통해 응용 프로그램은 기본 Java 데이터 유형을 이식 가능한 방식으로 출력 스트림에 쓸 수 있습니다. 그런 다음 응용 프로그램은 데이터 입력 스트림을 사용하여 데이터를 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="860c85146d0e51648ee215e21e8c0d125f69ac4d" translate="yes" xml:space="preserve">
          <source>A datagram channel is created by invoking one of the &lt;a href=&quot;datagramchannel#open--&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; methods of this class. It is not possible to create a channel for an arbitrary, pre-existing datagram socket. A newly-created datagram channel is open but not connected. A datagram channel need not be connected in order for the &lt;a href=&quot;datagramchannel#send-java.nio.ByteBuffer-java.net.SocketAddress-&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datagramchannel#receive-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; methods to be used. A datagram channel may be connected, by invoking its &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method, in order to avoid the overhead of the security checks are otherwise performed as part of every send and receive operation. A datagram channel must be connected in order to use the &lt;a href=&quot;datagramchannel#read-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datagramchannel#write-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; methods, since those methods do not accept or return socket addresses.</source>
          <target state="translated">이 클래스 의 &lt;a href=&quot;datagramchannel#open--&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출하여 데이터 그램 채널이 작성됩니다 . 임의의 기존 데이터 그램 소켓에 대한 채널을 생성 할 수 없습니다. 새로 만든 데이터 그램 채널이 열려 있지만 연결되어 있지 않습니다. &lt;a href=&quot;datagramchannel#send-java.nio.ByteBuffer-java.net.SocketAddress-&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datagramchannel#receive-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 방법을 사용 하기 위해 데이터 그램 채널을 연결할 필요가 없습니다 . 보안 검사의 오버 헤드를 피하기 위해 모든 송수신 작업의 일부로 수행되는 보안 검사의 오버 헤드를 피하기 위해 &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 방법 을 호출하여 데이터 그램 채널을 연결할 수 있습니다. &lt;a href=&quot;datagramchannel#read-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datagramchannel#write-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법 을 사용하려면 데이터 그램 채널을 연결해야합니다. 이러한 방법은 소켓 주소를 허용하거나 반환하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b50daddc17e2dc3b7a053825fe91e19a870e48dc" translate="yes" xml:space="preserve">
          <source>A datagram socket associated with this channel</source>
          <target state="translated">이 채널과 관련된 데이터 그램 소켓</target>
        </trans-unit>
        <trans-unit id="3d2c68abbc6de0158a3eae16d10798edaae398fe" translate="yes" xml:space="preserve">
          <source>A datagram socket is the sending or receiving point for a packet delivery service. Each packet sent or received on a datagram socket is individually addressed and routed. Multiple packets sent from one machine to another may be routed differently, and may arrive in any order.</source>
          <target state="translated">데이터 그램 소켓은 패킷 전달 서비스의 송신 또는 수신 지점입니다. 데이터 그램 소켓에서 보내거나받는 각 패킷은 개별적으로 주소 지정되고 라우팅됩니다. 한 시스템에서 다른 시스템으로 전송 된 여러 패킷은 다르게 라우팅 될 수 있으며 어떤 순서로든 도착할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae7f8573e25c5bd21f3782b0c07769f31eec235" translate="yes" xml:space="preserve">
          <source>A datagram socket will have a channel if, and only if, the channel itself was created via the &lt;a href=&quot;../nio/channels/datagramchannel#open--&quot;&gt;&lt;code&gt;DatagramChannel.open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널 자체가 &lt;a href=&quot;../nio/channels/datagramchannel#open--&quot;&gt; &lt;code&gt;DatagramChannel.open&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 작성된 경우에만 데이터 그램 소켓에 채널이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28f9164c3c92e685be103dbf4f46c787de2d68b2" translate="yes" xml:space="preserve">
          <source>A date (day of month) is represented by an integer from 1 to 31 in the usual manner.</source>
          <target state="translated">날짜 (일)는 일반적인 방식으로 1에서 31 사이의 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="765d4dd40d45377469a0163c1106343e90f2903d" translate="yes" xml:space="preserve">
          <source>A date in the Hijrah calendar system.</source>
          <target state="translated">Hijrah 달력 시스템의 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="c1c7acc4aa80b7eeb7672f49c432e7cd85327b48" translate="yes" xml:space="preserve">
          <source>A date in the Japanese Imperial calendar system.</source>
          <target state="translated">일본 제국 달력 시스템의 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="7de30d127cf084154c18dba24d51f5c4658f9091" translate="yes" xml:space="preserve">
          <source>A date in the Minguo calendar system.</source>
          <target state="translated">Minguo 캘린더 시스템의 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="eb679e0dede92d2e659a9d8242cd334c8812c331" translate="yes" xml:space="preserve">
          <source>A date in the Thai Buddhist calendar system.</source>
          <target state="translated">태국 불교 달력 시스템의 날짜.</target>
        </trans-unit>
        <trans-unit id="73688423161d451845e09cb015764dabbeb668f9" translate="yes" xml:space="preserve">
          <source>A date is time-based if it can be used to imply meaning from a date. It must have a &lt;a href=&quot;temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; that is an integral multiple of the length of a standard day. Note that it is valid for both &lt;code&gt;isDateBased()&lt;/code&gt; and &lt;code&gt;isTimeBased()&lt;/code&gt; to return false, such as when representing a unit like 36 hours.</source>
          <target state="translated">날짜는 날짜를 의미하는 데 사용될 수있는 경우 시간 기반입니다. 표준 날짜 길이의 정수배 인 &lt;a href=&quot;temporalunit#getDuration--&quot;&gt;지속 기간&lt;/a&gt; 이 있어야합니다 . &lt;code&gt;isDateBased()&lt;/code&gt; 및 &lt;code&gt;isTimeBased()&lt;/code&gt; 가 36 시간과 같은 단위를 나타내는 경우와 같이 false를 리턴 하는 데 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="15998c955b5528e968175b0e012f5926807a8abe" translate="yes" xml:space="preserve">
          <source>A date without a time-zone in the ISO-8601 calendar system, such as &lt;code&gt;2007-12-03&lt;/code&gt;.</source>
          <target state="translated">ISO-8601 달력 시스템에 시간대가없는 날짜 (예 : &lt;code&gt;2007-12-03&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="922a9f59988c2dc98cc4b1ef57bbd880865b6d16" translate="yes" xml:space="preserve">
          <source>A date without time-of-day or time-zone in an arbitrary chronology, intended for advanced globalization use cases.</source>
          <target state="translated">고급 세계화 사용 사례를 위해 임의의 시간 순서로 시간대 또는 시간대가없는 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="2e438e7f48db8594363e3d4b8a272fd1430eae73" translate="yes" xml:space="preserve">
          <source>A date-based amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.</source>
          <target state="translated">ISO-8601 달력 시스템의 날짜 기반 시간 (예 : '2 년, 3 개월 및 4 일')</target>
        </trans-unit>
        <trans-unit id="ea8975e273a6ef0177859f50acb175de6d095b63" translate="yes" xml:space="preserve">
          <source>A date-based amount of time, such as '3 years, 4 months and 5 days' in an arbitrary chronology, intended for advanced globalization use cases.</source>
          <target state="translated">고급 세계화 사용 사례를위한 임의의 연대기에서 '3 년, 4 개월 및 5 일'과 같은 날짜 기반 시간입니다.</target>
        </trans-unit>
        <trans-unit id="164536bebef9f26d2ca2490445b8e742d6eac336" translate="yes" xml:space="preserve">
          <source>A date-time with a time-zone in an arbitrary chronology, intended for advanced globalization use cases.</source>
          <target state="translated">고급 세계화 사용 사례를위한 임의의 시간 순서대로 시간대가있는 날짜-시간입니다.</target>
        </trans-unit>
        <trans-unit id="097280af56f500be86aab77cc886c6c68d69083a" translate="yes" xml:space="preserve">
          <source>A date-time with a time-zone in the ISO-8601 calendar system, such as &lt;code&gt;2007-12-03T10:15:30+01:00 Europe/Paris&lt;/code&gt;.</source>
          <target state="translated">ISO-8601 캘린더 시스템에서 시간대가있는 날짜-시간 (예 : &lt;code&gt;2007-12-03T10:15:30+01:00 Europe/Paris&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="4ef9fd927e47ecd38cbd267620a731630ad6d605" translate="yes" xml:space="preserve">
          <source>A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as &lt;code&gt;2007-12-03T10:15:30+01:00&lt;/code&gt;.</source>
          <target state="translated">는 ISO-8601 시스템에서 일정 UTC / 그리니치 오프셋과 데이트 타임 같은 &lt;code&gt;2007-12-03T10:15:30+01:00&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa42790b0fd24d4edfc2bea6b761cee59e338ba9" translate="yes" xml:space="preserve">
          <source>A date-time without a time-zone in an arbitrary chronology, intended for advanced globalization use cases.</source>
          <target state="translated">고급 세계화 사용 사례를위한 임의의 연대기에 시간대가없는 날짜-시간입니다.</target>
        </trans-unit>
        <trans-unit id="4cd7fec84ac247f0315d0f529964606dad258e5d" translate="yes" xml:space="preserve">
          <source>A date-time without a time-zone in the ISO-8601 calendar system, such as &lt;code&gt;2007-12-03T10:15:30&lt;/code&gt;.</source>
          <target state="translated">ISO-8601 캘린더 시스템에서 시간대가없는 날짜-시간 (예 : &lt;code&gt;2007-12-03T10:15:30&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="157be410809c28fe9d32a7c9658f228c1d9c12a7" translate="yes" xml:space="preserve">
          <source>A day-of-week, such as 'Tuesday'.</source>
          <target state="translated">'화요일'과 같은 요일입니다.</target>
        </trans-unit>
        <trans-unit id="5eff0f0d27d8edf396c4eb418d3158f33ab7a26b" translate="yes" xml:space="preserve">
          <source>A decimal digit character:&lt;code&gt;p{IsDigit}&lt;/code&gt;</source>
          <target state="translated">10 진수 문자 : &lt;code&gt;p{IsDigit}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b598631977de5f143e88066dce901dff98686a6" translate="yes" xml:space="preserve">
          <source>A decimal digit: &lt;code&gt;[0-9]&lt;/code&gt;</source>
          <target state="translated">십진수 : &lt;code&gt;[0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="157311c8bc1e2a311fd7d16a1903d15eeb1dce10" translate="yes" xml:space="preserve">
          <source>A decimal point</source>
          <target state="translated">소수점</target>
        </trans-unit>
        <trans-unit id="cd2a0ef14d56cc958a92c93743ec0088b9a70441" translate="yes" xml:space="preserve">
          <source>A default &lt;code&gt;CallbackHandler&lt;/code&gt; class implementation may be specified by setting the value of the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property.</source>
          <target state="translated">&lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 보안 특성 의 값을 설정하여 기본 &lt;code&gt;CallbackHandler&lt;/code&gt; 클래스 구현을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3eead970a964cfd77fd60eb90fa4973507e78a75" translate="yes" xml:space="preserve">
          <source>A definition of the way a local time can be converted to the actual transition date-time.</source>
          <target state="translated">현지 시간을 실제 전환 날짜-시간으로 변환 할 수있는 방법에 대한 정의.</target>
        </trans-unit>
        <trans-unit id="c9dd44617c4d88f5e2e6388d8e2dafe4e46a14ef" translate="yes" xml:space="preserve">
          <source>A delayed result-bearing action that can be cancelled.</source>
          <target state="translated">취소 할 수있는 지연된 결과 보유 조치.</target>
        </trans-unit>
        <trans-unit id="ac46e84e3abf4aff48d4f542f6baf971ac9dad1e" translate="yes" xml:space="preserve">
          <source>A delayed result-bearing action that can be cancelled. Usually a scheduled future is the result of scheduling a task with a &lt;a href=&quot;scheduledexecutorservice&quot;&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소 할 수있는 지연된 결과 보유 조치. 일반적으로 스케줄 된 미래는 &lt;a href=&quot;scheduledexecutorservice&quot;&gt; &lt;code&gt;ScheduledExecutorService&lt;/code&gt; &lt;/a&gt; 로 태스크를 스케줄 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="9281783cd7910a1b9bd0cbddec54bbe22a45331a" translate="yes" xml:space="preserve">
          <source>A description of a Serializable field from a Serializable class.</source>
          <target state="translated">Serializable 클래스의 Serializable 필드에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="76b5a73d15645da68ef6f5bf9709ccb80943a81e" translate="yes" xml:space="preserve">
          <source>A description of a Serializable field from a Serializable class. An array of ObjectStreamFields is used to declare the Serializable fields of a class.</source>
          <target state="translated">Serializable 클래스의 Serializable 필드에 대한 설명입니다. ObjectStreamFields 배열은 클래스의 Serializable 필드를 선언하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="62eb29e85381c666aa2036d142f522d9f38765c8" translate="yes" xml:space="preserve">
          <source>A description of a to-be-instantiated KeyStore object.</source>
          <target state="translated">인스턴스화 할 KeyStore 객체의 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3d1c33b4d2727c3bbde32903a7c46f61993d7993" translate="yes" xml:space="preserve">
          <source>A description of the result state of a coder.</source>
          <target state="translated">코더의 결과 상태에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="941de8ae14a5bae60a5d906de62f015bbb32d97b" translate="yes" xml:space="preserve">
          <source>A descriptive string</source>
          <target state="translated">설명 문자열</target>
        </trans-unit>
        <trans-unit id="39b6b0c8659ae33eb1969916bc67e68279e3a0d9" translate="yes" xml:space="preserve">
          <source>A descriptor can be mutable or immutable. An immutable descriptor, once created, never changes. The &lt;code&gt;Descriptor&lt;/code&gt; methods that could modify the contents of the descriptor will throw an exception for an immutable descriptor. Immutable descriptors are usually instances of &lt;a href=&quot;immutabledescriptor&quot;&gt;&lt;code&gt;ImmutableDescriptor&lt;/code&gt;&lt;/a&gt; or a subclass. Mutable descriptors are usually instances of &lt;a href=&quot;modelmbean/descriptorsupport&quot;&gt;&lt;code&gt;DescriptorSupport&lt;/code&gt;&lt;/a&gt; or a subclass.</source>
          <target state="translated">디스크립터는 변경 가능하거나 변경 불가능할 수 있습니다. 변경 불가능한 디스크립터는 일단 작성된 후에는 변경되지 않습니다. 디스크립터의 내용을 수정할 수 있는 &lt;code&gt;Descriptor&lt;/code&gt; 메소드는 변경 불가능한 디스크립터에 대한 예외를 발생시킵니다. 불변 기술자는 일반적으로 &lt;a href=&quot;immutabledescriptor&quot;&gt; &lt;code&gt;ImmutableDescriptor&lt;/code&gt; &lt;/a&gt; 또는 서브 클래스의 인스턴스입니다 . 가변 디스크립터는 일반적으로 &lt;a href=&quot;modelmbean/descriptorsupport&quot;&gt; &lt;code&gt;DescriptorSupport&lt;/code&gt; &lt;/a&gt; 또는 서브 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="72904f35789eb5719433f738c8b55b480e3f7be2" translate="yes" xml:space="preserve">
          <source>A descriptor consists of a collection of fields. Each field is in fieldname=fieldvalue format. Field names are not case sensitive, case will be preserved on field values.</source>
          <target state="translated">디스크립터는 필드 콜렉션으로 구성됩니다. 각 필드는 fieldname = fieldvalue 형식입니다. 필드 이름은 대소 문자를 구분하지 않으며 필드 값에 대소 문자가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f0ff2df0a69862e0b2488b671e2b54a0b5b5e113" translate="yes" xml:space="preserve">
          <source>A descriptor which is equal to this descriptor.</source>
          <target state="translated">이 디스크립터와 동일한 디스크립터입니다.</target>
        </trans-unit>
        <trans-unit id="f2ac3be272a0574021e64ac6b1513e44e8223162" translate="yes" xml:space="preserve">
          <source>A digit: &lt;code&gt;[0-9]&lt;/code&gt;</source>
          <target state="translated">숫자 : &lt;code&gt;[0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e55b37ed13f5e44ba0fa6d222acf00463637355" translate="yes" xml:space="preserve">
          <source>A digit: &lt;code&gt;\p{IsDigit}&lt;/code&gt;</source>
          <target state="translated">숫자 : &lt;code&gt;\p{IsDigit}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e1c6320bfe897efcad522bedce59a1bf3c1d0a0" translate="yes" xml:space="preserve">
          <source>A direct byte buffer mapped to a region of a file</source>
          <target state="translated">파일 영역에 매핑 된 직접 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="81aaa261b81128af12881c936333c5551a92c591" translate="yes" xml:space="preserve">
          <source>A direct byte buffer may also be created by &lt;a href=&quot;channels/filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt;&lt;code&gt;mapping&lt;/code&gt;&lt;/a&gt; a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time.</source>
          <target state="translated">직접 바이트 버퍼는 파일 영역을 메모리에 직접 &lt;a href=&quot;channels/filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt; &lt;code&gt;mapping&lt;/code&gt; &lt;/a&gt; 하여 만들 수도 있습니다 . Java 플랫폼의 구현은 JNI를 통해 기본 코드에서 직접 바이트 버퍼 작성을 선택적으로 지원할 수 있습니다. 이러한 종류의 버퍼 중 하나의 인스턴스가 액세스 할 수없는 메모리 영역을 참조하는 경우 해당 영역에 액세스하려고하면 버퍼의 내용이 변경되지 않으며 액세스 시점 또는 나중에 지정되지 않은 예외가 발생합니다. 시각.</target>
        </trans-unit>
        <trans-unit id="ab01d4bccb2016b6742b55c3ca10eb76a7c66d26" translate="yes" xml:space="preserve">
          <source>A direct byte buffer may be created by invoking the &lt;a href=&quot;bytebuffer#allocateDirect-int-&quot;&gt;&lt;code&gt;allocateDirect&lt;/code&gt;&lt;/a&gt; factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.</source>
          <target state="translated">직접 바이트 버퍼는 이 클래스 의 &lt;a href=&quot;bytebuffer#allocateDirect-int-&quot;&gt; &lt;code&gt;allocateDirect&lt;/code&gt; &lt;/a&gt; 팩토리 메소드를 호출하여 작성할 수 있습니다 . 이 방법으로 반환 된 버퍼는 일반적으로 비 직접 버퍼보다 ​​할당 및 할당 취소 비용이 약간 높습니다. 직접 버퍼의 내용은 일반적인 가비지 수집 힙 외부에있을 수 있으므로 응용 프로그램의 메모리 공간에 미치는 영향이 명확하지 않을 수 있습니다. 따라서 기본 시스템의 기본 I / O 작업이 적용되는 오래 지속되는 대용량 버퍼에 직접 버퍼를 할당하는 것이 좋습니다. 일반적으로 직접 버퍼는 프로그램 성능에서 측정 가능한 이득을 얻을 때만 할당하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e62af31304449a0e8e9997671ca8cef65fe0060" translate="yes" xml:space="preserve">
          <source>A direct byte buffer whose content is a memory-mapped region of a file.</source>
          <target state="translated">내용이 파일의 메모리 매핑 영역 인 직접 바이트 버퍼.</target>
        </trans-unit>
        <trans-unit id="27d710eefe649a75a4ba4bf7f513ec23a73d1bf8" translate="yes" xml:space="preserve">
          <source>A direct method handle reference kind, as defined in the &lt;a href=&quot;methodhandleinfo#refkinds&quot;&gt;table above&lt;/a&gt;.</source>
          <target state="translated">직접적인 방법 핸들 참조 종류의 항에 &lt;a href=&quot;methodhandleinfo#refkinds&quot;&gt;상술 한 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4d94bf1cbf3f0b6e58c8d46620a3904bfb67dc" translate="yes" xml:space="preserve">
          <source>A directory might return more attributes than was requested (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description), but is not allowed to return arbitrary, unrelated attributes.</source>
          <target state="translated">디렉토리가 요청한 것보다 많은 속성 을 리턴 할 수 있지만 (클래스 설명의 &lt;strong&gt;속성 유형 이름&lt;/strong&gt; 참조 ) 임의의 관련없는 속성을 리턴 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f43b3eeaa9f2985c2c0a2500f1ecaf8cf55ba57" translate="yes" xml:space="preserve">
          <source>A directory might return more attributes than were requested (see &lt;strong&gt;Attribute Type Names&lt;/strong&gt; in the class description) but is not allowed to return arbitrary, unrelated attributes.</source>
          <target state="translated">디렉토리가 요청한 것보다 많은 속성 을 리턴 할 수 있지만 (클래스 설명의 &lt;strong&gt;속성 유형 이름&lt;/strong&gt; 참조 ) 임의의 관련없는 속성을 리턴 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03fe397e85f8a42f3fbf743c8747c214f39a12ce" translate="yes" xml:space="preserve">
          <source>A directory stream is not required to be</source>
          <target state="translated">디렉토리 스트림은 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="1daa8bbdabafd9fce66bb5e5f6f1d901814d2276" translate="yes" xml:space="preserve">
          <source>A discussion of the use of dynamically typesafe views may be found in the documentation for the &lt;a href=&quot;collections#checkedCollection-java.util.Collection-java.lang.Class-&quot;&gt;&lt;code&gt;checkedCollection&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">dynamictypesafe 뷰 사용에 대한 설명은 &lt;a href=&quot;collections#checkedCollection-java.util.Collection-java.lang.Class-&quot;&gt; &lt;code&gt;checkedCollection&lt;/code&gt; &lt;/a&gt; 메소드 의 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f4fef94aef2e7e91d9e397eff9c286026bcf3e" translate="yes" xml:space="preserve">
          <source>A documentation comment of an element is a comment that begins with &quot;&lt;code&gt;/**&lt;/code&gt;&quot; , ends with a separate &quot;&lt;code&gt;*/&lt;/code&gt;&quot;, and immediately precedes the element, ignoring white space. Therefore, a documentation comment contains at least three&quot;&lt;code&gt;*&lt;/code&gt;&quot; characters. The text returned for the documentation comment is a processed form of the comment as it appears in source code. The leading &quot;&lt;code&gt;/**&lt;/code&gt;&quot; and trailing &quot;&lt;code&gt;*/&lt;/code&gt;&quot; are removed. For lines of the comment starting after the initial &quot;&lt;code&gt;/**&lt;/code&gt;&quot;, leading white space characters are discarded as are any consecutive &quot;&lt;code&gt;*&lt;/code&gt;&quot; characters appearing after the white space or starting the line. The processed lines are then concatenated together (including line terminators) and returned.</source>
          <target state="translated">요소의 문서 주석은 &quot; &lt;code&gt;/**&lt;/code&gt; &quot;로 시작 하고 별도의 &quot; &lt;code&gt;*/&lt;/code&gt; &quot;로 끝나고 공백을 무시하고 요소 바로 앞에 오는 주석입니다 . 따라서 문서 주석에는 최소 3 개의 &quot; &lt;code&gt;*&lt;/code&gt; &quot;문자가 포함됩니다. 문서 주석에 대해 리턴 된 텍스트는 소스 코드에 표시되는 주석의 처리 된 양식입니다. 선행 &quot; &lt;code&gt;/**&lt;/code&gt; &quot;및 후행 &quot; &lt;code&gt;*/&lt;/code&gt; &quot;가 제거됩니다. 초기 &quot; &lt;code&gt;/**&lt;/code&gt; &quot; 다음에 시작되는 주석 행의 경우 선행 공백 문자는 연속적인 &quot; &lt;code&gt;*&lt;/code&gt; 공백 다음에 문자가 나타나거나 줄을 시작합니다. 그런 다음 처리 된 줄이 함께 연결되고 (줄 종결자를 포함하여) 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc953ed4ff12851c45b606c0dca273654084ace6" translate="yes" xml:space="preserve">
          <source>A domain name consisting of one or more</source>
          <target state="translated">하나 이상의 도메인으로 구성된 도메인 이름</target>
        </trans-unit>
        <trans-unit id="f0a13517cae5c3558d1607d5b802c6dbc9b72514" translate="yes" xml:space="preserve">
          <source>A dotted-quad IPv4 address of the form</source>
          <target state="translated">형식의 점으로 구분 된 IPv4 주소</target>
        </trans-unit>
        <trans-unit id="5a84dd1bce4cdbeb08becc1d7ae6d1d359e78aa6" translate="yes" xml:space="preserve">
          <source>A double buffer is not comparable to any other type of object.</source>
          <target state="translated">이중 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c42eb01adeccbb9bb551f09447b1ea18887c870f" translate="yes" xml:space="preserve">
          <source>A double buffer is not equal to any other type of object.</source>
          <target state="translated">이중 버퍼는 다른 유형의 객체와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eef80ddc49ceb62f77b5716e5156654ae8ddee60" translate="yes" xml:space="preserve">
          <source>A double buffer.</source>
          <target state="translated">더블 버퍼.</target>
        </trans-unit>
        <trans-unit id="ec23e7b42341db8a34268a2d8f2135e2acccceeb" translate="yes" xml:space="preserve">
          <source>A duration of zero or one nanosecond would have no truncation effect. Passing one of these will return the underlying clock.</source>
          <target state="translated">0 또는 1 나노초의 지속 시간은 절단 효과가 없습니다. 이 중 하나를 전달하면 기본 시계가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="707ea64794ea49795fc1fbf1c5bb2e342b9a2947" translate="yes" xml:space="preserve">
          <source>A duration of zero would have no offsetting effect. Passing zero will return the underlying clock.</source>
          <target state="translated">지속 시간이 0이면 오프셋 효과가 없습니다. 0을 전달하면 기본 시계가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b537f9aafa5416ef5331e31b922ae14170c2110" translate="yes" xml:space="preserve">
          <source>A dynamic call site is linked just before its first execution. The bootstrap method call implementing the linkage occurs within a thread that is attempting a first execution.</source>
          <target state="translated">동적 호출 사이트는 첫 실행 직전에 연결됩니다. 연결을 구현하는 부트 스트랩 메서드 호출은 첫 번째 실행을 시도하는 스레드 내에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80f373678cec5d9f9816518ac0151384e5addeb3" translate="yes" xml:space="preserve">
          <source>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.</source>
          <target state="translated">동적 호출 사이트는 원래 연결되지 않은 상태입니다. 이 상태에서는 호출 사이트가 호출 할 대상 메소드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0e84d0f37ed837b18dc38b43e9581df209ca4d8" translate="yes" xml:space="preserve">
          <source>A facility for threads to schedule tasks for future execution in a background thread.</source>
          <target state="translated">백그라운드 스레드에서 향후 실행을 위해 작업을 예약하는 스레드 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bdaa3fdd98dc8ca4ca47e134d4bacf3327c2afba" translate="yes" xml:space="preserve">
          <source>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</source>
          <target state="translated">백그라운드 스레드에서 향후 실행을 위해 작업을 예약하는 스레드 기능입니다. 작업은 한 번만 실행하거나 정기적으로 반복적으로 실행되도록 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e0b467ba2dc989506e0ee0a0bb1aacb33912437" translate="yes" xml:space="preserve">
          <source>A factory object that generates Preferences objects.</source>
          <target state="translated">기본 설정 개체를 생성하는 팩토리 개체입니다.</target>
        </trans-unit>
        <trans-unit id="101b3fce69853a396df998619090ea7c49a64227" translate="yes" xml:space="preserve">
          <source>A factory object that generates Preferences objects. Providers of new &lt;a href=&quot;preferences&quot;&gt;&lt;code&gt;Preferences&lt;/code&gt;&lt;/a&gt; implementations should provide corresponding &lt;code&gt;PreferencesFactory&lt;/code&gt; implementations so that the new &lt;code&gt;Preferences&lt;/code&gt; implementation can be installed in place of the platform-specific default implementation.</source>
          <target state="translated">기본 설정 개체를 생성하는 팩토리 개체입니다. 새로운 &lt;a href=&quot;preferences&quot;&gt; &lt;code&gt;Preferences&lt;/code&gt; &lt;/a&gt; 구현 제공자는 플랫폼 별 기본 구현 대신 새 &lt;code&gt;Preferences&lt;/code&gt; 구현을 설치할 수 있도록 해당 &lt;code&gt;PreferencesFactory&lt;/code&gt; 설정 Factory 구현을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="63b7b032fe80d4faf6433141990e02b45251e415" translate="yes" xml:space="preserve">
          <source>A family of character subsets representing the character blocks in the Unicode specification.</source>
          <target state="translated">유니 코드 사양에서 문자 블록을 나타내는 문자 하위 집합 패밀리입니다.</target>
        </trans-unit>
        <trans-unit id="a24fb7d86b530dcf58935f77822385b0ba5a6d7b" translate="yes" xml:space="preserve">
          <source>A family of character subsets representing the character blocks in the Unicode specification. Character blocks generally define characters used for a specific script or purpose. A character is contained by at most one Unicode block.</source>
          <target state="translated">유니 코드 사양에서 문자 블록을 나타내는 문자 하위 집합 패밀리입니다. 문자 블록은 일반적으로 특정 스크립트 또는 목적에 사용되는 문자를 정의합니다. 문자는 최대 하나의 유니 코드 블록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec563e568f55e4f71b71ac1435cf68999ac1f70" translate="yes" xml:space="preserve">
          <source>A family of character subsets representing the character scripts defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr24/&quot;&gt; &lt;i&gt;Unicode Standard Annex #24: Script Names&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.unicode.org/reports/tr24/&quot;&gt;&lt;i&gt;Unicode Standard Annex # 24 : Script Names에&lt;/i&gt;&lt;/a&gt; 정의 된 문자 스크립트를 나타내는 문자 서브 세트 . &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="9c8c5279fc99f2514225c6d1d19175798ae080ea" translate="yes" xml:space="preserve">
          <source>A family of character subsets representing the character scripts defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr24/&quot;&gt; &lt;i&gt;Unicode Standard Annex #24: Script Names&lt;/i&gt;&lt;/a&gt;. Every Unicode character is assigned to a single Unicode script, either a specific script, such as &lt;a href=&quot;character.unicodescript#LATIN&quot;&gt;&lt;code&gt;Latin&lt;/code&gt;&lt;/a&gt;, or one of the following three special values, &lt;a href=&quot;character.unicodescript#INHERITED&quot;&gt;&lt;code&gt;Inherited&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;character.unicodescript#COMMON&quot;&gt;&lt;code&gt;Common&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;character.unicodescript#UNKNOWN&quot;&gt;&lt;code&gt;Unknown&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.unicode.org/reports/tr24/&quot;&gt;&lt;i&gt;Unicode Standard Annex # 24 : Script Names에&lt;/i&gt;&lt;/a&gt; 정의 된 문자 스크립트를 나타내는 문자 서브 세트 . 모든 유니 코드 문자는 단일 유니 코드 스크립트, 즉 &lt;a href=&quot;character.unicodescript#LATIN&quot;&gt; &lt;code&gt;Latin&lt;/code&gt; &lt;/a&gt; 과 같은 특정 스크립트 또는 &lt;a href=&quot;character.unicodescript#INHERITED&quot;&gt; &lt;code&gt;Inherited&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;character.unicodescript#COMMON&quot;&gt; &lt;code&gt;Common&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;character.unicodescript#UNKNOWN&quot;&gt; &lt;code&gt;Unknown&lt;/code&gt; &lt;/a&gt; 세 가지 특수 값 중 하나에 지정 됩니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="cb6cfa1af99682ad4ccf2d09f7b713dfe2919b99" translate="yes" xml:space="preserve">
          <source>A field is date-based if it can be derived from &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt;. Note that it is valid for both &lt;code&gt;isDateBased()&lt;/code&gt; and &lt;code&gt;isTimeBased()&lt;/code&gt; to return false, such as when representing a field like minute-of-week.</source>
          <target state="translated">필드는 &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 에서 파생 될 수있는 경우 날짜 기반 입니다. &lt;code&gt;isDateBased()&lt;/code&gt; 및 &lt;code&gt;isTimeBased()&lt;/code&gt; 가 모두 주와 같은 필드를 나타내는 경우와 같이 false를 리턴 하는 데 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="06d4b6c0fcbdbfaf03d612c54baeb44342bf70b4" translate="yes" xml:space="preserve">
          <source>A field is time-based if it can be derived from &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt;. Note that it is valid for both &lt;code&gt;isDateBased()&lt;/code&gt; and &lt;code&gt;isTimeBased()&lt;/code&gt; to return false, such as when representing a field like minute-of-week.</source>
          <target state="translated">&lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 에서 파생 될 수있는 필드는 시간 기반 입니다. &lt;code&gt;isDateBased()&lt;/code&gt; 및 &lt;code&gt;isTimeBased()&lt;/code&gt; 가 모두 주와 같은 필드를 나타내는 경우와 같이 false를 리턴 하는 데 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="b07348f8e4cb68554849ca186156d3c0c4587481" translate="yes" xml:space="preserve">
          <source>A field is used to express part of a larger date-time, such as year, month-of-year or second-of-minute. All fields implement &lt;a href=&quot;temporalfield&quot;&gt;&lt;code&gt;TemporalField&lt;/code&gt;&lt;/a&gt;. The set of well known fields are defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;. Additional fields are defined by &lt;a href=&quot;julianfields&quot;&gt;&lt;code&gt;JulianFields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields&quot;&gt;&lt;code&gt;WeekFields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;. The field interface is designed to allow application defined fields.</source>
          <target state="translated">필드는 연도, 월 또는 분과 같은 더 큰 날짜 시간의 일부를 나타내는 데 사용됩니다. 모든 필드는 &lt;a href=&quot;temporalfield&quot;&gt; &lt;code&gt;TemporalField&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 잘 알려진 필드 세트는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 (예 : &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; ) . 추가 필드는 &lt;a href=&quot;julianfields&quot;&gt; &lt;code&gt;JulianFields&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weekfields&quot;&gt; &lt;code&gt;WeekFields&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 로 정의됩니다 . 필드 인터페이스는 응용 프로그램 정의 필드를 허용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="835f2490b6cfe9fa75186c818d8516b2e4a5f979" translate="yes" xml:space="preserve">
          <source>A field not described by a more specific kind (like &lt;code&gt;ENUM_CONSTANT&lt;/code&gt;).</source>
          <target state="translated">보다 구체적인 종류 (예 : &lt;code&gt;ENUM_CONSTANT&lt;/code&gt; )로 설명되지 않은 필드</target>
        </trans-unit>
        <trans-unit id="b9124f145776683f4253809cd0411ccd5b528c41" translate="yes" xml:space="preserve">
          <source>A field of date-time, such as month-of-year or hour-of-minute.</source>
          <target state="translated">년 또는 분과 같은 날짜-시간 필드.</target>
        </trans-unit>
        <trans-unit id="dda0e6d153e939c0eebf6f92e4c6f459678f22a4" translate="yes" xml:space="preserve">
          <source>A file attribute view provides a read-only or updatable view of a set of file attributes. This method is intended to be used where the file attribute view defines type-safe methods to read or update the file attributes. The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attribute view required and the method returns an instance of that type if supported. The &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; type supports access to the basic attributes of a file. Invoking this method to select a file attribute view of that type will always return an instance of that class.</source>
          <target state="translated">파일 속성보기는 파일 속성 세트의 읽기 전용 또는 업데이트 가능한보기를 제공합니다. 이 방법은 파일 속성보기가 파일 속성을 읽거나 업데이트하기 위해 형식에 안전한 방법을 정의하는 경우에 사용됩니다. &lt;code&gt;type&lt;/code&gt; 파라미터는 요구되는 특성 뷰의 타입 및 지원되는 경우에있어서 그 타입의 인스턴스를 리턴한다. &lt;a href=&quot;attribute/basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; 의&lt;/a&gt; 유형 지원은 파일의 기본 속성에 액세스 할 수 있습니다. 해당 유형의 파일 속성보기를 선택하기 위해이 메소드를 호출하면 항상 해당 클래스의 인스턴스가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="deda609125e7d48e407f76f729b8f27d65f74ddb" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of a &lt;em&gt;basic set&lt;/em&gt; of file attributes common to many file systems.</source>
          <target state="translated">많은 파일 시스템에 공통적 인 &lt;em&gt;기본&lt;/em&gt; 파일 속성 &lt;em&gt;세트&lt;/em&gt; 를 제공하는 파일 속성보기입니다 .</target>
        </trans-unit>
        <trans-unit id="c25c5edd2e59e66e30742b0dc9fb42aac420e492" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of a &lt;em&gt;basic set&lt;/em&gt; of file attributes common to many file systems. The basic set of file attributes consist of &lt;em&gt;mandatory&lt;/em&gt; and &lt;em&gt;optional&lt;/em&gt; file attributes as defined by the &lt;a href=&quot;basicfileattributes&quot;&gt;&lt;code&gt;BasicFileAttributes&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">많은 파일 시스템에 공통적 인 &lt;em&gt;기본&lt;/em&gt; 파일 속성 &lt;em&gt;세트&lt;/em&gt; 를 제공하는 파일 속성보기입니다 . 기본 파일 속성 세트 는 &lt;a href=&quot;basicfileattributes&quot;&gt; &lt;code&gt;BasicFileAttributes&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 정의 된 &lt;em&gt;필수&lt;/em&gt; 및 &lt;em&gt;선택적&lt;/em&gt; 파일 속성으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f5f657f89b3a00a961d3cdfff1050605cb66a30" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of a file's user-defined attributes, sometimes known as &lt;em&gt;extended attributes&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;확장 속성&lt;/em&gt; 이라고도하는 파일의 사용자 정의 속성보기를 제공하는 파일 속성보기입니다 .</target>
        </trans-unit>
        <trans-unit id="92134ae2669883f7bd8d353e8b759e080264ae92" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of a file's user-defined attributes, sometimes known as &lt;em&gt;extended attributes&lt;/em&gt;. User-defined file attributes are used to store metadata with a file that is not meaningful to the file system. It is primarily intended for file system implementations that support such a capability directly but may be emulated. The details of such emulation are highly implementation specific and therefore not specified.</source>
          <target state="translated">&lt;em&gt;확장 속성&lt;/em&gt; 이라고도하는 파일의 사용자 정의 속성보기를 제공하는 파일 속성보기입니다 . 사용자 정의 파일 속성은 파일 시스템에 의미가없는 파일과 함께 메타 데이터를 저장하는 데 사용됩니다. 주로 그러한 기능을 직접 지원하지만 에뮬레이트 될 수있는 파일 시스템 구현을위한 것입니다. 이러한 에뮬레이션의 세부 사항은 구현에 따라 다르므로 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e6a4b8e3954a7ff014e199475145d881eb3c5987" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of the file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.</source>
          <target state="translated">POSIX (Portable Operating System Interface) 표준 제품군을 구현하는 운영 체제에서 사용하는 파일 시스템의 파일과 일반적으로 관련된 파일 속성의보기를 제공하는 파일 속성보기입니다.</target>
        </trans-unit>
        <trans-unit id="73aab05f1958ac269a1d81f012b9a0e86f942671" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of the legacy &quot;DOS&quot; file attributes.</source>
          <target state="translated">레거시 &quot;DOS&quot;파일 속성보기를 제공하는 파일 속성보기</target>
        </trans-unit>
        <trans-unit id="06ce420caee228b75176ea93c6da6be3e8962c23" translate="yes" xml:space="preserve">
          <source>A file attribute view that provides a view of the legacy &quot;DOS&quot; file attributes. These attributes are supported by file systems such as the File Allocation Table (FAT) format commonly used in &lt;em&gt;consumer devices&lt;/em&gt;.</source>
          <target state="translated">레거시 &quot;DOS&quot;파일 속성보기를 제공하는 파일 속성보기 이러한 속성은 &lt;em&gt;소비자 장치&lt;/em&gt; 에서 일반적으로 사용되는 FAT (File Allocation Table) 형식과 같은 파일 시스템에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c56af10820e6747bde58155c74dc6b8cb1c563e9" translate="yes" xml:space="preserve">
          <source>A file attribute view that supports reading or updating a file's Access Control Lists (ACL) or file owner attributes.</source>
          <target state="translated">파일의 ACL (액세스 제어 목록) 또는 파일 소유자 속성을 읽거나 업데이트 할 수있는 파일 속성보기입니다.</target>
        </trans-unit>
        <trans-unit id="fc8f481ef9d0d618680cc9caba8c29e3b337fd06" translate="yes" xml:space="preserve">
          <source>A file attribute view that supports reading or updating the owner of a file.</source>
          <target state="translated">파일 소유자 읽기 또는 업데이트를 지원하는 파일 속성보기입니다.</target>
        </trans-unit>
        <trans-unit id="637eb168120f6d58bb9a543da7d437ff587931ee" translate="yes" xml:space="preserve">
          <source>A file attribute view that supports reading or updating the owner of a file. This file attribute view is intended for file system implementations that support a file attribute that represents an identity that is the owner of the file. Often the owner of a file is the identity of the entity that created the file.</source>
          <target state="translated">파일 소유자 읽기 또는 업데이트를 지원하는 파일 속성보기입니다. 이 파일 속성보기는 파일 소유자 인 ID를 나타내는 파일 속성을 지원하는 파일 시스템 구현을위한 것입니다. 종종 파일의 소유자는 파일을 만든 엔티티의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="50d3c544cf02930f72d3dd2dcf7596521b56b995" translate="yes" xml:space="preserve">
          <source>A file channel is a &lt;a href=&quot;seekablebytechannel&quot;&gt;&lt;code&gt;SeekableByteChannel&lt;/code&gt;&lt;/a&gt; that is connected to a file. It has a current</source>
          <target state="translated">파일 채널은 파일에 연결된 &lt;a href=&quot;seekablebytechannel&quot;&gt; &lt;code&gt;SeekableByteChannel&lt;/code&gt; &lt;/a&gt; 입니다. 그것은 전류가</target>
        </trans-unit>
        <trans-unit id="a3d45873616dfb5f64695ebaf34a5417aaf96574" translate="yes" xml:space="preserve">
          <source>A file channel is created by invoking one of the &lt;a href=&quot;filechannel#open-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; methods defined by this class. A file channel can also be obtained from an existing &lt;a href=&quot;../../io/fileinputstream#getChannel--&quot;&gt;&lt;code&gt;FileInputStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../io/fileoutputstream#getChannel--&quot;&gt;&lt;code&gt;FileOutputStream&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../io/randomaccessfile#getChannel--&quot;&gt;&lt;code&gt;RandomAccessFile&lt;/code&gt;&lt;/a&gt; object by invoking that object's &lt;code&gt;getChannel&lt;/code&gt; method, which returns a file channel that is connected to the same underlying file. Where the file channel is obtained from an existing stream or random access file then the state of the file channel is intimately connected to that of the object whose &lt;code&gt;getChannel&lt;/code&gt; method returned the channel. Changing the channel's position, whether explicitly or by reading or writing bytes, will change the file position of the originating object, and vice versa. Changing the file's length via the file channel will change the length seen via the originating object, and vice versa. Changing the file's content by writing bytes will change the content seen by the originating object, and vice versa.</source>
          <target state="translated">파일 채널은 이 클래스에 의해 정의 된 &lt;a href=&quot;filechannel#open-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출하여 작성됩니다 . 동일한 기본 파일에 연결된 파일 채널을 반환하는 해당 객체의 &lt;code&gt;getChannel&lt;/code&gt; 메소드 를 호출 하여 기존 &lt;a href=&quot;../../io/fileinputstream#getChannel--&quot;&gt; &lt;code&gt;FileInputStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../io/fileoutputstream#getChannel--&quot;&gt; &lt;code&gt;FileOutputStream&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/randomaccessfile#getChannel--&quot;&gt; &lt;code&gt;RandomAccessFile&lt;/code&gt; &lt;/a&gt; 객체 에서 파일 채널을 가져올 수도 있습니다 . 파일 스트림이 기존 스트림 또는 임의 액세스 파일에서 확보되는 경우 파일 채널의 상태는 &lt;code&gt;getChannel&lt;/code&gt; 이있는 객체의 상태와 밀접하게 연결됩니다.메소드가 채널을 리턴했습니다. 명시 적으로 또는 바이트를 읽거나 쓰는 방식으로 채널 위치를 변경하면 원래 객체의 파일 위치가 변경되고 그 반대도 마찬가지입니다. 파일 채널을 통해 파일 길이를 변경하면 원래 객체를 통해 보이는 길이가 변경되고 그 반대도 마찬가지입니다. 바이트를 작성하여 파일의 내용을 변경하면 원래 객체에서 본 내용이 변경되고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b94e4d0c80198834d983bc6e3bb51a9dd99a5d5e" translate="yes" xml:space="preserve">
          <source>A file channel that is open for writing may be in</source>
          <target state="translated">쓰기 위해 열려있는 파일 채널이</target>
        </trans-unit>
        <trans-unit id="cb5c27031614e42ea12644e9d3cc607334c9b99b" translate="yes" xml:space="preserve">
          <source>A file lock is either</source>
          <target state="translated">파일 잠금은</target>
        </trans-unit>
        <trans-unit id="e16568056aeea069ecd34d375096a08ef82c7ca7" translate="yes" xml:space="preserve">
          <source>A file output stream is an output stream for writing data to a &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;.</source>
          <target state="translated">파일 출력 스트림은 &lt;code&gt;File&lt;/code&gt; 또는 &lt;code&gt;FileDescriptor&lt;/code&gt; 에 데이터를 쓰는 출력 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="6d6f1007335cda7cde3d679a1dbaf6aa504670c2" translate="yes" xml:space="preserve">
          <source>A file output stream is an output stream for writing data to a &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;. Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one &lt;code&gt;FileOutputStream&lt;/code&gt; (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.</source>
          <target state="translated">파일 출력 스트림은 &lt;code&gt;File&lt;/code&gt; 또는 &lt;code&gt;FileDescriptor&lt;/code&gt; 에 데이터를 쓰는 출력 스트림입니다 . 파일의 사용 가능 여부는 기본 플랫폼에 따라 다릅니다. 특히 일부 플랫폼에서는 한 번에 하나의 &lt;code&gt;FileOutputStream&lt;/code&gt; (또는 다른 파일 쓰기 객체) 만 쓰기 위해 파일을 열 수 있습니다 . 이러한 상황에서 관련된 파일이 이미 열려 있으면이 클래스의 생성자가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9dfaa0b7bf6f105699605d63ef04558be23f70fd" translate="yes" xml:space="preserve">
          <source>A file system is open upon creation and can be closed by invoking its &lt;a href=&quot;filesystem#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. Once closed, any further attempt to access objects in the file system cause &lt;a href=&quot;closedfilesystemexception&quot;&gt;&lt;code&gt;ClosedFileSystemException&lt;/code&gt;&lt;/a&gt; to be thrown. File systems created by the default &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;provider&lt;/code&gt;&lt;/a&gt; cannot be closed.</source>
          <target state="translated">파일 시스템은 작성시 열려 있으며 &lt;a href=&quot;filesystem#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 닫을 수 있습니다 . 닫힌 후에는 파일 시스템의 객체에 대한 추가 액세스 시도로 인해 &lt;a href=&quot;closedfilesystemexception&quot;&gt; &lt;code&gt;ClosedFileSystemException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 기본 &lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;provider&lt;/code&gt; &lt;/a&gt; 가 작성한 파일 시스템을 닫을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d1780ff9ebff809b69e5e84bd16e835fd70a0aa" translate="yes" xml:space="preserve">
          <source>A file system is the factory for several types of objects:</source>
          <target state="translated">파일 시스템은 여러 유형의 객체에 대한 팩토리입니다.</target>
        </trans-unit>
        <trans-unit id="2aafa7d2b1e430fc99b0ad47e955d5980d694e00" translate="yes" xml:space="preserve">
          <source>A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as</source>
          <target state="translated">파일 시스템은 실제 파일 시스템 객체에 대한 특정 작업 (예 : 읽기, 쓰기 및 실행)에 대한 제한을 구현할 수 있습니다. 이러한 제한은 통칭하여</target>
        </trans-unit>
        <trans-unit id="1e8b4b9993656e1244070ad20dae9aefaa220eb7" translate="yes" xml:space="preserve">
          <source>A file system provider is a concrete implementation of this class that implements the abstract methods defined by this class. A provider is identified by a &lt;code&gt;URI&lt;/code&gt;&lt;a href=&quot;filesystemprovider#getScheme--&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt;. The default provider is identified by the URI scheme &quot;file&quot;. It creates the &lt;a href=&quot;../filesystem&quot;&gt;&lt;code&gt;FileSystem&lt;/code&gt;&lt;/a&gt; that provides access to the file systems accessible to the Java virtual machine. The &lt;a href=&quot;../filesystems&quot;&gt;&lt;code&gt;FileSystems&lt;/code&gt;&lt;/a&gt; class defines how file system providers are located and loaded. The default provider is typically a system-default provider but may be overridden if the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is set. In that case, the provider has a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. All other providers have a zero argument constructor that initializes the provider.</source>
          <target state="translated">파일 시스템 제공자는이 클래스에 의해 정의 된 추상 메소드를 구현하는이 클래스의 구체적 구현입니다. 공급자는 &lt;code&gt;URI&lt;/code&gt; &lt;a href=&quot;filesystemprovider#getScheme--&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 식별됩니다 . 기본 제공자는 URI 스킴 &quot;file&quot;로 식별됩니다. Java 가상 머신에 액세스 가능한 파일 시스템에 대한 액세스를 제공 하는 &lt;a href=&quot;../filesystem&quot;&gt; &lt;code&gt;FileSystem&lt;/code&gt; &lt;/a&gt; 을 작성합니다 . &lt;a href=&quot;../filesystems&quot;&gt; &lt;code&gt;FileSystems&lt;/code&gt; 도&lt;/a&gt; 파일 시스템 제공 업체가 위치 및로드 방법 클래스 정의합니다. 기본 제공자는 일반적으로 시스템 기본 제공자이지만 시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 가 설정된 경우 대체 될 수 있습니다 . 이 경우 공급자는 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 인수 생성자를 하나 갖습니다.. 다른 모든 공급자에는 공급자를 초기화하는 인수 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce65bc131fb341143ffa2432afe6788f89f640c4" translate="yes" xml:space="preserve">
          <source>A file system provides access to a file store that may be composed of a number of distinct file hierarchies, each with its own top-level root directory. Unless denied by the security manager, each element in the returned iterator corresponds to the root directory of a distinct file hierarchy. The order of the elements is not defined. The file hierarchies may change during the lifetime of the Java virtual machine. For example, in some implementations, the insertion of removable media may result in the creation of a new file hierarchy with its own top-level directory.</source>
          <target state="translated">파일 시스템은 각각 고유 한 최상위 루트 디렉토리가있는 여러 개의 고유 한 파일 계층으로 구성 될 수있는 파일 저장소에 대한 액세스를 제공합니다. 보안 관리자가 거부하지 않는 한, 리턴 된 반복자의 각 요소는 고유 파일 계층의 루트 디렉토리에 해당합니다. 요소의 순서는 정의되어 있지 않습니다. 파일 계층은 Java 가상 머신의 수명 동안 변경 될 수 있습니다. 예를 들어, 일부 구현에서, 이동식 매체를 삽입하면 자체 최상위 디렉토리를 사용하여 새 파일 계층이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ce0311f6028fd1552cf502d1719372ae4c2342" translate="yes" xml:space="preserve">
          <source>A file type detector for probing a file to guess its file type.</source>
          <target state="translated">파일 형식을 추측하기 위해 파일을 검사하기위한 파일 형식 탐지기입니다.</target>
        </trans-unit>
        <trans-unit id="61027a230d12f615246216d95e4ebcd7132e375c" translate="yes" xml:space="preserve">
          <source>A file type detector is a concrete implementation of this class, has a zero-argument constructor, and implements the abstract methods specified below.</source>
          <target state="translated">파일 형식 탐지기는이 클래스의 구체적인 구현이며 인수가없는 생성자를 가지며 아래에 지정된 추상 메서드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7a8fa8c5ab136a06c54fd39e4c674ceb8e8879dc" translate="yes" xml:space="preserve">
          <source>A file-lock object is created each time a lock is acquired on a file via one of the &lt;a href=&quot;filechannel#lock-long-long-boolean-&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;filechannel#tryLock-long-long-boolean-&quot;&gt;&lt;code&gt;tryLock&lt;/code&gt;&lt;/a&gt; methods of the &lt;a href=&quot;filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt; class, or the &lt;a href=&quot;asynchronousfilechannel#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asynchronousfilechannel#tryLock-long-long-boolean-&quot;&gt;&lt;code&gt;tryLock&lt;/code&gt;&lt;/a&gt; methods of the &lt;a href=&quot;asynchronousfilechannel&quot;&gt;&lt;code&gt;AsynchronousFileChannel&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt; 클래스 는 FileChannel 클래스의 &lt;a href=&quot;asynchronousfilechannel#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asynchronousfilechannel#tryLock-long-long-boolean-&quot;&gt; &lt;code&gt;tryLock&lt;/code&gt; &lt;/a&gt; 메소드 또는 &lt;a href=&quot;asynchronousfilechannel&quot;&gt; &lt;code&gt;AsynchronousFileChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;filechannel#lock-long-long-boolean-&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;filechannel#tryLock-long-long-boolean-&quot;&gt; &lt;code&gt;tryLock&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 파일에서 잠금을 획득 할 때마다 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad42d41492ff4c772586b7c3843a8158af9ec343" translate="yes" xml:space="preserve">
          <source>A file-lock object is initially valid. It remains valid until the lock is released by invoking the &lt;a href=&quot;filelock#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method, by closing the channel that was used to acquire it, or by the termination of the Java virtual machine, whichever comes first. The validity of a lock may be tested by invoking its &lt;a href=&quot;filelock#isValid--&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일 잠금 객체는 처음에 유효합니다. 잠금 &lt;a href=&quot;filelock#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 방법 을 호출 하거나이를 확보하는 데 사용 된 채널을 닫거나 Java 가상 머신을 종료 하여 잠금이 해제 될 때까지 유효합니다 . 잠금의 유효성은 &lt;a href=&quot;filelock#isValid--&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="711939d8e50341d6cac3f60c7b46e0edf7fe9bab" translate="yes" xml:space="preserve">
          <source>A file-lock object records the file channel upon whose file the lock is held, the type and validity of the lock, and the position and size of the locked region. Only the validity of a lock is subject to change over time; all other aspects of a lock's state are immutable.</source>
          <target state="translated">파일 잠금 오브젝트는 파일이 잠금을 보유한 파일 채널, 잠금 유형 및 유효성, 잠금 영역의 위치 및 크기를 기록합니다. 잠금의 유효성 만 시간이 지남에 따라 변경 될 수 있습니다. 잠금 상태의 다른 모든 측면은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0bf0848690b34b73710f009588eaee0ac9b1dec7" translate="yes" xml:space="preserve">
          <source>A filter for abstract pathnames.</source>
          <target state="translated">추상 경로 이름에 대한 필터입니다.</target>
        </trans-unit>
        <trans-unit id="a0855a7cb6e2cc9c6bb1e2f2e28bf3f0bf0f605f" translate="yes" xml:space="preserve">
          <source>A flag for recording whether this attribute's values are ordered.</source>
          <target state="translated">이 속성 값의 순서를 기록하기위한 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="0150a3e4f9ae041e8ce2e60f25a81b388f493479" translate="yes" xml:space="preserve">
          <source>A flag indicating that there has been at least one &lt;code&gt;PropertyChangeVetoException&lt;/code&gt; thrown for the attempted setBeanContext operation.</source>
          <target state="translated">시도 된 setBeanContext 조작에 대해 하나 이상의 &lt;code&gt;PropertyChangeVetoException&lt;/code&gt; 이 발생 했음을 나타내는 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="dec43e8a9f1bb9d6b9c197216876739e500aa223" translate="yes" xml:space="preserve">
          <source>A float buffer is not comparable to any other type of object.</source>
          <target state="translated">플로트 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fb7a5a9e39b583648f523754a43509e1e7a8e4b" translate="yes" xml:space="preserve">
          <source>A float buffer is not equal to any other type of object.</source>
          <target state="translated">플로트 버퍼는 다른 유형의 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e77a58864e91572b793bb101954ce33a7471066" translate="yes" xml:space="preserve">
          <source>A float buffer.</source>
          <target state="translated">플로트 버퍼.</target>
        </trans-unit>
        <trans-unit id="095d84578b9b46db68702b89c5e268f351fac4b5" translate="yes" xml:space="preserve">
          <source>A format conversion provider provides format conversion services from one or more input formats to one or more output formats.</source>
          <target state="translated">형식 변환 공급자는 하나 이상의 입력 형식에서 하나 이상의 출력 형식으로 형식 변환 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9cc5d6ee4e5941d38db8fe246dade4e397e58a4b" translate="yes" xml:space="preserve">
          <source>A format conversion provider provides format conversion services from one or more input formats to one or more output formats. Converters include codecs, which encode and/or decode audio data, as well as transcoders, etc. Format converters provide methods for determining what conversions are supported and for obtaining an audio stream from which converted data can be read.</source>
          <target state="translated">형식 변환 공급자는 하나 이상의 입력 형식에서 하나 이상의 출력 형식으로 형식 변환 서비스를 제공합니다. 변환기는 트랜스 코더뿐만 아니라 오디오 데이터를 인코딩 및 / 또는 디코딩하는 코덱을 포함한다. 포맷 변환기는 어떤 변환이 지원되는지를 결정하고 변환 된 데이터를 읽을 수있는 오디오 스트림을 얻는 방법을 제공한다.</target>
        </trans-unit>
        <trans-unit id="787cdbb4f865ed56be30b06dfca7e0f4af1393ad" translate="yes" xml:space="preserve">
          <source>A formatted string</source>
          <target state="translated">형식화 된 문자열</target>
        </trans-unit>
        <trans-unit id="35d25a295891e4731302bd13ab6217bf8d2a28c1" translate="yes" xml:space="preserve">
          <source>A fragment of Java code representing an initializer for the current value.</source>
          <target state="translated">현재 값의 이니셜 라이저를 나타내는 Java 코드 조각입니다.</target>
        </trans-unit>
        <trans-unit id="f50712164fb4f66c4a5273060c757a95e13d5e62" translate="yes" xml:space="preserve">
          <source>A freshly-created lookup object on the &lt;a href=&quot;methodhandles#lookup--&quot;&gt;caller's class&lt;/a&gt; has all possible bits set, since the caller class can access all its own members. A lookup object on a new lookup class &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;created from a previous lookup object&lt;/a&gt; may have some mode bits set to zero. The purpose of this is to restrict access via the new lookup object, so that it can access only names which can be reached by the original lookup object, and also by the new lookup class.</source>
          <target state="translated">&lt;a href=&quot;methodhandles#lookup--&quot;&gt;호출자 클래스&lt;/a&gt; 에서 새로 작성된 조회 오브젝트 는 가능한 모든 비트 세트를 갖습니다. 호출자 클래스는 모든 자체 멤버에 액세스 할 수 있기 때문입니다. &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;이전 조회 객체에서 생성 된&lt;/a&gt; 새 조회 클래스의 조회 객체 에는 일부 모드 비트가 0으로 설정되어있을 수 있습니다. 이것의 목적은 새로운 룩업 객체를 통한 액세스를 제한하여 원래 룩업 객체와 새로운 룩업 클래스가 도달 할 수있는 이름에만 액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d07cafb2c426484441f2fe06c267dc28cd189d5" translate="yes" xml:space="preserve">
          <source>A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.</source>
          <target state="translated">두 개의 부분 결과를 받아 병합하는 함수입니다. 결합기 함수는 한 인수에서 다른 인수로 상태를 접고이를 리턴하거나 새 결과 컨테이너를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43bddcf15e634de817d95953c7f18c644307bb91" translate="yes" xml:space="preserve">
          <source>A function that creates and returns a new mutable result container.</source>
          <target state="translated">새로운 가변 결과 컨테이너를 생성하고 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ac772ea250f6df76a426391d3fc80b98a029b616" translate="yes" xml:space="preserve">
          <source>A function that folds a value into a mutable result container.</source>
          <target state="translated">값을 변경 가능한 결과 컨테이너로 접는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f1e987f1e57505c842f18a1165026e190dbf68de" translate="yes" xml:space="preserve">
          <source>A gauge monitor observes an attribute that is continuously variable with time. A gauge monitor sends notifications as follows:</source>
          <target state="translated">게이지 모니터는 시간에 따라 지속적으로 변하는 속성을 관찰합니다. 게이지 모니터는 다음과 같이 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f3bb2e152ff1aaee77640e95e07291f19892a22f" translate="yes" xml:space="preserve">
          <source>A generator of uniform pseudorandom values applicable for use in (among other contexts) isolated parallel computations that may generate subtasks.</source>
          <target state="translated">서브 태스크를 생성 할 수있는 고립 된 병렬 계산에 (다른 상황에서) 적용 할 수있는 균일 한 의사 난수 값 생성기.</target>
        </trans-unit>
        <trans-unit id="f296f7762bab23d802a5065844a5502434108582" translate="yes" xml:space="preserve">
          <source>A generator of uniform pseudorandom values applicable for use in (among other contexts) isolated parallel computations that may generate subtasks. Class &lt;code&gt;SplittableRandom&lt;/code&gt; supports methods for producing pseudorandom numbers of type &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt; with similar usages as for class &lt;a href=&quot;random&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; but differs in the following ways:</source>
          <target state="translated">서브 태스크를 생성 할 수있는 고립 된 병렬 계산에 (다른 상황에서) 적용 할 수있는 균일 한 의사 난수 값 생성기. 클래스 &lt;code&gt;SplittableRandom&lt;/code&gt; 는 형의 의사 난수 생성 방법 지원 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 클래스와 유사한 용도로 &lt;a href=&quot;random&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt; 그러나 다음과 같은 방법으로 다릅니다 :</target>
        </trans-unit>
        <trans-unit id="ee3e63d8bc812120b6319da0e643f81f18db8658" translate="yes" xml:space="preserve">
          <source>A generic account exception.</source>
          <target state="translated">일반적인 계정 예외입니다.</target>
        </trans-unit>
        <trans-unit id="ea8cc0b37c072a62f90548d86d62546be1b6030b" translate="yes" xml:space="preserve">
          <source>A generic credential exception.</source>
          <target state="translated">일반적인 자격 증명 예외입니다.</target>
        </trans-unit>
        <trans-unit id="8d3921e6c41e544a62aad090d777399ba09dfeb0" translate="yes" xml:space="preserve">
          <source>A generic element defines a family of types, not just one. If this is a generic element, a</source>
          <target state="translated">일반 요소는 유형이 아닌 유형 군을 정의합니다. 이것이 일반 요소 인 경우</target>
        </trans-unit>
        <trans-unit id="36a2626cbe080b42ca256bc3f5f06c6e465de057" translate="yes" xml:space="preserve">
          <source>A given connector need not support the generation of client stubs. However, the connectors specified by the JMX Remote API do (JMXMP Connector and RMI Connector).</source>
          <target state="translated">지정된 커넥터는 클라이언트 스텁 생성을 지원할 필요가 없습니다. 그러나 JMX Remote API에 의해 지정된 커넥터 (JMXMP 커넥터 및 RMI 커넥터)가 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b139f5ad6b7946d259047308f55c666e905ba834" translate="yes" xml:space="preserve">
          <source>A given invocation of the Java virtual machine maintains a system-wide list of file type detectors. Installed file type detectors are loaded using the service-provider loading facility defined by the &lt;a href=&quot;../../util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; class. Installed file type detectors are loaded using the system class loader. If the system class loader cannot be found then the extension class loader is used; If the extension class loader cannot be found then the bootstrap class loader is used. File type detectors are typically installed by placing them in a JAR file on the application class path or in the extension directory, the JAR file contains a provider-configuration file named &lt;code&gt;java.nio.file.spi.FileTypeDetector&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, and the file lists one or more fully-qualified names of concrete subclass of &lt;code&gt;FileTypeDetector &lt;/code&gt; that have a zero argument constructor. If the process of locating or instantiating the installed file type detectors fails then an unspecified error is thrown. The ordering that installed providers are located is implementation specific.</source>
          <target state="translated">JVM (Java Virtual Machine)을 호출하면 시스템 전체의 파일 유형 검출기 목록이 유지됩니다. 설치된 파일 유형 검출기는 &lt;a href=&quot;../../util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 클래스에 의해 정의 된 서비스 제공자로드 기능을 사용하여로드됩니다 . 설치된 파일 유형 감지기는 시스템 클래스 로더를 사용하여로드됩니다. 시스템 클래스 로더를 찾을 수 없으면 확장 클래스 로더가 사용됩니다. 확장 클래스 로더를 찾을 수 없으면 부트 스트랩 클래스 로더가 사용됩니다. 파일 유형 검출기는 일반적으로 애플리케이션 클래스 경로 또는 확장 디렉토리의 JAR 파일에 배치하여 설치하며, JAR 파일 은 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; &lt;code&gt;java.nio.file.spi.FileTypeDetector&lt;/code&gt; 라는 제공자 구성 파일을 포함합니다. /서비스파일에는 인수 생성자가없는 &lt;code&gt;FileTypeDetector &lt;/code&gt; 의 구체적인 하위 클래스의 정규화 된 이름이 하나 이상 나열 됩니다. 설치된 파일 유형 감지기를 찾거나 인스턴스화하는 프로세스가 실패하면 지정되지 않은 오류가 발생합니다. 설치된 공급자가있는 순서는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e3b442b5fe9a27c98a08c95f21bc990f7ab8bc7" translate="yes" xml:space="preserve">
          <source>A global color table is written to the output stream if one of the following conditions is met:</source>
          <target state="translated">다음 조건 중 하나가 충족되면 글로벌 색상 표가 출력 스트림에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8af0722143a8cd99cd10f9bcc5d199373569cb1d" translate="yes" xml:space="preserve">
          <source>A grouping of asynchronous channels for the purpose of resource sharing</source>
          <target state="translated">리소스 공유를위한 비동기 채널 그룹</target>
        </trans-unit>
        <trans-unit id="c24b47a3aa5a36d6a87410408d2c4d5a5faf5cfe" translate="yes" xml:space="preserve">
          <source>A grouping of asynchronous channels for the purpose of resource sharing.</source>
          <target state="translated">리소스 공유를위한 비동기 채널 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="9928d62a2404074511ec0f299ada0040336beb28" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream. Usually, this file descriptor is not used directly, but rather via the output stream known as &lt;code&gt;System.err&lt;/code&gt;.</source>
          <target state="translated">표준 오류 스트림에 대한 핸들입니다. 일반적으로이 파일 디스크립터는 직접 사용되지 않고 &lt;code&gt;System.err&lt;/code&gt; 이라는 출력 스트림을 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2838c09bf3325466fca5db9ee06eb2453bfff6d" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream. Usually, this file descriptor is not used directly, but rather via the input stream known as &lt;code&gt;System.in&lt;/code&gt;.</source>
          <target state="translated">표준 입력 스트림에 대한 핸들입니다. 일반적으로이 파일 디스크립터는 직접 사용되는 것이 아니라 &lt;code&gt;System.in&lt;/code&gt; 이라는 입력 스트림을 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8b2f584a4219597bac6f663c5cbf24cfa40cf51" translate="yes" xml:space="preserve">
          <source>A handle to the standard output stream. Usually, this file descriptor is not used directly, but rather via the output stream known as &lt;code&gt;System.out&lt;/code&gt;.</source>
          <target state="translated">표준 출력 스트림에 대한 핸들입니다. 일반적으로이 파일 디스크립터는 직접 사용되는 것이 아니라 &lt;code&gt;System.out&lt;/code&gt; 이라는 출력 스트림을 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a3f24c9968701ba089eded185c35bffc8539bb2" translate="yes" xml:space="preserve">
          <source>A handler for consuming the result of an asynchronous I/O operation.</source>
          <target state="translated">비동기 I / O 작업 결과를 사용하기위한 처리기</target>
        </trans-unit>
        <trans-unit id="87b43b91a9388e1643e11f5fb51e2f91d80cd199" translate="yes" xml:space="preserve">
          <source>A handler for consuming the result of an asynchronous operation</source>
          <target state="translated">비동기 작업의 결과를 소비하기위한 핸들러</target>
        </trans-unit>
        <trans-unit id="3cec3929b4904998820b22c6d9b5a5aebdfb2d20" translate="yes" xml:space="preserve">
          <source>A handler for rejected tasks that discards the oldest unhandled request and then retries &lt;code&gt;execute&lt;/code&gt;, unless the executor is shut down, in which case the task is discarded.</source>
          <target state="translated">가장 오래된 처리되지 않은 요청을 삭제 한 후 재 시도가 거부 된 태스크의 핸들러 &lt;code&gt;execute&lt;/code&gt; 집행자가 종료되지 않는 한 작업이 삭제되는 경우.</target>
        </trans-unit>
        <trans-unit id="6d2b537bf297eb19ca8a1ca48bc8a94afcc52f9b" translate="yes" xml:space="preserve">
          <source>A handler for rejected tasks that runs the rejected task directly in the calling thread of the &lt;code&gt;execute&lt;/code&gt; method, unless the executor has been shut down, in which case the task is discarded.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 이 종료되지 않은 경우 실행 메소드 의 호출 스레드에서 거부 된 태스크를 직접 실행하는 거부 된 태스크에 대한 핸들러입니다 .이 경우 태스크는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="12e0f3f68b2f87e89d6864a58af1905bcde37958" translate="yes" xml:space="preserve">
          <source>A handler for rejected tasks that silently discards the rejected task.</source>
          <target state="translated">거부 된 작업을 자동으로 삭제하는 거부 된 작업에 대한 처리기</target>
        </trans-unit>
        <trans-unit id="d3cce71daa234bfb9ba87e7bb64a50184f43e70f" translate="yes" xml:space="preserve">
          <source>A handler for rejected tasks that throws a &lt;code&gt;RejectedExecutionException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RejectedExecutionException&lt;/code&gt; 을 발생 시키는 거부 된 작업에 대한 처리기입니다 .</target>
        </trans-unit>
        <trans-unit id="7f8ca17fde6e602f88cd3d6a07f614961244d33f" translate="yes" xml:space="preserve">
          <source>A handler for tasks that cannot be executed by a &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 로 실행할 수없는 태스크의 핸들러입니다 .</target>
        </trans-unit>
        <trans-unit id="cb43ba18f8e33a313d98fe4907d0dc669c17300e" translate="yes" xml:space="preserve">
          <source>A hardware or software device that plays back a MIDI &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; is known as a &lt;em&gt;sequencer&lt;/em&gt;.</source>
          <target state="translated">MIDI &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 를 재생하는 하드웨어 또는 소프트웨어 장치를 시퀀서 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1050858df573c8b54a98d32a32a6761e7ca701a4" translate="yes" xml:space="preserve">
          <source>A hardware or software device that plays back a MIDI &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; is known as a &lt;em&gt;sequencer&lt;/em&gt;. A MIDI sequence contains lists of time-stamped MIDI data, such as might be read from a standard MIDI file. Most sequencers also provide functions for creating and editing sequences.</source>
          <target state="translated">MIDI &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 를 재생하는 하드웨어 또는 소프트웨어 장치를 시퀀서 라고 &lt;em&gt;합니다&lt;/em&gt; . MIDI 시퀀스에는 표준 MIDI 파일에서 읽을 수있는 타임 스탬프 된 MIDI 데이터 목록이 포함됩니다. 대부분의 시퀀서는 시퀀스 생성 및 편집 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a7edc5100c7524404899934b687c1b0263088ad" translate="yes" xml:space="preserve">
          <source>A hash code</source>
          <target state="translated">해시 코드</target>
        </trans-unit>
        <trans-unit id="8f0f5eba602ce509dcca3db786c22c74bdedbf76" translate="yes" xml:space="preserve">
          <source>A hash code based on the executable's hash code.</source>
          <target state="translated">실행 파일의 해시 코드를 기반으로하는 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="6422685e686802184d02914f59e5e03e37e4b920" translate="yes" xml:space="preserve">
          <source>A hash code for this &lt;code&gt;WeekFields&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;WeekFields&lt;/code&gt; 의 해시 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="082377c5769ccaeb74c377e922e220bd74c1eb8b" translate="yes" xml:space="preserve">
          <source>A hash code for this DecimalStyle.</source>
          <target state="translated">이 DecimalStyle의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1a0a2cbf33b6fc708b1e71a5607d7568aba4cd9d" translate="yes" xml:space="preserve">
          <source>A hash code for this abstract pathname</source>
          <target state="translated">이 추상 경로명의 해시 코드</target>
        </trans-unit>
        <trans-unit id="5e74913296ef0affb84d3a88b703ae21e89763f7" translate="yes" xml:space="preserve">
          <source>A hash code for this chronology.</source>
          <target state="translated">이 연대기의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="56ecf462977972b604f5d42c94c6433b5d120cb4" translate="yes" xml:space="preserve">
          <source>A hash code for this clock.</source>
          <target state="translated">이 시계의 해시 코드</target>
        </trans-unit>
        <trans-unit id="6d733f15fb333cbf3f6de70fb60920b8481a2562" translate="yes" xml:space="preserve">
          <source>A hash code for this date-time.</source>
          <target state="translated">이 날짜-시간의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="cd393e22a9982f36df6d1e49fdc513be03d5db18" translate="yes" xml:space="preserve">
          <source>A hash code for this date.</source>
          <target state="translated">이 날짜의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="75aa073250f910cbe612992bee56c47830c125f3" translate="yes" xml:space="preserve">
          <source>A hash code for this duration.</source>
          <target state="translated">이 기간 동안의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="ef6b3720cb101c6523e14b342faf358533e784b6" translate="yes" xml:space="preserve">
          <source>A hash code for this month-day.</source>
          <target state="translated">이 달의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="9d286da27efe86be8a56c732ea14a6d1d4c2dd17" translate="yes" xml:space="preserve">
          <source>A hash code for this offset.</source>
          <target state="translated">이 오프셋의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="338c5ee14af4c4f5108e22b8984af253203eb866" translate="yes" xml:space="preserve">
          <source>A hash code for this period.</source>
          <target state="translated">이 기간의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="d1ca372319e5779208c68834db7457509cffd5e9" translate="yes" xml:space="preserve">
          <source>A hash code for this range.</source>
          <target state="translated">이 범위의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="def95cbd7ecd69e1cb41c6e7fe9e142e1b6e12b9" translate="yes" xml:space="preserve">
          <source>A hash code for this time-zone ID.</source>
          <target state="translated">이 시간대 ID의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="21b0c4b6c9ca1f20ee357c40a64a32937d745822" translate="yes" xml:space="preserve">
          <source>A hash code for this time.</source>
          <target state="translated">이번에는 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="8fc40307541ad29754e7c8cc76d8cdac1da4dab9" translate="yes" xml:space="preserve">
          <source>A hash code for this year-month.</source>
          <target state="translated">올해의 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="0f0ed6aa7948b36fe936b86cc68d0c6dc3a1c7b0" translate="yes" xml:space="preserve">
          <source>A hash code for this year.</source>
          <target state="translated">올해의 해시 코드.</target>
        </trans-unit>
        <trans-unit id="c7260df544fa8e975c1248b223e104cf612fdcea" translate="yes" xml:space="preserve">
          <source>A hash code of this reference as an int.</source>
          <target state="translated">이 참조의 해시 코드를 정수로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c038c38ee7b79b8905fbe54cde0df6b4f273532e" translate="yes" xml:space="preserve">
          <source>A hash code value for this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 해시 코드 값</target>
        </trans-unit>
        <trans-unit id="85283c8b1e2ec2edadf924f01b3aaeb9490f0d58" translate="yes" xml:space="preserve">
          <source>A hash code value for this object.</source>
          <target state="translated">이 객체의 해시 코드 값</target>
        </trans-unit>
        <trans-unit id="5e119773bedd6f34e3f4a604ececbbc72f9f1cf7" translate="yes" xml:space="preserve">
          <source>A hash table supporting full concurrency of retrievals and high expected concurrency for updates.</source>
          <target state="translated">검색의 전체 동시성 및 업데이트에 대한 예상되는 높은 동시성을 지원하는 해시 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="7be080c5693a5494d8a81110a7c2c060ad2b0789" translate="yes" xml:space="preserve">
          <source>A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as &lt;a href=&quot;../hashtable&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt;, and includes versions of methods corresponding to each method of &lt;code&gt;Hashtable&lt;/code&gt;. However, even though all operations are thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking, and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table in a way that prevents all access. This class is fully interoperable with &lt;code&gt;Hashtable&lt;/code&gt; in programs that rely on its thread safety but not on its synchronization details.</source>
          <target state="translated">검색의 전체 동시성 및 업데이트에 대한 예상되는 높은 동시성을 지원하는 해시 테이블입니다. 이 클래스는 &lt;a href=&quot;../hashtable&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; 과 동일한 기능 사양을 준수하며 각 &lt;code&gt;Hashtable&lt;/code&gt; 메서드에 해당하는 메서드 버전을 포함 합니다. 그러나 모든 작업이 스레드로부터 안전하더라도 검색 작업에는 잠금이 필요하지 &lt;em&gt;않으며&lt;/em&gt; 모든 액세스를 막는 방식으로 전체 테이블을 잠글 수 &lt;em&gt;없습니다&lt;/em&gt; . 이 클래스는 스레드 안전에 의존하지만 동기화 세부 사항에는 의존하지 않는 프로그램에서 &lt;code&gt;Hashtable&lt;/code&gt; 과 완전히 상호 운용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2ac80bdd78fba7e815e2307473834134c0b8301" translate="yes" xml:space="preserve">
          <source>A hash-code value for this URI</source>
          <target state="translated">이 URI의 해시 코드 값</target>
        </trans-unit>
        <trans-unit id="6f786cf19e1bfad99116b7eea0c7c4d01a129f5e" translate="yes" xml:space="preserve">
          <source>A hashcode value for this object.</source>
          <target state="translated">이 객체의 해시 코드 값</target>
        </trans-unit>
        <trans-unit id="531037da01ce93fad322a6e90507cf29968387ee" translate="yes" xml:space="preserve">
          <source>A hexadecimal digit: &lt;code&gt;[0-9a-fA-F]&lt;/code&gt;</source>
          <target state="translated">16 진수 : &lt;code&gt;[0-9a-fA-F]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8019d565ee6672068a88a557bf3259f61e9f6e2e" translate="yes" xml:space="preserve">
          <source>A hexadecimal digit: &lt;code&gt;[\p{gc=Nd}\p{IsHex_Digit}]&lt;/code&gt;</source>
          <target state="translated">16 진수 : &lt;code&gt;[\p{gc=Nd}\p{IsHex_Digit}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0eaf5113462f5f09a75427d07e5000b2557a560e" translate="yes" xml:space="preserve">
          <source>A hierarchical URI is considered to be less than an opaque URI with an identical scheme.</source>
          <target state="translated">계층 적 URI는 동일한 체계를 가진 불투명 한 URI보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3f15b0dd6e68706f3cc8aca6a2b0b354d9959881" translate="yes" xml:space="preserve">
          <source>A hierarchical URI is subject to further parsing according to the syntax</source>
          <target state="translated">계층 적 URI는 구문에 따라 추가로 구문 분석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a70b6cdbfa6b9ebe9df52783e9c0b40b7945da0" translate="yes" xml:space="preserve">
          <source>A higher-quality spliterator will provide balanced and known-size splits, accurate sizing information, and a number of other &lt;a href=&quot;../spliterator#characteristics--&quot;&gt;&lt;code&gt;characteristics&lt;/code&gt;&lt;/a&gt; of the spliterator or data that can be used by implementations to optimize execution.</source>
          <target state="translated">고품질 스플리터는 알려진 크기의 스플릿, 정확한 크기 정보 및 구현에 의해 실행 최적화를 위해 사용할 수있는 스플리터 또는 데이터의 여러 가지 다른 &lt;a href=&quot;../spliterator#characteristics--&quot;&gt; &lt;code&gt;characteristics&lt;/code&gt; &lt;/a&gt; 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1d2af2f2ec5660f7616d7e59e084554df9083acf" translate="yes" xml:space="preserve">
          <source>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</source>
          <target state="translated">현재 스레드가 현재 프로세서를 사용하려고한다는 스케줄러에 대한 힌트입니다. 스케줄러는이 힌트를 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="dce262eaf05a51984255debdf4e961963652fdf2" translate="yes" xml:space="preserve">
          <source>A horizontal offset to be applied to the subsampling grid before subsampling. The first pixel to be used will be offset this amount from the origin of the region, or of the image if no region is specified.</source>
          <target state="translated">서브 샘플링 전에 서브 샘플링 그리드에 적용되는 수평 오프셋입니다. 사용되는 첫 번째 픽셀은 영역의 원점 또는 영역이 지정되지 않은 경우 이미지의 원점에서이 양만큼 오프셋됩니다.</target>
        </trans-unit>
        <trans-unit id="cae300f90785fca5b33cd05f0e37e347f3bdb295" translate="yes" xml:space="preserve">
          <source>A horizontal whitespace character: &lt;code&gt;[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]&lt;/code&gt;</source>
          <target state="translated">가로 공백 문자 : &lt;code&gt;[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2092bd5cb7b434a04d1edfe6aba1977fb241b996" translate="yes" xml:space="preserve">
          <source>A host isn't in a domain (RFC 2965 sec. 3.3.2) if:</source>
          <target state="translated">다음과 같은 경우 호스트가 도메인에 없습니다 (RFC 2965 초 3.3.2).</target>
        </trans-unit>
        <trans-unit id="07aa9b38a4ede3c83aa047636c3e1f374ce196f4" translate="yes" xml:space="preserve">
          <source>A instance of &lt;code&gt;CookieManager&lt;/code&gt; will have cookie policy ACCEPT_ORIGINAL_SERVER by default. Users always can call this method to set another cookie policy.</source>
          <target state="translated">&lt;code&gt;CookieManager&lt;/code&gt; 의 인스턴스는 기본적으로 쿠키 정책 ACCEPT_ORIGINAL_SERVER를 갖습니다. 사용자는 항상이 메소드를 호출하여 다른 쿠키 정책을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed93d745a111d391d7a2f46cbf50e03f102e5d8b" translate="yes" xml:space="preserve">
          <source>A int buffer is not comparable to any other type of object.</source>
          <target state="translated">int 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7a5c5dcd5045f34fd77586929f7a76518869889" translate="yes" xml:space="preserve">
          <source>A int buffer is not equal to any other type of object.</source>
          <target state="translated">int 버퍼는 다른 유형의 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b8db826daaeb4da111cdd530cd07bbeacba70f5" translate="yes" xml:space="preserve">
          <source>A is a HDN string and has the form NB, where N is a non-empty name string, B has the form .B', and B' is a HDN string. (So, x.y.com domain-matches .Y.com but not Y.com.)</source>
          <target state="translated">A는 HDN 문자열이며 NB 형식입니다. 여기서 N은 비어 있지 않은 이름 문자열이고 B는 .B '형식이며 B'는 HDN 문자열입니다. 따라서 xycom 도메인은 .Y.com과 일치하지만 Y.com과는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1d25b7429dcbb1987d6223c0fd9a5ab8b4f4d68" translate="yes" xml:space="preserve">
          <source>A java.awt.Component that will allow a human to directly edit the current property value. May be null if this is not supported.</source>
          <target state="translated">인간이 현재 특성 값을 직접 편집 할 수있게하는 java.awt.Component. 지원되지 않는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc935686fe4c4bf5294565416f415b4c8bfe92e9" translate="yes" xml:space="preserve">
          <source>A key is added to a selector's key set as a side effect of registering a channel via the channel's &lt;a href=&quot;selectablechannel#register-java.nio.channels.Selector-int-&quot;&gt;&lt;code&gt;register&lt;/code&gt;&lt;/a&gt; method. Cancelled keys are removed from the key set during selection operations. The key set itself is not directly modifiable.</source>
          <target state="translated">채널의 &lt;a href=&quot;selectablechannel#register-java.nio.channels.Selector-int-&quot;&gt; &lt;code&gt;register&lt;/code&gt; &lt;/a&gt; 방법을 통해 채널을 등록하면 부작용으로 키가 선택기의 키 세트에 추가됩니다 . 취소 된 키는 선택 조작 중에 키 세트에서 제거됩니다. 키 세트 자체는 직접 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="964050a9069a956131820dda0c3b3fdb5dec31af" translate="yes" xml:space="preserve">
          <source>A key is added to its selector's cancelled-key set when it is cancelled, whether by closing its channel or by invoking its &lt;a href=&quot;selectionkey#cancel--&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method. Cancelling a key will cause its channel to be deregistered during the next selection operation, at which time the key will removed from all of the selector's key sets.</source>
          <target state="translated">채널을 닫거나 &lt;a href=&quot;selectionkey#cancel--&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 방법 을 호출하여 취소 할 때 선택기의 취소 된 키 세트에 키가 추가됩니다 . 키를 취소하면 다음 선택 작업 중에 채널이 등록 취소되며이 때 키가 선택기의 모든 키 세트에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c83f6d5654385f02695581674b4358677f2c26" translate="yes" xml:space="preserve">
          <source>A key is valid upon creation and remains so until it is cancelled, its channel is closed, or its selector is closed.</source>
          <target state="translated">키는 생성시 유효하며 취소되거나 채널이 닫히거나 선택기가 닫힐 때까지 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3567b234d34db2898e97ad89a7423f7ad8bb314d" translate="yes" xml:space="preserve">
          <source>A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). For example, a DSA private key may be specified by its components &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; (see &lt;a href=&quot;dsaprivatekeyspec&quot;&gt;&lt;code&gt;DSAPrivateKeySpec&lt;/code&gt;&lt;/a&gt;), or it may be specified using its DER encoding (see &lt;a href=&quot;pkcs8encodedkeyspec&quot;&gt;&lt;code&gt;PKCS8EncodedKeySpec&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">키는 알고리즘에 따라 지정되거나 알고리즘에 독립적 인 인코딩 형식 (예 : ASN.1)으로 지정 될 수 있습니다. 예를 들어, DSA 개인 키는 구성 요소 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; 및 &lt;code&gt;g&lt;/code&gt; 로 지정되거나 ( &lt;a href=&quot;dsaprivatekeyspec&quot;&gt; &lt;code&gt;DSAPrivateKeySpec&lt;/code&gt; &lt;/a&gt; 참조 ) DER 인코딩을 사용하여 지정 될 수 있습니다 ( &lt;a href=&quot;pkcs8encodedkeyspec&quot;&gt; &lt;code&gt;PKCS8EncodedKeySpec&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1f46b54c144fbfb71c028bbb373ce3b3ddfb0cb9" translate="yes" xml:space="preserve">
          <source>A key part of the date-time problem space is adjusting a date to a new, related value, such as the &quot;last day of the month&quot;, or &quot;next Wednesday&quot;. These are modeled as functions that adjust a base date-time. The functions implement &lt;a href=&quot;temporaladjuster&quot;&gt;&lt;code&gt;TemporalAdjuster&lt;/code&gt;&lt;/a&gt; and operate on &lt;code&gt;Temporal&lt;/code&gt;. A set of common functions are provided in &lt;a href=&quot;temporaladjusters&quot;&gt;&lt;code&gt;TemporalAdjusters&lt;/code&gt;&lt;/a&gt;. For example, to find the first occurrence of a day-of-week after a given date, use &lt;a href=&quot;temporaladjusters#next-java.time.DayOfWeek-&quot;&gt;&lt;code&gt;TemporalAdjusters.next(DayOfWeek)&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;date.with(next(MONDAY))&lt;/code&gt;. Applications can also define adjusters by implementing &lt;a href=&quot;temporaladjuster&quot;&gt;&lt;code&gt;TemporalAdjuster&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">날짜-시간 문제 공간의 주요 부분은 날짜를 &quot;매월 마지막 날&quot;또는 &quot;다음 수요일&quot;과 같은 새로운 관련 값으로 조정하는 것입니다. 이들은 기본 날짜-시간을 조정하는 함수로 모델링됩니다. 기능 구현 &lt;a href=&quot;temporaladjuster&quot;&gt; &lt;code&gt;TemporalAdjuster&lt;/code&gt; 을&lt;/a&gt; 과에서 작동 &lt;code&gt;Temporal&lt;/code&gt; . &lt;a href=&quot;temporaladjusters&quot;&gt; &lt;code&gt;TemporalAdjusters&lt;/code&gt; &lt;/a&gt; 에 공통 기능 세트가 제공됩니다 . 예를 들어, 주어진 날짜 이후 요일의 첫 번째 항목을 찾으려면 &lt;a href=&quot;temporaladjusters#next-java.time.DayOfWeek-&quot;&gt; &lt;code&gt;TemporalAdjusters.next(DayOfWeek)&lt;/code&gt; &lt;/a&gt; 사용하십시오 ( 예 : &lt;code&gt;date.with(next(MONDAY))&lt;/code&gt; . 응용 프로그램은 &lt;a href=&quot;temporaladjuster&quot;&gt; &lt;code&gt;TemporalAdjuster&lt;/code&gt; &lt;/a&gt; 를 구현하여 조정자를 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd8a761e520198c1cdaa54b4d4372dc66292abc6" translate="yes" xml:space="preserve">
          <source>A key property list as defined below.</source>
          <target state="translated">아래 정의 된 주요 속성 목록.</target>
        </trans-unit>
        <trans-unit id="f68a1b3c961bf3188f44addd02d18988aa1e3f1b" translate="yes" xml:space="preserve">
          <source>A key property list written as a String is a comma-separated list of elements. Each element is either an asterisk or a key property. A key property consists of a key, an equals (&lt;code&gt;=&lt;/code&gt;), and the associated value.</source>
          <target state="translated">문자열로 작성된 키 특성 목록은 쉼표로 구분 된 요소 목록입니다. 각 요소는 별표 또는 키 속성입니다. 키 속성은 키, 등호 ( &lt;code&gt;=&lt;/code&gt; ) 및 관련 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c0586c9ec6232590f575482bb2c80c36ba5f7423" translate="yes" xml:space="preserve">
          <source>A key representing the registration of this channel with the given selector</source>
          <target state="translated">주어진 셀렉터로이 채널의 등록을 나타내는 키</target>
        </trans-unit>
        <trans-unit id="ecefc7965907056694e7481d75b869b29f450431" translate="yes" xml:space="preserve">
          <source>A key representing the registration of this object with the given watch service</source>
          <target state="translated">지정된 시계 서비스에이 객체의 등록을 나타내는 키</target>
        </trans-unit>
        <trans-unit id="f42a40d645e94595a63ed0059561f728071e39f5" translate="yes" xml:space="preserve">
          <source>A key specification is a transparent representation of the key material that constitutes a key. A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). This package contains key specifications for DSA public and private keys, RSA public and private keys, PKCS #8 private keys in DER-encoded format, and X.509 public and private keys in DER-encoded format.</source>
          <target state="translated">키 사양은 키를 구성하는 키 자료를 투명하게 표현한 것입니다. 키는 알고리즘 별 방식 또는 알고리즘 독립적 인코딩 형식 (예 : ASN.1)으로 지정할 수 있습니다. 이 패키지에는 DSA 공개 및 개인 키, RSA 공개 및 개인 키, DER 인코딩 형식의 PKCS # 8 개인 키 및 DER 인코딩 형식의 X.509 공개 및 개인 키에 대한 키 사양이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0f3d8b0a4094e0a7b104df6160697464e59ec13" translate="yes" xml:space="preserve">
          <source>A key specification is a transparent representation of the key material that constitutes a key. A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). This package contains key specifications for Diffie-Hellman public and private keys, as well as key specifications for DES, Triple DES, and PBE secret keys.</source>
          <target state="translated">키 사양은 키를 구성하는 키 자료를 투명하게 표현한 것입니다. 키는 알고리즘 별 방식 또는 알고리즘 독립적 인코딩 형식 (예 : ASN.1)으로 지정할 수 있습니다. 이 패키지에는 Diffie-Hellman 공개 및 개인 키의 주요 사양과 DES, Triple DES 및 PBE 비밀 키의 주요 사양이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aacfcfb6bf4889f12230f05b825f1f2e0d7537b" translate="yes" xml:space="preserve">
          <source>A key use case for calculations on a date in an arbitrary calendar system is producing a month-by-month calendar for display and user interaction. Again, this is a UI issue, and use of this interface solely within a few methods of the UI layer may be justified.</source>
          <target state="translated">임의의 달력 시스템에서 날짜를 계산하는 주요 사용 사례는 디스플레이 및 사용자 상호 작용을위한 월별 달력을 생성하는 것입니다. 다시 말하지만 이것은 UI 문제이며 UI 인터페이스의 몇 가지 방법 내에서만이 인터페이스를 사용하는 것이 정당화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcb15f00291a40cab9dcee79f5d952bd5eac29d" translate="yes" xml:space="preserve">
          <source>A label is an individual part of a domain name. The original ToASCII operation, as defined in RFC 3490, only operates on a single label. This method can handle both label and entire domain name, by assuming that labels in a domain name are always separated by dots. The following characters are recognized as dots: \u002E (full stop), \u3002 (ideographic full stop), \uFF0E (fullwidth full stop), and \uFF61 (halfwidth ideographic full stop). if dots are used as label separators, this method also changes all of them to \u002E (full stop) in output translated string.</source>
          <target state="translated">레이블은 도메인 이름의 개별 부분입니다. RFC 3490에 정의 된 원래 ToASCII 작업은 단일 레이블에서만 작동합니다. 이 방법은 도메인 이름의 레이블이 항상 점으로 구분되어 있다고 가정하여 레이블과 전체 도메인 이름을 모두 처리 할 수 ​​있습니다. 다음 문자는 점으로 인식됩니다 : \ u002E (완전 정지), \ u3002 (표면 정지), \ uFF0E (전폭 완전 정지) 및 \ uFF61 (반각 표의 문자 완전 정지). 점이 레이블 구분 기호로 사용되는 경우이 방법은 출력 변환 된 문자열에서 모든 점을 \ u002E (완전 정지)로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="123da693824e9381ac6679a81d6dc167f1012487" translate="yes" xml:space="preserve">
          <source>A label is an individual part of a domain name. The original ToUnicode operation, as defined in RFC 3490, only operates on a single label. This method can handle both label and entire domain name, by assuming that labels in a domain name are always separated by dots. The following characters are recognized as dots: \u002E (full stop), \u3002 (ideographic full stop), \uFF0E (fullwidth full stop), and \uFF61 (halfwidth ideographic full stop).</source>
          <target state="translated">레이블은 도메인 이름의 개별 부분입니다. RFC 3490에 정의 된 원래 ToUnicode 작업은 단일 레이블에서만 작동합니다. 이 방법은 도메인 이름의 레이블이 항상 점으로 구분되어 있다고 가정하여 레이블과 전체 도메인 이름을 모두 처리 할 수 ​​있습니다. 다음 문자는 점으로 인식됩니다 : \ u002E (완전 정지), \ u3002 (표면 완전 정지), \ uFF0E (전폭 완전 정지) 및 \ uFF61 (반각 표의 문자 완전 정지).</target>
        </trans-unit>
        <trans-unit id="97d54d21fcf748da2a9bb68d7e686e2f8dfef862" translate="yes" xml:space="preserve">
          <source>A leading component separator (the composite name string begins with a separator) denotes a leading empty component (a component consisting of an empty string). A trailing component separator (the composite name string ends with a separator) denotes a trailing empty component. Adjacent component separators denote an empty component.</source>
          <target state="translated">선행 구성 요소 구분 기호 (복합 이름 문자열은 구분 기호로 시작)는 선행 빈 구성 요소 (빈 문자열로 구성된 구성 요소)를 나타냅니다. 후행 구성 요소 구분 기호 (복합 이름 문자열은 구분 기호로 끝남)는 빈 구성 요소를 나타냅니다. 인접한 구성 요소 구분 기호는 빈 구성 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fcad8987095acc8d02184de58b249c169cc6e9af" translate="yes" xml:space="preserve">
          <source>A leading separator (the compound name string begins with a separator) denotes a leading empty atomic component (consisting of an empty string). A trailing separator (the compound name string ends with a separator) denotes a trailing empty atomic component. Adjacent separators denote an empty atomic component.</source>
          <target state="translated">선행 구분 기호 (화합물 이름 문자열은 구분 기호로 시작)는 선행 빈 원자 구성 요소 (빈 문자열로 구성)를 나타냅니다. 후행 구분 기호 (화합물 이름 문자열은 구분 기호로 끝남)는 후행 빈 원자 성분을 나타냅니다. 인접한 분리기는 빈 원자 성분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e1a750474571c1caa8c781c57987f658741abc84" translate="yes" xml:space="preserve">
          <source>A leap-year is a year of a longer length than normal. The exact meaning is determined by the chronology according to the following constraints.</source>
          <target state="translated">윤년은 평소보다 긴 기간입니다. 정확한 의미는 다음 제약 조건에 따라 연대기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="97d705fdaf553c98ff69239e30eff552390ebd01" translate="yes" xml:space="preserve">
          <source>A leap-year is a year of a longer length than normal. The exact meaning is determined by the chronology with the constraint that a leap-year must imply a year-length longer than a non leap-year.</source>
          <target state="translated">윤년은 평소보다 긴 기간입니다. 정확한 의미는 윤년이 비 윤년보다 1 년 더 길어야한다는 제약 조건이있는 연대기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="53a2599abeb7238ac2f98a3b5600a3def82bd862" translate="yes" xml:space="preserve">
          <source>A lenient query for the &lt;code&gt;ZoneId&lt;/code&gt;, falling back to the &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">에 대한 관대 한 쿼리 &lt;code&gt;ZoneId&lt;/code&gt; 의에 떨어지는 다시 &lt;code&gt;ZoneOffset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b56c5699f1874ffdd2862ebff22710a3d81daec8" translate="yes" xml:space="preserve">
          <source>A line can have controls, such as gain, pan, and reverb. The controls themselves are instances of classes that extend the base &lt;code&gt;&lt;a href=&quot;control&quot;&gt;&lt;code&gt;Control&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; class. The &lt;code&gt;Line&lt;/code&gt; interface provides two accessor methods for obtaining the line's controls: &lt;code&gt;&lt;a href=&quot;line#getControls--&quot;&gt;&lt;code&gt;getControls&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; returns the entire set, and &lt;code&gt;&lt;a href=&quot;line#getControl-javax.sound.sampled.Control.Type-&quot;&gt;&lt;code&gt;getControl&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; returns a single control of specified type.</source>
          <target state="translated">라인에는 게인, 팬 및 리버브와 같은 컨트롤이 있습니다. 컨트롤 자체는 기본 &lt;code&gt;&lt;a href=&quot;control&quot;&gt;&lt;code&gt;Control&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 클래스 를 확장하는 클래스의 인스턴스입니다 . &lt;code&gt;Line&lt;/code&gt; : 인터페이스는 라인을 컨트롤하기위한 접근 방법을 제공 &lt;code&gt;&lt;a href=&quot;line#getControls--&quot;&gt;&lt;code&gt;getControls&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 전체 세트를 반환하고 &lt;code&gt;&lt;a href=&quot;line#getControl-javax.sound.sampled.Control.Type-&quot;&gt;&lt;code&gt;getControl&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 지정된 유형의 단일 제어를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8786a5fe383b5efbdf5037cc5b63611602b61532" translate="yes" xml:space="preserve">
          <source>A line feed (LF) character standing by itself means &quot;go to column 1 of the next line.&quot;</source>
          <target state="translated">줄 바꿈 (LF) 문자 자체는 &quot;다음 줄의 1 열로 이동&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b693dcbd13d371398add1d691705128da936559" translate="yes" xml:space="preserve">
          <source>A line is a sequence of bytes ending with a carriage return character (&lt;code&gt;'\r'&lt;/code&gt;), a newline character (&lt;code&gt;'\n'&lt;/code&gt;), or a carriage return character followed immediately by a linefeed character. In all three cases, the line terminating character(s) are returned as a single newline character.</source>
          <target state="translated">줄은 캐리지 리턴 문자 ( &lt;code&gt;'\r'&lt;/code&gt; ), 줄 바꿈 문자 ( &lt;code&gt;'\n'&lt;/code&gt; ) 또는 캐리지 리턴 문자로 끝나는 일련의 바이트 로, 줄 바꿈 문자가 바로 뒤에옵니다. 세 가지 경우 모두 줄 끝 문자가 단일 줄 바꿈 문자로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd89c4e3b2be50c382c2539dcc24464fdbb0045e" translate="yes" xml:space="preserve">
          <source>A line is a sequence of characters ending with either a carriage-return character (&lt;code&gt;'\r'&lt;/code&gt;) or a newline character (&lt;code&gt;'\n'&lt;/code&gt;). In addition, a carriage-return character followed immediately by a newline character is treated as a single end-of-line token.</source>
          <target state="translated">줄은 캐리지 리턴 문자 ( &lt;code&gt;'\r'&lt;/code&gt; ) 또는 줄 바꿈 문자 ( &lt;code&gt;'\n'&lt;/code&gt; )로 끝나는 일련의 문자 입니다. 또한 캐리지 리턴 문자 다음에 줄 바꿈 문자가 오는 즉시 단일 줄 끝 토큰으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3247ed16456853302a1cf889fa07ec387d051119" translate="yes" xml:space="preserve">
          <source>A line is considered to be &lt;a name=&quot;lt&quot;&gt;terminated&lt;/a&gt; by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a linefeed.</source>
          <target state="translated">줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 캐리지 리턴 다음에 줄 바꿈이 있으면 줄이 &lt;a name=&quot;lt&quot;&gt;종료&lt;/a&gt; 된 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b7ca0c2af9f1edee874d303ecbb4bfe840e2ae1" translate="yes" xml:space="preserve">
          <source>A line of text is terminated by a carriage-return character (&lt;code&gt;'\r'&lt;/code&gt;), a newline character (&lt;code&gt;'\n'&lt;/code&gt;), a carriage-return character immediately followed by a newline character, or the end of the file. Line-terminating characters are discarded and are not included as part of the string returned.</source>
          <target state="translated">텍스트 줄은 캐리지 리턴 문자 ( &lt;code&gt;'\r'&lt;/code&gt; ), 줄 바꿈 문자 ( &lt;code&gt;'\n'&lt;/code&gt; ), 캐리지 리턴 문자 바로 다음에 줄 바꿈 문자 또는 파일 끝으로 끝납니다. 줄로 끝나는 문자는 무시되며 반환 된 문자열의 일부로 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1d421a3c437913459686e8e2c616f56c058bc0b" translate="yes" xml:space="preserve">
          <source>A line-separator character (&lt;code&gt;'\u2028'&lt;/code&gt;), or</source>
          <target state="translated">줄 구분 문자 ( &lt;code&gt;'\u2028'&lt;/code&gt; ) 또는</target>
        </trans-unit>
        <trans-unit id="6a06843d99cb5f85c0cf509d37a1efecb9a3799a" translate="yes" xml:space="preserve">
          <source>A linear collection that supports element insertion and removal at both ends.</source>
          <target state="translated">양쪽 끝에서 요소 삽입 및 제거를 지원하는 선형 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="b40d08cf909bccb933847ab2cbb7c69d15600fc8" translate="yes" xml:space="preserve">
          <source>A linear collection that supports element insertion and removal at both ends. The name</source>
          <target state="translated">양쪽 끝에서 요소 삽입 및 제거를 지원하는 선형 컬렉션입니다. 이름</target>
        </trans-unit>
        <trans-unit id="97306c8d3ba98c3b4909e917962a43aca00f125b" translate="yes" xml:space="preserve">
          <source>A linked hash map has two parameters that affect its performance:</source>
          <target state="translated">연결된 해시 맵에는 성능에 영향을주는 두 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5d0567d95ba1f476603a27df139f097cc946400" translate="yes" xml:space="preserve">
          <source>A linked hash set has two parameters that affect its performance:</source>
          <target state="translated">연결된 해시 세트에는 성능에 영향을주는 두 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a34d022e2b151d44379f6754c3e516c74e49078" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;String&lt;/code&gt; each of which is a currently registered &lt;code&gt;Logger&lt;/code&gt; name.</source>
          <target state="translated">현재 등록 된 &lt;code&gt;Logger&lt;/code&gt; 이름 인 각 &lt;code&gt;String&lt;/code&gt; 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="15cf90d8d2220c9cd8197762d2212a7447bdf437" translate="yes" xml:space="preserve">
          <source>A list of MBeanServer objects.</source>
          <target state="translated">MBeanServer 오브젝트의리스트입니다.</target>
        </trans-unit>
        <trans-unit id="e2cdf1db9dc024dd948eaa61978df4a6a1912d0e" translate="yes" xml:space="preserve">
          <source>A list of matching &lt;code&gt;Element&lt;/code&gt; nodes.</source>
          <target state="translated">일치하는 &lt;code&gt;Element&lt;/code&gt; 노드 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="0a94d2ecd063ae6a1df5852d1841f65f60bd65cf" translate="yes" xml:space="preserve">
          <source>A listener for a Timer MBean can itself be an MBean, using the method &lt;a href=&quot;../mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.ObjectName-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;MBeanServer.addNotificationListener(ObjectName,
      ObjectName, NotificationFilter, Object)&lt;/code&gt;&lt;/a&gt;. In this way, a management application can create an MBean representing a task, then schedule that task using a Timer MBean.</source>
          <target state="translated">&lt;a href=&quot;../mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.ObjectName-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;MBeanServer.addNotificationListener(ObjectName, ObjectName, NotificationFilter, Object)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 타이머 MBean의 리스너 자체가 MBean 일 수 있습니다 . 이런 방식으로 관리 응용 프로그램은 작업을 나타내는 MBean을 만든 다음 Timer MBean을 사용하여 해당 작업을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="698554ac6345725e38dfb1615e0a194ec85c4ba6" translate="yes" xml:space="preserve">
          <source>A listener for receiving preference change events.</source>
          <target state="translated">환경 설정 변경 이벤트를 수신하기위한 리스너입니다.</target>
        </trans-unit>
        <trans-unit id="1aabbb23a368618bba8cf844d1f5d4f8bd473acc" translate="yes" xml:space="preserve">
          <source>A listener for receiving preference node change events.</source>
          <target state="translated">기본 설정 노드 변경 이벤트를 수신하기위한 리스너입니다.</target>
        </trans-unit>
        <trans-unit id="b4e8c843b8da1377b4a4fe35087522a11a1f018f" translate="yes" xml:space="preserve">
          <source>A listener interested in &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event types must:</source>
          <target state="translated">&lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 이벤트 유형에 관심이있는 리스너 는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1eb406af2e34f83c1ff0326d1a53689b2620751" translate="yes" xml:space="preserve">
          <source>A listener that wants to be notified of &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event types should also implement the &lt;code&gt;ObjectChangeListener&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 이벤트 유형에 대한 알림을 받으려는 리스너 도 &lt;code&gt;ObjectChangeListener&lt;/code&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="de4c0125a157adee093814e09b281eaa9497021d" translate="yes" xml:space="preserve">
          <source>A listener that wants to be notified of namespace change events should also implement the &lt;code&gt;NamespaceChangeListener&lt;/code&gt; interface.</source>
          <target state="translated">네임 스페이스 변경 이벤트에 대한 알림을 받으려는 리스너도 &lt;code&gt;NamespaceChangeListener&lt;/code&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e24f20d2177ce0b96413ecb356cb7008b6d89e3" translate="yes" xml:space="preserve">
          <source>A literal string replacement</source>
          <target state="translated">리터럴 문자열 대체</target>
        </trans-unit>
        <trans-unit id="592b027e5e9d567689958753a9389037cb88b1a2" translate="yes" xml:space="preserve">
          <source>A local color table is written to the output stream only if image metadata containing a LocalColorTable element is supplied to the writer, or no image metadata is supplied to the writer and the local color table which would be generated from the image itself is not equal to the global color table.</source>
          <target state="translated">LocalColorTable 요소가 포함 된 이미지 메타 데이터가 기록기에 제공되거나 기록기에 이미지 메타 데이터가 제공되지 않고 이미지 자체에서 생성 된 로컬 색상 표가 같지 않은 경우에만 로컬 색상 표가 출력 스트림에 기록됩니다. 글로벌 컬러 테이블</target>
        </trans-unit>
        <trans-unit id="5e67dc7d76e5d6260aa02465cd132b1be622d15e" translate="yes" xml:space="preserve">
          <source>A local port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up a free port in the &lt;code&gt;bind&lt;/code&gt; operation.</source>
          <target state="translated">로컬 포트 ​​번호가 &lt;code&gt;zero&lt;/code&gt; 이면 시스템이 &lt;code&gt;bind&lt;/code&gt; 작업 에서 사용 가능한 포트를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2e095520751ba87e3068d056542787aeca9197" translate="yes" xml:space="preserve">
          <source>A local variable.</source>
          <target state="translated">지역 변수.</target>
        </trans-unit>
        <trans-unit id="6955283daf06e25711bb8ad70a56014545639769" translate="yes" xml:space="preserve">
          <source>A locale with language &quot;no&quot;, country &quot;NO&quot;, and variant &quot;NY&quot;, representing Norwegian Nynorsk (Norway), is converted to a language tag &quot;nn-NO&quot;.</source>
          <target state="translated">노르웨이어 Nynorsk (노르웨이)를 나타내는 언어 &quot;no&quot;, 국가 &quot;NO&quot;및 변형 &quot;NY&quot;가있는 로캘은 언어 태그 &quot;nn-NO&quot;로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a27552254d56009aa8e1699a2f0793508aa6107" translate="yes" xml:space="preserve">
          <source>A localized short description associated with this property/method/event. This defaults to be the display name.</source>
          <target state="translated">이 속성 / 방법 / 이벤트와 관련된 현지화 된 간단한 설명입니다. 기본적으로 표시 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5c9fada9017e71f49bf3f0e12ca12af8b3cad0a7" translate="yes" xml:space="preserve">
          <source>A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a &lt;a href=&quot;readwritelock&quot;&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잠금은 여러 스레드가 공유 리소스에 대한 액세스를 제어하는 ​​도구입니다. 일반적으로 잠금은 공유 자원에 대한 독점 액세스를 제공합니다. 한 번에 하나의 스레드 만 잠금을 획득 할 수 있으며 공유 자원에 대한 모든 액세스는 먼저 잠금을 획득해야합니다. 그러나 일부 잠금은 &lt;a href=&quot;readwritelock&quot;&gt; &lt;code&gt;ReadWriteLock&lt;/code&gt; &lt;/a&gt; 의 읽기 잠금과 같은 공유 리소스에 대한 동시 액세스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a6ffffd6b30beb72af7461ead42991d37ef4948" translate="yes" xml:space="preserve">
          <source>A lock object remains valid until it is released or the associated file channel is closed, whichever comes first.</source>
          <target state="translated">잠금 오브젝트는 해제되거나 연관된 파일 채널이 닫힐 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="28a3b257aa12bb2f4fb5f8f6e1420bc67c0a823b" translate="yes" xml:space="preserve">
          <source>A lock object representing the newly-acquired lock</source>
          <target state="translated">새로 획득 한 잠금을 나타내는 잠금 객체</target>
        </trans-unit>
        <trans-unit id="2b22d963da1177eba0b896711186aa82f5524a3d" translate="yes" xml:space="preserve">
          <source>A lock object representing the newly-acquired lock, or &lt;code&gt;null&lt;/code&gt; if the lock could not be acquired because another program holds an overlapping lock</source>
          <target state="translated">새로 획득 한 잠금을 나타내는 잠금 객체 또는 다른 프로그램이 겹치는 잠금을 보유하여 잠금을 획득 할 수없는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94c9f044a4875cfd3ff8a41efa0667cbf6bb53d6" translate="yes" xml:space="preserve">
          <source>A lock on a (region of a) file</source>
          <target state="translated">(영역의) 파일에 대한 잠금</target>
        </trans-unit>
        <trans-unit id="84ac1353e7256bd0e9a70d66e51652a6d59ae9e0" translate="yes" xml:space="preserve">
          <source>A locked region need not be contained within, or even overlap, the actual underlying file, so the value returned by this method may exceed the file's current size.</source>
          <target state="translated">잠긴 영역은 실제 기본 파일 내에 포함되거나 겹치지 않아도되므로이 방법으로 반환 된 값이 파일의 현재 크기를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="568c4b3b9a76ea6ca643c5daaf99dff90277ebc4" translate="yes" xml:space="preserve">
          <source>A login configuration contains the following information. Note that this example only represents the default syntax for the &lt;code&gt;Configuration&lt;/code&gt;. Subclass implementations of this class may implement alternative syntaxes and may retrieve the &lt;code&gt;Configuration&lt;/code&gt; from any source such as files, databases, or servers.</source>
          <target state="translated">로그인 구성에는 다음 정보가 포함됩니다. 이 예제는 &lt;code&gt;Configuration&lt;/code&gt; 의 기본 구문 만 나타냅니다 . 이 클래스의 서브 클래스 구현은 대체 구문을 구현할 수 있으며 파일, 데이터베이스 또는 서버와 같은 모든 소스 에서 &lt;code&gt;Configuration&lt;/code&gt; 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26dda26d1e92f5c5e23547c5c332144ba4720ca0" translate="yes" xml:space="preserve">
          <source>A long buffer is not comparable to any other type of object.</source>
          <target state="translated">긴 버퍼는 다른 유형의 객체와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af058ad87a032a73c5dbeda376e1410c7f0e9d15" translate="yes" xml:space="preserve">
          <source>A long buffer is not equal to any other type of object.</source>
          <target state="translated">긴 버퍼는 다른 유형의 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14db0bab1d80c04094c29c5f4876e521eaaaad9a" translate="yes" xml:space="preserve">
          <source>A long buffer.</source>
          <target state="translated">긴 버퍼.</target>
        </trans-unit>
        <trans-unit id="fdd3fa643df0a7408495d391eff49d6089573722" translate="yes" xml:space="preserve">
          <source>A lookup can fail, because the containing class is not accessible to the lookup class, or because the desired class member is missing, or because the desired class member is not accessible to the lookup class, or because the lookup object is not trusted enough to access the member. In any of these cases, a &lt;code&gt;ReflectiveOperationException&lt;/code&gt; will be thrown from the attempted lookup. The exact class will be one of the following:</source>
          <target state="translated">포함 클래스에 조회 클래스에 액세스 할 수 없거나, 원하는 클래스 멤버가 누락되었거나, 원하는 클래스 멤버가 조회 클래스에 액세스 할 수 없거나, 조회 오브젝트가 충분히 신뢰할 수 없기 때문에 조회에 실패 할 수 있습니다. 회원에게 액세스하십시오. 이러한 경우, 시도 된 조회에서 &lt;code&gt;ReflectiveOperationException&lt;/code&gt; 이 발생합니다. 정확한 수업은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0b8aa7e616f29eacc7bbf003997b65bbb16a9d5b" translate="yes" xml:space="preserve">
          <source>A lookup class which needs to create method handles will call &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt; to create a factory for itself. When the &lt;code&gt;Lookup&lt;/code&gt; factory object is created, the identity of the lookup class is determined, and securely stored in the &lt;code&gt;Lookup&lt;/code&gt; object. The lookup class (or its delegates) may then use factory methods on the &lt;code&gt;Lookup&lt;/code&gt; object to create method handles for access-checked members. This includes all methods, constructors, and fields which are allowed to the lookup class, even private ones.</source>
          <target state="translated">메소드 핸들을 작성해야하는 조회 클래스는 &lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 을 호출 하여 자체 팩토리를 작성합니다. &lt;code&gt;Lookup&lt;/code&gt; 팩토리 오브젝트가 작성 되면 Lookup 클래스의 ID가 판별되어 &lt;code&gt;Lookup&lt;/code&gt; 오브젝트 에 안전하게 저장됩니다 . 그런 다음 조회 클래스 (또는 해당 대리자)는 &lt;code&gt;Lookup&lt;/code&gt; 객체에서 팩토리 메소드를 사용 하여 액세스 확인 멤버에 대한 메소드 핸들을 작성할 수 있습니다. 여기에는 조회 클래스에 허용되는 모든 메소드, 생성자 및 필드 (개인용 클래스 포함)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8153cb1f4f8081e17bb4e5f6258e0dc551189059" translate="yes" xml:space="preserve">
          <source>A lower-case alphabetic character: &lt;code&gt;[a-z]&lt;/code&gt;</source>
          <target state="translated">소문자 알파벳 문자 : &lt;code&gt;[a-z]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54d053dd5de98d77f961dfe613bd1e3a4b83129d" translate="yes" xml:space="preserve">
          <source>A lowercase character:&lt;code&gt;\p{IsLowercase}&lt;/code&gt;</source>
          <target state="translated">소문자 : &lt;code&gt;\p{IsLowercase}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0c5f1bada31724a95975e7fb4646121c67bb998" translate="yes" xml:space="preserve">
          <source>A management application and a platform MBeanServer of a running virtual machine can interoperate without requiring classes used by the platform MXBean interfaces. The data types being transmitted between the JMX connector server and the connector client are JMX &lt;a href=&quot;../../../javax/management/openmbean/opentype&quot;&gt;open types&lt;/a&gt; and this allows interoperation across versions. A data type used by the MXBean interfaces are mapped to an open type when being accessed via MBeanServer interface. See the &lt;a href=&quot;../../../javax/management/mxbean#MXBean-spec&quot;&gt; MXBean&lt;/a&gt; specification for details.</source>
          <target state="translated">실행중인 가상 머신의 관리 애플리케이션 및 플랫폼 MBeanServer는 플랫폼 MXBean 인터페이스에서 사용하는 클래스를 요구하지 않고 상호 운용 할 수 있습니다. JMX 커넥터 서버와 커넥터 클라이언트간에 전송되는 데이터 유형은 JMX &lt;a href=&quot;../../../javax/management/openmbean/opentype&quot;&gt;개방형&lt;/a&gt; 이므로 버전 간 상호 운용이 가능합니다. MXBean 인터페이스에서 사용하는 데이터 유형은 MBeanServer 인터페이스를 통해 액세스 될 때 열린 유형에 맵핑됩니다. 세부 사항 은 &lt;a href=&quot;../../../javax/management/mxbean#MXBean-spec&quot;&gt;MXBean&lt;/a&gt; 스펙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="523acc2618e298537fac6c6db657235420efeba2" translate="yes" xml:space="preserve">
          <source>A map entry (key-value pair).</source>
          <target state="translated">맵 항목 (키-값 쌍).</target>
        </trans-unit>
        <trans-unit id="f8154228f438e29a074d401ba3f6df78033cad84" translate="yes" xml:space="preserve">
          <source>A map entry (key-value pair). The &lt;code&gt;Map.entrySet&lt;/code&gt; method returns a collection-view of the map, whose elements are of this class. The</source>
          <target state="translated">맵 항목 (키-값 쌍). &lt;code&gt;Map.entrySet&lt;/code&gt; 의 방법은이 클래스에 속하는 요소를 가지는 맵의 코레 크 션뷰를 돌려줍니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="734ae33840ce4ece035615ca1a3162f9e1c88c0c" translate="yes" xml:space="preserve">
          <source>A map from single character keys to string values, indicating extensions apart from language identification. The extensions in &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47 extension subtags and private use subtags. The extensions are case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all extension keys and values to lower case. Note that extensions cannot have empty values.</source>
          <target state="translated">단일 문자 키에서 문자열 값으로의 맵으로 언어 식별과 별개로 확장을 나타냅니다. &lt;code&gt;Locale&lt;/code&gt; 의 확장 은 BCP 47 확장 서브 태그 및 개인용 서브 태그의 시맨틱 및 구문을 구현합니다. 확장명은 대소 문자를 구분하지 않지만 &lt;code&gt;Locale&lt;/code&gt; 모든 확장 키와 값을 소문자로 정규화합니다. 확장은 빈 값을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4fac118eaa61bd3381786afc5506fae5041565a" translate="yes" xml:space="preserve">
          <source>A map of the attributes of the &lt;code&gt;MLET&lt;/code&gt; tag and their values.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 속성 및 해당 값 의 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="ecca0e69af4452740453796ec2257a6e8d86c1b0" translate="yes" xml:space="preserve">
          <source>A map of zone overrides to enable the short time-zone names to be used.</source>
          <target state="translated">짧은 시간대 이름을 사용할 수 있도록 영역 맵이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="125d5f648fdc6b3b583770be46f92225acbb6df2" translate="yes" xml:space="preserve">
          <source>A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.</source>
          <target state="translated">맵핑 된 바이트 버퍼 및이를 나타내는 파일 맵핑은 버퍼 자체가 가비지 수집 될 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1d8b4897e57fdeecad1d940f01be5b12c7f07121" translate="yes" xml:space="preserve">
          <source>A mapping of key/value pairs, all of whose keys are &lt;code&gt;Strings&lt;/code&gt;.</source>
          <target state="translated">키 / 값 쌍, 그 키가 모두의 매핑 &lt;code&gt;Strings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="249f4e6247696ef79d77f9632a8840e624e39fa5" translate="yes" xml:space="preserve">
          <source>A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping.</source>
          <target state="translated">한 번 설정된 매핑은 매핑에 사용 된 파일 채널에 의존하지 않습니다. 특히 채널을 닫으면 매핑의 유효성에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf7ecf320778fa8570ef98cef4c60a4d8eee590" translate="yes" xml:space="preserve">
          <source>A marker interface for &lt;code&gt;KeyStore&lt;/code&gt; entry types.</source>
          <target state="translated">&lt;code&gt;KeyStore&lt;/code&gt; 엔트리 타입 의 마커 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="4f97d254de94be9955d0374c391792c8cd03cd9a" translate="yes" xml:space="preserve">
          <source>A marker interface for &lt;code&gt;KeyStore&lt;/code&gt;&lt;a href=&quot;keystore#load-java.security.KeyStore.LoadStoreParameter-&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keystore#store-java.security.KeyStore.LoadStoreParameter-&quot;&gt;&lt;code&gt;store&lt;/code&gt;&lt;/a&gt; parameters.</source>
          <target state="translated">&lt;code&gt;KeyStore&lt;/code&gt; &lt;a href=&quot;keystore#load-java.security.KeyStore.LoadStoreParameter-&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;keystore#store-java.security.KeyStore.LoadStoreParameter-&quot;&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt; 매개 변수 의 마커 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="b87ab39dbbc70f26edc0d8e9c3fcd2b14e207095" translate="yes" xml:space="preserve">
          <source>A marker interface for keystore protection parameters.</source>
          <target state="translated">키 스토어 보호 파라미터의 마커 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9eff216b480311bcbb9834bfd9e89e5bb1ab95d0" translate="yes" xml:space="preserve">
          <source>A marker interface identifying asynchronous tasks produced by &lt;code&gt;async&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 메서드로 생성 된 비동기 작업을 식별하는 마커 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="c7f8f418ddcef0be0c8c3683d4d5c10eac3e4d5a" translate="yes" xml:space="preserve">
          <source>A marker interface identifying asynchronous tasks produced by &lt;code&gt;async&lt;/code&gt; methods. This may be useful for monitoring, debugging, and tracking asynchronous activities.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 메서드로 생성 된 비동기 작업을 식별하는 마커 인터페이스 입니다. 비동기 활동을 모니터링, 디버깅 및 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a34b881770391e5c98b3f4b648f43d1c9c9288b" translate="yes" xml:space="preserve">
          <source>A master or slave synchronization mode that specifies the use of MIDI Time Code. If this mode is used as the master sync mode, the sequencer gets its timing information from MIDI Time Code messages. This mode only applies as the master sync mode to sequencers that are also MIDI receivers. If this mode is used as the slave sync mode, the sequencer sends MIDI Time Code messages to its receiver. (See the MIDI 1.0 Detailed Specification for a description of MIDI Time Code.)</source>
          <target state="translated">MIDI 타임 코드 사용을 지정하는 마스터 또는 슬레이브 동기화 모드. 이 모드가 마스터 동기화 모드로 사용되면 시퀀서는 MIDI 타임 코드 메시지에서 타이밍 정보를 얻습니다. 이 모드는 MIDI 리시버이기도 한 시퀀서에만 마스터 동기화 모드로 적용됩니다. 이 모드가 슬레이브 동기화 모드로 사용되면 시퀀서는 MIDI 타임 코드 메시지를 수신기로 보냅니다. (MIDI 타임 코드에 대한 설명은 MIDI 1.0 세부 사양을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f1c1acbd4422c8096f1ccd850fc6f1437ccd7db8" translate="yes" xml:space="preserve">
          <source>A master or slave synchronization mode that specifies the use of MIDI clock messages. If this mode is used as the master sync mode, the sequencer gets its timing information from system real-time MIDI clock messages. This mode only applies as the master sync mode for sequencers that are also MIDI receivers. If this is the slave sync mode, the sequencer sends system real-time MIDI clock messages to its receiver. MIDI clock messages are sent at a rate of 24 per quarter note.</source>
          <target state="translated">MIDI 클럭 메시지 사용을 지정하는 마스터 또는 슬레이브 동기화 모드. 이 모드가 마스터 동기화 모드로 사용되면 시퀀서는 시스템 실시간 MIDI 클럭 메시지에서 타이밍 정보를 얻습니다. 이 모드는 MIDI 수신기 인 시퀀서의 마스터 동기화 모드로만 적용됩니다. 이것이 슬레이브 동기화 모드 인 경우 시퀀서는 시스템 실시간 MIDI 클럭 메시지를 수신기로 보냅니다. MIDI 클록 메시지는 분기당 24의 비율로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="12d3b27856e9bd36d1a97eaae0372f0f8a17e986" translate="yes" xml:space="preserve">
          <source>A master synchronization mode that makes the sequencer get its timing information from its internal clock. This is not a legal slave sync mode.</source>
          <target state="translated">시퀀서가 내부 클록으로부터 타이밍 정보를 얻도록하는 마스터 동기화 모드. 이것은 올바른 슬레이브 동기화 모드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e8d49a16c11b345dbd45845c1fa0699317425664" translate="yes" xml:space="preserve">
          <source>A matcher finds matches in a subset of its input called the</source>
          <target state="translated">매처는 해당 입력의 하위 집합에서</target>
        </trans-unit>
        <trans-unit id="2beb95eaaa4f46d10d05eb1b5ffd8b1199e910da" translate="yes" xml:space="preserve">
          <source>A matcher is created from a pattern by invoking the pattern's &lt;a href=&quot;pattern#matcher-java.lang.CharSequence-&quot;&gt;&lt;code&gt;matcher&lt;/code&gt;&lt;/a&gt; method. Once created, a matcher can be used to perform three different kinds of match operations:</source>
          <target state="translated">패턴의 &lt;a href=&quot;pattern#matcher-java.lang.CharSequence-&quot;&gt; &lt;code&gt;matcher&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 패턴에서 matcher가 작성됩니다 . 일단 matcher를 사용하면 세 가지 종류의 일치 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec1706ed07cebe204549527211631a07768594eb" translate="yes" xml:space="preserve">
          <source>A matcher may be reset explicitly by invoking its &lt;a href=&quot;matcher#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; method or, if a new input sequence is desired, its &lt;a href=&quot;matcher#reset-java.lang.CharSequence-&quot;&gt;&lt;code&gt;reset(CharSequence)&lt;/code&gt;&lt;/a&gt; method. Resetting a matcher discards its explicit state information and sets the append position to zero.</source>
          <target state="translated">matcher는 &lt;a href=&quot;matcher#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 새 입력 시퀀스가 ​​필요한 경우 &lt;a href=&quot;matcher#reset-java.lang.CharSequence-&quot;&gt; &lt;code&gt;reset(CharSequence)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 명시 적으로 재설정 할 수 있습니다 . 매처를 재설정하면 명시 적 상태 정보가 삭제되고 추가 위치가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aac5131474a1f3893bb80ebe32ae2b7a9c14944f" translate="yes" xml:space="preserve">
          <source>A membership key is valid upon creation and remains valid until the membership is dropped by invoking the &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; method, or the channel is closed. The validity of the membership key may be tested by invoking its &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">멤버쉽 키는 생성시 유효하며 &lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 멤버쉽이 삭제 되거나 채널이 닫힐 때까지 유효합니다 . 멤버쉽 키의 유효성은 &lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92540732008e2be4a329a53daa253b9bb615558c" translate="yes" xml:space="preserve">
          <source>A membership key may represent a membership to receive all datagrams sent to the group, or it may be &lt;em&gt;source-specific&lt;/em&gt;, meaning that it represents a membership that receives only datagrams from a specific source address. Whether or not a membership key is source-specific may be determined by invoking its &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt;&lt;code&gt;sourceAddress&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">멤버쉽 키는 그룹으로 전송 된 모든 데이터 그램을 수신하기위한 멤버쉽을 나타내거나 &lt;em&gt;소스에 따라&lt;/em&gt; 다를 수 있습니다. &lt;em&gt;즉&lt;/em&gt; , 특정 소스 주소에서 데이터 그램 만 수신하는 멤버쉽을 나타냅니다. 멤버쉽 키가 소스 특정인지 여부는 &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt; &lt;code&gt;sourceAddress&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="759c3acd1cbf2f8d514c805241af3bdaa1b340bb" translate="yes" xml:space="preserve">
          <source>A memory manager is responsible for managing one or more memory pools. The garbage collector is one type of memory manager responsible for reclaiming memory occupied by unreachable objects. A Java virtual machine may have one or more memory managers. It may add or remove memory managers during execution. A memory pool can be managed by more than one memory manager.</source>
          <target state="translated">메모리 관리자는 하나 이상의 메모리 풀을 관리합니다. 가비지 수집기는 도달 할 수없는 객체가 차지한 메모리를 회수하는 책임을지는 한 가지 유형의 메모리 관리자입니다. Java 가상 머신에는 하나 이상의 메모리 관리자가있을 수 있습니다. 실행 중에 메모리 관리자를 추가하거나 제거 할 수 있습니다. 메모리 풀은 둘 이상의 메모리 관리자가 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="bf21ff485998503fc83eb613e59967f6d9bc4ba8" translate="yes" xml:space="preserve">
          <source>A memory notification is emitted by &lt;a href=&quot;memorymxbean&quot;&gt;&lt;code&gt;MemoryMXBean&lt;/code&gt;&lt;/a&gt; when the Java virtual machine detects that the memory usage of a memory pool is exceeding a threshold value. The notification emitted will contain the memory notification information about the detected condition:</source>
          <target state="translated">Java 가상 머신이 메모리 풀의 메모리 사용량이 임계 값을 초과 함을 감지하면 &lt;a href=&quot;memorymxbean&quot;&gt; &lt;code&gt;MemoryMXBean&lt;/code&gt; 에&lt;/a&gt; 의해 메모리 알림이 생성됩니다 . 생성 된 알림에는 감지 된 조건에 대한 메모리 알림 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8ab28529f854079d6bca735fc48ddf13983bb582" translate="yes" xml:space="preserve">
          <source>A memory pool has the following attributes:</source>
          <target state="translated">메모리 풀에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dcfc0734c44f5245f5a089b1b448dece950547" translate="yes" xml:space="preserve">
          <source>A memory pool represents a memory area that the Java virtual machine manages. The Java virtual machine has at least one memory pool and it may create or remove memory pools during execution. A memory pool can belong to either the heap or the non-heap memory.</source>
          <target state="translated">메모리 풀은 Java 가상 머신이 관리하는 메모리 영역을 나타냅니다. Java 가상 머신에는 하나 이상의 메모리 풀이 있으며 실행 중에 메모리 풀을 작성하거나 제거 할 수 있습니다. 메모리 풀은 힙 또는 힙이 아닌 메모리에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="457a7051128277e171a5ea7f82f57b1cd1040435" translate="yes" xml:space="preserve">
          <source>A method &lt;code&gt;&lt;em&gt;T&lt;/em&gt; get&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt;, where &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; is a Java type (not &lt;code&gt;void&lt;/code&gt;) and &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; is a non-empty string, specifies that there is a readable attribute called &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;. The Java type and Open type of the attribute are determined by the mapping rules below. The method &lt;code&gt;final Class getClass()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt; is ignored when looking for getters.</source>
          <target state="translated">메소드 &lt;code&gt;&lt;em&gt;T&lt;/em&gt; get&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt; (여기서 &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아닌 Java 유형 이고 &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 은 비어 있지 않은 문자열 임) 은 &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 이라는 읽기 가능한 속성이 있음을 지정합니다 . 속성의 Java 유형과 Open 유형은 아래의 매핑 규칙에 따라 결정됩니다. getter를 찾을 때 &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 &lt;code&gt;final Class getClass()&lt;/code&gt; 메소드 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="45e0dc0f042d7646630672696718f7e2db616536" translate="yes" xml:space="preserve">
          <source>A method &lt;code&gt;boolean is&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt; specifies that there is a readable attribute called &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; with Java type &lt;code&gt;boolean&lt;/code&gt; and Open type &lt;code&gt;SimpleType.Boolean&lt;/code&gt;.</source>
          <target state="translated">메소드 &lt;code&gt;boolean is&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt; 이라고하는 판독 속성이 존재 함을 지정 &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 자바 형으로 &lt;code&gt;boolean&lt;/code&gt; 와 오픈형 &lt;code&gt;SimpleType.Boolean&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="4a00575483612c388739a75e40677c1065a6370f" translate="yes" xml:space="preserve">
          <source>A method &lt;code&gt;void set&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T&lt;/em&gt; x)&lt;/code&gt; specifies that there is a writeable attribute called &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;. The Java type and Open type of the attribute are determined by the mapping rules below. (Of course, the name &lt;code&gt;x&lt;/code&gt; of the parameter is irrelevant.)</source>
          <target state="translated">&lt;code&gt;void set&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T&lt;/em&gt; x)&lt;/code&gt; 메소드 는 &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 이라는 쓰기 가능한 속성이 있음을 지정합니다 . 속성의 Java 유형과 Open 유형은 아래의 매핑 규칙에 따라 결정됩니다. (물론 매개 변수 의 이름 &lt;code&gt;x&lt;/code&gt; 는 관련이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="6b21bdd4c6300a890a95cf204bbba7785f32d420" translate="yes" xml:space="preserve">
          <source>A method handle can be obtained on a method, constructor, or field which is declared with Java generic types. As with the Core Reflection API, the type of the method handle will constructed from the erasure of the source-level type. When a method handle is invoked, the types of its arguments or the return value cast type may be generic types or type instances. If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the &lt;code&gt;invokevirtual&lt;/code&gt; instruction.</source>
          <target state="translated">메소드 핸들은 Java 일반 유형으로 선언 된 메소드, 생성자 또는 필드에서 얻을 수 있습니다. Core Reflection API와 마찬가지로 메소드 핸들의 유형은 소스 레벨 유형의 삭제로 구성됩니다. 메소드 핸들이 호출 될 때 인수 유형 또는 리턴 값 캐스트 유형은 일반 유형 또는 유형 인스턴스 일 수 있습니다. 이 경우 컴파일러는 &lt;code&gt;invokevirtual&lt;/code&gt; 명령에 대한 기호 유형 설명자를 구성 할 때 해당 유형을 삭제하여 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="8baa56b94df191753f371cdf316dbc026a4b19c5" translate="yes" xml:space="preserve">
          <source>A method handle contains a pair of special invoker methods called &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;. Both invoker methods provide direct access to the method handle's underlying method, constructor, field, or other operation, as modified by transformations of arguments and return values. Both invokers accept calls which exactly match the method handle's own type. The plain, inexact invoker also accepts a range of other call types.</source>
          <target state="translated">메소드 핸들에는 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 라는 특수 호출자 메소드 쌍이 포함되어 있습니다 . 두 호출자 메소드 모두 인수 및 리턴 값의 변환에 의해 수정 된대로 메소드 핸들의 기본 메소드, 생성자, 필드 또는 기타 조작에 직접 액세스 할 수 있습니다. 두 호출자 모두 메소드 핸들 자체 유형과 정확히 일치하는 호출을 승인합니다. 정확하고 정확하지 않은 호출자는 다양한 다른 호출 유형도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="572fd61588901813858a5e05ef980f150779222e" translate="yes" xml:space="preserve">
          <source>A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.</source>
          <target state="translated">메소드 핸들은 인수 또는 리턴 값의 선택적 변환을 사용하여 기본 메소드, 생성자, 필드 또는 유사한 저수준 조작에 대한 직접 실행 가능한 유형의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="3fa05ec6e74c0fc625c0541a82a118964114ff54" translate="yes" xml:space="preserve">
          <source>A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;conversion&lt;/a&gt;, &lt;a href=&quot;methodhandle#bindTo-java.lang.Object-&quot;&gt;insertion&lt;/a&gt;, &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt;deletion&lt;/a&gt;, and &lt;a href=&quot;methodhandles#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-&quot;&gt;substitution&lt;/a&gt;.</source>
          <target state="translated">메소드 핸들은 인수 또는 리턴 값의 선택적 변환을 사용하여 기본 메소드, 생성자, 필드 또는 유사한 저수준 조작에 대한 직접 실행 가능한 유형의 참조입니다. 이러한 변환은 매우 일반적이며 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;변환&lt;/a&gt; , &lt;a href=&quot;methodhandle#bindTo-java.lang.Object-&quot;&gt;삽입&lt;/a&gt; , &lt;a href=&quot;methodhandles#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-&quot;&gt;삭제&lt;/a&gt; 및 &lt;a href=&quot;methodhandles#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-&quot;&gt;대체&lt;/a&gt; 와 같은 패턴을 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="5d952641ca1800b10d6cffa65e1d0f020bc88924" translate="yes" xml:space="preserve">
          <source>A method handle's type controls the types of invocations it accepts, and the kinds of transformations that apply to it.</source>
          <target state="translated">메소드 핸들의 유형은 허용하는 호출 유형 및 적용되는 변환 유형을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="868a3299e2184db727b0edc3655d74054eb7fe70" translate="yes" xml:space="preserve">
          <source>A method is not required to declare in its &lt;code&gt;throws&lt;/code&gt; clause any subclasses of &lt;code&gt;Error&lt;/code&gt; that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur. That is, &lt;code&gt;Error&lt;/code&gt; and its subclasses are regarded as unchecked exceptions for the purposes of compile-time checking of exceptions.</source>
          <target state="translated">메소드는 &lt;code&gt;throws&lt;/code&gt; 절 에서 메소드 실행 중에 발생할 수 있지만 포착되지 않은 &lt;code&gt;Error&lt;/code&gt; 의 서브 클래스 를 선언 할 필요는 없습니다. 이러한 오류는 절대 발생하지 않아야하는 비정상적인 조건이기 때문입니다. 즉, &lt;code&gt;Error&lt;/code&gt; 및 해당 서브 클래스는 예외 컴파일 시간 검사를 위해 검사되지 않은 예외로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9eec3fbd4625bc7c0178910686b6b7a4115fd480" translate="yes" xml:space="preserve">
          <source>A method reference may refer either to a static or non-static method. In the non-static case, the method handle type includes an explicit receiver argument, prepended before any other arguments. In the method handle's type, the initial receiver argument is typed according to the class under which the method was initially requested. (E.g., if a non-static method handle is obtained via &lt;code&gt;ldc&lt;/code&gt;, the type of the receiver is the class named in the constant pool entry.)</source>
          <target state="translated">메소드 참조는 정적 또는 비 정적 메소드를 참조 할 수 있습니다. 비 정적 경우, 메소드 핸들 유형에는 다른 인수 앞에 추가 된 명시 적 수신자 인수가 포함됩니다. 메소드 핸들의 유형에서 초기 수신자 인수는 메소드가 처음 요청 된 클래스에 따라 유형이 지정됩니다. (예를 들어, 비 정적 메소드 핸들이 &lt;code&gt;ldc&lt;/code&gt; 를 통해 얻은 경우, 수신자의 유형은 상수 풀 항목에 이름이 지정된 클래스입니다.)</target>
        </trans-unit>
        <trans-unit id="cad269b9da91c19f486eedab75bf4efc3bb48451" translate="yes" xml:space="preserve">
          <source>A method reference to the exception constructor with an empty argument list can be used as the supplier. For example, &lt;code&gt;IllegalStateException::new&lt;/code&gt;</source>
          <target state="translated">빈 인수 목록이있는 예외 생성자에 대한 메서드 참조를 공급자로 사용할 수 있습니다. 예를 들어, &lt;code&gt;IllegalStateException::new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80ff713d25db02a3cefe09efa77844101963da11" translate="yes" xml:space="preserve">
          <source>A method that result-bearing CountedCompleters may optionally use to help maintain result data. By default, does nothing. Overrides are not recommended. However, if this method is overridden to update existing objects or fields, then it must in general be defined to be thread-safe.</source>
          <target state="translated">결과를 나타내는 CountedCompleters는 선택적으로 결과 데이터를 유지 관리하는 데 사용할 수있는 방법입니다. 기본적으로 아무 것도 수행하지 않습니다. 재정의는 권장되지 않습니다. 그러나 기존 객체 또는 필드를 업데이트하기 위해이 방법을 재정의하는 경우 일반적으로 스레드 안전하도록 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4afeaccf26c0c9c61c626d5668b50078b9e9509" translate="yes" xml:space="preserve">
          <source>A method type represents the arguments and return type accepted and returned by a method handle, or the arguments and return type passed and expected by a method handle caller.</source>
          <target state="translated">메소드 유형은 메소드 핸들이 승인하고 리턴하는 인수 및 리턴 유형 또는 메소드 핸들 호출자가 전달하고 예상 한 인수 및 리턴 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71a2dc9fcf19a2c5b0704beb5103aeb20daf64e4" translate="yes" xml:space="preserve">
          <source>A method type represents the arguments and return type accepted and returned by a method handle, or the arguments and return type passed and expected by a method handle caller. Method types must be properly matched between a method handle and all its callers, and the JVM's operations enforce this matching at, specifically during calls to &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;MethodHandle.invokeExact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;MethodHandle.invoke&lt;/code&gt;&lt;/a&gt;, and during execution of &lt;code&gt;invokedynamic&lt;/code&gt; instructions.</source>
          <target state="translated">메소드 유형은 메소드 핸들이 승인하고 리턴하는 인수 및 리턴 유형 또는 메소드 핸들 호출자가 전달하고 예상 한 인수 및 리턴 유형을 나타냅니다. 메소드 핸들은 메소드 핸들과 모든 호출자간에 올바르게 일치해야하며 JVM 조작은 특히 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;MethodHandle.invokeExact&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;MethodHandle.invoke&lt;/code&gt; &lt;/a&gt; 호출 중 및 &lt;code&gt;invokedynamic&lt;/code&gt; 명령 실행 중에이 일치를 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="45fcaa635da8696543cc6670e9a6f2c07be4af8b" translate="yes" xml:space="preserve">
          <source>A method, constructor, or initializer.</source>
          <target state="translated">메서드, 생성자 또는 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="d107594adcb7aadca22825c251cefea0649e7b80" translate="yes" xml:space="preserve">
          <source>A method.</source>
          <target state="translated">방법.</target>
        </trans-unit>
        <trans-unit id="a6157c9c5a862c0de70fda2d64867e07de05695a" translate="yes" xml:space="preserve">
          <source>A minimal set of system dependent environment variables may be required to start a process on some operating systems. As a result, the subprocess may inherit additional environment variable settings beyond those in the process builder's &lt;a href=&quot;processbuilder#environment--&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 운영 체제에서 프로세스를 시작하려면 최소한의 시스템 종속 환경 변수 세트가 필요할 수 있습니다. 결과적으로 서브 프로세스는 프로세스 빌더의 &lt;a href=&quot;processbuilder#environment--&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 이외의 추가 환경 변수 설정을 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78868ad6806cc456fd63e85f5e434673de3bcbf" translate="yes" xml:space="preserve">
          <source>A minimal set of system dependent environment variables may be required to start a process on some operating systems. As a result, the subprocess may inherit additional environment variable settings beyond those in the specified environment.</source>
          <target state="translated">일부 운영 체제에서 프로세스를 시작하려면 최소한의 시스템 종속 환경 변수 세트가 필요할 수 있습니다. 결과적으로, 서브 프로세스는 지정된 환경의 설정 이외의 추가 환경 변수 설정을 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90de6152ceb7e2040443e1d839e2daeb98a99880" translate="yes" xml:space="preserve">
          <source>A minute is represented by an integer from 0 to 59 in the usual manner.</source>
          <target state="translated">분은 일반적인 방식으로 0에서 59 사이의 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2b165d0ebb6938fa640f88e06d14ff5829009a" translate="yes" xml:space="preserve">
          <source>A mix-in style interface for marking objects that should be acted upon after a given delay.</source>
          <target state="translated">지정된 지연 후에 작동해야하는 객체를 표시하기위한 믹스 인 스타일 인터페이스.</target>
        </trans-unit>
        <trans-unit id="a82b2f3ea80435da0528df31d8de211f9f131bb9" translate="yes" xml:space="preserve">
          <source>A mixer can support synchronization of its lines. When one line in a synchronized group is started or stopped, the other lines in the group automatically start or stop simultaneously with the explicitly affected one.</source>
          <target state="translated">믹서는 회선 동기화를 지원할 수 있습니다. 동기화 된 그룹의 한 라인이 시작 또는 중지되면 그룹의 다른 라인은 자동으로 영향을받는 라인과 동시에 시작되거나 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="6605ccbd86386660b3cccfb6c44a5bbaf230733d" translate="yes" xml:space="preserve">
          <source>A mixer is an audio device with one or more lines.</source>
          <target state="translated">믹서는 하나 이상의 라인이있는 오디오 장치입니다.</target>
        </trans-unit>
        <trans-unit id="f0a85bd03cce327d0a024b8ca3c5739ec1759ae7" translate="yes" xml:space="preserve">
          <source>A mixer is an audio device with one or more lines. It need not be designed for mixing audio signals. A mixer that actually mixes audio has multiple input (source) lines and at least one output (target) line. The former are often instances of classes that implement &lt;code&gt;&lt;a href=&quot;sourcedataline&quot;&gt;&lt;code&gt;SourceDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;, and the latter, &lt;code&gt;&lt;a href=&quot;targetdataline&quot;&gt;&lt;code&gt;TargetDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; objects, too, are either source lines or target lines. A mixer can accept prerecorded, loopable sound as input, by having some of its source lines be instances of objects that implement the &lt;code&gt;&lt;a href=&quot;clip&quot;&gt;&lt;code&gt;Clip&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">믹서는 하나 이상의 라인이있는 오디오 장치입니다. 오디오 신호를 믹싱하도록 설계 될 필요는 없습니다. 실제로 오디오를 믹스하는 믹서에는 여러 입력 (소스) 라인과 하나 이상의 출력 (타겟) 라인이 있습니다. 전자는 종종 &lt;code&gt;&lt;a href=&quot;sourcedataline&quot;&gt;&lt;code&gt;SourceDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 을 구현하는 클래스의 인스턴스이고 후자는 &lt;code&gt;&lt;a href=&quot;targetdataline&quot;&gt;&lt;code&gt;TargetDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 객체도 소스 라인 또는 대상 라인입니다. 믹서는 소스 라인 중 일부를 &lt;code&gt;&lt;a href=&quot;clip&quot;&gt;&lt;code&gt;Clip&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 인터페이스 를 구현하는 객체의 인스턴스로함으로써 미리 녹음 된 루프 가능한 사운드를 입력으로 받아 들일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb3efede6328869ca7c41918f11095f6b2a95ea9" translate="yes" xml:space="preserve">
          <source>A mixin interface for an element that has a qualified name.</source>
          <target state="translated">규정 된 이름을 가진 요소의 믹스 인 인터페이스.</target>
        </trans-unit>
        <trans-unit id="940bc0118071492b342d59cad911ef90c1786c35" translate="yes" xml:space="preserve">
          <source>A mixin interface for an element that has type parameters.</source>
          <target state="translated">유형 매개 변수가있는 요소의 믹스 인 인터페이스.</target>
        </trans-unit>
        <trans-unit id="42953139b3b36dae3cc66096b2aec9e05777e71d" translate="yes" xml:space="preserve">
          <source>A month is represented by an integer from 0 to 11; 0 is January, 1 is February, and so forth; thus 11 is December.</source>
          <target state="translated">월은 0에서 11까지의 정수로 표시됩니다. 0은 1 월이고 1은 2 월 등입니다. 따라서 11은 12 월입니다.</target>
        </trans-unit>
        <trans-unit id="ab22d20d25b582a956df404a2854dfd37a08a7c3" translate="yes" xml:space="preserve">
          <source>A month-day in the ISO-8601 calendar system, such as &lt;code&gt;--12-03&lt;/code&gt;.</source>
          <target state="translated">등은 ISO-8601 달력 시스템에있는 월 - 일, &lt;code&gt;--12-03&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e911868de06210df74694f89f02b4486402c1f21" translate="yes" xml:space="preserve">
          <source>A month-day of February 29th will be adjusted to February 28th in the resulting date if the year is not a leap year.</source>
          <target state="translated">연도가 윤년이 아닌 경우 결과 날짜의 2 월 29 일은 2 월 28 일로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="544d028170c4cc8966d5aa5df1674bb3bd930fe7" translate="yes" xml:space="preserve">
          <source>A month-of-year, such as 'July'.</source>
          <target state="translated">'7 월'과 같은 한 달의 월입니다.</target>
        </trans-unit>
        <trans-unit id="72ef0e6fc016a03a5df04c55ed4903f14c08ffee" translate="yes" xml:space="preserve">
          <source>A more complete and consistent set of LIFO stack operations is provided by the &lt;a href=&quot;deque&quot;&gt;&lt;code&gt;Deque&lt;/code&gt;&lt;/a&gt; interface and its implementations, which should be used in preference to this class. For example:</source>
          <target state="translated">보다 완벽하고 일관된 LIFO 스택 작업 세트는 &lt;a href=&quot;deque&quot;&gt; &lt;code&gt;Deque&lt;/code&gt; &lt;/a&gt; 인터페이스 및 해당 구현에 의해 제공 되며이 클래스보다 우선적으로 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8ef92902ef52fc9390a15bc63628b67c671c8aa" translate="yes" xml:space="preserve">
          <source>A more informative set of completions would include the number of each prime:</source>
          <target state="translated">보다 유익한 완성 세트에는 각 소수의 숫자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8fba423df016bcca01d528c49a66aa0490f8d71b" translate="yes" xml:space="preserve">
          <source>A more interesting case can be illustrated by the following example in which a method in type &lt;code&gt;A&lt;/code&gt; does not override a like-named method in type &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">보다 흥미로운 경우는 유형 &lt;code&gt;A&lt;/code&gt; 의 메소드가 유형 &lt;code&gt;B&lt;/code&gt; 의 유사한 이름의 메소드를 대체하지 않는 다음 예제로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9c58067d77bf7244be501b1ebc8017e9dfb5d7a" translate="yes" xml:space="preserve">
          <source>A more reliable way to determine which &lt;code&gt;ImageReader&lt;/code&gt;s are likely to be able to parse a particular data stream is provided by the &lt;code&gt;canDecodeInput&lt;/code&gt; method. This methods allows the service provider to inspect the actual stream contents.</source>
          <target state="translated">특정 데이터 스트림을 구문 분석 할 수 있는 &lt;code&gt;ImageReader&lt;/code&gt; 를 결정하는보다 안정적인 방법 은 &lt;code&gt;canDecodeInput&lt;/code&gt; 메소드에 의해 제공됩니다 . 이 메소드는 서비스 제공자가 실제 스트림 컨텐츠를 검사 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="6f2e502d946565cf8a0faf1431c1e45de5f7293b" translate="yes" xml:space="preserve">
          <source>A more reliable way to determine which &lt;code&gt;ImageWriter&lt;/code&gt;s are likely to be able to parse a particular data stream is provided by the &lt;code&gt;canEncodeImage&lt;/code&gt; method. This methods allows the service provider to inspect the actual image contents.</source>
          <target state="translated">특정 데이터 스트림을 구문 분석 할 수 있는 &lt;code&gt;ImageWriter&lt;/code&gt; 를 판별하는보다 안정적인 방법 은 &lt;code&gt;canEncodeImage&lt;/code&gt; 메소드로 제공됩니다 . 이 방법을 통해 서비스 공급자는 실제 이미지 내용을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98fad3c4bc26860fd5b43356494929e7f5e13c6" translate="yes" xml:space="preserve">
          <source>A multicast channel may join several multicast groups, including the same group on more than one interface. An implementation may impose a limit on the number of groups that may be joined at the same time.</source>
          <target state="translated">멀티 캐스트 채널은 둘 이상의 인터페이스에서 동일한 그룹을 포함하여 여러 멀티 캐스트 그룹에 참여할 수 있습니다. 구현시 동시에 참여할 수있는 그룹 수에 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6c2bf87ac13f1021feb64a454cd4052af2d2c4" translate="yes" xml:space="preserve">
          <source>A multicast group is specified by a class D IP address and by a standard UDP port number. Class D IP addresses are in the range &lt;code&gt;224.0.0.0&lt;/code&gt; to &lt;code&gt;239.255.255.255&lt;/code&gt;, inclusive. The address 224.0.0.0 is reserved and should not be used.</source>
          <target state="translated">멀티 캐스트 그룹은 클래스 D IP 주소와 표준 UDP 포트 번호로 지정됩니다. 클래스 D IP 주소는 &lt;code&gt;224.0.0.0&lt;/code&gt; ~ &lt;code&gt;239.255.255.255&lt;/code&gt; 범위에 있습니다. 224.0.0.0 주소는 예약되어 있으므로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2c4338d75e8f3f9d14e959f365f91cefea68d6d9" translate="yes" xml:space="preserve">
          <source>A multicast group membership is valid upon creation and remains valid until the membership is dropped by invoking the &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; method, or the channel is closed.</source>
          <target state="translated">멀티 캐스트 그룹 멤버쉽은 작성시 유효하며 &lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 멤버쉽이 삭제 되거나 채널이 닫힐 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="a8f6c2efcaf967fd17cecf4f42e5961f5cdde54a" translate="yes" xml:space="preserve">
          <source>A multiplexor of &lt;a href=&quot;selectablechannel&quot;&gt;&lt;code&gt;SelectableChannel&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;selectablechannel&quot;&gt; &lt;code&gt;SelectableChannel&lt;/code&gt; &lt;/a&gt; 객체 의 멀티플렉서</target>
        </trans-unit>
        <trans-unit id="1495361d783dd2a9d043b0f1ccc945ff6d84551d" translate="yes" xml:space="preserve">
          <source>A multiplexor of selectable channels</source>
          <target state="translated">선택 가능한 채널의 멀티플렉서</target>
        </trans-unit>
        <trans-unit id="555863f097a94438e284e109cba2dc49bb401875" translate="yes" xml:space="preserve">
          <source>A mutable builder for a &lt;code&gt;DoubleStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DoubleStream&lt;/code&gt; 의 가변 빌더입니다 .</target>
        </trans-unit>
        <trans-unit id="90417ba4d57dcf29afd7fec868b8fdb146ad4c9b" translate="yes" xml:space="preserve">
          <source>A mutable builder for a &lt;code&gt;LongStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LongStream&lt;/code&gt; 의 가변 빌더입니다 .</target>
        </trans-unit>
        <trans-unit id="044e204fc4ab1c02d5ea7c7f7994ed6f2a93ca7d" translate="yes" xml:space="preserve">
          <source>A mutable builder for a &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 의 변경 가능한 빌더입니다 .</target>
        </trans-unit>
        <trans-unit id="a93cbe7058fafefe2e6c3715c295688f4da1f0bc" translate="yes" xml:space="preserve">
          <source>A mutable builder for a &lt;code&gt;Stream&lt;/code&gt;. This allows the creation of a &lt;code&gt;Stream&lt;/code&gt; by generating elements individually and adding them to the &lt;code&gt;Builder&lt;/code&gt; (without the copying overhead that comes from using an &lt;code&gt;ArrayList&lt;/code&gt; as a temporary buffer.)</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 의 변경 가능한 빌더입니다 . 이를 통해 요소를 개별적으로 생성하고 &lt;code&gt;Builder&lt;/code&gt; 추가 하여 &lt;code&gt;Stream&lt;/code&gt; 을 작성할 수 있습니다 ( &lt;code&gt;ArrayList&lt;/code&gt; 를 임시 버퍼로 사용하여 발생하는 복사 오버 헤드없이 ).</target>
        </trans-unit>
        <trans-unit id="18ca1533c6784699fe41abab6fed9f7491312a39" translate="yes" xml:space="preserve">
          <source>A mutable builder for an &lt;code&gt;IntStream&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IntStream&lt;/code&gt; 의 가변 빌더입니다 .</target>
        </trans-unit>
        <trans-unit id="ecc126b3174f7ae048b22adc473a9269aec45ddf" translate="yes" xml:space="preserve">
          <source>A mutable sequence of characters.</source>
          <target state="translated">변경 가능한 문자 시퀀스</target>
        </trans-unit>
        <trans-unit id="114a5f53e63078efc11af25d64ad64ab43e20f20" translate="yes" xml:space="preserve">
          <source>A mutable sequence of characters. This class provides an API compatible with &lt;code&gt;StringBuffer&lt;/code&gt;, but with no guarantee of synchronization. This class is designed for use as a drop-in replacement for &lt;code&gt;StringBuffer&lt;/code&gt; in places where the string buffer was being used by a single thread (as is generally the case). Where possible, it is recommended that this class be used in preference to &lt;code&gt;StringBuffer&lt;/code&gt; as it will be faster under most implementations.</source>
          <target state="translated">변경 가능한 문자 시퀀스 이 클래스는 &lt;code&gt;StringBuffer&lt;/code&gt; 와 호환되는 API를 제공 하지만 동기화를 보장하지는 않습니다. 이 클래스는 문자열 버퍼가 단일 스레드에 의해 사용되는 장소에서 &lt;code&gt;StringBuffer&lt;/code&gt; 를 대체하는 대체물로 사용하도록 설계되었습니다 (일반적인 경우). 가능한 경우이 클래스 는 대부분의 구현에서 더 빠를 것이기 때문에 &lt;code&gt;StringBuffer&lt;/code&gt; 보다 우선적으로 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="72b546ec375c20860b8c2b5ba62a0a6c41c735cf" translate="yes" xml:space="preserve">
          <source>A named mapping between characters</source>
          <target state="translated">문자 사이의 명명 된 매핑</target>
        </trans-unit>
        <trans-unit id="500b84de38af55c5c034588505665f0cccfa6d4e" translate="yes" xml:space="preserve">
          <source>A named mapping between sequences of sixteen-bit Unicode &lt;a href=&quot;../../lang/character#unicode&quot;&gt;code units&lt;/a&gt; and sequences of bytes.</source>
          <target state="translated">16 비트 유니 &lt;a href=&quot;../../lang/character#unicode&quot;&gt;코드 코드 단위&lt;/a&gt; 시퀀스와 바이트 시퀀스 사이의 명명 된 매핑 입니다.</target>
        </trans-unit>
        <trans-unit id="8a8533ff28a7e7235565a6d9d987a050c6c50423" translate="yes" xml:space="preserve">
          <source>A named mapping between sequences of sixteen-bit Unicode &lt;a href=&quot;../../lang/character#unicode&quot;&gt;code units&lt;/a&gt; and sequences of bytes. This class defines methods for creating decoders and encoders and for retrieving the various names associated with a charset. Instances of this class are immutable.</source>
          <target state="translated">16 비트 유니 &lt;a href=&quot;../../lang/character#unicode&quot;&gt;코드 코드 단위&lt;/a&gt; 시퀀스와 바이트 시퀀스 사이의 명명 된 매핑 입니다. 이 클래스는 디코더와 인코더를 생성하고 문자셋과 관련된 다양한 이름을 검색하기위한 메소드를 정의합니다. 이 클래스의 인스턴스는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="458cd2c85e7533ea872f2e22726ff6877b1309a4" translate="yes" xml:space="preserve">
          <source>A named type declared within a construct other than a type.</source>
          <target state="translated">형식 이외의 구문 내에서 선언 된 명명 된 형식</target>
        </trans-unit>
        <trans-unit id="1f79de9c3b1e951c7064e57fbe3bb9c1a04d7fa1" translate="yes" xml:space="preserve">
          <source>A natural line that contains only white space characters is considered blank and is ignored. A comment line has an ASCII &lt;code&gt;'#'&lt;/code&gt; or &lt;code&gt;'!'&lt;/code&gt; as its first non-white space character; comment lines are also ignored and do not encode key-element information. In addition to line terminators, this format considers the characters space (&lt;code&gt;' '&lt;/code&gt;, &lt;code&gt;'\u0020'&lt;/code&gt;), tab (&lt;code&gt;'\t'&lt;/code&gt;, &lt;code&gt;'\u0009'&lt;/code&gt;), and form feed (&lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\u000C'&lt;/code&gt;) to be white space.</source>
          <target state="translated">공백 문자 만 포함 된 자연 줄은 공백으로 간주되어 무시됩니다. 주석 줄에는 ASCII &lt;code&gt;'#'&lt;/code&gt; 또는 &lt;code&gt;'!'&lt;/code&gt; 가 있습니다.공백이 아닌 첫 번째 문자로서; 주석 행도 무시되며 키 요소 정보를 인코딩하지 않습니다. 줄 종결 자 &lt;code&gt;'\u0020'&lt;/code&gt; 형식은 문자 공간 ( &lt;code&gt;' '&lt;/code&gt; , '\ u0020' ), 탭 ( &lt;code&gt;'\t'&lt;/code&gt; , &lt;code&gt;'\u0009'&lt;/code&gt; ) 및 양식 피드 ( &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\u000C'&lt;/code&gt; )를 공백이 되십시오.</target>
        </trans-unit>
        <trans-unit id="f5b4f6afaac43c87c02b9b20cd494e01bc27a526" translate="yes" xml:space="preserve">
          <source>A negated constraint. The returned object will be serialized as an instance of the non-public class  javax.management.NotQueryExp.</source>
          <target state="translated">부정 된 제약. 리턴 된 오브젝트는 비 공용 클래스 javax.management.NotQueryExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="79bb08b42e8bcc663e05f72c5017484d7a3c8843" translate="yes" xml:space="preserve">
          <source>A negative integer, zero, or a positive integer as this Name is less than, equal to, or greater than the given obj.</source>
          <target state="translated">이 Name이 지정된 obj보다 작은 경우는 부의 정수, 0 또는 양의 정수</target>
        </trans-unit>
        <trans-unit id="6eced5b2e4d81d3b26a2627fda3671b2f3b39190" translate="yes" xml:space="preserve">
          <source>A negative integer, zero, or a positive integer as this Rdn is less than, equal to, or greater than the given Object.</source>
          <target state="translated">이 Rdn가 지정된 Object보다 작은 경우는 부의 정수, 제로 또는 정의 정수</target>
        </trans-unit>
        <trans-unit id="9fb8c6b86e5345cbef91652c29458695a07c1f13" translate="yes" xml:space="preserve">
          <source>A negative integer, zero, or a positive integer as this URI is less than, equal to, or greater than the given URI</source>
          <target state="translated">이 URI가 지정된 URI보다 작거나 같거나 더 큰 음수, 0 또는 양의 정수</target>
        </trans-unit>
        <trans-unit id="ed80c12a5615031d10b0f7059e7c8eb7c272608a" translate="yes" xml:space="preserve">
          <source>A negative integer, zero, or a positive integer as this buffer is less than, equal to, or greater than the given buffer</source>
          <target state="translated">이 버퍼가 지정된 버퍼보다 ​​작거나 같거나 크므로 음의 정수, 0 또는 양의 정수</target>
        </trans-unit>
        <trans-unit id="c47633dceffec00e2e7bfd87003eb21a20911f2d" translate="yes" xml:space="preserve">
          <source>A negative integer, zero, or a positive integer as this charset is less than, equal to, or greater than the specified charset</source>
          <target state="translated">이 문자 세트가 지정된 문자 세트보다 작거나 같거나 큰 경우 음의 정수, 0 또는 양의 정수</target>
        </trans-unit>
        <trans-unit id="58f9c54b8b24163ccca7d19df4cfdcb1e2f4b205" translate="yes" xml:space="preserve">
          <source>A negative value means that the cookie is not stored persistently and will be deleted when the Web browser exits. A zero value causes the cookie to be deleted.</source>
          <target state="translated">음수 값은 쿠키가 지속적으로 저장되지 않으며 웹 브라우저가 종료 될 때 삭제됨을 의미합니다. 값이 0이면 쿠키가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="88f0bc390bc81564616c7ace6f9f0ff719f435d2" translate="yes" xml:space="preserve">
          <source>A network channel that supports Internet Protocol (IP) multicasting.</source>
          <target state="translated">IP (Internet Protocol) 멀티 캐스팅을 지원하는 네트워크 채널.</target>
        </trans-unit>
        <trans-unit id="cbdc419e84e51b1088337a46cc75bdfa7afbab39" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance for this &lt;code&gt;Lock&lt;/code&gt; instance</source>
          <target state="translated">이 &lt;code&gt;Lock&lt;/code&gt; 인스턴스 의 새로운 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="aceb0d651c53edfc705d99c1a7c6bd60485b446b" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c807f5aaccbe3ed21f9844b74c3f8e26dc5c8f14" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object for managing the subprocess</source>
          <target state="translated">하위 프로세스 관리를위한 새로운 &lt;a href=&quot;process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="41077822641618130ec0bedfaf21b31638589ccb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;NodeList&lt;/code&gt; object containing all the matched &lt;code&gt;Elements&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;NodeList&lt;/code&gt; 를에 일치하는 모든 포함 된 개체 &lt;code&gt;Elements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a0818fae3b102f2598d388007a8a9be75f48b7f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;ProtectionDomain&lt;/code&gt; instance is created for each &lt;code&gt;ProtectionDomain&lt;/code&gt; in the</source>
          <target state="translated">새 &lt;code&gt;ProtectionDomain&lt;/code&gt; 인스턴스는 각 &lt;code&gt;ProtectionDomain&lt;/code&gt; 에 대해</target>
        </trans-unit>
        <trans-unit id="a95239ece3f57681e7656c554da453f9592e1013" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;ScriptEngine&lt;/code&gt; instance.</source>
          <target state="translated">새로운 &lt;code&gt;ScriptEngine&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="eda082cce43bbb1d4dd772771575be56b104b4ff" translate="yes" xml:space="preserve">
          <source>A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 AlgorithmParameterGeneratorSpi 구현을 캡슐화하는 새로운 AlgorithmParameterGenerator 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0096921d89846c0cf2763feccbd6997a0ca057e4" translate="yes" xml:space="preserve">
          <source>A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 AlgorithmParameterGeneratorSpi 구현을 캡슐화하는 새로운 AlgorithmParameterGenerator 객체가 리턴됩니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8db4ef5023ec47dffbc295585ed2ee725e8ec7e" translate="yes" xml:space="preserve">
          <source>A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 AlgorithmParametersSpi 구현을 캡슐화하는 새로운 AlgorithmParameters 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="05e564e535bfdce60132adece41bae9a47113364" translate="yes" xml:space="preserve">
          <source>A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 AlgorithmParametersSpi 구현을 캡슐화하는 새로운 AlgorithmParameters 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f1d7452ea04f9c2afe99ae652273776235855e7" translate="yes" xml:space="preserve">
          <source>A new CertPathBuilder object encapsulating the CertPathBuilderSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 CertPathBuilderSpi 구현을 캡슐화하는 새로운 CertPathBuilder 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4813f80297b39ee0005052624b5afe1227d8ba78" translate="yes" xml:space="preserve">
          <source>A new CertPathBuilder object encapsulating the CertPathBuilderSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 CertPathBuilderSpi 구현을 캡슐화하는 새로운 CertPathBuilder 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f6e5d465fe4439ee8d90eb2dc3dbe6fb7f98e1" translate="yes" xml:space="preserve">
          <source>A new CertPathValidator object encapsulating the CertPathValidatorSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 CertPathValidatorSpi 구현을 캡슐화하는 새로운 CertPathValidator 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c47b2e857fd28f65e29dfe763089c7fad02932d8" translate="yes" xml:space="preserve">
          <source>A new CertPathValidator object encapsulating the CertPathValidatorSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 CertPathValidatorSpi 구현을 캡슐화하는 새로운 CertPathValidator 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd4645178202c99207e926685878b815ba8fce2" translate="yes" xml:space="preserve">
          <source>A new CertStore object encapsulating the CertStoreSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 CertStoreSpi 구현을 캡슐화하는 새로운 CertStore 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d8f6a7b01df83b2a9a8122afb18b83d00dd1d65" translate="yes" xml:space="preserve">
          <source>A new CertStore object encapsulating the CertStoreSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 CertStoreSpi 구현을 캡슐화하는 새로운 CertStore 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ffe740d37d58dd03d186ad8aaf4cc29b54a3ee6" translate="yes" xml:space="preserve">
          <source>A new CertificateFactory object encapsulating the CertificateFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 CertificateFactorySpi 구현을 캡슐화하는 새로운 CertificateFactory 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="667c5edd8de2720b23e0df06dc2169efc2ffbf6e" translate="yes" xml:space="preserve">
          <source>A new CertificateFactory object encapsulating the CertificateFactorySpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 CertificateFactorySpi 구현을 캡슐화하는 새로운 CertificateFactory 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="13f5262b3e58b67e449bf85fb8910c0c65651876" translate="yes" xml:space="preserve">
          <source>A new Cipher object encapsulating the CipherSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 CipherSpi 구현을 캡슐화하는 새로운 Cipher 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a779576cecf11550d340570f7b289b329b69e9c0" translate="yes" xml:space="preserve">
          <source>A new Cipher object encapsulating the CipherSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 CipherSpi 구현을 캡슐화하는 새로운 Cipher 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6ef251d1ad08ddaf631fcd2060e3b3a5e0f46c5" translate="yes" xml:space="preserve">
          <source>A new Configuration object encapsulating the ConfigurationSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 ConfigurationSpi 구현을 캡슐화하는 새로운 Configuration 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa463bab5fbb393507e91ecd483b38008a3795b7" translate="yes" xml:space="preserve">
          <source>A new Configuration object encapsulating the ConfigurationSpi implementation from the specified provider is returned. The specified provider must be registered in the provider list.</source>
          <target state="translated">지정된 공급자의 ConfigurationSpi 구현을 캡슐화하는 새로운 Configuration 개체가 반환됩니다. 지정된 제공자는 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d7bca7783460fdcbe766d8afa49d507dd57fce6" translate="yes" xml:space="preserve">
          <source>A new ExemptionMechanism object encapsulating the ExemptionMechanismSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 ExemptionMechanismSpi 구현을 캡슐화하는 새로운 ExemptionMechanism 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d01edec86d421f499b113f481dc2188c1235265" translate="yes" xml:space="preserve">
          <source>A new ExemptionMechanism object encapsulating the ExemptionMechanismSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 공급자로부터 ExemptionMechanismSpi 구현을 캡슐화하는 새로운 ExemptionMechanism 객체가 반환됩니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a8f176dc13128dc7727dc967e2effffb4fd2d1e" translate="yes" xml:space="preserve">
          <source>A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 KeyAgreementSpi 구현을 캡슐화하는 새로운 KeyAgreement 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="abfdca351b763735030c6ffa741e09a2e267a2fe" translate="yes" xml:space="preserve">
          <source>A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyAgreementSpi 구현을 캡슐화하는 새로운 KeyAgreement 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="84931dacf7f4308bf76b01043d9e1d1952f0c0e2" translate="yes" xml:space="preserve">
          <source>A new KeyFactory object encapsulating the KeyFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 KeyFactorySpi 구현을 캡슐화하는 새로운 KeyFactory 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="17be658cae2f4ca28d3a636c2fb89480fddc80e2" translate="yes" xml:space="preserve">
          <source>A new KeyFactory object encapsulating the KeyFactorySpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyFactorySpi 구현을 캡슐화하는 새로운 KeyFactory 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="726b9be3aa361c7a1a6a8904841d210166b70e4a" translate="yes" xml:space="preserve">
          <source>A new KeyGenerator object encapsulating the KeyGeneratorSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 KeyGeneratorSpi 구현을 캡슐화하는 새로운 KeyGenerator 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="601bd47706449db33537347d94064978f2eacaea" translate="yes" xml:space="preserve">
          <source>A new KeyGenerator object encapsulating the KeyGeneratorSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyGeneratorSpi 구현을 캡슐화하는 새로운 KeyGenerator 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb1a75f50c4c8029b580cf3a428319dbb0999447" translate="yes" xml:space="preserve">
          <source>A new KeyManagerFactory object encapsulating the KeyManagerFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 KeyManagerFactorySpi 구현을 캡슐화하는 새로운 KeyManagerFactory 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4797fb2c6d23e5bab123bb7103d87927153a81fa" translate="yes" xml:space="preserve">
          <source>A new KeyManagerFactory object encapsulating the KeyManagerFactorySpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyManagerFactorySpi 구현을 캡슐화하는 새로운 KeyManagerFactory 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd15c6ed2e3240f50d98657c044e44c22458ebd1" translate="yes" xml:space="preserve">
          <source>A new KeyPairGenerator object encapsulating the KeyPairGeneratorSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 KeyPairGeneratorSpi 구현을 캡슐화하는 새로운 KeyPairGenerator 객체가 리턴됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="12c4ce735c8941f25ce3934bcb5bb865e73a5782" translate="yes" xml:space="preserve">
          <source>A new KeyPairGenerator object encapsulating the KeyPairGeneratorSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyPairGeneratorSpi 구현을 캡슐화하는 새로운 KeyPairGenerator 객체가 리턴됩니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ab07cbfc7499c36532bc293c456c29f325598e5" translate="yes" xml:space="preserve">
          <source>A new KeyStore object encapsulating the KeyStoreSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 KeyStoreSpi 구현을 캡슐화하는 새로운 KeyStore 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c8dfdc36199a332249519eeeea1609560b4aada" translate="yes" xml:space="preserve">
          <source>A new KeyStore object encapsulating the KeyStoreSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 KeyStoreSpi 구현을 캡슐화하는 새로운 KeyStore 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="efcee39721eebc8fee884a81cb101c715d642357" translate="yes" xml:space="preserve">
          <source>A new Mac object encapsulating the MacSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 MacSpi 구현을 캡슐화하는 새로운 Mac 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3df5f1db3255acb1b4aec4415fe60b9d47e4877d" translate="yes" xml:space="preserve">
          <source>A new Mac object encapsulating the MacSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 공급자로부터 MacSpi 구현을 캡슐화하는 새로운 Mac 객체가 반환됩니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e0370abbf39cd0a1720174664441cdfa936cded" translate="yes" xml:space="preserve">
          <source>A new MessageDigest object encapsulating the MessageDigestSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 MessageDigestSpi 구현을 캡슐화하는 새로운 MessageDigest 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b3460499c4fc8e488a6d3199e9febda0e668b3b" translate="yes" xml:space="preserve">
          <source>A new MessageDigest object encapsulating the MessageDigestSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 MessageDigestSpi 구현을 캡슐화하는 새로운 MessageDigest 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="e951b0d1178624f88694988cc856af7f8e4eb0d7" translate="yes" xml:space="preserve">
          <source>A new Policy object encapsulating the PolicySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 PolicySpi 구현을 캡슐화하는 새로운 Policy 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="af2d9c29be422703f6d5f565cf9b2fa602f5114a" translate="yes" xml:space="preserve">
          <source>A new Policy object encapsulating the PolicySpi implementation from the specified provider is returned. The specified provider must be registered in the provider list.</source>
          <target state="translated">지정된 공급자의 PolicySpi 구현을 캡슐화하는 새로운 정책 개체가 반환됩니다. 지정된 제공자는 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="7858bf11a432c416daff7336874533473b29ac41" translate="yes" xml:space="preserve">
          <source>A new SSLContext object encapsulating the SSLContextSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 SSLContextSpi 구현을 캡슐화하는 새로운 SSLContext 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8fb01cecb27c91b6b8cf68e13eff80f90e7c94f" translate="yes" xml:space="preserve">
          <source>A new SSLContext object encapsulating the SSLContextSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 SSLContextSpi 구현을 캡슐화하는 새로운 SSLContext 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="125b51a284735009e0587e15b1957037a70f2802" translate="yes" xml:space="preserve">
          <source>A new SecretKeyFactory object encapsulating the SecretKeyFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 SecretKeyFactorySpi 구현을 캡슐화하는 새로운 SecretKeyFactory 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a40ee33baacc8bc5aa95c3f9ea8fbb1bb62b66e8" translate="yes" xml:space="preserve">
          <source>A new SecretKeyFactory object encapsulating the SecretKeyFactorySpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 SecretKeyFactorySpi 구현을 캡슐화하는 새로운 SecretKeyFactory 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0ad3fe577ac3de904aa73bfe5d0324bc87a0ef2" translate="yes" xml:space="preserve">
          <source>A new SecureRandom object encapsulating the SecureRandomSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 SecureRandomSpi 구현을 캡슐화하는 새로운 SecureRandom 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cbd31f6dffe090270edeb2c56d25020ed9dc191" translate="yes" xml:space="preserve">
          <source>A new SecureRandom object encapsulating the SecureRandomSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 프로 바이더로부터 SecureRandomSpi 구현을 캡슐화하는 새로운 SecureRandom 객체가 돌려 주어집니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="828cbcea91bf56c9036fa8b7931cff18275cc27b" translate="yes" xml:space="preserve">
          <source>A new Signature object encapsulating the SignatureSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체에서 SignatureSpi 구현을 캡슐화하는 새로운 Signature 객체가 반환됩니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce3264e462754c18f1da3742ab2d57ae7b1dd714" translate="yes" xml:space="preserve">
          <source>A new Signature object encapsulating the SignatureSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list.</source>
          <target state="translated">지정된 공급자의 SignatureSpi 구현을 캡슐화하는 새로운 Signature 객체가 반환됩니다. 지정된 제공자는 보안 제공자 목록에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad638694a4b1174b1e24a42aa6da4815fa5435e1" translate="yes" xml:space="preserve">
          <source>A new Socket &lt;code&gt;s&lt;/code&gt; is created and, if there is a security manager, the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method is called with &lt;code&gt;s.getInetAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;s.getPort()&lt;/code&gt; as its arguments to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">새로운 소켓 &lt;code&gt;s&lt;/code&gt; 보안 관리자가 보안 관리자의 존재하는 경우, 생성됩니다 &lt;code&gt;checkAccept&lt;/code&gt; 메소드가 불려 &lt;code&gt;s.getInetAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;s.getPort()&lt;/code&gt; 작동을 보장하기 위해 인수를 허용한다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97302852d3f597f8d52fdf01ec03933350e6ae95" translate="yes" xml:space="preserve">
          <source>A new TrustManagerFactory object encapsulating the TrustManagerFactorySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</source>
          <target state="translated">지정된 Provider 객체로부터 TrustManagerFactorySpi 구현을 캡슐화하는 새로운 TrustManagerFactory 객체가 돌려 주어집니다. 지정된 제공자 오브젝트를 제공자 목록에 등록 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="23fe331bb6446dd58e24f97a053114136ed0249e" translate="yes" xml:space="preserve">
          <source>A new URI is constructed with this URI's scheme and the given URI's query and fragment components.</source>
          <target state="translated">이 URI의 체계와 지정된 URI의 쿼리 및 조각 구성 요소를 사용하여 새 URI가 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="06f9613f699e6fa12d911001309fb89e22f8dd9e" translate="yes" xml:space="preserve">
          <source>A new asynchronous channel group</source>
          <target state="translated">새로운 비동기 채널 그룹</target>
        </trans-unit>
        <trans-unit id="f9986c93c068befdf1d67a7439a7159a62fd88b3" translate="yes" xml:space="preserve">
          <source>A new asynchronous file channel</source>
          <target state="translated">새로운 비동기 파일 채널</target>
        </trans-unit>
        <trans-unit id="0cbc57d6c284b1dd12c94be8622f616e240f8834" translate="yes" xml:space="preserve">
          <source>A new asynchronous server socket channel</source>
          <target state="translated">새로운 비동기 서버 소켓 채널</target>
        </trans-unit>
        <trans-unit id="9c56f1e622819c89f8e6fae5048bfb4464aa4589" translate="yes" xml:space="preserve">
          <source>A new asynchronous socket channel</source>
          <target state="translated">새로운 비동기 소켓 채널</target>
        </trans-unit>
        <trans-unit id="25ee34a403c6700c546a4108cc328ae600591c3e" translate="yes" xml:space="preserve">
          <source>A new certificate handling package is created in the Java platform.</source>
          <target state="translated">Java 플랫폼에서 새 인증서 처리 패키지가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="718f2b8bbf1587dde6bb38de3b6d608243e6dea2" translate="yes" xml:space="preserve">
          <source>A new certificate handling package is created in the Java platform. This Certificate interface is entirely deprecated and is here to allow for a smooth transition to the new package.</source>
          <target state="translated">Java 플랫폼에서 새 인증서 처리 패키지가 작성됩니다. 이 인증서 인터페이스는 완전히 사용되지 않으며 새 패키지로 원활하게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ac536ddec39c76615631278c13e054fe68ed0b" translate="yes" xml:space="preserve">
          <source>A new char buffer</source>
          <target state="translated">새로운 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="01d9b805add68dab9a76c40af460390f4da7fb91" translate="yes" xml:space="preserve">
          <source>A new client connection has been opened.</source>
          <target state="translated">새로운 클라이언트 연결이 열렸습니다.</target>
        </trans-unit>
        <trans-unit id="827e2087bb76a0b88fc51994d48a3006017e8bae" translate="yes" xml:space="preserve">
          <source>A new collation rules string can be created by concatenating rules strings. For example, the rules returned by &lt;a href=&quot;rulebasedcollator#getRules--&quot;&gt;&lt;code&gt;getRules()&lt;/code&gt;&lt;/a&gt; could be concatenated to combine multiple &lt;code&gt;RuleBasedCollator&lt;/code&gt;s.</source>
          <target state="translated">규칙 문자열을 연결하여 새로운 데이터 정렬 규칙 문자열을 만들 수 있습니다. 예를 들어, &lt;a href=&quot;rulebasedcollator#getRules--&quot;&gt; &lt;code&gt;getRules()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 규칙 은 여러 &lt;code&gt;RuleBasedCollator&lt;/code&gt; 를 결합하도록 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c8e2bfcf83550d90a8829fb36311408b5e67747" translate="yes" xml:space="preserve">
          <source>A new datagram channel</source>
          <target state="translated">새로운 데이터 그램 채널</target>
        </trans-unit>
        <trans-unit id="e0b8ebf717a254cbd0e710cad36b3aa7cf6b47c8" translate="yes" xml:space="preserve">
          <source>A new decoder for this charset</source>
          <target state="translated">이 캐릭터 세트의 새로운 디코더</target>
        </trans-unit>
        <trans-unit id="a58078311df4687b197e1dcc8ca8cfde78caada0" translate="yes" xml:space="preserve">
          <source>A new double buffer</source>
          <target state="translated">새로운 더블 버퍼</target>
        </trans-unit>
        <trans-unit id="c7e6b0b71de9de9ede7aea10272874373ea2cfbf" translate="yes" xml:space="preserve">
          <source>A new encoder for this charset</source>
          <target state="translated">이 문자셋을위한 새로운 인코더</target>
        </trans-unit>
        <trans-unit id="7a12be5620980a642f2d62bb55b1169fe7d2f9c0" translate="yes" xml:space="preserve">
          <source>A new file channel</source>
          <target state="translated">새로운 파일 채널</target>
        </trans-unit>
        <trans-unit id="7a03fc9b6fe7f9f50a8b588d5c2839f795d5cfa3" translate="yes" xml:space="preserve">
          <source>A new file system</source>
          <target state="translated">새로운 파일 시스템</target>
        </trans-unit>
        <trans-unit id="2c72f7dbc539aca73a65ca87d61f96c62f44ab73" translate="yes" xml:space="preserve">
          <source>A new float buffer</source>
          <target state="translated">새로운 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="07e3279021ba77f5ae5155347ef02546bd534253" translate="yes" xml:space="preserve">
          <source>A new input stream</source>
          <target state="translated">새로운 입력 스트림</target>
        </trans-unit>
        <trans-unit id="c28559dd6b37c82370a2d6d36b273e27af024dea" translate="yes" xml:space="preserve">
          <source>A new instance of &lt;a href=&quot;urlconnection&quot;&gt;URLConnection&lt;/a&gt; is created every time when invoking the &lt;a href=&quot;urlstreamhandler#openConnection-java.net.URL-&quot;&gt;URLStreamHandler.openConnection(URL)&lt;/a&gt; method of the protocol handler for this URL.</source>
          <target state="translated">이 URL에 대한 프로토콜 핸들러 의 &lt;a href=&quot;urlstreamhandler#openConnection-java.net.URL-&quot;&gt;URLStreamHandler.openConnection (URL)&lt;/a&gt; 메소드를 호출 할 때마다 &lt;a href=&quot;urlconnection&quot;&gt;URLConnection&lt;/a&gt; 의 새 인스턴스 가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="70dd79cc189d68c5b9c4748ef1fbf76c508ca55d" translate="yes" xml:space="preserve">
          <source>A new int buffer</source>
          <target state="translated">새로운 int 버퍼</target>
        </trans-unit>
        <trans-unit id="4cab229378aefd95620182bd2e26e42daed2a585" translate="yes" xml:space="preserve">
          <source>A new key representing the registration of the given channel with this selector</source>
          <target state="translated">이 선택기로 주어진 채널의 등록을 나타내는 새로운 키</target>
        </trans-unit>
        <trans-unit id="eb82ef1bb373c9a76bbed75b19d1396c6c0475f9" translate="yes" xml:space="preserve">
          <source>A new long buffer</source>
          <target state="translated">새로운 긴 버퍼</target>
        </trans-unit>
        <trans-unit id="2378edf28d0f7cd090a51aaa3253aba996f08c6c" translate="yes" xml:space="preserve">
          <source>A new matcher for this pattern</source>
          <target state="translated">이 패턴에 대한 새로운 매처</target>
        </trans-unit>
        <trans-unit id="370091f3315fb7e9620cc6ef2c7174e7f8b439d4" translate="yes" xml:space="preserve">
          <source>A new output stream</source>
          <target state="translated">새로운 출력 스트림</target>
        </trans-unit>
        <trans-unit id="fc00dcf9a6f1431f2f4900621a30444a41c3f824" translate="yes" xml:space="preserve">
          <source>A new pipe</source>
          <target state="translated">새로운 파이프</target>
        </trans-unit>
        <trans-unit id="195dbfc34817c71b0ac77609e1a68b8637c20709" translate="yes" xml:space="preserve">
          <source>A new private implementation of an MBeanServer.</source>
          <target state="translated">MBeanServer의 새로운 개인 구현</target>
        </trans-unit>
        <trans-unit id="c1bba2ce8a1736ca41dee666c238188a8f3968a5" translate="yes" xml:space="preserve">
          <source>A new readable byte channel</source>
          <target state="translated">읽을 수있는 새로운 바이트 채널</target>
        </trans-unit>
        <trans-unit id="227964ba0cdb00d556590c57b5b512186bc50f84" translate="yes" xml:space="preserve">
          <source>A new reader</source>
          <target state="translated">새로운 독자</target>
        </trans-unit>
        <trans-unit id="a987f16a3add20d096c2dc2279a462557da4b375" translate="yes" xml:space="preserve">
          <source>A new selector</source>
          <target state="translated">새로운 선택기</target>
        </trans-unit>
        <trans-unit id="f414cd40bc587b5cb076112120f1a32f7542e237" translate="yes" xml:space="preserve">
          <source>A new sequential &lt;code&gt;IntStream&lt;/code&gt;</source>
          <target state="translated">새로운 순차 &lt;code&gt;IntStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53d0dbb2fa07c0c02c96d61beb2e8a31523487e" translate="yes" xml:space="preserve">
          <source>A new service is available from the nesting BeanContext. Subclasses may override this method in order to implement their own behaviors</source>
          <target state="translated">중첩 BeanContext에서 새 서비스를 사용할 수 있습니다. 자체 클래스를 구현하기 위해 서브 클래스가이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc5510b8ee23c196414d7a41911a0b2d8c8655c7" translate="yes" xml:space="preserve">
          <source>A new service loader</source>
          <target state="translated">새로운 서비스 로더</target>
        </trans-unit>
        <trans-unit id="7a598ad4eff5223742f9071b01244341dbae324b" translate="yes" xml:space="preserve">
          <source>A new short buffer</source>
          <target state="translated">새로운 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="92e48cdd5d234dfa3d6e9af022c9d12a72a40f16" translate="yes" xml:space="preserve">
          <source>A new socket channel</source>
          <target state="translated">새로운 소켓 채널</target>
        </trans-unit>
        <trans-unit id="ad8acabd40cadf9e1fc83439d4cacc467728413a" translate="yes" xml:space="preserve">
          <source>A new volatile variable &lt;code&gt;V&lt;/code&gt; is created, and written by the current thread. As defined by the JMM, this write is a global synchronization event.</source>
          <target state="translated">새로운 휘발성 변수 &lt;code&gt;V&lt;/code&gt; 가 생성되어 현재 스레드에 의해 작성됩니다. JMM에서 정의한대로이 쓰기는 글로벌 동기화 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="fae76c304ef49fc476ffd8e6ab0bb7e6f610c034" translate="yes" xml:space="preserve">
          <source>A new writable byte channel</source>
          <target state="translated">새로운 쓰기 가능한 바이트 채널</target>
        </trans-unit>
        <trans-unit id="f9a4767fbb8f8aed5b2928cb74b7c92f9ba2c665" translate="yes" xml:space="preserve">
          <source>A new writer</source>
          <target state="translated">새로운 작가</target>
        </trans-unit>
        <trans-unit id="96a14b87d6769803187b54bde0e78433cf67339d" translate="yes" xml:space="preserve">
          <source>A new, and connected, socket channel</source>
          <target state="translated">새로운 연결 소켓 채널</target>
        </trans-unit>
        <trans-unit id="2595cfcee208226807eae38461417b358c37d2c5" translate="yes" xml:space="preserve">
          <source>A newLine() method is provided, which uses the platform's own notion of line separator as defined by the system property &lt;code&gt;line.separator&lt;/code&gt;. Not all platforms use the newline character ('\n') to terminate lines. Calling this method to terminate each output line is therefore preferred to writing a newline character directly.</source>
          <target state="translated">시스템 특성 &lt;code&gt;line.separator&lt;/code&gt; 에 의해 정의 된대로 플랫폼 자체의 선 구분 기호 개념을 사용하는 newLine () 메소드가 제공됩니다 . 모든 플랫폼이 개행 문자 ( '\ n')를 사용하여 행을 종료하는 것은 아닙니다. 따라서이 메소드를 호출하여 각 출력 행을 종료하는 것이 개행 문자를 직접 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d618578a9393e1dd96591434db2110ed0c362143" translate="yes" xml:space="preserve">
          <source>A newline (line feed) character (&lt;code&gt;'\n'&lt;/code&gt;),</source>
          <target state="translated">줄 바꿈 (줄 바꿈) 문자 ( &lt;code&gt;'\n'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8b5f06c0531c3ba4c791f46b68dc5d8317f9ec88" translate="yes" xml:space="preserve">
          <source>A newline character (the character '\n' in Java) is replaced by a backslash followed by the character '\n'.</source>
          <target state="translated">줄 바꿈 문자 (Java에서 문자 '\ n')는 백 슬래시와 문자 '\ n'으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ad7e79fbc80b15ff80930a2bd90a4d857f0a8809" translate="yes" xml:space="preserve">
          <source>A newly allocated Packer engine.</source>
          <target state="translated">새로 할당 된 Packer 엔진.</target>
        </trans-unit>
        <trans-unit id="ae89a8172fee4e06f55daa88ca36ec1e21275ab3" translate="yes" xml:space="preserve">
          <source>A newly allocated Unpacker engine.</source>
          <target state="translated">새로 할당 된 Unpacker 엔진.</target>
        </trans-unit>
        <trans-unit id="f749a2698aa7b3fe7595ce4fe494aefb6961a78f" translate="yes" xml:space="preserve">
          <source>A newly-allocated byte array containing the decoded bytes.</source>
          <target state="translated">디코딩 된 바이트를 포함하는 새로 할당 된 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="4500d02e284d7deca5c46a49dd59c877a9687edf" translate="yes" xml:space="preserve">
          <source>A newly-allocated byte array containing the resulting encoded bytes.</source>
          <target state="translated">결과 인코딩 된 바이트를 포함하는 새로 할당 된 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ad405c747b824e9ef58d7c88b72e9eb7cc3efb65" translate="yes" xml:space="preserve">
          <source>A newly-allocated byte buffer containing the decoded bytes</source>
          <target state="translated">디코딩 된 바이트를 포함하는 새로 할당 된 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="91f70710f376acb4f8c9553c4de7e523904b6303" translate="yes" xml:space="preserve">
          <source>A newly-allocated byte buffer containing the encoded bytes.</source>
          <target state="translated">인코딩 된 바이트를 포함하는 새로 할당 된 바이트 버퍼.</target>
        </trans-unit>
        <trans-unit id="8c318ea698e58c2b2e4ebdafd737b67d00e3f939" translate="yes" xml:space="preserve">
          <source>A newly-allocated byte buffer containing the result of the encoding operation. The buffer's position will be zero and its limit will follow the last byte written.</source>
          <target state="translated">인코딩 작업의 결과를 포함하는 새로 할당 된 바이트 버퍼입니다. 버퍼의 위치는 0이되고 한계는 마지막으로 쓴 바이트를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e1af1e5437c51808c4a8a1190c196a71f76d20e4" translate="yes" xml:space="preserve">
          <source>A newly-allocated character buffer containing the result of the decoding operation. The buffer's position will be zero and its limit will follow the last character written.</source>
          <target state="translated">디코딩 작업의 결과를 포함하는 새로 할당 된 문자 버퍼. 버퍼의 위치는 0이되고 한계는 마지막으로 쓴 문자를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="14848075c6a2bf1c1cd5881b071a496387811f42" translate="yes" xml:space="preserve">
          <source>A newly-created buffer always has a position of zero and a mark that is undefined. The initial limit may be zero, or it may be some other value that depends upon the type of the buffer and the manner in which it is constructed. Each element of a newly-allocated buffer is initialized to zero.</source>
          <target state="translated">새로 작성된 버퍼는 항상 0의 위치와 정의되지 않은 표시를 갖습니다. 초기 한계는 0 일 수 있거나, 버퍼의 유형 및 그것이 구성되는 방식에 의존하는 다른 값일 수있다. 새로 할당 된 버퍼의 각 요소는 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="12e02aa878755e8bc2b352a4b4027c3700104164" translate="yes" xml:space="preserve">
          <source>A newly-created channel is connected by invoking its &lt;a href=&quot;asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method; once connected, a channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its &lt;a href=&quot;asynchronoussocketchannel#getRemoteAddress--&quot;&gt;&lt;code&gt;getRemoteAddress&lt;/code&gt;&lt;/a&gt; method. An attempt to invoke an I/O operation upon an unconnected channel will cause a &lt;a href=&quot;notyetconnectedexception&quot;&gt;&lt;code&gt;NotYetConnectedException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">새로 작성된 채널은 &lt;a href=&quot;asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 방법 을 호출하여 연결 됩니다. 연결되면 채널은 닫힐 때까지 연결된 상태로 유지됩니다. 소켓 채널의 연결 여부는 &lt;a href=&quot;asynchronoussocketchannel#getRemoteAddress--&quot;&gt; &lt;code&gt;getRemoteAddress&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 . 연결되지 않은 채널에서 I / O 작업을 호출하려고하면 &lt;a href=&quot;notyetconnectedexception&quot;&gt; &lt;code&gt;NotYetConnectedException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3937dfeb6f50d8b3801a4e97455d079ce3003278" translate="yes" xml:space="preserve">
          <source>A newly-created connector server is &lt;em&gt;inactive&lt;/em&gt;, and does not yet listen for connections. Only when its &lt;a href=&quot;jmxconnectorservermbean#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method has been called does it start listening for connections.</source>
          <target state="translated">새로 작성된 커넥터 서버가 &lt;em&gt;비활성 상태&lt;/em&gt; 이며 아직 연결을 청취하지 않습니다. &lt;a href=&quot;jmxconnectorservermbean#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 경우에만 연결 청취를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9320a55b7ef50489ba9462b8018314f21d3b82a1" translate="yes" xml:space="preserve">
          <source>A newly-created object of this type is unconnected. Its &lt;a href=&quot;jmxconnector#connect--&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method must be called before it can be used. However, objects created by &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect&lt;/code&gt;&lt;/a&gt; are already connected.</source>
          <target state="translated">이 유형의 새로 작성된 오브젝트는 연결되어 있지 않습니다. 그것의 &lt;a href=&quot;jmxconnector#connect--&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 사용하기 전에 메서드를 호출 할 필요가 있습니다. 그러나 &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect&lt;/code&gt; &lt;/a&gt; 에 의해 작성된 오브젝트 는 이미 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d920ab1e496d0ab22784661132c5d8cba8bb07a7" translate="yes" xml:space="preserve">
          <source>A next-line character (&lt;code&gt;'\u0085'&lt;/code&gt;),</source>
          <target state="translated">다음 줄 문자 ( &lt;code&gt;'\u0085'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3ad327a430dd79283b9f13832e1f8c1e8b07e851" translate="yes" xml:space="preserve">
          <source>A nexus for I/O operations</source>
          <target state="translated">I / O 작업을위한 넥서스</target>
        </trans-unit>
        <trans-unit id="30b96666137ff956b13f29c122ff2067f45da9e4" translate="yes" xml:space="preserve">
          <source>A nexus for I/O operations.</source>
          <target state="translated">I / O 작업을위한 연결.</target>
        </trans-unit>
        <trans-unit id="32d94d48baeb48749abc6e461ec1568849d96888" translate="yes" xml:space="preserve">
          <source>A node</source>
          <target state="translated">노드</target>
        </trans-unit>
        <trans-unit id="6d1ab6e4231c9fd824e59dacc81a7b8495e33cd8" translate="yes" xml:space="preserve">
          <source>A node in a hierarchical collection of preference data.</source>
          <target state="translated">기본 설정 데이터의 계층 적 콜렉션에있는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="0d390cb60da6e421d230a106d5ce284bbd479bfd" translate="yes" xml:space="preserve">
          <source>A node in a hierarchical collection of preference data. This class allows applications to store and retrieve user and system preference and configuration data. This data is stored persistently in an implementation-dependent backing store. Typical implementations include flat files, OS-specific registries, directory servers and SQL databases. The user of this class needn't be concerned with details of the backing store.</source>
          <target state="translated">기본 설정 데이터의 계층 적 콜렉션에있는 노드입니다. 이 클래스를 통해 응용 프로그램은 사용자 및 시스템 환경 설정 및 구성 데이터를 저장하고 검색 할 수 있습니다. 이 데이터는 구현 종속 백업 저장소에 지속적으로 저장됩니다. 일반적인 구현에는 플랫 파일, OS 특정 레지스트리, 디렉토리 서버 및 SQL 데이터베이스가 포함됩니다. 이 클래스의 사용자는 백업 저장소의 세부 사항에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="34276e6cf55ed986512c9b4e3783654205d06d95" translate="yes" xml:space="preserve">
          <source>A non-ASCII character c for which &lt;a href=&quot;../lang/character#isDigit-char-&quot;&gt;&lt;code&gt;Character.isDigit&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(c)&lt;/code&gt; returns true</source>
          <target state="translated">&lt;a href=&quot;../lang/character#isDigit-char-&quot;&gt; &lt;code&gt;Character.isDigit&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(c)&lt;/code&gt; 가 true를 리턴 하는 비 ASCII 문자 c</target>
        </trans-unit>
        <trans-unit id="49951378a32d6d7aa2f164737d4577800b20cbd4" translate="yes" xml:space="preserve">
          <source>A non-blocking connection operation is initiated by placing a socket channel in non-blocking mode and then invoking its &lt;a href=&quot;socketchannel#connect-java.net.SocketAddress-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method. Once the connection is established, or the attempt has failed, the socket channel will become connectable and this method may be invoked to complete the connection sequence. If the connection operation failed then invoking this method will cause an appropriate &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">비 차단 연결 작업은 소켓 채널을 비 차단 모드로 설정 한 다음 &lt;a href=&quot;socketchannel#connect-java.net.SocketAddress-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 방법 을 호출하여 시작 됩니다 . 연결이 설정되거나 시도가 실패하면 소켓 채널이 연결 가능해지며 연결 순서를 완료하기 위해이 메소드가 호출 될 수 있습니다. 연결 조작이 실패한 경우이 메소드를 호출하면 적절한 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc767860690d8c24cb88c960e15a4973d9558857" translate="yes" xml:space="preserve">
          <source>A non-constant call site may be &lt;em&gt;relinked&lt;/em&gt; by changing its target. The new target must have the same &lt;a href=&quot;methodhandle#type--&quot;&gt;type&lt;/a&gt; as the previous target. Thus, though a call site can be relinked to a series of successive targets, it cannot change its type.</source>
          <target state="translated">일정하지 않은 통화 사이트는 대상을 변경하여 &lt;em&gt;다시 연결할&lt;/em&gt; 수 있습니다 . 새 대상은 이전 대상 과 동일한 &lt;a href=&quot;methodhandle#type--&quot;&gt;유형&lt;/a&gt; 이어야합니다 . 따라서 콜 사이트를 일련의 연속 대상으로 다시 연결할 수 있지만 유형을 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac6825da8adbf85d254ecf0727fccd99ee289ca9" translate="yes" xml:space="preserve">
          <source>A non-digit: &lt;code&gt;[^0-9]&lt;/code&gt;</source>
          <target state="translated">숫자가 아닌 숫자 : &lt;code&gt;[^0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41ae39581d83b8afbf8fbfd5ce8d03c1bf3a0325" translate="yes" xml:space="preserve">
          <source>A non-digit: &lt;code&gt;[^\d]&lt;/code&gt;</source>
          <target state="translated">숫자가 아닌 숫자 : &lt;code&gt;[^\d]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eabbd7a5ea7b535624280794aea261db5d7739a3" translate="yes" xml:space="preserve">
          <source>A non-escaped begin-quote which precedes a component must be matched by a non-escaped end-quote at the end of the component. A component thus quoted is referred to as a &lt;em&gt;quoted component&lt;/em&gt;. It is parsed by removing the being- and end- quotes, and by treating the intervening characters as ordinary characters unless one of the rules involving quoted components listed below applies.</source>
          <target state="translated">구성 요소 앞에 나오는 이스케이프되지 않은 시작 인용 부호는 구성 요소 끝에있는 이스케이프 처리되지 않은 끝 인용 부호와 일치해야합니다. 따라서, 인용 된 구성 요소는라고 &lt;em&gt;인용 성분&lt;/em&gt; . 아래 인용 된 구성 요소와 관련된 규칙 중 하나가 적용되지 않는 한, 존재하는 인용 부호와 종료 인용 부호를 제거하고 중간 문자를 일반 문자로 취급하여 구문 분석합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
