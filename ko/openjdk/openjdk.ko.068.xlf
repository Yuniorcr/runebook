<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="a52b588e8161963b7e18fcda42fa7ec362e0a098" translate="yes" xml:space="preserve">
          <source>The current buffer position.</source>
          <target state="translated">현재 버퍼 위치</target>
        </trans-unit>
        <trans-unit id="63e50ac838b3848cc91de53941e6dcec2e9f8b7f" translate="yes" xml:space="preserve">
          <source>The current byte order setting is ignored.</source>
          <target state="translated">현재 바이트 순서 설정은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="12dd3caf907559af5dbbbed0c023c0d9054ec8bf" translate="yes" xml:space="preserve">
          <source>The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching in the &lt;code&gt;ImageInputStream&lt;/code&gt; that is created.</source>
          <target state="translated">&lt;code&gt;getUseCache&lt;/code&gt; 및 &lt;code&gt;getCacheDirectory&lt;/code&gt; 의 현재 캐시 설정 은 작성된 &lt;code&gt;ImageInputStream&lt;/code&gt; 의 캐싱을 제어하는 ​​데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="92e771a6c7da10585ddeb438ab541e0b3a851ef9" translate="yes" xml:space="preserve">
          <source>The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching.</source>
          <target state="translated">&lt;code&gt;getUseCache&lt;/code&gt; 및 &lt;code&gt;getCacheDirectory&lt;/code&gt; 의 현재 캐시 설정은 캐싱을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff6ca30c84f040773ec8774963807e0a8e8d43eb" translate="yes" xml:space="preserve">
          <source>The current destination &lt;code&gt;BufferedImage&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if none has been set. By default, the value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">현재 대상 &lt;code&gt;BufferedImage&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 아무것도 설정되어 있지 않은 경우. 기본적으로 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8b92d6a2986b52e6629a746b55b0a9cddbea4b1" translate="yes" xml:space="preserve">
          <source>The current directory used by the library loader.</source>
          <target state="translated">라이브러리 로더가 사용하는 현재 디렉토리.</target>
        </trans-unit>
        <trans-unit id="73727ebdabca1a91204ed31d331e5ef77030a4a0" translate="yes" xml:space="preserve">
          <source>The current era, which is the only accepted value, has the value 1</source>
          <target state="translated">유일하게 허용되는 값인 현재 시대의 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="26717e43208f4640d19e6b5f6728d4a14a1505eb" translate="yes" xml:space="preserve">
          <source>The current hash code of this buffer</source>
          <target state="translated">이 버퍼의 현재 해시 코드</target>
        </trans-unit>
        <trans-unit id="b0b0b2d452f6407d3565f329540e6cccfca94297" translate="yes" xml:space="preserve">
          <source>The current line number</source>
          <target state="translated">현재 줄 번호</target>
        </trans-unit>
        <trans-unit id="b28b91e59d7ae0762d443355c9917cff3adbc619" translate="yes" xml:space="preserve">
          <source>The current locale of this BeanContext.</source>
          <target state="translated">이 BeanContext의 현재 로케일</target>
        </trans-unit>
        <trans-unit id="b08f612d5c5c523da7676da4b4cce78624b9e4e6" translate="yes" xml:space="preserve">
          <source>The current malformed-input action, which is never &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">현재의 부정 입력 입력 액션. &lt;code&gt;null&lt;/code&gt; 는 아니다</target>
        </trans-unit>
        <trans-unit id="e5ad146812d579b16f33f69cf1e04cbb0531d75a" translate="yes" xml:space="preserve">
          <source>The current position in the buffer. This is the index of the next character to be read from the &lt;code&gt;buf&lt;/code&gt; array.</source>
          <target state="translated">버퍼의 현재 위치 이것은 &lt;code&gt;buf&lt;/code&gt; 배열 에서 읽을 다음 문자의 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="4f0b5f02342bf7d81232d1242170194474834edf" translate="yes" xml:space="preserve">
          <source>The current position in this stream, in sample frames (zero-based).</source>
          <target state="translated">샘플 프레임에서이 스트림의 현재 위치입니다 (0부터 시작).</target>
        </trans-unit>
        <trans-unit id="cd07329f3f1e3728051b83bc09960471c2e49eb2" translate="yes" xml:space="preserve">
          <source>The current read position within the stream. Subclasses are responsible for keeping this value current from any method they override that alters the read position.</source>
          <target state="translated">스트림 내의 현재 읽기 위치 서브 클래스는 읽기 위치를 변경하는 모든 메소드에서이 값을 최신 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="dbb2a76e76608609682c9f165bc8e263dc315e1a" translate="yes" xml:space="preserve">
          <source>The current security manager is set by the &lt;code&gt;setSecurityManager&lt;/code&gt; method in class &lt;code&gt;System&lt;/code&gt;. The current security manager is obtained by the &lt;code&gt;getSecurityManager&lt;/code&gt; method.</source>
          <target state="translated">현재 보안 관리자는 &lt;code&gt;System&lt;/code&gt; 클래스 의 &lt;code&gt;setSecurityManager&lt;/code&gt; 메소드로 설정됩니다 . 현재 보안 관리자는 &lt;code&gt;getSecurityManager&lt;/code&gt; 메소드에 의해 확보됩니다 .</target>
        </trans-unit>
        <trans-unit id="74f480c6ae193e5a9d3b709b2c2a7c453d4dfc2d" translate="yes" xml:space="preserve">
          <source>The current set of system properties for use by the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; method is returned as a &lt;code&gt;Properties&lt;/code&gt; object. If there is no current set of system properties, a set of system properties is first created and initialized. This set of system properties always includes values for the following keys:</source>
          <target state="translated">&lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt; 메소드가 사용하는 현재 시스템 특성 세트가 &lt;code&gt;Properties&lt;/code&gt; 오브젝트 로 리턴됩니다 . 현재 시스템 특성 세트가없는 경우 시스템 특성 세트가 먼저 작성되고 초기화됩니다. 이 시스템 특성 세트에는 항상 다음 키의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="79a720cf83d499f6e0973994d3499581df2c23c7" translate="yes" xml:space="preserve">
          <source>The current size of this channel's file, measured in bytes</source>
          <target state="translated">이 채널 파일의 현재 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="7343e97e3c7e753dcd01486a1d5489595ced50fc" translate="yes" xml:space="preserve">
          <source>The current size, measured in bytes</source>
          <target state="translated">바이트 단위로 측정 된 현재 크기</target>
        </trans-unit>
        <trans-unit id="0f29d38f501c28836502c9b60c42dbfd6c16e02e" translate="yes" xml:space="preserve">
          <source>The current thread is assumed to hold the lock associated with this &lt;code&gt;Condition&lt;/code&gt; when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt;) and the implementation must document that fact.</source>
          <target state="translated">현재 스레드는 이 메소드가 호출 될 때이 &lt;code&gt;Condition&lt;/code&gt; 과 연관된 잠금을 보유한다고 가정합니다 . 이 경우에 해당하는지 여부와 그렇지 않은 경우 응답 방법을 결정하는 것은 구현에 달려 있습니다. 일반적으로 예외 (예 : &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; ) 가 발생 하며 구현시 해당 사실을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fbef1cf24d964f6ca313f95f4fe01571dff952a" translate="yes" xml:space="preserve">
          <source>The current thread must own this object's monitor.</source>
          <target state="translated">현재 스레드는이 객체의 모니터를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb005abf75b48dfbf8bfb52c0de3735aa29c85f2" translate="yes" xml:space="preserve">
          <source>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the &lt;code&gt;notify&lt;/code&gt; method or the &lt;code&gt;notifyAll&lt;/code&gt; method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</source>
          <target state="translated">현재 스레드는이 객체의 모니터를 소유해야합니다. 스레드는이 모니터의 소유권을 해제하고 다른 스레드가이 객체의 모니터에서 대기중인 스레드가 &lt;code&gt;notify&lt;/code&gt; 메소드 또는 &lt;code&gt;notifyAll&lt;/code&gt; 메소드에 대한 호출을 통해 깨어날 때까지 알릴 때까지 기다립니다 . 그런 다음 스레드는 모니터 소유권을 다시 얻을 수있을 때까지 기다렸다가 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="074bc81cd00e30024a40cff7dc9639a832494853" translate="yes" xml:space="preserve">
          <source>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until either of the following two conditions has occurred:</source>
          <target state="translated">현재 스레드는이 객체의 모니터를 소유해야합니다. 스레드는이 모니터의 소유권을 해제하고 다음 두 조건 중 하나가 발생할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="7d7de3eb289e620ce7d37cc5459f23d8d68c0732" translate="yes" xml:space="preserve">
          <source>The current threshold of every object in the set of observed MBeans is updated consequently.</source>
          <target state="translated">관찰 된 MBean 세트에있는 모든 오브젝트의 현재 임계 값이 결과적으로 갱신됩니다.</target>
        </trans-unit>
        <trans-unit id="035b0994516ff38617336fc9d2cad5f9f8cf8008" translate="yes" xml:space="preserve">
          <source>The current token is a word when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_WORD&lt;/code&gt;. The current token is a quoted string token when the value of the &lt;code&gt;ttype&lt;/code&gt; field is a quote character.</source>
          <target state="translated">&lt;code&gt;ttype&lt;/code&gt; 필드 의 값 이 &lt;code&gt;TT_WORD&lt;/code&gt; 인 경우 현재 토큰은 단어 입니다. &lt;code&gt;ttype&lt;/code&gt; 필드 의 값이 인용 문자 인 경우 현재 토큰은 인용 문자열 토큰 입니다.</target>
        </trans-unit>
        <trans-unit id="9279d01dc19f7a0342350a1d9adf8f833fd5ece2" translate="yes" xml:space="preserve">
          <source>The current unmappable-character action, which is never &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">현재 매핑 할 수없는 문자 작업으로, &lt;code&gt;null&lt;/code&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b28d72a296f5ec1bac25b851e0e08dad5342265a" translate="yes" xml:space="preserve">
          <source>The currently marked position in the stream. ByteArrayInputStream objects are marked at position zero by default when constructed. They may be marked at another position within the buffer by the &lt;code&gt;mark()&lt;/code&gt; method. The current buffer position is set to this point by the &lt;code&gt;reset()&lt;/code&gt; method.</source>
          <target state="translated">스트림에서 현재 표시된 위치입니다. ByteArrayInputStream 객체는 생성시 기본적으로 위치 0에 표시됩니다. 그것들은 &lt;code&gt;mark()&lt;/code&gt; 메소드에 의해 버퍼 내의 다른 위치에 표시 될 수 있습니다 . 현재 버퍼 위치는 &lt;code&gt;reset()&lt;/code&gt; 메소드에 의해이 지점으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ac7b43047b38b0ded9bac0773edbdff61065cab" translate="yes" xml:space="preserve">
          <source>The currently set time for this calendar, expressed in milliseconds after January 1, 1970, 0:00:00 GMT.</source>
          <target state="translated">이 달력에 현재 설정된 시간으로 1970 년 1 월 1 일 0:00:00 GMT 이후 밀리 초로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3c07ff5671cb5699eada17ac47b9280751bc33" translate="yes" xml:space="preserve">
          <source>The customization is performed after modification using the IANA Language Subtag Registry.</source>
          <target state="translated">사용자 정의는 IANA 언어 서브 태그 레지스트리를 사용하여 수정 한 후에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="08979f718f326c5f8394531a530cb7e583213f81" translate="yes" xml:space="preserve">
          <source>The dash character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;, &lt;small&gt;HYPHEN-MINUS&lt;/small&gt;),</source>
          <target state="translated">대시 문자 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; , &lt;small&gt;HYPHEN-MINUS&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="1dec4275df36c1854d79822ee5f08702fa14c2fd" translate="yes" xml:space="preserve">
          <source>The datagram is transferred from the byte buffer as if by a regular &lt;a href=&quot;writablebytechannel#write-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; operation.</source>
          <target state="translated">데이터 그램은 마치 일반 &lt;a href=&quot;writablebytechannel#write-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 작업에 의한 것처럼 바이트 버퍼에서 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="aff3539ad7288dc64dc12b9b5b5e51225eb5c928" translate="yes" xml:space="preserve">
          <source>The datagram is transferred into the given byte buffer starting at its current position, as if by a regular &lt;a href=&quot;readablebytechannel#read-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; operation. If there are fewer bytes remaining in the buffer than are required to hold the datagram then the remainder of the datagram is silently discarded.</source>
          <target state="translated">데이터 그램은 마치 일반 &lt;a href=&quot;readablebytechannel#read-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 작업 에서처럼 현재 위치에서 시작하여 지정된 바이트 버퍼로 전송됩니다 . 버퍼에 남아있는 바이트 수가 데이터 그램을 유지하는 데 필요한 것보다 적은 경우 나머지 데이터 그램은 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="24d582cad53c25bb1fd76ac3a0fa2a82ea7fdc17" translate="yes" xml:space="preserve">
          <source>The datagram's source address, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no datagram was immediately available</source>
          <target state="translated">데이터 그램의 소스 주소. 이 채널이 비 블로킹 모드에 있고 데이터 그램을 즉시 사용할 수없는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c77e6f71adf1b1e1f486b87e6228fc384160bf79" translate="yes" xml:space="preserve">
          <source>The date and offset do not affect the calculation and will be the same in the result.</source>
          <target state="translated">날짜와 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76281265656763ab45ee0c7d36b85aa33eaf99ac" translate="yes" xml:space="preserve">
          <source>The date component of the instant is dropped during the conversion. This means that the conversion can never fail due to the instant being out of the valid range of dates.</source>
          <target state="translated">전환하는 동안 인스턴트의 날짜 구성 요소가 삭제됩니다. 즉, 유효한 날짜 범위를 벗어난 순간으로 인해 변환에 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d6977e22aea69347ff602053e3d840347dc8f4e" translate="yes" xml:space="preserve">
          <source>The date is expressed using three fields:</source>
          <target state="translated">날짜는 세 가지 필드를 사용하여 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="74de0d1e3d82e3986ec00f2b62db03b96d85c46e" translate="yes" xml:space="preserve">
          <source>The date or time format strings are not part of the definition of a calendar, as those must be modifiable or overridable by the user at runtime. Use &lt;a href=&quot;../text/dateformat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; to format dates.</source>
          <target state="translated">날짜 또는 시간 형식 문자열은 런타임에 사용자가 수정하거나 무시할 수 있어야하므로 달력 정의의 일부가 아닙니다. &lt;a href=&quot;../text/dateformat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 을 사용 하여 날짜를 형식화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6341cf516a426c257f29c6363980da19fa50fc5e" translate="yes" xml:space="preserve">
          <source>The day-of-month must be valid for the month within a leap year. Hence, for February, day 29 is valid.</source>
          <target state="translated">윤년 내에 해당 월의 날짜가 유효해야합니다. 따라서 2 월에는 29 일이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e236b7cdb2321ccc4dc1f333c4d5a4d610923567" translate="yes" xml:space="preserve">
          <source>The day-of-month must be valid for the month within a leap year. Hence, for month 2 (February), day 29 is valid.</source>
          <target state="translated">윤년 내에 해당 월의 날짜가 유효해야합니다. 따라서 2 월 (2 월)의 경우 29 일이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a4a0bf6cb6cb52da7a88d253064f19d6bbaab527" translate="yes" xml:space="preserve">
          <source>The day-of-month value must be valid for the year-month.</source>
          <target state="translated">월 값은 해당 월에 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="d921c6edafb2d37d1c786f95679e37c443203e53" translate="yes" xml:space="preserve">
          <source>The day-of-month.</source>
          <target state="translated">월요일.</target>
        </trans-unit>
        <trans-unit id="27a0a133085f381089155fd312fed76aa39ecb97" translate="yes" xml:space="preserve">
          <source>The day-of-quarter can only be calculated if the day-of-year, month-of-year and year are available.</source>
          <target state="translated">분기는 연도, 월 및 연도를 사용할 수있는 경우에만 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd639b3194b43c8fa09d1e20c2ddaece739d19dd" translate="yes" xml:space="preserve">
          <source>The day-of-week, such as Tuesday.</source>
          <target state="translated">화요일과 같은 요일.</target>
        </trans-unit>
        <trans-unit id="ee88394025012e606d83fcbd6088ac260748de1b" translate="yes" xml:space="preserve">
          <source>The day-of-year in this factory is expressed relative to the start of the proleptic year. The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system. They are not reset when the era changes.</source>
          <target state="translated">이 공장의 일 년은 proleptic 연도의 시작과 관련하여 표현됩니다. 일본의 proleptic 연도 및 일자는 ISO 캘린더 시스템과 동일합니다. 시대가 바뀌더라도 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c38cedc9fdfbe3ac0677cb0cf2faf0a0f17b9ef4" translate="yes" xml:space="preserve">
          <source>The day-of-year in this factory is expressed relative to the start of the year-of-era. This definition changes the normal meaning of day-of-year only in those years where the year-of-era is reset to one due to a change in the era. For example:</source>
          <target state="translated">이 공장의 연도는 연도의 시작과 관련하여 표현됩니다. 이 정의는 시대의 변화로 인해 연도가 1로 재설정되는 연도에서만 일상의 의미를 변경합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84655d6a49701a5dd5ce719fc3a2810442727831" translate="yes" xml:space="preserve">
          <source>The day-of-year value 366 is only valid in a leap year.</source>
          <target state="translated">일별 가치 366은 윤년에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8ea8d37df3af7523b59633adef493d9aa58c7633" translate="yes" xml:space="preserve">
          <source>The day-of-year.</source>
          <target state="translated">일.</target>
        </trans-unit>
        <trans-unit id="05eaecddac6892292b3e2f44b8678131b32ba0b1" translate="yes" xml:space="preserve">
          <source>The de-serialized object stream.</source>
          <target state="translated">직렬화 해제 된 객체 스트림</target>
        </trans-unit>
        <trans-unit id="9984a65133bd7cfb7c869dfc5de68f3cce753e9b" translate="yes" xml:space="preserve">
          <source>The decapitalized version of the string.</source>
          <target state="translated">대문자로 된 문자열 버전입니다.</target>
        </trans-unit>
        <trans-unit id="fa52962577498fc2664e907faf54c5feae2e82ee" translate="yes" xml:space="preserve">
          <source>The decimal separator will only appear if a digit follows it</source>
          <target state="translated">소수점 구분 기호는 숫자가 뒤에 오는 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="daea7aca56c46cf4aef47ef8c4efe93967b8427a" translate="yes" xml:space="preserve">
          <source>The decimation subsampling to be applied in the horizontal direction. By default, the value is &lt;code&gt;1&lt;/code&gt;. The value must not be negative or 0.</source>
          <target state="translated">수평 방향으로 적용되는 데시 메이션 서브 샘플링. 기본적으로 값은 &lt;code&gt;1&lt;/code&gt; 입니다. 값은 음수 또는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="006024692a78673c0c0e79f925430f1877ff3c44" translate="yes" xml:space="preserve">
          <source>The decimation subsampling to be applied in the vertical direction. By default, the value is &lt;code&gt;1&lt;/code&gt;. The value must not be negative or 0.</source>
          <target state="translated">수직 방향으로 적용되는 데시 메이션 서브 샘플링. 기본적으로 값은 &lt;code&gt;1&lt;/code&gt; 입니다. 값은 음수 또는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="b89ecc31ea13d452408cdb763636a71209285d8c" translate="yes" xml:space="preserve">
          <source>The declared type of the attribute is the String returned by &lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt;&lt;code&gt;MBeanAttributeInfo.getType()&lt;/code&gt;&lt;/a&gt;. A value is compatible with this type if one of the following is true:</source>
          <target state="translated">속성의 선언 된 타입은 &lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt; &lt;code&gt;MBeanAttributeInfo.getType()&lt;/code&gt; &lt;/a&gt; 의해 돌려 주어지는 String 입니다. 다음 중 하나에 해당하면 값이이 유형과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="535c4d716a707dc9c251826b8415c6348f2fe8af" translate="yes" xml:space="preserve">
          <source>The decoded authority component of this URI, or &lt;code&gt;null&lt;/code&gt; if the authority is undefined</source>
          <target state="translated">이 URI의 디코드 된 권한 컴퍼넌트. 또는 권한이 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c714b16e464134076f2a8654a0032155cf7da549" translate="yes" xml:space="preserve">
          <source>The decoded fragment component of this URI, or &lt;code&gt;null&lt;/code&gt; if the fragment is undefined</source>
          <target state="translated">이 URI의 디코드 된 프래그먼트 컴퍼넌트 . 프래그먼트가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6e006f9c9f2005028fa416f544de4838e11f54" translate="yes" xml:space="preserve">
          <source>The decoded path component of this URI, or &lt;code&gt;null&lt;/code&gt; if the path is undefined</source>
          <target state="translated">이 URI의 디코드 된 패스 컴퍼넌트 . 패스가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b65588b2698dd5f5945bfa151383f0905c62a633" translate="yes" xml:space="preserve">
          <source>The decoded query component of this URI, or &lt;code&gt;null&lt;/code&gt; if the query is undefined</source>
          <target state="translated">이 URI의 디코드 된 쿼리 컴퍼넌트 . 쿼리가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0fec59c98565c6479cff461d8ddfce7807920d6" translate="yes" xml:space="preserve">
          <source>The decoded scheme-specific part of this URI (never &lt;code&gt;null&lt;/code&gt;)</source>
          <target state="translated">이 URI의 디코드 된 방식 특정 부분 ( &lt;code&gt;null&lt;/code&gt; 은 아님)</target>
        </trans-unit>
        <trans-unit id="8435f54fb31ea388cc6e458b15be2994395e323d" translate="yes" xml:space="preserve">
          <source>The decoded user-information component of this URI, or &lt;code&gt;null&lt;/code&gt; if the user information is undefined</source>
          <target state="translated">이 URI의 디코드 된 사용자 정보 컴포넌트 . 사용자 정보가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7907e6f214950bddb5f40a37068dac0948eafa5a" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertPathBuilder&lt;/code&gt; type can be changed by setting the value of the &lt;code&gt;certpathbuilder.type&lt;/code&gt; security property to the desired type.</source>
          <target state="translated">&lt;code&gt;certpathbuilder.type&lt;/code&gt; 보안 특성 의 값을 원하는 유형 으로 설정하여 기본 &lt;code&gt;CertPathBuilder&lt;/code&gt; 유형을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="169cb40e6f0b3986734e5949791939b89c4e99ff" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertPathBuilder&lt;/code&gt; type can be used by applications that do not want to use a hard-coded type when calling one of the &lt;code&gt;getInstance&lt;/code&gt; methods, and want to provide a default type in case a user does not specify its own.</source>
          <target state="translated">&lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 호출 할 때 하드 코딩 된 유형을 사용하지 않고 사용자가 고유 한 유형을 지정하지 않은 경우 기본 유형을 제공하려는 응용 프로그램 은 기본 &lt;code&gt;CertPathBuilder&lt;/code&gt; 유형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fce3e36c470100ba0f05cb22ad90d617c81b37a2" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertPathValidator&lt;/code&gt; type can be changed by setting the value of the &lt;code&gt;certpathvalidator.type&lt;/code&gt; security property to the desired type.</source>
          <target state="translated">&lt;code&gt;certpathvalidator.type&lt;/code&gt; 보안 특성 의 값을 원하는 유형 으로 설정하여 기본 &lt;code&gt;CertPathValidator&lt;/code&gt; 유형을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfcb8b7d4a8f23bc853d6960c44a686f58e177ec" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertPathValidator&lt;/code&gt; type can be used by applications that do not want to use a hard-coded type when calling one of the &lt;code&gt;getInstance&lt;/code&gt; methods, and want to provide a default type in case a user does not specify its own.</source>
          <target state="translated">기본 &lt;code&gt;CertPathValidator&lt;/code&gt; 유형은 &lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 호출 할 때 하드 코딩 된 유형을 사용하지 않고 사용자가 고유 한 유형을 지정하지 않은 경우 기본 유형을 제공하려는 응용 프로그램에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d07184c65b7ccd4f391807571d9702f5edb70ffc" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertStore&lt;/code&gt; type can be changed by setting the value of the &lt;code&gt;certstore.type&lt;/code&gt; security property to the desired type.</source>
          <target state="translated">&lt;code&gt;certstore.type&lt;/code&gt; 보안 특성 의 값을 원하는 유형 으로 설정하여 기본 &lt;code&gt;CertStore&lt;/code&gt; 유형을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b2bb65040f2ee372eaa243409c208749e5283a2" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;CertStore&lt;/code&gt; type can be used by applications that do not want to use a hard-coded type when calling one of the &lt;code&gt;getInstance&lt;/code&gt; methods, and want to provide a default &lt;code&gt;CertStore&lt;/code&gt; type in case a user does not specify its own.</source>
          <target state="translated">기본 &lt;code&gt;CertStore&lt;/code&gt; 유형은 &lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 호출 할 때 하드 코딩 된 유형을 사용하지 않으려 는 사용자가 사용할 수 있으며 사용자가 자체적으로 지정하지 않은 경우 기본 &lt;code&gt;CertStore&lt;/code&gt; 유형 을 제공하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="cbc93f4ae8e8274df32c8bc329a11232de678eb4" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;IIOParamController&lt;/code&gt; that will be used to provide settings for this &lt;code&gt;IIOParam&lt;/code&gt; object when the &lt;code&gt;activateController&lt;/code&gt; method is called. This default should be set by subclasses that choose to provide their own default controller, usually a GUI, for setting parameters.</source>
          <target state="translated">&lt;code&gt;activateController&lt;/code&gt; 메소드가 호출 될 때이 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트에 설정을 제공하는 데 사용되는 기본 &lt;code&gt;IIOParamController&lt;/code&gt; . 이 기본값은 매개 변수 설정을 위해 자체 기본 제어기 (일반적으로 GUI)를 제공하도록 선택한 서브 클래스에 의해 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="57e32562b6e8f186f77339fc053477ffca1f346a" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;JPEGImageReadParam&lt;/code&gt; returned by the &lt;code&gt;getDefaultReadParam&lt;/code&gt; method of the builtin JPEG reader contains no tables. Default tables may be obtained from the table classes &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 JPEG 리더 의 &lt;code&gt;getDefaultReadParam&lt;/code&gt; 메소드가 리턴 한 기본 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 테이블이 없습니다. 기본 테이블은 &lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt; 테이블 클래스에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b2406800a67217fbd1a9f281c566631046db38" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; returned by the &lt;code&gt;getDefaultWriteParam&lt;/code&gt; method of the writer contains no tables. Default tables are included in the default &lt;code&gt;IIOMetadata&lt;/code&gt; objects returned by the writer.</source>
          <target state="translated">라이터 의 &lt;code&gt;getDefaultWriteParam&lt;/code&gt; 메소드에 의해 리턴 된 기본 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에는 테이블이 없습니다. 기본 테이블은 기록기에서 반환 한 기본 &lt;code&gt;IIOMetadata&lt;/code&gt; 개체에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="995ebdbf9779bc7f77f4a6e8d49122ee3bdaf7ae" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Policy&lt;/code&gt; implementation can be changed by setting the value of the &lt;code&gt;auth.policy.provider&lt;/code&gt; security property to the fully qualified name of the desired &lt;code&gt;Policy&lt;/code&gt; implementation class.</source>
          <target state="translated">&lt;code&gt;auth.policy.provider&lt;/code&gt; 보안 특성 값을 원하는 &lt;code&gt;Policy&lt;/code&gt; 구현 클래스 의 완전한 이름 으로 설정하여 기본 &lt;code&gt;Policy&lt;/code&gt; 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e63e9c0f8cf09f6a10ed1a8634fc87ea2f97b334" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;ScriptContext&lt;/code&gt; of the &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ScriptEngine&lt;/code&gt; 의 기본 &lt;code&gt;ScriptContext&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7fc29a454e860e83b3bc76ddafa6475f0a359fc0" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;ScriptContext&lt;/code&gt; of this &lt;code&gt;AbstractScriptEngine&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;AbstractScriptEngine&lt;/code&gt; 의 디폴트 &lt;code&gt;ScriptContext&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="549984e5ac51caa6cbbf5e4edb304bf3b73af399" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TimeZone&lt;/code&gt; created from the ID is cached, and its clone is returned. The &lt;code&gt;user.timezone&lt;/code&gt; property value is set to the ID upon return.</source>
          <target state="translated">ID에서 생성 된 기본 &lt;code&gt;TimeZone&lt;/code&gt; 이 캐시되고 복제본이 반환됩니다. &lt;code&gt;user.timezone&lt;/code&gt; 의 속성 값이 반환시 ID로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="98b80f1d6ce18945f617c88a8c5bb74f2f717d2f" translate="yes" xml:space="preserve">
          <source>The default TrustManager can be changed at runtime by setting the value of the &lt;code&gt;ssl.TrustManagerFactory.algorithm&lt;/code&gt; security property to the desired algorithm name.</source>
          <target state="translated">&lt;code&gt;ssl.TrustManagerFactory.algorithm&lt;/code&gt; 보안 특성 값을 원하는 알고리즘 이름 으로 설정하여 런타임시 기본 TrustManager를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="065207c3af02f55adc01e9d832de92a7ef8b9126" translate="yes" xml:space="preserve">
          <source>The default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. The malformed-input error action may be changed via the &lt;a href=&quot;charsetdecoder#onMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;onMalformedInput&lt;/code&gt;&lt;/a&gt; method; the unmappable-character action may be changed via the &lt;a href=&quot;charsetdecoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;onUnmappableCharacter&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">잘못된 입력 및 매핑 할 수없는 문자 오류에 대한 기본 조치는 오류를 &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;보고&lt;/a&gt; 하는 것입니다. 잘못된 입력 오류 조치는 &lt;a href=&quot;charsetdecoder#onMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;onMalformedInput&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 변경 될 수 있습니다 . 매핑 할 수없는 문자 동작은 &lt;a href=&quot;charsetdecoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;onUnmappableCharacter&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec62c969eb133dfbc9c988f11f12e4deac10163e" translate="yes" xml:space="preserve">
          <source>The default action for malformed-input and unmappable-character errors is to &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;report&lt;/a&gt; them. The malformed-input error action may be changed via the &lt;a href=&quot;charsetencoder#onMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;onMalformedInput&lt;/code&gt;&lt;/a&gt; method; the unmappable-character action may be changed via the &lt;a href=&quot;charsetencoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;onUnmappableCharacter&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">잘못된 입력 및 매핑 할 수없는 문자 오류에 대한 기본 조치는 오류를 &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;보고&lt;/a&gt; 하는 것입니다. 잘못된 입력 오류 조치는 &lt;a href=&quot;charsetencoder#onMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;onMalformedInput&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 변경 될 수 있습니다 . 매핑 할 수없는 문자 동작은 &lt;a href=&quot;charsetencoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;onUnmappableCharacter&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c3c403a4f09194e1102b4853284882f0214c7f4" translate="yes" xml:space="preserve">
          <source>The default action for visit methods. The implementation in this class just returns &lt;a href=&quot;simpleannotationvaluevisitor6#DEFAULT_VALUE&quot;&gt;&lt;code&gt;DEFAULT_VALUE&lt;/code&gt;&lt;/a&gt;; subclasses will commonly override this method.</source>
          <target state="translated">방문 방법에 대한 기본 동작입니다. 이 클래스의 구현은 &lt;a href=&quot;simpleannotationvaluevisitor6#DEFAULT_VALUE&quot;&gt; &lt;code&gt;DEFAULT_VALUE&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 서브 클래스는 일반적으로이 메소드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="338077b1a922572e323ce56edddf01210e486e6c" translate="yes" xml:space="preserve">
          <source>The default action for visit methods. The implementation in this class just returns &lt;a href=&quot;simpleelementvisitor6#DEFAULT_VALUE&quot;&gt;&lt;code&gt;DEFAULT_VALUE&lt;/code&gt;&lt;/a&gt;; subclasses will commonly override this method.</source>
          <target state="translated">방문 방법에 대한 기본 동작입니다. 이 클래스의 구현은 &lt;a href=&quot;simpleelementvisitor6#DEFAULT_VALUE&quot;&gt; &lt;code&gt;DEFAULT_VALUE&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 서브 클래스는 일반적으로이 메소드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d1ae51af628026a026f4ab18a6a94b87755a9969" translate="yes" xml:space="preserve">
          <source>The default action for visit methods. The implementation in this class just returns &lt;a href=&quot;simpletypevisitor6#DEFAULT_VALUE&quot;&gt;&lt;code&gt;DEFAULT_VALUE&lt;/code&gt;&lt;/a&gt;; subclasses will commonly override this method.</source>
          <target state="translated">방문 방법에 대한 기본 동작입니다. 이 클래스의 구현은 &lt;a href=&quot;simpletypevisitor6#DEFAULT_VALUE&quot;&gt; &lt;code&gt;DEFAULT_VALUE&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 서브 클래스는 일반적으로이 메소드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="56fdc967835d45d8075eb4123eec44af83d8c83e" translate="yes" xml:space="preserve">
          <source>The default algorithm can be changed at runtime by setting the value of the &lt;code&gt;ssl.KeyManagerFactory.algorithm&lt;/code&gt; security property to the desired algorithm name.</source>
          <target state="translated">&lt;code&gt;ssl.KeyManagerFactory.algorithm&lt;/code&gt; 보안 특성 의 값을 원하는 알고리즘 이름 으로 설정하여 런타임시 기본 알고리즘을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="219399cbbc7a9d3cb62f850e117c92373162126e" translate="yes" xml:space="preserve">
          <source>The default behavior for periodic notifications is</source>
          <target state="translated">정기 알림의 기본 동작은</target>
        </trans-unit>
        <trans-unit id="5600708ed2f7dd91972887c671ab434f56e3c891" translate="yes" xml:space="preserve">
          <source>The default behavior is to return 0.</source>
          <target state="translated">기본 동작은 0을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aec3e37d4de160fa09df5d605e351831569f8fa2" translate="yes" xml:space="preserve">
          <source>The default behavior returns &lt;code&gt;true&lt;/code&gt; if the classes of the two instances are the same.</source>
          <target state="translated">두 인스턴스의 클래스가 동일한 경우 기본 동작은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3d489244f97c3366532480e2ccb5f4628993bf9c" translate="yes" xml:space="preserve">
          <source>The default charset is determined during virtual-machine startup and typically depends upon the locale and charset of the underlying operating system.</source>
          <target state="translated">기본 문자 집합은 가상 시스템 시작 중에 결정되며 일반적으로 기본 운영 체제의 로캘 및 문자 집합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1f1b2ef2bc979e969e552e10e46c7d5d8d156b03" translate="yes" xml:space="preserve">
          <source>The default constructor.</source>
          <target state="translated">기본 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="2ebee53bb68f545bfd0e8060228273d17f9e1822" translate="yes" xml:space="preserve">
          <source>The default context is immediately usable and does not require &lt;a href=&quot;sslcontext#init-javax.net.ssl.KeyManager:A-javax.net.ssl.TrustManager:A-java.security.SecureRandom-&quot;&gt;initialization&lt;/a&gt;.</source>
          <target state="translated">기본 컨텍스트는 즉시 사용할 수 있으며 &lt;a href=&quot;sslcontext#init-javax.net.ssl.KeyManager:A-javax.net.ssl.TrustManager:A-java.security.SecureRandom-&quot;&gt;초기화&lt;/a&gt; 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d0779f05c7c3391386551fcb2988a002b160b831" translate="yes" xml:space="preserve">
          <source>The default descriptor contains the name, descriptorType and displayName fields. The default value of the name and displayName fields is the name of the attribute.</source>
          <target state="translated">기본 설명자는 이름, descriptorType 및 displayName 필드를 포함합니다. name 및 displayName 필드의 기본값은 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="31eaebdb1de27720394fdc4e00e02d2dbbc6280e" translate="yes" xml:space="preserve">
          <source>The default descriptor contains the name, descriptorType, displayName and severity(=6) fields. The default value of the name and displayName fields is the name of the Notification class (as specified by the &lt;code&gt;name&lt;/code&gt; parameter of the ModelMBeanNotificationInfo constructor).</source>
          <target state="translated">기본 설명자는 이름, descriptorType, displayName 및 심각도 (= 6) 필드를 포함합니다. name 및 displayName 필드의 기본값은 Notification 클래스의 &lt;code&gt;name&lt;/code&gt; 입니다 (ModelMBeanNotificationInfo 생성자 의 name 매개 변수 로 지정됨 ).</target>
        </trans-unit>
        <trans-unit id="f2101b5c8b9ce0f1759aca14b47ae2d9e6dbc985" translate="yes" xml:space="preserve">
          <source>The default descriptor is: name=className,descriptorType=&quot;mbean&quot;, displayName=className, persistPolicy=&quot;never&quot;,log=&quot;F&quot;,visibility=&quot;1&quot; If the descriptor does not contain all these fields, they will be added with these default values.</source>
          <target state="translated">기본 디스크립터는 다음과 같습니다. name = className, descriptorType = &quot;mbean&quot;, displayName = className, persistPolicy = &quot;never&quot;, log = &quot;F&quot;, visibility = &quot;1&quot;디스크립터에 이러한 필드가 모두 포함되어 있지 않으면 추가됩니다. 이 기본값으로.</target>
        </trans-unit>
        <trans-unit id="71a36f46f91101f9e56c61f1cb33445002c648ca" translate="yes" xml:space="preserve">
          <source>The default descriptor will have name, descriptorType, displayName and role fields set. The default value of the name and displayName fields is the operation name.</source>
          <target state="translated">기본 설명자는 이름, descriptorType, displayName 및 역할 필드가 설정됩니다. name 및 displayName 필드의 기본값은 조작 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8e6c7442ac0022cf752f85776d55404b461a102e" translate="yes" xml:space="preserve">
          <source>The default descriptor will have the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;descriptorType&lt;/code&gt;, &lt;code&gt;displayName&lt;/code&gt; and &lt;code&gt;role&lt;/code&gt; fields.</source>
          <target state="translated">기본 설명자는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;descriptorType&lt;/code&gt; , &lt;code&gt;displayName&lt;/code&gt; 및 &lt;code&gt;role&lt;/code&gt; 필드를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8623c5eb869c81af609df29d6207eeddb27448" translate="yes" xml:space="preserve">
          <source>The default deserialization mechanism for objects restores the contents of each field to the value and type it had when it was written. Fields declared as transient or static are ignored by the deserialization process. References to other objects cause those objects to be read from the stream as necessary. Graphs of objects are restored correctly using a reference sharing mechanism. New objects are always allocated when deserializing, which prevents existing objects from being overwritten.</source>
          <target state="translated">객체에 대한 기본 역 직렬화 메커니즘은 각 필드의 내용을 기록 당시의 값과 유형으로 복원합니다. 임시 또는 정적으로 선언 된 필드는 역 직렬화 프로세스에서 무시됩니다. 다른 객체를 참조하면 필요에 따라 스트림에서 해당 객체를 읽습니다. 참조 공유 메커니즘을 사용하여 오브젝트의 그래프가 올바르게 복원됩니다. 역 직렬화시 새 객체가 항상 할당되므로 기존 객체를 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce4ea61d829c9dd15ee14afdaae10ef9ccde5105" translate="yes" xml:space="preserve">
          <source>The default file system, obtained by invoking the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;FileSystems.getDefault&lt;/code&gt;&lt;/a&gt; method, provides access to the file system that is accessible to the Java virtual machine. The &lt;a href=&quot;filesystems&quot;&gt;&lt;code&gt;FileSystems&lt;/code&gt;&lt;/a&gt; class defines methods to create file systems that provide access to other types of (custom) file systems.</source>
          <target state="translated">&lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;FileSystems.getDefault&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 얻은 기본 파일 시스템 은 Java 가상 머신에 액세스 할 수있는 파일 시스템에 대한 액세스를 제공합니다. &lt;a href=&quot;filesystems&quot;&gt; &lt;code&gt;FileSystems&lt;/code&gt; &lt;/a&gt; 클래스를 정의 방법 (사용자 정의) 다른 유형의 파일 시스템에 대한 액세스를 제공하는 파일 시스템을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="356b324d41bc6cd39a64b2b9dca8543c1579dd18" translate="yes" xml:space="preserve">
          <source>The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in this order. This &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;unmodifiable&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 를 포함하는 기본 형식 &lt;code&gt;List&lt;/code&gt; 입니다. 이 &lt;code&gt;List&lt;/code&gt; 은 &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;수정할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdeb59c0e74f57661ae61da028cc8532ec2c21a9" translate="yes" xml:space="preserve">
          <source>The default implementation always throws &lt;a href=&quot;../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 항상 &lt;a href=&quot;../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2eedaa20e42053b1073b0f60bf4b1cdb2ca31400" translate="yes" xml:space="preserve">
          <source>The default implementation assumes that &lt;code&gt;IllegalStateException&lt;/code&gt; thrown by &lt;code&gt;getKey()&lt;/code&gt; or &lt;code&gt;getValue()&lt;/code&gt; indicates that the entry has been removed and cannot be processed. Operation continues for subsequent entries.</source>
          <target state="translated">기본 구현에서는 &lt;code&gt;getKey()&lt;/code&gt; 또는 &lt;code&gt;getValue()&lt;/code&gt; 의해 발생 된 &lt;code&gt;IllegalStateException&lt;/code&gt; 은 항목이 제거되어 처리 할 수 ​​없음을 나타냅니다. 후속 항목에 대한 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="5db0479a3df6538a51997ff32362bca3b5840b40" translate="yes" xml:space="preserve">
          <source>The default implementation behaves as if:</source>
          <target state="translated">기본 구현은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="97dfeb0dbd5d60dd5c8330ad181682923848b7d2" translate="yes" xml:space="preserve">
          <source>The default implementation behaves as though the formatter was used to format the chronology textual name.</source>
          <target state="translated">기본 구현은 포맷터가 연대기 텍스트 이름을 형식화하는 데 사용 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a2ea092b6396012bc615aeb37ebffe3492b5d650" translate="yes" xml:space="preserve">
          <source>The default implementation boxes the result of calling &lt;a href=&quot;primitiveiterator.ofdouble#nextDouble--&quot;&gt;&lt;code&gt;nextDouble()&lt;/code&gt;&lt;/a&gt;, and returns that boxed result.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;primitiveiterator.ofdouble#nextDouble--&quot;&gt; &lt;code&gt;nextDouble()&lt;/code&gt; &lt;/a&gt; 호출 결과를 상자에 넣고 상자에 넣은 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45941eed3592e8a60eb95c36831683de8d484482" translate="yes" xml:space="preserve">
          <source>The default implementation boxes the result of calling &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt;&lt;code&gt;nextInt()&lt;/code&gt;&lt;/a&gt;, and returns that boxed result.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt; &lt;code&gt;nextInt()&lt;/code&gt; &lt;/a&gt; 호출 결과를 상자에 넣고 상자에 넣은 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="804986eab3cdd370e05fe66ef1a8b97ca175e8ce" translate="yes" xml:space="preserve">
          <source>The default implementation boxes the result of calling &lt;a href=&quot;primitiveiterator.oflong#nextLong--&quot;&gt;&lt;code&gt;nextLong()&lt;/code&gt;&lt;/a&gt;, and returns that boxed result.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;primitiveiterator.oflong#nextLong--&quot;&gt; &lt;code&gt;nextLong()&lt;/code&gt; &lt;/a&gt; 호출 결과를 상자에 넣고 상자에 넣은 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cb14b6d97a10573299274dfd36f31ebbcef668e" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;getController&lt;/code&gt; and the calls &lt;code&gt;activate&lt;/code&gt; on the returned object if &lt;code&gt;hasController&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;getController&lt;/code&gt; 를 호출 하고 &lt;code&gt;hasController&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 반환 된 객체 에서 호출이 &lt;code&gt;activate&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="df01be13e18539b383c1254ee93e383fec8add75" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;getNativeMetadataFormatName&lt;/code&gt;, &lt;code&gt;isStandardMetadataFormatSupported&lt;/code&gt;, and &lt;code&gt;getExtraMetadataFormatNames&lt;/code&gt; and returns the combined results.</source>
          <target state="translated">기본 구현은 &lt;code&gt;getNativeMetadataFormatName&lt;/code&gt; , &lt;code&gt;isStandardMetadataFormatSupported&lt;/code&gt; 및 &lt;code&gt;getExtraMetadataFormatNames&lt;/code&gt; 를 호출 하고 결합 된 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="67a57c6dfdd99c7076148f3d7c50149afec84949" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;reset&lt;/code&gt; followed by &lt;code&gt;mergeTree(formatName, root)&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;reset&lt;/code&gt; 다음에 &lt;code&gt;mergeTree(formatName, root)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0255a5e00097a3b4f9441120fe16636ab71d78d7" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;setInput(null,
 false)&lt;/code&gt;, &lt;code&gt;setLocale(null)&lt;/code&gt;, &lt;code&gt;removeAllIIOReadUpdateListeners()&lt;/code&gt;, &lt;code&gt;removeAllIIOReadWarningListeners()&lt;/code&gt;, &lt;code&gt;removeAllIIOReadProgressListeners()&lt;/code&gt;, and &lt;code&gt;clearAbortRequest&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;setInput(null, false)&lt;/code&gt; , &lt;code&gt;setLocale(null)&lt;/code&gt; , &lt;code&gt;removeAllIIOReadUpdateListeners()&lt;/code&gt; , &lt;code&gt;removeAllIIOReadWarningListeners()&lt;/code&gt; , &lt;code&gt;removeAllIIOReadProgressListeners()&lt;/code&gt; 및 &lt;code&gt;clearAbortRequest&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ca35547c3dfbf7785332a0eb798130f62c8b33d3" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;setOutput(null)&lt;/code&gt;, &lt;code&gt;setLocale(null)&lt;/code&gt;, &lt;code&gt;removeAllIIOWriteWarningListeners()&lt;/code&gt;, &lt;code&gt;removeAllIIOWriteProgressListeners()&lt;/code&gt;, and &lt;code&gt;clearAbortRequest&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;setOutput(null)&lt;/code&gt; , &lt;code&gt;setLocale(null)&lt;/code&gt; , &lt;code&gt;removeAllIIOWriteWarningListeners()&lt;/code&gt; , &lt;code&gt;removeAllIIOWriteProgressListeners()&lt;/code&gt; 및 &lt;code&gt;clearAbortRequest&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ce38494e2e9aed50f10699c88cbc167e8321eefe" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;toString&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;toString&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4149de8d1608259427bd33ee41cd5da9e437894c" translate="yes" xml:space="preserve">
          <source>The default implementation checks &lt;code&gt;locale&lt;/code&gt; against the values returned by &lt;code&gt;getAvailableLocales&lt;/code&gt;, and sets the &lt;code&gt;locale&lt;/code&gt; instance variable if it is found. If &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the instance variable is set to &lt;code&gt;null&lt;/code&gt; without any checking.</source>
          <target state="translated">기본 구현 은 &lt;code&gt;getAvailableLocales&lt;/code&gt; 에서 리턴 한 값과 &lt;code&gt;locale&lt;/code&gt; 을 확인 하고 &lt;code&gt;locale&lt;/code&gt; 인스턴스 변수가있는 경우이를 설정합니다 . 경우 &lt;code&gt;locale&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 인스턴스 변수로 설정되어 &lt;code&gt;null&lt;/code&gt; 어떤 확인하지 않고.</target>
        </trans-unit>
        <trans-unit id="e153265a13b18e093fb1de6300c02f9e01167b80" translate="yes" xml:space="preserve">
          <source>The default implementation checks if compression is supported and throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if not. Otherwise, it returns a clone of the &lt;code&gt;compressionTypes&lt;/code&gt; instance variable if it is non-&lt;code&gt;null&lt;/code&gt;, or else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 압축이 지원되는지 확인하고 그렇지 않은 경우 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다. 그렇지 않으면, &lt;code&gt;compressionTypes&lt;/code&gt; 인스턴스 변수가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 compressionTypes 인스턴스 변수 의 복제를 리턴하거나 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7224588cc878f7a39d862ce9de2f7338e978e3ad" translate="yes" xml:space="preserve">
          <source>The default implementation checks if reading &lt;code&gt;Raster&lt;/code&gt;s is supported, and if so calls &lt;a href=&quot;imagereader#readRaster-int-javax.imageio.ImageReadParam-&quot;&gt;&lt;code&gt;readRaster(imageIndex, null)&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are 0, or throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; otherwise.</source>
          <target state="translated">디폴트 구현 검사 읽는 경우 &lt;code&gt;Raster&lt;/code&gt; 의 것은 지원하고, 경우에 이렇게 호출됩니다 &lt;a href=&quot;imagereader#readRaster-int-javax.imageio.ImageReadParam-&quot;&gt; &lt;code&gt;readRaster(imageIndex, null)&lt;/code&gt; &lt;/a&gt; 하는 경우 &lt;code&gt;tileX&lt;/code&gt; 및 &lt;code&gt;tileY&lt;/code&gt; 의가 0 인, 또는 발생 &lt;code&gt;IllegalArgumentException&lt;/code&gt; , 그렇지 않으면.</target>
        </trans-unit>
        <trans-unit id="ee84ebf390912c50ff7306120240840012654e59" translate="yes" xml:space="preserve">
          <source>The default implementation checks that compression is supported and that the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 경우, &lt;code&gt;getCompressionTypes()&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;getCompressionType()&lt;/code&gt; 비입니다 &lt;code&gt;null&lt;/code&gt; , 그것은 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39ae91123b183f38ef980a5bdd8f15dbeaf947d7" translate="yes" xml:space="preserve">
          <source>The default implementation checks that compression is supported and that the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it returns the value of the &lt;code&gt;compressionQuality&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;getCompressionTypes()&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;getCompressionType()&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 &lt;code&gt;compressionQuality&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d7662a6d3adccfb0c9ce530f65142152c500933c" translate="yes" xml:space="preserve">
          <source>The default implementation checks that compression is supported and the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;quality&lt;/code&gt; is within bounds, it returns &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 경우, &lt;code&gt;getCompressionTypes()&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;getCompressionType()&lt;/code&gt; 비입니다 &lt;code&gt;null&lt;/code&gt; , 그리고 &lt;code&gt;quality&lt;/code&gt; 범위 내에서, 그것은 반환 &lt;code&gt;-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa40cd63fa69bf871b72c0b8b4d327c36b842489" translate="yes" xml:space="preserve">
          <source>The default implementation checks that compression is supported, and that the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;getCompressionTypes()&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;compressionType&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; it sets the &lt;code&gt;compressionQuality&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;getCompressionTypes()&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 을 반환 하거나 &lt;code&gt;compressionType&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 &lt;code&gt;compressionQuality&lt;/code&gt; 인스턴스 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="bd1cafa89eed3756b88a0081e6e16202e59efef1" translate="yes" xml:space="preserve">
          <source>The default implementation checks the &lt;code&gt;input&lt;/code&gt; argument against the list returned by &lt;code&gt;originatingProvider.getInputTypes()&lt;/code&gt; and fails if the argument is not an instance of one of the classes in the list. If the originating provider is set to &lt;code&gt;null&lt;/code&gt;, the input is accepted only if it is an &lt;code&gt;ImageInputStream&lt;/code&gt;.</source>
          <target state="translated">기본 구현 은 &lt;code&gt;originatingProvider.getInputTypes()&lt;/code&gt; 의해 리턴 된 목록과 비교 하여 &lt;code&gt;input&lt;/code&gt; 인수를 점검하고 인수가 목록 에있는 클래스 중 하나의 인스턴스가 아닌 경우 실패합니다. 시작 공급자가 &lt;code&gt;null&lt;/code&gt; 로 설정된 경우 입력이 &lt;code&gt;ImageInputStream&lt;/code&gt; 인 경우에만 입력이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="de6c078c94849f60318934cda47e0b37e95b6c18" translate="yes" xml:space="preserve">
          <source>The default implementation checks the name against the global standard metadata format name, and returns that format if it is supported. Otherwise, it checks against the native format names followed by any additional format names. If a match is found, it retrieves the name of the &lt;code&gt;IIOMetadataFormat&lt;/code&gt; class from &lt;code&gt;nativeMetadataFormatClassName&lt;/code&gt; or &lt;code&gt;extraMetadataFormatClassNames&lt;/code&gt; as appropriate, and constructs an instance of that class using its &lt;code&gt;getInstance&lt;/code&gt; method.</source>
          <target state="translated">기본 구현은 글로벌 표준 메타 데이터 형식 이름과 비교하여 이름을 확인하고 지원되는 경우 해당 형식을 리턴합니다. 그렇지 않으면 기본 형식 이름과 추가 형식 이름이 있는지 확인합니다. 일치하는 것이 발견되면 &lt;code&gt;nativeMetadataFormatClassName&lt;/code&gt; 또는 &lt;code&gt;extraMetadataFormatClassNames&lt;/code&gt; 에서 &lt;code&gt;IIOMetadataFormat&lt;/code&gt; 클래스 의 이름을 검색 하고 &lt;code&gt;getInstance&lt;/code&gt; 메소드를 사용하여 해당 클래스의 인스턴스를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="57d4c9e43f4ff778390d28f361ac4b410962aafa" translate="yes" xml:space="preserve">
          <source>The default implementation checks whether compression is supported and the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt; the value of &lt;code&gt;getCompressionType&lt;/code&gt; is returned as a convenience.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;compressionType&lt;/code&gt; 이 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우 &lt;code&gt;getCompressionType&lt;/code&gt; 의 값이 편의상 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a05d28dd7af9099d59cdf9067f8a6b7710071433" translate="yes" xml:space="preserve">
          <source>The default implementation checks whether compression is supported and the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, if &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;true&lt;/code&gt; is returned as a convenience.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;getCompressionTypes()&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;getCompressionType()&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 편의상 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35b1ea663a2ae101c3c00afff29dd0cff89ecf63" translate="yes" xml:space="preserve">
          <source>The default implementation checks whether compression is supported and the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, it calls &lt;code&gt;getCompressionTypes&lt;/code&gt; and checks if &lt;code&gt;compressionType&lt;/code&gt; is one of the legal values. If it is, the &lt;code&gt;compressionType&lt;/code&gt; instance variable is set. If &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the instance variable is set without performing any checking.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;getCompressionTypes&lt;/code&gt; 를 호출 하고 &lt;code&gt;compressionType&lt;/code&gt; 이 올바른 값 중 하나 인지 확인 합니다. 설정되어 있으면 &lt;code&gt;compressionType&lt;/code&gt; 인스턴스 변수가 설정됩니다. 경우 &lt;code&gt;compressionType&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; , 인스턴스 변수는 검사를 수행하지 않고 설정된다.</target>
        </trans-unit>
        <trans-unit id="55b272519206e035d427301e9f11c2476d9dc214" translate="yes" xml:space="preserve">
          <source>The default implementation checks whether compression is supported and the compression mode is &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. If so, it returns the value of the &lt;code&gt;compressionType&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 압축이 지원되고 압축 모드가 &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 인지 확인 합니다 . 그렇다면 &lt;code&gt;compressionType&lt;/code&gt; 인스턴스 변수 의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d869e07f9367ed0b78dd812236faf6f1418870b0" translate="yes" xml:space="preserve">
          <source>The default implementation combines the era and year-of-era into a proleptic year before calling &lt;a href=&quot;chronology#date-int-int-int-&quot;&gt;&lt;code&gt;date(int, int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronology#date-int-int-int-&quot;&gt; &lt;code&gt;date(int, int, int)&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 연대와 연대를 다산 연도로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="9f0d1f5b1a006f93eedf297c18be2449f5c967bb" translate="yes" xml:space="preserve">
          <source>The default implementation combines the era and year-of-era into a proleptic year before calling &lt;a href=&quot;chronology#dateYearDay-int-int-&quot;&gt;&lt;code&gt;dateYearDay(int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronology#dateYearDay-int-int-&quot;&gt; &lt;code&gt;dateYearDay(int, int)&lt;/code&gt; &lt;/a&gt; 호출하기 전에 연대와 연대를 다산 연도로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="bef8795a4b88b10f7df84401dbb530a35adde301" translate="yes" xml:space="preserve">
          <source>The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and the last modified time of the source data of the resource bundle. If it's determined that the source data has been modified since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the same string as its file suffix if it's not one of the default formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 자원 번들 소스 데이터의 &lt;code&gt;loadTime&lt;/code&gt; 과 마지막 수정 시간을 비교 합니다 . &lt;code&gt;loadTime&lt;/code&gt; 이후에 소스 데이터가 수정 된 것으로 확인 되면 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 이 구현은 지정된 &lt;code&gt;format&lt;/code&gt; 이 기본 형식 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 가 아닌 경우 파일 형식 접미사와 동일한 문자열 이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1e204313c32984cae90a2a91aad2c88b02b56213" translate="yes" xml:space="preserve">
          <source>The default implementation compares the fully-qualified class name of the &lt;code&gt;reader&lt;/code&gt; argument with the class name passed into the constructor. This method may be overridden if more sophisticated checking is required.</source>
          <target state="translated">기본 구현은 &lt;code&gt;reader&lt;/code&gt; 인수 의 완전한 클래스 이름을 생성자에 전달 된 클래스 이름과 비교합니다 . 보다 정교한 검사가 필요한 경우이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de233325d954cf602c0b09028338c86e02fdb18" translate="yes" xml:space="preserve">
          <source>The default implementation constructs and returns a new &lt;code&gt;ImageReadParam&lt;/code&gt; object that does not allow source scaling (</source>
          <target state="translated">기본 구현 은 소스 스케일링을 허용하지 않는 새 &lt;code&gt;ImageReadParam&lt;/code&gt; 객체를 구성하고 반환합니다 (</target>
        </trans-unit>
        <trans-unit id="b4f2e505d3f48149cfce0c86882a9067aabb5144" translate="yes" xml:space="preserve">
          <source>The default implementation constructs and returns a new &lt;code&gt;ImageWriteParam&lt;/code&gt; object that does not allow tiling, progressive encoding, or compression, and that will be localized for the current &lt;code&gt;Locale&lt;/code&gt; (</source>
          <target state="translated">기본 구현 은 바둑판 식 배열, 점진적 인코딩 또는 압축을 허용하지 않고 현재 &lt;code&gt;Locale&lt;/code&gt; 대해 지역화 된 새 &lt;code&gt;ImageWriteParam&lt;/code&gt; 객체를 구성하고 반환합니다 (</target>
        </trans-unit>
        <trans-unit id="caf5ae9c3ead5d9e333d24fada341d846129a5c1" translate="yes" xml:space="preserve">
          <source>The default implementation creates a &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator from the collections's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator.</source>
          <target state="translated">기본 구현은 컬렉션의 &lt;code&gt;Iterator&lt;/code&gt; 에서 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;후기 바인딩&lt;/a&gt;&lt;/em&gt; 스플리터를 만듭니다 . spliterator는 컬렉션 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ebc35ea34ff849f1faa4854330171c731fcbcc2" translate="yes" xml:space="preserve">
          <source>The default implementation creates a &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator from the list's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the list's iterator.</source>
          <target state="translated">기본 구현은 목록의 &lt;code&gt;Iterator&lt;/code&gt; 에서 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;후기 바인딩&lt;/a&gt;&lt;/em&gt; 분할기를 만듭니다 . spliterator는 목록 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 특성을 상속 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5afcae0816c1de81e39db535f75600f6f559966c" translate="yes" xml:space="preserve">
          <source>The default implementation creates a &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator from the set's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the set's iterator.</source>
          <target state="translated">기본 구현은 세트의 &lt;code&gt;Iterator&lt;/code&gt; 에서 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;후기 바인딩&lt;/a&gt;&lt;/em&gt; 스플리터를 만듭니다 . spliterator는 세트 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 특성을 상속 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81da0467decb6d6413d96923a42a5d8da3edc8d5" translate="yes" xml:space="preserve">
          <source>The default implementation creates a &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator from the sorted set's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the set's iterator. The spliterator's comparator is the same as the sorted set's comparator.</source>
          <target state="translated">기본 구현은 정렬 된 세트의 &lt;code&gt;Iterator&lt;/code&gt; 에서 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;후기 바인딩&lt;/a&gt;&lt;/em&gt; 스플리터를 만듭니다 . spliterator는 세트 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 특성을 상속 합니다. 스플리터의 비교기는 정렬 된 세트의 비교기와 동일합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0fb63792a28dd0738ee92a341649aed08cc226a" translate="yes" xml:space="preserve">
          <source>The default implementation creates a parallel &lt;code&gt;Stream&lt;/code&gt; from the collection's &lt;code&gt;Spliterator&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 컬렉션의 &lt;code&gt;Spliterator&lt;/code&gt; 에서 병렬 &lt;code&gt;Stream&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c445c05975d79e195385fca5e455ac4e8c3782a9" translate="yes" xml:space="preserve">
          <source>The default implementation creates a sequential &lt;code&gt;Stream&lt;/code&gt; from the collection's &lt;code&gt;Spliterator&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 컬렉션의 &lt;code&gt;Spliterator&lt;/code&gt; 에서 순차적 &lt;code&gt;Stream&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8f5a18e08ccf5130e36d85839db77e95a638fbbd" translate="yes" xml:space="preserve">
          <source>The default implementation creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses that support fields should override this and create an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.</source>
          <target state="translated">기본 구현은 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 이없는 AttributedCharacterIterator 를 작성 합니다. 필드를 지원하는 서브 클래스는 이것을 재정의 하고 의미있는 속성으로 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 를 작성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="257e09e4da5e8975f2d1b36e54ab7cdc57a925cc" translate="yes" xml:space="preserve">
          <source>The default implementation creates an &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;early-binding&lt;/a&gt;&lt;/em&gt; spliterator from the iterable's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterable's iterator.</source>
          <target state="translated">기본 구현은 iterable의 &lt;code&gt;Iterator&lt;/code&gt; 에서 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;초기 바인딩&lt;/a&gt;&lt;/em&gt; 스플리터를 만듭니다 . spliterator는 iterable 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 특성을 상속 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="faff3da8d58dfb0a89340fcc75e40705b0c48c65" translate="yes" xml:space="preserve">
          <source>The default implementation currently calls &lt;a href=&quot;clock#instant--&quot;&gt;&lt;code&gt;instant()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 현재 &lt;a href=&quot;clock#instant--&quot;&gt; &lt;code&gt;instant()&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e344a527e52059ed12cb005a4d948b2d946466df" translate="yes" xml:space="preserve">
          <source>The default implementation does not throw NullPointerException for maps that do not support null values if oldValue is null unless newValue is also null.</source>
          <target state="translated">newValue도 null이 아니면 oldValue가 null 인 경우 null 값을 지원하지 않는 맵에 대해서는 기본 구현에서 NullPointerException이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d18445a0259ec3d88cb415f6a4ab2b65a2c28a83" translate="yes" xml:space="preserve">
          <source>The default implementation first calls &lt;a href=&quot;annotatedelement#getDeclaredAnnotationsByType-java.lang.Class-&quot;&gt;&lt;code&gt;getDeclaredAnnotationsByType(Class)&lt;/code&gt;&lt;/a&gt; passing &lt;code&gt;annotationClass&lt;/code&gt; as the argument. If the returned array has length greater than zero, the array is returned. If the returned array is zero-length and this &lt;code&gt;AnnotatedElement&lt;/code&gt; is a class and the argument type is an inheritable annotation type, and the superclass of this &lt;code&gt;AnnotatedElement&lt;/code&gt; is non-null, then the returned result is the result of calling &lt;a href=&quot;annotatedelement#getAnnotationsByType-java.lang.Class-&quot;&gt;&lt;code&gt;getAnnotationsByType(Class)&lt;/code&gt;&lt;/a&gt; on the superclass with &lt;code&gt;annotationClass&lt;/code&gt; as the argument. Otherwise, a zero-length array is returned.</source>
          <target state="translated">기본 구현은 먼저 &lt;code&gt;annotationClass&lt;/code&gt; 를 인수로 전달하는 &lt;a href=&quot;annotatedelement#getDeclaredAnnotationsByType-java.lang.Class-&quot;&gt; &lt;code&gt;getDeclaredAnnotationsByType(Class)&lt;/code&gt; &lt;/a&gt; 를 호출합니다 . 반환 된 배열의 길이가 0보다 크면 배열이 반환됩니다. 리턴 된 배열의 길이가 0 &lt;code&gt;AnnotatedElement&lt;/code&gt; 가 클래스이고 인수 유형이 상속 가능한 어노테이션 유형 &lt;code&gt;AnnotatedElement&lt;/code&gt; 의 수퍼 클래스가 널이 아닌 경우 리턴 된 결과는 &lt;a href=&quot;annotatedelement#getAnnotationsByType-java.lang.Class-&quot;&gt; &lt;code&gt;getAnnotationsByType(Class)&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;annotationClass&lt;/code&gt; 를 인수로 가지는 슈퍼 클래스 그렇지 않으면 길이가 0 인 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b29496e4ca6310ce75237ca300bd0956250bad5f" translate="yes" xml:space="preserve">
          <source>The default implementation first performs a null check and then loops over the results of &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt;&lt;code&gt;getDeclaredAnnotations()&lt;/code&gt;&lt;/a&gt; returning the first annotation whose annotation type matches the argument type.</source>
          <target state="translated">기본 구현은 먼저 널 검사를 수행 한 다음 &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt; &lt;code&gt;getDeclaredAnnotations()&lt;/code&gt; &lt;/a&gt; 결과를 반복하여 주석 유형이 인수 유형과 일치하는 첫 번째 주석을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="76ff9fb0db913e8975e85677fb1c71ccbf4fb1ea" translate="yes" xml:space="preserve">
          <source>The default implementation instantiates a &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.</source>
          <target state="translated">기본 구현 은 다음과 같이 &lt;code&gt;ResourceBundle&lt;/code&gt; 을 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="918bb92ec2528bdf22aec70dfdfb2fe0a6e367dd" translate="yes" xml:space="preserve">
          <source>The default implementation invokes &lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;date(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;date(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="79e8716004917e61f473c5368fc8648954fb1f82" translate="yes" xml:space="preserve">
          <source>The default implementation invokes &lt;a href=&quot;chronology#dateNow-java.time.Clock-&quot;&gt;&lt;code&gt;dateNow(Clock)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronology#dateNow-java.time.Clock-&quot;&gt; &lt;code&gt;dateNow(Clock)&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="014a22a299a670f8d7b72efc0612886981858d75" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to performing the following steps for this &lt;code&gt;map&lt;/code&gt;, then returning the current value or &lt;code&gt;null&lt;/code&gt; if absent:</source>
          <target state="translated">기본 구현은이 &lt;code&gt;map&lt;/code&gt; 에 대해 다음 단계를 수행 한 다음 현재 값을 반환하거나 &lt;code&gt;null&lt;/code&gt; 경우 null 을 반환하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa2710befa618a19048e8cc0acee687d89bd86c5" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to performing the following steps for this &lt;code&gt;map&lt;/code&gt;, then returning the current value or &lt;code&gt;null&lt;/code&gt; if now absent. :</source>
          <target state="translated">기본 구현은이 &lt;code&gt;map&lt;/code&gt; 대해 다음 단계를 수행 한 다음 현재 값을 반환하거나 현재 값이 &lt;code&gt;null&lt;/code&gt; 경우 null 을 반환하는 것과 같습니다 . :</target>
        </trans-unit>
        <trans-unit id="026c5286ae8f56b4406db07c9581d56f87f2dc0b" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to performing the following steps for this &lt;code&gt;map&lt;/code&gt;, then returning the current value or &lt;code&gt;null&lt;/code&gt; if now absent:</source>
          <target state="translated">기본 구현은이 &lt;code&gt;map&lt;/code&gt; 에 대해 다음 단계를 수행 한 다음 현재 값을 반환하거나 현재 &lt;code&gt;null&lt;/code&gt; 경우 null 을 반환하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eef0971abbf01d3bc47a44b27a4a2cc98b3ab74" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to the following steps for this &lt;code&gt;map&lt;/code&gt;, then returning the current value or &lt;code&gt;null&lt;/code&gt; if now absent:</source>
          <target state="translated">기본 구현은이 &lt;code&gt;map&lt;/code&gt; 의 다음 단계와 동일 하며 현재 값을 반환하거나 현재 값이 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6968615c8fa6a8bfd97574b9c80fd40718f157f2" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to, for this &lt;code&gt;list&lt;/code&gt;:</source>
          <target state="translated">이 &lt;code&gt;list&lt;/code&gt; 의 기본 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e6894200795f6724b275671bc97189a298ba8795" translate="yes" xml:space="preserve">
          <source>The default implementation is equivalent to, for this &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">디폴트의 구현이 들어에 해당 &lt;code&gt;map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89a10c605a0a915e925bdbb88ad6011593975fe1" translate="yes" xml:space="preserve">
          <source>The default implementation is suitable for most calendar systems. If &lt;a href=&quot;../temporal/chronofield#YEAR_OF_ERA&quot;&gt;&lt;code&gt;ChronoField.YEAR_OF_ERA&lt;/code&gt;&lt;/a&gt; is found without an &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt;&lt;code&gt;ChronoField.ERA&lt;/code&gt;&lt;/a&gt; then the last era in &lt;a href=&quot;chronology#eras--&quot;&gt;&lt;code&gt;Chronology.eras()&lt;/code&gt;&lt;/a&gt; is used. The implementation assumes a 7 day week, that the first day-of-month has the value 1, that first day-of-year has the value 1, and that the first of the month and year always exists.</source>
          <target state="translated">기본 구현은 대부분의 달력 시스템에 적합합니다. 경우 &lt;a href=&quot;../temporal/chronofield#YEAR_OF_ERA&quot;&gt; &lt;code&gt;ChronoField.YEAR_OF_ERA&lt;/code&gt; 가&lt;/a&gt; 없이 발견 &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt; &lt;code&gt;ChronoField.ERA&lt;/code&gt; &lt;/a&gt; 다음의 마지막 시대 &lt;a href=&quot;chronology#eras--&quot;&gt; &lt;code&gt;Chronology.eras()&lt;/code&gt; &lt;/a&gt; 사용됩니다. 구현에서는 주 7 일, 첫 번째 달의 값은 1, 첫 번째 날의 값은 1, 달과 연도의 첫 번째는 항상 존재한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="af19e76588cdbfce2ffd8bc95a9d4cbb9eb587e0" translate="yes" xml:space="preserve">
          <source>The default implementation just calls &lt;a href=&quot;imagereader#read-int-&quot;&gt;&lt;code&gt;read(imageIndex, param)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;imagereader#read-int-&quot;&gt; &lt;code&gt;read(imageIndex, param)&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="030df48ed1152ec9e82a1924114a1066300d507f" translate="yes" xml:space="preserve">
          <source>The default implementation just returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 단지 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4333a467dfc27a2a2e92417f9cda2aa5f63dd748" translate="yes" xml:space="preserve">
          <source>The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.</source>
          <target state="translated">기본 구현은이 메소드의 동기화 또는 원 자성 특성을 보장하지 않습니다. 원 자성 보장을 제공하는 모든 구현은이 메소드를 대체하고 동시성 특성을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9052a30fa282fd5d62ff058e23ca591de82a02d" translate="yes" xml:space="preserve">
          <source>The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. In particular, all implementations of subinterface &lt;a href=&quot;concurrent/concurrentmap&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; must document whether the function is applied once atomically only if the value is not present.</source>
          <target state="translated">기본 구현은이 메소드의 동기화 또는 원 자성 특성을 보장하지 않습니다. 원 자성 보장을 제공하는 모든 구현은이 메소드를 대체하고 동시성 특성을 문서화해야합니다. 특히, 서브 인터페이스 &lt;a href=&quot;concurrent/concurrentmap&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt; 의 모든 구현은 값이 존재하지 않는 경우에만 함수가 원자 적으로 한 번 적용되는지 여부를 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e3bd2dd9cf90d335e6718a23d07e019f6c4fbc3" translate="yes" xml:space="preserve">
          <source>The default implementation may call &lt;a href=&quot;annotatedelement#getDeclaredAnnotation-java.lang.Class-&quot;&gt;&lt;code&gt;getDeclaredAnnotation(Class)&lt;/code&gt;&lt;/a&gt; one or more times to find a directly present annotation and, if the annotation type is repeatable, to find a container annotation. If annotations of the annotation type &lt;code&gt;annotationClass&lt;/code&gt; are found to be both directly and indirectly present, then &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt;&lt;code&gt;getDeclaredAnnotations()&lt;/code&gt;&lt;/a&gt; will get called to determine the order of the elements in the returned array.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;annotatedelement#getDeclaredAnnotation-java.lang.Class-&quot;&gt; &lt;code&gt;getDeclaredAnnotation(Class)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 직접 존재하는 주석을 찾고 주석 유형이 반복 가능한 경우 컨테이너 주석을 찾을 수 있습니다. 어노테이션 유형 &lt;code&gt;annotationClass&lt;/code&gt; 의 어노테이션 이 직접 및 간접적으로 존재하는 것으로 밝혀 지면 , &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt; &lt;code&gt;getDeclaredAnnotations()&lt;/code&gt; &lt;/a&gt; 가 호출되어 리턴 된 배열에서 요소의 순서를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="6cd785303d6feb56889a2312039dcca432903a18" translate="yes" xml:space="preserve">
          <source>The default implementation may retry these steps when multiple threads attempt updates including potentially calling the function repeatedly for a given key.</source>
          <target state="translated">기본 구현은 여러 스레드가 주어진 키에 대해 함수를 반복적으로 호출하는 것을 포함하여 업데이트를 시도 할 때 이러한 단계를 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e2c2c4187fa5b9a4e6f992fe975bdd23985b74" translate="yes" xml:space="preserve">
          <source>The default implementation may retry these steps when multiple threads attempt updates including potentially calling the mapping function multiple times.</source>
          <target state="translated">기본 구현은 여러 스레드가 잠재적으로 맵핑 기능 호출을 여러 번 포함하여 업데이트를 시도 할 때 이러한 단계를 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32701543b1bc1d3c034ba9603164585a2f0ef108" translate="yes" xml:space="preserve">
          <source>The default implementation may retry these steps when multiple threads attempt updates including potentially calling the remapping function multiple times.</source>
          <target state="translated">기본 구현에서는 리 맵핑 기능을 여러 번 호출하는 것을 포함하여 여러 스레드가 업데이트를 시도 할 때 이러한 단계를 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be67d96b90561a823bdfda3d44474ce0126a3d4" translate="yes" xml:space="preserve">
          <source>The default implementation must behave as follows:</source>
          <target state="translated">기본 구현은 다음과 같이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="70aebb7aed28f4bf168a2c97372a4c30db417af1" translate="yes" xml:space="preserve">
          <source>The default implementation must behave equivalent to this code:</source>
          <target state="translated">기본 구현은 다음 코드와 동일하게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcda3bf4ce8c419c3bc7e1f477ff20b820d9b13d" translate="yes" xml:space="preserve">
          <source>The default implementation must check the locale is not null and return &lt;code&gt;toString()&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 로케일이 널이 아닌지 확인하고 &lt;code&gt;toString()&lt;/code&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e596ac7aa5bcdb03db9e92086bd5472370f3ea67" translate="yes" xml:space="preserve">
          <source>The default implementation must return a range for &lt;code&gt;ERA&lt;/code&gt; from zero to one, suitable for two era calendar systems such as ISO.</source>
          <target state="translated">기본 구현은 0과 1 사이의 &lt;code&gt;ERA&lt;/code&gt; 범위를 반환해야 하며 ISO와 같은 두 가지 달력 시스템에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="79036d29929066707dfd837bdea2877a6798d0fb" translate="yes" xml:space="preserve">
          <source>The default implementation must return null.</source>
          <target state="translated">기본 구현은 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3df8c3b790ebaa8058812e7beb24ee8eb8f9d123" translate="yes" xml:space="preserve">
          <source>The default implementation obtains an array containing all elements in this list, sorts the array, and iterates over this list resetting each element from the corresponding position in the array. (This avoids the n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting to sort a linked list in place.)</source>
          <target state="translated">기본 구현은이 목록의 모든 요소가 포함 된 배열을 가져 와서 배열을 정렬 한 다음이 목록을 반복하여 배열의 해당 위치에서 각 요소를 재설정합니다. (이것은 링크 된 목록을 제자리에 정렬하려고 시도 할 때 발생 하는 n &lt;sup&gt;2&lt;/sup&gt; log (n) 성능을 피합니다 .)</target>
        </trans-unit>
        <trans-unit id="7ca6949caf6b0d77298ceb070d9d0d30bb4360e1" translate="yes" xml:space="preserve">
          <source>The default implementation obtains the parameters from an SSLSocket created by calling the &lt;a href=&quot;../socketfactory#createSocket--&quot;&gt;SocketFactory.createSocket()&lt;/a&gt; method of this context's SocketFactory.</source>
          <target state="translated">기본 구현은 이 컨텍스트 &lt;a href=&quot;../socketfactory#createSocket--&quot;&gt;SocketFactory&lt;/a&gt; 의 SocketFactory.createSocket () 메소드를 호출하여 작성된 SSLSocket에서 매개 변수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d57182faa5a56d287f3fccf41980142289b8f413" translate="yes" xml:space="preserve">
          <source>The default implementation of this method always returns &lt;code&gt;false&lt;/code&gt;; it should be overridden by auto-detecting decoders to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 항상 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . 자동 감지 디코더로 재정 의하여 &lt;code&gt;true&lt;/code&gt; 를 반환해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6ec8de1749dc65a1db36ab0e96100e3f43a438" translate="yes" xml:space="preserve">
          <source>The default implementation of this method always throws an &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;; it should be overridden by auto-detecting decoders to return &lt;code&gt;true&lt;/code&gt; once the input charset has been determined.</source>
          <target state="translated">이 메소드의 기본 구현은 항상 &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 입력 문자 집합이 결정되면 &lt;code&gt;true&lt;/code&gt; 를 반환하도록 자동 감지 디코더로이를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="84c56c6184f245e5717d0eed4a21403c086527ad" translate="yes" xml:space="preserve">
          <source>The default implementation of this method always throws an &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;; it should be overridden by auto-detecting decoders to return the appropriate value.</source>
          <target state="translated">이 메소드의 기본 구현은 항상 &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 적절한 값을 반환하려면 자동 감지 디코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a58a102eae4311db2f6f37b7e4387da56ae8cf4f" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing and has no side-effects.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 작업도 수행하지 않으며 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3994ea328aca33c69fba9329be5dd141f01d5e2c" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing for Standard MBeans. For MXBeans, it removes any information that was recorded by the &lt;a href=&quot;standardmbean#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt;&lt;code&gt;preRegister&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드의 기본 구현은 표준 MBean에 대해서는 아무 것도 수행하지 않습니다. MXBean의 경우, &lt;a href=&quot;standardmbean#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt; &lt;code&gt;preRegister&lt;/code&gt; &lt;/a&gt; 메소드 로 기록 된 정보를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="30bd152bf900f1b000302b88ac35a6924367dc91" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing for Standard MBeans. For MXBeans, it undoes any work done by &lt;a href=&quot;standardmbean#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt;&lt;code&gt;preRegister&lt;/code&gt;&lt;/a&gt; if registration fails.</source>
          <target state="translated">이 메소드의 기본 구현은 표준 MBean에 대해서는 아무 것도 수행하지 않습니다. MXBean의 경우 등록이 실패하면 &lt;a href=&quot;standardmbean#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt; &lt;code&gt;preRegister&lt;/code&gt; &lt;/a&gt; 가 수행 한 모든 작업을 취소 합니다.</target>
        </trans-unit>
        <trans-unit id="8765bc738015d203a4af606c4a6f55768a8e5a11" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing, and always returns &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt;&lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt;&lt;/a&gt;. This method should be overridden by decoders that may need to write final characters to the output buffer once the entire input sequence has been read.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 작업도 수행하지 않으며 항상 &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt; &lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt; 를&lt;/a&gt; 리턴합니다 . 이 방법은 전체 입력 시퀀스를 읽은 후에 최종 문자를 출력 버퍼에 기록해야하는 디코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="21136800dfa96253addc04e09765f4dfaf422034" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing, and always returns &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt;&lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt;&lt;/a&gt;. This method should be overridden by encoders that may need to write final bytes to the output buffer once the entire input sequence has been read.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 작업도 수행하지 않으며 항상 &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt; &lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt; 를&lt;/a&gt; 리턴합니다 . 이 방법은 전체 입력 시퀀스를 읽은 후 최종 버퍼를 출력 버퍼에 기록해야하는 인코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc8af0e398eadda26724c4a515729c005773991" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6356e6ebfa2c78a362b78ff6d4ee7f0de096b5f" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by decoders that maintain internal state.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 내부 상태를 유지하는 디코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1b84f2a9743dc119ac2d3713895968a7add43d0" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the malformed-input action.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 잘못된 입력 조치 변경 사항을 통지해야하는 디코더로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6ce0b265ee419122ec8855546bfd3a2ae99478e" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the replacement.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 교체에 대한 변경 알림이 필요한 디코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="767016fd3314e89124d0d9b043175bc59403ace2" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by decoders that require notification of changes to the unmappable-character action.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 매핑 할 수없는 문자 작업에 대한 변경 사항을 알리는 디코더가이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="12a06e718e61fe0fff9794455337b56a5d988056" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by encoders that maintain internal state.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 내부 상태를 유지하는 인코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8531dcafa5f5a87dfd0a1c5b6f5a56a12c9a4b0" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the malformed-input action.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 잘못된 입력 조치 변경을 통지해야하는 인코더로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="cba512eb19ac0e743b2cded5855b48cf016b8a76" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the replacement.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 교체 변경 알림이 필요한 인코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="55160a40552ceb3074e4b342d9b8cab192478f11" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden by encoders that require notification of changes to the unmappable-character action.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 이 방법은 매핑 할 수없는 문자 작업에 대한 변경 알림이 필요한 인코더로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f460c604725d4b6aad092c435218386e84ad8ab" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden if a refresh operation is supported by the implementation.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 구현에서 새로 고침 작업이 지원되는 경우이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="845fbda2b27759d2fe63c2180337153361a9c337" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing. This method should be overridden if a refresh operation is supported by the policy implementation.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 정책 구현에서 새로 고침 작업을 지원하는 경우이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d81b717bc18ae61e330547009a5491e88ea842f5" translate="yes" xml:space="preserve">
          <source>The default implementation of this method first retrieves the permissions returned via &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt; (the CodeSource is taken from the specified ProtectionDomain), as well as the permissions located inside the specified ProtectionDomain. All of these permissions are then combined and returned in a new PermissionCollection object. If &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt; returns Policy.UNSUPPORTED_EMPTY_COLLECTION, then this method returns the permissions contained inside the specified ProtectionDomain in a new PermissionCollection object.</source>
          <target state="translated">이 메소드의 기본 구현은 먼저 &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt; (CodeSource는 지정된 ProtectionDomain에서 가져옴) 를 통해 리턴 된 권한 및 지정된 ProtectionDomain 내에있는 권한을 검색합니다. 그런 다음 이러한 모든 권한이 결합되어 새 PermissionCollection 객체에 반환됩니다. 경우 &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt; Policy.UNSUPPORTED_EMPTY_COLLECTION을 반환,이 메소드는 새로운 PermissionCollection 객체에 지정된 ProtectionDomain를 내부에 포함 된 권한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1395192a4c2426ed16e9ab647006e2e67dd98144" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in &lt;code&gt;AbstractAnnotationValueVisitor6&lt;/code&gt; will always throw &lt;code&gt;UnknownAnnotationValueException&lt;/code&gt;. This behavior is not required of a subclass.</source>
          <target state="translated">&lt;code&gt;AbstractAnnotationValueVisitor6&lt;/code&gt; 에서이 메소드의 기본 구현 은 항상 &lt;code&gt;UnknownAnnotationValueException&lt;/code&gt; 을 발생 시킵니다. 하위 클래스에는이 동작이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09fc7bca50e027a1531b8ca2a649f2701ed9a9f6" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in &lt;code&gt;AbstractElementVisitor6&lt;/code&gt; will always throw &lt;code&gt;UnknownElementException&lt;/code&gt;. This behavior is not required of a subclass.</source>
          <target state="translated">&lt;code&gt;AbstractElementVisitor6&lt;/code&gt; 에서이 메소드의 기본 구현 은 항상 &lt;code&gt;UnknownElementException&lt;/code&gt; 을 발생 시킵니다. 하위 클래스에는이 동작이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37e48dcb5da9e1384dabbdd038d48c6529719db0" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in &lt;code&gt;AbstractTypeVisitor6&lt;/code&gt; will always throw &lt;code&gt;UnknownTypeException&lt;/code&gt;. This behavior is not required of a subclass.</source>
          <target state="translated">&lt;code&gt;AbstractTypeVisitor6&lt;/code&gt; 에서이 메소드의 기본 구현 은 항상 &lt;code&gt;UnknownTypeException&lt;/code&gt; 을 발생 시킵니다. 하위 클래스에는이 동작이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e7b191d5867ad1062d38b01c93fd704c4b8870c" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling</source>
          <target state="translated">&lt;code&gt;ObjectInputStream&lt;/code&gt; 에서이 메소드의 기본 구현 은 호출 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf3c39f51686e7f6758b61b7cbe168ee9866d63d" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt; objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt; parameter. The &lt;code&gt;Class&lt;/code&gt; object for each interface name &lt;code&gt;i&lt;/code&gt; is the value returned by calling</source>
          <target state="translated">&lt;code&gt;ObjectInputStream&lt;/code&gt; 에서이 메소드의 기본 구현은 &lt;code&gt;interfaces&lt;/code&gt; 매개 변수에 이름이 지정된 인터페이스 의 &lt;code&gt;Class&lt;/code&gt; 오브젝트 목록과 함께 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 를 호출 한 결과를 리턴합니다 . 각 인터페이스 이름 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;Class&lt;/code&gt; 객체 는 다음을 호출하여 반환 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="74859b6ee9bfdad46c83820f3af96fb81266f4fd" translate="yes" xml:space="preserve">
          <source>The default implementation of this method in the superclass does nothing. Subclass implementations should ensure that all resources, especially native resources, are released.</source>
          <target state="translated">수퍼 클래스에서이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 서브 클래스 구현은 모든 자원, 특히 기본 자원이 해제되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a5c155f61f9316dae194ccbc8690f506a0f9f8f" translate="yes" xml:space="preserve">
          <source>The default implementation of this method invokes &lt;a href=&quot;process#destroy--&quot;&gt;&lt;code&gt;destroy()&lt;/code&gt;&lt;/a&gt; and so may not forcibly terminate the process. Concrete implementations of this class are strongly encouraged to override this method with a compliant implementation. Invoking this method on &lt;code&gt;Process&lt;/code&gt; objects returned by &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;ProcessBuilder.start()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime#exec-java.lang.String-&quot;&gt;&lt;code&gt;Runtime.exec(java.lang.String)&lt;/code&gt;&lt;/a&gt; will forcibly terminate the process.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;a href=&quot;process#destroy--&quot;&gt; &lt;code&gt;destroy()&lt;/code&gt; &lt;/a&gt; 호출 하므로 프로세스를 강제로 종료하지 못할 수 있습니다. 이 클래스의 구체적인 구현은이 구현을 준수하는 구현으로 재정의하는 것이 좋습니다. &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;ProcessBuilder.start()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;runtime#exec-java.lang.String-&quot;&gt; &lt;code&gt;Runtime.exec(java.lang.String)&lt;/code&gt; &lt;/a&gt; 리턴 한 &lt;code&gt;Process&lt;/code&gt; 오브젝트 에서이 메소드를 호출하면 프로세스 가 강제 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="67aed0c93c9f92e5f7ddfb736b5a28c91956a767" translate="yes" xml:space="preserve">
          <source>The default implementation of this method is equivalent to</source>
          <target state="translated">이 메소드의 기본 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c2a9154ee3bc4aca50e303f68455f25bb4db4eb" translate="yes" xml:space="preserve">
          <source>The default implementation of this method is not very efficient; it should generally be overridden to improve performance.</source>
          <target state="translated">이 방법의 기본 구현은 그리 효율적이지 않습니다. 일반적으로 성능을 개선하기 위해 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="180883ef0d214bcc583e65a883e7519d97ea4003" translate="yes" xml:space="preserve">
          <source>The default implementation of this method is to return an &lt;code&gt;AccessControlContext&lt;/code&gt; object.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;AccessControlContext&lt;/code&gt; 오브젝트 를 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9d9bb00b9ffb7a7bd61277057d049cff0a056e2" translate="yes" xml:space="preserve">
          <source>The default implementation of this method opens a channel to the file as if by invoking the &lt;a href=&quot;filesystemprovider#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newByteChannel(java.nio.file.Path, java.util.Set&amp;lt;? extends java.nio.file.OpenOption&amp;gt;, java.nio.file.attribute.FileAttribute&amp;lt;?&amp;gt;...)&lt;/code&gt;&lt;/a&gt; method and constructs a stream that reads bytes from the channel. This method should be overridden where appropriate.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;a href=&quot;filesystemprovider#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newByteChannel(java.nio.file.Path, java.util.Set&amp;lt;? extends java.nio.file.OpenOption&amp;gt;, java.nio.file.attribute.FileAttribute&amp;lt;?&amp;gt;...)&lt;/code&gt; &lt;/a&gt; 을 호출하여 java.nio.file.OpenOption&amp;gt;, java.nio.file 을 호출하는 것처럼 파일에 대한 채널을 엽니 다 . attribute.FileAttribute &amp;lt;?&amp;gt; ...) 메소드를 사용하여 채널에서 바이트를 읽는 스트림을 구성합니다. 적절한 경우이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e635d5dffc59dbf2a8230d857d2ff39d849566f0" translate="yes" xml:space="preserve">
          <source>The default implementation of this method opens a channel to the file as if by invoking the &lt;a href=&quot;filesystemprovider#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newByteChannel(java.nio.file.Path, java.util.Set&amp;lt;? extends java.nio.file.OpenOption&amp;gt;, java.nio.file.attribute.FileAttribute&amp;lt;?&amp;gt;...)&lt;/code&gt;&lt;/a&gt; method and constructs a stream that writes bytes to the channel. This method should be overridden where appropriate.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;a href=&quot;filesystemprovider#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newByteChannel(java.nio.file.Path, java.util.Set&amp;lt;? extends java.nio.file.OpenOption&amp;gt;, java.nio.file.attribute.FileAttribute&amp;lt;?&amp;gt;...)&lt;/code&gt; &lt;/a&gt; 을 호출하여 java.nio.file.OpenOption&amp;gt;, java.nio.file 을 호출하는 것처럼 파일에 대한 채널을 엽니 다 . attribute.FileAttribute &amp;lt;?&amp;gt; ...) 메소드를 사용하여 채널에 바이트를 쓰는 스트림을 구성합니다. 적절한 경우이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="27b6bbb57d8319f0d5b942584b1d2260f97ec8d8" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns &lt;code&gt;codebase&lt;/code&gt; unchanged.</source>
          <target state="translated">이 메소드의 기본 구현은 변경되지 않은 &lt;code&gt;codebase&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0279ac968c430844dbb750fe24866fbd667e4c7d" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e1c9e402e3f751b0877055f67d0264d06f524ce5" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1520ed6a69f68296c1cc829610cacf2ae7aef99a" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns Policy.UNSUPPORTED_EMPTY_COLLECTION object. This method can be overridden if the policy implementation can return a set of permissions granted to a CodeSource.</source>
          <target state="translated">이 메소드의 기본 구현은 Policy.UNSUPPORTED_EMPTY_COLLECTION 객체를 반환합니다. 정책 구현이 CodeSource에 부여 된 일련의 권한을 반환 할 수있는 경우이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb6050a1bc2e372f82c2365c1c63f09f8300eac" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns Policy.UNSUPPORTED_EMPTY_COLLECTION object. This method can be overridden if the policy implementation can return a set of permissions granted to a ProtectionDomain.</source>
          <target state="translated">이 메소드의 기본 구현은 Policy.UNSUPPORTED_EMPTY_COLLECTION 객체를 반환합니다. 정책 구현이 ProtectionDomain에 부여 된 일련의 권한을 반환 할 수있는 경우이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3456dc514497d279f977f873718814d5cf316c08" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns Policy.UNSUPPORTED_EMPTY_COLLECTION. This method can be overridden if the policy implementation can return a set of permissions granted to a CodeSource.</source>
          <target state="translated">이 메소드의 기본 구현은 Policy.UNSUPPORTED_EMPTY_COLLECTION을 리턴합니다. 정책 구현이 CodeSource에 부여 된 일련의 권한을 반환 할 수있는 경우이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff397bf1e9c5a559a146f6cda49e448f572bd756" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns the &lt;code&gt;name&lt;/code&gt; parameter. It does nothing else for Standard MBeans. For MXBeans, it records the &lt;code&gt;MBeanServer&lt;/code&gt; and &lt;code&gt;ObjectName&lt;/code&gt; parameters so they can be used to translate inter-MXBean references.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;name&lt;/code&gt; 매개 변수를 리턴합니다 . 표준 MBean에 대해서는 다른 작업을 수행하지 않습니다. MXBean의 경우 &lt;code&gt;MBeanServer&lt;/code&gt; 및 &lt;code&gt;ObjectName&lt;/code&gt; 매개 변수를 기록하여 MXMX 간 참조를 변환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b79e73cf1b5ed928e71581f7254e4f17f3f0c3e" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns the class name of this &lt;code&gt;Calendar&lt;/code&gt; instance. Any subclasses that implement LDML-defined calendar systems should override this method to return appropriate calendar types.</source>
          <target state="translated">이 메서드의 기본 구현은이 &lt;code&gt;Calendar&lt;/code&gt; 인스턴스 의 클래스 이름을 반환합니다 . LDML로 정의 된 달력 시스템을 구현하는 모든 하위 클래스는이 방법을 재정 의하여 적절한 달력 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="be74a20cc90e49c30c1ce02f45baf5365b008f58" translate="yes" xml:space="preserve">
          <source>The default implementation of this method returns true if &lt;code&gt;subject&lt;/code&gt; is non-null and contains at least one principal that is equal to this principal.</source>
          <target state="translated">&lt;code&gt;subject&lt;/code&gt; 가 널이 아니고이 프린시 펄과 동일한 프린시 펄을 하나 이상 포함 하는 경우이 메소드의 기본 구현은 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="81be369eb56b7d67bf7290656729ab294f338416" translate="yes" xml:space="preserve">
          <source>The default implementation of this method simply invokes &lt;a href=&quot;filesystemprovider#delete-java.nio.file.Path-&quot;&gt;&lt;code&gt;delete(java.nio.file.Path)&lt;/code&gt;&lt;/a&gt; ignoring the &lt;code&gt;NoSuchFileException&lt;/code&gt; when the file does not exist. It may be overridden where appropriate.</source>
          <target state="translated">이 메소드의 기본 구현은 파일이 존재하지 않을 때 &lt;code&gt;NoSuchFileException&lt;/code&gt; 을 무시하고 단순히 &lt;a href=&quot;filesystemprovider#delete-java.nio.file.Path-&quot;&gt; &lt;code&gt;delete(java.nio.file.Path)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 적절한 경우 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832a6cca2cbf89c5ad349db3560d7dd67d98f4c7" translate="yes" xml:space="preserve">
          <source>The default implementation of this method simply returns this charset's canonical name. Concrete subclasses of this class may override this method in order to provide a localized display name.</source>
          <target state="translated">이 메소드의 기본 구현은 단순히이 문자 ​​세트의 정식 이름을 리턴합니다. 이 클래스의 구체적 서브 클래스는 지역화 된 표시 이름을 제공하기 위해이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8950dba55ec671c66cd04ea3480734672f47fdf" translate="yes" xml:space="preserve">
          <source>The default implementation of this method throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2f6d32b5f639897a26f98c2e0c5d7c5346de7ddf" translate="yes" xml:space="preserve">
          <source>The default implementation of this method throws an &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d2d17078d58b74ab844ae6a2946c0c40dc1e374" translate="yes" xml:space="preserve">
          <source>The default implementation of this method throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b01e359858be47e68148d12a3da5cbe8164cfe87" translate="yes" xml:space="preserve">
          <source>The default implementation of this method uses &lt;a href=&quot;jmxconnectorservermbean#getAddress--&quot;&gt;&lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jmxconnectorfactory&quot;&gt;&lt;code&gt;JMXConnectorFactory&lt;/code&gt;&lt;/a&gt; to generate the stub, with code equivalent to the following:</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;a href=&quot;jmxconnectorservermbean#getAddress--&quot;&gt; &lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;jmxconnectorfactory&quot;&gt; &lt;code&gt;JMXConnectorFactory&lt;/code&gt; &lt;/a&gt; 를 사용하여 다음과 같은 코드로 스텁을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3448223dcce9d9abf6240417c6688888aa37b783" translate="yes" xml:space="preserve">
          <source>The default implementation of this method uses an iterative algorithm to determine the actual maximum value for the calendar field. Subclasses should, if possible, override this with a more efficient implementation.</source>
          <target state="translated">이 방법의 기본 구현은 반복 알고리즘을 사용하여 달력 필드의 실제 최대 값을 결정합니다. 가능한 경우 서브 클래스는보다 효율적인 구현으로이를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd5056e65c065a85be62f3e220fc274d6d8450ec" translate="yes" xml:space="preserve">
          <source>The default implementation of this method uses an iterative algorithm to determine the actual minimum value for the calendar field. Subclasses should, if possible, override this with a more efficient implementation - in many cases, they can simply return &lt;code&gt;getMinimum()&lt;/code&gt;.</source>
          <target state="translated">이 방법의 기본 구현은 반복 알고리즘을 사용하여 달력 필드의 실제 최소값을 결정합니다. 가능하다면 서브 클래스는보다 효율적인 구현으로이를 재정의해야합니다. 많은 경우에, 단순히 &lt;code&gt;getMinimum()&lt;/code&gt; 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f60fd84474340e106ffa3e318e3b9871bb95ccdb" translate="yes" xml:space="preserve">
          <source>The default implementation of this methods polls the &lt;code&gt;exitValue&lt;/code&gt; to check if the process has terminated. Concrete implementations of this class are strongly encouraged to override this method with a more efficient implementation.</source>
          <target state="translated">이 메소드의 기본 구현은 &lt;code&gt;exitValue&lt;/code&gt; 를 폴링 하여 프로세스가 종료되었는지 확인합니다. 이 클래스의 구체적인 구현은이 방법을보다 효율적인 구현으로 재정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e55ba59172f293a1c293e6f792d51d8e386f4a09" translate="yes" xml:space="preserve">
          <source>The default implementation repeatedly invokes &lt;a href=&quot;spliterator#tryAdvance-java.util.function.Consumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.Consumer&amp;lt;? super T&amp;gt;)&lt;/code&gt;&lt;/a&gt; until it returns &lt;code&gt;false&lt;/code&gt;. It should be overridden whenever possible.</source>
          <target state="translated">기본 구현 은 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 때까지 &lt;a href=&quot;spliterator#tryAdvance-java.util.function.Consumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.Consumer&amp;lt;? super T&amp;gt;)&lt;/code&gt; &lt;/a&gt; 반복적으로 호출합니다 . 가능할 때마다 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa971368436f3447697d4c4bc1fa1a8bc9058ad1" translate="yes" xml:space="preserve">
          <source>The default implementation repeatedly invokes &lt;a href=&quot;spliterator.ofprimitive#tryAdvance-T_CONS-&quot;&gt;&lt;code&gt;tryAdvance(T_CONS)&lt;/code&gt;&lt;/a&gt; until it returns &lt;code&gt;false&lt;/code&gt;. It should be overridden whenever possible.</source>
          <target state="translated">기본 구현 은 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때까지 &lt;a href=&quot;spliterator.ofprimitive#tryAdvance-T_CONS-&quot;&gt; &lt;code&gt;tryAdvance(T_CONS)&lt;/code&gt; &lt;/a&gt; 반복적으로 호출합니다 . 가능할 때마다 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="9805f50cd3a610ec3e5b9d6ba42a1abe18143db8" translate="yes" xml:space="preserve">
          <source>The default implementation resets the compression quality to &lt;code&gt;0.75F&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 압축 품질을 &lt;code&gt;0.75F&lt;/code&gt; 로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fa0ededd27d3b43df7c08265dee4e1dac0291e58" translate="yes" xml:space="preserve">
          <source>The default implementation returns 0 without checking its argument.</source>
          <target state="translated">기본 구현은 인수를 확인하지 않고 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44f08debcebfa65912f9940c51e12d0a5ec7355c" translate="yes" xml:space="preserve">
          <source>The default implementation returns 0.</source>
          <target state="translated">기본 구현은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="525175900b4250ea0a15de5caabdd6dec937c8f6" translate="yes" xml:space="preserve">
          <source>The default implementation returns 0. If the enumeration class (a subclass of class EnumSyntax) uses integer values starting at other than 0, override this method in the subclass.</source>
          <target state="translated">기본 구현은 0을 반환합니다. 열거 클래스 (EnumSyntax 클래스의 서브 클래스)가 0 이외의 정수 값을 사용하는 경우 서브 클래스에서이 메소드를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="8c7eb26e2a4bde791083e2062fd3e853596d4fb2" translate="yes" xml:space="preserve">
          <source>The default implementation returns 3600000 milliseconds (i.e., one hour) if a call to &lt;a href=&quot;timezone#useDaylightTime--&quot;&gt;&lt;code&gt;useDaylightTime()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, 0 (zero) is returned.</source>
          <target state="translated">&lt;a href=&quot;timezone#useDaylightTime--&quot;&gt; &lt;code&gt;useDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 기본 구현은 3600000 밀리 초 (즉, 1 시간 )를 반환 합니다 . 그렇지 않으면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bed40a02370db4a4b689534fb405f887ea85bacf" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;resourcebundle.control#FORMAT_DEFAULT&quot;&gt;&lt;code&gt;FORMAT_DEFAULT&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method looks up first class-based resource bundles, then properties-based ones.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;resourcebundle.control#FORMAT_DEFAULT&quot;&gt; &lt;code&gt;FORMAT_DEFAULT&lt;/code&gt; 를&lt;/a&gt; 반환 하여 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드가 첫 번째 클래스 기반 자원 번들을 찾은 다음 특성 기반 번들을 찾 도록 합니다.</target>
        </trans-unit>
        <trans-unit id="a5d3e0802c1e69202fecfa0848ff568aa916b467" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;resourcebundle.control#TTL_NO_EXPIRATION_CONTROL&quot;&gt;&lt;code&gt;TTL_NO_EXPIRATION_CONTROL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;resourcebundle.control#TTL_NO_EXPIRATION_CONTROL&quot;&gt; &lt;code&gt;TTL_NO_EXPIRATION_CONTROL&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e70df20667e7c6fe7bd94b1c9f99eef6501cba9" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d5b69d455ba66aa15fbd8cbbea3da37b9789c34d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;originatingProvider.getFormatNames()[0]&lt;/code&gt;. Implementations that may not have an originating service provider, or which desire a different naming policy should override this method.</source>
          <target state="translated">기본 구현은 &lt;code&gt;originatingProvider.getFormatNames()[0]&lt;/code&gt; 반환합니다 . 시작 서비스 공급자가 없거나 다른 이름 지정 정책을 원하는 구현은이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5eb7fe7015df0ec71cb44b29af561861ffa9474" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;getNumThumbnails&lt;/code&gt; returns a value greater than 0.</source>
          <target state="translated">&lt;code&gt;getNumThumbnails&lt;/code&gt; 가 0보다 큰 값을 반환 하면 기본 구현은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2a53289ec753ec13903955accdc333e19f0e2bfd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;useDaylightTime()&lt;/code&gt; or &lt;code&gt;inDaylightTime(new Date())&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useDaylightTime()&lt;/code&gt; 또는 &lt;code&gt;inDaylightTime(new Date())&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 기본 구현은 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="e51a840f5afb68faa7a3a9344bd2a4c43bc5ce96" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;getController&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;getController&lt;/code&gt; 메소드가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값을 리턴 하면 기본 구현은 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="d5bd255f8bd6294e34b1cf849d6cb17a4a6dacb2" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;locale&lt;/code&gt; is equal to any of the available &lt;code&gt;Locale&lt;/code&gt;s returned by &lt;a href=&quot;localeserviceprovider#getAvailableLocales--&quot;&gt;&lt;code&gt;getAvailableLocales()&lt;/code&gt;&lt;/a&gt; with ignoring any extensions in both the given &lt;code&gt;locale&lt;/code&gt; and the available locales. Concrete locale service provider implementations should override this method if those implementations are &lt;code&gt;Locale&lt;/code&gt; extensions-aware. For example, &lt;code&gt;DecimalFormatSymbolsProvider&lt;/code&gt; implementations will need to check extensions in the given &lt;code&gt;locale&lt;/code&gt; to see if any numbering system is specified and can be supported. However, &lt;code&gt;CollatorProvider&lt;/code&gt; implementations may not be affected by any particular numbering systems, and in that case, extensions for numbering systems should be ignored.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 이 지정된 &lt;code&gt;locale&lt;/code&gt; 과 사용 가능한 로케일 모두에서 확장을 무시하고 &lt;a href=&quot;localeserviceprovider#getAvailableLocales--&quot;&gt; &lt;code&gt;getAvailableLocales()&lt;/code&gt; &lt;/a&gt; 가 리턴 한 사용 가능한 &lt;code&gt;Locale&lt;/code&gt; 과 동일한 경우 기본 구현은 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다. 구체적인 로케일 서비스 제공자 구현은 해당 구현이 &lt;code&gt;Locale&lt;/code&gt; 확장을 인식 하는 경우이 메소드를 대체해야합니다 . 예를 들어 &lt;code&gt;DecimalFormatSymbolsProvider&lt;/code&gt; 구현은 지정된 &lt;code&gt;locale&lt;/code&gt; 확장명을 확인 하여 번호 시스템이 지정되어 있고 지원 될 수 있는지 확인해야합니다 . 그러나 &lt;code&gt;CollatorProvider&lt;/code&gt; 구현은 특정 번호 시스템의 영향을받지 않을 수 있으며,이 경우 번호 시스템의 확장은 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f26c06bba4e113482890792bd35d73301accad7" translate="yes" xml:space="preserve">
          <source>The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;Locale&lt;/code&gt;s using the rules described below. In the description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt; respectively represent non-empty language, script, country, and variant. For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and country. The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty) language value is &quot;xx&quot;. For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose final component values are empty strings are omitted.</source>
          <target state="translated">기본 구현은 아래에 설명 된 규칙을 사용하여 &lt;code&gt;Locale&lt;/code&gt; 포함 된 &lt;code&gt;List&lt;/code&gt; 를 반환 합니다. 아래 설명에서 &lt;em&gt;L&lt;/em&gt; , &lt;em&gt;S&lt;/em&gt; , &lt;em&gt;C&lt;/em&gt; 및 &lt;em&gt;V는&lt;/em&gt; 각각 비어 있지 않은 언어, 스크립트, 국가 및 변형을 나타냅니다. 예를 들어, [ &lt;em&gt;L&lt;/em&gt; , &lt;em&gt;C&lt;/em&gt; ]는 언어 및 국가에 대해서만 비어 있지 않은 값을 가진 &lt;code&gt;Locale&lt;/code&gt; 을 나타냅니다 . 폼 &lt;em&gt;L&lt;/em&gt; ( &quot;XX&quot;)는 (비어) 언어 값이 &quot;XX&quot;이다 나타낸다. 모든 경우에, 최종 컴포넌트 값이 빈 문자열 인 &lt;code&gt;Locale&lt;/code&gt; 은 생략됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4df76b1a1a841eec548df4a90332710647b34d87" translate="yes" xml:space="preserve">
          <source>The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the keys returned by the &lt;a href=&quot;resourcebundle#getKeys--&quot;&gt;&lt;code&gt;getKeys&lt;/code&gt;&lt;/a&gt; method except for the ones for which the &lt;a href=&quot;resourcebundle#handleGetObject-java.lang.String-&quot;&gt;&lt;code&gt;handleGetObject&lt;/code&gt;&lt;/a&gt; method returns &lt;code&gt;null&lt;/code&gt;. Once the &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can override this method for faster handling.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;resourcebundle#handleGetObject-java.lang.String-&quot;&gt; &lt;code&gt;handleGetObject&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴하는 키를 제외하고 &lt;a href=&quot;resourcebundle#getKeys--&quot;&gt; &lt;code&gt;getKeys&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 키 &lt;code&gt;Set&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;Set&lt;/code&gt; 가 작성 되면 이후 호출에서 동일한 &lt;code&gt;Set&lt;/code&gt; 가 생성되지 않도록 이 &lt;code&gt;ResourceBundle&lt;/code&gt; 에 값이 유지됩니다 . 서브 클래스는보다 빠른 처리를 위해이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f164a65412907e8355a8fbac7eb64cce826fea7" translate="yes" xml:space="preserve">
          <source>The default implementation returns a clone of the &lt;code&gt;availableLocales&lt;/code&gt; instance variable if it is non-&lt;code&gt;null&lt;/code&gt;, or else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;availableLocales&lt;/code&gt; 인스턴스 변수가 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 복제를 반환하거나 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5291c6b504728ff58ad979fd24d2d8150a471209" translate="yes" xml:space="preserve">
          <source>The default implementation returns a clone of the &lt;code&gt;extraImageMetadataFormatNames&lt;/code&gt; instance variable, which is typically set by the constructor.</source>
          <target state="translated">기본 구현은 &lt;code&gt;extraImageMetadataFormatNames&lt;/code&gt; 인스턴스 변수 의 복제본을 반환하며 ,이 변수는 일반적으로 생성자가 설정합니다.</target>
        </trans-unit>
        <trans-unit id="713eac467c3ce45ac50052a65517e6643598b192" translate="yes" xml:space="preserve">
          <source>The default implementation returns a clone of the &lt;code&gt;extraMetadataFormatNames&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;extraMetadataFormatNames&lt;/code&gt; 인스턴스 변수 의 복제본을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4ce1a56176217b8f5598efa1a875c94505a6ac11" translate="yes" xml:space="preserve">
          <source>The default implementation returns a clone of the &lt;code&gt;extraStreamMetadataFormatNames&lt;/code&gt; instance variable, which is typically set by the constructor.</source>
          <target state="translated">기본 구현은 &lt;code&gt;extraStreamMetadataFormatNames&lt;/code&gt; 인스턴스 변수 의 복제본을 반환하며 ,이 변수는 일반적으로 생성자가 설정합니다.</target>
        </trans-unit>
        <trans-unit id="47959ec47d9d64de76ab5b568c249eaabd38f476" translate="yes" xml:space="preserve">
          <source>The default implementation returns an empty &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 빈 &lt;code&gt;Set&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc32cd7a8698071309cf6fa6f784e40739e60c58" translate="yes" xml:space="preserve">
          <source>The default implementation returns an implementation class suitable for most calendar systems. It is based solely on the three units. Normalization, addition and subtraction derive the number of months in a year from the &lt;a href=&quot;chronology#range-java.time.temporal.ChronoField-&quot;&gt;&lt;code&gt;range(ChronoField)&lt;/code&gt;&lt;/a&gt;. If the number of months within a year is fixed, then the calculation approach for addition, subtraction and normalization is slightly different.</source>
          <target state="translated">기본 구현은 대부분의 달력 시스템에 적합한 구현 클래스를 반환합니다. 세 단위에만 기반합니다. 정규화, 덧셈 및 뺄셈은 &lt;a href=&quot;chronology#range-java.time.temporal.ChronoField-&quot;&gt; &lt;code&gt;range(ChronoField)&lt;/code&gt; &lt;/a&gt; 에서 1 년 동안 개월 수를 도출합니다 . 1 년 이내에 개월 수가 고정되어 있으면 더하기, 빼기 및 정규화에 대한 계산 방법이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="583d826e08dd481c47e46fb710129cfb1a0587d1" translate="yes" xml:space="preserve">
          <source>The default implementation returns false.</source>
          <target state="translated">기본 구현은 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6219a3b738876f26259c0a2b1aeea127358a5eb2" translate="yes" xml:space="preserve">
          <source>The default implementation returns null.</source>
          <target state="translated">기본 구현은 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af16238c442909af7ff28025be03d983968464ab" translate="yes" xml:space="preserve">
          <source>The default implementation returns null. If the enumeration class (a subclass of class EnumSyntax) does not override this method to return a non-null enumeration value table, and the subclass does not override the &lt;a href=&quot;enumsyntax#readResolve--&quot;&gt;&lt;code&gt;readResolve()&lt;/code&gt;&lt;/a&gt; method, the base class &lt;a href=&quot;enumsyntax#readResolve--&quot;&gt;&lt;code&gt;readResolve()&lt;/code&gt;&lt;/a&gt; method will throw an exception whenever an enumeration instance is deserialized from an object input stream.</source>
          <target state="translated">기본 구현은 null을 반환합니다. 열거 클래스 (EnumSyntax 클래스의 서브 클래스)가 널이 아닌 열거 값 테이블을 리턴하기 위해이 메소드를 대체하지 않고 서브 클래스가 &lt;a href=&quot;enumsyntax#readResolve--&quot;&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;/a&gt; 메소드를 대체하지 않는 경우 기본 클래스 &lt;a href=&quot;enumsyntax#readResolve--&quot;&gt; &lt;code&gt;readResolve()&lt;/code&gt; &lt;/a&gt; 메소드는 항상 예외를 처리합니다. 열거 인스턴스는 객체 입력 스트림로부터 직렬화 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fa5806bc3fcd2a15aa8e902f4485f05c9e922feb" translate="yes" xml:space="preserve">
          <source>The default implementation returns null. If the enumeration class (a subclass of class EnumSyntax) does not override this method to return a non-null string table, and the subclass does not override the &lt;a href=&quot;enumsyntax#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method, the base class &lt;a href=&quot;enumsyntax#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method will return just a string representation of this enumeration value's integer value.</source>
          <target state="translated">기본 구현은 null을 반환합니다. 열거 클래스 (EnumSyntax 클래스의 서브 클래스)가 널이 아닌 문자열 테이블을 리턴하기 위해이 메소드를 대체하지 않고 서브 클래스가 &lt;a href=&quot;enumsyntax#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드를 대체하지 않는 경우 기본 클래스 &lt;a href=&quot;enumsyntax#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드는 문자열 표현 만 리턴합니다. 이 열거 치의 정 수치</target>
        </trans-unit>
        <trans-unit id="530941e23db8b6df7916e0ba842ac7350b82d756" translate="yes" xml:space="preserve">
          <source>The default implementation returns the &lt;a href=&quot;locale#getDefault--&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;locale&lt;/code&gt; isn't the default one. Otherwise, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 이 기본 로케일 이 아닌 경우 기본 구현은 &lt;a href=&quot;locale#getDefault--&quot;&gt;기본 &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt; 리턴합니다 . 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1285e540c706e34a2fe155a3067b3966189ed8c9" translate="yes" xml:space="preserve">
          <source>The default implementation returns the &lt;code&gt;nativeImageMetadataFormatName&lt;/code&gt; instance variable, which is typically set by the constructor.</source>
          <target state="translated">기본 구현은 기본적 으로 생성자가 설정 한 &lt;code&gt;nativeImageMetadataFormatName&lt;/code&gt; 인스턴스 변수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="56f73985b019d1c94844a80a8e9aace5646ae486" translate="yes" xml:space="preserve">
          <source>The default implementation returns the &lt;code&gt;nativeStreamMetadataFormatName&lt;/code&gt; instance variable, which is typically set by the constructor.</source>
          <target state="translated">기본 구현 은 일반적으로 생성자가 설정 한 &lt;code&gt;nativeStreamMetadataFormatName&lt;/code&gt; 인스턴스 변수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="90f81aed9686112358767822a093ce35a355ec5c" translate="yes" xml:space="preserve">
          <source>The default implementation returns the entire image if &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are 0, or throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;tileX&lt;/code&gt; 와 &lt;code&gt;tileY&lt;/code&gt; 가 0 이면 기본 구현에서 전체 이미지를 반환 하거나 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ec14c9646579f9df4ae3a3fe244de3c99a4055d9" translate="yes" xml:space="preserve">
          <source>The default implementation returns the result of &lt;code&gt;estimateSize()&lt;/code&gt; if the Spliterator reports a characteristic of &lt;code&gt;SIZED&lt;/code&gt;, and &lt;code&gt;-1&lt;/code&gt; otherwise.</source>
          <target state="translated">기본 구현의 결과 반환 &lt;code&gt;estimateSize()&lt;/code&gt; Spliterator이의 특성을보고하는 경우 &lt;code&gt;SIZED&lt;/code&gt; 을 하고, &lt;code&gt;-1&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="1a550ed82a80e8651d37d2cf8005d5123673674d" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;controller&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;controller&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="57a65497f3319fe6b7165fb9a3233f9a7282e0ea" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;defaultController&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;defaultController&lt;/code&gt; 인스턴스 변수 의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="401df454dd8688f1801859319021d8d1b903105b" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;locale&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;locale&lt;/code&gt; 인스턴스 변수 의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2c5f6b03ef3e16194301d12095d1dff542d24662" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;nativeMetadataFormatName&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;nativeMetadataFormatName&lt;/code&gt; 인스턴스 변수 의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4436e20443f28f420184d54b80cb83f51f839bb9" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;originatingProvider&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;originatingProvider&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c487266161ac7323e1f6133662973e6e030a8e21" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;output&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;output&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1e4c3c4ef6d8be32740c7eb9a81d93b4a60a66de" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;standardFormatSupported&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;standardFormatSupported&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d973f8675988369c962159dedc8f1d058d6adefe" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;vendorName&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;vendorName&lt;/code&gt; 인스턴스 변수 의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="62f16b9f22d86fc9c8e5eb99782d71bf161fe610" translate="yes" xml:space="preserve">
          <source>The default implementation returns the value of the &lt;code&gt;version&lt;/code&gt; instance variable.</source>
          <target state="translated">기본 구현은 &lt;code&gt;version&lt;/code&gt; 인스턴스 변수 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d40f76d4d8b18564502261c82c464f86b088246" translate="yes" xml:space="preserve">
          <source>The default implementation returns true if the corresponding bits of the given characteristics are set.</source>
          <target state="translated">주어진 특성의 해당 비트가 설정되면 기본 구현은 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff63705eedf8e97393eaa7bb4cbaaaaf958ca9e0" translate="yes" xml:space="preserve">
          <source>The default implementation sets the &lt;code&gt;controller&lt;/code&gt; instance variable to the supplied value.</source>
          <target state="translated">기본 구현은 &lt;code&gt;controller&lt;/code&gt; 인스턴스 변수를 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="84abf02e2044dda45b808c2e603c2037fc11fc85" translate="yes" xml:space="preserve">
          <source>The default implementation sets the &lt;code&gt;output&lt;/code&gt; instance variable to the value of &lt;code&gt;output&lt;/code&gt; after checking &lt;code&gt;output&lt;/code&gt; against the set of classes advertised by the originating provider, if there is one.</source>
          <target state="translated">기본 구현은 세트 &lt;code&gt;output&lt;/code&gt; 의 값과 인스턴스 변수 &lt;code&gt;output&lt;/code&gt; 확인한 후 &lt;code&gt;output&lt;/code&gt; 존재하는 경우, 발신 제공자가 광고 클래스들의 세트를 대.</target>
        </trans-unit>
        <trans-unit id="9509b98507ddce11729608901728e06782d38720" translate="yes" xml:space="preserve">
          <source>The default implementation sets the &lt;code&gt;progressListeners&lt;/code&gt; instance variable to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;progressListeners&lt;/code&gt; 인스턴스 변수를 &lt;code&gt;null&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="085d9cdf0fb616300bfeace8b3678226146b5b65" translate="yes" xml:space="preserve">
          <source>The default implementation sets the &lt;code&gt;updateListeners&lt;/code&gt; instance variable to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;updateListeners&lt;/code&gt; 인스턴스 변수를 &lt;code&gt;null&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="326a47bc9e4b1ac2be66ed87cce676b9f765a274" translate="yes" xml:space="preserve">
          <source>The default implementation sets the &lt;code&gt;warningListeners&lt;/code&gt; and &lt;code&gt;warningLocales&lt;/code&gt; instance variables to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;warningListeners&lt;/code&gt; 및 &lt;code&gt;warningLocales&lt;/code&gt; 인스턴스 변수를 &lt;code&gt;null&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4ed35ab18cc1e9af75622e4cfef4d008f3a080" translate="yes" xml:space="preserve">
          <source>The default implementation sets the instance variable &lt;code&gt;compressionType&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;, and the instance variable &lt;code&gt;compressionQuality&lt;/code&gt; to &lt;code&gt;1.0F&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 인스턴스 변수 &lt;code&gt;compressionType&lt;/code&gt; 을 &lt;code&gt;null&lt;/code&gt; 로 설정하고 인스턴스 변수 &lt;code&gt;compressionQuality&lt;/code&gt; 를 &lt;code&gt;1.0F&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="588dab97d46c2c545e5800ef6a2fbf51a6d4be03" translate="yes" xml:space="preserve">
          <source>The default implementation sets the instance variables &lt;code&gt;tileWidth&lt;/code&gt;, &lt;code&gt;tileHeight&lt;/code&gt;, &lt;code&gt;tileGridXOffset&lt;/code&gt;, and &lt;code&gt;tileGridYOffset&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 인스턴스 변수 &lt;code&gt;tileWidth&lt;/code&gt; , &lt;code&gt;tileHeight&lt;/code&gt; , &lt;code&gt;tileGridXOffset&lt;/code&gt; 및 &lt;code&gt;tileGridYOffset&lt;/code&gt; 을 &lt;code&gt;0&lt;/code&gt; 으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="16f72f1f6e04f83b068d6afa6833f2f3b3616536" translate="yes" xml:space="preserve">
          <source>The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the &lt;a href=&quot;collection#stream--&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collection#parallelStream--&quot;&gt;&lt;code&gt;parallelStream()&lt;/code&gt;&lt;/a&gt;} methods, spliterators should either have the characteristic of &lt;code&gt;IMMUTABLE&lt;/code&gt; or &lt;code&gt;CONCURRENT&lt;/code&gt;, or be &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the &lt;a href=&quot;collection#stream--&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collection#parallelStream--&quot;&gt;&lt;code&gt;parallelStream()&lt;/code&gt;&lt;/a&gt; methods to create streams using a &lt;code&gt;Supplier&lt;/code&gt; of the spliterator, as in:</source>
          <target state="translated">보다 효율적인 스플리터를 리턴 할 수있는 서브 클래스로 기본 구현을 대체해야합니다. &lt;a href=&quot;collection#stream--&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;collection#parallelStream--&quot;&gt; &lt;code&gt;parallelStream()&lt;/code&gt; &lt;/a&gt; } 메서드에 대해 예상되는 게으름 동작을 유지하려면 스플리터의 특성이 &lt;code&gt;IMMUTABLE&lt;/code&gt; 또는 &lt;code&gt;CONCURRENT&lt;/code&gt; 이거나 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩되어야&lt;/a&gt;&lt;/em&gt; 합니다. 이들 중 어느 것도 실용적이지 않으면 재정의 클래스는 스플리터의 문서화 된 바인딩 및 구조적 간섭 정책을 설명하고 다음 과 같이 스플리터 &lt;code&gt;Supplier&lt;/code&gt; 를 사용하여 스트림을 만들기 위해 &lt;a href=&quot;collection#stream--&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;collection#parallelStream--&quot;&gt; &lt;code&gt;parallelStream()&lt;/code&gt; &lt;/a&gt; 메서드를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33635c4f3f61329896d4977d521fdb0a85471bca" translate="yes" xml:space="preserve">
          <source>The default implementation should usually be overridden. The spliterator returned by the default implementation has poor splitting capabilities, is unsized, and does not report any spliterator characteristics. Implementing classes can nearly always provide a better implementation.</source>
          <target state="translated">기본 구현은 일반적으로 재정의해야합니다. 기본 구현에서 반환 된 스플리터는 분할 기능이 불량하고 크기가 조정되지 않으며 스플리터 특성을보고하지 않습니다. 클래스를 구현하면 거의 항상 더 나은 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5bf9b6840dc44b537c683f20caf0ba6781801f" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns 0, which is correct for non-tiled images and tiled images in most formats. Readers that support tiling with non-(0, 0) offsets should override this method.</source>
          <target state="translated">기본 구현은 단순히 0을 반환하는데, 이는 대부분의 형식에서 타일링되지 않은 이미지와 바둑판 식 이미지에 적합합니다. (0, 0)이 아닌 오프셋으로 타일링을 지원하는 리더는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="83c74b3dea4821e7f0178f2950cdfa2b1671eb34" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;(float)getWidth(imageIndex)/getHeight(imageIndex)&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;(float)getWidth(imageIndex)/getHeight(imageIndex)&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ea212f64b6ea2979e53763518342728cfd8e8a91" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;createReaderInstance(null)&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;createReaderInstance(null)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a99ccb6164f8428ccf2931b77db30dc3db5bbc47" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;createWriterInstance(null)&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;createWriterInstance(null)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="809a2dc37a2f5f2fa1a2d91bb082289500c9bf8e" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;getHeight(imageIndex)&lt;/code&gt;, which is correct for non-tiled images. Readers that support tiling should override this method.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;getHeight(imageIndex)&lt;/code&gt; 않은 이미지에 올바른 getHeight (imageIndex) 를 반환합니다 . 타일링을 지원하는 독자는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f8a27203d188d897d5c3d651db0c17ffc27c6ed" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;getWidth(imageIndex)&lt;/code&gt;, which is correct for non-tiled images. Readers that support tiling should override this method.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;getWidth(imageIndex)&lt;/code&gt; 않은 이미지에 올바른 getWidth (imageIndex) 를 반환합니다 . 타일링을 지원하는 독자는이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b00f0d3fbe6f6b8b36e74726a86f832512832583" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;readThumbnail(imageindex,
 thumbnailIndex).getHeight()&lt;/code&gt;. Subclasses should therefore override this method if possible in order to avoid forcing the thumbnail to be read.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;readThumbnail(imageindex, thumbnailIndex).getHeight()&lt;/code&gt; 를 반환합니다 . 따라서 서브 클래스가 썸네일을 읽지 않도록하려면 가능한 경우이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="1df197fe9dd4eb65dcb16cf450546e91456ce5fb" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns &lt;code&gt;readThumbnail(imageindex,
 thumbnailIndex).getWidth()&lt;/code&gt;. Subclasses should therefore override this method if possible in order to avoid forcing the thumbnail to be read.</source>
          <target state="translated">기본 구현은 단순히 &lt;code&gt;readThumbnail(imageindex, thumbnailIndex).getWidth()&lt;/code&gt; 를 반환합니다 . 따라서 서브 클래스가 썸네일을 읽지 않도록하려면 가능한 경우이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a9ed219c65ea0f44e34f664919c8e2af6fd6f3c" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns the first entry from the list provided by &lt;code&gt;getImageType&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;getImageType&lt;/code&gt; 이 제공 한 목록에서 첫 번째 항목을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="796ec8a94060e7b6d53dd4d48e395de2597b5b2a" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns the result of calling &lt;code&gt;getImageMetadata(imageIndex)&lt;/code&gt;, after checking that the format name is supported. If it is not, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">기본 구현 은 형식 이름이 지원 &lt;code&gt;getImageMetadata(imageIndex)&lt;/code&gt; 확인한 후 getImageMetadata (imageIndex) 호출 결과를 리턴합니다 . 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="da05fa86efb2e3c31060124ac8d2165f81abc3c0" translate="yes" xml:space="preserve">
          <source>The default implementation simply returns the result of calling &lt;code&gt;getStreamMetadata()&lt;/code&gt;, after checking that the format name is supported. If it is not, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">기본 구현 은 형식 이름이 지원 &lt;code&gt;getStreamMetadata()&lt;/code&gt; 확인한 후 getStreamMetadata () 호출 결과를 리턴합니다 . 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="03e3294973b4042249f320b86c7952eaea27b119" translate="yes" xml:space="preserve">
          <source>The default implementation supports display names contained in a &lt;a href=&quot;../text/dateformatsymbols&quot;&gt;&lt;code&gt;DateFormatSymbols&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;field&lt;/code&gt; is &lt;a href=&quot;calendar#MONTH&quot;&gt;&lt;code&gt;MONTH&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;style&lt;/code&gt; is &lt;a href=&quot;calendar#ALL_STYLES&quot;&gt;&lt;code&gt;ALL_STYLES&lt;/code&gt;&lt;/a&gt;, this method returns a &lt;code&gt;Map&lt;/code&gt; containing all strings returned by &lt;a href=&quot;../text/dateformatsymbols#getShortMonths--&quot;&gt;&lt;code&gt;DateFormatSymbols.getShortMonths()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../text/dateformatsymbols#getMonths--&quot;&gt;&lt;code&gt;DateFormatSymbols.getMonths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../text/dateformatsymbols&quot;&gt; &lt;code&gt;DateFormatSymbols&lt;/code&gt; 에&lt;/a&gt; 포함 된 표시 이름을 지원합니다 . 예를 들어, &lt;code&gt;field&lt;/code&gt; 가 &lt;a href=&quot;calendar#MONTH&quot;&gt; &lt;code&gt;MONTH&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;style&lt;/code&gt; 이 &lt;a href=&quot;calendar#ALL_STYLES&quot;&gt; &lt;code&gt;ALL_STYLES&lt;/code&gt; &lt;/a&gt; 인 경우이 메소드는 &lt;a href=&quot;../text/dateformatsymbols#getShortMonths--&quot;&gt; &lt;code&gt;DateFormatSymbols.getShortMonths()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../text/dateformatsymbols#getMonths--&quot;&gt; &lt;code&gt;DateFormatSymbols.getMonths()&lt;/code&gt; &lt;/a&gt; 리턴 한 모든 문자열을 포함 하는 &lt;code&gt;Map&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="757744186a7e79cc3da649ffb40fd0d52df1c8c9" translate="yes" xml:space="preserve">
          <source>The default implementation supports the calendar fields for which a &lt;a href=&quot;../text/dateformatsymbols&quot;&gt;&lt;code&gt;DateFormatSymbols&lt;/code&gt;&lt;/a&gt; has names in the given &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../text/dateformatsymbols&quot;&gt; &lt;code&gt;DateFormatSymbols&lt;/code&gt; &lt;/a&gt; 에 지정된 &lt;code&gt;locale&lt;/code&gt; 이름 이있는 달력 필드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2340b3daf3dba30c4bb3f926b100ace732b22162" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd7e97ec049daba17dfc9519005aabbaac7a9b33" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;. This method is invoked internally only within &lt;a href=&quot;abstractqueuedlongsynchronizer.conditionobject&quot;&gt;&lt;code&gt;AbstractQueuedLongSynchronizer.ConditionObject&lt;/code&gt;&lt;/a&gt; methods, so need not be defined if conditions are not used.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 이 메소드는 &lt;a href=&quot;abstractqueuedlongsynchronizer.conditionobject&quot;&gt; &lt;code&gt;AbstractQueuedLongSynchronizer.ConditionObject&lt;/code&gt; &lt;/a&gt; 메소드 내에서만 내부적으로 호출 되므로 조건을 사용하지 않는 경우에는 정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="566fdb1f29530ad57488a429ddee7bc4b8e63170" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;. This method is invoked internally only within &lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt;&lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt;&lt;/a&gt; methods, so need not be defined if conditions are not used.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 이 메소드는 &lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt; &lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt; &lt;/a&gt; 메소드 내에서만 내부적으로 호출 되므로 조건을 사용하지 않는 경우 정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79b12493bc4f358c0c142065c4a63eac5813c4bc" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;code&gt;DestroyFailedException&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;DestroyFailedException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9b5e7a9ca18c71a04d099bd724a3a0d356ba3366" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="afb68171ba746055d6ca53452d30073c5d3f7754" translate="yes" xml:space="preserve">
          <source>The default implementation throws an &lt;code&gt;IllegalStateException&lt;/code&gt; if the output is &lt;code&gt;null&lt;/code&gt;, and otherwise returns &lt;code&gt;false&lt;/code&gt; without checking the value of &lt;code&gt;imageIndex&lt;/code&gt;.</source>
          <target state="translated">출력이 &lt;code&gt;null&lt;/code&gt; 의 경우는 디폴트 구현은 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 Throw 합니다. 그렇지 않은 경우는 &lt;code&gt;imageIndex&lt;/code&gt; 의 값을 확인하지 않고 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="7ac120a3563328f07bce0df7acd6d29239acefca" translate="yes" xml:space="preserve">
          <source>The default implementation throws an &lt;code&gt;IllegalStateException&lt;/code&gt; if the output is &lt;code&gt;null&lt;/code&gt;, and otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">출력이 &lt;code&gt;null&lt;/code&gt; 의 경우는 디폴트 구현은 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 Throw , 그렇지 않은 경우는 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="0deaa3caf94a726e4720ef14c68c4eece06e4c8a" translate="yes" xml:space="preserve">
          <source>The default implementation throws an &lt;code&gt;IllegalStateException&lt;/code&gt; if the output is &lt;code&gt;null&lt;/code&gt;, and otherwise throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">출력이 &lt;code&gt;null&lt;/code&gt; 의 경우는 디폴트 구현은 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 , 그렇지 않은 경우는 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="4807b6f3376c3b3784645bff86c1c6d59920fae6" translate="yes" xml:space="preserve">
          <source>The default implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="87d9716bfa984a3bcad18139765dddf159844c78" translate="yes" xml:space="preserve">
          <source>The default implementation throws an instance of &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; and performs no other action.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 인스턴스를 throw하고 다른 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="363300b80fc8d4a327f0a3aa5cd28335292795e2" translate="yes" xml:space="preserve">
          <source>The default implementation traverses all elements of the collection using its &lt;a href=&quot;collection#iterator--&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt;. Each matching element is removed using &lt;a href=&quot;iterator#remove--&quot;&gt;&lt;code&gt;Iterator.remove()&lt;/code&gt;&lt;/a&gt;. If the collection's iterator does not support removal then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown on the first matching element.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;collection#iterator--&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 사용하여 컬렉션의 모든 요소를 ​​순회합니다 . 일치하는 각 요소는 &lt;a href=&quot;iterator#remove--&quot;&gt; &lt;code&gt;Iterator.remove()&lt;/code&gt; &lt;/a&gt; 사용하여 제거됩니다 . 컬렉션의 반복자가 제거를 지원하지 않으면 첫 번째 일치하는 요소에서 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a8506e45362d08ce9568d67a3ae99890b28f0b8" translate="yes" xml:space="preserve">
          <source>The default implementation uses &lt;a href=&quot;chronolocaldate#isLeapYear--&quot;&gt;&lt;code&gt;ChronoLocalDate.isLeapYear()&lt;/code&gt;&lt;/a&gt; and returns 365 or 366.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronolocaldate#isLeapYear--&quot;&gt; &lt;code&gt;ChronoLocalDate.isLeapYear()&lt;/code&gt; &lt;/a&gt; 하고 365 또는 366을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57b82ffd52abde3e677246bf8be4d192adddbfba" translate="yes" xml:space="preserve">
          <source>The default implementation uses &lt;a href=&quot;chronolocaldate#isLeapYear--&quot;&gt;&lt;code&gt;isLeapYear()&lt;/code&gt;&lt;/a&gt; and returns 365 or 366.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;chronolocaldate#isLeapYear--&quot;&gt; &lt;code&gt;isLeapYear()&lt;/code&gt; &lt;/a&gt; 하고 365 또는 366을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d61b8113c64fb7663a4c5461e3b048f125d1f3a6" translate="yes" xml:space="preserve">
          <source>The default implementation uses an &lt;a href=&quot;arraylist&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; that overriding implementations may modify before returning it to the caller. However, a subclass must not modify it after it has been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 재정의 구현이 호출자에게 반환하기 전에 수정할 수 있는 &lt;a href=&quot;arraylist&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; 를 사용 합니다. 그러나 &lt;code&gt;getCandidateLocales&lt;/code&gt; 가 서브 클래스를 리턴 한 후에는 서브 클래스를 수정해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4121d6a9a341da3113c28c90f0edcb971e6641ed" translate="yes" xml:space="preserve">
          <source>The default implementation uses reflection to invoke the standard constructor for this type of service. Security providers can override this method to implement instantiation in a different way. For details and the values of constructorParameter that are valid for the various types of services see the  Java Cryptography Architecture API Specification &amp;amp; Reference.</source>
          <target state="translated">기본 구현에서는 리플렉션을 사용하여이 유형의 서비스에 대한 표준 생성자를 호출합니다. 보안 공급자는이 방법을 재정 의하여 인스턴스화를 다른 방식으로 구현할 수 있습니다. 다양한 유형의 서비스에 유효한 constructorParameter의 세부 사항 및 값에 대해서는 Java Cryptography Architecture API 스펙 및 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf10f641341e0eb37678ba3876c5f8ff6f3f3a4e" translate="yes" xml:space="preserve">
          <source>The default implementation will first locate a &lt;code&gt;ResourceBundle&lt;/code&gt; using the current resource base name set by &lt;code&gt;setResourceBaseName&lt;/code&gt; and the supplied &lt;code&gt;Locale&lt;/code&gt;, using the fallback mechanism described in the comments for &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;. If a &lt;code&gt;ResourceBundle&lt;/code&gt; is found, the element name followed by a &quot;/&quot; character followed by the attribute name (&lt;code&gt;elementName + &quot;/&quot; + attrName&lt;/code&gt;) will be used as a key to its &lt;code&gt;getString&lt;/code&gt; method, and the result returned. If no &lt;code&gt;ResourceBundle&lt;/code&gt; is found, or no such key is present, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">기본 구현은 먼저 찾은 것이다 &lt;code&gt;ResourceBundle&lt;/code&gt; 하여 현재 자원 기반 이름 집합 사용 &lt;code&gt;setResourceBaseName&lt;/code&gt; 및 공급 &lt;code&gt;Locale&lt;/code&gt; 에 대한 주석에서 설명한 대체기구 사용 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 의이 . 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 발견되어 소자 이름 속성 명 「/」문자 하였다 ( &lt;code&gt;elementName + &quot;/&quot; + attrName&lt;/code&gt; )의 열쇠로 사용될 &lt;code&gt;getString&lt;/code&gt; 방법 및 결과가 반환. 어떤 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 발견, 또는 그러한 키가 존재하지 않는, &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3848e33cc5aaadfedfa534b9853cb484d489f1" translate="yes" xml:space="preserve">
          <source>The default implementation will first locate a &lt;code&gt;ResourceBundle&lt;/code&gt; using the current resource base name set by &lt;code&gt;setResourceBaseName&lt;/code&gt; and the supplied &lt;code&gt;Locale&lt;/code&gt;, using the fallback mechanism described in the comments for &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;. If a &lt;code&gt;ResourceBundle&lt;/code&gt; is found, the element name will be used as a key to its &lt;code&gt;getString&lt;/code&gt; method, and the result returned. If no &lt;code&gt;ResourceBundle&lt;/code&gt; is found, or no such key is present, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">기본 구현은 먼저 찾은 것이다 &lt;code&gt;ResourceBundle&lt;/code&gt; 하여 현재 자원 기반 이름 집합 사용 &lt;code&gt;setResourceBaseName&lt;/code&gt; 및 공급 &lt;code&gt;Locale&lt;/code&gt; 에 대한 주석에서 설명한 대체기구 사용 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 의이 . 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 발견, 요소 이름은 열쇠로 사용됩니다 &lt;code&gt;getString&lt;/code&gt; 방법 및 결과가 반환. 어떤 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 발견, 또는 그러한 키가 존재하지 않는, &lt;code&gt;null&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d8e722b6c2872cdd0880234c873128a2bac9a8a8" translate="yes" xml:space="preserve">
          <source>The default implementation, calls the &lt;code&gt;initialize&lt;/code&gt; method of the type's superclass.</source>
          <target state="translated">기본 구현 은 유형의 수퍼 클래스 의 &lt;code&gt;initialize&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a609ae1178482f89fd3a3e6c3a664c702d5f2372" translate="yes" xml:space="preserve">
          <source>The default implementation, which explains typical resolve behaviour, is provided in &lt;a href=&quot;abstractchronology&quot;&gt;&lt;code&gt;AbstractChronology&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 해결 동작을 설명하는 기본 구현은 &lt;a href=&quot;abstractchronology&quot;&gt; &lt;code&gt;AbstractChronology&lt;/code&gt; &lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a75241ad421aa6838be3b0e7f091e001ddc0e4e7" translate="yes" xml:space="preserve">
          <source>The default is -1, which means the packer will always create a single segment output file. In cases where extremely large output files are generated, users are strongly encouraged to use segmenting or break up the input file into smaller JARs.</source>
          <target state="translated">기본값은 -1이며, 패커는 항상 단일 세그먼트 출력 파일을 작성합니다. 매우 큰 출력 파일이 생성되는 경우 사용자는 입력 파일을 더 작은 JAR로 분할하거나 분할하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="262f0c0ca2ca77ae719addf88cdd09ee4b4cb09d" translate="yes" xml:space="preserve">
          <source>The default is 5, investing a modest amount of time to produce reasonable compression.</source>
          <target state="translated">기본값은 5이며, 적당한 압축을 위해 적당한 시간을 투자합니다.</target>
        </trans-unit>
        <trans-unit id="15461d064a1287ffe97e7c92de29748b5a8d3403" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;pack200.packer#KEEP&quot;&gt;&lt;code&gt;KEEP&lt;/code&gt;&lt;/a&gt;, which preserves the input information, but may cause the transmitted archive to be larger than necessary.</source>
          <target state="translated">기본값은 입력 정보를 유지하지만 전송 된 아카이브가 필요 이상으로 커질 수있는 &lt;a href=&quot;pack200.packer#KEEP&quot;&gt; &lt;code&gt;KEEP&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="995e43ed08f0c352b0b3da09b56d5bc0be0cf00f" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;pack200.packer#TRUE&quot;&gt;&lt;code&gt;TRUE&lt;/code&gt;&lt;/a&gt;, which preserves the input information, but may cause the transmitted archive to be larger than necessary.</source>
          <target state="translated">기본값은 &lt;a href=&quot;pack200.packer#TRUE&quot;&gt; &lt;code&gt;TRUE&lt;/code&gt; &lt;/a&gt; 이며 입력 정보는 유지하지만 전송 된 아카이브가 필요 이상으로 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784ca0180973adfba5c92e31eea0967211dd6ca0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f4165b0eefbc9206203d6c87fff4a6726bef578b" translate="yes" xml:space="preserve">
          <source>The default keystore type can be changed by setting the value of the &lt;code&gt;keystore.type&lt;/code&gt; security property to the desired keystore type.</source>
          <target state="translated">&lt;code&gt;keystore.type&lt;/code&gt; security 특성 값을 원하는 키 저장소 유형 으로 설정하여 기본 키 저장소 유형을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4c736504e183c1a916a63a8f6737eed0fa497a" translate="yes" xml:space="preserve">
          <source>The default keystore type can be used by applications that do not want to use a hard-coded keystore type when calling one of the &lt;code&gt;getInstance&lt;/code&gt; methods, and want to provide a default keystore type in case a user does not specify its own.</source>
          <target state="translated">기본 키 저장소 유형은 &lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 호출 할 때 하드 코드 된 키 저장소 유형을 사용하지 않고 사용자가 고유 한 키 저장소 유형을 제공 하지 않으려는 경우 응용 프로그램에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="951c81fd610ec5d817f5f091469118671a67331b" translate="yes" xml:space="preserve">
          <source>The default method implementations (inherited or otherwise) do not apply any synchronization protocol. If a &lt;code&gt;Collection&lt;/code&gt; implementation has a specific synchronization protocol, then it must override default implementations to apply that protocol.</source>
          <target state="translated">기본 메소드 구현 (상속되거나 다른 방식으로)은 동기화 프로토콜을 적용하지 않습니다. 경우 &lt;code&gt;Collection&lt;/code&gt; 구현은 특정 동기화 프로토콜을 가지고, 그것은 그 프로토콜을 적용하는 기본 구현을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c5a9dec31f4fd826d16ff0e5fefee4737538a6" translate="yes" xml:space="preserve">
          <source>The default method name is &quot;new&quot;.</source>
          <target state="translated">기본 메소드 이름은 &quot;new&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5921f0e5e747e700cdba877924262940728c035b" translate="yes" xml:space="preserve">
          <source>The default policy is to allow access to PUBLIC members, as well as access to classes that have the same class loader as the caller. In all other cases, this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;accessDeclaredMembers&quot;)
 &lt;/code&gt; permission.</source>
          <target state="translated">기본 정책은 PUBLIC 멤버 및 호출자와 클래스 로더가 동일한 클래스에 대한 액세스를 허용하는 것입니다. 다른 모든 경우에이 메소드 는 &lt;code&gt;RuntimePermission(&quot;accessDeclaredMembers&quot;) &lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="68b19e3d21765f69f41bd0585951690681bbd053" translate="yes" xml:space="preserve">
          <source>The default priority that is assigned to a thread.</source>
          <target state="translated">스레드에 지정된 기본 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="e2d3a9991fe4ff7fe03b248ed7222e0f4d9b8a66" translate="yes" xml:space="preserve">
          <source>The default provider provides a similar &lt;em&gt;round-trip&lt;/em&gt; guarantee to the &lt;a href=&quot;../../io/file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; class. For a given &lt;code&gt;Path&lt;/code&gt;</source>
          <target state="translated">기본 공급자는 &lt;a href=&quot;../../io/file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 클래스 와 유사한 &lt;em&gt;왕복&lt;/em&gt; 보증을 제공합니다 . 주어진 &lt;code&gt;Path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2dd252b637b95e299f5a35c05983ea8110ca8eb" translate="yes" xml:space="preserve">
          <source>The default proxy selector does enforce a set of System Properties related to proxy settings.</source>
          <target state="translated">기본 프록시 선택기는 프록시 설정과 관련된 일련의 시스템 속성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="5ef1430c0a6be359fcfcb60ed6a55e10d76a1755" translate="yes" xml:space="preserve">
          <source>The default serialization mechanism for an object writes the class of the object, the class signature, and the values of all non-transient and non-static fields. References to other objects (except in transient or static fields) cause those objects to be written also. Multiple references to a single object are encoded using a reference sharing mechanism so that graphs of objects can be restored to the same shape as when the original was written.</source>
          <target state="translated">객체의 기본 직렬화 메커니즘은 객체의 클래스, 클래스 서명 및 모든 비 일시적 필드와 비 정적 필드의 값을 씁니다. 다른 객체에 대한 참조 (일시적 또는 정적 필드 제외)로 인해 해당 객체도 작성됩니다. 단일 객체에 대한 여러 참조는 참조 공유 메커니즘을 사용하여 인코딩되므로 객체의 그래프를 원본을 쓸 때와 같은 모양으로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32637bb0ba9b4568fd20589a70ef634007051ac" translate="yes" xml:space="preserve">
          <source>The default size of the pipe's circular input buffer.</source>
          <target state="translated">파이프 원형 입력 버퍼의 기본 크기입니다.</target>
        </trans-unit>
        <trans-unit id="113957ad271a9b5c1e40fbcfa11f18e16ce344d3" translate="yes" xml:space="preserve">
          <source>The default system class loader is an implementation-dependent instance of this class.</source>
          <target state="translated">기본 시스템 클래스 로더는이 클래스의 구현 종속 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="a8b05e1e858df06ac67c65d5405fc793b170340e" translate="yes" xml:space="preserve">
          <source>The default value comes from followRedirects, which defaults to true.</source>
          <target state="translated">기본값은 followRedirects에서 가져 오며 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="e518b624add89d75b6c3f3b203b751145bb030cb" translate="yes" xml:space="preserve">
          <source>The default value for this array is implementation-dependent, e.g. Sun implementation initially sets to {&quot;sun.beans.editors&quot;}.</source>
          <target state="translated">이 어레이의 기본값은 구현에 따라 다릅니다. 예를 들어 Sun 구현은 초기에 { &quot;sun.beans.editors&quot;}로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d1a992846527a1b81eead2d3524c3954a2bdda" translate="yes" xml:space="preserve">
          <source>The default value of the active on/off flag is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">활성화 된 on / off 플래그의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4f434b29b06a94502c33c2afdd2c1eade4cde38" translate="yes" xml:space="preserve">
          <source>The default value of the granularity period is 10 seconds.</source>
          <target state="translated">세분성 기간의 기본값은 10 초입니다.</target>
        </trans-unit>
        <trans-unit id="a533f343e61fe6cce66d559689bdc3e773dbc87a" translate="yes" xml:space="preserve">
          <source>The default value of the past notifications sending on/off flag is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">과거 / 이전 알림 전송 켜기 / 끄기 플래그의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43ea81b0f5e78d14e99345bd7715e17f32bfb853" translate="yes" xml:space="preserve">
          <source>The default value of this field is &lt;code&gt;0&lt;/code&gt;, indicating that the fetching must always occur.</source>
          <target state="translated">이 필드의 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 페치가 항상 발생해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="34407862fb456a39cfdd224ab9faf20b775a0cee" translate="yes" xml:space="preserve">
          <source>The default value of this field is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 필드의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e314ce2a42ca129dfaf2cef8414e47e543b7cfb8" translate="yes" xml:space="preserve">
          <source>The default value of this field is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 필드의 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="972b6959cc09449e8ac91ab30aa149e60c64d106" translate="yes" xml:space="preserve">
          <source>The default value of this socket option is &lt;code&gt;FALSE&lt;/code&gt;. The socket option should only be enabled in cases where it is known that the coalescing impacts performance. The socket option may be enabled at any time. In other words, the Nagle Algorithm can be disabled. Once the option is enabled, it is system dependent whether it can be subsequently disabled. If it cannot, then invoking the &lt;code&gt;setOption&lt;/code&gt; method to disable the option has no effect.</source>
          <target state="translated">이 소켓 옵션의 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다. 통합 옵션이 성능에 영향을 미치는 것으로 알려진 경우에만 소켓 옵션을 사용해야합니다. 소켓 옵션은 언제든지 활성화 될 수 있습니다. 즉, Nagle 알고리즘을 비활성화 할 수 있습니다. 옵션이 활성화되면 나중에 비활성화 할 수 있는지 여부는 시스템에 따라 다릅니다. &lt;code&gt;setOption&lt;/code&gt; 하면, setOption 메소드를 호출 하여 옵션을 비활성화 해도 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f263e9163c5170e98fc380a13f245f08fed92fcf" translate="yes" xml:space="preserve">
          <source>The default value of this variable is the value of the URL argument in the &lt;code&gt;URLConnection&lt;/code&gt; constructor.</source>
          <target state="translated">이 변수의 기본값은 &lt;code&gt;URLConnection&lt;/code&gt; 생성자 의 URL 인수 값입니다 .</target>
        </trans-unit>
        <trans-unit id="2e41a02212a6983a97c5d2784f949cc6515db3fa" translate="yes" xml:space="preserve">
          <source>The default values are used for locale and time zone if these parameters haven't been given explicitly.</source>
          <target state="translated">이러한 매개 변수를 명시 적으로 지정하지 않은 경우 기본값은 로캘 및 표준 시간대에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d6243a4db1d53f508b92879981b4ab37f22d8e" translate="yes" xml:space="preserve">
          <source>The default values of security properties are read from an implementation-specific location, which is typically the properties file &lt;code&gt;lib/security/java.security&lt;/code&gt; in the Java installation directory.</source>
          <target state="translated">보안 특성의 기본값은 구현 별 위치에서 읽습니다. 일반적으로 Java 설치 디렉토리 의 특성 파일 &lt;code&gt;lib/security/java.security&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a61917a3186488cd9a2bac20f1fa15923bedac55" translate="yes" xml:space="preserve">
          <source>The defaults are:</source>
          <target state="translated">기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ac4b8e3f813351f8ea9005cdbeffd201d69d04" translate="yes" xml:space="preserve">
          <source>The definition of &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; is the same for all calendar systems, thus it can be used for conversion.</source>
          <target state="translated">&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 의 정의는 모든 달력 시스템에서 동일하므로 변환에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc53d844d5dcb0b2342d79cd2a2b18ae8c5916b0" translate="yes" xml:space="preserve">
          <source>The definitions are the same in the two cases, except that with the MXBean, &lt;code&gt;MemoryUsage&lt;/code&gt; no longer needs to be marked &lt;code&gt;Serializable&lt;/code&gt; (though it can be). On the other hand, we have added a &lt;code&gt;@ConstructorProperties&lt;/code&gt; annotation to link the constructor parameters to the corresponding getters. We will see more about this below.</source>
          <target state="translated">MXBean의 경우 &lt;code&gt;MemoryUsage&lt;/code&gt; 를 더 이상 &lt;code&gt;Serializable&lt;/code&gt; 로 표시 할 필요가 없다는 점을 제외하고 두 가지 경우 모두 정의가 동일합니다 . 반면에 생성자 매개 변수를 해당 게터에 연결하기 위해 &lt;code&gt;@ConstructorProperties&lt;/code&gt; 주석을 추가했습니다 . 우리는 이것에 대해 아래에서 더 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="2e7b3c7b50f30ab95b1f9b75e5ea9e1a831e4144" translate="yes" xml:space="preserve">
          <source>The definitions of the rule elements is as follows:</source>
          <target state="translated">규칙 요소의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c901310db86132ac5a2d60bead838f92de2f9706" translate="yes" xml:space="preserve">
          <source>The deflation hint of a ZIP or JAR element indicates whether the element was deflated or stored directly.</source>
          <target state="translated">ZIP 또는 JAR 요소의 수축 힌트는 요소가 수축되었는지 또는 직접 저장되었는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3467a6619cc41595188d0a0e5221f37b84b7f994" translate="yes" xml:space="preserve">
          <source>The degree of completion is expressed as a percentage varying from &lt;code&gt;0.0F&lt;/code&gt; to &lt;code&gt;100.0F&lt;/code&gt;. The percentage should ideally be calculated in terms of the remaining time to completion, but it is usually more practical to use a more well-defined metric such as pixels decoded or portion of input stream consumed. In any case, a sequence of calls to this method during a given read operation should supply a monotonically increasing sequence of percentage values. It is not necessary to supply the exact values &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt;, as these may be inferred by the callee from other methods.</source>
          <target state="translated">완성의 정도의 변화 비율로 표현된다 &lt;code&gt;0.0F&lt;/code&gt; 에 &lt;code&gt;100.0F&lt;/code&gt; . 백분율은 남은 완료 시간 측면에서 이상적으로 계산해야하지만 일반적으로 디코딩 된 픽셀 또는 입력 스트림의 일부와 같이보다 잘 정의 된 메트릭을 사용하는 것이 더 실용적입니다. 어쨌든, 주어진 읽기 작업 동안이 메소드에 대한 일련의 호출은 백분율 값의 단조 증가 시퀀스를 제공해야합니다. 다른 값들 로부터 수신자에 의해 추론 될 수 있기 때문에, 정확한 값 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;100&lt;/code&gt; 을 제공 할 필요는 없다 .</target>
        </trans-unit>
        <trans-unit id="2ffdf631cc74ed2ac1117237bc13b5422364570f" translate="yes" xml:space="preserve">
          <source>The degree of completion is expressed as an index indicating which image is being written, and a percentage varying from &lt;code&gt;0.0F&lt;/code&gt; to &lt;code&gt;100.0F&lt;/code&gt; indicating how much of the current image has been output. The percentage should ideally be calculated in terms of the remaining time to completion, but it is usually more practical to use a more well-defined metric such as pixels decoded or portion of input stream consumed. In any case, a sequence of calls to this method during a given read operation should supply a monotonically increasing sequence of percentage values. It is not necessary to supply the exact values &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt;, as these may be inferred by the callee from other methods.</source>
          <target state="translated">완성도가 기록되고있는 화상을 나타내는 인덱스로부터 변화 비율로 표현된다 &lt;code&gt;0.0F&lt;/code&gt; 에 &lt;code&gt;100.0F&lt;/code&gt; 출력 된 방법과 현재 영상의 대부분 나타낸다. 백분율은 완료까지 남은 시간과 관련하여 이상적으로 계산해야하지만 일반적으로 디코딩 된 픽셀 또는 소비 된 입력 스트림의 일부와 같이보다 잘 정의 된 메트릭을 사용하는 것이 더 실용적입니다. 어쨌든, 주어진 읽기 작업 동안이 메소드에 대한 일련의 호출은 백분율 값의 단조 증가 시퀀스를 제공해야합니다. 다른 값들 로부터 수신자에 의해 추론 될 수 있기 때문에, 정확한 값 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;100&lt;/code&gt; 을 제공 할 필요는 없다 .</target>
        </trans-unit>
        <trans-unit id="622a976524ed481d2754b97f7a5bad4bec7f5898" translate="yes" xml:space="preserve">
          <source>The derived gauge for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 MBean가 감시 MBean 세트에있는 경우, 지정된 MBean 파생 게이지 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ea7deb1e8589b725bd49a88de4713e9844734a5" translate="yes" xml:space="preserve">
          <source>The derived gauge of the specified object.</source>
          <target state="translated">지정된 객체의 파생 게이지.</target>
        </trans-unit>
        <trans-unit id="ab2e53105c7c016ee5ef4c432335811e13095204" translate="yes" xml:space="preserve">
          <source>The derived gauge timestamp for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 MBean가 감시 대상의 MBean 세트에있는 경우, 지정된 MBean의 파생 게이지 타임 스탬프 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918d0ea45853df33982f469ba8e883d71c15cad9" translate="yes" xml:space="preserve">
          <source>The derived gauge timestamp of the specified object.</source>
          <target state="translated">지정된 객체의 파생 게이지 타임 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="b8628a54ca7d03acc7fca1476c826bfdbf381af3" translate="yes" xml:space="preserve">
          <source>The derived gauge timestamp.</source>
          <target state="translated">파생 된 게이지 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="47e0873d39cb4d938084449ff57e1ed328ee5697" translate="yes" xml:space="preserve">
          <source>The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">파생 게이지 값 (V [t])은 다음 방법을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a738d9e1b4632ee603b2672dbe53af96c180022b" translate="yes" xml:space="preserve">
          <source>The derived gauge.</source>
          <target state="translated">파생 게이지.</target>
        </trans-unit>
        <trans-unit id="6e2b2b219b70436ddff91fb78a9791c602594fa8" translate="yes" xml:space="preserve">
          <source>The description of a security service.</source>
          <target state="translated">보안 서비스에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="9eb3b0b493c05d5f164212704ce4ac88339de729" translate="yes" xml:space="preserve">
          <source>The description of a security service. It encapsulates the properties of a service and contains a factory method to obtain new implementation instances of this service.</source>
          <target state="translated">보안 서비스에 대한 설명입니다. 서비스의 속성을 캡슐화하고이 서비스의 새로운 구현 인스턴스를 얻기위한 팩토리 메소드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="969469f11a23e8de53e48ff12aacf7f0460ef420" translate="yes" xml:space="preserve">
          <source>The description of the error</source>
          <target state="translated">오류에 대한 설명</target>
        </trans-unit>
        <trans-unit id="ea41313256c5230eea46e12afb4c4f1ebd86e07b" translate="yes" xml:space="preserve">
          <source>The description returned by &lt;a href=&quot;mbeaninfo#getDescription--&quot;&gt;&lt;code&gt;getDescription()&lt;/code&gt;&lt;/a&gt; and the descriptions of the contained attributes and operations are not specified.</source>
          <target state="translated">&lt;a href=&quot;mbeaninfo#getDescription--&quot;&gt; &lt;code&gt;getDescription()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 설명 및 포함 된 속성 및 조작에 대한 설명이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c3b81e61c0a6a08ad74e75183195b7a367b8c01e" translate="yes" xml:space="preserve">
          <source>The descriptions should be localized for the &lt;code&gt;Locale&lt;/code&gt; returned by &lt;code&gt;getLocale&lt;/code&gt;, if it is non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">설명이 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;getLocale&lt;/code&gt; 의 경우는, getLocale 에 의해 돌려 주어진 &lt;code&gt;Locale&lt;/code&gt; 에 대한 설명을 현지화 할 필요가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="344a0689fe209e6b771f1512c673e6d6a695ac56" translate="yes" xml:space="preserve">
          <source>The design of the API encourages the use of &lt;code&gt;LocalDate&lt;/code&gt; rather than this interface, even in the case where the application needs to deal with multiple calendar systems.</source>
          <target state="translated">응용 프로그램이 여러 달력 시스템을 처리해야하는 경우에도 API 디자인은 이 인터페이스 대신 &lt;code&gt;LocalDate&lt;/code&gt; 를 사용하도록 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="ba11f2c8ae2cc526f50b83b31dfd781fb499060a" translate="yes" xml:space="preserve">
          <source>The design of the API encourages the use of &lt;code&gt;LocalDateTime&lt;/code&gt; rather than this interface, even in the case where the application needs to deal with multiple calendar systems. The rationale for this is explored in detail in &lt;a href=&quot;chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램이 여러 달력 시스템을 처리해야하는 경우에도 API 디자인은 이 인터페이스 대신 &lt;code&gt;LocalDateTime&lt;/code&gt; 을 사용하도록 권장합니다 . 이에 대한 이론적 근거는 &lt;a href=&quot;chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4098159590d5a0be0ade361e674cb64f25bf4478" translate="yes" xml:space="preserve">
          <source>The design of the API encourages the use of &lt;code&gt;ZonedDateTime&lt;/code&gt; rather than this interface, even in the case where the application needs to deal with multiple calendar systems. The rationale for this is explored in detail in &lt;a href=&quot;chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램이 여러 달력 시스템을 처리해야하는 경우에도 API 디자인은 이 인터페이스 대신 &lt;code&gt;ZonedDateTime&lt;/code&gt; 을 사용하도록 권장합니다 . 이에 대한 이론적 근거는 &lt;a href=&quot;chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7998624e98208d9dca9c1f843311127f0c1df866" translate="yes" xml:space="preserve">
          <source>The desired rendering width and height of the source, if &lt;code&gt;canSetSourceRenderSize&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;canSetSourceRenderSize&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 소스의 원하는 렌더링 폭과 높이 또는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aefa9bbde256c3b0f7ea7830535fda90978d6d12" translate="yes" xml:space="preserve">
          <source>The destination for the output</source>
          <target state="translated">출력 대상</target>
        </trans-unit>
        <trans-unit id="f08645b6db1ebe7d6424f30f2504cbbedb0c2fdb" translate="yes" xml:space="preserve">
          <source>The destination of the formatted output is a &lt;a href=&quot;../lang/stringbuilder&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/a&gt; which may be retrieved by invoking &lt;a href=&quot;formatter#out--&quot;&gt;&lt;code&gt;out()&lt;/code&gt;&lt;/a&gt; and whose current content may be converted into a string by invoking &lt;a href=&quot;formatter#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식화 된 출력의 대상은 &lt;a href=&quot;formatter#out--&quot;&gt; &lt;code&gt;out()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 검색 할 수 있고 &lt;a href=&quot;formatter#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 을 호출하여 현재 컨텐츠를 문자열로 변환 할 수 있는 &lt;a href=&quot;../lang/stringbuilder&quot;&gt; &lt;code&gt;StringBuilder&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="5922b766b3984cfed20c7a5e5693f7ca47586ff2" translate="yes" xml:space="preserve">
          <source>The destination of the formatted output is a &lt;a href=&quot;../lang/stringbuilder&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/a&gt; which may be retrieved by invoking &lt;a href=&quot;formatter#out--&quot;&gt;&lt;code&gt;out()&lt;/code&gt;&lt;/a&gt; and whose current content may be converted into a string by invoking &lt;a href=&quot;formatter#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;. The locale used is the &lt;a href=&quot;locale#getDefault-java.util.Locale.Category-&quot;&gt;default locale&lt;/a&gt; for &lt;a href=&quot;locale.category#FORMAT&quot;&gt;formatting&lt;/a&gt; for this instance of the Java virtual machine.</source>
          <target state="translated">형식화 된 출력의 대상은 &lt;a href=&quot;formatter#out--&quot;&gt; &lt;code&gt;out()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 검색 할 수 있고 &lt;a href=&quot;formatter#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 을 호출하여 현재 컨텐츠를 문자열로 변환 할 수 있는 &lt;a href=&quot;../lang/stringbuilder&quot;&gt; &lt;code&gt;StringBuilder&lt;/code&gt; &lt;/a&gt; 입니다 . 사용되는 로케일은,이다 &lt;a href=&quot;locale#getDefault-java.util.Locale.Category-&quot;&gt;기본 로케일&lt;/a&gt; 에 대한 &lt;a href=&quot;locale.category#FORMAT&quot;&gt;서식&lt;/a&gt; 이 Java 가상 머신 인스턴스.</target>
        </trans-unit>
        <trans-unit id="c0f3d8e39e4a15746121302a291d05298071f204" translate="yes" xml:space="preserve">
          <source>The destination region is specified in the &lt;code&gt;param&lt;/code&gt; argument, and will be clipped to the image boundaries and the region supplied to &lt;code&gt;prepareReplacePixels&lt;/code&gt;. At least one pixel of the source must not be clipped, or an exception is thrown.</source>
          <target state="translated">대상 영역은 &lt;code&gt;param&lt;/code&gt; 인수에 지정되며 이미지 경계 및 &lt;code&gt;prepareReplacePixels&lt;/code&gt; 제공된 영역에 잘립니다 . 소스의 적어도 하나의 픽셀이 잘리지 않아야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c64195340f2b1561568956b9b738819b8d888742" translate="yes" xml:space="preserve">
          <source>The details as to how the name of the directory is constructed is implementation dependent and therefore not specified. Where possible the &lt;code&gt;prefix&lt;/code&gt; is used to construct candidate names.</source>
          <target state="translated">디렉토리 이름의 구성 방법에 대한 세부 사항은 구현에 따라 다르므로 지정되지 않았습니다. 가능한 경우 &lt;code&gt;prefix&lt;/code&gt; 가 후보 이름을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13e3105ecc501e450654c55ee27633db720c9d10" translate="yes" xml:space="preserve">
          <source>The details as to how the name of the file is constructed is implementation dependent and therefore not specified. Where possible the &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;suffix&lt;/code&gt; are used to construct candidate names in the same manner as the &lt;a href=&quot;../../io/file#createTempFile-java.lang.String-java.lang.String-java.io.File-&quot;&gt;&lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일 이름 구성 방법에 대한 세부 사항은 구현에 따라 다르므로 지정되지 않았습니다. 가능한 경우 &lt;code&gt;prefix&lt;/code&gt; 와 &lt;code&gt;suffix&lt;/code&gt; 가 &lt;a href=&quot;../../io/file#createTempFile-java.lang.String-java.lang.String-java.io.File-&quot;&gt; &lt;code&gt;File.createTempFile(String,String,File)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 후보 이름을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cba2519f0b1ce3a070aa5dd7763ad3ccf86e3d3" translate="yes" xml:space="preserve">
          <source>The device has a media jam.</source>
          <target state="translated">장치에 용지가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="66006232695e41b5c6ac636adf56ec27c7ce85e4" translate="yes" xml:space="preserve">
          <source>The device is low on at least one marker supply (e.g. toner, ink, ribbon).</source>
          <target state="translated">장치에 하나 이상의 마커 공급 장치 (예 : 토너, 잉크, 리본)가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="29f9dd9acfd7460a5bb63ab5fd2c2a3e3198166d" translate="yes" xml:space="preserve">
          <source>The device is low on developer.</source>
          <target state="translated">기기의 개발자가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="542e2763c0b2510c401d46d8fd95e8dc50a4b179" translate="yes" xml:space="preserve">
          <source>The device is low on toner.</source>
          <target state="translated">토너가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="2d766fd6e4a64bf066ff0d6e551d91bfb267900f" translate="yes" xml:space="preserve">
          <source>The device is out of at least one marker supply (e.g. toner, ink, ribbon).</source>
          <target state="translated">장치에 하나 이상의 마커 공급 장치 (예 : 토너, 잉크, 리본)가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa7f3afbbcec8442a53aed2b81e4cca4e3c5e7ee" translate="yes" xml:space="preserve">
          <source>The device is out of developer.</source>
          <target state="translated">장치에 개발자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9003dae5dc55c7520c1913a281ed7b8f4138a6f3" translate="yes" xml:space="preserve">
          <source>The device is out of toner.</source>
          <target state="translated">토너가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="016818b5f80841ea367578651504c2c2e67f0f01" translate="yes" xml:space="preserve">
          <source>The device marker supply waste receptacle is almost full.</source>
          <target state="translated">장치 마커 공급 쓰레기통이 거의 찼습니다.</target>
        </trans-unit>
        <trans-unit id="f9002b26167422aebb9a8d3912d0ce925b8b97e0" translate="yes" xml:space="preserve">
          <source>The device marker supply waste receptacle is full.</source>
          <target state="translated">장치 마커 공급 폐기물 리셉터클이 가득 찼습니다.</target>
        </trans-unit>
        <trans-unit id="69c893e55c76bdf9733ed371bb8a202b8b6db89e" translate="yes" xml:space="preserve">
          <source>The dialog may include a tab panel with custom UI lazily obtained from the PrintService's ServiceUIFactory when the PrintService is browsed. The dialog will attempt to locate a MAIN_UIROLE first as a JComponent, then as a Panel. If there is no ServiceUIFactory or no matching role the custom tab will be empty or not visible.</source>
          <target state="translated">대화 상자에는 PrintService를 찾아 볼 때 PrintService의 ServiceUIFactory에서 느리게 가져온 사용자 정의 UI가있는 탭 패널이 포함될 수 있습니다. 대화 상자는 먼저 MAIN_UIROLE을 JComponent로 찾은 다음 Panel로 찾으려고합니다. ServiceUIFactory가 없거나 일치하는 역할이 없으면 사용자 정의 탭이 비어 있거나 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cc399a15b8f756f5185fc205b17982999412260" translate="yes" xml:space="preserve">
          <source>The dialog returns the print service selected by the user if the user OK's the dialog and null if the user cancels the dialog.</source>
          <target state="translated">대화 상자는 사용자가 대화 상자를 확인한 경우 사용자가 선택한 인쇄 서비스를 반환하고 사용자가 대화 상자를 취소하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="579f01e86dd6699ada620aefc1c7afb266adc891" translate="yes" xml:space="preserve">
          <source>The dialogs are designed to work with pluggable print services though the public APIs of those print services.</source>
          <target state="translated">대화 상자는 해당 인쇄 서비스의 공용 API를 통해 플러그 가능한 인쇄 서비스와 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="db3841cda9fb9966f1d8587166f67225d1444f8b" translate="yes" xml:space="preserve">
          <source>The dialogs follow a standard pattern of acting as a continue/cancel option for a user as well as allowing the user to select the print service to use and specify choices such as paper size and number of copies.</source>
          <target state="translated">대화 상자는 사용자가 계속 / 취소 옵션으로 작동하는 표준 패턴을 따르며 사용자가 사용할 인쇄 서비스를 선택하고 용지 크기 및 매수와 같은 선택을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c96480009197f705592107a5cb718405cd00f4db" translate="yes" xml:space="preserve">
          <source>The difference between the 'standard' and 'stand-alone' forms is trickier to describe as there is no difference in English. However, in other languages there is a difference in the word used when the text is used alone, as opposed to in a complete date. For example, the word used for a month when used alone in a date picker is different to the word used for month in association with a day and year in a date.</source>
          <target state="translated">'표준'양식과 '독립형'양식의 차이점은 영어에는 차이가 없으므로 설명하기가 더 까다 롭습니다. 그러나 다른 언어에서는 완전한 날짜가 아닌 텍스트를 단독으로 사용할 때 사용되는 단어에 차이가 있습니다. 예를 들어, 날짜 선택기에서 단독으로 사용될 때 한 달에 사용 된 단어는 날짜의 일 및 연도와 관련하여 월에 사용 된 단어와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d40a3fc423cd4e4ebf79f443777971ee6f079eed" translate="yes" xml:space="preserve">
          <source>The difference between the three sizes is obvious in most languages. For example, in English the 'full' month is 'January', the 'short' month is 'Jan' and the 'narrow' month is 'J'. Note that the narrow size is often not unique. For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.</source>
          <target state="translated">세 가지 크기의 차이는 대부분의 언어에서 분명합니다. 예를 들어 영어에서 '전체'달은 '1 월'이고 '짧은'달은 '1 월'이며 '좁은'달은 'J'입니다. 좁은 크기는 종종 고유하지 않습니다. 예를 들어 'January', 'June'및 'July'는 모두 '좁은'텍스트 'J'를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8d01b8818c08d858b2ee09d956697424edc75b8c" translate="yes" xml:space="preserve">
          <source>The difference in values between &lt;code&gt;floorMod&lt;/code&gt; and the &lt;code&gt;%&lt;/code&gt; operator is due to the difference between &lt;code&gt;floorDiv&lt;/code&gt; that returns the integer less than or equal to the quotient and the &lt;code&gt;/&lt;/code&gt; operator that returns the integer closest to zero.</source>
          <target state="translated">&lt;code&gt;floorMod&lt;/code&gt; 와 &lt;code&gt;%&lt;/code&gt; 연산자 의 값 차이 는 몫보다 작거나 같은 정수를 반환하는 &lt;code&gt;floorDiv&lt;/code&gt; 와 0에 가장 가까운 정수를 반환하는 &lt;code&gt;/&lt;/code&gt; 연산자 의 차이로 인해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7586d3a365a4d67c1c9b505b682867dabb42cd40" translate="yes" xml:space="preserve">
          <source>The differences between &lt;code&gt;IIOMetadataFormat&lt;/code&gt;-described structures and DTDs are as follows:</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 기술 구조와 DTD 의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae28aa9bd9bde2c9ea45602f28fc04b20eab977c" translate="yes" xml:space="preserve">
          <source>The differences between this format and the standard UTF-8 format are the following:</source>
          <target state="translated">이 형식과 표준 UTF-8 형식의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="443467df3062dda08fb61c5f1f09b1961e943d03" translate="yes" xml:space="preserve">
          <source>The digit-to-character mapping provided by &lt;code&gt;Character.forDigit&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Character.forDigit&lt;/code&gt; 에서 제공하는 숫자-문자 매핑 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdabe34d95ee2b49e101157e361587437533a830" translate="yes" xml:space="preserve">
          <source>The digits &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt;),</source>
          <target state="translated">숫자 &lt;code&gt;'0'&lt;/code&gt; ~ &lt;code&gt;'9'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f6c9c6a6e7be02e6daeaaa0b692f02eddae01f71" translate="yes" xml:space="preserve">
          <source>The directory service interface, containing methods for examining and updating attributes associated with objects, and for searching the directory.</source>
          <target state="translated">디렉토리 서비스 인터페이스. 오브젝트와 연관된 속성을 검사 및 업데이트하고 디렉토리를 검색하는 메소드가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="03bddf843ccf72f679cd306d4d5724dee75cbf6b" translate="yes" xml:space="preserve">
          <source>The disjunction of the two arguments. The returned object will be serialized as an instance of the non-public class  javax.management.OrQueryExp.</source>
          <target state="translated">두 주장의 분리. 리턴 된 오브젝트는 비 공용 클래스 javax.management.OrQueryExp의 인스턴스로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="70b0bf684f9d37699ae21723515abb62707cc192" translate="yes" xml:space="preserve">
          <source>The display name of this charset in the default locale</source>
          <target state="translated">기본 로케일에서이 문자 세트의 표시 이름</target>
        </trans-unit>
        <trans-unit id="f0d028866b466d6a1b80e5ff746a3a47c46f64b5" translate="yes" xml:space="preserve">
          <source>The display name of this charset in the given locale</source>
          <target state="translated">지정된 로케일에서이 문자 세트의 표시 이름</target>
        </trans-unit>
        <trans-unit id="6558e5722111fb8030f8f035b9e1182199e1e238" translate="yes" xml:space="preserve">
          <source>The distinction has other effects. Serializing the &lt;code&gt;ZoneId&lt;/code&gt; will only send the ID, whereas serializing the rules sends the entire data set. Similarly, a comparison of two IDs only examines the ID, whereas a comparison of two rules examines the entire data set.</source>
          <target state="translated">구별은 다른 영향을 미칩니다. &lt;code&gt;ZoneId&lt;/code&gt; 를 직렬화하면 ID 만 전송되고 규칙을 직렬화하면 전체 데이터 세트가 전송됩니다. 마찬가지로 두 ID를 비교하면 ID 만 검사하지만 두 규칙을 비교하면 전체 데이터 세트를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="38a85796cc6ed5c1cec11291d1d7b83212a9375d" translate="yes" xml:space="preserve">
          <source>The division type of the MIDI file.</source>
          <target state="translated">MIDI 파일의 분할 형식입니다.</target>
        </trans-unit>
        <trans-unit id="869f1e09781f53f737dbed3b4023e5a59ef687d7" translate="yes" xml:space="preserve">
          <source>The doc flavor's representation class is a conduit for the JPS &lt;code&gt;DocPrintJob&lt;/code&gt; to obtain a sequence of characters or bytes from the client. The doc flavor's MIME type is one of the standard media types telling how to interpret the sequence of characters or bytes. For a list of standard media types, see the Internet Assigned Numbers Authority's (IANA's) &lt;a href=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;Media Types Directory&lt;/a&gt;. Interface &lt;a href=&quot;doc&quot;&gt;&lt;code&gt;Doc&lt;/code&gt;&lt;/a&gt; provides two utility operations, &lt;a href=&quot;doc#getReaderForText--&quot;&gt;&lt;code&gt;getReaderForText&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;doc#getStreamForBytes--&quot;&gt;&lt;code&gt;getStreamForBytes()&lt;/code&gt;&lt;/a&gt;, to help a &lt;code&gt;Doc&lt;/code&gt; object's client extract client formatted print data.</source>
          <target state="translated">doc 플레이버의 표현 클래스는 JPS &lt;code&gt;DocPrintJob&lt;/code&gt; 이 클라이언트로부터 일련의 문자 또는 바이트를 얻기 위한 통로입니다 . doc 후 레이 바의 MIME 유형은 문자 또는 바이트 시퀀스를 해석하는 방법을 알려주는 표준 미디어 유형 중 하나입니다. 표준 미디어 유형 목록은 IANA (Internet Assigned Numbers Authority) &lt;a href=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;미디어 유형 디렉토리를 참조하십시오&lt;/a&gt; . &lt;a href=&quot;doc&quot;&gt; &lt;code&gt;Doc&lt;/code&gt; &lt;/a&gt; 인터페이스 는 &lt;code&gt;Doc&lt;/code&gt; 객체의 클라이언트가 클라이언트 형식의 인쇄 데이터를 추출 할 수 있도록 &lt;a href=&quot;doc#getReaderForText--&quot;&gt; &lt;code&gt;getReaderForText&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;doc#getStreamForBytes--&quot;&gt; &lt;code&gt;getStreamForBytes()&lt;/code&gt; &lt;/a&gt; 두 가지 유틸리티 작업을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a3636bed168062a4be7658e3dce8cd0ecc826622" translate="yes" xml:space="preserve">
          <source>The doc's print data representation object is obtained. Then, an input stream for reading the print data from the print data representation object as a stream of bytes is created and returned. However, if the print data representation object is itself an input stream then the print data representation object is simply returned.</source>
          <target state="translated">문서의 인쇄 데이터 표현 객체가 취득됩니다. 그리고, 바이트 스트림으로서 인쇄 데이터 표현 객체로부터 인쇄 데이터를 판독하기위한 입력 스트림이 생성되어 리턴된다. 그러나, 인쇄 데이터 표현 객체 자체가 입력 스트림 인 경우, 인쇄 데이터 표현 객체가 단순히 반환된다.</target>
        </trans-unit>
        <trans-unit id="3f91aaed4e96bb3e312b02c04ea2422a5607a8e3" translate="yes" xml:space="preserve">
          <source>The doc's print data representation object is used to construct and return a &lt;code&gt;Reader&lt;/code&gt; for reading the print data as a stream of characters from the print data representation object. However, if the print data representation object is itself a &lt;code&gt;Reader&lt;/code&gt; then the print data representation object is simply returned.</source>
          <target state="translated">이 문서의 인쇄 데이터 표현 객체는 인쇄 데이터 표현 객체 로부터 인쇄 데이터를 문자 스트림으로서 판독하기위한 &lt;code&gt;Reader&lt;/code&gt; 를 구성 및 반환하는데 사용됩니다 . 그러나 인쇄 데이터 표현 객체 자체가 &lt;code&gt;Reader&lt;/code&gt; 인 경우 인쇄 데이터 표현 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="86be973af863aa4f1edbeefcc60b36166183116f" translate="yes" xml:space="preserve">
          <source>The doc's print data representation object is used to construct and return a Reader for reading the print data as a stream of characters from the print data representation object. However, if the print data representation object is itself a Reader, then the print data representation object is simply returned.</source>
          <target state="translated">이 문서의 인쇄 데이터 표현 객체는 인쇄 데이터 표현 객체로부터 인쇄 데이터를 문자 스트림으로서 판독하기위한 리더를 구성 및 반환하는데 사용됩니다. 그러나 인쇄 데이터 표현 객체 자체가 Reader 인 경우 인쇄 데이터 표현 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4346f386d24938e54c58e824844367e8315c425a" translate="yes" xml:space="preserve">
          <source>The document cis completely printed.</source>
          <target state="translated">문서 cis가 완전히 인쇄되었습니다.</target>
        </trans-unit>
        <trans-unit id="e1e1e129521668afdfb0bc599e4c0a4a6401e2bf" translate="yes" xml:space="preserve">
          <source>The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.</source>
          <target state="translated">이 클래스의 각 비추 상 메소드에 대한 문서는 해당 구현을 자세히 설명합니다. 구현되고있는 콜렉션이보다 효율적인 구현을 인정하는 경우, 이러한 각 메소드를 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c064c790f850928f176a0eed5acdd1dac84be16" translate="yes" xml:space="preserve">
          <source>The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation.</source>
          <target state="translated">이 클래스의 각 비추 상 메소드에 대한 문서는 해당 구현을 자세히 설명합니다. 구현중인 맵이보다 효율적인 구현을 허용하는 경우 이러한 각 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e25aacee17cd879d32cfcd3e2fabaae73ccff4" translate="yes" xml:space="preserve">
          <source>The documentation for the methods contained in this class includes briefs description of the</source>
          <target state="translated">이 클래스에 포함 된 메소드에 대한 문서에는 간략한 설명이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebdb4d98b88e2c546269aeb62054e235e5938f82" translate="yes" xml:space="preserve">
          <source>The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the</source>
          <target state="translated">이 클래스에 포함 된 다형성 알고리즘에 대한 설명서에는 일반적으로</target>
        </trans-unit>
        <trans-unit id="e1e1db6291b1775b87fec76a01adaa51114c3dd8" translate="yes" xml:space="preserve">
          <source>The domain name and the type key property in the &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;a href=&quot;garbagecollectormxbean&quot;&gt;&lt;code&gt;GarbageCollectorMXBean&lt;/code&gt;&lt;/a&gt;. The unique &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; can be formed by appending this string with &quot;&lt;code&gt;,name=&lt;/code&gt;</source>
          <target state="translated">도메인 이름과의 형 키 속성 &lt;code&gt;ObjectName&lt;/code&gt; A에 대한 &lt;a href=&quot;garbagecollectormxbean&quot;&gt; &lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; &lt;/a&gt; . 고유 &lt;code&gt;ObjectName&lt;/code&gt; A에 대한 &lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; 는 &quot;이 문자열을 추가하여 형성 될 수있다 &lt;code&gt;,name=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264fa33727dd99c3d72ccf4cdfba08ce5446f92f" translate="yes" xml:space="preserve">
          <source>The domain name and the type key property in the &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;a href=&quot;memorymanagermxbean&quot;&gt;&lt;code&gt;MemoryManagerMXBean&lt;/code&gt;&lt;/a&gt;. The unique &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;code&gt;MemoryManagerMXBean&lt;/code&gt; can be formed by appending this string with &quot;&lt;code&gt;,name=&lt;/code&gt;</source>
          <target state="translated">도메인 이름과의 형 키 속성 &lt;code&gt;ObjectName&lt;/code&gt; A의 &lt;a href=&quot;memorymanagermxbean&quot;&gt; &lt;code&gt;MemoryManagerMXBean&lt;/code&gt; 의&lt;/a&gt; . 고유 &lt;code&gt;ObjectName&lt;/code&gt; A의 &lt;code&gt;MemoryManagerMXBean&lt;/code&gt; 의는 &quot;이 문자열을 추가하여 형성 될 수있다 &lt;code&gt;,name=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ede1ca279c5f59b6e4da4ff4353367bbe5352a3c" translate="yes" xml:space="preserve">
          <source>The domain name and the type key property in the &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;a href=&quot;memorypoolmxbean&quot;&gt;&lt;code&gt;MemoryPoolMXBean&lt;/code&gt;&lt;/a&gt;. The unique &lt;code&gt;ObjectName&lt;/code&gt; for a &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; can be formed by appending this string with &lt;code&gt;,name=&lt;/code&gt;</source>
          <target state="translated">도메인 이름과의 형 키 속성 &lt;code&gt;ObjectName&lt;/code&gt; A에 대한 &lt;a href=&quot;memorypoolmxbean&quot;&gt; &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 의&lt;/a&gt; . 고유 &lt;code&gt;ObjectName&lt;/code&gt; A의 &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 의이 이 문자열을 추가하여 형성 할 수있다 &lt;code&gt;,name=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8158d808147de732c43a706f28d52f744973dc6c" translate="yes" xml:space="preserve">
          <source>The domain.</source>
          <target state="translated">도메인.</target>
        </trans-unit>
        <trans-unit id="a65b7c0c36803800708cedb0df8738ed9f04e50e" translate="yes" xml:space="preserve">
          <source>The double at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 더블</target>
        </trans-unit>
        <trans-unit id="bb422b89f341960d85df8d0d85c2bf012d8bd2f9" translate="yes" xml:space="preserve">
          <source>The double at the given index</source>
          <target state="translated">주어진 인덱스에서 더블</target>
        </trans-unit>
        <trans-unit id="7544f4bd4a98eece8837aaf5ef9e0593ff2a0e95" translate="yes" xml:space="preserve">
          <source>The double value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치의 double 값</target>
        </trans-unit>
        <trans-unit id="f2a46aa41603b7c65b26cfad50f5d84de1e81b27" translate="yes" xml:space="preserve">
          <source>The double value at the given index</source>
          <target state="translated">주어진 인덱스의 double 값</target>
        </trans-unit>
        <trans-unit id="adde14f4d575069814d1f552f1044bb344825c01" translate="yes" xml:space="preserve">
          <source>The doubles between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the double at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 두 배 (있는 경우)는 버퍼의 시작 부분에 복사됩니다. 즉, 인덱스의 이중</target>
        </trans-unit>
        <trans-unit id="22e2f67d5a85f4f389e5c72a2bba9662f61ae9ab" translate="yes" xml:space="preserve">
          <source>The duration amount is measured in terms of the specified unit. Only a subset of units are accepted by this method. The unit must either have an &lt;a href=&quot;temporal/temporalunit#isDurationEstimated--&quot;&gt;exact duration&lt;/a&gt; or be &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;ChronoUnit.DAYS&lt;/code&gt;&lt;/a&gt; which is treated as 24 hours. Other units throw an exception.</source>
          <target state="translated">지속 시간은 지정된 단위로 측정됩니다. 이 방법에서는 단위의 하위 집합 만 허용됩니다. 단위는 &lt;a href=&quot;temporal/temporalunit#isDurationEstimated--&quot;&gt;정확한 기간을&lt;/a&gt; 갖거나 24 시간으로 처리되는 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;ChronoUnit.DAYS&lt;/code&gt; &lt;/a&gt; 여야합니다 . 다른 부대는 예외를 던진다.</target>
        </trans-unit>
        <trans-unit id="6abef57b0f93c82e44d47ecad7e94788f986c7d1" translate="yes" xml:space="preserve">
          <source>The duration is measured in &quot;seconds&quot;, but these are not necessarily identical to the scientific &quot;SI second&quot; definition based on atomic clocks. This difference only impacts durations measured near a leap-second and should not affect most applications. See &lt;a href=&quot;instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; for a discussion as to the meaning of the second and time-scales.</source>
          <target state="translated">지속 시간은 &quot;초&quot;로 측정되지만 원자 시계를 기반으로 한 과학적인 &quot;SI 초&quot;정의와 반드시 동일하지는 않습니다. 이 차이는 윤초 근처에서 측정 된 지속 시간에만 영향을 미치며 대부분의 응용 프로그램에는 영향을 미치지 않습니다. 초와 시간 척도의 의미에 대한 설명 은 &lt;a href=&quot;instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8204922d650956e148f922400129f8214b214218" translate="yes" xml:space="preserve">
          <source>The duration of the MIDI file in microseconds.</source>
          <target state="translated">MIDI 파일의 지속 시간 (마이크로 초)</target>
        </trans-unit>
        <trans-unit id="46c748aebf80472386e07211c6f120afd16ad95e" translate="yes" xml:space="preserve">
          <source>The effect of a Copies attribute with a value of</source>
          <target state="translated">값이 Copies 인 속성의 효과</target>
        </trans-unit>
        <trans-unit id="99c81a32e6fe7d95ef738fc6e5197a05ba683765" translate="yes" xml:space="preserve">
          <source>The effect of a Finishings attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same binding specified or whether different docs have different bindings specified, and on the (perhaps defaulted) value of the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">다중 문서 인쇄 작업 (여러 문서가있는 작업)에서 Finishings 속성의 효과는 모든 문서에 동일한 바인딩이 지정되어 있는지 또는 다른 문서에 다른 바인딩이 지정되어 있는지 여부 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성 의 (기본값) 값에 따라 다릅니다. .</target>
        </trans-unit>
        <trans-unit id="ca28a91fe647ee89563cea14ff3cd42c9c4abad6" translate="yes" xml:space="preserve">
          <source>The effect of a JobSheets attribute on multidoc print jobs (jobs with multiple documents) may be affected by the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; job attribute, depending on the meaning of the particular JobSheets value.</source>
          <target state="translated">다중 문서 인쇄 작업 (여러 문서가있는 작업)에 대한 JobSheets 속성의 영향 은 특정 JobSheets 값의 의미에 따라 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 작업 속성의 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dab0b65cd15fe15dc69345c7a99597f70822a1d" translate="yes" xml:space="preserve">
          <source>The effect of a NumberUp attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same number up values specified or whether different docs have different number up values specified, and on the (perhaps defaulted) value of the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">다중 문서 인쇄 작업 (여러 문서가있는 작업)에 대한 NumberUp 속성의 효과는 모든 문서에 동일한 번호 설정 값이 지정되어 있는지 또는 다른 문서에 다른 번호 설정 값이 지정되어 있는지 (그리고 아마도 기본값) 값에 따라 달라집니다 의 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="70dd2fd6d028415bf0d583d7e912b5a74d86f7de" translate="yes" xml:space="preserve">
          <source>The effect of a PageRanges attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same page ranges specified or whether different docs have different page ranges specified, and on the (perhaps defaulted) value of the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">다중 문서 인쇄 작업 (여러 문서가있는 작업)에서 PageRanges 속성의 효과는 모든 문서에 동일한 페이지 범위가 지정되어 있는지 또는 다른 문서에 다른 페이지 범위가 지정되어 있는지 여부 및 (기본값) 값에 따라 다릅니다. &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="331d96f910fe20a1bc1e50c890418b0b106bcc13" translate="yes" xml:space="preserve">
          <source>The effect of a SheetCollate attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same sheet collation specified or whether different docs have different sheet collations specified, and on the (perhaps defaulted) value of the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">다중 문서 인쇄 작업 (여러 문서가있는 작업)에 대한 SheetCollate 속성의 영향은 모든 문서에 동일한 시트 데이터 정렬이 지정되어 있는지 또는 다른 문서에 다른 시트 데이터 정렬이 지정되어 있는지 여부 및 기본값 (기본값)에 따라 다릅니다. &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="ac6b72215081f38ac969887ef91e4267f38b1a3a" translate="yes" xml:space="preserve">
          <source>The effect of a Sides attribute on a multidoc print job (a job with multiple documents) depends on whether all the docs have the same sides values specified or whether different docs have different sides values specified, and on the (perhaps defaulted) value of the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">복수 문서 인쇄 작업 (여러 문서가있는 작업)에 대한면 속성의 효과는 모든 문서에 동일한면 값이 지정되어 있는지 또는 다른 문서에 다른면 값이 지정되어 있는지 여부 및 기본값 (기본값)에 따라 다릅니다. &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="6829b6046ec27924944931d65a75557aac43dc72" translate="yes" xml:space="preserve">
          <source>The effect of calling this constructor is the same as calling &lt;code&gt;ScriptEngineManager(Thread.currentThread().getContextClassLoader())&lt;/code&gt;.</source>
          <target state="translated">이 생성자를 호출하면 &lt;code&gt;ScriptEngineManager(Thread.currentThread().getContextClassLoader())&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8f05da664002548278889e82bb2f048a8b692ad3" translate="yes" xml:space="preserve">
          <source>The effect of this method is identical to that of the &lt;a href=&quot;bigdecimal#plus-java.math.MathContext-&quot;&gt;&lt;code&gt;plus(MathContext)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드의 효과는 &lt;a href=&quot;bigdecimal#plus-java.math.MathContext-&quot;&gt; &lt;code&gt;plus(MathContext)&lt;/code&gt; &lt;/a&gt; 메소드 의 효과와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="240610244ce46db1d65c39b9ece6d3e1892f2aea" translate="yes" xml:space="preserve">
          <source>The effect of this method is identical to that of the &lt;a href=&quot;bigdecimal#round-java.math.MathContext-&quot;&gt;&lt;code&gt;round(MathContext)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드의 효과는 &lt;a href=&quot;bigdecimal#round-java.math.MathContext-&quot;&gt; &lt;code&gt;round(MathContext)&lt;/code&gt; &lt;/a&gt; 메소드 의 효과와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b0a1f54a3aa4b4cc5dbf26335398ce36efb240bd" translate="yes" xml:space="preserve">
          <source>The effective host name that derives from the request-host does not domain-match the Domain attribute.</source>
          <target state="translated">요청 호스트에서 파생 된 유효 호스트 이름이 도메인 속성과 도메인 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8528845c5c4df26720cbcf625a610c0d09f4d337" translate="yes" xml:space="preserve">
          <source>The elements in the returned array are not sorted and are not in any particular order.</source>
          <target state="translated">반환 된 배열의 요소는 정렬되지 않으며 특정 순서가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4747e5a9fa1beb70aa3841d35d6509a1676789ff" translate="yes" xml:space="preserve">
          <source>The elements of the returned iterator are the &lt;a href=&quot;filestore&quot;&gt;&lt;code&gt;FileStores&lt;/code&gt;&lt;/a&gt; for this file system. The order of the elements is not defined and the file stores may change during the lifetime of the Java virtual machine. When an I/O error occurs, perhaps because a file store is not accessible, then it is not returned by the iterator.</source>
          <target state="translated">리턴 된 반복자의 요소는 이 파일 시스템의 파일 &lt;a href=&quot;filestore&quot;&gt; &lt;code&gt;FileStores&lt;/code&gt; &lt;/a&gt; 입니다. 요소의 순서는 정의되어 있지 않으며 파일 저장소는 Java 가상 머신의 수명 동안 변경 될 수 있습니다. 파일 저장소에 액세스 할 수 없기 때문에 I / O 오류가 발생하면 반복자에 의해 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a60448268f4f78f386f7f84f2c5f1a05d7a5a619" translate="yes" xml:space="preserve">
          <source>The elements of the stream are &lt;a href=&quot;path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; objects that are obtained as if by &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolving&lt;/code&gt;&lt;/a&gt; the name of the directory entry against &lt;code&gt;dir&lt;/code&gt;. Some file systems maintain special links to the directory itself and the directory's parent directory. Entries representing these links are not included.</source>
          <target state="translated">스트림의 요소는 &lt;code&gt;dir&lt;/code&gt; 에 대한 디렉토리 항목의 이름을 &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolving&lt;/code&gt; &lt;/a&gt; 하여 얻은 것처럼 &lt;a href=&quot;path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 객체입니다 . 일부 파일 시스템은 디렉토리 자체와 디렉토리의 상위 디렉토리에 대한 특수 링크를 유지합니다. 이러한 링크를 나타내는 항목은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbc2ae2f21b51f8bf47adefd8539ccb40f888682" translate="yes" xml:space="preserve">
          <source>The elements returned by the iterator are in no specific order. Some file systems maintain special links to the directory itself and the directory's parent directory. Entries representing these links are not returned by the iterator.</source>
          <target state="translated">반복자가 반환 한 요소는 특정 순서가 아닙니다. 일부 파일 시스템은 디렉토리 자체와 디렉토리의 상위 디렉토리에 대한 특수 링크를 유지합니다. 이 링크를 나타내는 항목은 반복자가 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9ef353251d48288ffd3652f1f37c47124f1b9d2" translate="yes" xml:space="preserve">
          <source>The embedded code constructs &lt;code&gt;(?{&lt;/code&gt;</source>
          <target state="translated">임베디드 코드는 &lt;code&gt;(?{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0c2d1ad066e6739f583f355da9a4f5e3e8c69ad" translate="yes" xml:space="preserve">
          <source>The embedded comment syntax &lt;code&gt;(?#comment)&lt;/code&gt;, and</source>
          <target state="translated">포함 된 주석 구문 &lt;code&gt;(?#comment)&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="6a88bf55348203ef6e9f6286a971b3e85a1f2f13" translate="yes" xml:space="preserve">
          <source>The emitted notification.</source>
          <target state="translated">생성 된 알림.</target>
        </trans-unit>
        <trans-unit id="0cb0b0d6ef2409e36ed9fe34e19950b0163a49d3" translate="yes" xml:space="preserve">
          <source>The empty list (immutable). This list is serializable.</source>
          <target state="translated">빈리스트 (불변) 이 목록은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88137698e00d8f0652a82fe6508b16749429979f" translate="yes" xml:space="preserve">
          <source>The empty map (immutable). This map is serializable.</source>
          <target state="translated">빈 맵 (불변). 이 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="180ebf25843521d97d4f2d04fea45f85b9208bbe" translate="yes" xml:space="preserve">
          <source>The empty set (immutable). This set is serializable.</source>
          <target state="translated">빈 세트 (불변) 이 세트는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="04710e8ea7ef328080b66f61a16fa7d06fca71ab" translate="yes" xml:space="preserve">
          <source>The empty spliterator reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;. Calls to &lt;a href=&quot;spliterator#trySplit--&quot;&gt;&lt;code&gt;Spliterator.trySplit()&lt;/code&gt;&lt;/a&gt; always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">빈 spliterator 보고서 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; 을&lt;/a&gt; . &lt;a href=&quot;spliterator#trySplit--&quot;&gt; &lt;code&gt;Spliterator.trySplit()&lt;/code&gt; &lt;/a&gt; 호출은 항상 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a4258855a05f3c4988c5d23737a7b0335e728c12" translate="yes" xml:space="preserve">
          <source>The encapsulated object is unsealed (using the given Cipher, assuming that the Cipher is already properly initialized) and de-serialized, before it is returned.</source>
          <target state="translated">캡슐화 된 객체는 봉인되지 않은 상태로 (암호가 이미 올바르게 초기화되었다고 가정 한 경우 지정된 암호를 사용하여) 직렬화 해제되고 반환되기 전에 직렬화 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4cab56e097451f176a982ee92d2d74b62d281b8b" translate="yes" xml:space="preserve">
          <source>The encapsulated object is unsealed and de-serialized, before it is returned.</source>
          <target state="translated">캡슐화 된 객체는 반환되기 전에 봉인 해제되고 역 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="199c2a38ff6aa6fabd32c8a3c9f3caf0eb39b53e" translate="yes" xml:space="preserve">
          <source>The encoding input P whose value equals byte[0].</source>
          <target state="translated">값이 byte [0]과 같은 인코딩 입력 P</target>
        </trans-unit>
        <trans-unit id="cfbc32ba92aba58363c14e07072f16236de40055" translate="yes" xml:space="preserve">
          <source>The encoding name. May be null, which indicates the default encoding should be used.</source>
          <target state="translated">인코딩 이름 기본 인코딩을 사용해야 함을 나타내는 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e05ebaa86b65502750822b548c59b7f59f18d9d5" translate="yes" xml:space="preserve">
          <source>The encoding scheme of this encoder instance is unaffected by this invocation. The returned encoder instance should be used for non-padding encoding operation.</source>
          <target state="translated">이 인코더 인스턴스의 인코딩 체계는이 호출의 영향을받지 않습니다. 패딩되지 않은 인코딩 작업에는 반환 된 인코더 인스턴스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="00a91fa3e606aaba9d4e25afa9d2cef72d5fc178" translate="yes" xml:space="preserve">
          <source>The encoding should be set before any &lt;code&gt;LogRecords&lt;/code&gt; are written to the &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">인코딩은 &lt;code&gt;LogRecords&lt;/code&gt; 가 &lt;code&gt;Handler&lt;/code&gt; 에 작성 되기 전에 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="60091846e46c40257fd7a742d4619bbc19aa8175" translate="yes" xml:space="preserve">
          <source>The end argument must be greater than or equal to &lt;code&gt;start&lt;/code&gt;, and less than or equal to the length of s.</source>
          <target state="translated">end 인수는 &lt;code&gt;start&lt;/code&gt; 보다 크거나 같아야하고 s의 길이보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="711a09ed66a073766bca3e7b6ef36bcbe9e2bcfa" translate="yes" xml:space="preserve">
          <source>The end of a line</source>
          <target state="translated">줄의 끝</target>
        </trans-unit>
        <trans-unit id="2b7cb3f2f726e71310a51789affbad5826f447fa" translate="yes" xml:space="preserve">
          <source>The end of the input</source>
          <target state="translated">입력의 끝</target>
        </trans-unit>
        <trans-unit id="83ac7dbc36de6be08d58b4bbfe9e0a56933b8da8" translate="yes" xml:space="preserve">
          <source>The end of the input but for the final &lt;a href=&quot;#lt&quot;&gt;terminator&lt;/a&gt;, if any</source>
          <target state="translated">입력의 끝이지만 최종 &lt;a href=&quot;#lt&quot;&gt;터미네이터&lt;/a&gt; (있는 경우)</target>
        </trans-unit>
        <trans-unit id="ef4414b7c806493fb5d10ea630e15048e7a0b572" translate="yes" xml:space="preserve">
          <source>The end of the previous match</source>
          <target state="translated">이전 경기의 끝</target>
        </trans-unit>
        <trans-unit id="4fcef1061367fe496df98fb6e285795bde375b7d" translate="yes" xml:space="preserve">
          <source>The engine to handle scripts with this extension. Returns &lt;code&gt;null&lt;/code&gt; if not found.</source>
          <target state="translated">이 확장으로 스크립트를 처리하는 엔진입니다. 찾을 수 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c8026a80c8952092d49eb36b05845480d8dbedd6" translate="yes" xml:space="preserve">
          <source>The engine to handle scripts with this mime type. Returns &lt;code&gt;null&lt;/code&gt; if not found.</source>
          <target state="translated">이 MIME 유형으로 스크립트를 처리하는 엔진입니다. 찾을 수 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5d9018d772f1115a9de50a7ae9129bb12d2e335" translate="yes" xml:space="preserve">
          <source>The entire name is converted to lower case using &lt;code&gt;String.toLowerCase(Locale.US)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.toLowerCase(Locale.US)&lt;/code&gt; 사용하여 전체 이름이 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="276a2e35ec48a4b15619c06e947a59549e48ad49" translate="yes" xml:space="preserve">
          <source>The entire name is converted to upper case using &lt;code&gt;String.toUpperCase(Locale.US)&lt;/code&gt;</source>
          <target state="translated">전체 이름은 &lt;code&gt;String.toUpperCase(Locale.US)&lt;/code&gt; 사용하여 대문자 로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2cf0cb7e58f2504fba1a3138d73c6049b494a8" translate="yes" xml:space="preserve">
          <source>The entire state of the object is compared.</source>
          <target state="translated">객체의 전체 상태가 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="47c0130f063f1660f8c0d872244fda8cbf918c22" translate="yes" xml:space="preserve">
          <source>The entry that was removed.</source>
          <target state="translated">제거 된 항목입니다.</target>
        </trans-unit>
        <trans-unit id="18f0442bd8b0a54d4c0285c94f5620f08066be05" translate="yes" xml:space="preserve">
          <source>The enumeration class &lt;code&gt;java.nio.ByteOrder&lt;/code&gt; is used to specify the byte order. A value of &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; specifies so-called big-endian or network byte order, in which the high-order byte comes first. Motorola and Sparc processors store data in this format, while Intel processors store data in the reverse &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; order.</source>
          <target state="translated">열거 클래스 &lt;code&gt;java.nio.ByteOrder&lt;/code&gt; 는 바이트 순서를 지정하는 데 사용됩니다. &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; 의 값은 소위 빅 엔디안 또는 네트워크 바이트 순서를 지정하며 상위 바이트가 우선합니다. Motorola 및 Sparc 프로세서는이 형식으로 데이터를 저장하지만 Intel 프로세서는 역 &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; 순서로 데이터를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="93a83d4b2463802ed63b71007b3d2a201c1657a1" translate="yes" xml:space="preserve">
          <source>The enumeration singleton value stored at index</source>
          <target state="translated">인덱스에 저장된 열거 형 싱글 톤 값</target>
        </trans-unit>
        <trans-unit id="447fe37c6bb84b1b519d70e69f405d19fe3bb27a" translate="yes" xml:space="preserve">
          <source>The envelope input tray in the printer.</source>
          <target state="translated">프린터의 봉투 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="7320b1d90fa4d701e7a16f43a233c4390cf54ae6" translate="yes" xml:space="preserve">
          <source>The environment associated with this InitialContext. It is initialized to null and is updated by the constructor that accepts an environment or by the &lt;code&gt;init()&lt;/code&gt; method.</source>
          <target state="translated">이 InitialContext에 관련한 환경입니다. null로 초기화되고 환경을 허용하는 생성자 또는 &lt;code&gt;init()&lt;/code&gt; 메소드에 의해 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="a209249a1bb001079ff30fe84944238386409855" translate="yes" xml:space="preserve">
          <source>The environment is inherited from the parent context as context methods proceed from one context to the next. Changes to the environment of one context do not directly affect those of other contexts.</source>
          <target state="translated">하나의 컨텍스트에서 다음 컨텍스트로 컨텍스트 메소드가 진행됨에 따라 환경은 상위 컨텍스트에서 상속됩니다. 한 컨텍스트의 환경에 대한 변경은 다른 컨텍스트의 환경에 직접적인 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9dee9225753fc6b669ebb73bdd54e1d209d99ca" translate="yes" xml:space="preserve">
          <source>The environment of the context being operated on.</source>
          <target state="translated">컨텍스트의 환경이 운영되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef8a562764f2b68aa9e4e0b27ff74e8ea33e36dd" translate="yes" xml:space="preserve">
          <source>The environment parameter is owned by the caller. The implementation will not modify the object or keep a reference to it, although it may keep a reference to a clone or copy.</source>
          <target state="translated">환경 매개 변수는 호출자가 소유합니다. 구현은 객체를 수정하거나 참조를 유지하지 않지만 복제 또는 복사에 대한 참조를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73513013d840568497d96e281a5e7d4e7a8991b6" translate="yes" xml:space="preserve">
          <source>The environment variable that stores a keystore password. Alternatively, passwords may be supplied to the constructor method in a &lt;code&gt;Map&amp;lt;String, ProtectionParameter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">키 저장소 비밀번호를 저장하는 환경 변수입니다. 또는 비밀번호가 &lt;code&gt;Map&amp;lt;String, ProtectionParameter&amp;gt;&lt;/code&gt; 의 생성자 메소드에 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="451d2b13281af07c21676b10d78a114a9213b989" translate="yes" xml:space="preserve">
          <source>The epoch second count is a simple incrementing count of seconds where second 0 is 1970-01-01T00:00:00Z. The nanosecond part of the day is returned by &lt;code&gt;getNanosOfSecond&lt;/code&gt;.</source>
          <target state="translated">에포크 초 카운트는 초 0이 1970-01-01T00 : 00 : 00Z 인 간단한 증분 초입니다. 하루의 나노초 부분은 &lt;code&gt;getNanosOfSecond&lt;/code&gt; 에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="13f61041587cde1d2ef70a5612d087fffea4f8a6" translate="yes" xml:space="preserve">
          <source>The epoch-day, based on the Java epoch of 1970-01-01 (ISO).</source>
          <target state="translated">1970 년 1 월 1 일 (ISO)의 Java 시대를 기반으로 한 시대.</target>
        </trans-unit>
        <trans-unit id="f79c64d33ada160a9aa9a0dee87d4b4477a4a32f" translate="yes" xml:space="preserve">
          <source>The era AH has the value 1.</source>
          <target state="translated">AH 시대의 가치는 1입니다.</target>
        </trans-unit>
        <trans-unit id="3e1c9900b94880fd7e7c021ee09ac2c00bf64a53" translate="yes" xml:space="preserve">
          <source>The era BCE has the value 0, while the era CE has the value 1.</source>
          <target state="translated">BCE 시대는 0, CE 시대는 1입니다.</target>
        </trans-unit>
        <trans-unit id="5051bf50e01fc2774c8eb947eb59b6962dbe9b88" translate="yes" xml:space="preserve">
          <source>The era BEFORE_BE has the value 0, while the era BE has the value 1.</source>
          <target state="translated">BEFORE_BE는 값이 0 인 반면 BE는 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f1e8420b21ccf344f49d55914b45558ed396505c" translate="yes" xml:space="preserve">
          <source>The era BEFORE_ROC has the value 0, while the era ROC has the value 1.</source>
          <target state="translated">BEFORE_ROC 시대는 값이 0이고 ROC 시대는 1입니다.</target>
        </trans-unit>
        <trans-unit id="9f4534bad72f013551c9f764a1def4ccdab2de91" translate="yes" xml:space="preserve">
          <source>The era in use at 1970-01-01 must have the value 1. Later eras must have sequentially higher values. Earlier eras must have sequentially lower values. Each chronology must refer to an enum or similar singleton to provide the era values.</source>
          <target state="translated">1970-01-01의 사용 기간은 1이어야합니다. 나중에는 순차적으로 높은 값을 가져야합니다. 초기는 순차적으로 낮아야합니다. 각 연대기는 시대 값을 제공하기 위해 열거 형 또는 유사한 싱글 톤을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="87541603348e098b6e3532cfb361646f1efe0412" translate="yes" xml:space="preserve">
          <source>The era in use at the epoch 1970-01-01 (ISO) has the value 1.</source>
          <target state="translated">신기원 1970-01-01 (ISO)에서 사용되는 기간은 1입니다.</target>
        </trans-unit>
        <trans-unit id="09028bc65a868277e7b5ae99345ad33a969765b4" translate="yes" xml:space="preserve">
          <source>The era is, conceptually, the largest division of the time-line. Most calendar systems have a single epoch dividing the time-line into two eras. However, some have multiple eras, such as one for the reign of each leader. The exact meaning is determined by the &lt;code&gt;Chronology&lt;/code&gt;.</source>
          <target state="translated">시대는 개념 상 타임 라인의 가장 큰 부분입니다. 대부분의 달력 시스템에는 타임 라인을 두 개의 시대로 나누는 단일 시대가 있습니다. 그러나 어떤 지도자들은 각 지도자의 통치 기간과 같은 여러 시대를 가지고 있습니다. 정확한 의미는 &lt;code&gt;Chronology&lt;/code&gt; 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff2e26c4f18353f82283eccb549a2ce5f2603627" translate="yes" xml:space="preserve">
          <source>The era is, conceptually, the largest division of the time-line. Most calendar systems have a single epoch dividing the time-line into two eras. However, some have multiple eras, such as one for the reign of each leader. The exact meaning is determined by the chronology according to the following constraints.</source>
          <target state="translated">시대는 개념 상 타임 라인의 가장 큰 부분입니다. 대부분의 달력 시스템에는 타임 라인을 두 개의 시대로 나누는 단일 시대가 있습니다. 그러나 어떤 지도자들은 각 지도자의 통치 기간과 같은 여러 시대를 가지고 있습니다. 정확한 의미는 다음 제약 조건에 따라 연대기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="745a52e844df97899a3ede65646ea36c0fd17371" translate="yes" xml:space="preserve">
          <source>The era.</source>
          <target state="translated">시대.</target>
        </trans-unit>
        <trans-unit id="2caffe614643d6e127ea5c039dc53ac14adaff9a" translate="yes" xml:space="preserve">
          <source>The erroneous pattern</source>
          <target state="translated">잘못된 패턴</target>
        </trans-unit>
        <trans-unit id="1e98ccc16f95f86f47c7a57ca3607f40e966ecd8" translate="yes" xml:space="preserve">
          <source>The error index</source>
          <target state="translated">에러 인덱스</target>
        </trans-unit>
        <trans-unit id="4a0628012c2d77c4a62f2562528b964f8e826cdc" translate="yes" xml:space="preserve">
          <source>The error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155f296108df1212e1fa7c200cb6147e704d7079" translate="yes" xml:space="preserve">
          <source>The error method is called when a Handler failure occurs.</source>
          <target state="translated">핸들러 실패가 발생하면 오류 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a410fae8eeeeb214fc59888859b3800e99fda5d" translate="yes" xml:space="preserve">
          <source>The escape character (&lt;code&gt;'\u001B'&lt;/code&gt;)</source>
          <target state="translated">이스케이프 문자 ( &lt;code&gt;'\u001B'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d34d828cba8da1b4111d6f70690a234a819abfb3" translate="yes" xml:space="preserve">
          <source>The event property may be &quot;qualified&quot; with an arbitrary number of property prefixes delimited with the &quot;.&quot; character. The &quot;qualifying&quot; names that appear before the &quot;.&quot; characters are taken as the names of properties that should be applied, left-most first, to the event object.</source>
          <target state="translated">이벤트 속성은 &quot;.&quot;로 구분 된 임의의 수의 속성 접두사를 사용하여 &quot;규격화&quot;될 수 있습니다. 캐릭터. &quot;.&quot;앞에 나타나는 &quot;자격&quot;이름 문자는 맨 왼쪽 이벤트 개체에 적용해야하는 속성 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f559f796a4abfc896af3dfc6be310d8b091505bc" translate="yes" xml:space="preserve">
          <source>The event source: the &lt;code&gt;EventContext&lt;/code&gt; which fired this event.</source>
          <target state="translated">이벤트 소스 : 이 이벤트를 시작한 &lt;code&gt;EventContext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7d703d953f82fc64328567ded4065357410b7d7" translate="yes" xml:space="preserve">
          <source>The event type.</source>
          <target state="translated">이벤트 유형</target>
        </trans-unit>
        <trans-unit id="801bb999f2915842503297d7a55e5337855dcb13" translate="yes" xml:space="preserve">
          <source>The exact behavior is as follows. Parse the full set of fields and determine the effective chronology using the last chronology if it appears more than once. Then convert the base date to the effective chronology. Then extract the specified field from the chronology-specific base date and use it to determine the &lt;code&gt;baseValue&lt;/code&gt; used below.</source>
          <target state="translated">정확한 동작은 다음과 같습니다. 전체 필드 세트를 구문 분석하고 마지막 연대기가 두 번 이상 나타나는 경우 유효 연대기를 판별하십시오. 그런 다음 기준 날짜를 유효 연대기로 변환하십시오. 그런 다음 연대기 별 기준 날짜에서 지정된 필드를 추출하여이를 사용하여 아래에 사용 된 &lt;code&gt;baseValue&lt;/code&gt; 을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c12e27171aa51bd9aa8f7f961c2ff8b5eca35700" translate="yes" xml:space="preserve">
          <source>The exact behavior of monitors is detailed in the &lt;a href=&quot;#spec&quot;&gt;JMX Specification&lt;/a&gt;. What follows is a summary.</source>
          <target state="translated">모니터의 정확한 동작은 &lt;a href=&quot;#spec&quot;&gt;JMX 사양에&lt;/a&gt; 자세히 설명되어 있습니다. 다음은 요약입니다.</target>
        </trans-unit>
        <trans-unit id="bd471b56699ef39010fba9b749ad14cd54415b7d" translate="yes" xml:space="preserve">
          <source>The exact details of the representation are unspecified and subject to change, but the following may be regarded as typical:</source>
          <target state="translated">표현의 정확한 세부 사항은 지정되지 않았으며 변경 될 수 있지만 다음은 일반적인 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66df7228668613a58111f2895d7f4a5daf80cea" translate="yes" xml:space="preserve">
          <source>The exact form of a &lt;code&gt;file:&lt;/code&gt; URI is system-dependent, hence the transformation performed by this constructor is also system-dependent.</source>
          <target state="translated">&lt;code&gt;file:&lt;/code&gt; 의 정확한 형식 : URI는 시스템에 따라 다르므로이 생성자가 수행하는 변환도 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dc981df5951ebbd2d225b7d4ed612eca36ff7515" translate="yes" xml:space="preserve">
          <source>The exact form of the URI is file system provider dependent. In the case of the default provider, the URI scheme is &lt;code&gt;&quot;file&quot;&lt;/code&gt; and the given URI has a non-empty path component, and undefined query, and fragment components. The resulting &lt;code&gt;Path&lt;/code&gt; is associated with the default &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;&lt;code&gt;FileSystem&lt;/code&gt;.</source>
          <target state="translated">URI의 정확한 형식은 파일 시스템 공급자에 따라 다릅니다. 기본 공급자의 경우 URI 체계는 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이며 지정된 URI에는 비어 있지 않은 경로 구성 요소와 정의되지 않은 쿼리 및 조각 구성 요소가 있습니다. 결과 &lt;code&gt;Path&lt;/code&gt; 는 기본 &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; &lt;code&gt;FileSystem&lt;/code&gt; 과 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="9697a2a14d97c5e708bf64a93aac8e3b81e327df" translate="yes" xml:space="preserve">
          <source>The exact form of the URI is system-dependent. If it can be determined that the file denoted by this abstract pathname is a directory, then the resulting URI will end with a slash.</source>
          <target state="translated">URI의 정확한 형식은 시스템에 따라 다릅니다. 이 추상 경로명으로 표시된 파일이 디렉토리 인 것으로 판별 될 경우 결과 URI는 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9aa800104b8645f432b1c0777e913b6648da24d1" translate="yes" xml:space="preserve">
          <source>The exact meaning and format of the version is provider specific. The version must follow lexicographical order, thus the returned map will be order from the oldest known rules to the newest available rules. The default 'TZDB' group uses version numbering consisting of the year followed by a letter, such as '2009e' or '2012f'.</source>
          <target state="translated">버전의 정확한 의미와 형식은 공급자마다 다릅니다. 버전은 사전 식 순서를 따라야하므로 반환 된 맵은 가장 오래된 알려진 규칙에서 사용 가능한 최신 규칙으로 정렬됩니다. 기본 'TZDB'그룹은 연도로 구성된 버전 번호 매기기와 '2009e'또는 '2012f'와 같은 문자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="202e6f1d0220247616c834f1fe78276d90a9f0ce" translate="yes" xml:space="preserve">
          <source>The exact naming patterns for Standard MBeans are detailed in the &lt;a href=&quot;#spec&quot;&gt;JMX Specification&lt;/a&gt;.</source>
          <target state="translated">표준 MBean의 정확한 이름 지정 패턴은 &lt;a href=&quot;#spec&quot;&gt;JMX 사양에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d2a903e4f369778a39675882ed8ca3dfabde11" translate="yes" xml:space="preserve">
          <source>The exact operation of the &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; instance depends on the &lt;code&gt;Lock&lt;/code&gt; implementation and must be documented by that implementation.</source>
          <target state="translated">&lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 인스턴스 의 정확한 작동은 &lt;code&gt;Lock&lt;/code&gt; 구현 에 따라 다르며 해당 구현에서 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b0d4d6e7aa50a3ce0bc0196f6c80877208e0249" translate="yes" xml:space="preserve">
          <source>The exact semantics of this socket options are system dependent. In particular, it is system dependent whether the loopback applies to multicast datagrams sent from the socket or received by the socket. For &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; sockets then it is system dependent whether the option also applies to multicast datagrams sent to IPv4 addresses.</source>
          <target state="translated">이 소켓 옵션의 정확한 의미는 시스템에 따라 다릅니다. 특히 루프백이 소켓에서 전송되거나 소켓에서 수신 된 멀티 캐스트 데이터 그램에 적용되는지 여부는 시스템에 따라 다릅니다. 대한 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓 다음은 옵션이 아니라 IPv4 주소로 전송 멀티 캐스트 데이터 그램에 적용되는지 여부 시스템에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="dcf3b498256a8390df6c831306b8777539da56b0" translate="yes" xml:space="preserve">
          <source>The exact set of locations searched depends on the implementation of the Java runtime environment.</source>
          <target state="translated">검색된 정확한 위치 세트는 Java 런타임 환경의 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a46638a46aa36be6870c59328abd975a302ed5d9" translate="yes" xml:space="preserve">
          <source>The example above shows only one form of address. An address for the RMI Connector can take several forms, as detailed in the documentation for the package &lt;code&gt;&lt;a href=&quot;rmi/package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 예는 한 가지 형식의 주소 만 보여줍니다. RMI 커넥터의 주소는 &lt;code&gt;&lt;a href=&quot;rmi/package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 패키지의 문서에 자세히 기술 된대로 여러 형태를 취할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf256aa92da408eb634bac9c48df3a1edf45330c" translate="yes" xml:space="preserve">
          <source>The exception handler for this stream. Will return the default exception listener if this has not explicitly been set.</source>
          <target state="translated">이 스트림의 예외 핸들러입니다. 명시 적으로 설정되지 않은 경우 기본 예외 수신기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2aa040dbff462a04d3abbb5593e1fb08753604d8" translate="yes" xml:space="preserve">
          <source>The exception handler for this stream; Will return the default exception listener if this has not explicitly been set.</source>
          <target state="translated">이 스트림의 예외 핸들러입니다. 명시 적으로 설정되지 않은 경우 기본 예외 리스너를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3725f62226b7f5164a5c53cb1c5db24d41640d24" translate="yes" xml:space="preserve">
          <source>The exception that was thrown.</source>
          <target state="translated">발생한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="1b74aaa2703470e90f28d9b9ca620765332c9fec" translate="yes" xml:space="preserve">
          <source>The executable is represented as when viewed as a method (or constructor or initializer) of some reference type. If that reference type is parameterized, then its actual type arguments are substituted into any types returned by the methods of this interface.</source>
          <target state="translated">실행 파일은 일부 참조 유형의 메소드 (또는 생성자 또는 이니셜 라이저)로 볼 때 표시됩니다. 해당 참조 유형이 매개 변수화 된 경우 실제 유형 인수는이 인터페이스의 메소드가 리턴 한 모든 유형으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d29a50e79da812a685fcf8e4148c18068c2c4497" translate="yes" xml:space="preserve">
          <source>The execution status of tasks may be queried at several levels of detail: &lt;a href=&quot;forkjointask#isDone--&quot;&gt;&lt;code&gt;isDone()&lt;/code&gt;&lt;/a&gt; is true if a task completed in any way (including the case where a task was cancelled without executing); &lt;a href=&quot;forkjointask#isCompletedNormally--&quot;&gt;&lt;code&gt;isCompletedNormally()&lt;/code&gt;&lt;/a&gt; is true if a task completed without cancellation or encountering an exception; &lt;a href=&quot;forkjointask#isCancelled--&quot;&gt;&lt;code&gt;isCancelled()&lt;/code&gt;&lt;/a&gt; is true if the task was cancelled (in which case &lt;a href=&quot;forkjointask#getException--&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; returns a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;); and &lt;a href=&quot;forkjointask#isCompletedAbnormally--&quot;&gt;&lt;code&gt;isCompletedAbnormally()&lt;/code&gt;&lt;/a&gt; is true if a task was either cancelled or encountered an exception, in which case &lt;a href=&quot;forkjointask#getException--&quot;&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/a&gt; will return either the encountered exception or &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업의 실행 상태는 몇 가지 세부 수준으로 쿼리 될 수 있습니다. &lt;a href=&quot;forkjointask#isDone--&quot;&gt; &lt;code&gt;isDone()&lt;/code&gt; &lt;/a&gt; 작업이 어떤 방식 으로든 완료된 경우 (작업이 실행되지 않고 취소 된 경우 포함 ) true입니다. 작업이 취소 또는 예외없이 완료된 경우 &lt;a href=&quot;forkjointask#isCompletedNormally--&quot;&gt; &lt;code&gt;isCompletedNormally()&lt;/code&gt; &lt;/a&gt; 는 true입니다. 작업이 취소 된 경우 &lt;a href=&quot;forkjointask#isCancelled--&quot;&gt; &lt;code&gt;isCancelled()&lt;/code&gt; &lt;/a&gt; 는 true입니다 (이 경우 &lt;a href=&quot;forkjointask#getException--&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; 을&lt;/a&gt; 반환 함 ). 및 &lt;a href=&quot;forkjointask#isCompletedAbnormally--&quot;&gt; &lt;code&gt;isCompletedAbnormally()&lt;/code&gt; &lt;/a&gt; 작업 중 하나를 취소하는 경우있는 예외, 발생했을 경우 사실이다 &lt;a href=&quot;forkjointask#getException--&quot;&gt; &lt;code&gt;getException()&lt;/code&gt; &lt;/a&gt; 만난 예외 또는 중 하나를 반환합니다 &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4d9dd131f37a7f42a4bcff42d9a1446d224c987" translate="yes" xml:space="preserve">
          <source>The executor is intended to be used exclusively by the resulting asynchronous channel group. Termination of the group results in the orderly &lt;a href=&quot;../../util/concurrent/executorservice#shutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; of the executor service. Shutting down the executor service by other means results in unspecified behavior.</source>
          <target state="translated">실행기는 결과 비동기 채널 그룹에서 독점적으로 사용하도록되어 있습니다. 그룹이 &lt;a href=&quot;../../util/concurrent/executorservice#shutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 되면 실행기 서비스 가 순서대로 종료 됩니다. 다른 방법으로 실행기 서비스를 종료하면 지정되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9d8f0bcf70d559439cda5ca1964e2a9c53e1f14" translate="yes" xml:space="preserve">
          <source>The expiration affects only the bundle loading process by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. That is, if the factory method finds a resource bundle in the cache that has expired, the factory method calls the &lt;a href=&quot;resourcebundle.control#needsReload-java.lang.String-java.util.Locale-java.lang.String-java.lang.ClassLoader-java.util.ResourceBundle-long-&quot;&gt;&lt;code&gt;needsReload&lt;/code&gt;&lt;/a&gt; method to determine whether the resource bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed from the cache. Otherwise, the instance stays in the cache, updated with the new TTL value returned by this method.</source>
          <target state="translated">만료는 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드에 의한 번들로드 프로세스에만 영향을줍니다 . 즉, 팩토리 메소드가 만료 된 캐시에서 자원 번들을 찾으면 팩토리 메소드는 &lt;a href=&quot;resourcebundle.control#needsReload-java.lang.String-java.util.Locale-java.lang.String-java.lang.ClassLoader-java.util.ResourceBundle-long-&quot;&gt; &lt;code&gt;needsReload&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 자원 번들을 다시로드해야하는지 여부를 판별합니다. 경우 &lt;code&gt;needsReload&lt;/code&gt; 가 반환 &lt;code&gt;true&lt;/code&gt; , 예를 번들 캐시 된 리소스는 캐시에서 제거됩니다. 그렇지 않으면 인스턴스가 캐시에 유지되고이 메소드에서 리턴 한 새 TTL 값으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc14daed0248ca40fd5504121c75a52196ab986" translate="yes" xml:space="preserve">
          <source>The explicit state of a matcher includes the start and end indices of the most recent successful match. It also includes the start and end indices of the input subsequence captured by each &lt;a href=&quot;pattern#cg&quot;&gt;capturing group&lt;/a&gt; in the pattern as well as a total count of such subsequences. As a convenience, methods are also provided for returning these captured subsequences in string form.</source>
          <target state="translated">매처의 명시 적 상태에는 가장 최근에 성공한 경기의 시작 및 종료 인덱스가 포함됩니다. 또한 패턴에서 각 &lt;a href=&quot;pattern#cg&quot;&gt;캡처 그룹&lt;/a&gt; 에 의해 캡처 된 입력 서브 시퀀스의 시작 및 종료 인덱스 와 이러한 서브 시퀀스의 총 수를 포함합니다. 편의상, 이러한 캡처 된 서브 시퀀스를 문자열 형태로 리턴하기위한 메소드도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b30369bd27defe750e02c533a376297b7fac15" translate="yes" xml:space="preserve">
          <source>The explicit state of a matcher is initially undefined; attempting to query any part of it before a successful match will cause an &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; to be thrown. The explicit state of a matcher is recomputed by every match operation.</source>
          <target state="translated">매처의 명시 적 상태는 처음에 정의되지 않습니다. 일치하기 전에 해당 부분을 쿼리하려고하면 &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 매처의 명시 적 상태는 모든 일치 조작에 의해 재 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a3c7c1344d3645ede9619e20180ea6a536e509b1" translate="yes" xml:space="preserve">
          <source>The exponent consists of the character &lt;code&gt;'e'&lt;/code&gt; (&lt;code&gt;'\u0065'&lt;/code&gt;) or &lt;code&gt;'E'&lt;/code&gt; (&lt;code&gt;'\u0045'&lt;/code&gt;) followed by one or more decimal digits. The value of the exponent must lie between -&lt;a href=&quot;../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../lang/integer#MIN_VALUE&quot;&gt;&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;&lt;/a&gt;+1) and &lt;a href=&quot;../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;, inclusive.</source>
          <target state="translated">지수는 문자 &lt;code&gt;'e'&lt;/code&gt; ( &lt;code&gt;'\u0065'&lt;/code&gt; ) 또는 &lt;code&gt;'E'&lt;/code&gt; ( &lt;code&gt;'\u0045'&lt;/code&gt; )와 하나 이상의 10 진수로 구성됩니다. - 지수의 값이 아니면 안됩니다 &lt;a href=&quot;../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../lang/integer#MIN_VALUE&quot;&gt; &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; &lt;/a&gt; +1)과 &lt;a href=&quot;../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; (포함).</target>
        </trans-unit>
        <trans-unit id="f0533f2a29f52d331ec56f16f61c10c53b5897f4" translate="yes" xml:space="preserve">
          <source>The exported constant &lt;a href=&quot;resolutionsyntax#DPI&quot;&gt;&lt;code&gt;DPI&lt;/code&gt;&lt;/a&gt; is actually the conversion factor by which to multiply a value in dpi to get the value in dphi. Likewise, the exported constant &lt;a href=&quot;resolutionsyntax#DPCM&quot;&gt;&lt;code&gt;DPCM&lt;/code&gt;&lt;/a&gt; is the conversion factor by which to multiply a value in dpcm to get the value in dphi. A client can specify a resolution value in units other than dpi or dpcm by supplying its own conversion factor. However, since the internal units of dphi was chosen with supporting only the external units of dpi and dpcm in mind, there is no guarantee that the conversion factor for the client's units will be an exact integer. If the conversion factor isn't an exact integer, resolution values in the client's units won't be stored precisely.</source>
          <target state="translated">내 보낸 상수 &lt;a href=&quot;resolutionsyntax#DPI&quot;&gt; &lt;code&gt;DPI&lt;/code&gt; &lt;/a&gt; 는 실제로 dphi의 값을 얻기 위해 dpi의 값을 곱하는 변환 계수입니다. 마찬가지로, 내 보낸 상수 &lt;a href=&quot;resolutionsyntax#DPCM&quot;&gt; &lt;code&gt;DPCM&lt;/code&gt; &lt;/a&gt; 은 dphi의 값을 얻기 위해 dpcm의 값을 곱하는 변환 계수입니다. 클라이언트는 자체 변환 계수를 제공하여 dpi 또는 dpcm 이외의 단위로 해상도 값을 지정할 수 있습니다. 그러나 dpi의 내부 단위는 dpi와 dpcm의 외부 단위 만 지원하도록 선택되었으므로 클라이언트 단위의 변환 계수가 정확한 정수일 것이라는 보장은 없습니다. 변환 계수가 정확한 정수가 아닌 경우 클라이언트 단위의 분해능 값이 정확하게 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ffeca453b85f8c0c2115aaee678b47fadf06c73" translate="yes" xml:space="preserve">
          <source>The exported constant &lt;a href=&quot;size2dsyntax#INCH&quot;&gt;&lt;code&gt;INCH&lt;/code&gt;&lt;/a&gt; is actually the conversion factor by which to multiply a value in inches to get the value in &amp;micro;m. Likewise, the exported constant &lt;a href=&quot;size2dsyntax#MM&quot;&gt;&lt;code&gt;MM&lt;/code&gt;&lt;/a&gt; is the conversion factor by which to multiply a value in mm to get the value in &amp;micro;m. A client can specify a resolution value in units other than inches or mm by supplying its own conversion factor. However, since the internal units of &amp;micro;m was chosen with supporting only the external units of inch and mm in mind, there is no guarantee that the conversion factor for the client's units will be an exact integer. If the conversion factor isn't an exact integer, resolution values in the client's units won't be stored precisely.</source>
          <target state="translated">내 보낸 상수 &lt;a href=&quot;size2dsyntax#INCH&quot;&gt; &lt;code&gt;INCH&lt;/code&gt; &lt;/a&gt; 는 실제로 &amp;micro;m 단위의 값을 얻기 위해 인치 단위의 값을 곱하는 변환 계수입니다. 마찬가지로, 내 보낸 상수 &lt;a href=&quot;size2dsyntax#MM&quot;&gt; &lt;code&gt;MM&lt;/code&gt; &lt;/a&gt; 은 값을 mm 단위로 곱하여 &amp;micro;m 단위의 값을 얻는 변환 계수입니다. 클라이언트는 자체 변환 계수를 제공하여 인치 또는 mm 이외의 단위로 해상도 값을 지정할 수 있습니다. 그러나 인치와 밀리미터의 외부 단위 만 지원하도록 &amp;micro;m의 내부 단위를 선택 했으므로 클라이언트 단위의 변환 계수가 정확한 정수일 것이라는 보장은 없습니다. 변환 계수가 정확한 정수가 아닌 경우 클라이언트 단위의 분해능 값이 정확하게 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c526e4b628135ef20bb3ec78aeb7857b7e29b6f2" translate="yes" xml:space="preserve">
          <source>The extension which (by convention) is normally used for this kind of file object. If no convention exists, the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">이러한 종류의 파일 객체에 일반적으로 사용되는 확장명입니다. 규칙이 없으면 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7077b0dc29af6cf86699b7e028c9503e4db51e1" translate="yes" xml:space="preserve">
          <source>The extension, or null if this locale defines no extension for the specified key.</source>
          <target state="translated">확장자.이 로케일이 지정된 키의 확장자를 정의하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="5a1dab9e41a5beec5f05c63e6ecb9a3afbdcbb0e" translate="yes" xml:space="preserve">
          <source>The extensions defined for X.509 v3 &lt;a href=&quot;x509certificate&quot;&gt;&lt;code&gt;Certificates&lt;/code&gt;&lt;/a&gt; and v2 &lt;a href=&quot;x509crl&quot;&gt;&lt;code&gt;CRLs&lt;/code&gt;&lt;/a&gt; (Certificate Revocation Lists) provide methods for associating additional attributes with users or public keys, for managing the certification hierarchy, and for managing CRL distribution. The X.509 extensions format also allows communities to define private extensions to carry information unique to those communities.</source>
          <target state="translated">X.509 v3 &lt;a href=&quot;x509certificate&quot;&gt; &lt;code&gt;Certificates&lt;/code&gt; &lt;/a&gt; 및 v2 &lt;a href=&quot;x509crl&quot;&gt; &lt;code&gt;CRLs&lt;/code&gt; &lt;/a&gt; (인증서 해지 목록)에 대해 정의 된 확장 기능은 추가 속성을 사용자 또는 공개 키와 연결하고 인증 계층을 관리하고 CRL 배포를 관리하는 방법을 제공합니다. X.509 확장 형식을 사용하면 커뮤니티가 개인 확장을 정의하여 해당 커뮤니티에 고유 한 정보를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0664d9fe950364ce2964d5f524212ff501587b8c" translate="yes" xml:space="preserve">
          <source>The fact that a client connection object is in this internal list does not prevent it from being garbage collected.</source>
          <target state="translated">클라이언트 연결 개체가이 내부 목록에 있다고해서 가비지 수집을 방해하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="21ce72be6b52dbd64592f3385a8d86f3fe793972" translate="yes" xml:space="preserve">
          <source>The factory is used by the service provider to return controls that it reads from the LDAP protocol as specialized control classes. Without this mechanism, the provider would be returning controls that only contained data in BER encoded format.</source>
          <target state="translated">팩토리는 서비스 제공자가 LDAP 프로토콜에서 읽은 제어를 특수 제어 클래스로 리턴하기 위해 사용됩니다. 이 메커니즘이 없으면 공급자는 BER 인코딩 형식의 데이터 만 포함 된 컨트롤을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b5a2c92a2eca28e67f326ce843048d8b7bd41378" translate="yes" xml:space="preserve">
          <source>The factory methods on a &lt;code&gt;Lookup&lt;/code&gt; object correspond to all major use cases for methods, constructors, and fields. Each method handle created by a factory method is the functional equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;. (Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.) Here is a summary of the correspondence between these factory methods and the behavior the resulting method handles:</source>
          <target state="translated">&lt;code&gt;Lookup&lt;/code&gt; 객체 의 팩토리 메소드 는 메소드, 생성자 및 필드의 모든 주요 사용 사례에 해당합니다. 팩토리 메소드에 의해 작성된 각 메소드 핸들은 특정 &lt;em&gt;바이트 코드 동작&lt;/em&gt; 과 기능적으로 같습니다 . (바이트 코드 동작은 Java Virtual Machine Specification의 5.4.3.5 섹션에 설명되어 있습니다.) 다음은 이러한 팩토리 메소드와 결과 메소드가 처리하는 동작 사이의 대응에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="b91218e70f871a17a2f6362660e1e868c721d3f4" translate="yes" xml:space="preserve">
          <source>The ffi ligature is not a distinct semantic character, and strictly speaking it shouldn't be in Unicode at all, but it was included for compatibility with existing character sets that already provided it. The Unicode standard identifies such characters by giving them &quot;compatibility&quot; decompositions into the corresponding semantic characters. When sorting and searching, you will often want to use these mappings.</source>
          <target state="translated">ffi 합자는 고유 한 의미 론적 문자가 아니며 엄격하게 말해서 전혀 유니 코드로되어서는 안되지만 이미 제공 한 기존 문자 세트와의 호환성을 위해 포함되었습니다. 유니 코드 표준은 해당하는 시맨틱 문자로 &quot;호환성&quot;분해를 제공하여 이러한 문자를 식별합니다. 정렬 및 검색 할 때 종종 이러한 매핑을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fc1056366c58e729dc6afba4a88b156e84cb7c50" translate="yes" xml:space="preserve">
          <source>The field has a range that matches &lt;a href=&quot;../localdate#MAX&quot;&gt;&lt;code&gt;LocalDate.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../localdate#MIN&quot;&gt;&lt;code&gt;LocalDate.MIN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드는 &lt;a href=&quot;../localdate#MAX&quot;&gt; &lt;code&gt;LocalDate.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../localdate#MIN&quot;&gt; &lt;code&gt;LocalDate.MIN&lt;/code&gt; &lt;/a&gt; 과 일치하는 범위를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="712e6cc0a25fd23aff0938900316cf865ad97a3d" translate="yes" xml:space="preserve">
          <source>The field is set to the possibly unwrapped and widened new value.</source>
          <target state="translated">이 필드는 랩핑되지 않고 확장 된 새 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ec741d1bc5da33c15fd4cf9fae30220bb200e38a" translate="yes" xml:space="preserve">
          <source>The field that represents the day-of-quarter.</source>
          <target state="translated">분기를 나타내는 필드입니다.</target>
        </trans-unit>
        <trans-unit id="8b7d9fb854224c991ea3360c6b4c23f03fd566dd" translate="yes" xml:space="preserve">
          <source>The field that represents the quarter-of-year.</source>
          <target state="translated">분기를 나타내는 필드입니다.</target>
        </trans-unit>
        <trans-unit id="795dbdb11ae198b5c6c80f4f325863a9203509aa" translate="yes" xml:space="preserve">
          <source>The field that represents the week-based-year.</source>
          <target state="translated">주별 연도를 나타내는 필드입니다.</target>
        </trans-unit>
        <trans-unit id="b9b5cb4820b010459b1459912d80e5cb74d3e0ec" translate="yes" xml:space="preserve">
          <source>The field that represents the week-of-week-based-year.</source>
          <target state="translated">주별 연도를 나타내는 필드입니다.</target>
        </trans-unit>
        <trans-unit id="11a83d8eda116d371253332d6166c5c806d645ad" translate="yes" xml:space="preserve">
          <source>The field to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">반영 될 필드는 다음 알고리즘에 의해 결정됩니다. C를이 객체가 나타내는 클래스 또는 인터페이스라고하자.</target>
        </trans-unit>
        <trans-unit id="3065ed970efb34e44cb7669dd9013a7609717b99" translate="yes" xml:space="preserve">
          <source>The field value will be validated before it is set. If it is not valid, then an exception will be thrown. If the arrays are empty, then no change will take effect.</source>
          <target state="translated">필드 값은 설정되기 전에 확인됩니다. 유효하지 않은 경우 예외가 발생합니다. 배열이 비어 있으면 변경 사항이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4511f22417eeea0c45d403aa99ec6c4e5f493b0" translate="yes" xml:space="preserve">
          <source>The field value will be validated before it is set. If it is not valid, then an exception will be thrown. The meaning of validity is dependent on the descriptor implementation.</source>
          <target state="translated">필드 값은 설정되기 전에 확인됩니다. 유효하지 않은 경우 예외가 발생합니다. 유효성의 의미는 설명자 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f4f3c25408da24ec64080897e774ca4ee83c6a8b" translate="yes" xml:space="preserve">
          <source>The field works using double dispatch. Client code calls methods on a date-time like &lt;code&gt;LocalDateTime&lt;/code&gt; which check if the field is a &lt;code&gt;ChronoField&lt;/code&gt;. If it is, then the date-time must handle it. Otherwise, the method call is re-dispatched to the matching method in this interface.</source>
          <target state="translated">이 필드는 이중 디스패치를 ​​사용하여 작동합니다. 클라이언트 코드 는 필드가 &lt;code&gt;ChronoField&lt;/code&gt; 인지 확인하는 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 같은 날짜-시간에 메소드를 호출합니다 . 그렇다면 날짜-시간이 처리해야합니다. 그렇지 않은 경우, 메소드 호출은이 인터페이스에서 일치하는 메소드로 다시 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="d2445e43410c56b93c9fa902256806bdd8ac4225" translate="yes" xml:space="preserve">
          <source>The fields are defined as follows:</source>
          <target state="translated">필드는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3950e6b64e221a1449f2c57aec2e0333531ef343" translate="yes" xml:space="preserve">
          <source>The fields are implemented relative to &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt;. The fields are supported, and can be queried and set if &lt;code&gt;EPOCH_DAY&lt;/code&gt; is available. The fields work with all chronologies.</source>
          <target state="translated">필드는 &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; 에&lt;/a&gt; 상대적으로 구현됩니다 . 이 필드는 지원되며 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 가 사용 가능한 경우 쿼리하고 설정할 수 있습니다. 이 필드는 모든 연대기에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="199b733d0ffa6832d77eb936ddcc1d5a1518b3c2" translate="yes" xml:space="preserve">
          <source>The fields in the descriptor are defined, but not limited to, the following. Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.</source>
          <target state="translated">디스크립터의 필드는 다음과 같이 정의되지만 이에 국한되지는 않습니다. 이 테이블의 Type이 Number 인 경우 Long의 10 진수 표시 인 String도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a383d343c59d3896d5803d4ffc93f25fe7eded" translate="yes" xml:space="preserve">
          <source>The file MyResources_fr_CH.properties is never used because it is hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties is also hidden by MyResources.class.</source>
          <target state="translated">MyResources_fr_CH.properties 파일은 MyResources_fr_CH.class에 의해 숨겨져 있으므로 사용되지 않습니다. 마찬가지로 MyResources.properties도 MyResources.class에 의해 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="460768a160dbe254fd47bae9a1c6fbf466aa407e" translate="yes" xml:space="preserve">
          <source>The file and its description are available from the Unicode Consortium at:</source>
          <target state="translated">파일 및 설명은 다음 유니 코드 컨소시엄에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d38047699bda15b24d821107e47230d44ea40f06" translate="yes" xml:space="preserve">
          <source>The file attributes are retrieved from the file system as a &lt;em&gt;bulk operation&lt;/em&gt; by invoking the &lt;a href=&quot;basicfileattributeview#readAttributes--&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method. This class also defines the &lt;a href=&quot;basicfileattributeview#setTimes-java.nio.file.attribute.FileTime-java.nio.file.attribute.FileTime-java.nio.file.attribute.FileTime-&quot;&gt;&lt;code&gt;setTimes&lt;/code&gt;&lt;/a&gt; method to update the file's time attributes.</source>
          <target state="translated">&lt;a href=&quot;basicfileattributeview#readAttributes--&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 &lt;em&gt;대량&lt;/em&gt; 속성으로 파일 시스템에서 파일 속성을 검색합니다 . 이 클래스는 또한 파일의 시간 속성을 업데이트하기 위해 &lt;a href=&quot;basicfileattributeview#setTimes-java.nio.file.attribute.FileTime-java.nio.file.attribute.FileTime-java.nio.file.attribute.FileTime-&quot;&gt; &lt;code&gt;setTimes&lt;/code&gt; &lt;/a&gt; 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="3d0ad957ceac44bd60f317f1b1648150ac44473f" translate="yes" xml:space="preserve">
          <source>The file channel, or &lt;code&gt;null&lt;/code&gt; if the file lock was not acquired by a file channel.</source>
          <target state="translated">파일 채널. 파일 채널 이 파일 잠금을 얻지 못한 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="500deb1ea9502c9ecef51d1cffe190f21f116b2f" translate="yes" xml:space="preserve">
          <source>The file contents must not change between the time this object is constructed and the time of the last call to a read method.</source>
          <target state="translated">파일 내용은이 객체가 생성 된 시간과 마지막으로 read 메소드를 호출 한 시간 사이에서 변경되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6abc4cd51296b6f0da0c0a949b11937dfb0ddb48" translate="yes" xml:space="preserve">
          <source>The file creation methods take a variable number of arguments to allow the &lt;em&gt;originating elements&lt;/em&gt; to be provided as hints to the tool infrastructure to better manage dependencies. The originating elements are the types or packages (representing &lt;code&gt;package-info&lt;/code&gt; files) which caused an annotation processor to attempt to create a new file. For example, if an annotation processor tries to create a source file, &lt;code&gt;GeneratedFromUserSource&lt;/code&gt;, in response to processing</source>
          <target state="translated">파일 생성 방법은 다양한 &lt;em&gt;요소&lt;/em&gt; 를 사용하여 &lt;em&gt;시작 요소&lt;/em&gt; 를 도구 인프라에 힌트로 제공하여 종속성을보다 잘 관리 할 수 ​​있습니다. 시작 요소는 어노테이션 프로세서가 새 파일을 작성하게하는 유형 또는 패키지 ( &lt;code&gt;package-info&lt;/code&gt; 파일을 나타냄)입니다. 예를 들어, 주석 처리기가 처리에 응답하여 소스 파일 &lt;code&gt;GeneratedFromUserSource&lt;/code&gt; 를 작성하려고하면</target>
        </trans-unit>
        <trans-unit id="67561e9ae30efb52fd2ccb565fc1f4c64205ef9b" translate="yes" xml:space="preserve">
          <source>The file denoted by the returned abstract pathname did not exist before this method was invoked, and</source>
          <target state="translated">이 메소드를 호출하기 전에 리턴 된 추상 경로 이름으로 표시된 파일이 존재하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9aa2ea757056f97f63f34c1ea5a82cce074962fc" translate="yes" xml:space="preserve">
          <source>The file descriptor object for this socket.</source>
          <target state="translated">이 소켓의 파일 기술자 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7314353b4cf774f72ba9ddad96690ede6bed41df" translate="yes" xml:space="preserve">
          <source>The file descriptor object.</source>
          <target state="translated">파일 기술자 객체.</target>
        </trans-unit>
        <trans-unit id="f09dc1410e94ff66898b33b377f334bb2824ec23" translate="yes" xml:space="preserve">
          <source>The file key returned by this method can only be guaranteed to be unique if the file system and files remain static. Whether a file system re-uses identifiers after a file is deleted is implementation dependent and therefore unspecified.</source>
          <target state="translated">이 방법으로 반환 된 파일 키는 파일 시스템과 파일이 정적으로 유지되는 경우에만 고유 할 수 있습니다. 파일이 삭제 된 후 파일 시스템이 식별자를 재사용하는지 여부는 구현에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7425c0f40a18828eac5ac2c682f75622122775e" translate="yes" xml:space="preserve">
          <source>The file manager which all methods are delegated to.</source>
          <target state="translated">모든 메소드가 위임 된 파일 관리자.</target>
        </trans-unit>
        <trans-unit id="c8db30cdd7f6bac3afaba29ab13bca0e83da6504" translate="yes" xml:space="preserve">
          <source>The file name of the script or some other string describing the script source. May return some implementation-defined string such as</source>
          <target state="translated">스크립트의 파일 이름 또는 스크립트 소스를 설명하는 다른 문자열 다음과 같은 구현 정의 문자열을 반환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1bb2b9f1de9de831304e060cac7b16327f82123a" translate="yes" xml:space="preserve">
          <source>The file object which all methods are delegated to.</source>
          <target state="translated">모든 메소드가 위임 된 파일 객체.</target>
        </trans-unit>
        <trans-unit id="0825f60097e94d1e85c49fd153a3b65272d6b95a" translate="yes" xml:space="preserve">
          <source>The file system</source>
          <target state="translated">파일 시스템</target>
        </trans-unit>
        <trans-unit id="82f5231af999cd534e151548b4f1675b3dfd6445" translate="yes" xml:space="preserve">
          <source>The filtering method will behave as follows:</source>
          <target state="translated">필터링 방법은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d896ef01136035a55ade69aaf7e02f44f8e7c594" translate="yes" xml:space="preserve">
          <source>The filtering operation returns all matching language tags. It is defined in RFC 4647 as follows: &quot;In filtering, each language range represents the least specific language tag (that is, the language tag with fewest number of subtags) that is an acceptable match. All of the language tags in the matching set of tags will have an equal or greater number of subtags than the language range. Every non-wildcard subtag in the language range will appear in every one of the matching language tags.&quot;</source>
          <target state="translated">필터링 작업은 일치하는 모든 언어 태그를 반환합니다. RFC 4647에서 다음과 같이 정의됩니다. &quot;필터링에서 각 언어 범위는 허용 가능한 일치하는 최소 특정 언어 태그 (즉, 하위 태그 수가 가장 적은 언어 태그)를 나타냅니다. 일치하는 세트의 모든 언어 태그 태그 수는 언어 범위와 같거나 더 많은 수의 하위 태그를 갖습니다. 언어 범위의 모든 비 와일드 카드 하위 태그는 일치하는 언어 태그마다 표시됩니다. &quot;</target>
        </trans-unit>
        <trans-unit id="d3162e7feec30f14f4aa6ef15c92c46449634803" translate="yes" xml:space="preserve">
          <source>The final results of decoding will be the same whether or not intermediate updates are performed. Thus if only the final image is desired it may be preferable not to register any &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s. In general, progressive updating is most effective when fetching images over a network connection that is very slow compared to local CPU processing; over a fast connection, progressive updates may actually slow down the presentation of the image.</source>
          <target state="translated">디코딩의 최종 결과는 중간 업데이트 수행 여부에 관계없이 동일합니다. 따라서 최종 이미지 만 필요한 경우 &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; 를 등록하지 않는 것이 좋습니다 . 일반적으로 점진적 업데이트는 로컬 CPU 처리와 비교할 때 네트워크 연결을 통해 이미지를 가져올 때 가장 효과적입니다. 빠른 연결을 통해 점진적 업데이트는 실제로 이미지 표시 속도를 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d110cf80264e279c1436d299ebda35ec112c3fd" translate="yes" xml:space="preserve">
          <source>The final value from either the positive or negative case is then rounded to the destination precision.</source>
          <target state="translated">그런 다음 양수 또는 음수의 최종 값은 대상 정밀도로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="dceb51577509ae3dfa0af99f1bc1e752a22466e6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;SysexMessage&lt;/code&gt; object containing data for a particular system exclusive message should have the status value 0xF0. If this message contains all the system exclusive data for the message, it should end with the status byte 0xF7 (EOX). Otherwise, additional system exclusive data should be sent in one or more &lt;code&gt;SysexMessages&lt;/code&gt; with a status value of 0xF7. The &lt;code&gt;SysexMessage&lt;/code&gt; containing the last of the data for the system exclusive message should end with the value 0xF7 (EOX) to mark the end of the system exclusive message.</source>
          <target state="translated">특정 시스템 독점 메시지에 대한 데이터를 포함하는 첫 번째 &lt;code&gt;SysexMessage&lt;/code&gt; 오브젝트의 상태 값은 0xF0이어야합니다. 이 메시지에 메시지에 대한 모든 시스템 독점 데이터가 포함 된 경우 상태 바이트 0xF7 (EOX)로 끝나야합니다. 그렇지 않으면 상태 값이 0xF7 인 하나 이상의 &lt;code&gt;SysexMessages&lt;/code&gt; 에 추가 시스템 독점 데이터를 보내야합니다 . &lt;code&gt;SysexMessage&lt;/code&gt; 값 나타내는 0xF7 (EOX)로 끝나야 시스템 독점 메시지의 마지막 데이터를 포함하는 시스템 독점 메시지의 끝을 표시한다.</target>
        </trans-unit>
        <trans-unit id="d2e2f7cac12c5ca488060725f68a6ecc25a456b2" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 를 포함한, 임의의 입력이 이전 동안 버퍼링되었을 수 바이트 &lt;code&gt;update&lt;/code&gt; 동작 처리, 패딩 (요청한 경우)이 적용된다. GCM / CCM과 같은 AEAD 모드를 사용하는 경우 암호화의 경우 인증 태그가 추가되거나 암호 해독의 경우 확인됩니다. 결과는 새로운 버퍼에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="450b35c105bb3a8a209c60a29d62db449ae9ed42" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at &lt;code&gt;outputOffset&lt;/code&gt; inclusive.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 를 포함한, 임의의 입력이 이전 동안 버퍼링되었을 수 바이트 &lt;code&gt;update&lt;/code&gt; 동작 처리, 패딩 (요청한 경우)이 적용된다. GCM / CCM과 같은 AEAD 모드를 사용하는 경우 암호화의 경우 인증 태그가 추가되거나 암호 해독의 경우 확인됩니다. 결과는 &lt;code&gt;outputOffset&lt;/code&gt; 에서 시작 하여 &lt;code&gt;output&lt;/code&gt; 버퍼에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bbd7df6363c689dcf63bfdd1fdab1320c3d681" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 를 포함한, 임의의 입력이 이전 동안 버퍼링되었을 수 바이트 &lt;code&gt;update&lt;/code&gt; 동작 처리, 패딩 (요청한 경우)이 적용된다. GCM / CCM과 같은 AEAD 모드를 사용중인 경우 암호화의 경우 인증 태그가 추가되거나 암호 해독의 경우 확인됩니다. 결과는 &lt;code&gt;output&lt;/code&gt; 버퍼에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="28af7ec760e52fc6a243e293787fc7c9a7265ce5" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed, and the result is stored in a new buffer.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 의 포괄적 처리되어 결과가 새 버퍼에 저장된다.</target>
        </trans-unit>
        <trans-unit id="dee5e44e4c07e3f64df924e1f093b2408bc750bf" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed, and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at &lt;code&gt;outputOffset&lt;/code&gt; inclusive.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 의 포괄적 처리되어 결과가 저장되는 &lt;code&gt;output&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;outputOffset&lt;/code&gt; 포함.</target>
        </trans-unit>
        <trans-unit id="642f9a22f339ca697888f292e90a89ff6619eb68" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt; buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed, and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer.</source>
          <target state="translated">최초 &lt;code&gt;inputLen&lt;/code&gt; 바이트 &lt;code&gt;input&lt;/code&gt; 에서 시작하여, 버퍼 &lt;code&gt;inputOffset&lt;/code&gt; 에 , 처리를 포함한, 그 결과가 저장되는 &lt;code&gt;output&lt;/code&gt; 버퍼.</target>
        </trans-unit>
        <trans-unit id="823a750eb068b083af9a3eec820704505156eba9" translate="yes" xml:space="preserve">
          <source>The first ClassLoader in a &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is always the MBean Server's own ClassLoader.</source>
          <target state="translated">ClassLoaderRepository의 최초의 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 는 항상 MBean Server 자신의 ClassLoader입니다.</target>
        </trans-unit>
        <trans-unit id="0aee605bf67dfc0c50ce0346dbcf9350e8a06cf8" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;code&gt;null&lt;/code&gt; or is a string of length zero.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;null&lt;/code&gt; 이거나 길이가 0 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2d03bc23e5360de30337060058588182a9ceb237" translate="yes" xml:space="preserve">
          <source>The first argument is treated as the name of a system property. System properties are accessible through the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(java.lang.String)&lt;/code&gt;&lt;/a&gt; method. The string value of this property is then interpreted as a &lt;code&gt;long&lt;/code&gt; value using the grammar supported by &lt;a href=&quot;long#decode-java.lang.String-&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; and a &lt;code&gt;Long&lt;/code&gt; object representing this value is returned.</source>
          <target state="translated">첫 번째 인수는 시스템 특성의 이름으로 취급됩니다. 시스템 특성은 &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드를 통해 액세스 할 수 있습니다 . 이 속성의 문자열 값은 다음과 같이 해석됩니다 &lt;code&gt;long&lt;/code&gt; 지원하는 문법을 사용하여 값을 &lt;a href=&quot;long#decode-java.lang.String-&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 하고 &lt;code&gt;Long&lt;/code&gt; 이 값을 나타내는 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca7bb292bb179eff369391d94b8d8d3d6c76e98" translate="yes" xml:space="preserve">
          <source>The first argument is treated as the name of a system property. System properties are accessible through the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(java.lang.String)&lt;/code&gt;&lt;/a&gt; method. The string value of this property is then interpreted as an integer value using the grammar supported by &lt;a href=&quot;integer#decode-java.lang.String-&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; and an &lt;code&gt;Integer&lt;/code&gt; object representing this value is returned.</source>
          <target state="translated">첫 번째 인수는 시스템 특성의 이름으로 취급됩니다. 시스템 특성은 &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드를 통해 액세스 할 수 있습니다 . 이 속성의 문자열 값은 다음에 의해 지원되는 문법을 사용하여 정수 값으로 해석되어 &lt;a href=&quot;integer#decode-java.lang.String-&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Integer&lt;/code&gt; 이 값을 나타내는 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="b2ae25b2e2ebc2286380592b87b73e4532b3206e" translate="yes" xml:space="preserve">
          <source>The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.</source>
          <target state="translated">누적 기 함수에 전달 된 첫 번째 인수, 결합기 함수에 전달 된 인수 및 피니셔 함수에 전달 된 인수는 이전에 결과 공급자, 누적 기 또는 결합기 함수를 호출 한 결과 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b8fb133ed9ac9f35d1632cf6521f669da4fe312e" translate="yes" xml:space="preserve">
          <source>The first argument will be of type &lt;code&gt;refc&lt;/code&gt; if the lookup class has full privileges to access the member. Otherwise the member must be &lt;code&gt;protected&lt;/code&gt; and the first argument will be restricted in type to the lookup class.</source>
          <target state="translated">조회 클래스에 멤버에 액세스 할 수있는 모든 권한이있는 경우 첫 번째 인수는 &lt;code&gt;refc&lt;/code&gt; 유형 입니다. 그렇지 않으면 멤버를 &lt;code&gt;protected&lt;/code&gt; 해야하며 첫 번째 인수는 조회 클래스 유형으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdce5da33999948b7b9edbf1747b81239005798" translate="yes" xml:space="preserve">
          <source>The first boundary after the specified offset or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the last text boundary is passed in as the offset.</source>
          <target state="translated">지정된 오프셋 이후의 첫 번째 경계 또는 마지막 텍스트 경계가 오프셋으로 전달 된 경우 &lt;code&gt;BreakIterator.DONE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60f933636fde5ae8ebd2c0b809d58ad8770e0632" translate="yes" xml:space="preserve">
          <source>The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let</source>
          <target state="translated">첫 번째 바이트는 판독 소자에 저장된 &lt;code&gt;b[0]&lt;/code&gt; , 다음으로 하나 &lt;code&gt;b[1]&lt;/code&gt; 그래서, 및. 읽은 바이트 수는 기껏해야 &lt;code&gt;b&lt;/code&gt; 길이와 같습니다 . 허락하다</target>
        </trans-unit>
        <trans-unit id="d03b0acc59bce24602d657d7614371387c0d8fd1" translate="yes" xml:space="preserve">
          <source>The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;code&gt;k&lt;/code&gt; be the number of bytes actually read; these bytes will be stored in elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[k-1]&lt;/code&gt;, leaving elements &lt;code&gt;b[k]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.</source>
          <target state="translated">첫 번째 바이트는 판독 소자에 저장된 &lt;code&gt;b[0]&lt;/code&gt; , 다음으로 하나 &lt;code&gt;b[1]&lt;/code&gt; 그래서, 및. 읽은 바이트 수는 기껏해야 &lt;code&gt;b&lt;/code&gt; 길이와 같습니다 . &lt;code&gt;k&lt;/code&gt; 는 실제로 읽은 바이트 수를 보자 . 이 바이트는 소자에 저장 될 것이다 &lt;code&gt;b[0]&lt;/code&gt; 을 &lt;code&gt;b[k-1]&lt;/code&gt; , 원소 이탈 &lt;code&gt;b[k]&lt;/code&gt; 내지 &lt;code&gt;b[b.length-1]&lt;/code&gt; 영향을받지 않는다.</target>
        </trans-unit>
        <trans-unit id="a8f1de6428cb4228c88c1554b26b34675848c6a6" translate="yes" xml:space="preserve">
          <source>The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let</source>
          <target state="translated">첫 번째 바이트는 판독 소자에 저장된다 &lt;code&gt;b[off]&lt;/code&gt; 로 다음의 하나의 &lt;code&gt;b[off+1]&lt;/code&gt; , 등. 읽은 바이트 수는 최대 &lt;code&gt;len&lt;/code&gt; 과 같습니다 . 허락하다</target>
        </trans-unit>
        <trans-unit id="c1d045c55ceefb91cc2dece8b6706b626a6357c6" translate="yes" xml:space="preserve">
          <source>The first call to the &lt;a href=&quot;keystore.builder#getKeyStore--&quot;&gt;&lt;code&gt;getKeyStore()&lt;/code&gt;&lt;/a&gt; method on the returned builder will create a KeyStore of type &lt;code&gt;type&lt;/code&gt; and call its &lt;a href=&quot;keystore#load-java.io.InputStream-char:A-&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; method. The &lt;code&gt;inputStream&lt;/code&gt; argument is constructed from &lt;code&gt;file&lt;/code&gt;. If &lt;code&gt;protection&lt;/code&gt; is a &lt;code&gt;PasswordProtection&lt;/code&gt;, the password is obtained by calling the &lt;code&gt;getPassword&lt;/code&gt; method. Otherwise, if &lt;code&gt;protection&lt;/code&gt; is a &lt;code&gt;CallbackHandlerProtection&lt;/code&gt;, the password is obtained by invoking the CallbackHandler.</source>
          <target state="translated">받는 첫 번째 호출 &lt;a href=&quot;keystore.builder#getKeyStore--&quot;&gt; &lt;code&gt;getKeyStore()&lt;/code&gt; &lt;/a&gt; 반환 빌더에 대한 방법은 타입의 키 스토어 생성합니다 &lt;code&gt;type&lt;/code&gt; 하고 전화를 &lt;a href=&quot;keystore#load-java.io.InputStream-char:A-&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 메소드를. &lt;code&gt;inputStream&lt;/code&gt; 인수로 구성됩니다 &lt;code&gt;file&lt;/code&gt; . 경우 &lt;code&gt;protection&lt;/code&gt; A는 &lt;code&gt;PasswordProtection&lt;/code&gt; , 암호 호출에 의해 얻어진다 &lt;code&gt;getPassword&lt;/code&gt; 방법. 그렇지 않으면 &lt;code&gt;protection&lt;/code&gt; 가 &lt;code&gt;CallbackHandlerProtection&lt;/code&gt; 인 경우 CallbackHandler 를 호출하여 비밀번호를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2f9b613c261320a940fcb9e06c67d081c2e33e53" translate="yes" xml:space="preserve">
          <source>The first character of the resulting string will be the character at this buffer's position, while the last character will be the character at index &lt;code&gt;limit()&lt;/code&gt; - 1. Invoking this method does not change the buffer's position.</source>
          <target state="translated">결과 문자열의 첫 번째 문자는이 버퍼 위치의 문자이고 마지막 문자는 index &lt;code&gt;limit()&lt;/code&gt; -1 의 문자입니다 .이 메소드를 호출해도 버퍼의 위치는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbf37e7b81a7fb879c8f2e225eb28bf22a25c9af" translate="yes" xml:space="preserve">
          <source>The first character to be copied is at index &lt;code&gt;srcBegin&lt;/code&gt;; the last character to be copied is at index &lt;code&gt;srcEnd-1&lt;/code&gt; (thus the total number of characters to be copied is &lt;code&gt;srcEnd-srcBegin&lt;/code&gt;). The characters are copied into the subarray of &lt;code&gt;dst&lt;/code&gt; starting at index &lt;code&gt;dstBegin&lt;/code&gt; and ending at index:</source>
          <target state="translated">복사 될 첫 문자는 index &lt;code&gt;srcBegin&lt;/code&gt; 입니다 . 복사 될 마지막 문자는 인덱스 &lt;code&gt;srcEnd-1&lt;/code&gt; 에 있습니다 (따라서 복사 될 총 문자 수는 &lt;code&gt;srcEnd-srcBegin&lt;/code&gt; 입니다 ). 문자는 인덱스 &lt;code&gt;dstBegin&lt;/code&gt; 에서 시작하여 인덱스에서 끝나는 &lt;code&gt;dst&lt;/code&gt; 의 서브 어레이에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="de566e0e6c84a80db615c5af628dc587bf7facb7" translate="yes" xml:space="preserve">
          <source>The first character to be copied is at index &lt;code&gt;srcBegin&lt;/code&gt;; the last character to be copied is at index &lt;code&gt;srcEnd-1&lt;/code&gt;. The total number of characters to be copied is &lt;code&gt;srcEnd-srcBegin&lt;/code&gt;. The characters, converted to bytes, are copied into the subarray of &lt;code&gt;dst&lt;/code&gt; starting at index &lt;code&gt;dstBegin&lt;/code&gt; and ending at index:</source>
          <target state="translated">복사 될 첫 문자는 index &lt;code&gt;srcBegin&lt;/code&gt; 입니다 . 복사 될 마지막 문자는 인덱스 &lt;code&gt;srcEnd-1&lt;/code&gt; 입니다. 복사 될 총 문자 수는 &lt;code&gt;srcEnd-srcBegin&lt;/code&gt; 입니다. 바이트로 변환 된 문자 는 인덱스 &lt;code&gt;dstBegin&lt;/code&gt; 에서 시작하여 인덱스에서 끝나는 &lt;code&gt;dst&lt;/code&gt; 의 하위 배열에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecf2e38c35f8de71bd3d5a9b4b40324da1f7036a" translate="yes" xml:space="preserve">
          <source>The first class defined in a package determines the exact set of certificates that all subsequent classes defined in that package must contain. The set of certificates for a class is obtained from the &lt;a href=&quot;../security/codesource&quot;&gt;&lt;code&gt;&lt;code&gt;CodeSource&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; within the &lt;code&gt;ProtectionDomain&lt;/code&gt; of the class. Any classes added to that package must contain the same set of certificates or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown. Note that if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this check is not performed. You should always pass in the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class you are defining as well as the bytes. This ensures that the class you are defining is indeed the class you think it is.</source>
          <target state="translated">패키지에 정의 된 첫 번째 클래스는 해당 패키지에 정의 된 모든 후속 클래스에 포함되어야하는 정확한 인증서 세트를 결정합니다. 클래스에 대한 인증서 세트는 클래스 의 &lt;code&gt;ProtectionDomain&lt;/code&gt; 내의 &lt;a href=&quot;../security/codesource&quot;&gt; &lt;code&gt;&lt;code&gt;CodeSource&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 에서 가져옵니다 . 해당 패키지에 추가 된 모든 클래스는 동일한 인증서 세트를 포함해야합니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다. 경우합니다 &lt;code&gt;name&lt;/code&gt; 입니다 &lt;code&gt;null&lt;/code&gt; 이 검사가 수행되지 않습니다. 항상 정의하고있는 클래스 의 &lt;a href=&quot;#name&quot;&gt;이진 이름&lt;/a&gt; 과 바이트를 전달해야합니다. 이것은 당신이 정의하고있는 클래스가 실제로 당신이 생각하는 클래스가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="955b718107c9a85fdf32d9b7ba615294c28a2d9c" translate="yes" xml:space="preserve">
          <source>The first day-of-week defines the ISO &lt;code&gt;DayOfWeek&lt;/code&gt; that is day 1 of the week. The minimal number of days in the first week defines how many days must be present in a month or year, starting from the first day-of-week, before the week is counted as the first week. A value of 1 will count the first day of the month or year as part of the first week, whereas a value of 7 will require the whole seven days to be in the new month or year.</source>
          <target state="translated">첫 번째 요일 은 요일 1 인 ISO &lt;code&gt;DayOfWeek&lt;/code&gt; 를 정의합니다 . 첫 번째 주에서 최소 일 수는 첫 주부터 시작하여 첫 주로 계산되기까지 한 달 또는 연도에 몇 일이 있어야하는지 정의합니다. 값이 1이면 해당 월 또는 연도의 첫날이 첫 번째주의 일부로 계산되지만 값이 7이면 전체 7 일이 새 달 또는 연도에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ede957077563e4ac1530acfa41dc3ea489ec60df" translate="yes" xml:space="preserve">
          <source>The first day-of-week varies by culture. For example, the US uses Sunday, while France and the ISO-8601 standard use Monday. This method returns the first day using the standard &lt;code&gt;DayOfWeek&lt;/code&gt; enum.</source>
          <target state="translated">첫 번째 요일은 문화에 따라 다릅니다. 예를 들어 미국은 일요일을 사용하고 프랑스와 ISO-8601 표준은 월요일을 사용합니다. 이 메서드는 표준 &lt;code&gt;DayOfWeek&lt;/code&gt; 열거 형을 사용하여 첫날을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a1da0a3f174bbc2d15f94c1f2cc8178e672bfa46" translate="yes" xml:space="preserve">
          <source>The first day-of-week. For example, the ISO-8601 standard considers Monday to be the first day-of-week.</source>
          <target state="translated">첫 번째 요일. 예를 들어, ISO-8601 표준은 월요일을 첫 번째 요일로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="82e2b795a8a8cbc96640a5d47b1525ee3c2a5661" translate="yes" xml:space="preserve">
          <source>The first element (position &lt;code&gt;0&lt;/code&gt;) in the &lt;code&gt;DoubleStream&lt;/code&gt; will be the provided &lt;code&gt;seed&lt;/code&gt;. For &lt;code&gt;n &amp;gt; 0&lt;/code&gt;, the element at position &lt;code&gt;n&lt;/code&gt;, will be the result of applying the function &lt;code&gt;f&lt;/code&gt; to the element at position &lt;code&gt;n - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DoubleStream&lt;/code&gt; 의 첫 번째 요소 (위치 &lt;code&gt;0&lt;/code&gt; ) 는 제공된 &lt;code&gt;seed&lt;/code&gt; 됩니다. 들면 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; , 위치의 요소는 &lt;code&gt;n&lt;/code&gt; , 함수 적용의 결과 일 것이다 &lt;code&gt;f&lt;/code&gt; 위치의 요소를 &lt;code&gt;n - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bded7ce8d5601d17d37c716de18a736a7543797d" translate="yes" xml:space="preserve">
          <source>The first element (position &lt;code&gt;0&lt;/code&gt;) in the &lt;code&gt;IntStream&lt;/code&gt; will be the provided &lt;code&gt;seed&lt;/code&gt;. For &lt;code&gt;n &amp;gt; 0&lt;/code&gt;, the element at position &lt;code&gt;n&lt;/code&gt;, will be the result of applying the function &lt;code&gt;f&lt;/code&gt; to the element at position &lt;code&gt;n - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IntStream&lt;/code&gt; 의 첫 번째 요소 (위치 &lt;code&gt;0&lt;/code&gt; ) 는 제공된 &lt;code&gt;seed&lt;/code&gt; 됩니다. 들면 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; , 위치의 요소는 &lt;code&gt;n&lt;/code&gt; , 함수 적용의 결과 일 것이다 &lt;code&gt;f&lt;/code&gt; 위치의 요소를 &lt;code&gt;n - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a194dadcec7148ad3f47ec6fd680590400a3449e" translate="yes" xml:space="preserve">
          <source>The first element (position &lt;code&gt;0&lt;/code&gt;) in the &lt;code&gt;LongStream&lt;/code&gt; will be the provided &lt;code&gt;seed&lt;/code&gt;. For &lt;code&gt;n &amp;gt; 0&lt;/code&gt;, the element at position &lt;code&gt;n&lt;/code&gt;, will be the result of applying the function &lt;code&gt;f&lt;/code&gt; to the element at position &lt;code&gt;n - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LongStream&lt;/code&gt; 의 첫 번째 요소 (위치 &lt;code&gt;0&lt;/code&gt; ) 는 제공된 &lt;code&gt;seed&lt;/code&gt; 됩니다. 들면 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; , 위치의 요소는 &lt;code&gt;n&lt;/code&gt; , 함수 적용의 결과 일 것이다 &lt;code&gt;f&lt;/code&gt; 위치의 요소를 &lt;code&gt;n - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a165f1a0b54273ae7adbf840b0c7faa2330e5ac4" translate="yes" xml:space="preserve">
          <source>The first element (position &lt;code&gt;0&lt;/code&gt;) in the &lt;code&gt;Stream&lt;/code&gt; will be the provided &lt;code&gt;seed&lt;/code&gt;. For &lt;code&gt;n &amp;gt; 0&lt;/code&gt;, the element at position &lt;code&gt;n&lt;/code&gt;, will be the result of applying the function &lt;code&gt;f&lt;/code&gt; to the element at position &lt;code&gt;n - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 의 첫 번째 요소 (위치 &lt;code&gt;0&lt;/code&gt; ) 는 제공된 &lt;code&gt;seed&lt;/code&gt; 됩니다. 들면 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; , 위치의 요소는 &lt;code&gt;n&lt;/code&gt; , 함수 적용의 결과 일 것이다 &lt;code&gt;f&lt;/code&gt; 위치의 요소를 &lt;code&gt;n - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5aab3f29aca09be0c5627c5a993c1167fb0b36b" translate="yes" xml:space="preserve">
          <source>The first element of the iterator should be the most &quot;natural&quot; type for decoding the image with as little loss as possible. For example, for a JPEG image the first entry should be an RGB image, even though the image data is stored internally in a YCbCr color space.</source>
          <target state="translated">반복자의 첫 번째 요소는 가능한 한 적은 손실로 이미지를 디코딩하는 가장 &quot;자연적인&quot;유형이어야합니다. 예를 들어 JPEG 이미지의 경우 이미지 데이터가 YCbCr 색상 공간에 내부적으로 저장되어 있어도 첫 번째 항목은 RGB 이미지 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4f67dca9f7c2569783dcc958d9c49f4cfb6a3bb" translate="yes" xml:space="preserve">
          <source>The first element returned by the iterator represents the name element that is closest to the root in the directory hierarchy, the second element is the next closest, and so on. The last element returned is the name of the file or directory denoted by this path. The &lt;a href=&quot;path#getRoot--&quot;&gt;&lt;code&gt;root&lt;/code&gt;&lt;/a&gt; component, if present, is not returned by the iterator.</source>
          <target state="translated">반복자가 리턴 한 첫 번째 요소는 디렉토리 계층에서 루트에 가장 가까운 이름 요소를 나타내고 두 번째 요소는 다음으로 가장 가까운 요소입니다. 마지막으로 리턴 된 요소는이 경로로 표시된 파일 또는 디렉토리의 이름입니다. &lt;a href=&quot;path#getRoot--&quot;&gt; &lt;code&gt;root&lt;/code&gt; &lt;/a&gt; 구성 요소가 존재하는 경우, 반복자에 의해 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6413ccd6f5782f5342b586620e6f4a0abde22ef" translate="yes" xml:space="preserve">
          <source>The first example specifies the methods: POST, GET and DELETE, but no request headers. The second example specifies one request method and two headers. The third example specifies two request methods, and two headers.</source>
          <target state="translated">첫 번째 예는 POST, GET 및 DELETE 메소드를 지정하지만 요청 헤더는 지정하지 않습니다. 두 번째 예는 하나의 요청 방법과 두 개의 헤더를 지정합니다. 세 번째 예는 두 개의 요청 메소드와 두 개의 헤더를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="232fe5799d43af6e10cb304776efde1739a6180e" translate="yes" xml:space="preserve">
          <source>The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;, which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:</source>
          <target state="translated">첫 번째 예는 정적 메소드 &lt;code&gt;MessageFormat.format&lt;/code&gt; 을 사용하여 내부적 으로 일회용 으로 &lt;code&gt;MessageFormat&lt;/code&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="9f9027453c27f495317af2745753a0e023e2b7cf" translate="yes" xml:space="preserve">
          <source>The first invocation of any of the methods defined by this class causes the default &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;provider&lt;/code&gt;&lt;/a&gt; to be loaded. The default provider, identified by the URI scheme &quot;file&quot;, creates the &lt;a href=&quot;filesystem&quot;&gt;&lt;code&gt;FileSystem&lt;/code&gt;&lt;/a&gt; that provides access to the file systems accessible to the Java virtual machine. If the process of loading or initializing the default provider fails then an unspecified error is thrown.</source>
          <target state="translated">이 클래스에 의해 정의 된 메소드를 처음 호출하면 기본 &lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;provider&lt;/code&gt; &lt;/a&gt; 가로드됩니다. URI 체계 &quot;file&quot;로 식별되는 기본 제공자 는 Java 가상 머신에 액세스 가능한 파일 시스템에 대한 액세스를 제공 하는 &lt;a href=&quot;filesystem&quot;&gt; &lt;code&gt;FileSystem&lt;/code&gt; &lt;/a&gt; 을 작성합니다 . 기본 제공자를로드하거나 초기화하는 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b707d2f98066d10d4d06e91896be54d4b5b28f2" translate="yes" xml:space="preserve">
          <source>The first invocation of any of the methods defined by this class locates the default &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;provider&lt;/code&gt;&lt;/a&gt; object. Where the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is not defined then the default provider is a system-default provider that is invoked to create the default file system.</source>
          <target state="translated">이 클래스에 의해 정의 된 메소드 중 첫 번째 호출은 기본 &lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;provider&lt;/code&gt; &lt;/a&gt; 오브젝트를 찾습니다 . 시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 가 정의되지 않은 경우 기본 제공자는 기본 파일 시스템을 작성하기 위해 호출되는 시스템 기본 제공자입니다.</target>
        </trans-unit>
        <trans-unit id="9eb8bef38b28e15b1a42751b14de53ed5402bed9" translate="yes" xml:space="preserve">
          <source>The first invocation of the &lt;a href=&quot;spi/filesystemprovider#installedProviders&quot;&gt;&lt;code&gt;installedProviders&lt;/code&gt;&lt;/a&gt; method, by way of invoking any of the &lt;code&gt;newFileSystem&lt;/code&gt; methods defined by this class, locates and loads all installed file system providers. Installed providers are loaded using the service-provider loading facility defined by the &lt;a href=&quot;../../util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; class. Installed providers are loaded using the system class loader. If the system class loader cannot be found then the extension class loader is used; if there is no extension class loader then the bootstrap class loader is used. Providers are typically installed by placing them in a JAR file on the application class path or in the extension directory, the JAR file contains a provider-configuration file named &lt;code&gt;java.nio.file.spi.FileSystemProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, and the file lists one or more fully-qualified names of concrete subclass of &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;FileSystemProvider&lt;/code&gt;&lt;/a&gt; that have a zero argument constructor. The ordering that installed providers are located is implementation specific. If a provider is instantiated and its &lt;a href=&quot;spi/filesystemprovider#getScheme--&quot;&gt;&lt;code&gt;getScheme&lt;/code&gt;&lt;/a&gt; returns the same URI scheme of a provider that was previously instantiated then the most recently instantiated duplicate is discarded. URI schemes are compared without regard to case. During construction a provider may safely access files associated with the default provider but care needs to be taken to avoid circular loading of other installed providers. If circular loading of installed providers is detected then an unspecified error is thrown.</source>
          <target state="translated">이 클래스에 의해 정의 된 &lt;code&gt;newFileSystem&lt;/code&gt; 메소드 를 호출 하여 &lt;a href=&quot;spi/filesystemprovider#installedProviders&quot;&gt; &lt;code&gt;installedProviders&lt;/code&gt; &lt;/a&gt; 메소드를 처음 호출하면 설치된 모든 파일 시스템 제공자를 찾아로드합니다. 설치된 제공자는 &lt;a href=&quot;../../util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 클래스에 의해 정의 된 서비스 제공자로드 기능을 사용하여로드됩니다 . 설치된 프로 바이더는 시스템 클래스 로더를 사용하여로드됩니다. 시스템 클래스 로더를 찾을 수 없으면 확장 클래스 로더가 사용됩니다. 확장 클래스 로더가 없으면 부트 스트랩 클래스 로더가 사용됩니다. 제공자는 일반적으로 애플리케이션 클래스 경로 또는 확장 디렉토리의 JAR 파일에 배치하여 설치되며, JAR 파일에는 &lt;code&gt;java.nio.file.spi.FileSystemProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함됩니다.자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 파일에 인수 생성자가없는 &lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;FileSystemProvider&lt;/code&gt; &lt;/a&gt; 의 구체적인 서브 클래스의 하나 이상의 완전한 이름이 나열 됩니다. 설치된 공급자가있는 순서는 구현에 따라 다릅니다. 제공자가 인스턴스화되고 해당 &lt;a href=&quot;spi/filesystemprovider#getScheme--&quot;&gt; &lt;code&gt;getScheme&lt;/code&gt; &lt;/a&gt; 이 이전에 인스턴스화 된 제공자의 동일한 URI 스킴을 리턴하면 가장 최근에 인스턴스화 된 복제본이 삭제됩니다. URI 스킴은 대소 문자와 상관없이 비교됩니다. 구성하는 동안 공급자는 기본 공급자와 관련된 파일에 안전하게 액세스 할 수 있지만 설치된 다른 공급자의 순환로드를 피하기 위해주의를 기울여야합니다. 설치된 제공자의 순환로드가 감지되면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50b4cfa2ac06af0620f808ca10930df4c3cf1775" translate="yes" xml:space="preserve">
          <source>The first invocation of this method causes the default provider to be initialized (if not already initialized) and loads any other installed providers as described by the &lt;a href=&quot;../filesystems&quot;&gt;&lt;code&gt;FileSystems&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 메소드를 처음 호출하면 기본 제공자가 초기화되고 (아직 초기화되지 않은 경우) &lt;a href=&quot;../filesystems&quot;&gt; &lt;code&gt;FileSystems&lt;/code&gt; &lt;/a&gt; 클래스에 설명 된대로 설치된 다른 제공자를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="04ddabf3609314c77fc9442c207329a5bac474e5" translate="yes" xml:space="preserve">
          <source>The first invocation of this method creates the channel that is returned. Subsequent invocations of this method return the same channel.</source>
          <target state="translated">이 메소드의 첫 번째 호출은 리턴되는 채널을 작성합니다. 이 메소드의 후속 호출은 동일한 채널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41806187d179ed163c43e135856d8b855c241487" translate="yes" xml:space="preserve">
          <source>The first invocation of this method locates the default provider object as follows:</source>
          <target state="translated">이 메소드의 첫 번째 호출은 다음과 같이 기본 제공자 오브젝트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="58220b7cc0880c65c446fb69fdba5d879036d3cd" translate="yes" xml:space="preserve">
          <source>The first invocation of this method works as if invoking it were equivalent to evaluating the expression:</source>
          <target state="translated">이 메소드의 첫 번째 호출은 호출하는 것이 표현식을 평가하는 것과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ca058cd84f4d90ef57f22561005b44549ee1824" translate="yes" xml:space="preserve">
          <source>The first is a start signal that prevents any worker from proceeding until the driver is ready for them to proceed;</source>
          <target state="translated">첫 번째는 운전자가 진행할 준비가 될 때까지 작업자가 진행하지 못하게하는 시작 신호입니다.</target>
        </trans-unit>
        <trans-unit id="89010690973d5a466a568016925bd8250e0db1e5" translate="yes" xml:space="preserve">
          <source>The first item in the array must be the name of the service provider for the &quot;preferred&quot; reader, as it will be used to instantiate the &lt;code&gt;ImageReader&lt;/code&gt; returned by &lt;code&gt;ImageIO.getImageReader(ImageWriter)&lt;/code&gt;.</source>
          <target state="translated">배열의 첫 번째 항목은 &quot;선호&quot;리더에 대한 서비스 제공자의 이름이어야합니다 . &lt;code&gt;ImageIO.getImageReader(ImageWriter)&lt;/code&gt; 의해 리턴 된 &lt;code&gt;ImageReader&lt;/code&gt; 를 인스턴스화하는 데 사용되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="9b96b213b3a7afec438c64603d9c66e3022ffe8e" translate="yes" xml:space="preserve">
          <source>The first item in the array must be the name of the service provider for the &quot;preferred&quot; writer, as it will be used to instantiate the &lt;code&gt;ImageWriter&lt;/code&gt; returned by &lt;code&gt;ImageIO.getImageWriter(ImageReader)&lt;/code&gt;.</source>
          <target state="translated">배열의 첫 번째 항목은 &quot;선호&quot;작성기에 대한 서비스 제공자의 이름이어야합니다 . &lt;code&gt;ImageIO.getImageWriter(ImageReader)&lt;/code&gt; 의해 리턴 된 &lt;code&gt;ImageWriter&lt;/code&gt; 를 인스턴스화하는 데 사용되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d712c8c96e658d28ae5bf8727956e1bad67dd834" translate="yes" xml:space="preserve">
          <source>The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no prefix and an empty name sequence.</source>
          <target state="translated">추상 경로 이름의 첫 번째 이름은 디렉토리 이름이거나 Microsoft Windows UNC 경로 이름의 경우 호스트 이름 일 수 있습니다. 추상 경로명의 각 후속 이름은 디렉토리를 나타냅니다. 성은 디렉토리 또는 파일을 나타낼 수 있습니다. &lt;em&gt;빈&lt;/em&gt; 추상 패스는 접두사와 하늘의 이름 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb460a3d41545816fab893228040f63048f7d7fb" translate="yes" xml:space="preserve">
          <source>The first occurrence of the property from the constructor's environment parameter and (for appropriate properties) the applet parameters and system properties.</source>
          <target state="translated">생성자의 환경 매개 변수 및 애플릿 매개 변수 및 시스템 특성 (적절한 특성의 경우)에서 특성이 처음으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff7a6ea7d00a42f276b2164fd60502c29eb70ffa" translate="yes" xml:space="preserve">
          <source>The first of two UUIDs is greater than the second if the most significant field in which the UUIDs differ is greater for the first UUID.</source>
          <target state="translated">UUID가 다른 최상위 필드가 첫 번째 UUID보다 큰 경우 두 UUID 중 첫 번째가 두 번째 UUID보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="f47ae950941163171dfda88d6714786ffab47ac4" translate="yes" xml:space="preserve">
          <source>The first time a &lt;code&gt;invokevirtual&lt;/code&gt; instruction is executed it is linked, by symbolically resolving the names in the instruction and verifying that the method call is statically legal. This is true of calls to &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt;. In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax and names it contains are resolved. Thus, an &lt;code&gt;invokevirtual&lt;/code&gt; instruction which invokes a method handle will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist.</source>
          <target state="translated">호출 &lt;code&gt;invokevirtual&lt;/code&gt; 명령이 처음 실행될 때 명령의 이름을 상징적으로 확인하고 메소드 호출이 정적으로 합법적인지 확인하여 연결됩니다. 이것은 &lt;code&gt;invokeExact&lt;/code&gt; 및 &lt;code&gt;invoke&lt;/code&gt; 호출에 해당 됩니다. 이 경우 컴파일러에서 생성 한 기호 형식 설명자가 올바른 구문인지 확인하고 포함 된 이름이 확인됩니다. 따라서, 메소드 핸들을 호출 하는 &lt;code&gt;invokevirtual&lt;/code&gt; 명령은 기호 유형 설명자가 구문 상 올바르게 구성되고 유형이 존재하는 한 항상 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="7984f8d9f334e66a61a472a9952f92a917e7ab62" translate="yes" xml:space="preserve">
          <source>The first time this method is called, the security property &quot;ssl.ServerSocketFactory.provider&quot; is examined. If it is non-null, a class by that name is loaded and instantiated. If that is successful and the object is an instance of SSLServerSocketFactory, it is made the default SSL server socket factory.</source>
          <target state="translated">이 메소드를 처음 호출하면 보안 특성 &quot;ssl.ServerSocketFactory.provider&quot;가 검사됩니다. 널이 아닌 경우 해당 이름의 클래스가로드되고 인스턴스화됩니다. 성공하고 오브젝트가 SSLServerSocketFactory의 인스턴스 인 경우 기본 SSL 서버 소켓 팩토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="e23a8d2403200f42d35c95dbaa01e126e21da9de" translate="yes" xml:space="preserve">
          <source>The first time this method is called, the security property &quot;ssl.SocketFactory.provider&quot; is examined. If it is non-null, a class by that name is loaded and instantiated. If that is successful and the object is an instance of SSLSocketFactory, it is made the default SSL socket factory.</source>
          <target state="translated">이 메소드를 처음 호출하면 보안 특성 &quot;ssl.SocketFactory.provider&quot;가 검사됩니다. 널이 아닌 경우 해당 이름의 클래스가로드되고 인스턴스화됩니다. 성공하고 객체가 SSLSocketFactory의 인스턴스 인 경우 기본 SSL 소켓 팩토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="8a962c97e6518122f548b76af705929079edf476" translate="yes" xml:space="preserve">
          <source>The first two bytes are read, starting from the current file pointer, as if by &lt;code&gt;readUnsignedShort&lt;/code&gt;. This value gives the number of following bytes that are in the encoded string, not the length of the resulting string. The following bytes are then interpreted as bytes encoding characters in the modified UTF-8 format and are converted into characters.</source>
          <target state="translated">&lt;code&gt;readUnsignedShort&lt;/code&gt; 처럼 현재 파일 포인터에서 시작하여 처음 두 바이트를 읽습니다 . 이 값은 결과 문자열의 길이가 아니라 인코딩 된 문자열에있는 다음 바이트 수를 제공합니다. 다음 바이트는 수정 된 UTF-8 형식의 문자를 인코딩하는 바이트로 해석되어 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fbae85dad2c6f7a5278ce4329244cf84e25dc187" translate="yes" xml:space="preserve">
          <source>The first week of a week-based-year is the first Monday-based week of the standard ISO year that has at least 4 days in the new year.</source>
          <target state="translated">주별 첫 번째주는 표준 ISO 연도의 첫 번째 월요일 기반 주이며 새해에는 최소 4 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf30efc47ef55fd6ea1c557d0031cbff7deeca7" translate="yes" xml:space="preserve">
          <source>The fixed content-length when using fixed-length streaming mode. A value of &lt;code&gt;-1&lt;/code&gt; means fixed-length streaming mode is disabled for output.</source>
          <target state="translated">고정 길이 스트리밍 모드를 사용할 때 고정 컨텐트 길이입니다. &lt;code&gt;-1&lt;/code&gt; 값은 고정 길이 스트리밍 모드가 출력에 대해 비활성화됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="18122c06563b7f982531824d6ea7e1e9e3c9b49b" translate="yes" xml:space="preserve">
          <source>The flag</source>
          <target state="translated">깃발</target>
        </trans-unit>
        <trans-unit id="3bdde16f19a07f9b8dc2c1020a660b4e0748e32a" translate="yes" xml:space="preserve">
          <source>The flag implies UNICODE_CASE, that is, it enables Unicode-aware case folding.</source>
          <target state="translated">이 플래그는 UNICODE_CASE를 의미합니다. 즉, 유니 코드를 인식하는 대소 문자 접기가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8475b1dcbef3b5a8dfaaa365038143cbaecb1e14" translate="yes" xml:space="preserve">
          <source>The flags</source>
          <target state="translated">깃발</target>
        </trans-unit>
        <trans-unit id="acf1c6f398fdcbcb2dd9d5e16e98bf9f77cfd517" translate="yes" xml:space="preserve">
          <source>The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on matching when used in conjunction with this flag. The other flags become superfluous.</source>
          <target state="translated">CASE_INSENSITIVE 및 UNICODE_CASE 플래그는이 플래그와 함께 사용될 때 일치에 대한 영향을 유지합니다. 다른 깃발들은 불필요 해집니다.</target>
        </trans-unit>
        <trans-unit id="07c51b56a837ef2b8a02eed0aace501dd2b7868a" translate="yes" xml:space="preserve">
          <source>The flags field contains an illegal flag (something other than FINAL, SYNTHETIC, or MANDATED)</source>
          <target state="translated">flags 필드에 잘못된 플래그가 포함되어 있습니다 (FINAL, SYNTHETIC 또는 MANDATED 이외)</target>
        </trans-unit>
        <trans-unit id="6d843126f25e81dcab6945d31541378846e0fe18" translate="yes" xml:space="preserve">
          <source>The flags which tell if a specified calendar field for the calendar is set. A new object has no fields set. After the first call to a method which generates the fields, they all remain set after that. This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; booleans, with index values &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.</source>
          <target state="translated">달력에 지정된 달력 필드가 설정되어 있는지 여부를 알려주는 플래그입니다. 새 개체에는 필드가 설정되어 있지 않습니다. 필드를 생성하는 메소드를 처음 호출 한 후에는 모두 그 이후에 설정된 상태로 유지됩니다. 인덱스 값이 &lt;code&gt;ERA&lt;/code&gt; ~ &lt;code&gt;DST_OFFSET&lt;/code&gt; 인 &lt;code&gt;FIELD_COUNT&lt;/code&gt; 부울 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="c0adaae78bcbe2a1b61d64399723374aac50d29d" translate="yes" xml:space="preserve">
          <source>The float at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에있는 float</target>
        </trans-unit>
        <trans-unit id="5f5dd8efc09209346141f04c0616a37cc7043005" translate="yes" xml:space="preserve">
          <source>The float at the given index</source>
          <target state="translated">주어진 인덱스에서의 float</target>
        </trans-unit>
        <trans-unit id="df503d78651dfa6cbdc66ce61ad5b430069142aa" translate="yes" xml:space="preserve">
          <source>The float value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치의 float 값</target>
        </trans-unit>
        <trans-unit id="9d0d1c8af02f3824120d9d83ef3d660c0196db65" translate="yes" xml:space="preserve">
          <source>The float value at the given index</source>
          <target state="translated">주어진 인덱스의 float 값</target>
        </trans-unit>
        <trans-unit id="cf38f97e89711d18ff8d18b3b447db9c2e704c37" translate="yes" xml:space="preserve">
          <source>The floating-point number adjacent to &lt;code&gt;start&lt;/code&gt; in the direction of &lt;code&gt;direction&lt;/code&gt;.</source>
          <target state="translated">인접 부동 소수점 수는하기 &lt;code&gt;start&lt;/code&gt; 하는 방향으로 &lt;code&gt;direction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c9bf2083aa59da93c11b568d897301a010de3b" translate="yes" xml:space="preserve">
          <source>The floats between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the float at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이에있는 수레는 버퍼의 시작 부분에 복사됩니다 (있는 경우). 즉, 인덱스에서 부동</target>
        </trans-unit>
        <trans-unit id="e0d99827c8ce6a7f1ce1c355b0240827dea1dca3" translate="yes" xml:space="preserve">
          <source>The floor modulus is &lt;code&gt;x - (floorDiv(x, y) * y)&lt;/code&gt;, has the same sign as the divisor &lt;code&gt;y&lt;/code&gt;, and is in the range of &lt;code&gt;-abs(y) &amp;lt; r &amp;lt; +abs(y)&lt;/code&gt;.</source>
          <target state="translated">바닥 계수이다 &lt;code&gt;x - (floorDiv(x, y) * y)&lt;/code&gt; , 제수와 같은 투표 &lt;code&gt;y&lt;/code&gt; , 그리고 범위 인 &lt;code&gt;-abs(y) &amp;lt; r &amp;lt; +abs(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34b31fc78f10c0c8e222a5a96f8da8b395480561" translate="yes" xml:space="preserve">
          <source>The following &lt;a name=&quot;dFlags&quot;&gt;flags&lt;/a&gt; apply to general conversions:</source>
          <target state="translated">다음 &lt;a name=&quot;dFlags&quot;&gt;플래그&lt;/a&gt; 는 일반 변환에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="718105550381be452dea567eb4cb4d403db03a9d" translate="yes" xml:space="preserve">
          <source>The following &lt;a name=&quot;intFlags&quot;&gt;flags&lt;/a&gt; apply to numeric integral conversions:</source>
          <target state="translated">다음 &lt;a name=&quot;intFlags&quot;&gt;플래그&lt;/a&gt; 는 숫자 적분 변환에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c97a3fa3251171b01f24900b04fa28963a31f2e" translate="yes" xml:space="preserve">
          <source>The following &lt;a name=&quot;sample&quot;&gt;example&lt;/a&gt; shows a member of a resource bundle family with the base name &quot;MyResources&quot;. The text defines the bundle &quot;MyResources_de&quot;, the German member of the bundle family. This member is based on &lt;code&gt;PropertyResourceBundle&lt;/code&gt;, and the text therefore is the content of the file &quot;MyResources_de.properties&quot; (a related &lt;a href=&quot;listresourcebundle#sample&quot;&gt;example&lt;/a&gt; shows how you can add bundles to this family that are implemented as subclasses of &lt;code&gt;ListResourceBundle&lt;/code&gt;). The keys in this example are of the form &quot;s1&quot; etc. The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle. Keys are case-sensitive.</source>
          <target state="translated">다음 &lt;a name=&quot;sample&quot;&gt;예&lt;/a&gt; 는 기본 이름이 &quot;MyResources&quot;인 자원 번들 제품군의 구성원을 보여줍니다. 이 텍스트는 번들 제품군의 독일어 멤버 인 &quot;MyResources_de&quot;번들을 정의합니다. 이 멤버는 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 에 기반 하므로 텍스트는 &quot;MyResources_de.properties&quot;파일의 컨텐츠입니다 (관련 &lt;a href=&quot;listresourcebundle#sample&quot;&gt;예제&lt;/a&gt; 는 &lt;code&gt;ListResourceBundle&lt;/code&gt; 의 서브 클래스로 구현되는이 제품군에 번들을 추가하는 방법을 보여줍니다 ). 이 예제의 키는 &quot;s1&quot;형식입니다. 실제 키는 번들에서 오브젝트를 검색하기 위해 프로그램에서 사용하는 키와 동일한 한 전적으로 원하는대로 선택됩니다. 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ab872f1920dd3b6207973c5efd102398d0548897" translate="yes" xml:space="preserve">
          <source>The following &lt;a name=&quot;sample&quot;&gt;example&lt;/a&gt; shows two members of a resource bundle family with the base name &quot;MyResources&quot;. &quot;MyResources&quot; is the default member of the bundle family, and &quot;MyResources_fr&quot; is the French member. These members are based on &lt;code&gt;ListResourceBundle&lt;/code&gt; (a related &lt;a href=&quot;propertyresourcebundle#sample&quot;&gt;example&lt;/a&gt; shows how you can add a bundle to this family that's based on a properties file). The keys in this example are of the form &quot;s1&quot; etc. The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle. Keys are case-sensitive.</source>
          <target state="translated">다음 &lt;a name=&quot;sample&quot;&gt;예&lt;/a&gt; 는 기본 이름이 &quot;MyResources&quot;인 자원 번들 제품군의 두 구성원을 보여줍니다. &quot;MyResources&quot;는 번들 제품군의 기본 멤버이고 &quot;MyResources_fr&quot;은 프랑스어 멤버입니다. 이 멤버는 &lt;code&gt;ListResourceBundle&lt;/code&gt; 을 기반으로합니다 (관련 &lt;a href=&quot;propertyresourcebundle#sample&quot;&gt;예제&lt;/a&gt; 는 특성 파일을 기반으로이 패밀리에 번들을 추가하는 방법을 보여줍니다). 이 예제의 키는 &quot;s1&quot;형식입니다. 실제 키는 번들에서 오브젝트를 검색하기 위해 프로그램에서 사용하는 키와 동일한 한 전적으로 원하는대로 선택됩니다. 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="4d7bc9d38cfb742a7ccf3ed1fac435611b40a277" translate="yes" xml:space="preserve">
          <source>The following &lt;b&gt;Predefined Character classes&lt;/b&gt; and &lt;b&gt;POSIX character classes&lt;/b&gt; are in conformance with the recommendation of</source>
          <target state="translated">다음 &lt;b&gt;사전 정의 된 문자 클래스&lt;/b&gt; 및 &lt;b&gt;POSIX 문자 클래스&lt;/b&gt; 는 다음 의 권장 사항을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="3bdbb766d31b298fea0830eadf61cfd0cf5d8817" translate="yes" xml:space="preserve">
          <source>The following &lt;b&gt;conversions&lt;/b&gt; are performed:</source>
          <target state="translated">다음과 같은 &lt;b&gt;변환&lt;/b&gt; 이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dae9623d0c0d956fdb794a25b86835fd7a72be31" translate="yes" xml:space="preserve">
          <source>The following Finishings values are more specific; they indicate a corner or an edge as if the document were a portrait document:</source>
          <target state="translated">다음 마감 값이 더 구체적입니다. 문서가 세로 문서 인 것처럼 모서리 나 가장자리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df4565a08976159f98d000170c1e13b94b809704" translate="yes" xml:space="preserve">
          <source>The following Unicode characters are ignorable in a Java identifier or a Unicode identifier:</source>
          <target state="translated">다음 유니 코드 문자는 Java 식별자 또는 유니 코드 식별자에서 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1ee2b7fc161b561363a09eb8a74b719ec01fd3b" translate="yes" xml:space="preserve">
          <source>The following are calendar-specific fields and their values to be supported.</source>
          <target state="translated">다음은 일정 별 필드와 지원되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="f0b92be08cad28f715f6320945131c35c8b3277f" translate="yes" xml:space="preserve">
          <source>The following are errors:</source>
          <target state="translated">다음은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27f242fe17aebfc38c4d46f59d88bb9f72485164" translate="yes" xml:space="preserve">
          <source>The following are examples of lowercase characters:</source>
          <target state="translated">다음은 소문자의 예입니다.</target>
        </trans-unit>
        <trans-unit id="05d1989cc2fb19eeffe91f625bf1710856eae32f" translate="yes" xml:space="preserve">
          <source>The following are examples of parameters for constructing time zone objects.</source>
          <target state="translated">다음은 표준 시간대 개체를 구성하기위한 매개 변수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c270078ad6b151e92fcc3a3f5df550c25921664d" translate="yes" xml:space="preserve">
          <source>The following are examples of uppercase characters:</source>
          <target state="translated">다음은 대문자의 예입니다.</target>
        </trans-unit>
        <trans-unit id="60a5c21ec25e055a782b032c59385ba40939fb9a" translate="yes" xml:space="preserve">
          <source>The following are examples of using the predefined collectors to perform common mutable reduction tasks:</source>
          <target state="translated">다음은 사전 정의 된 콜렉터를 사용하여 일반적인 변경 가능한 축소 작업을 수행하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="9869b3b737829b0afd57282f629afb3659f3487b" translate="yes" xml:space="preserve">
          <source>The following are sample usages. Sample code assumes that the &lt;code&gt;Calendar&lt;/code&gt; constants are statically imported.</source>
          <target state="translated">다음은 샘플 사용법입니다. 샘플 코드는 &lt;code&gt;Calendar&lt;/code&gt; 상수를 정적으로 가져 오는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d04cf50de153033d5654b8c69914c1515d75abe8" translate="yes" xml:space="preserve">
          <source>The following cases may result in an AttributeNotFoundException:</source>
          <target state="translated">다음과 같은 경우 AttributeNotFoundException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5acfaa953e3076c682c3b2882e4f2bd0aa0de39" translate="yes" xml:space="preserve">
          <source>The following class and property files are provided:</source>
          <target state="translated">다음과 같은 클래스 및 특성 파일이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="81dad332c4884662d7929a6f97cdab033d2eefd0" translate="yes" xml:space="preserve">
          <source>The following code can be used to dump a delay queue into a newly allocated array of &lt;code&gt;Delayed&lt;/code&gt;:</source>
          <target state="translated">다음 코드를 사용하여 지연 큐를 새로 할당 된 &lt;code&gt;Delayed&lt;/code&gt; 배열로 덤프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26190c69388e00e900b9c89c33b9000b686392c1" translate="yes" xml:space="preserve">
          <source>The following code example shows how to construct an Rdn using the constructor that takes type and value as arguments:</source>
          <target state="translated">다음 코드 예제에서는 형식과 값을 인수로 사용하는 생성자를 사용하여 Rdn을 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1d5968a08703e94a4a5aee0f8466d3006c4a1e9e" translate="yes" xml:space="preserve">
          <source>The following code fragment demonstrates a trivial compression and decompression of a string using &lt;code&gt;Deflater&lt;/code&gt; and &lt;code&gt;Inflater&lt;/code&gt;.</source>
          <target state="translated">다음 코드 조각은 &lt;code&gt;Deflater&lt;/code&gt; 및 &lt;code&gt;Inflater&lt;/code&gt; 를 사용하여 문자열을 간단하게 압축 및 압축 해제하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="72e0bde62e0509950a2948eb0be98aef7dd9a610" translate="yes" xml:space="preserve">
          <source>The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look up only properties-based resources.</source>
          <target state="translated">다음 코드는 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 이 속성 기반 리소스 만 조회 하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="471278ae41758f2c54b16869909329024c1ee488" translate="yes" xml:space="preserve">
          <source>The following code prints a message every time an MBean is registered or unregistered in the MBean Server &lt;code&gt;mbeanServer&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 MBean이 MBean 서버 &lt;code&gt;mbeanServer&lt;/code&gt; 에 등록되거나 등록 해제 될 때마다 메시지를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="1a6a91a281ec6e889efce394abfb1affdb89dbd0" translate="yes" xml:space="preserve">
          <source>The following code produces a &lt;code&gt;Calendar&lt;/code&gt; with date 2012-12-31 (Gregorian) because Monday is the first day of a week with the &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt; ISO 8601 compatible week parameters&lt;/a&gt;.</source>
          <target state="translated">다음 코드는 월요일이 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 호환 가능 주 매개 변수를&lt;/a&gt; 가진 주중 첫 번째 날이므로 2012-12-31 (Gregorian) 날짜 의 &lt;code&gt;Calendar&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="ab87950614c84f4772b1d7cc623a175f6ebb12a9" translate="yes" xml:space="preserve">
          <source>The following code produces a Japanese &lt;code&gt;Calendar&lt;/code&gt; with date 1989-01-08 (Gregorian), assuming that the default &lt;a href=&quot;calendar#ERA&quot;&gt;&lt;code&gt;ERA&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;Heisei&lt;/em&gt; that started on that day.</source>
          <target state="translated">다음 코드는 기본 &lt;a href=&quot;calendar#ERA&quot;&gt; &lt;code&gt;ERA&lt;/code&gt; &lt;/a&gt; 가 해당 날짜에 시작된 &lt;em&gt;Heisei&lt;/em&gt; 라고 가정하고 날짜가 1989-01-08 (Gregorian) 인 일본어 &lt;code&gt;Calendar&lt;/code&gt; 을 생성합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb95ad0021945bf1fe0b77677f62f2eddf938b" translate="yes" xml:space="preserve">
          <source>The following code sample demonstrates a typical use of the Java Print Service API: locating printers that can print five double-sided copies of a Postscript document on size A4 paper, creating a print job from one of the returned print services, and calling print.</source>
          <target state="translated">다음 코드 샘플은 Java Print Service API의 일반적인 사용법을 보여줍니다. A4 용지에 Postscript 문서의 양면 사본 5 개를 인쇄 할 수있는 프린터 찾기, 반환 된 인쇄 서비스 중 하나에서 인쇄 작업 생성 및 인쇄 호출.</target>
        </trans-unit>
        <trans-unit id="61a3e32e5712ad50c78bb9995574b8ec96afd4b2" translate="yes" xml:space="preserve">
          <source>The following code sample shows how &lt;code&gt;ReferralException&lt;/code&gt; can be used.</source>
          <target state="translated">다음 코드 샘플은 &lt;code&gt;ReferralException&lt;/code&gt; 을 사용 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="295dfd5f08ff24826ebdec76538be9d8a00cde7a" translate="yes" xml:space="preserve">
          <source>The following code sample shows how the class may be used:</source>
          <target state="translated">다음 코드 샘플은 클래스 사용 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c2684c37b3b077871a2d4e193478dca11f29cf45" translate="yes" xml:space="preserve">
          <source>The following code would then create a thread and start it running:</source>
          <target state="translated">다음 코드는 스레드를 작성하고 실행을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="946ced931944ab0fcf761b372c7c62806047c2f5" translate="yes" xml:space="preserve">
          <source>The following conditions must be met for these fields:</source>
          <target state="translated">이 필드에 대해 다음 조건이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f38ba93abbce590c90018a23bf3e81cef79cf784" translate="yes" xml:space="preserve">
          <source>The following conversion characters are used for formatting common date/time compositions.</source>
          <target state="translated">다음 변환 문자는 일반적인 날짜 / 시간 구성 형식을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c66b6555275a8ae7b8cd84818ca1b598e5538c" translate="yes" xml:space="preserve">
          <source>The following conversion characters are used for formatting dates:</source>
          <target state="translated">날짜를 형식화하는 데 다음 변환 문자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8bd8675f37c0b0472b0f1f740378fad3a66a09e" translate="yes" xml:space="preserve">
          <source>The following conversion characters are used for formatting times:</source>
          <target state="translated">다음 변환 문자는 형식화 시간에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31da467b8ae22861cce42f28720a8a402495a4aa" translate="yes" xml:space="preserve">
          <source>The following conversions may be applied &lt;a href=&quot;../math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 변환은 &lt;a href=&quot;../math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; 에&lt;/a&gt; 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="106372fe58a46e0b53a99e94653db8a635804bea" translate="yes" xml:space="preserve">
          <source>The following conversions may be applied to &lt;a href=&quot;../math/biginteger&quot;&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 변환이 &lt;a href=&quot;../math/biginteger&quot;&gt; &lt;code&gt;BigInteger&lt;/code&gt; 에&lt;/a&gt; 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="425f9f130ceaded63e8cd23ffbe952eb42b803cd" translate="yes" xml:space="preserve">
          <source>The following conversions may be applied to &lt;code&gt;byte&lt;/code&gt;, &lt;a href=&quot;../lang/byte&quot;&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;a href=&quot;../lang/short&quot;&gt;&lt;code&gt;Short&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;int&lt;/code&gt; and &lt;a href=&quot;../lang/integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;a href=&quot;../lang/long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;byte&lt;/code&gt; , &lt;a href=&quot;../lang/byte&quot;&gt; &lt;code&gt;Byte&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;a href=&quot;../lang/short&quot;&gt; &lt;code&gt;Short&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;int&lt;/code&gt; 및 &lt;a href=&quot;../lang/integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;a href=&quot;../lang/long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; 에&lt;/a&gt; 다음 변환이 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628b61b529939ce21c13396cc22e331c7a3b9d5c" translate="yes" xml:space="preserve">
          <source>The following conversions may be applied to &lt;code&gt;float&lt;/code&gt;, &lt;a href=&quot;../lang/float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;double&lt;/code&gt; and &lt;a href=&quot;../lang/double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; , &lt;a href=&quot;../lang/float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;a href=&quot;../lang/double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; 에&lt;/a&gt; 다음 변환이 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdf545ba7fe2ae6fd85883f41cc47873b6d1c669" translate="yes" xml:space="preserve">
          <source>The following date and time conversion character suffixes are defined for the &lt;code&gt;'t'&lt;/code&gt; and &lt;code&gt;'T'&lt;/code&gt; conversions. The types are similar to but not completely identical to those defined by GNU &lt;code&gt;date&lt;/code&gt; and POSIX &lt;code&gt;strftime(3c)&lt;/code&gt;. Additional conversion types are provided to access Java-specific functionality (e.g. &lt;code&gt;'L'&lt;/code&gt; for milliseconds within the second).</source>
          <target state="translated">다음 날짜 및 시간 변환 문자 접미사는 &lt;code&gt;'t'&lt;/code&gt; 및 &lt;code&gt;'T'&lt;/code&gt; 변환에 대해 정의됩니다 . 형식은 GNU &lt;code&gt;date&lt;/code&gt; 및 POSIX &lt;code&gt;strftime(3c)&lt;/code&gt; 의해 정의 된 형식과 유사하지만 완전히 동일하지는 않습니다 . Java 특정 기능에 액세스하기 위해 추가 변환 유형이 제공됩니다 (예 : 1 초 내에 밀리 초 동안 &lt;code&gt;'L'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc0bdf19d79e85fd3faa8257d73b9cf092721d6e" translate="yes" xml:space="preserve">
          <source>The following date and time conversion suffix characters are defined for the &lt;code&gt;'t'&lt;/code&gt; and &lt;code&gt;'T'&lt;/code&gt; conversions. The types are similar to but not completely identical to those defined by GNU &lt;code&gt;date&lt;/code&gt; and POSIX &lt;code&gt;strftime(3c)&lt;/code&gt;. Additional conversion types are provided to access Java-specific functionality (e.g. &lt;code&gt;'L'&lt;/code&gt; for milliseconds within the second).</source>
          <target state="translated">다음 날짜 및 시간 변환 접미사 문자는 &lt;code&gt;'t'&lt;/code&gt; 및 &lt;code&gt;'T'&lt;/code&gt; 변환에 대해 정의됩니다 . 형식은 GNU &lt;code&gt;date&lt;/code&gt; 및 POSIX &lt;code&gt;strftime(3c)&lt;/code&gt; 의해 정의 된 형식과 유사하지만 완전히 동일하지는 않습니다 . Java 특정 기능에 액세스하기 위해 추가 변환 유형이 제공됩니다 (예 : 1 초 내에 밀리 초 동안 &lt;code&gt;'L'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="33dd939ab9a8811a3f514f61fa7645ae76748a7a" translate="yes" xml:space="preserve">
          <source>The following documentation applies to all LoginContext constructors:</source>
          <target state="translated">다음 문서는 모든 LoginContext 생성자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="320a95b6b1eff732752676660004dbf33979b776" translate="yes" xml:space="preserve">
          <source>The following effects are apparent, for each individual call site &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">각 개별 통화 사이트 &lt;code&gt;S&lt;/code&gt; 에 대해 다음과 같은 효과가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="463ef87e1f64592c662b8763e7359844386e8e8c" translate="yes" xml:space="preserve">
          <source>The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that can be used repeatedly:</source>
          <target state="translated">다음 예제는 반복적으로 사용할 수 있는 &lt;code&gt;MessageFormat&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4c0362218022022478f648938bce1a3580a3ed64" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to change the order of non-spacing accents,</source>
          <target state="translated">다음 예는 간격이없는 악센트의 순서를 변경하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9544db90443cafd3f6fc0065fcfeac4c28840a8a" translate="yes" xml:space="preserve">
          <source>The following example illustrates an aggregate operation using &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt;, computing the sum of the weights of the red widgets:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; 을&lt;/a&gt; 사용 하여 빨간색 위젯의 가중치 합계를 계산 하는 집계 조작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="fb0fc38b0edfba8464de0f6ce5acb42f0c3826b7" translate="yes" xml:space="preserve">
          <source>The following example illustrates an aggregate operation using &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt;, computing the sum of the weights of the red widgets:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; 을&lt;/a&gt; 사용 하여 빨간색 위젯의 가중치 합계를 계산 하는 집계 조작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="56de90bb181885f2389c4de7a52719567afaa7dc" translate="yes" xml:space="preserve">
          <source>The following example illustrates an aggregate operation using &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt;, computing the sum of the weights of the red widgets:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; 을&lt;/a&gt; 사용 하여 빨간색 위젯의 가중치 합계를 계산 하는 집계 조작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="8ddec311e730687f1c9ec6444d2caa4fa990646a" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;String.split&lt;/code&gt; method can be used to break up a string into its basic tokens:</source>
          <target state="translated">다음 예제는 &lt;code&gt;String.split&lt;/code&gt; 메소드를 사용하여 문자열을 기본 토큰으로 나누는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3748733e6de1f4871baf1bb05d5ddce1922aa9c4" translate="yes" xml:space="preserve">
          <source>The following example illustrates some refinements and idioms that may lead to better performance: RecursiveActions need not be fully recursive, so long as they maintain the basic divide-and-conquer approach. Here is a class that sums the squares of each element of a double array, by subdividing out only the right-hand-sides of repeated divisions by two, and keeping track of them with a chain of &lt;code&gt;next&lt;/code&gt; references. It uses a dynamic threshold based on method &lt;code&gt;getSurplusQueuedTaskCount&lt;/code&gt;, but counterbalances potential excess partitioning by directly performing leaf actions on unstolen tasks rather than further subdividing.</source>
          <target state="translated">다음 예는 성능을 향상시킬 수있는 몇 가지 개선 및 관용구를 보여줍니다. RecursiveAction은 기본 분할 및 정복 방식을 유지하는 한 완전히 재귀적일 필요는 없습니다. 반복 배열의 오른쪽 만 두 개로 세분화하고 &lt;code&gt;next&lt;/code&gt; 참조 체인으로 추적하여 이중 배열의 각 요소의 제곱을 합산하는 클래스가 있습니다 . &lt;code&gt;getSurplusQueuedTaskCount&lt;/code&gt; 메소드를 기반으로하는 동적 임계 값을 사용 하지만, 더 세분화하지 않고 도난되지 않은 태스크에 대해 리프 조치를 직접 수행하여 잠재적 인 초과 파티셔닝을 카운터 밸런스합니다.</target>
        </trans-unit>
        <trans-unit id="a6e6290101eb5dc8885bc7d24ad7895acf725371" translate="yes" xml:space="preserve">
          <source>The following example parses a PKCS#7-formatted certificate reply stored in a file and extracts all the certificates from it:</source>
          <target state="translated">다음 예제는 파일에 저장된 PKCS # 7 형식의 인증서 응답을 구문 분석하고 모든 인증서를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b6581c0e64b1be525be912d116aeb461af451685" translate="yes" xml:space="preserve">
          <source>The following example reads a file with Base64 encoded certificates, which are each bounded at the beginning by -----BEGIN CERTIFICATE-----, and bounded at the end by -----END CERTIFICATE-----. We convert the &lt;code&gt;FileInputStream&lt;/code&gt; (which does not support &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;) to a &lt;code&gt;BufferedInputStream&lt;/code&gt; (which supports those methods), so that each call to &lt;code&gt;generateCertificate&lt;/code&gt; consumes only one certificate, and the read position of the input stream is positioned to the next certificate in the file:</source>
          <target state="translated">다음 예제는 Base64로 인코딩 된 인증서가있는 파일을 읽습니다.이 인증서는 각각 ----- BEGIN CERTIFICATE -----로 시작하고 끝에 ----- END CERTIFICATE ----- . 우리는 변환 &lt;code&gt;FileInputStream&lt;/code&gt; 에 (안지지 않습니다 &lt;code&gt;mark&lt;/code&gt; 와 &lt;code&gt;reset&lt;/code&gt; A를) &lt;code&gt;BufferedInputStream&lt;/code&gt; 을 (그 방식을 지원합니다) 때문에, 호출 할 때마다 것을 &lt;code&gt;generateCertificate&lt;/code&gt; 로는 내의 다음의 증명서에 배치되도록 하나의 인증서, 입력 스트림의 read 위치를 소비 파일:</target>
        </trans-unit>
        <trans-unit id="f4c63e2e5d2c5bad8b48d446236f32973f675b19" translate="yes" xml:space="preserve">
          <source>The following example shows a Model MBean being used to make the &lt;code&gt;get&lt;/code&gt; method of a &lt;code&gt;HashMap&lt;/code&gt; available for management through an MBean server. No other methods are available through the MBean server. There is nothing special about &lt;code&gt;HashMap&lt;/code&gt; here. Public methods from any public class can be exposed for management in the same way.</source>
          <target state="translated">다음 예제는 MBean 서버를 통해 &lt;code&gt;HashMap&lt;/code&gt; 의 &lt;code&gt;get&lt;/code&gt; 메소드 를 관리 하는 데 사용하기 위해 사용되는 Model MBean을 보여줍니다 . MBean 서버를 통해 사용할 수있는 다른 방법은 없습니다. &lt;code&gt;HashMap&lt;/code&gt; 에는 특별한 것이 없습니다 . 모든 공개 클래스의 공개 메소드는 동일한 방식으로 관리에 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea50f0b6178150f168fc19ed1cb369f75bd8701" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;CollationKey&lt;/code&gt;s might be used to sort a list of &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">다음 예제는 &lt;code&gt;CollationKey&lt;/code&gt; 를 사용하여 &lt;code&gt;String&lt;/code&gt; 목록을 정렬하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ce6e79fdf9431b4c01ca7a6d0321f3ae696e0bd6" translate="yes" xml:space="preserve">
          <source>The following example shows how to compare two strings using the &lt;code&gt;Collator&lt;/code&gt; for the default locale.</source>
          <target state="translated">다음 예제는 기본 로케일에 대해 &lt;code&gt;Collator&lt;/code&gt; 를 사용하여 두 문자열을 비교하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c187db380cfc2f123c5979ca0ebed27c25c70c1d" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a &lt;code&gt;Locale&lt;/code&gt; object with the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;Builder&lt;/code&gt; 로 &lt;code&gt;Locale&lt;/code&gt; 객체 를 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="34a66fd3c2e9d5a20b80170ff37d4fcae56dbf7b" translate="yes" xml:space="preserve">
          <source>The following example shows how to use the public constructor &lt;a href=&quot;standardemittermbean#StandardEmitterMBean-T-java.lang.Class-javax.management.NotificationEmitter-&quot;&gt;&lt;code&gt;StandardEmitterMBean(implementation, mbeanInterface, emitter)&lt;/code&gt;&lt;/a&gt; to create an MBean emitting notifications with any implementation class name</source>
          <target state="translated">다음 예제는 공용 생성자 &lt;a href=&quot;standardemittermbean#StandardEmitterMBean-T-java.lang.Class-javax.management.NotificationEmitter-&quot;&gt; &lt;code&gt;StandardEmitterMBean(implementation, mbeanInterface, emitter)&lt;/code&gt; &lt;/a&gt; 을 사용하여 구현 클래스 이름으로 MBean 방출 알림을 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0332a21704227b2fe01c6ea2919706eb14858df4" translate="yes" xml:space="preserve">
          <source>The following example uses a &lt;code&gt;Class&lt;/code&gt; object to print the class name of an object:</source>
          <target state="translated">다음 예제는 &lt;code&gt;Class&lt;/code&gt; 객체를 사용하여 객체의 클래스 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="70e1b9830a3df588a8b8a729994679251f34346f" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate possible values for the &lt;code&gt;attributes&lt;/code&gt; parameter:</source>
          <target state="translated">다음 예제는 &lt;code&gt;attributes&lt;/code&gt; 매개 변수에 가능한 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6cf471a50873b59781f1a5d22c6455b5de64fb64" translate="yes" xml:space="preserve">
          <source>The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.</source>
          <target state="translated">다음 예제는 미국 로케일에서 날짜 및 시간 패턴이 해석되는 방식을 보여줍니다. 주어진 날짜와 시간은 미국 태평양 표준시의 2001-07-04 12:08:56 현지 시간입니다.</target>
        </trans-unit>
        <trans-unit id="d27a5fac9684ab445570c45c6aa8783eca1e2a54" translate="yes" xml:space="preserve">
          <source>The following form:</source>
          <target state="translated">다음과 같은 형태 :</target>
        </trans-unit>
        <trans-unit id="279fcc4d026d6759301de3593759ad5dea9bdb03" translate="yes" xml:space="preserve">
          <source>The following general conversions may be applied to any argument type:</source>
          <target state="translated">다음과 같은 일반적인 변환이 모든 인수 유형에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a6aefb999d419cd1a82d97d1a727b01ec7b7ec" translate="yes" xml:space="preserve">
          <source>The following interfaces are not MXBean interfaces:</source>
          <target state="translated">다음 인터페이스는 MXBean 인터페이스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b0b30e55e796a5ec6b2164196050ba8bf078c28" translate="yes" xml:space="preserve">
          <source>The following invariant holds for the mark, position, limit, and capacity values:</source>
          <target state="translated">마크, 위치, 한계 및 용량 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edfb837a44de40c003fa4a1712d49041093f4267" translate="yes" xml:space="preserve">
          <source>The following is a list of conditions under which this exception can be thrown:</source>
          <target state="translated">다음은이 예외가 발생할 수있는 조건 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3c66588b87527f1a5baf11483bf18ea1e5e20a3b" translate="yes" xml:space="preserve">
          <source>The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt; subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of resources you would probably use a &lt;code&gt;Map&lt;/code&gt;). Notice that you don't need to supply a value if a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same key with the same value (as for the okKey below).</source>
          <target state="translated">다음은 두 개의 자원을 관리 하는 &lt;code&gt;ResourceBundle&lt;/code&gt; 서브 클래스 &lt;code&gt;MyResources&lt;/code&gt; 의 매우 간단한 예입니다 (더 많은 수의 자원에 대해서는 &lt;code&gt;Map&lt;/code&gt; 을 사용할 것입니다 ). &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; 이 동일한 값을 가진 동일한 키를 처리하는 경우 (아래 okKey와 같이) 값을 제공 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bdaadb43c4aeb6da55f35a1a37d30ab08c2123d1" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use a key factory in order to instantiate a DSA public key from its encoding. Assume Alice has received a digital signature from Bob. Bob also sent her his public key (in encoded format) to verify his signature. Alice then performs the following actions:</source>
          <target state="translated">다음은 인코딩에서 DSA 공개 키를 인스턴스화하기 위해 키 팩토리를 사용하는 방법의 예입니다. Alice가 Bob으로부터 디지털 서명을 받았다고 가정하십시오. 또한 Bob은 서명을 확인하기 위해 공개 키 (인코딩 형식)를 보냈습니다. 그런 다음 Alice는 다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="804b14ddfbb725fdd0c6db2c193593fa8a180d72" translate="yes" xml:space="preserve">
          <source>The following is an example of loading XML-based bundles using &lt;a href=&quot;properties#loadFromXML-java.io.InputStream-&quot;&gt;&lt;code&gt;Properties.loadFromXML&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;properties#loadFromXML-java.io.InputStream-&quot;&gt; &lt;code&gt;Properties.loadFromXML&lt;/code&gt; 을&lt;/a&gt; 사용하여 XML 기반 번들을로드하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b19e1ceab964624bd7adda3910cb263b99752918" translate="yes" xml:space="preserve">
          <source>The following is an example of the bundle loading process with the default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.</source>
          <target state="translated">다음은 기본 &lt;code&gt;ResourceBundle.Control&lt;/code&gt; 구현을 사용한 번들로드 프로세스의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bea54c2ee0652c739fb146ce39cebf51995f73cb" translate="yes" xml:space="preserve">
          <source>The following is one example of the use of the tokenizer. The code:</source>
          <target state="translated">다음은 토크 나이저 사용의 한 예입니다. 코드:</target>
        </trans-unit>
        <trans-unit id="c2c0d7dfb61bac087e83f84901457fcbf7f4359a" translate="yes" xml:space="preserve">
          <source>The following low-level information summarizes relevant parts of the Java Virtual Machine specification. For full details, please see the current version of that specification. Each occurrence of an &lt;code&gt;invokedynamic&lt;/code&gt; instruction is called a &lt;em&gt;dynamic call site&lt;/em&gt;.</source>
          <target state="translated">다음의 저수준 정보는 Java Virtual Machine 사양의 관련 부분을 요약합니다. 자세한 내용은 해당 사양의 현재 버전을 참조하십시오. &lt;code&gt;invokedynamic&lt;/code&gt; 명령 의 각 발생을 &lt;em&gt;동적 호출 사이트라고합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a314b46d00422122cdcb27ebe2ea8043e6f6b1" translate="yes" xml:space="preserve">
          <source>The following method shuts down an &lt;code&gt;ExecutorService&lt;/code&gt; in two phases, first by calling &lt;code&gt;shutdown&lt;/code&gt; to reject incoming tasks, and then calling &lt;code&gt;shutdownNow&lt;/code&gt;, if necessary, to cancel any lingering tasks:</source>
          <target state="translated">다음 방법은 먼저 &lt;code&gt;shutdown&lt;/code&gt; 을 호출 하여 수신 작업을 거부 한 다음 필요한 경우 &lt;code&gt;shutdownNow&lt;/code&gt; 를 호출 하여 느린 작업을 취소 하여 두 단계 로 &lt;code&gt;ExecutorService&lt;/code&gt; 를 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="a328e9adb76cbb68764d8f97da4a65fd0868eb7c" translate="yes" xml:space="preserve">
          <source>The following method types are handled as special cases:</source>
          <target state="translated">다음과 같은 메소드 유형이 특수한 경우로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="32c5f835db7f701a964e6eeb354a81d6919fa866" translate="yes" xml:space="preserve">
          <source>The following methods are used to access the header fields and the contents after the connection is made to the remote object:</source>
          <target state="translated">원격 객체에 연결 한 후 헤더 필드 및 내용에 액세스하는 데 다음 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d58a87561186b3df4cf28fc117db16e1fb370f26" translate="yes" xml:space="preserve">
          <source>The following pattern letters are defined (all other characters from &lt;code&gt;'A'&lt;/code&gt; to &lt;code&gt;'Z'&lt;/code&gt; and from &lt;code&gt;'a'&lt;/code&gt; to &lt;code&gt;'z'&lt;/code&gt; are reserved):</source>
          <target state="translated">다음 패턴 문자가 정의되어 있습니다 (모든 다른 문자 &lt;code&gt;'A'&lt;/code&gt; 에 &lt;code&gt;'Z'&lt;/code&gt; 과에서를 &lt;code&gt;'a'&lt;/code&gt; 에 &lt;code&gt;'z'&lt;/code&gt; 예약되어 있습니다) :</target>
        </trans-unit>
        <trans-unit id="0581e85badd78769c153a1b23a991b8102df6ee3" translate="yes" xml:space="preserve">
          <source>The following permissions have been superseded by newer permissions or are associated with classes that have been deprecated: &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;Identity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;identityscope&quot;&gt;&lt;code&gt;IdentityScope&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;signer&quot;&gt;&lt;code&gt;Signer&lt;/code&gt;&lt;/a&gt;. Use of them is discouraged. See the applicable classes for more information.</source>
          <target state="translated">다음 권한은 새로운 권한으로 대체되었거나 더 이상 사용되지 않는 클래스 ( &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;Identity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;identityscope&quot;&gt; &lt;code&gt;IdentityScope&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;signer&quot;&gt; &lt;code&gt;Signer&lt;/code&gt; )&lt;/a&gt; 와 연관되어 있습니다 . 그것들의 사용은 권장되지 않습니다. 자세한 내용은 해당 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="095e3e7355fa19f5ee58289d9796e3e988d310d1" translate="yes" xml:space="preserve">
          <source>The following represents an example &lt;code&gt;Configuration&lt;/code&gt; entry based on the syntax above:</source>
          <target state="translated">다음은 위 구문을 기반으로 한 예제 &lt;code&gt;Configuration&lt;/code&gt; 항목을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f897dc897276fa2272fca1b98488f908fe0ba63e" translate="yes" xml:space="preserve">
          <source>The following rule is used to create the control:</source>
          <target state="translated">컨트롤을 만드는 데 다음 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e08456c6517fc0c2e3ee51167af4648cf8de1dd" translate="yes" xml:space="preserve">
          <source>The following rules are applied in the conversion:</source>
          <target state="translated">다음 규칙이 변환에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="08205e616ea1bce1e08b0bc0e1129d0240a8555c" translate="yes" xml:space="preserve">
          <source>The following rules are used to interpret glob patterns:</source>
          <target state="translated">glob 패턴을 해석하는 데 다음 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e662f5cafdbd5ecb60e1c6f67533b72f8424da4a" translate="yes" xml:space="preserve">
          <source>The following sections give further details of these rules.</source>
          <target state="translated">다음 섹션에서는 이러한 규칙에 대한 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="616bdaa8268db9337c435490cc6ea5d71fc28b55" translate="yes" xml:space="preserve">
          <source>The following syntax is supported for configuration data:</source>
          <target state="translated">구성 데이터에 대해 다음 구문이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ef5787f391778d570faa8f529dd2d4b7ec4d7af7" translate="yes" xml:space="preserve">
          <source>The following table lists all the possible NetPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표에는 가능한 모든 NetPermission 대상 이름이 나열되어 있으며 각각에 대해 권한이 허용하는 내용과 코드에 권한을 부여 할 수있는 위험에 대한 설명이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="17260818ccc38c24f91ff1a15d0d3826faa41c0e" translate="yes" xml:space="preserve">
          <source>The following table lists all the possible RuntimePermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표는 가능한 모든 RuntimePermission 대상 이름을 나열하고 각각에 대해 권한이 허용하는 대상에 대한 설명과 코드에 권한을 부여하는 위험에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ff5627793347ef7ce9be716f4b73a272dd3f460" translate="yes" xml:space="preserve">
          <source>The following table lists all the possible SSLPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표는 가능한 모든 SSLPermission 대상 이름을 나열하고 각각에 대해 권한이 무엇을 허용하는지에 대한 설명과 코드에 권한을 부여하는 위험에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f4e15c4be2288a1f5a4c41bc7168d70d61fef07" translate="yes" xml:space="preserve">
          <source>The following table lists all the possible SecurityPermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표는 가능한 모든 SecurityPermission 대상 이름을 나열하고 각각에 대해 권한이 허용하는 내용과 코드에 권한을 부여 할 수있는 위험에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9c80eaace1109e654052b6da7dfbb1e233a7e068" translate="yes" xml:space="preserve">
          <source>The following table lists all the possible SerializablePermission target names, and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표에는 가능한 모든 SerializablePermission 대상 이름이 나열되어 있으며 각각에 대해 권한이 무엇을 허용하는지에 대한 설명과 코드에 권한을 부여 할 때의 위험에 대한 설명이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f54160ed60b7126e0f30578518989c027ea5ce1b" translate="yes" xml:space="preserve">
          <source>The following table lists some common properties that should be used in implementations:</source>
          <target state="translated">다음 표는 구현에 사용해야하는 몇 가지 일반적인 속성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="660a03ca8d2ac49279e69071cdeceb003e271b59" translate="yes" xml:space="preserve">
          <source>The following table lists some common properties which service providers should use, if applicable:</source>
          <target state="translated">다음 표는 해당되는 경우 서비스 공급자가 사용해야하는 몇 가지 일반적인 속성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="179bd60df88f32c14ede99ee9b73f1703dc32793" translate="yes" xml:space="preserve">
          <source>The following table lists the possible &lt;code&gt;AudioPermission&lt;/code&gt; target names. For each name, the table provides a description of exactly what that permission allows, as well as a discussion of the risks of granting code the permission.</source>
          <target state="translated">다음 표는 가능한 &lt;code&gt;AudioPermission&lt;/code&gt; 대상 이름을 나열합니다 . 각 이름에 대해이 표는 해당 권한이 허용하는 대상에 대한 설명과 코드에 권한을 부여하는 위험에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c596c0991d22917115d21c4df40bbc0100da38f5" translate="yes" xml:space="preserve">
          <source>The following table provides a summary description of what the permission allows, and discusses the risks of granting code the permission.</source>
          <target state="translated">다음 표는 권한이 허용하는 것에 대한 요약 설명을 제공하고 코드에 권한을 부여하는 위험에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f2fb49e04ae635cd7cfef1d54fffded805a24728" translate="yes" xml:space="preserve">
          <source>The following table shows what parameter values an implementation might use for a representative set of reverberation settings.</source>
          <target state="translated">다음 표는 구현에서 대표적인 잔향 설정에 사용할 수있는 매개 변수 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="36442fed0b3c21cba2fc0264c571657e0341e0c1" translate="yes" xml:space="preserve">
          <source>The following table summarizes the supported conversions. Conversions denoted by an upper-case character (i.e. &lt;code&gt;'B'&lt;/code&gt;, &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'S'&lt;/code&gt;, &lt;code&gt;'C'&lt;/code&gt;, &lt;code&gt;'X'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt;, &lt;code&gt;'G'&lt;/code&gt;, &lt;code&gt;'A'&lt;/code&gt;, and &lt;code&gt;'T'&lt;/code&gt;) are the same as those for the corresponding lower-case conversion characters except that the result is converted to upper case according to the rules of the prevailing &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt;. The result is equivalent to the following invocation of &lt;a href=&quot;../lang/string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음 표는 지원되는 변환을 요약 한 것입니다. 대문자로 표시되는 변환 (예 : &lt;code&gt;'B'&lt;/code&gt; , &lt;code&gt;'H'&lt;/code&gt; , &lt;code&gt;'S'&lt;/code&gt; , &lt;code&gt;'C'&lt;/code&gt; , &lt;code&gt;'X'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; , &lt;code&gt;'G'&lt;/code&gt; , &lt;code&gt;'A'&lt;/code&gt; 및 &lt;code&gt;'T'&lt;/code&gt; )은 동일합니다 결과가 일반적인 &lt;a href=&quot;locale&quot;&gt; &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt; 규칙에 따라 대문자로 변환된다는 점을 제외하고 해당하는 소문자 변환 문자의 경우와 같습니다 . 결과는 다음 &lt;a href=&quot;../lang/string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65e243be51f564c984aa8e7b3c0b24bf9c633580" translate="yes" xml:space="preserve">
          <source>The following table summarizes the supported flags.</source>
          <target state="translated">다음 표는 지원되는 플래그를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="ccb7111863ddef3a44afb63ff5af119b506708e5" translate="yes" xml:space="preserve">
          <source>The following table summarizes the type mapping rules.</source>
          <target state="translated">다음 표는 유형 매핑 규칙을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6eb3829191aadf52b3efa4b3303459432ed38cd5" translate="yes" xml:space="preserve">
          <source>The following target name has been deprecated in favor of &lt;code&gt;createLoginContext.{name}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createLoginContext.{name}&lt;/code&gt; 대신 다음 대상 이름이 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="05b2a57dc3dff480b15b59294cea7041689febef" translate="yes" xml:space="preserve">
          <source>The following will accumulate strings into an ArrayList:</source>
          <target state="translated">다음은 문자열을 ArrayList에 누적합니다.</target>
        </trans-unit>
        <trans-unit id="ff3f1c7285fc03704a549b7ebe12c02f8a4efaf9" translate="yes" xml:space="preserve">
          <source>The following will classify &lt;code&gt;Person&lt;/code&gt; objects by city:</source>
          <target state="translated">다음은 도시별로 &lt;code&gt;Person&lt;/code&gt; 객체를 분류 합니다.</target>
        </trans-unit>
        <trans-unit id="659f4685dccfaaf333b539f6e067f1ae741d4c90" translate="yes" xml:space="preserve">
          <source>The following will classify &lt;code&gt;Person&lt;/code&gt; objects by state and city, cascading two &lt;code&gt;Collector&lt;/code&gt;s together:</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;Collector&lt;/code&gt; 연계하여 주 및 도시별로 &lt;code&gt;Person&lt;/code&gt; 객체를 분류 합니다.</target>
        </trans-unit>
        <trans-unit id="6241dc4fdeacf1d1841f3cd3b25a57ea3305649e" translate="yes" xml:space="preserve">
          <source>The following will take a stream of strings and concatenates them into a single string:</source>
          <target state="translated">다음은 문자열 스트림을 가져와 단일 문자열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa942ce1023e5baebf9a307baa7bd02eece99d" translate="yes" xml:space="preserve">
          <source>The form of the domain name is specified by RFC 2965. A domain name begins with a dot (&lt;code&gt;.foo.com&lt;/code&gt;) and means that the cookie is visible to servers in a specified Domain Name System (DNS) zone (for example, &lt;code&gt;www.foo.com&lt;/code&gt;, but not &lt;code&gt;a.b.foo.com&lt;/code&gt;). By default, cookies are only returned to the server that sent them.</source>
          <target state="translated">도메인 이름의 형식은 RFC 2965에 의해 지정됩니다. 도메인 이름은 점 ( &lt;code&gt;.foo.com&lt;/code&gt; )으로 시작 하며 쿠키는 지정된 DNS (Domain Name System) 영역 (예 : &lt;code&gt;www.foo.com&lt;/code&gt; )의 서버에서 볼 수 있음을 의미합니다 . foo.com 이지만 &lt;code&gt;a.b.foo.com&lt;/code&gt; ). 기본적으로 쿠키는 쿠키를 보낸 서버로만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="186d34b99f6c159fe7b20960d58eebbd64ab2b53" translate="yes" xml:space="preserve">
          <source>The form-feed character (&lt;code&gt;'\u000C'&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;'\u000C'&lt;/code&gt; 공급 문자 ( '\ u000C' )</target>
        </trans-unit>
        <trans-unit id="ac10df27c6523117883e512c48a3dc443ff47107" translate="yes" xml:space="preserve">
          <source>The formal grammar for connection ids that follow this convention is as follows (using the grammar notation from section 2.4 of &lt;em&gt;The Java&amp;trade; Language Specification&lt;/em&gt;):</source>
          <target state="translated">이 규칙을 따르는 연결 ID의 공식 문법은 다음과 같습니다 ( &lt;em&gt;The Java &amp;trade; Language Specification의&lt;/em&gt; 2.4 절의 문법 표기법 사용 ).</target>
        </trans-unit>
        <trans-unit id="2cf1258d334e355d142bef03535337a03ed0c616" translate="yes" xml:space="preserve">
          <source>The format and interpretation of &lt;code&gt;filter&lt;/code&gt; follows RFC 2254 with the following interpretations for &lt;code&gt;attr&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; mentioned in the RFC.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 의 형식 및 해석은 RFC에 언급 된 &lt;code&gt;attr&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 대한 다음 해석과 함께 RFC 2254를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="5b744b244f5335a7221e3aa66efc0d53650d86fb" translate="yes" xml:space="preserve">
          <source>The format consists of the &lt;code&gt;LocalDateTime&lt;/code&gt; followed by the &lt;code&gt;ZoneOffset&lt;/code&gt;. If the &lt;code&gt;ZoneId&lt;/code&gt; is not the same as the offset, then the ID is output. The output is compatible with ISO-8601 if the offset and ID are the same.</source>
          <target state="translated">형식은 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 &lt;code&gt;ZoneOffset&lt;/code&gt; 으로 구성됩니다 . 경우] &lt;code&gt;ZoneId&lt;/code&gt; 이 (가) 오프셋과 동일하지 후 ID를 출력한다. 오프셋과 ID가 동일한 경우 출력이 ISO-8601과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="e348646ae1fcbac451ad03744c692f77282975a4" translate="yes" xml:space="preserve">
          <source>The format consists of:</source>
          <target state="translated">형식은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9c6440eac25ca25ad1f5532fd5250acc6573ef48" translate="yes" xml:space="preserve">
          <source>The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard. No daylight saving time transition schedule can be specified with a custom time zone ID. If the specified string doesn't match the syntax, &lt;code&gt;&quot;GMT&quot;&lt;/code&gt; is used.</source>
          <target state="translated">형식은 로케일 독립적이며 숫자는 유니 코드 표준의 기본 라틴 블록에서 가져와야합니다. 사용자 지정 표준 시간대 ID를 사용하여 일광 절약 시간제 전환 일정을 지정할 수 없습니다. 지정된 문자열이 구문과 일치하지 않으면 &lt;code&gt;&quot;GMT&quot;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2abc0d69d332bd14c8108e7ef901fd679e5a23cb" translate="yes" xml:space="preserve">
          <source>The format is not defined, but an implementation must ensure that the string returned by this method can be used to build an equivalent descriptor when instantiated using the constructor &lt;a href=&quot;descriptorsupport#DescriptorSupport-java.lang.String-&quot;&gt;&lt;code&gt;DescriptorSupport(String inStr)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식은 정의되어 있지 않지만 구현에서는 &lt;a href=&quot;descriptorsupport#DescriptorSupport-java.lang.String-&quot;&gt; &lt;code&gt;DescriptorSupport(String inStr)&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 인스턴스화 할 때이 메소드가 리턴 한 문자열을 사용하여 동등한 설명자를 빌드 할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c239b759e0bd91e3deaa124baf341e96eadd502f" translate="yes" xml:space="preserve">
          <source>The format of a provider-configuration file violates the &lt;a href=&quot;serviceloader#format&quot;&gt;specification&lt;/a&gt;;</source>
          <target state="translated">공급자 구성 파일의 형식이 &lt;a href=&quot;serviceloader#format&quot;&gt;사양을&lt;/a&gt; 위반합니다 .</target>
        </trans-unit>
        <trans-unit id="10a6300c9d0f42d3b1164cab5831a27b66704f50" translate="yes" xml:space="preserve">
          <source>The format of the IPv6reference should follow that specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;IPv6 참조 형식&lt;/i&gt;&lt;/a&gt; 은 &lt;i&gt;RFC 2732 : URL의 리터럴 IPv6 주소 형식에&lt;/i&gt; 지정된 형식을 따라야 &lt;i&gt;합니다&lt;/i&gt; .</target>
        </trans-unit>
        <trans-unit id="e1864d871bbfba4b54130ce6fa9ccd149fe6fcc6" translate="yes" xml:space="preserve">
          <source>The format of the XML string is not defined, but an implementation must ensure that the string returned by &lt;a href=&quot;descriptorsupport#toXMLString--&quot;&gt;&lt;code&gt;toXMLString()&lt;/code&gt;&lt;/a&gt; on an existing descriptor can be used to instantiate an equivalent descriptor using this constructor.</source>
          <target state="translated">XML 문자열의 형식은 정의되어 있지 않지만 구현시 기존 설명자에서 &lt;a href=&quot;descriptorsupport#toXMLString--&quot;&gt; &lt;code&gt;toXMLString()&lt;/code&gt; &lt;/a&gt; 리턴 한 문자열을 사용하여이 생성자를 사용하여 동등한 설명자를 인스턴스화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d99535add274a0feacad81889acf4221b07d0c89" translate="yes" xml:space="preserve">
          <source>The format of the audio data contained in the stream.</source>
          <target state="translated">스트림에 포함 된 오디오 데이터의 형식입니다.</target>
        </trans-unit>
        <trans-unit id="05fc3b303a60aef7cfaee1c74286f09fc7d392d0" translate="yes" xml:space="preserve">
          <source>The format of the metadata contained in the XML &lt;code&gt;Document&lt;/code&gt; is identified by a string which appears as the root node of the tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt; objects. This string contains a version number, e.g. &quot;javax_imageio_jpeg_image_1.0&quot;. Readers and writers may support multiple versions of the same basic format and the Image I/O API has methods that allow specifying which version to use by passing the string to the method/constructor used to obtain an &lt;code&gt;IIOMetadata&lt;/code&gt; object. In some cases, a more recent version may not be strictly compatible with a program written expecting an older version (for an example, see the Native Metadata Format section of the JPEG Metadata Usage Notes below).</source>
          <target state="translated">XML &lt;code&gt;Document&lt;/code&gt; 포함 된 메타 데이터의 형식은 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 객체 트리의 루트 노드로 나타나는 문자열로 식별됩니다 . 이 문자열은 버전 번호 (예 : &quot;javax_imageio_jpeg_image_1.0&quot;)를 포함합니다. 리더와 라이터는 동일한 기본 형식의 여러 버전을 지원할 수 있으며 Image I / O API에는 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 를 얻는 데 사용 된 메서드 / 생성자에 문자열을 전달하여 사용할 버전을 지정할 수있는 메서드가 있습니다 . 경우에 따라 최신 버전이 이전 버전을 예상하여 작성된 프로그램과 엄격하게 호환되지 않을 수 있습니다 (예를 들어, 아래 JPEG 메타 데이터 사용 메모의 기본 메타 데이터 형식 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="cbdbd7a56c0b79b1e7da582d74bf2a348a161879" translate="yes" xml:space="preserve">
          <source>The format of the offset is controlled by a pattern which must be one of the following:</source>
          <target state="translated">오프셋 형식은 다음 중 하나 여야하는 패턴으로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2c2b152a17451e766c6d0d785dd6c0c42c5238" translate="yes" xml:space="preserve">
          <source>The format of the read data is not specified, but if an implementation supports &lt;a href=&quot;mlet#readExternal-java.io.ObjectInput-&quot;&gt;&lt;code&gt;readExternal(java.io.ObjectInput)&lt;/code&gt;&lt;/a&gt; it must also support &lt;a href=&quot;mlet#writeExternal-java.io.ObjectOutput-&quot;&gt;&lt;code&gt;writeExternal(java.io.ObjectOutput)&lt;/code&gt;&lt;/a&gt; in such a way that what is written by the latter can be read by the former.</source>
          <target state="translated">읽은 데이터의 형식은 지정되지 않지만 구현에서 &lt;a href=&quot;mlet#readExternal-java.io.ObjectInput-&quot;&gt; &lt;code&gt;readExternal(java.io.ObjectInput)&lt;/code&gt; &lt;/a&gt; 을 지원 하는 경우 후자가 작성한 내용을 읽을 수있는 방식으로 &lt;a href=&quot;mlet#writeExternal-java.io.ObjectOutput-&quot;&gt; &lt;code&gt;writeExternal(java.io.ObjectOutput)&lt;/code&gt; &lt;/a&gt; 도 지원해야합니다. 전자.</target>
        </trans-unit>
        <trans-unit id="fbf991f65c863ce81f15c443fc068ade469b4433" translate="yes" xml:space="preserve">
          <source>The format of the returned string will be &lt;code&gt;PTnHnMnS&lt;/code&gt;, where n is the relevant hours, minutes or seconds part of the duration. Any fractional seconds are placed after a decimal point i the seconds section. If a section has a zero value, it is omitted. The hours, minutes and seconds will all have the same sign.</source>
          <target state="translated">리턴 된 문자열의 형식은 &lt;code&gt;PTnHnMnS&lt;/code&gt; 입니다 . 여기서 n은 지속 시간의 관련 시간, 분 또는 초 부분입니다. 소수 부분 초는 소수 부분 i 초 섹션 뒤에 위치합니다. 섹션의 값이 0이면 생략됩니다. 시, 분 및 초는 모두 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f504d28c270f13a15deb747709fbbc28c2a06377" translate="yes" xml:space="preserve">
          <source>The format of the string does not correspond to a valid ObjectName.</source>
          <target state="translated">문자열 형식이 유효한 ObjectName에 해당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67213f01e1e8583efbac8e7258bbba0c3fc20def" translate="yes" xml:space="preserve">
          <source>The format of the written data is not specified, but if an implementation supports &lt;a href=&quot;mlet#writeExternal-java.io.ObjectOutput-&quot;&gt;&lt;code&gt;writeExternal(java.io.ObjectOutput)&lt;/code&gt;&lt;/a&gt; it must also support &lt;a href=&quot;mlet#readExternal-java.io.ObjectInput-&quot;&gt;&lt;code&gt;readExternal(java.io.ObjectInput)&lt;/code&gt;&lt;/a&gt; in such a way that what is written by the former can be read by the latter.</source>
          <target state="translated">기록 된 데이터의 형식은 지정되지 않지만 구현이 &lt;a href=&quot;mlet#writeExternal-java.io.ObjectOutput-&quot;&gt; &lt;code&gt;writeExternal(java.io.ObjectOutput)&lt;/code&gt; &lt;/a&gt; 을 지원 하는 경우 전자가 작성한 내용을 읽을 수있는 방식으로 &lt;a href=&quot;mlet#readExternal-java.io.ObjectInput-&quot;&gt; &lt;code&gt;readExternal(java.io.ObjectInput)&lt;/code&gt; &lt;/a&gt; 도 지원해야합니다. 후자의.</target>
        </trans-unit>
        <trans-unit id="f6020ce09c1e4d4ec666557878868f95d5d65fb6" translate="yes" xml:space="preserve">
          <source>The format of this string is described in the section &lt;a href=&quot;mxbean#type-names&quot;&gt;Type Names&lt;/a&gt; of the MXBean specification.</source>
          <target state="translated">이 문자열의 형식은 MXBean 스펙의 &lt;a href=&quot;mxbean#type-names&quot;&gt;유형 이름&lt;/a&gt; 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d3b3bc4192e2a3475a44b9d2b7b65fd6277144" translate="yes" xml:space="preserve">
          <source>The format should include the entire state of the object.</source>
          <target state="translated">형식은 객체의 전체 상태를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7596810905a51fecd6f83bdfab4d5540921936d" translate="yes" xml:space="preserve">
          <source>The format specifier which does not have a width</source>
          <target state="translated">너비가없는 형식 지정자</target>
        </trans-unit>
        <trans-unit id="043084d451c25a99dbe68ad95096051b578a0bcb" translate="yes" xml:space="preserve">
          <source>The format specifiers for general, character, and numeric types have the following syntax:</source>
          <target state="translated">일반, 문자 및 숫자 유형의 형식 지정자는 다음 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="445503196824627d242ab13a02f403b7cf0ba95e" translate="yes" xml:space="preserve">
          <source>The format specifiers for types which are used to represents dates and times have the following syntax:</source>
          <target state="translated">날짜와 시간을 나타내는 데 사용되는 형식의 형식 지정자는 다음 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1f5372c3a3d6ab4effeaec652a6cca082ace5f1a" translate="yes" xml:space="preserve">
          <source>The format specifiers which do not correspond to arguments have the following syntax:</source>
          <target state="translated">인수에 해당하지 않는 형식 지정자는 다음 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="578480d24c9aa71ffd93d6698d6025b396d96e7b" translate="yes" xml:space="preserve">
          <source>The format used is the same as &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용되는 형식은 &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d30c57ca5e389c0408c9e4853695750e44db69b9" translate="yes" xml:space="preserve">
          <source>The format used will be the shortest that outputs the full value of the time where the omitted parts are implied to be zero.</source>
          <target state="translated">사용 된 형식은 생략 된 부분이 0으로 암시되는 시간의 전체 값을 출력하는 가장 짧은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b5668256a561602f226996b461ed4d6a78b7620c" translate="yes" xml:space="preserve">
          <source>The format will be '{min}/{largestMin} - {smallestMax}/{max}', where the largestMin or smallestMax sections may be omitted, together with associated slash, if they are the same as the min or max.</source>
          <target state="translated">형식은 '{min} / {largestMin}-{smallestMax} / {max}'입니다. 여기서 maximumMin 또는 smallestMax 섹션은 min 또는 max와 동일한 경우 관련 슬래시와 함께 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509d4cab08978635bbfa5b631cb5bb8efac09dae" translate="yes" xml:space="preserve">
          <source>The formats returned by the &lt;a href=&quot;resourcebundle.control#getFormats-java.lang.String-&quot;&gt;&lt;code&gt;getFormats&lt;/code&gt;&lt;/a&gt; method and candidate locales returned by the &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;getCandidateLocales&lt;/code&gt;&lt;/a&gt; method must be consistent in all &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods may return unintended bundles. For example, if only &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt; method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the second call will return the class-based one that has been cached during the first call.</source>
          <target state="translated">&lt;a href=&quot;resourcebundle.control#getFormats-java.lang.String-&quot;&gt; &lt;code&gt;getFormats&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 형식 및 &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;getCandidateLocales&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 후보 로케일 은 동일한 기본 번들에 대한 모든 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 호출 에서 일관성이 있어야합니다 . 그렇지 않으면 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 메소드가 의도하지 않은 번들을 리턴 할 수 있습니다. 예를 들어, &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 에 대한 첫 번째 호출 에 대해서는 &lt;code&gt;getFormats&lt;/code&gt; 메소드 가 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 만 리턴 하고 두 번째 호출에 대해서는 &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; 만 리턴하면 두 번째 호출은 클래스 기반 호출을 리턴합니다. 첫 번째 통화 중에 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa01f15b0b2302f3a77b309cda420bc04d7418d1" translate="yes" xml:space="preserve">
          <source>The formatted number string</source>
          <target state="translated">서식이 지정된 숫자 문자열</target>
        </trans-unit>
        <trans-unit id="182105ef6901365d5695117e4cfb7d169f95dc6a" translate="yes" xml:space="preserve">
          <source>The formatter will format if data is available for all the fields contained within it. The formatter will parse if the string matches, otherwise no error is returned.</source>
          <target state="translated">포맷터는 데이터가 포함 된 모든 필드에 대해 데이터를 사용할 수있는 경우 포맷합니다. 문자열이 일치하면 포맷터가 구문 분석하고 그렇지 않으면 오류가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f3d2dba38dbe5eb07f6491258e9927edabf3d82" translate="yes" xml:space="preserve">
          <source>The formatter will use the &lt;a href=&quot;../../util/locale#getDefault-java.util.Locale.Category-&quot;&gt;&lt;code&gt;default FORMAT locale&lt;/code&gt;&lt;/a&gt;. This can be changed using &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt;&lt;code&gt;withLocale(Locale)&lt;/code&gt;&lt;/a&gt; on the returned formatter Alternatively use the &lt;a href=&quot;datetimeformatter#ofPattern-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;ofPattern(String, Locale)&lt;/code&gt;&lt;/a&gt; variant of this method.</source>
          <target state="translated">포맷터는 &lt;a href=&quot;../../util/locale#getDefault-java.util.Locale.Category-&quot;&gt; &lt;code&gt;default FORMAT locale&lt;/code&gt; &lt;/a&gt; 사용합니다 . 리턴 된 포매터에서 &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt; &lt;code&gt;withLocale(Locale)&lt;/code&gt; &lt;/a&gt; 을 사용하여 변경할 수 있습니다. 또는 이 메소드 의 &lt;a href=&quot;datetimeformatter#ofPattern-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;ofPattern(String, Locale)&lt;/code&gt; &lt;/a&gt; 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10900480441d4fb200d2493b9b165c75a96be514" translate="yes" xml:space="preserve">
          <source>The formatter will use the specified locale. This can be changed using &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt;&lt;code&gt;withLocale(Locale)&lt;/code&gt;&lt;/a&gt; on the returned formatter</source>
          <target state="translated">포맷터는 지정된 로케일을 사용합니다. 이것은 반환 된 포맷터에서 &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt; &lt;code&gt;withLocale(Locale)&lt;/code&gt; &lt;/a&gt; 을 사용하여 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b8a6884838b5d2380f0211a6d7b078af03a56063" translate="yes" xml:space="preserve">
          <source>The formatting can be customized by specifying the &lt;a href=&quot;../formatter#syntax&quot;&gt;format string&lt;/a&gt; in the &lt;a href=&quot;#formatting&quot;&gt; &lt;code&gt;java.util.logging.SimpleFormatter.format&lt;/code&gt;&lt;/a&gt; property. The given &lt;code&gt;LogRecord&lt;/code&gt; will be formatted as if by calling:</source>
          <target state="translated">&lt;a href=&quot;#formatting&quot;&gt; &lt;code&gt;java.util.logging.SimpleFormatter.format&lt;/code&gt; &lt;/a&gt; 특성 에서 &lt;a href=&quot;../formatter#syntax&quot;&gt;형식 문자열&lt;/a&gt; 을 지정하여 형식화를 사용자 정의 할 수 있습니다 . 주어진 &lt;code&gt;LogRecord&lt;/code&gt; 는 다음과 같이 호출하여 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ad810658b54468ba29faa08fbcb8a912699a741b" translate="yes" xml:space="preserve">
          <source>The formatting engine allows the positive and negative signs of numbers to be controlled using this enum. See &lt;a href=&quot;datetimeformatterbuilder&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt;&lt;/a&gt; for usage.</source>
          <target state="translated">서식 엔진을 사용하면이 열거 형을 사용하여 양수 및 음수 부호를 제어 할 수 있습니다. 사용법 은 &lt;a href=&quot;datetimeformatterbuilder&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f994484334957b5e0ec6abc999ce7977df9d0433" translate="yes" xml:space="preserve">
          <source>The formatting of the magnitude</source>
          <target state="translated">크기의 서식</target>
        </trans-unit>
        <trans-unit id="bac9328bbe8404cc24578cda59316d244c5919ca" translate="yes" xml:space="preserve">
          <source>The former is used whenever a connection needs to be established or re-established with an LDAP server. The latter is used when all other LDAP operations are sent to the LDAP server. The reason why a distinction between these two types of request controls is necessary is because JNDI is a high-level API that does not deal directly with connections. It is the job of service providers to do any necessary connection management. Consequently, a single connection may be shared by multiple context instances, and a service provider is free to use its own algorithms to conserve connection and network usage. Thus, when a method is invoked on the context instance, the service provider might need to do some connection management in addition to performing the corresponding LDAP operations. For connection management, it uses the &lt;em&gt;connection request controls&lt;/em&gt;, while for the normal LDAP operations, it uses the &lt;em&gt;context request controls&lt;/em&gt;.</source>
          <target state="translated">전자는 LDAP 서버와의 연결을 설정하거나 다시 설정해야 할 때마다 사용됩니다. 후자는 다른 모든 LDAP 작업이 LDAP 서버로 전송 될 때 사용됩니다. 이 두 가지 유형의 요청 제어를 구별해야하는 이유는 JNDI가 연결을 직접 처리하지 않는 고급 API이기 때문입니다. 필요한 연결 관리를 수행하는 것은 서비스 제공 업체의 임무입니다. 결과적으로 단일 연결은 여러 컨텍스트 인스턴스에서 공유 될 수 있으며 서비스 제공 업체는 자체 알고리즘을 사용하여 연결 및 네트워크 사용을 보존 할 수 있습니다. 따라서 컨텍스트 인스턴스에서 메소드가 호출되면 서비스 제공자는 해당 LDAP 조작을 수행하는 것 외에도 일부 연결 관리를 수행해야 할 수도 있습니다. 연결 관리를 위해&lt;em&gt;연결 요청 제어&lt;/em&gt; , 일반 LDAP 조작의 경우 &lt;em&gt;컨텍스트 요청 제어를&lt;/em&gt; 사용 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f21520d7d456f5c00184b6c77d28a66fae2bd2ae" translate="yes" xml:space="preserve">
          <source>The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the</source>
          <target state="translated">분수는 소수점과 0 개 이상의 10 진수로 구성됩니다. 문자열은 정수 또는 분수 중 하나 이상의 숫자를 포함해야합니다. 부호, 정수 및 분수로 형성된 숫자를</target>
        </trans-unit>
        <trans-unit id="6f49809e86cf974fe275860950ae0472de435862" translate="yes" xml:space="preserve">
          <source>The fractional value of the field will be output including the preceding decimal point. The preceding value is not output. For example, the second-of-minute value of 15 would be output as &lt;code&gt;.25&lt;/code&gt;.</source>
          <target state="translated">앞의 소수점을 포함하여 필드의 분수 값이 출력됩니다. 앞의 값은 출력되지 않습니다. 예를 들어 분의 초 값 15는 &lt;code&gt;.25&lt;/code&gt; 로 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0d3ed6299aa9c75b61db9ef56cc15810b1d204f" translate="yes" xml:space="preserve">
          <source>The fragment component of a URI, if defined, only contains legal URI characters.</source>
          <target state="translated">URI의 조각 구성 요소에는 정의 된 경우 유효한 URI 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b045361cfaffd0cd8b7868eeb08d022948c4e3dd" translate="yes" xml:space="preserve">
          <source>The full detail message</source>
          <target state="translated">상세 메시지</target>
        </trans-unit>
        <trans-unit id="6e6af340438b798b4af65334c20b15a8a6ab7f82" translate="yes" xml:space="preserve">
          <source>The full name of this binding.</source>
          <target state="translated">이 바인딩의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e2e8ad3cad9cd9a7c5ceff9a5d59565630dc6be2" translate="yes" xml:space="preserve">
          <source>The full set of mixer info objects that represent the mixers supported by this &lt;code&gt;MixerProvider&lt;/code&gt; may be obtained through the &lt;code&gt;getMixerInfo&lt;/code&gt; method.</source>
          <target state="translated">이 &lt;code&gt;MixerProvider&lt;/code&gt; 가 지원하는 믹서를 나타내는 믹서 정보 객체의 전체 세트 는 &lt;code&gt;getMixerInfo&lt;/code&gt; 메소드 를 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="045b6c4a34c997a5ff03677d71a427fd8c213949" translate="yes" xml:space="preserve">
          <source>The full set of the mixer info objects that represent the mixers supported by this &lt;code&gt;MixerProvider&lt;/code&gt; may be obtained through the &lt;code&gt;getMixerInfo&lt;/code&gt; method. Use the &lt;code&gt;isMixerSupported&lt;/code&gt; method to test whether this &lt;code&gt;MixerProvider&lt;/code&gt; supports a particular mixer.</source>
          <target state="translated">이 &lt;code&gt;MixerProvider&lt;/code&gt; 가 지원하는 믹서를 나타내는 믹서 정보 객체의 전체 세트 는 &lt;code&gt;getMixerInfo&lt;/code&gt; 메소드 를 통해 얻을 수 있습니다 . 사용 &lt;code&gt;isMixerSupported&lt;/code&gt; 의 이 있는지 여부를 테스트 방법을 &lt;code&gt;MixerProvider&lt;/code&gt; 가이 특정 믹서를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="75e634abd512af1008080e4c7a639343ae697365" translate="yes" xml:space="preserve">
          <source>The fully qualified directory name where the MBean should be persisted (if appropriate).</source>
          <target state="translated">MBean을 유지해야하는 완전한 디렉토리 이름입니다 (적절한 경우).</target>
        </trans-unit>
        <trans-unit id="f08d6d7401fc9ae382da885fdc61f3b1d5cf0c2d" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of this package as defined in section 6.5.3 of</source>
          <target state="translated">섹션 6.5.3에 정의 된이 패키지의 정규화 된 이름</target>
        </trans-unit>
        <trans-unit id="322b80361dc210bb26cb16137caf000fff8d9ec3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;MethodHandles.lookup&lt;/code&gt; is caller sensitive so that there can be a secure foundation for lookups. Nearly all other methods in the JSR 292 API rely on lookup objects to check access requests.</source>
          <target state="translated">&lt;code&gt;MethodHandles.lookup&lt;/code&gt; 함수 는 호출자에 민감하므로 검색을위한 안전한 기반이 될 수 있습니다. JSR 292 API의 거의 모든 다른 메소드는 조회 오브젝트를 사용하여 액세스 요청을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7b75d2f564388e2749324f7684de8741790d40b7" translate="yes" xml:space="preserve">
          <source>The functional interfaces in this package follow an extensible naming convention, as follows:</source>
          <target state="translated">이 패키지의 기능 인터페이스는 다음과 같이 확장 가능한 명명 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="fd1adb1c6cdaf34899213972486b61cb86d4b763" translate="yes" xml:space="preserve">
          <source>The fundamental notion of the JMX API is the &lt;em&gt;MBean&lt;/em&gt;. An MBean is a named &lt;em&gt;managed object&lt;/em&gt; representing a resource. It has a &lt;em id=&quot;mgIface&quot;&gt;management interface&lt;/em&gt; which must be &lt;em&gt;public&lt;/em&gt; and consist of:</source>
          <target state="translated">JMX API의 기본 개념은 &lt;em&gt;MBean&lt;/em&gt; 입니다. MBean은 자원을 나타내는 명명 된 &lt;em&gt;관리 객체&lt;/em&gt; 입니다. 그것은이 &lt;em id=&quot;mgIface&quot;&gt;관리 인터페이스&lt;/em&gt; 해야합니다 &lt;em&gt;공공&lt;/em&gt; 및 구성을 :</target>
        </trans-unit>
        <trans-unit id="affa9a95efd7c99562b168220dc0b3a62ddadab8" translate="yes" xml:space="preserve">
          <source>The fuser temperature is above normal.</source>
          <target state="translated">퓨저 온도가 정상보다 높습니다.</target>
        </trans-unit>
        <trans-unit id="b432c989f957660cc61cab309227c58b52d723b4" translate="yes" xml:space="preserve">
          <source>The fuser temperature is below normal.</source>
          <target state="translated">퓨저 온도가 정상보다 낮습니다.</target>
        </trans-unit>
        <trans-unit id="d165af52d9801f2b9c6ca7bc842ffcb4a3efd77c" translate="yes" xml:space="preserve">
          <source>The general contract for the &lt;code&gt;Object.equals&lt;/code&gt; method states that equals must be symmetric (in other words, &lt;code&gt;a.equals(b)&lt;/code&gt; if and only if &lt;code&gt;b.equals(a)&lt;/code&gt;). The contracts for &lt;code&gt;List.equals&lt;/code&gt; and &lt;code&gt;Set.equals&lt;/code&gt; state that lists are only equal to other lists, and sets to other sets. Thus, a custom &lt;code&gt;equals&lt;/code&gt; method for a collection class that implements neither the &lt;code&gt;List&lt;/code&gt; nor &lt;code&gt;Set&lt;/code&gt; interface must return &lt;code&gt;false&lt;/code&gt; when this collection is compared to any list or set. (By the same logic, it is not possible to write a class that correctly implements both the &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt; interfaces.)</source>
          <target state="translated">&lt;code&gt;Object.equals&lt;/code&gt; 메소드 의 일반 계약에 따르면 equals는 대칭이어야합니다 (즉, &lt;code&gt;a.equals(b)&lt;/code&gt; 경우에만 a.equals (b &lt;code&gt;b.equals(a)&lt;/code&gt; ). &lt;code&gt;List.equals&lt;/code&gt; 및 &lt;code&gt;Set.equals&lt;/code&gt; 계약은 목록이 다른 목록과 동일하고 다른 세트로 설정 됨을 나타냅니다 . 따라서 &lt;code&gt;List&lt;/code&gt; 또는 &lt;code&gt;Set&lt;/code&gt; 인터페이스 를 구현하지 않는 컬렉션 클래스에 대한 사용자 정의 &lt;code&gt;equals&lt;/code&gt; 메소드는 이 컬렉션을 목록 또는 세트와 비교할 때 &lt;code&gt;false&lt;/code&gt; 를 반환 하지 않아야합니다 . 동일한 논리에 의해 &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;List&lt;/code&gt; 인터페이스를 모두 올바르게 구현하는 클래스를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a5cdfce9e4b05d212da94fe95d771caea20d5dc9" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;finalize&lt;/code&gt; is that it is invoked if and when the Java&amp;trade; virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The &lt;code&gt;finalize&lt;/code&gt; method may take any action, including making this object available again to other threads; the usual purpose of &lt;code&gt;finalize&lt;/code&gt;, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded.</source>
          <target state="translated">의 일반 계약 &lt;code&gt;finalize&lt;/code&gt; 이 호출되는 경우와 자바 (Java &amp;trade;) 가상 머신은 더 이상 객체가 아직 행동의 결과를 제외하고, 생존하고있는 임의의 thread에 액세스하는 방법이 있음을 결정하지 때 완성 될 준비가 된 다른 객체 또는 클래스의 완성으로 가져옵니다. &lt;code&gt;finalize&lt;/code&gt; 방법은 다른 thread로 다시 이용 가능하게하는이 객체을 포함한 모든 조치를 취할 수; 그러나 &lt;code&gt;finalize&lt;/code&gt; 의 일반적인 목적은 개체를 취소 할 수없는 방식으로 삭제하기 전에 정리 작업을 수행하는 것입니다. 예를 들어, 입출력 연결을 나타내는 오브젝트의 finalize 메소드는 오브젝트가 영구적으로 삭제되기 전에 명시 적 I / O 트랜잭션을 수행하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb9c7d88cc1ce8aa97ce8fb3d5a87c01fd408d1" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;hashCode&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;hashCode&lt;/code&gt; 의 일반적인 계약 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d0761a5d4d4cfe1bb133ae32ec4751724e2ff9b" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;mark&lt;/code&gt; is that, if the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the stream somehow remembers all the bytes read after the call to &lt;code&gt;mark&lt;/code&gt; and stands ready to supply those same bytes again if and whenever the method &lt;code&gt;reset&lt;/code&gt; is called. However, the stream is not required to remember any data at all if more than &lt;code&gt;readlimit&lt;/code&gt; bytes are read from the stream before &lt;code&gt;reset&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;mark&lt;/code&gt; 의 일반적인 계약은 , &lt;code&gt;markSupported&lt;/code&gt; 메소드 가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 , 스트림은 &lt;code&gt;mark&lt;/code&gt; 호출 후 읽힌 모든 바이트를 어떻게 든 기억해 , 메소드 &lt;code&gt;reset&lt;/code&gt; 이 불려 갈 때마다 같은 바이트를 다시 공급할 준비가되어있는 것 입니다. 그러나 &lt;code&gt;reset&lt;/code&gt; 이 호출 되기 전에 스트림에서 &lt;code&gt;readlimit&lt;/code&gt; 바이트 이상 을 읽는 경우 스트림은 데이터를 전혀 기억하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="78814a25bae5a1e5785d20a4fef6c1ed9141d5cb" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;next&lt;/code&gt; is that it returns an &lt;code&gt;int&lt;/code&gt; value and if the argument &lt;code&gt;bits&lt;/code&gt; is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt; (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The method &lt;code&gt;next&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; by atomically updating the seed to</source>
          <target state="translated">일반 계약 &lt;code&gt;next&lt;/code&gt; 그것이 리턴이다 &lt;code&gt;int&lt;/code&gt; 값과 인수 경우 &lt;code&gt;bits&lt;/code&gt; 사이 인 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;32&lt;/code&gt; 이들은 각각 독립적으로 선택된 비트의 값 (범위) 후 리턴 값의 많은 하위 비트 (약) 될 것이라고 는 대략적으로 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 일 것 입니다. 방법 &lt;code&gt;next&lt;/code&gt; 클래스에 의해 구현되는 &lt;code&gt;Random&lt;/code&gt; 원자에 씨앗을 업데이트하여</target>
        </trans-unit>
        <trans-unit id="3a2499a7d19b1785e56ca1842106c833aeadeaff" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;nextDouble&lt;/code&gt; is that one &lt;code&gt;double&lt;/code&gt; value, chosen (approximately) uniformly from the range &lt;code&gt;0.0d&lt;/code&gt; (inclusive) to &lt;code&gt;1.0d&lt;/code&gt; (exclusive), is pseudorandomly generated and returned.</source>
          <target state="translated">&lt;code&gt;nextDouble&lt;/code&gt; 의 일반적인 계약은 &lt;code&gt;0.0d&lt;/code&gt; (포함)에서 &lt;code&gt;1.0d&lt;/code&gt; (제외) 범위에서 (대략) 균일하게 선택된 하나의 &lt;code&gt;double&lt;/code&gt; 값 이 의사 난수로 생성되어 반환 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="33e5522f2cf381304bb4acc1f444b2ec6731ffff" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;nextFloat&lt;/code&gt; is that one &lt;code&gt;float&lt;/code&gt; value, chosen (approximately) uniformly from the range &lt;code&gt;0.0f&lt;/code&gt; (inclusive) to &lt;code&gt;1.0f&lt;/code&gt; (exclusive), is pseudorandomly generated and returned. All 2&lt;sup&gt;24&lt;/sup&gt; possible &lt;code&gt;float&lt;/code&gt; values of the form</source>
          <target state="translated">&lt;code&gt;nextFloat&lt;/code&gt; 의 일반적인 계약은 &lt;code&gt;0.0f&lt;/code&gt; (포함)에서 &lt;code&gt;1.0f&lt;/code&gt; (제외) 범위에서 (대략) 균일하게 선택된 하나의 &lt;code&gt;float&lt;/code&gt; 값 이 의사 난수로 생성되어 반환 된다는 것 입니다. 형식의 모든 2 &lt;sup&gt;24&lt;/sup&gt; 가능한 &lt;code&gt;float&lt;/code&gt; 값&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a6108c9c3bb11e8358e1337d11fb7dd99c819fca" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;nextGaussian&lt;/code&gt; is that one &lt;code&gt;double&lt;/code&gt; value, chosen from (approximately) the usual normal distribution with mean &lt;code&gt;0.0&lt;/code&gt; and standard deviation &lt;code&gt;1.0&lt;/code&gt;, is pseudorandomly generated and returned.</source>
          <target state="translated">&lt;code&gt;nextGaussian&lt;/code&gt; 의 일반적인 계약은 평균 &lt;code&gt;0.0&lt;/code&gt; 및 표준 편차 &lt;code&gt;1.0&lt;/code&gt; 으로 일반적인 정규 분포에서 (대략) 선택되는 하나의 &lt;code&gt;double&lt;/code&gt; 값 이 의사 난수로 생성되고 반환 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a39c42a97f8cc2bfa84444b9a77fa5e02fd465b3" translate="yes" xml:space="preserve">
          <source>The general contract of &lt;code&gt;reset&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 의 일반적인 계약 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b12c78c2fa8a5ae02abd10ed060377fad12b602d" translate="yes" xml:space="preserve">
          <source>The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may take any action whatsoever.</source>
          <target state="translated">메소드 &lt;code&gt;run&lt;/code&gt; 의 일반적인 계약은 어떤 조치 든 취할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b26618e1345d461e2aa57cbd21c3a074e197e40" translate="yes" xml:space="preserve">
          <source>The general format for specifying the</source>
          <target state="translated">지정하는 일반적인 형식</target>
        </trans-unit>
        <trans-unit id="836684afab62f49f45418668a259cd352042272e" translate="yes" xml:space="preserve">
          <source>The generator function takes an integer, which is the size of the desired array, and produces an array of the desired size. This can be concisely expressed with an array constructor reference:</source>
          <target state="translated">제너레이터 함수는 원하는 배열의 크기 인 정수를 취하여 원하는 크기의 배열을 생성합니다. 이것은 배열 생성자 참조로 간결하게 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22988a82c700434c5bff9a5cb2087e4845138282" translate="yes" xml:space="preserve">
          <source>The generic &lt;code&gt;Exception&lt;/code&gt; class for the Scripting APIs.</source>
          <target state="translated">스크립팅 API 의 일반 &lt;code&gt;Exception&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="50eca365888aa60e1583460ae7dbd0f1387e5760" translate="yes" xml:space="preserve">
          <source>The generic &lt;code&gt;Exception&lt;/code&gt; class for the Scripting APIs. Checked exception types thrown by underlying scripting implementations must be wrapped in instances of &lt;code&gt;ScriptException&lt;/code&gt;. The class has members to store line and column numbers and filenames if this information is available.</source>
          <target state="translated">스크립팅 API 의 일반 &lt;code&gt;Exception&lt;/code&gt; 클래스입니다. 기본 스크립팅 구현에 의해 발생 된 확인 된 예외 유형은 &lt;code&gt;ScriptException&lt;/code&gt; 인스턴스로 랩핑되어야합니다 . 이 정보가있는 경우 클래스에는 행 및 열 번호와 파일 이름을 저장하는 멤버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d751203fcfaae4c2dcf23fd2c630ff3255ac97" translate="yes" xml:space="preserve">
          <source>The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type.</source>
          <target state="translated">언어의 제네릭 메커니즘은 컴파일 타임 (정적) 유형 검사를 제공하지만, 확인되지 않은 캐스트로이 메커니즘을 물리 칠 수 있습니다. 컴파일러는 검사되지 않은 모든 작업에 대해 경고를 발행하므로 일반적으로 문제가되지 않습니다. 그러나 정적 유형 검사만으로는 충분하지 않은 경우가 있습니다. 예를 들어, 콜렉션이 써드 파티 라이브러리로 전달되고 라이브러리 코드가 잘못된 유형의 요소를 삽입하여 콜렉션을 손상시키지 않아야한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="17607035e1067bccfbdc24ec6f6fef5ac0edd8c8" translate="yes" xml:space="preserve">
          <source>The getter methods all require the key as an argument and return the object if found. If the object is not found, the getter method throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.</source>
          <target state="translated">getter 메소드는 모두 키를 인수로 요구하고 발견되면 오브젝트를 리턴합니다. 객체가 발견되지 않은 경우, getter 메소드는 &lt;code&gt;MissingResourceException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f1838c464e5ae39d5db0e960e217af9f7c2dcff4" translate="yes" xml:space="preserve">
          <source>The getter methods may &lt;a href=&quot;messager#printMessage-javax.tools.Diagnostic.Kind-java.lang.CharSequence-&quot;&gt;issue warnings&lt;/a&gt; about noteworthy conditions using the facilities available after the processor has been &lt;a href=&quot;abstractprocessor#isInitialized--&quot;&gt;initialized&lt;/a&gt;.</source>
          <target state="translated">getter 메소드는 프로세서가 &lt;a href=&quot;abstractprocessor#isInitialized--&quot;&gt;초기화 된&lt;/a&gt; 후 사용 가능한 기능을 사용하여 주목할만한 조건에 대한 &lt;a href=&quot;messager#printMessage-javax.tools.Diagnostic.Kind-java.lang.CharSequence-&quot;&gt;경고&lt;/a&gt; 를 발행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8bbd09e2f9282fab1c5b17105f5168116e9943f" translate="yes" xml:space="preserve">
          <source>The getter names.</source>
          <target state="translated">게터 이름.</target>
        </trans-unit>
        <trans-unit id="ee07db4a9afb88d70f978c9557d54a36e2844c3a" translate="yes" xml:space="preserve">
          <source>The given Graphics object will have the default font, color, etc of the parent container. The PropertyEditor may change graphics attributes such as font and color and doesn't need to restore the old values.</source>
          <target state="translated">주어진 Graphics 객체는 부모 컨테이너의 기본 글꼴, 색상 등을 갖습니다. PropertyEditor는 글꼴 및 색상과 같은 그래픽 속성을 변경할 수 있으며 이전 값을 복원 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="183415761a8e6024f617fa5cc5c9cfc1f85baa21" translate="yes" xml:space="preserve">
          <source>The given array controls the reordering. Call &lt;code&gt;#I&lt;/code&gt; the number of incoming parameters (the value &lt;code&gt;newType.parameterCount()&lt;/code&gt;, and call &lt;code&gt;#O&lt;/code&gt; the number of outgoing parameters (the value &lt;code&gt;target.type().parameterCount()&lt;/code&gt;). Then the length of the reordering array must be &lt;code&gt;#O&lt;/code&gt;, and each element must be a non-negative number less than &lt;code&gt;#I&lt;/code&gt;. For every &lt;code&gt;N&lt;/code&gt; less than &lt;code&gt;#O&lt;/code&gt;, the &lt;code&gt;N&lt;/code&gt;-th outgoing argument will be taken from the &lt;code&gt;I&lt;/code&gt;-th incoming argument, where &lt;code&gt;I&lt;/code&gt; is &lt;code&gt;reorder[N]&lt;/code&gt;.</source>
          <target state="translated">주어진 배열은 재정렬을 제어합니다. 전화 &lt;code&gt;#I&lt;/code&gt; 입력 매개 변수의 수 (값 &lt;code&gt;newType.parameterCount()&lt;/code&gt; 및 전화 &lt;code&gt;#O&lt;/code&gt; 나가는 매개 변수의 수 (값 &lt;code&gt;target.type().parameterCount()&lt;/code&gt; ). 그런 다음 재정렬 배열의 길이가되어야합니다 &lt;code&gt;#O&lt;/code&gt; , 각각의 요소는 이하의 음이 아닌 수 있어야 &lt;code&gt;#I&lt;/code&gt; . 들어 모든 &lt;code&gt;N&lt;/code&gt; 미만 &lt;code&gt;#O&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; 번째 송신 인수는 찍은 것이다 &lt;code&gt;I&lt;/code&gt; 번째 수신 인수 &lt;code&gt;I&lt;/code&gt; 이 인 &lt;code&gt;reorder[N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703c48b1d2340b04df1d9cc4e78601063cf33268" translate="yes" xml:space="preserve">
          <source>The given group of events are all delivered as method calls on a single event listener interface, and an event listener object can be registered via a call on a registration method supplied by the event source.</source>
          <target state="translated">주어진 이벤트 그룹은 모두 단일 이벤트 리스너 인터페이스에서 메소드 호출로 전달되며 이벤트 리스너 오브젝트는 이벤트 소스가 제공 한 등록 메소드에 대한 호출을 통해 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffdfa6782f35f4a8c141a6192add2493234091aa" translate="yes" xml:space="preserve">
          <source>The given object is serialized, and its serialized contents are encrypted using the given Cipher, which must be fully initialized.</source>
          <target state="translated">주어진 객체는 직렬화되고, 그 직렬화 된 내용은 주어진 암호를 사용하여 암호화되며, 이는 완전히 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d8a013ff12d3a4688960660289fa06921be7c57" translate="yes" xml:space="preserve">
          <source>The global LogManager object can be retrieved using LogManager.getLogManager(). The LogManager object is created during class initialization and cannot subsequently be changed.</source>
          <target state="translated">전역 LogManager 객체는 LogManager.getLogManager ()를 사용하여 검색 할 수 있습니다. LogManager 객체는 클래스 초기화 중에 만들어지며 나중에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48c726674f74cb2aff8847caf7527cd3e0074a2a" translate="yes" xml:space="preserve">
          <source>The global logging properties may include:</source>
          <target state="translated">글로벌 로깅 특성에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e07a1d0c0f4cd0a58eb556541bb0061d79fff226" translate="yes" xml:space="preserve">
          <source>The globalScope field.</source>
          <target state="translated">globalScope 필드</target>
        </trans-unit>
        <trans-unit id="11f1f51aa9771116b126b51dc32fcfd9d04831e3" translate="yes" xml:space="preserve">
          <source>The globbing pattern is specified by the &lt;a href=&quot;filesystem#getPathMatcher-java.lang.String-&quot;&gt;&lt;code&gt;getPathMatcher&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">globbing 패턴은 &lt;a href=&quot;filesystem#getPathMatcher-java.lang.String-&quot;&gt; &lt;code&gt;getPathMatcher&lt;/code&gt; &lt;/a&gt; 메소드로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8937687f2af88776c3e820a3f8d7c35d4bb55dfc" translate="yes" xml:space="preserve">
          <source>The granularity period value.</source>
          <target state="translated">입도 기간 값입니다.</target>
        </trans-unit>
        <trans-unit id="88e6210bb5ce3e1e84b64575d362a93f604005d7" translate="yes" xml:space="preserve">
          <source>The granularity period.</source>
          <target state="translated">입도 기간.</target>
        </trans-unit>
        <trans-unit id="3420277017038a0f3a7a8735146a1a372f94b576" translate="yes" xml:space="preserve">
          <source>The group is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-int-java.util.concurrent.ThreadFactory-&quot;&gt;&lt;code&gt;openAsynchronousChannelGroup(int,ThreadFactory)&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">그룹은 시스템 전체의 기본 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-int-java.util.concurrent.ThreadFactory-&quot;&gt; &lt;code&gt;openAsynchronousChannelGroup(int,ThreadFactory)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb720d2e33987d2cf50e3dfc5d3cb6091f00a40a" translate="yes" xml:space="preserve">
          <source>The group is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-java.util.concurrent.ExecutorService-int-&quot;&gt;&lt;code&gt;openAsynchronousChannelGroup(ExecutorService,int)&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object with an &lt;code&gt;initialSize&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">그룹이 호출에 의해 생성된다 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-java.util.concurrent.ExecutorService-int-&quot;&gt; &lt;code&gt;openAsynchronousChannelGroup(ExecutorService,int)&lt;/code&gt; &lt;/a&gt; 시스템 전체의 기본 방법 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; 의&lt;/a&gt; 와 오브젝트 &lt;code&gt;initialSize&lt;/code&gt; 가 의 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="667fea1471914e720a235f53da83ac53eff12116" translate="yes" xml:space="preserve">
          <source>The group is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-java.util.concurrent.ExecutorService-int-&quot;&gt;&lt;code&gt;openAsynchronousChannelGroup(ExecutorService,int)&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">그룹은 시스템 전체 기본 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousChannelGroup-java.util.concurrent.ExecutorService-int-&quot;&gt; &lt;code&gt;openAsynchronousChannelGroup(ExecutorService,int)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac647a1b50a49dce6768605287c17212490f6461" translate="yes" xml:space="preserve">
          <source>The grouping separator is commonly used for thousands, but in some countries it separates ten-thousands. The grouping size is a constant number of digits between the grouping characters, such as 3 for 100,000,000 or 4 for 1,0000,0000. If you supply a pattern with multiple grouping characters, the interval between the last one and the end of the integer is the one that is used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.</source>
          <target state="translated">그룹화 구분 기호는 일반적으로 수천 명에 사용되지만 일부 국가에서는 10 만 개를 분리합니다. 그룹화 크기는 그룹화 문자 사이의 일정한 자릿수입니다 (예 : 100,000,000의 경우 3 또는 1,0000,0000의 경우 4). 여러 그룹화 문자가있는 패턴을 제공하는 경우 마지막 문자와 정수 끝 사이의 간격이 사용됩니다. 따라서 &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3f7c4e20300c4bd0cb6b80a481daa7faae00611" translate="yes" xml:space="preserve">
          <source>The hardware's minimum margins is not just a property of the printer, but may be a function of the media size, orientation, media type, and any specified finishings. &lt;code&gt;PrintService&lt;/code&gt; provides the method to query the supported values of an attribute in a suitable context : See &lt;a href=&quot;../../printservice#getSupportedAttributeValues-java.lang.Class-javax.print.DocFlavor-javax.print.attribute.AttributeSet-&quot;&gt;&lt;code&gt;PrintService.getSupportedAttributeValues()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">하드웨어의 최소 여백은 프린터의 속성 일뿐 아니라 용지 크기, 방향, 용지 종류 및 지정된 마무리 기능에 따라 달라질 수 있습니다. &lt;code&gt;PrintService&lt;/code&gt; 는 적절한 컨텍스트에서 지원되는 속성 값을 쿼리하는 메소드를 제공합니다. &lt;a href=&quot;../../printservice#getSupportedAttributeValues-java.lang.Class-javax.print.DocFlavor-javax.print.attribute.AttributeSet-&quot;&gt; &lt;code&gt;PrintService.getSupportedAttributeValues()&lt;/code&gt; &lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9538c39f3494d1f790686c158fa3908b95b519b" translate="yes" xml:space="preserve">
          <source>The hash code is based upon all the URL components relevant for URL comparison. As such, this operation is a blocking operation.</source>
          <target state="translated">해시 코드는 URL 비교와 관련된 모든 URL 구성 요소를 기반으로합니다. 따라서이 작업은 차단 작업입니다.</target>
        </trans-unit>
        <trans-unit id="c70cace9970285dcf9cdf6965c3562c7040cae45" translate="yes" xml:space="preserve">
          <source>The hash code is based upon the components of the path, and satisfies the general contract of the &lt;a href=&quot;../../lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">해시 코드는 경로의 구성 요소를 기반으로하며 &lt;a href=&quot;../../lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode&lt;/code&gt; &lt;/a&gt; 메서드 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="c527b264eac325d09725ecb4874d7a3ee1aba8e2" translate="yes" xml:space="preserve">
          <source>The hash code is based upon the value represented, and satisfies the general contract of the &lt;a href=&quot;../../../lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">해시 코드는 표시된 값을 기반으로하며 &lt;a href=&quot;../../../lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 메서드 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="6aaf165addd90a50c9183a3d2875d6a72cb1ef7a" translate="yes" xml:space="preserve">
          <source>The hash code is calculated via: &lt;code&gt;getName(X500Principal.CANONICAL).hashCode()&lt;/code&gt;</source>
          <target state="translated">해시 코드는 &lt;code&gt;getName(X500Principal.CANONICAL).hashCode()&lt;/code&gt; 를 통해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="0ba358f7e4c5629a504cdd4a1c1f292ba74a0a9d" translate="yes" xml:space="preserve">
          <source>The hash code is computed by adding the hash code of the attribute's id and that of all of its values except for values that are arrays. For an array, the hash code of each element of the array is summed. If a subclass overrides &lt;code&gt;hashCode()&lt;/code&gt;, it should override &lt;code&gt;equals()&lt;/code&gt; as well so that two attributes that are equal have the same hash code.</source>
          <target state="translated">해시 코드는 배열의 값을 제외하고 속성의 id 및 모든 값의 해시 코드를 추가하여 계산됩니다. 배열의 경우 배열의 각 요소의 해시 코드가 합산됩니다. 서브 클래스가 &lt;code&gt;hashCode()&lt;/code&gt; 대체하는 경우, 동일한 두 속성이 동일한 해시 코드를 갖도록 &lt;code&gt;equals()&lt;/code&gt; 를 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="280b797559d043d8daa32c7b2b5ee41ca3702e4d" translate="yes" xml:space="preserve">
          <source>The hash code is computed by adding the hash code of the attributes of this object. If this BasicAttributes ignores case of its attribute IDs, one is added to the hash code. If a subclass overrides &lt;code&gt;hashCode()&lt;/code&gt;, it should override &lt;code&gt;equals()&lt;/code&gt; as well so that two &lt;code&gt;Attributes&lt;/code&gt; instances that are equal have the same hash code.</source>
          <target state="translated">해시 코드는이 객체 속성의 해시 코드를 추가하여 계산됩니다. 이 BasicAttributes가 속성 ID의 대소 문자를 무시하면 해시 코드에 추가됩니다. 서브 클래스가 &lt;code&gt;hashCode()&lt;/code&gt; 대체하는 경우, &lt;code&gt;equals()&lt;/code&gt; 두 개의 &lt;code&gt;Attributes&lt;/code&gt; 인스턴스가 동일한 해시 코드를 갖도록 equals () 를 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bbaead227f6f55e6d05891b8aa6b6409429186cb" translate="yes" xml:space="preserve">
          <source>The hash code is defined to be the result of the following calculation:</source>
          <target state="translated">해시 코드는 다음 계산 결과로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd08498997ed584941a561e6db8ab3f78bf82c2" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;CompositeData&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;CompositeData&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 그</target>
        </trans-unit>
        <trans-unit id="d55d18b3e39ef2ab73da42191dee5a25b8360e6e" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;CompositeDataSupport&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 그</target>
        </trans-unit>
        <trans-unit id="23d71a4647e5d7c762e18b1c5f72a5feccc76928" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;CompositeType&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: name, items names, items types). This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; for any two &lt;code&gt;CompositeType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, as required by the general contract of the method &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;CompositeType&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (이름, 항목 이름, 항목 유형 예) 비교. 이 것을 보장하지만 &lt;code&gt; t1.equals(t2) &lt;/code&gt; 의미하는 &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; 임의의 두 &lt;code&gt;CompositeType&lt;/code&gt; 인스턴스 &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;t2&lt;/code&gt; 에있어서의 일반 계약에 의해 필요에 따라 &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d318826cde719be40f380791a8f546b82ed80cd5" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;TabularData&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;TabularData&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 그</target>
        </trans-unit>
        <trans-unit id="7be5b5cc6924ee6b06115e4c236b4aa63d3a3653" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;TabularDataSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;TabularDataSupport&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 그</target>
        </trans-unit>
        <trans-unit id="247a077ccfc174f8e6662782ad271b4b18c19d87" translate="yes" xml:space="preserve">
          <source>The hash code of a &lt;code&gt;TabularType&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: name, row type, index names). This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; for any two &lt;code&gt;TabularType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, as required by the general contract of the method &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 해시 코드 &lt;code&gt;TabularType&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; (이름, 행의 형태, 인덱스 이름 예) 비교. 이 것을 보장하지만 &lt;code&gt; t1.equals(t2) &lt;/code&gt; 의미하는 &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; 두 용 &lt;code&gt;TabularType&lt;/code&gt; 인스턴스 &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;t2&lt;/code&gt; 에있어서의 일반 계약에 의해 필요에 따라 &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="870f42492879e018456513ed48f2e9081dd2adc9" translate="yes" xml:space="preserve">
          <source>The hash code of a byte buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">바이트 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae060928fbf5519b2c2adaf53bf19772feaa56c3" translate="yes" xml:space="preserve">
          <source>The hash code of a char buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">char 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e856bea9bb9b618831e36d6cb05e907153d7b262" translate="yes" xml:space="preserve">
          <source>The hash code of a double buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이중 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77547da71388901473497d1b6c4f94fc525f313f" translate="yes" xml:space="preserve">
          <source>The hash code of a float buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">플로트 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7daacfd0664bde6221147f25fc4590d2f02384b5" translate="yes" xml:space="preserve">
          <source>The hash code of a int buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">int 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="448d49d6ad775b6519c9d1b6671194f14b98ec77" translate="yes" xml:space="preserve">
          <source>The hash code of a long buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">긴 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210cdb9a0ce5d545d18adc0fc1f6167261b16830" translate="yes" xml:space="preserve">
          <source>The hash code of a member-value depends on its type:</source>
          <target state="translated">멤버 값의 해시 코드는 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2134ae5696f587a6755931aaf788a2d6221bf325" translate="yes" xml:space="preserve">
          <source>The hash code of a primitive value &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; is equal to &lt;code&gt;&lt;i&gt;WrapperType&lt;/i&gt;.valueOf(&lt;i&gt;v&lt;/i&gt;).hashCode()&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;WrapperType&lt;/i&gt;&lt;/code&gt; is the wrapper type corresponding to the primitive type of &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; (&lt;a href=&quot;../byte&quot;&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../short&quot;&gt;&lt;code&gt;Short&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">원시 값의 해시 코드 &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; 같다 &lt;code&gt;&lt;i&gt;WrapperType&lt;/i&gt;.valueOf(&lt;i&gt;v&lt;/i&gt;).hashCode()&lt;/code&gt; , &lt;code&gt;&lt;i&gt;WrapperType&lt;/i&gt;&lt;/code&gt; 가 의 프리미티브 타입에 대응 랩퍼 타입 &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; ( &lt;a href=&quot;../byte&quot;&gt; &lt;code&gt;Byte&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../short&quot;&gt; &lt;code&gt;Short&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d02a73fa0f7e8ac01c968c0c089bcfd10620f9c" translate="yes" xml:space="preserve">
          <source>The hash code of a short buffer depends only upon its remaining elements; that is, upon the elements from &lt;code&gt;position()&lt;/code&gt; up to, and including, the element at &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">짧은 버퍼의 해시 코드는 나머지 요소에만 의존합니다. 즉, 상기의 요소에, 인 &lt;code&gt;position()&lt;/code&gt; 까지, 및 포함의 요소 &lt;code&gt;limit()&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b69f411272182de725ee87c28429b094dc5c1c" translate="yes" xml:space="preserve">
          <source>The hash code of a string, enum, class, or annotation member-value I &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; is computed as by calling &lt;code&gt;&lt;i&gt;v&lt;/i&gt;.hashCode()&lt;/code&gt;. (In the case of annotation member values, this is a recursive definition.)</source>
          <target state="translated">문자열, 열거 형, 클래스 또는 주석 멤버 값 I &lt;code&gt;&lt;i&gt;v&lt;/i&gt;&lt;/code&gt; 의 해시 코드는 &lt;code&gt;&lt;i&gt;v&lt;/i&gt;.hashCode()&lt;/code&gt; 호출하여 계산됩니다 . 주석 멤버 값의 경우 재귀 적 정의입니다.</target>
        </trans-unit>
        <trans-unit id="01d1fa6e57ef84b5eecfaa822a60e3bc34f1f826" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;ArrayType&lt;/code&gt; instance is the sum of the hash codes of all the elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (i.e. dimension, elements' open type and primitive array flag). The hashcode for a primitive value is the hashcode of the corresponding boxed object (e.g. the hashcode for &lt;code&gt;true&lt;/code&gt; is &lt;code&gt;Boolean.TRUE.hashCode()&lt;/code&gt;). This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; for any two &lt;code&gt;ArrayType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, as required by the general contract of the method &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 해시 코드 &lt;code&gt;ArrayType&lt;/code&gt; 의 인스턴스에 사용되는 정보의 모든 요소의 해시 코드의 합계 &lt;code&gt;equals&lt;/code&gt; 비교 (즉, 차원, 요소의 오픈 타입 및 기본 배열 플래그). 프리미티브 값의 해시 코드는 해당 박스 객체의 해시 코드입니다 (예 : &lt;code&gt;true&lt;/code&gt; 의 해시 코드 는 &lt;code&gt;Boolean.TRUE.hashCode()&lt;/code&gt; ). 이 것을 보장하지만 &lt;code&gt; t1.equals(t2) &lt;/code&gt; 의미하는 &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt; 임의의 두 &lt;code&gt;ArrayType&lt;/code&gt; 의 인스턴스 &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;t2&lt;/code&gt; 에있어서의 일반 계약에 의해 필요에 따라 &lt;a href=&quot;../../../java/lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89859869abc1e87bea0cedbd234cccfbd6292353" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, its</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 이름을, 그</target>
        </trans-unit>
        <trans-unit id="d4009fccc58869916c6960aab5f22a0c9ff7dbc5" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, its</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 이름을, 그</target>
        </trans-unit>
        <trans-unit id="2f397ac542d0038cb102144a0cc57e017b2c4f8d" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanConstructorInfo&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name and signature, where the signature hashCode is calculated by a call to &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanConstructorInfo&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (비교 예 : 서명 해시 코드가 호출에 의해 계산의 이름과 서명, &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="04266c1edbee1d94b1f76015779f40d46219c679" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name and signature, where the signature hashCode is calculated by a call to &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanConstructorInfoSupport&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (비교 예 : 서명 해시 코드가 호출에 의해 계산의 이름과 서명, &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a41b2af637d21816176cf096c670471a0f1f21d" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanInfo&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its class name, and its infos on attributes, constructors, operations and notifications, where the hashCode of each of these arrays is calculated by a call to &lt;code&gt;new java.util.HashSet(java.util.Arrays.asList(this.getSignature)).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanInfo&lt;/code&gt; 에의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (비교 예 : 클래스 명과 속성, 생성자, 운영 및 알림의 정보를 정기적으로, 개개의 배열의 hashCode &lt;code&gt;new java.util.HashSet(java.util.Arrays.asList(this.getSignature)).hashCode()&lt;/code&gt; 에 대한 호출로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="7134d10e582e012e058ace133bc0a5e89599df5c" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its class name, and its infos on attributes, constructors, operations and notifications, where the hashCode of each of these arrays is calculated by a call to &lt;code&gt;new
 java.util.HashSet(java.util.Arrays.asList(this.getSignature)).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanInfoSupport&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (비교 예 : 클래스 명과 속성, 생성자, 운영 및 알림의 정보를 정기적으로, 개개의 배열의 hashCode &lt;code&gt;new java.util.HashSet(java.util.Arrays.asList(this.getSignature)).hashCode()&lt;/code&gt; 에 대한 호출로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="f54d7fb241c970213208d826f32b3107dda26d22" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanOperationInfo&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, return open type, impact and signature, where the signature hashCode is calculated by a call to &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanOperationInfo&lt;/code&gt; 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; 이름이 서명 해시 코드가 호출에 의해 계산되는 공개 형, 영향 및 서명, 반환 : 예 (비교 &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbcfc09c215717c345d74980a70a4ff3a832c4e1" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, return open type, impact and signature, where the signature hashCode is calculated by a call to &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt;).</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계입니다 &lt;code&gt;equals&lt;/code&gt; (비교 예 : 그 이름은, 서명 해시 코드가 호출에 의해 계산되는 공개 형, 영향 및 서명, 돌려 &lt;code&gt;java.util.Arrays.asList(this.getSignature).hashCode()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="00e028f4abde36a33f7e7c1ecf97c6a5135da15d" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, its</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 이름을, 그</target>
        </trans-unit>
        <trans-unit id="31d61d2f8f6cfb064e5c7aa593ca2ca50815ceaf" translate="yes" xml:space="preserve">
          <source>The hash code of an &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; instance is the sum of the hash codes of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons (ie: its name, its</source>
          <target state="translated">의 해시 코드 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 의 인스턴스에 사용되는 모든 정보 요소의 해시 코드의 합계 것은 &lt;code&gt;equals&lt;/code&gt; 비교 (예 : 이름을, 그</target>
        </trans-unit>
        <trans-unit id="ec70ed87a298662c34b1f376ba077c2bc1d629fc" translate="yes" xml:space="preserve">
          <source>The hash code of an annotation is the sum of the hash codes of its members (including those with default values), as defined below: The hash code of an annotation member is (127 times the hash code of the member-name as computed by &lt;a href=&quot;../string#hashCode--&quot;&gt;&lt;code&gt;String.hashCode()&lt;/code&gt;&lt;/a&gt;) XOR the hash code of the member-value, as defined below:</source>
          <target state="translated">주석의 해시 코드는 아래에 정의 된대로 멤버의 해시 코드 (기본값이 포함 된 코드 포함)의 합입니다. 주석 멤버의 해시 코드는 다음에 의해 계산 된 member-name의 해시 코드의 127 배입니다. &lt;a href=&quot;../string#hashCode--&quot;&gt; &lt;code&gt;String.hashCode()&lt;/code&gt; &lt;/a&gt; ) 아래에 정의 된대로 멤버 값의 해시 코드를 XOR합니다.</target>
        </trans-unit>
        <trans-unit id="c3b05c5d540ac9609ca285969339a76621c23f02" translate="yes" xml:space="preserve">
          <source>The hash code of an array member-value is computed by calling the appropriate overloading of &lt;a href=&quot;../../util/arrays#hashCode-long:A-&quot;&gt;&lt;code&gt;Arrays.hashCode&lt;/code&gt;&lt;/a&gt; on the value. (There is one overloading for each primitive type, and one for object reference types.)</source>
          <target state="translated">배열 멤버 값의 해시 코드는 값에서 &lt;a href=&quot;../../util/arrays#hashCode-long:A-&quot;&gt; &lt;code&gt;Arrays.hashCode&lt;/code&gt; &lt;/a&gt; 의 적절한 오버로드를 호출하여 계산됩니다 . 각 기본 유형마다 하나의 오버로드가 있으며 오브젝트 참조 유형마다 하나의 오버로드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb2f0111cd6022a0599aca13287860989104c38" translate="yes" xml:space="preserve">
          <source>The hash code of this address as an int.</source>
          <target state="translated">이 주소의 해시 코드를 정수로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbc46fa08eff76ca50a494a67a9f9afc3402dc72" translate="yes" xml:space="preserve">
          <source>The hash code should be based on the entire state of the object.</source>
          <target state="translated">해시 코드는 객체의 전체 상태를 기반으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="712b5a084994256ad3e9968d5206089d7ea3c72c" translate="yes" xml:space="preserve">
          <source>The hash code value for this attribute set.</source>
          <target state="translated">이 속성 세트의 해시 코드 값</target>
        </trans-unit>
        <trans-unit id="2b53bb94c3bfc0bbacc248ee138e0c2f7cbbffc9" translate="yes" xml:space="preserve">
          <source>The hash code value is generated using the case-insensitive hostname of this &lt;code&gt;SNIHostName&lt;/code&gt;.</source>
          <target state="translated">해시 코드 값은이 &lt;code&gt;SNIHostName&lt;/code&gt; 의 대소 문자를 구분하지 않는 호스트 이름을 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a94e0117685d82860b0a3c8054cc73b78793fa96" translate="yes" xml:space="preserve">
          <source>The hash code value is generated using the name type and encoded value of this server name.</source>
          <target state="translated">해시 코드 값은이 서버 이름의 이름 유형 및 인코딩 된 값을 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="536d7623d1b3e33ffe89509fa39178919882bcb0" translate="yes" xml:space="preserve">
          <source>The heap may be of a fixed size or may be expanded and shrunk. The memory for the heap does not need to be contiguous.</source>
          <target state="translated">힙은 고정 된 크기이거나 확장 및 축소 될 수 있습니다. 힙의 메모리는 연속적 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f81b9ca5d1cfd1e67c799ae3c17e744c07d9afc0" translate="yes" xml:space="preserve">
          <source>The hedge &quot;approximately&quot; is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity.</source>
          <target state="translated">&quot;임의의&quot;헤지는 전술 한 설명에서 사용되는데, 디폴트 랜덤 소스는 대략 독립적으로 선택된 비트의 바이어스되지 않은 소스이기 때문이다. 무작위로 선택된 비트의 완벽한 소스라면 알고리즘은 완벽한 균일 성을 가진 순열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="67a3fd782abccfd0623f5ed131c4181f7176648a" translate="yes" xml:space="preserve">
          <source>The hedge &quot;approximately&quot; is used in the foregoing description only because the &lt;code&gt;next&lt;/code&gt; method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose &lt;code&gt;double&lt;/code&gt; values from the stated range with perfect uniformity.</source>
          <target state="translated">헤지 &quot;대략&quot;은 전술 한 설명에서 단지 &lt;code&gt;next&lt;/code&gt; 방법이 단지 독립적으로 선택된 비트의 바이어스되지 않은 소스 이기 때문에 사용 된다. 무작위로 선택된 비트의 완벽한 소스라면, 표시된 알고리즘 은 지정된 범위에서 완벽한 균일 성을 가진 &lt;code&gt;double&lt;/code&gt; 값을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="58816a4e8f485de5ac4b356dc59cc5616b00d6ae" translate="yes" xml:space="preserve">
          <source>The hedge &quot;approximately&quot; is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose &lt;code&gt;float&lt;/code&gt; values from the stated range with perfect uniformity.</source>
          <target state="translated">헤지 &quot;대략&quot;은 전술 한 설명에서 단지 다음 방법이 단지 독립적으로 선택된 비트의 바이어스되지 않은 소스이기 때문에 사용된다. 무작위로 선택된 비트의 완벽한 소스라면, 표시된 알고리즘 은 명시된 균일 한 범위에서 &lt;code&gt;float&lt;/code&gt; 값을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="502b6b76db7ef6889c24c49044d80cfde1ed3dae" translate="yes" xml:space="preserve">
          <source>The hedge &quot;approximately&quot; is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose &lt;code&gt;int&lt;/code&gt; values from the stated range with perfect uniformity.</source>
          <target state="translated">헤지 &quot;대략&quot;은 전술 한 설명에서 단지 다음 방법이 단지 독립적으로 선택된 비트의 바이어스되지 않은 소스이기 때문에 사용된다. 무작위로 선택된 비트의 완벽한 소스라면, 표시된 알고리즘 은 명시된 균일 한 범위에서 &lt;code&gt;int&lt;/code&gt; 값을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="f23417dbb721134e36b8caed73cad75ac4c3a829" translate="yes" xml:space="preserve">
          <source>The height of each tile if tiling has been set, or 0 otherwise. The initial value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">바둑판 식 배열이 설정된 경우 각 타일의 높이, 그렇지 않으면 0입니다. 초기 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5737454dda055bd8bb162cd9eb4846920e7b432e" translate="yes" xml:space="preserve">
          <source>The high threshold value.</source>
          <target state="translated">높은 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="15326738362d08a71045fe2aaa50b89b8bdc9feb" translate="yes" xml:space="preserve">
          <source>The higher-level code that calls getCustomEditor may either embed the Component in some larger property sheet, or it may put it in its own individual dialog, or ...</source>
          <target state="translated">getCustomEditor를 호출하는 상위 레벨 코드는 더 큰 특성 시트에 Component를 임베드하거나 고유 한 개별 대화 상자에 배치하거나 ...</target>
        </trans-unit>
        <trans-unit id="31982dd70867d5c4e880c2e13841ee34ddf0228e" translate="yes" xml:space="preserve">
          <source>The historical name of this encoding, or &lt;code&gt;null&lt;/code&gt; if the stream has been closed</source>
          <target state="translated">이 인코딩의 히스토리 이름 . 스트림이 닫힌 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54f0c950a5ffae3623bf86533115f2ac87fb076a" translate="yes" xml:space="preserve">
          <source>The historical name of this encoding, or possibly &lt;code&gt;null&lt;/code&gt; if the stream has been closed</source>
          <target state="translated">이 인코딩의 히스토리 이름 . 스트림이 닫혀있는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4119b3c56ec8cdf2cd86fad835660f7db959c4e5" translate="yes" xml:space="preserve">
          <source>The hold count information is typically only used for testing and debugging purposes. For example, if a certain section of code should not be entered with the lock already held then we can assert that fact:</source>
          <target state="translated">홀드 카운트 정보는 일반적으로 테스트 및 디버깅 목적으로 만 사용됩니다. 예를 들어, 잠금을 이미 보유한 상태에서 특정 코드 섹션을 입력하지 않으면 다음과 같은 사실을 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb71ca01e20f35ec2e60135062bb088ddef248f" translate="yes" xml:space="preserve">
          <source>The hook is said to bind the call site to a target method handle, and a typical action would be &lt;code&gt;someTarget.bindTo(this)&lt;/code&gt;. However, the hook is free to take any action whatever, including ignoring the call site and returning a constant target.</source>
          <target state="translated">후크는 호출 사이트를 대상 메소드 핸들에 바인딩한다고하며 일반적인 조치는 &lt;code&gt;someTarget.bindTo(this)&lt;/code&gt; 입니다. 그러나 후크는 호출 사이트를 무시하고 일정한 대상을 반환하는 것을 포함하여 모든 조치를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78eb699ee386d149fce0ecce892268c6bd08062" translate="yes" xml:space="preserve">
          <source>The host component of a URI cannot contain escaped octets, hence this method does not perform any decoding.</source>
          <target state="translated">URI의 호스트 구성 요소는 이스케이프 된 옥텟을 포함 할 수 없으므로이 방법은 디코딩을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34bc17988021d57400932c60a1e04c33487914e0" translate="yes" xml:space="preserve">
          <source>The host component of a URI, if defined, will have one of the following forms:</source>
          <target state="translated">URI의 호스트 구성 요소는 정의 된 경우 다음 형식 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bab1b3cf2cb0aea0d2eaa0c153c81181ea3acbd4" translate="yes" xml:space="preserve">
          <source>The host component of this URI, or &lt;code&gt;null&lt;/code&gt; if the host is undefined</source>
          <target state="translated">이 URI의 호스트 컴퍼넌트 . 호스트가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb770726793d61fc3715477603a657f226342af0" translate="yes" xml:space="preserve">
          <source>The host is expressed as a DNS name, as a numerical IP address, or as &quot;localhost&quot; (for the local machine). The wildcard &quot;*&quot; may be included once in a DNS name host specification. If it is included, it must be in the leftmost position, as in &quot;*.sun.com&quot;.</source>
          <target state="translated">호스트는 DNS 이름, 숫자 IP 주소 또는 &quot;localhost&quot;(로컬 시스템의 경우)로 표시됩니다. 와일드 카드 &quot;*&quot;는 DNS 이름 호스트 사양에 한 번만 포함될 수 있습니다. 포함 된 경우 &quot;* .sun.com&quot;과 같이 가장 왼쪽에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e252805e8eb7c5662da677e362f2cd533b3c21d" translate="yes" xml:space="preserve">
          <source>The host name can either be a machine name, such as &quot;&lt;code&gt;java.sun.com&lt;/code&gt;&quot;, or a textual representation of its IP address.</source>
          <target state="translated">호스트 이름은 &quot; &lt;code&gt;java.sun.com&lt;/code&gt; &quot; 과 같은 시스템 이름 이거나 IP 주소의 텍스트 표현 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1afa1c850d1e44153fc7f23be8c095a3d2063c" translate="yes" xml:space="preserve">
          <source>The host name can either be a machine name, such as &quot;&lt;code&gt;java.sun.com&lt;/code&gt;&quot;, or a textual representation of its IP address. If a literal IP address is supplied, only the validity of the address format is checked.</source>
          <target state="translated">호스트 이름은 &quot; &lt;code&gt;java.sun.com&lt;/code&gt; &quot; 과 같은 시스템 이름 이거나 IP 주소의 텍스트 표현 일 수 있습니다. 리터럴 IP 주소가 제공되면 주소 형식의 유효성 만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="a3428c73a7d464a7c6ecc80b4fae8fd1231500c2" translate="yes" xml:space="preserve">
          <source>The host part of the Service URL. If the Service URL was constructed with the constructor that takes a URL string parameter, the result is the substring specifying the host in that URL. If the Service URL was constructed with a constructor that takes a separate host parameter, the result is the string that was specified. If that string was null, the result is &lt;code&gt;InetAddress.getLocalHost().getHostName()&lt;/code&gt;.</source>
          <target state="translated">서비스 URL의 호스트 부분. URL 문자열 매개 변수를 사용하는 생성자로 서비스 URL을 구성한 경우 결과는 해당 URL의 호스트를 지정하는 하위 문자열입니다. 서비스 URL이 별도의 호스트 매개 변수를 사용하는 생성자로 구성된 경우 결과는 지정된 문자열입니다. 해당 문자열이 널인 경우 결과는 &lt;code&gt;InetAddress.getLocalHost().getHostName()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1dcee8edf5db3c10041f3cbfdb216b1982c4cffa" translate="yes" xml:space="preserve">
          <source>The hour-of-am-pm.</source>
          <target state="translated">오후 1시</target>
        </trans-unit>
        <trans-unit id="b720f6beb2fbf1d5c52c3391ad82145cb332f215" translate="yes" xml:space="preserve">
          <source>The hour-of-day.</source>
          <target state="translated">시간.</target>
        </trans-unit>
        <trans-unit id="01edc38d3117a9fe881c313fc58cca68efb8a8e6" translate="yes" xml:space="preserve">
          <source>The http response code.</source>
          <target state="translated">http 응답 코드</target>
        </trans-unit>
        <trans-unit id="b1398050303d32bd6bb6a984fba0512e95f44388" translate="yes" xml:space="preserve">
          <source>The human-readable description of the feature. It is recommended that subclasses call &lt;a href=&quot;mbeanfeatureinfo#getDescription--&quot;&gt;&lt;code&gt;getDescription()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">사람이 읽을 수있는 기능에 대한 설명입니다. 서브 클래스는 이 필드를 읽지 않고 &lt;a href=&quot;mbeanfeatureinfo#getDescription--&quot;&gt; &lt;code&gt;getDescription()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="067c8f1c5a2df4367c4fb697f0db77afbe16cfb8" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의 쌍곡선 코사인 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac815b6ce55116fb0ad007c349798f1c55dd700a" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 사인 .</target>
        </trans-unit>
        <trans-unit id="f1dc45b4f7299ddca231f496c19774a95fb60160" translate="yes" xml:space="preserve">
          <source>The hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">쌍곡선 탄젠트 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ceebf4829e52c6881341df19a363dee2748a39d" translate="yes" xml:space="preserve">
          <source>The id of the authorized user. &lt;code&gt;null&lt;/code&gt; means the authorization failed.</source>
          <target state="translated">권한이 부여 된 사용자의 ID입니다. &lt;code&gt;null&lt;/code&gt; 은 인증이 실패했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="190daa117302150eaa044ad50f789c954c118362" translate="yes" xml:space="preserve">
          <source>The id of this attribute. It cannot be null.</source>
          <target state="translated">이 속성의 ID입니다. 널이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af4834bd960aa2b9216df25c846ec21872b9bcac" translate="yes" xml:space="preserve">
          <source>The identifier of the new created timer notification.</source>
          <target state="translated">새로 작성된 타이머 알림의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="9f826dacde229ce2d8640f93c05a284337137571" translate="yes" xml:space="preserve">
          <source>The identifier.</source>
          <target state="translated">식별자입니다.</target>
        </trans-unit>
        <trans-unit id="5f01919588f40a4b942e738f32090ead7b0d1160" translate="yes" xml:space="preserve">
          <source>The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result &lt;code&gt;a&lt;/code&gt; that is the result of any series of accumulator and combiner invocations, &lt;code&gt;a&lt;/code&gt; must be equivalent to &lt;code&gt;combiner.apply(a, supplier.get())&lt;/code&gt;.</source>
          <target state="translated">ID 제약 조건에 따르면 부분적으로 누적 된 결과에 대해 빈 결과 컨테이너와 결합하면 동등한 결과가 생성되어야합니다. 즉, 부분적으로 축적 된 결과에 대해 누산기 및 결합기 호출의 임의의 일련의 결과 즉, &lt;code&gt;a&lt;/code&gt; 는 동등해야 &lt;code&gt;combiner.apply(a, supplier.get())&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a98ad4c844ccaeef716227f0929dd675df827093" translate="yes" xml:space="preserve">
          <source>The identity of a remote client of the JMX Remote API.</source>
          <target state="translated">JMX Remote API의 리모트 클라이언트의 아이덴티티.</target>
        </trans-unit>
        <trans-unit id="50a057a048396611cc27a43faa15d99cedba2e6f" translate="yes" xml:space="preserve">
          <source>The illegal Unicode code point</source>
          <target state="translated">잘못된 유니 코드 코드 포인트</target>
        </trans-unit>
        <trans-unit id="f118b75c2086f0962577e58b3b46529624d030c6" translate="yes" xml:space="preserve">
          <source>The illegal charset name</source>
          <target state="translated">잘못된 문자셋 이름</target>
        </trans-unit>
        <trans-unit id="650107fc502ca4b1e9a1b9ac9eb0045aaaf8cb53" translate="yes" xml:space="preserve">
          <source>The image contents may be supplied later using the &lt;code&gt;replacePixels&lt;/code&gt; method. The insertion is not complete until a call to &lt;code&gt;endInsertEmpty&lt;/code&gt; occurs. Calls to &lt;code&gt;prepareReplacePixels&lt;/code&gt;, &lt;code&gt;replacePixels&lt;/code&gt;, and &lt;code&gt;endReplacePixels&lt;/code&gt; may occur between calls to &lt;code&gt;prepareInsertEmpty&lt;/code&gt; and &lt;code&gt;endInsertEmpty&lt;/code&gt;. However, calls to &lt;code&gt;prepareInsertEmpty&lt;/code&gt; cannot be nested, and calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; and &lt;code&gt;prepareInsertEmpty&lt;/code&gt; may not be interspersed.</source>
          <target state="translated">이미지 내용은 나중에 &lt;code&gt;replacePixels&lt;/code&gt; 방법을 사용하여 제공 될 수 있습니다 . &lt;code&gt;endInsertEmpty&lt;/code&gt; 에 대한 호출이 발생할 때까지 삽입이 완료되지 않습니다 . 를 호출 &lt;code&gt;prepareReplacePixels&lt;/code&gt; , &lt;code&gt;replacePixels&lt;/code&gt; 및 &lt;code&gt;endReplacePixels&lt;/code&gt; 는 호출 사이에 발생할 수 &lt;code&gt;prepareInsertEmpty&lt;/code&gt; 및 &lt;code&gt;endInsertEmpty&lt;/code&gt; . 그러나 호출 &lt;code&gt;prepareInsertEmpty&lt;/code&gt; 중첩 될 수 없으며, 호출 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 와 &lt;code&gt;prepareInsertEmpty&lt;/code&gt; 산재되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d33b4e926de1659092487a8d33def5c221eb13e" translate="yes" xml:space="preserve">
          <source>The image data may take the form of either a &lt;code&gt;RenderedImage&lt;/code&gt;, or a &lt;code&gt;Raster&lt;/code&gt;. Reader methods that return an &lt;code&gt;IIOImage&lt;/code&gt; will always return a &lt;code&gt;BufferedImage&lt;/code&gt; using the &lt;code&gt;RenderedImage&lt;/code&gt; reference. Writer methods that accept an &lt;code&gt;IIOImage&lt;/code&gt; will always accept a &lt;code&gt;RenderedImage&lt;/code&gt;, and may optionally accept a &lt;code&gt;Raster&lt;/code&gt;.</source>
          <target state="translated">이미지 데이터는 &lt;code&gt;RenderedImage&lt;/code&gt; 또는 &lt;code&gt;Raster&lt;/code&gt; 형식 일 수 있습니다 . &lt;code&gt;IIOImage&lt;/code&gt; 를 리턴하는 리더 메소드 는 항상 &lt;code&gt;RenderedImage&lt;/code&gt; 참조를 사용하여 &lt;code&gt;BufferedImage&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;IIOImage&lt;/code&gt; 를 받아들이는 라이터 메소드 는 항상 &lt;code&gt;RenderedImage&lt;/code&gt; 를 받아들이고, 선택적으로 &lt;code&gt;Raster&lt;/code&gt; 를 받아 들일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcee0bb2e49666ba14873e56d922ec392d842b66" translate="yes" xml:space="preserve">
          <source>The image returned will be formatted according to the first &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; returned from &lt;code&gt;getImageTypes&lt;/code&gt;.</source>
          <target state="translated">리턴 된 이미지는 &lt;code&gt;getImageTypes&lt;/code&gt; 에서 리턴 된 첫 번째 &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; 에 따라 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6325bd4afd820329b33a81aad4acb98f22f1739" translate="yes" xml:space="preserve">
          <source>The implementation chooses a buffer size, which is measured in bytes but which encompasses an integral number of sample frames. The buffer size that the system has chosen may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">구현시 버퍼 크기를 선택합니다.이 크기는 바이트 단위로 측정되지만 정수 샘플 프레임을 포함합니다. 시스템이 선택한 버퍼 크기는 나중에 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 호출하여 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8ee360abb575ae83e0aad557bc14c7679e4103" translate="yes" xml:space="preserve">
          <source>The implementation chooses a buffer size, which is measured in bytes but which encompasses an integral number of sample frames. The buffer size that the system has chosen may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현시 버퍼 크기를 선택합니다.이 크기는 바이트 단위로 측정되지만 정수 샘플 프레임을 포함합니다. 시스템이 선택한 버퍼 크기는 나중에 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 호출하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="09ccd30cdba3e587d31b9f21539df9dbcdfde8d9" translate="yes" xml:space="preserve">
          <source>The implementation conforms to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;RFC 2965&lt;/a&gt;, section 3.3.</source>
          <target state="translated">구현은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;RFC 2965&lt;/a&gt; 섹션 3.3을 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="14e2c00678648d5a3c84fa75329fd77db6950875" translate="yes" xml:space="preserve">
          <source>The implementation creates a &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; spliterator from the set's &lt;code&gt;Iterator&lt;/code&gt;. The spliterator inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the set's iterator. The created &lt;code&gt;Spliterator&lt;/code&gt; additionally reports &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현은 세트의 &lt;code&gt;Iterator&lt;/code&gt; 로부터 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;후기 바인딩&lt;/a&gt;&lt;/em&gt; 스플리터를 작성합니다 . spliterator는 세트 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 특성을 상속 합니다. 생성 된 &lt;code&gt;Spliterator&lt;/code&gt; 는 또한 Spliterator.SUBSIZED를 보고 &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5223f3996aa8fb012e6b7bd1bc47d31df8164864" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the synthesizer is brought to a consistent state when jumping to the loop start point by sending appropriate controllers, pitch bend, and program change events.</source>
          <target state="translated">이 구현은 적절한 컨트롤러, 피치 벤드 및 프로그램 변경 이벤트를 전송하여 루프 시작점으로 점프 할 때 신시사이저가 일관된 상태가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="81e190cedf9e21a5a2481992af348a4d3f5f90b0" translate="yes" xml:space="preserve">
          <source>The implementation first checks to see if an expression with this value has already been written. If not, the expression is cloned, using the same procedure as &lt;code&gt;writeStatement&lt;/code&gt;, and the value of this expression is reconciled with the value of the cloned expression by calling &lt;code&gt;writeObject&lt;/code&gt;.</source>
          <target state="translated">구현은 먼저이 값을 가진 표현식이 이미 작성되었는지 확인합니다. 그렇지 않은 경우, &lt;code&gt;writeStatement&lt;/code&gt; 와 동일한 프로 시저를 사용하여 표현식이 복제 되고 &lt;code&gt;writeObject&lt;/code&gt; 를 호출하여이 표현식의 값이 복제 된 표현식의 값과 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cb9f909f198fcf0061370bf797f93bff7fa7ff4" translate="yes" xml:space="preserve">
          <source>The implementation method is described with a method handle. In theory, any method handle could be used. Currently supported are direct method handles representing invocation of virtual, interface, constructor and static methods.</source>
          <target state="translated">구현 방법은 메소드 핸들로 설명됩니다. 이론적으로는 모든 메소드 핸들을 사용할 수 있습니다. 가상, 인터페이스, 생성자 및 정적 메소드의 호출을 나타내는 직접 메소드 핸들이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f9a4ef58c41d6065832b1b74a1b3fa3eaa4f52" translate="yes" xml:space="preserve">
          <source>The implementation must take the input object and add to it. The implementation defines the logic of the addition and is responsible for documenting that logic. It may use any method on &lt;code&gt;Temporal&lt;/code&gt; to query the temporal object and perform the addition. The returned object must have the same observable type as the input object</source>
          <target state="translated">구현시 입력 개체를 가져 와서 추가해야합니다. 구현은 추가 논리를 정의하고 해당 논리를 문서화합니다. &lt;code&gt;Temporal&lt;/code&gt; 에서 임의의 메소드를 사용 하여 임시 오브젝트를 쿼리하고 추가를 수행 할 수 있습니다. 반환 된 객체는 입력 객체와 동일한 관찰 가능 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e56e06001459e0c1e6e272244337fd5cebdd144" translate="yes" xml:space="preserve">
          <source>The implementation must take the input object and adjust it. The implementation defines the logic of the adjustment and is responsible for documenting that logic. It may use any method on &lt;code&gt;Temporal&lt;/code&gt; to query the temporal object and perform the adjustment. The returned object must have the same observable type as the input object</source>
          <target state="translated">구현시 입력 개체를 가져 와서 조정해야합니다. 구현은 조정의 논리를 정의하며 해당 논리를 문서화합니다. &lt;code&gt;Temporal&lt;/code&gt; 에서 임의의 메소드를 사용 하여 임시 오브젝트를 쿼리하고 조정을 수행 할 수 있습니다. 반환 된 객체는 입력 객체와 동일한 관찰 가능 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2da52b48d84c4b30715e4af7716531223f872291" translate="yes" xml:space="preserve">
          <source>The implementation must take the input object and query it. The implementation defines the logic of the query and is responsible for documenting that logic. It may use any method on &lt;code&gt;TemporalAccessor&lt;/code&gt; to determine the result. The input object must not be altered.</source>
          <target state="translated">구현시 입력 개체를 가져 와서 쿼리해야합니다. 구현은 쿼리의 논리를 정의하며 해당 논리를 문서화합니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 에서 임의의 메소드 를 사용하여 결과를 판별 할 수 있습니다. 입력 개체를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2dacb5e6e4d33c85aaf3a8b2840566262196b216" translate="yes" xml:space="preserve">
          <source>The implementation must take the input object and subtract from it. The implementation defines the logic of the subtraction and is responsible for documenting that logic. It may use any method on &lt;code&gt;Temporal&lt;/code&gt; to query the temporal object and perform the subtraction. The returned object must have the same observable type as the input object</source>
          <target state="translated">구현시 입력 객체를 가져와 빼야합니다. 구현은 뺄셈의 논리를 정의하고 해당 논리를 문서화합니다. &lt;code&gt;Temporal&lt;/code&gt; 에서 임의의 메소드를 사용 하여 임시 오브젝트를 쿼리하고 빼기를 수행 할 수 있습니다. 반환 된 객체는 입력 객체와 동일한 관찰 가능 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bd649c4c9a306542067e2337ea94241b40146d2f" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;setSeed&lt;/code&gt; by class &lt;code&gt;Random&lt;/code&gt; happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the &lt;code&gt;long&lt;/code&gt; argument as a seed value.</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; 클래스에 의한 &lt;code&gt;setSeed&lt;/code&gt; 의 구현은 주어진 시드의 48 비트만을 사용합니다. 그러나 일반적으로 재정의 방법은 &lt;code&gt;long&lt;/code&gt; 인수 의 64 비트를 모두 시드 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35791792ef6356de1f2cbc30dca9984d8aef3776" translate="yes" xml:space="preserve">
          <source>The implementation of a &lt;code&gt;ListResourceBundle&lt;/code&gt; subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the methods in this class are thread-safe.</source>
          <target state="translated">&lt;code&gt;ListResourceBundle&lt;/code&gt; 서브 클래스 의 구현은 다중 스레드에서 동시에 사용되는 경우 스레드 안전해야합니다. 이 클래스의 메소드의 기본 구현은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="dbd88d54003995fa128d1a669f95113fbbc46b8d" translate="yes" xml:space="preserve">
          <source>The implementation of a &lt;code&gt;PropertyResourceBundle&lt;/code&gt; subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the non-abstract methods in this class are thread-safe.</source>
          <target state="translated">&lt;code&gt;PropertyResourceBundle&lt;/code&gt; 서브 클래스 의 구현은 다중 스레드에서 동시에 사용되는 경우 스레드 안전해야합니다. 이 클래스에서 비추 상 메소드의 기본 구현은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8f2a4a09568db481af411da9df2b6666a394506d" translate="yes" xml:space="preserve">
          <source>The implementation of a &lt;code&gt;ResourceBundle&lt;/code&gt; subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the non-abstract methods in this class, and the methods in the direct known concrete subclasses &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt; are thread-safe.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; 서브 클래스 의 구현은 여러 스레드에서 동시에 사용되는 경우 스레드 안전해야합니다. 이 클래스의 비추 상 메소드의 기본 구현과 직접 알려진 구체적인 서브 클래스 &lt;code&gt;ListResourceBundle&lt;/code&gt; 및 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 의 메소드 는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="967f67768043a0e5a6e3ce4151e32a33e8442d96" translate="yes" xml:space="preserve">
          <source>The implementation of class &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt; does not guarantee that equivalent data flavors will have the same serialized representation. DocFlavor does, and can be used in services which need this.</source>
          <target state="translated">클래스 &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt; 의 구현은 동등한 데이터 플레이버가 동일한 직렬화 된 표현을 가질 것이라고 보장하지 않습니다. DocFlavor는이를 필요로하는 서비스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa595b341b716ddfe95468de8d46da61dd15f01" translate="yes" xml:space="preserve">
          <source>The implementation of class &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt; includes a human presentable name as part of the serialized representation. This is not appropriate as part of a service matching constraint.</source>
          <target state="translated">클래스 &lt;code&gt;java.awt.datatransfer.DataFlavor&lt;/code&gt; 의 구현 에는 직렬화 된 표현의 일부로 사람이 표시 할 수있는 이름이 포함됩니다. 이는 서비스 일치 제한 조건의 일부로 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3f640b6933929080a0a003b9d5726689efac7dc" translate="yes" xml:space="preserve">
          <source>The implementation of selectors, selectable channels, and selection keys can be replaced by &quot;plugging in&quot; an alternative definition or instance of the &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; class defined in the &lt;code&gt;&lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.channels.spi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; package. It is not expected that many developers will actually make use of this facility; it is provided primarily so that sophisticated users can take advantage of operating-system-specific I/O-multiplexing mechanisms when very high performance is required.</source>
          <target state="translated">선택기, 선택 가능 채널 및 선택 키의 구현은 &lt;code&gt;&lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.channels.spi&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 패키지에 정의 된 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 클래스 의 대체 정의 또는 인스턴스를 &quot;플러그인&quot;하여 대체 할 수 있습니다 . 많은 개발자들이 실제로이 기능을 사용할 것으로 예상되지는 않습니다. 기본적으로 고급 사용자가 매우 높은 성능이 필요할 때 운영 체제 별 I / O 멀티플렉싱 메커니즘을 활용할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d1783d029ef344e41e430f17d5f10e6b3b15270a" translate="yes" xml:space="preserve">
          <source>The implementation of this Standard MBean (or MXBean).</source>
          <target state="translated">이 표준 MBean (또는 MXBean)의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="382a6dd38dda6c0a39223f62855989d45f555777" translate="yes" xml:space="preserve">
          <source>The implementation of this method authenticates a &lt;code&gt;Subject&lt;/code&gt;. For example, it may prompt for &lt;code&gt;Subject&lt;/code&gt; information such as a username and password and then attempt to verify the password. This method saves the result of the authentication attempt as private state within the LoginModule.</source>
          <target state="translated">이 메소드의 구현은 &lt;code&gt;Subject&lt;/code&gt; 를 인증합니다 . 예를 들어, 사용자 이름 및 비밀번호와 같은 &lt;code&gt;Subject&lt;/code&gt; 정보를 묻는 프롬프트가 표시 되면 비밀번호 확인을 시도 할 수 있습니다. 이 방법은 인증 시도 결과를 LoginModule 내 개인 상태로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f858f34f76a8d32fba15b3e497ed1df2fe0bb20c" translate="yes" xml:space="preserve">
          <source>The implementation of this method may transform the supplied class file and return a new replacement class file.</source>
          <target state="translated">이 메소드의 구현은 제공된 클래스 파일을 변환하고 새 대체 클래스 파일을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5621f16ce87e09eca19aa3e0b40c7ee6b5d44b52" translate="yes" xml:space="preserve">
          <source>The implementation of this method will produce a second expression to represent the same expression in an environment that will exist when the stream is read. This is achieved simply by calling &lt;code&gt;writeObject&lt;/code&gt; on the target and all the arguments and building a new expression with the results.</source>
          <target state="translated">이 메소드의 구현은 스트림을 읽을 때 존재할 환경에서 동일한 표현식을 나타내는 두 번째 표현식을 생성합니다. 대상과 모든 인수에서 &lt;code&gt;writeObject&lt;/code&gt; 를 호출 하고 결과를 사용하여 새 표현식을 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0f6c0c74d6ce56b3b7dcf48a3803936cda181fb0" translate="yes" xml:space="preserve">
          <source>The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.</source>
          <target state="translated">구현은 결과 공급 업체, 누산기 또는 결합기 함수의 결과로 누산기, 결합기 또는 피니셔 함수로 다시 전달하거나 축소 작업의 호출자에게 반환하는 것 이외의 다른 결과를 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="764bc44f931b2a056f6de3d2e74007be7dab4252" translate="yes" xml:space="preserve">
          <source>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array.</source>
          <target state="translated">구현시 입력 배열에서 오름차순 및 내림차순을 동일하게 사용하며 동일한 입력 배열의 다른 부분에서 오름차순 및 내림차순을 활용할 수 있습니다. 둘 이상의 정렬 된 배열을 병합하는 데 적합합니다. 단순히 배열을 연결하고 결과 배열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="20e810f071954672f66c3ff4da645466cee6a581" translate="yes" xml:space="preserve">
          <source>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array.</source>
          <target state="translated">구현시 입력 배열에서 오름차순 및 내림차순을 동일하게 사용하며 동일한 입력 배열의 다른 부분에서 오름차순 및 내림차순을 활용할 수 있습니다. 둘 이상의 정렬 된 배열을 병합하는 데 적합합니다. 단순히 배열을 연결하고 결과 배열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="d19f87950e204f701655c7eb90a32dffeb95482a" translate="yes" xml:space="preserve">
          <source>The implementation that observes events from the file system is intended to map directly on to the native file event notification facility where available, or to use a primitive mechanism, such as polling, when a native facility is not available. Consequently, many of the details on how events are detected, their timeliness, and whether their ordering is preserved are highly implementation specific. For example, when a file in a watched directory is modified then it may result in a single &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt;&lt;code&gt;ENTRY_MODIFY&lt;/code&gt;&lt;/a&gt; event in some implementations but several events in other implementations. Short-lived files (meaning files that are deleted very quickly after they are created) may not be detected by primitive implementations that periodically poll the file system to detect changes.</source>
          <target state="translated">파일 시스템에서 이벤트를 관찰하는 구현은 사용 가능한 경우 기본 파일 이벤트 알림 기능에 직접 맵핑하거나 기본 기능을 사용할 수없는 경우 폴링과 같은 기본 메커니즘을 사용하기위한 것입니다. 결과적으로 이벤트 감지 방법, 적시성 및 순서 유지 여부에 대한 많은 세부 사항은 구현에 따라 다릅니다. 예를 들어 감시 된 디렉토리의 파일이 수정 되면 일부 구현 에서는 단일 &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt; &lt;code&gt;ENTRY_MODIFY&lt;/code&gt; &lt;/a&gt; 이벤트가 발생하지만 다른 구현에서는 여러 이벤트 가 발생할 수 있습니다 . 수명이 짧은 파일 (생성 된 후 파일이 매우 빠르게 삭제됨)은 파일 시스템을 정기적으로 폴링하여 변경 사항을 감지하는 기본 구현에서 감지되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d66d33c9220cc88ec7f77711dd3f7ca2bf80a6" translate="yes" xml:space="preserve">
          <source>The implementation title, version, and vendor strings identify an implementation and are made available conveniently to enable accurate reporting of the packages involved when a problem occurs. The contents all three implementation strings are vendor specific. The implementation version strings have no specified syntax and should only be compared for equality with desired version identifiers.</source>
          <target state="translated">구현 제목, 버전 및 공급 업체 문자열은 구현을 식별하며 문제가 발생할 때 관련된 패키지를 정확하게보고 할 수 있도록 편리하게 제공됩니다. 세 가지 구현 문자열의 내용은 모두 공급 업체에 따라 다릅니다. 구현 버전 문자열에는 지정된 구문이 없으며 원하는 버전 식별자와 동일한 지 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="f348190d718bffe13008c0ecdf1745c28e601e6d" translate="yes" xml:space="preserve">
          <source>The implementation typically achieves this goal by producing a series of &quot;what happened&quot; statements involving the &lt;code&gt;oldInstance&lt;/code&gt; and its publicly available state. These statements are sent to the output stream using its &lt;code&gt;writeExpression&lt;/code&gt; method which returns an expression involving elements in a cloned environment simulating the state of an input stream during reading. Each statement returned will have had all instances the old environment replaced with objects which exist in the new one. In particular, references to the target of these statements, which start out as references to &lt;code&gt;oldInstance&lt;/code&gt; are returned as references to the &lt;code&gt;newInstance&lt;/code&gt; instead. Executing these statements effects an incremental alignment of the state of the two objects as a series of modifications to the objects in the new environment. By the time the initialize method returns it should be impossible to tell the two instances apart by using their public APIs. Most importantly, the sequence of steps that were used to make these objects appear equivalent will have been recorded by the output stream and will form the actual output when the stream is flushed.</source>
          <target state="translated">구현은 일반적으로 &lt;code&gt;oldInstance&lt;/code&gt; 및 공개적으로 사용 가능한 상태와 관련된 일련의 &quot;무슨 일&quot;을 생성하여이 목표를 달성합니다 . 이 명령문은 &lt;code&gt;writeExpression&lt;/code&gt; 메소드를 사용하여 출력 스트림으로 전송됩니다.이 메소드는 읽기 환경에서 입력 스트림의 상태를 시뮬레이션하는 복제 된 환경의 요소와 관련된 표현식을 리턴합니다. 리턴 된 각 명령문에는 이전 환경이 새 환경에 존재하는 오브젝트로 대체 된 모든 인스턴스가 있습니다. 특히, &lt;code&gt;oldInstance&lt;/code&gt; 에 대한 참조로 시작되는 이러한 명령문의 대상에 대한 참조는 &lt;code&gt;newInstance&lt;/code&gt; 에 대한 참조로 리턴됩니다.대신에. 이 명령문을 실행하면 새 환경의 오브젝트에 대한 일련의 수정 사항으로 두 오브젝트의 상태가 점진적으로 정렬됩니다. initialize 메소드가 리턴 할 때까지 공용 API를 사용하여 두 인스턴스를 구별하는 것은 불가능합니다. 가장 중요한 것은 이러한 객체를 동일하게 보이게하는 데 사용 된 일련의 단계는 출력 스트림에 의해 기록 된 것이며 스트림이 플러시 될 때 실제 출력을 형성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0071233711fe7922557f3cc5e77ff86d3c7489b1" translate="yes" xml:space="preserve">
          <source>The implementation was adapted from Tim Peters's list sort for Python (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt; TimSort&lt;/a&gt;). It uses techniques from Peter McIlroy's &quot;Optimistic Sorting and Information Theoretic Complexity&quot;, in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.</source>
          <target state="translated">이 구현은 Tim Peters의 목록 정렬 (Python ( &lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;TimSort&lt;/a&gt; )) 에서 채택되었습니다 . 이 문서는 Peter McIlroy의 &quot;최적 정렬 및 정보 이론적 복잡성&quot;기술을 사용하여 이산 알고리즘에 관한 제 4 차 연례 ACM-SIAM 심포지엄, pp 467-474, 1993 년 1 월에 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="13c96c1ad096f5a00f55072e0f2d6780edfeb958" translate="yes" xml:space="preserve">
          <source>The implementer must ensure that the returned node has not been removed. If a like-named child of this node was previously removed, the implementer must return a newly constructed &lt;code&gt;AbstractPreferences&lt;/code&gt; node; once removed, an &lt;code&gt;AbstractPreferences&lt;/code&gt; node cannot be &quot;resuscitated.&quot;</source>
          <target state="translated">구현자는 리턴 된 노드가 제거되지 않았는지 확인해야합니다. 이 노드의 같은 이름의 자식이 이전에 제거 된 경우 구현자는 새로 구성된 &lt;code&gt;AbstractPreferences&lt;/code&gt; 노드를 반환해야 합니다. 일단 제거되면 &lt;code&gt;AbstractPreferences&lt;/code&gt; 노드는 &quot;소생&quot;될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ef8dcbf55f1377ba0f6614596e7efbe0b86999c" translate="yes" xml:space="preserve">
          <source>The implementor must also ensure that the relation is transitive: &lt;code&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0))&lt;/code&gt; implies &lt;code&gt;compare(x, z)&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">구현할 경우도 전이 관계인지 확인한다 : &lt;code&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0))&lt;/code&gt; 것을 의미 &lt;code&gt;compare(x, z)&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93c35843f73a7cf775788fe7aa6a58715a248347" translate="yes" xml:space="preserve">
          <source>The implementor must also ensure that the relation is transitive: &lt;code&gt;(x.compareTo(y)&amp;gt;0 &amp;amp;&amp;amp; y.compareTo(z)&amp;gt;0)&lt;/code&gt; implies &lt;code&gt;x.compareTo(z)&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">구현자가 또한 전이 관계인지 확인한다 : &lt;code&gt;(x.compareTo(y)&amp;gt;0 &amp;amp;&amp;amp; y.compareTo(z)&amp;gt;0)&lt;/code&gt; 의미 &lt;code&gt;x.compareTo(z)&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984e8a841ada6b193bdac6bd769182c3ed6633a1" translate="yes" xml:space="preserve">
          <source>The implementor must ensure &lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. (This implies that &lt;code&gt;x.compareTo(y)&lt;/code&gt; must throw an exception iff &lt;code&gt;y.compareTo(x)&lt;/code&gt; throws an exception.)</source>
          <target state="translated">구현자는 모든 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 에 대해 &lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt; 를 확인해야 합니다. (이것은 &lt;code&gt;y.compareTo(x)&lt;/code&gt; 가 예외를 던지면 &lt;code&gt;x.compareTo(y)&lt;/code&gt; 가 예외를 발생시켜야 함을 의미합니다 .)</target>
        </trans-unit>
        <trans-unit id="6f253988de023323ef8d0ef1dfa1dcf6d324129a" translate="yes" xml:space="preserve">
          <source>The implementor must ensure that &lt;code&gt;sgn(compare(x, y)) == -sgn(compare(y, x))&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. (This implies that &lt;code&gt;compare(x, y)&lt;/code&gt; must throw an exception if and only if &lt;code&gt;compare(y, x)&lt;/code&gt; throws an exception.)</source>
          <target state="translated">구현자는 모든 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 에 대해 &lt;code&gt;sgn(compare(x, y)) == -sgn(compare(y, x))&lt;/code&gt; 해야합니다 . (이것은 &lt;code&gt;compare(y, x)&lt;/code&gt; 가 예외를 던지는 경우에만 &lt;code&gt;compare(x, y)&lt;/code&gt; 가 예외를 throw해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c5bd518953d05705af43274895fb8112f343bc54" translate="yes" xml:space="preserve">
          <source>The implicit state of a matcher includes the input character sequence as well as the</source>
          <target state="translated">매처의 내재 된 상태에는 입력 문자 순서와</target>
        </trans-unit>
        <trans-unit id="7aa873e376794141b49cb1ea8a0bd75fbba299ec" translate="yes" xml:space="preserve">
          <source>The importance of this to parallel evaluation can be seen if we expand this to four terms:</source>
          <target state="translated">이것을 4 개의 용어로 확장하면 병렬 평가에 대한 중요성을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b8f3fc9feb417d0cc733925e38d2fcdc82d0b5" translate="yes" xml:space="preserve">
          <source>The in-memory representation of an elements may contain a reference to an &lt;code&gt;Object&lt;/code&gt;. There is no provision for representing such objects textually.</source>
          <target state="translated">요소의 메모리 내 표현에는 &lt;code&gt;Object&lt;/code&gt; 에 대한 참조가 포함될 수 있습니다 . 그러한 객체를 텍스트로 표현할 규정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d11ff3668969981f7d9c4c8296a5b6396f07bac9" translate="yes" xml:space="preserve">
          <source>The inapplicable conversion</source>
          <target state="translated">적용 할 수없는 전환</target>
        </trans-unit>
        <trans-unit id="bb2a6499474ea9eac81ba3d143a5276ee4c995c9" translate="yes" xml:space="preserve">
          <source>The inbound network buffer may be modified as a result of this call: therefore if the network data packet is required for some secondary purpose, the data should be duplicated before calling this method. Note: the network data will not be useful to a second SSLEngine, as each SSLEngine contains unique random state which influences the SSL/TLS messages.</source>
          <target state="translated">이 호출의 결과로 인바운드 네트워크 버퍼가 수정 될 수 있습니다. 따라서 일부 보조 목적으로 네트워크 데이터 패킷이 필요한 경우이 메소드를 호출하기 전에 데이터를 복제해야합니다. 참고 : 각 SSLEngine에는 SSL / TLS 메시지에 영향을주는 고유 한 임의 상태가 포함되므로 네트워크 데이터는 두 번째 SSLEngine에 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d09f0816d06c72350347621095fd55b4391384a1" translate="yes" xml:space="preserve">
          <source>The index argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than the length of this sequence.</source>
          <target state="translated">인덱스 인수는 &lt;code&gt;0&lt;/code&gt; 보다 크거나 같아야하며이 시퀀스의 길이보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="d110c0303b7504a3d86b1ba9fbbb90cb3182eff3" translate="yes" xml:space="preserve">
          <source>The index must be a value greater than or equal to &lt;code&gt;0&lt;/code&gt; and less than or equal to the current size of the vector. (If the index is equal to the current size of the vector, the new element is appended to the Vector.)</source>
          <target state="translated">인덱스는 &lt;code&gt;0&lt;/code&gt; 보다 크거나 같고 벡터의 현재 크기 보다 작거나 같은 값이어야합니다 . 색인이 벡터의 현재 크기와 같으면 새 요소가 벡터에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c8b94ccd821ae168771b3c0bce8f50e0fa10c633" translate="yes" xml:space="preserve">
          <source>The index must be a value greater than or equal to &lt;code&gt;0&lt;/code&gt; and less than the current size of the vector.</source>
          <target state="translated">인덱스는 &lt;code&gt;0&lt;/code&gt; 보다 크거나 같고 벡터의 현재 크기보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="f695822c13213a26a764fdd97f97ec145aace4f7" translate="yes" xml:space="preserve">
          <source>The index of the end of this buffer. There is not valid data at or beyond this index.</source>
          <target state="translated">이 버퍼 끝의 인덱스입니다. 이 인덱스 이상의 유효한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1590c17a9cdabf74852b9b628b34f6bb6547ef85" translate="yes" xml:space="preserve">
          <source>The index of the first character captured by the group, or &lt;code&gt;-1&lt;/code&gt; if the match was successful but the group itself did not match anything</source>
          <target state="translated">그룹이 캡처 한 첫 번째 문자의 색인이거나 , 일치했지만 그룹 자체가 아무 것도 일치하지 않으면 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14690427864e8e9fb011be08cf98fb6bec38525d" translate="yes" xml:space="preserve">
          <source>The index of the first character matched</source>
          <target state="translated">일치하는 첫 번째 문자의 색인</target>
        </trans-unit>
        <trans-unit id="2b1a675cd8d72171fb8d26b97ee0f084893697b2" translate="yes" xml:space="preserve">
          <source>The index of the next character to read from the input stream buffer.</source>
          <target state="translated">입력 스트림 버퍼에서 읽을 다음 문자의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6236644c7f73481257e874584222314b9bf01500" translate="yes" xml:space="preserve">
          <source>The index of the next character to read from the input stream buffer. This value should always be nonnegative and not larger than the value of &lt;code&gt;count&lt;/code&gt;. The next byte to be read from the input stream buffer will be &lt;code&gt;buf[pos]&lt;/code&gt;.</source>
          <target state="translated">입력 스트림 버퍼에서 읽을 다음 문자의 인덱스입니다. 이 값은 항상 음수가 아니어야하며 &lt;code&gt;count&lt;/code&gt; 값보다 크지 않아야 합니다. 입력 스트림 버퍼에서 읽을 다음 바이트는 &lt;code&gt;buf[pos]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5efc56a51a0de538997e4f3583c8deb79cf74c6d" translate="yes" xml:space="preserve">
          <source>The index of the position in the circular buffer at which the next byte of data will be read by this piped input stream.</source>
          <target state="translated">이 파이프 된 입력 스트림이 다음 바이트의 데이터를 읽을 순환 버퍼의 위치 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7730a24d44411399e802148bed0e48e3d5ce6bbf" translate="yes" xml:space="preserve">
          <source>The index of the position in the circular buffer at which the next byte of data will be stored when received from the connected piped output stream. &lt;code&gt;in&amp;lt;0&lt;/code&gt; implies the buffer is empty, &lt;code&gt;in==out&lt;/code&gt; implies the buffer is full</source>
          <target state="translated">연결된 파이프 출력 스트림에서 수신 될 때 다음 바이트의 데이터가 저장 될 순환 버퍼의 위치 인덱스입니다. &lt;code&gt;in&amp;lt;0&lt;/code&gt; 은 버퍼가 비어 있음을 나타내고 &lt;code&gt;in==out&lt;/code&gt; 은 버퍼가 가득 찼음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35f63ccce04acce64e5535be8e7c215541fbc335" translate="yes" xml:space="preserve">
          <source>The index one greater than the index of the last valid byte in the buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;; elements &lt;code&gt;buf[0]&lt;/code&gt; through &lt;code&gt;buf[count-1]
 &lt;/code&gt;contain buffered input data obtained from the underlying input stream.</source>
          <target state="translated">버퍼에서 마지막 유효 바이트의 인덱스보다 하나 큰 인덱스. 이 값은 항상 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;buf.length&lt;/code&gt; 범위입니다 . &lt;code&gt;buf[0]&lt;/code&gt; ~ &lt;code&gt;buf[count-1] &lt;/code&gt; 요소 는 기본 입력 스트림에서 얻은 버퍼링 된 입력 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7532d289f9d5f9dcf22dd308f11ba59cb53013a2" translate="yes" xml:space="preserve">
          <source>The index one greater than the last valid character in the input stream buffer. This value should always be nonnegative and not larger than the length of &lt;code&gt;buf&lt;/code&gt;. It is one greater than the position of the last byte within &lt;code&gt;buf&lt;/code&gt; that can ever be read from the input stream buffer.</source>
          <target state="translated">입력 스트림 버퍼의 마지막 유효 문자보다 1 큰 인덱스. 이 값은 항상 음이 아니어야하고 &lt;code&gt;buf&lt;/code&gt; 길이보다 크지 않아야 합니다. 입력 스트림 버퍼에서 읽을 수 있는 &lt;code&gt;buf&lt;/code&gt; 내의 마지막 바이트 위치보다 1이 큽니다 .</target>
        </trans-unit>
        <trans-unit id="c9b5de3fe1d20ea7f6963929d78c83ff1a95b6b4" translate="yes" xml:space="preserve">
          <source>The index specifying the property element that was changed.</source>
          <target state="translated">변경된 프로퍼티 요소를 지정하는 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="d3784a6dc8c24e3b9cfd559138d87a6ec297e1ea" translate="yes" xml:space="preserve">
          <source>The indexing of RDNs in the list follows the numbering of RDNs described in the class description.</source>
          <target state="translated">목록에서 RDN의 색인 작성은 클래스 설명에 설명 된 RDN의 번호 지정을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="faa5405bce53fb18abb915b5abeb8c78b7d17c39" translate="yes" xml:space="preserve">
          <source>The individual positive and negative permission sets are also determined. The positive permission set contains the permissions specified in the positive ACL entry (if any) for the principal. Similarly, the negative permission set contains the permissions specified in the negative ACL entry (if any) for the principal. The individual positive (or negative) permission set is considered to be null if there is not a positive (negative) ACL entry for the principal in this ACL.</source>
          <target state="translated">개별 긍정적 및 부정적 권한 집합도 결정됩니다. 긍정적 인 권한 집합에는 보안 주체에 대한 긍정적 인 ACL 항목 (있는 경우)에 지정된 권한이 포함됩니다. 마찬가지로, 부정 권한 세트에는 보안 주체에 대한 부정 ACL 항목 (있는 경우)에 지정된 권한이 포함됩니다. 이 ACL의 프린시 펄에 대한 긍정적 (음) ACL 항목이없는 경우 개별 긍정적 (또는 부정) 권한 세트는 널로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ef3f30727d6bb6becf057ae182437cf5ed0c6feb" translate="yes" xml:space="preserve">
          <source>The information about a memory notification.</source>
          <target state="translated">메모리 알림에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="ca5670133dfad682241f9a7899b676fcf937d136" translate="yes" xml:space="preserve">
          <source>The information is returned as a set of pairs; the first element of a pair contains an (inclusive) minimum width and height, and the second element contains an (inclusive) maximum width and height. Together, each pair defines a valid range of sizes. To specify a fixed size, the same width and height will appear for both elements. A return value of &lt;code&gt;null&lt;/code&gt; indicates that the size is arbitrary or unknown.</source>
          <target state="translated">정보는 한 쌍의 세트로 리턴됩니다. 쌍의 첫 번째 요소에는 최소 너비와 높이가 포함되며 두 번째 요소에는 최대 너비와 높이가 포함됩니다. 각 쌍은 유효한 크기 범위를 정의합니다. 고정 크기를 지정하려면 두 요소 모두에 동일한 너비와 높이가 나타납니다. &lt;code&gt;null&lt;/code&gt; 값을 반환 하면 크기가 임의적이거나 알 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a415dbd9864205bad4fef6fbdbf7a0c48d16cbbf" translate="yes" xml:space="preserve">
          <source>The information is returned as a set of pairs; the first element of a pair contains an (inclusive) minimum width and height, and the second element contains an (inclusive) maximum width and height. Together, each pair defines a valid range of sizes. To specify a fixed size, use the same width and height for both elements. To specify an arbitrary range, a value of &lt;code&gt;null&lt;/code&gt; is used in place of an actual array of &lt;code&gt;Dimension&lt;/code&gt;s.</source>
          <target state="translated">정보는 한 쌍의 세트로 리턴됩니다. 쌍의 첫 번째 요소에는 최소 너비와 높이가 포함되며 두 번째 요소에는 최대 너비와 높이가 포함됩니다. 각 쌍은 유효한 크기 범위를 정의합니다. 고정 크기를 지정하려면 두 요소 모두에 동일한 너비와 높이를 사용하십시오. 임의의 범위를 지정하기 위해 실제 &lt;code&gt;Dimension&lt;/code&gt; 배열 대신 &lt;code&gt;null&lt;/code&gt; 값 이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3103eb0cb29acd4b776d2c741f795f0cb2bfd745" translate="yes" xml:space="preserve">
          <source>The information stored in a &lt;code&gt;ProtectionParameter&lt;/code&gt; object protects the contents of a keystore. For example, protection parameters may be used to check the integrity of keystore data, or to protect the confidentiality of sensitive keystore data (such as a &lt;code&gt;PrivateKey&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ProtectionParameter&lt;/code&gt; 객체에 저장된 정보 는 키 저장소의 내용을 보호합니다. 예를 들어, 보호 매개 변수를 사용하여 키 저장소 데이터의 무결성을 확인하거나 민감한 키 저장소 데이터 (예 : &lt;code&gt;PrivateKey&lt;/code&gt; ) 의 기밀성을 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f232b85978434189e4a717f030e028407dbe5c9" translate="yes" xml:space="preserve">
          <source>The information that can be retrieved from an object class definition is directory-dependent.</source>
          <target state="translated">객체 클래스 정의에서 검색 할 수있는 정보는 디렉토리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d4844822fb540c78ff0305e65b984a34e04d1176" translate="yes" xml:space="preserve">
          <source>The information that you can retrieve from a syntax definition is directory-dependent.</source>
          <target state="translated">구문 정의에서 검색 할 수있는 정보는 디렉토리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d754234c829daf3f7bdab4a40e2f1300ae4ef5c9" translate="yes" xml:space="preserve">
          <source>The inherited channel, if any, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 상속 채널은, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23fdec03cbe08d9ee1145b99b267e04326a46f01" translate="yes" xml:space="preserve">
          <source>The initial &lt;a href=&quot;../nio/channels/filechannel#position--&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; of the returned channel will be equal to the number of bytes read from the file so far. Reading bytes from this stream will increment the channel's position. Changing the channel's position, either explicitly or by reading, will change this stream's file position.</source>
          <target state="translated">리턴 된 채널 의 초기 &lt;a href=&quot;../nio/channels/filechannel#position--&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 는 지금까지 파일에서 읽은 바이트 수와 같습니다. 이 스트림에서 바이트를 읽으면 채널 위치가 증가합니다. 채널 위치를 명시 적으로 또는 읽음으로 변경하면이 스트림의 파일 위치가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e56adadcca778289c07ac038c40805d5ee9569a3" translate="yes" xml:space="preserve">
          <source>The initial &lt;a href=&quot;../nio/channels/filechannel#position--&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; of the returned channel will be equal to the number of bytes written to the file so far unless this stream is in append mode, in which case it will be equal to the size of the file. Writing bytes to this stream will increment the channel's position accordingly. Changing the channel's position, either explicitly or by writing, will change this stream's file position.</source>
          <target state="translated">리턴 된 채널 의 초기 &lt;a href=&quot;../nio/channels/filechannel#position--&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 는이 스트림이 추가 모드에 있지 않는 한 파일에 기록 된 바이트 수와 같으며이 경우 파일 크기와 같습니다. 이 스트림에 바이트를 쓰면 그에 따라 채널의 위치가 증가합니다. 채널 위치를 명시 적 또는 쓰기로 변경하면이 스트림의 파일 위치가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="54104849828faeb71a83684ba5a379183a42a8a1" translate="yes" xml:space="preserve">
          <source>The initial capacity controls a tradeoff between wasted space and the need for &lt;code&gt;rehash&lt;/code&gt; operations, which are time-consuming. No &lt;code&gt;rehash&lt;/code&gt; operations will</source>
          <target state="translated">초기 용량은 낭비되는 공간과 시간이 많이 걸리는 &lt;code&gt;rehash&lt;/code&gt; 작업 의 필요성 간의 균형을 제어합니다 . &lt;code&gt;rehash&lt;/code&gt; 작업이 없습니다</target>
        </trans-unit>
        <trans-unit id="73036cdb82068da260ec582e655554dd532915b6" translate="yes" xml:space="preserve">
          <source>The initial class file bytes represent the bytes passed to &lt;a href=&quot;../classloader#defineClass-byte:A-int-int-&quot;&gt;&lt;code&gt;ClassLoader.defineClass&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;instrumentation#redefineClasses-java.lang.instrument.ClassDefinition...-&quot;&gt;&lt;code&gt;redefineClasses&lt;/code&gt;&lt;/a&gt; (before any transformations were applied), however they might not exactly match them. The constant pool might not have the same layout or contents. The constant pool may have more or fewer entries. Constant pool entries may be in a different order; however, constant pool indices in the bytecodes of methods will correspond. Some attributes may not be present. Where order is not meaningful, for example the order of methods, order might not be preserved.</source>
          <target state="translated">초기 클래스 파일 바이트는 변환이 적용되기 전에 &lt;a href=&quot;../classloader#defineClass-byte:A-int-int-&quot;&gt; &lt;code&gt;ClassLoader.defineClass&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;instrumentation#redefineClasses-java.lang.instrument.ClassDefinition...-&quot;&gt; &lt;code&gt;redefineClasses&lt;/code&gt; 에&lt;/a&gt; 전달 된 바이트를 나타내지 만 정확하게 일치하지 않을 수 있습니다. 상수 풀의 레이아웃이나 내용이 같지 않을 수 있습니다. 상수 풀에는 더 많거나 적은 항목이있을 수 있습니다. 상수 풀 항목은 다른 순서로있을 수 있습니다. 그러나 메소드의 바이트 코드에서 상수 풀 인덱스는 일치합니다. 일부 속성이 없을 수 있습니다. 순서가 의미가없는 경우 (예 : 메소드 순서) 순서가 유지되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad81007d5811bb624623fea0ed5de856f5ea5fbc" translate="yes" xml:space="preserve">
          <source>The initial context implementation is determined at runtime. The default policy uses the environment property &quot;&lt;a href=&quot;context#INITIAL_CONTEXT_FACTORY&quot;&gt;&lt;code&gt;java.naming.factory.initial&lt;/code&gt;&lt;/a&gt;&quot;, which contains the class name of the initial context factory. An exception to this policy is made when resolving URL strings, as described below.</source>
          <target state="translated">초기 컨텍스트 구현은 런타임에 결정됩니다. 기본 정책은 초기 컨텍스트 팩토리의 클래스 이름을 포함 하는 환경 특성 &quot; &lt;a href=&quot;context#INITIAL_CONTEXT_FACTORY&quot;&gt; &lt;code&gt;java.naming.factory.initial&lt;/code&gt; &lt;/a&gt; &quot;을 사용합니다 . 아래 설명과 같이 URL 문자열을 확인할 때이 정책은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="5968bd4b24be43322be2226d7e4b483ae0f3d038" translate="yes" xml:space="preserve">
          <source>The initial inherited setting may be overridden by calling &lt;a href=&quot;sslsocket#setNeedClientAuth-boolean-&quot;&gt;&lt;code&gt;SSLSocket.setNeedClientAuth(boolean)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sslsocket#setWantClientAuth-boolean-&quot;&gt;&lt;code&gt;SSLSocket.setWantClientAuth(boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상속 된 초기 설정은 &lt;a href=&quot;sslsocket#setNeedClientAuth-boolean-&quot;&gt; &lt;code&gt;SSLSocket.setNeedClientAuth(boolean)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sslsocket#setWantClientAuth-boolean-&quot;&gt; &lt;code&gt;SSLSocket.setWantClientAuth(boolean)&lt;/code&gt; &lt;/a&gt; 을 호출하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9935552c412b3a39d923f441da111d0d265b51da" translate="yes" xml:space="preserve">
          <source>The initial threshold value.</source>
          <target state="translated">초기 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="e4712f648942f6879aa403441218fb6b8e9518fe" translate="yes" xml:space="preserve">
          <source>The initial threshold.</source>
          <target state="translated">초기 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="bdc9501532a47a6e31c18417935f798102b78798" translate="yes" xml:space="preserve">
          <source>The initial value of this field is -4.</source>
          <target state="translated">이 필드의 초기 값은 -4입니다.</target>
        </trans-unit>
        <trans-unit id="f2f1d7dcaca30d81c998107fa35d0caadf3769db" translate="yes" xml:space="preserve">
          <source>The initial value of this field is 0.0.</source>
          <target state="translated">이 필드의 초기 값은 0.0입니다.</target>
        </trans-unit>
        <trans-unit id="b2c6b58f2a898e929dd294246d0e9d9b915b3041" translate="yes" xml:space="preserve">
          <source>The initial value of this field is null.</source>
          <target state="translated">이 필드의 초기 값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="480fad772f115d1b94ae7ccdff16d0e302222891" translate="yes" xml:space="preserve">
          <source>The initial value of this socket option is &lt;code&gt;FALSE&lt;/code&gt;. The socket option may be enabled or disabled at any time.</source>
          <target state="translated">이 소켓 옵션의 초기 값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다. 소켓 옵션은 언제든지 활성화하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d64b75cc22cc7a22a6b3905f1b539199bfb6427f" translate="yes" xml:space="preserve">
          <source>The initial value of this socket option is &lt;code&gt;FALSE&lt;/code&gt;. The socket option may be enabled or disabled at any time. Some operating systems may require that the Java virtual machine be started with implementation specific privileges to enable this option or send broadcast datagrams.</source>
          <target state="translated">이 소켓 옵션의 초기 값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다. 소켓 옵션은 언제든지 활성화하거나 비활성화 할 수 있습니다. 일부 운영 체제에서는이 옵션을 사용하거나 브로드 캐스트 데이터 그램을 전송하기 위해 구현 별 권한으로 Java 가상 머신을 시작해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b53baf5e2a73c2a6e3ac07e7437cbec9e913530a" translate="yes" xml:space="preserve">
          <source>The initial value of this socket option is a negative value, meaning that the option is disabled. The option may be enabled, or the linger interval changed, at any time. The maximum value of the linger interval is system dependent. Setting the linger interval to a value that is greater than its maximum value causes the linger interval to be set to its maximum value.</source>
          <target state="translated">이 소켓 옵션의 초기 값은 음수 값이므로 옵션이 비활성화되어 있습니다. 이 옵션은 언제든지 활성화되거나 지연 간격이 변경 될 수 있습니다. 지연 간격의 최대 값은 시스템에 따라 다릅니다. 지연 간격을 최대 값보다 큰 값으로 설정하면 지연 간격이 최대 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="145aa0f5c504a6b90dfb4929918b3107cf434d35" translate="yes" xml:space="preserve">
          <source>The initial/default size of the socket receive buffer and the range of allowable values is system dependent although a negative size is not allowed. An attempt to set the socket receive buffer to larger than its maximum size causes it to be set to its maximum size.</source>
          <target state="translated">소켓 수신 버퍼의 초기 / 기본 크기와 허용 가능한 값의 범위는 음수 크기는 허용되지 않지만 시스템에 따라 다릅니다. 소켓 수신 버퍼를 최대 크기보다 크게 설정하려고하면 최대 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="51f73748332022abeb0586fd7f96ab66f0792fc2" translate="yes" xml:space="preserve">
          <source>The initial/default size of the socket send buffer and the range of allowable values is system dependent although a negative size is not allowed. An attempt to set the socket send buffer to larger than its maximum size causes it to be set to its maximum size.</source>
          <target state="translated">소켓 송신 버퍼의 초기 / 기본 크기와 허용 가능한 값의 범위는 음수 크기는 허용되지 않지만 시스템에 따라 다릅니다. 소켓 송신 버퍼를 최대 크기보다 크게 설정하려고하면 최대 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6a796b3846abce78654b51752b778ce337d346" translate="yes" xml:space="preserve">
          <source>The initial/default value of the TOS field in the ToS octet is implementation specific but will typically be &lt;code&gt;0&lt;/code&gt;. For datagram-oriented sockets the option may be configured at any time after the socket has been bound. The new value of the octet is used when sending subsequent datagrams. It is system dependent whether this option can be queried or changed prior to binding the socket.</source>
          <target state="translated">ToS 옥텟에서 TOS 필드의 초기 / 기본 값은 구현에 따라 다르지만 일반적으로 &lt;code&gt;0&lt;/code&gt; 입니다. 데이터 그램 지향 소켓의 경우, 소켓이 바인드 된 후 언제든지 옵션을 구성 할 수 있습니다. 후속 데이터 그램을 전송할 때 옥텟의 새로운 값이 사용됩니다. 소켓 바인딩 전에이 옵션을 쿼리하거나 변경할 수 있는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e93c89bc9134002e795c3937793d09a863552a6d" translate="yes" xml:space="preserve">
          <source>The initial/default value of the time-to-live setting is typically &lt;code&gt;1&lt;/code&gt;. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.</source>
          <target state="translated">유효 기간 설정의 초기 / 기본값은 일반적으로 &lt;code&gt;1&lt;/code&gt; 입니다. 구현에서는 소켓이 바인드 된 후이 소켓 옵션을 설정할 수 있습니다. 소켓을 바인딩하기 전에 소켓 옵션을 쿼리하거나 변경할 수 있는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f14681da9e2cf817ea3cfed63d4502d38744917" translate="yes" xml:space="preserve">
          <source>The initial/default value of this socket option is &lt;code&gt;TRUE&lt;/code&gt;. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.</source>
          <target state="translated">이 소켓 옵션의 초기 / 기본값은 &lt;code&gt;TRUE&lt;/code&gt; 입니다. 구현에서는 소켓이 바인드 된 후이 소켓 옵션을 설정할 수 있습니다. 소켓을 바인딩하기 전에 소켓 옵션을 쿼리하거나 변경할 수 있는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7a10bc1d584244ec597309a501f8537f0906aac2" translate="yes" xml:space="preserve">
          <source>The initial/default value of this socket option may be &lt;code&gt;null&lt;/code&gt; to indicate that outgoing interface will be selected by the operating system, typically based on the network routing tables. An implementation allows this socket option to be set after the socket is bound. Whether the socket option can be queried or changed prior to binding the socket is system dependent.</source>
          <target state="translated">이 소켓 옵션의 초기 값 / 기본값 은 네트워크 라우팅 테이블을 기반으로 운영 체제에서 발신 인터페이스를 선택 함을 나타 내기 위해 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 구현에서는 소켓이 바인드 된 후이 소켓 옵션을 설정할 수 있습니다. 소켓을 바인딩하기 전에 소켓 옵션을 쿼리하거나 변경할 수 있는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b9fedeff43c59d7b5dbcc75d3c74145f2e5a51f4" translate="yes" xml:space="preserve">
          <source>The input (via the &lt;code&gt;classfileBuffer&lt;/code&gt; parameter) to the first transformer is:</source>
          <target state="translated">첫 번째 변환기에 대한 입력 ( &lt;code&gt;classfileBuffer&lt;/code&gt; 매개 변수 를 통한 )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0353ae3109c30633907963c70d9936359968faf7" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).</source>
          <target state="translated">매개 변수 (MONDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-10 (5 일 전)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97cf88e493d8b44880901ab10ce09e76612bd97e" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).</source>
          <target state="translated">매개 변수 (MONDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-17 (2 일 후)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9bef351d0d747e19c535a278617e57a2452563ef" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).</source>
          <target state="translated">매개 변수 (SATURDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-08 (7 일 전)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="459e681c26aecf2f2ec743dc66e3693663f75fd5" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).</source>
          <target state="translated">매개 변수 (SATURDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-15 (입력과 동일)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fd71f4910bd3fe09f4a43f337e9282decd32cea5" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).</source>
          <target state="translated">매개 변수 (SATURDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-22 (7 일 후)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0efcc6067b189acef66d69c2de50d8589fa25cbf" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).</source>
          <target state="translated">매개 변수 (WEDNESDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-12 (3 일 전)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b80d3ce9751afa5ad36e2eb87a5ace0f63cba29" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).</source>
          <target state="translated">매개 변수 (WEDNESDAY)에 대한 2011-01-15 (토요일) 입력은 2011-01-19 (4 일 후)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7f73626e5956acb720a1570a8f4536e229179c28" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 will return 2011-01-01.</source>
          <target state="translated">2011-01-15 입력은 2011-01-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0124e9614f4487f35850bcf026ed566a4761b1d3" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 will return 2011-01-31.</source>
          <target state="translated">2011-01-15 입력은 2011-01-31을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ab919d34d3b479bb430190e4c37a22ea00323df" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 will return 2011-02-01.</source>
          <target state="translated">2011-01-15 입력은 2011-02-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40c59e3915752f42edd5a88ff72e759568a6189a" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 will return 2011-12-31.</source>
          <target state="translated">입력 2011-01-15는 2011-12-31을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="727c7b425fd65ecf52b229b890c5788c0dc30227" translate="yes" xml:space="preserve">
          <source>The input 2011-01-15 will return 2012-01-01.</source>
          <target state="translated">2011-01-15 입력은 2012-01-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c09e595a2bedd7bb1101024bc041b5b29e2d95e2" translate="yes" xml:space="preserve">
          <source>The input 2011-02-15 will return 2011-01-01.</source>
          <target state="translated">2011-02-15 입력은 2011-01-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5cc26e63ef17d6b476896380461bf4720673e59e" translate="yes" xml:space="preserve">
          <source>The input 2011-02-15 will return 2011-02-01.</source>
          <target state="translated">2011-02-15 입력은 2011-02-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bab49004e8b5e91474ec75a110529a798471e37" translate="yes" xml:space="preserve">
          <source>The input 2011-02-15 will return 2011-02-28.</source>
          <target state="translated">2011-02-15 입력은 2011-02-28을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6af6d6025b1ce4e1ae4e9a586de3fc7c32e1e4fe" translate="yes" xml:space="preserve">
          <source>The input 2011-02-15 will return 2011-03-01.</source>
          <target state="translated">2011-02-15 입력은 2011-03-01을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b043e7ffb342331a742f793366c7737a0d6e3fd" translate="yes" xml:space="preserve">
          <source>The input 2011-02-15 will return 2011-12-31.</source>
          <target state="translated">입력 2011-02-15는 2011-12-31을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c894c15b25c9be063955c487b0570699b1d5eab8" translate="yes" xml:space="preserve">
          <source>The input 2011-04-15 will return 2011-04-30.</source>
          <target state="translated">2011-04-15 입력은 2011-04-30을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="674c825d6c5d4d93b9ccdbda2b8b7895d7891b2a" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).</source>
          <target state="translated">(-1, TUESDAY)에 대한 2011-12-15 입력은 2011-12-27 (마지막 달)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f45c3e12c42281a12669c273ca00a557f31deb4e" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).</source>
          <target state="translated">(-4, TUESDAY)에 대한 2011-12-15 입력은 2011-12-06 (지난달 3 주 전)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e511359656fd86726c2553e964175b3339937510" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).</source>
          <target state="translated">(-5, TUESDAY)에 대한 2011-12-15 입력은 2011-11-29 (매달 마지막 4 주 전)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61f6b1886bb948c2d22a9f26dbaf718741f9d55f" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).</source>
          <target state="translated">(0, TUESDAY)에 대한 2011-12-15 입력은 2011-11-29 (이전 달 마지막)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7aa0d892978892f55b314a5cb46650cec948a67" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.</source>
          <target state="translated">(1, TUESDAY)에 대한 2011-12-15 입력은 2011-12-06을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08504b039b2c14ec9e3edb95f9f492e2689a26fe" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.</source>
          <target state="translated">(2, TUESDAY)에 대한 2011-12-15 입력은 2011-12-13을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="434481f6384a2e789c2579a256e032c2a65c242a" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.</source>
          <target state="translated">(3, TUESDAY)에 대한 2011-12-15 입력은 2011-12-20을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a82ae127fda436ed10390e170c5197b4b398e8a1" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.</source>
          <target state="translated">(4, TUESDAY)에 대한 2011-12-15 입력은 2011-12-27을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a711831c25339a45671c5ac67f113204cb02e01" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.</source>
          <target state="translated">(5, TUESDAY)에 대한 2011-12-15 입력은 2012-01-03을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c6eb26c15efb0ec8afeabaaa608820b693f2649" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (FRIDAY) will return 2011-12-02.</source>
          <target state="translated">(금요일)에 대한 2011-12-15 입력은 2011-12-02를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="567a413ddb1e838b7fa5d14dcbe912be2ae1fa62" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (FRIDAY) will return 2011-12-30.</source>
          <target state="translated">(금요일)에 대한 2011-12-15 입력은 2011-12-30을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e72c437ba8ad9a6ff2bc3eeff73507f67a633af" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (MONDAY) will return 2011-12-05.</source>
          <target state="translated">(월요일)에 대한 2011-12-15 입력은 2011-12-05를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d64c410b23535de8786153e85ed7090c36fe6d3d" translate="yes" xml:space="preserve">
          <source>The input 2011-12-15 for (MONDAY) will return 2011-12-26.</source>
          <target state="translated">(월요일)에 대한 2011-12-15 입력은 2011-12-26을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b914beb04279584398f5931bb837c143e20f3c7b" translate="yes" xml:space="preserve">
          <source>The input 2012-02-15 will return 2012-02-29 (leap year).</source>
          <target state="translated">입력 2012-02-15는 2012-02-29 (윤년)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="edb13fdec6e5487029f19ef469d2d4b7243b4fe9" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these expressions:</source>
          <target state="translated">예를 들어, 입력 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 표현식으로 다음과 같은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e76816c962ee6c820f09b31b57f2a819c6ee424e" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these parameters:</source>
          <target state="translated">예를 들어, 입력 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 매개 변수를 사용하여 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7fe0fa4d1613c22f20c32d6adf058d34e0d76640" translate="yes" xml:space="preserve">
          <source>The input byte sequence is provided in a byte buffer or a series of such buffers. The output character sequence is written to a character buffer or a series of such buffers. A decoder should always be used by making the following sequence of method invocations, hereinafter referred to as a</source>
          <target state="translated">입력 바이트 시퀀스는 바이트 버퍼 또는 일련의 이러한 버퍼로 제공됩니다. 출력 문자 시퀀스는 문자 버퍼 또는 일련의 이러한 버퍼에 기록됩니다. 디코더는 항상 다음과 같은 메소드 호출 시퀀스를 작성하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="19ef1842ed4e5eb52651c1849cddba210d1892ca" translate="yes" xml:space="preserve">
          <source>The input character sequence is provided in a character buffer or a series of such buffers. The output byte sequence is written to a byte buffer or a series of such buffers. An encoder should always be used by making the following sequence of method invocations, hereinafter referred to as an</source>
          <target state="translated">입력 문자 시퀀스는 문자 버퍼 또는 일련의 이러한 버퍼로 제공됩니다. 출력 바이트 시퀀스는 바이트 버퍼 또는 일련의 이러한 버퍼에 기록됩니다. 엔코더는 항상 다음과 같은 일련의 메소드 호출을 수행하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="83653305fe618a807c36ae9ff751ddeb894361e2" translate="yes" xml:space="preserve">
          <source>The input object must not be altered. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable temporal objects.</source>
          <target state="translated">입력 개체를 변경해서는 안됩니다. 대신 조정 된 원본을 반환해야합니다. 이것은 불변 및 변경 가능한 시간 객체에 대해 동등하고 안전한 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5c910580a21e4b944c3ab323f7cd8f43016d192b" translate="yes" xml:space="preserve">
          <source>The input set will be empty if the processor supports &lt;code&gt;&quot;*&quot;&lt;/code&gt; and the root elements have no annotations. A &lt;code&gt;Processor&lt;/code&gt; must gracefully handle an empty set of annotations.</source>
          <target state="translated">프로세서가 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 지원 하고 루트 요소에 주석이없는 경우 입력 세트가 비어 있습니다 . &lt;code&gt;Processor&lt;/code&gt; 정상적으로 주석의 빈 세트를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed552da2306d43fec33a5ddad4dd6d2b2ba78449" translate="yes" xml:space="preserve">
          <source>The input stream to be filtered.</source>
          <target state="translated">필터링 할 입력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="309bc11db643dd7e62cb11f361090715463174e8" translate="yes" xml:space="preserve">
          <source>The input string</source>
          <target state="translated">입력 문자열</target>
        </trans-unit>
        <trans-unit id="6ff27ced2c6ba8898b27209a9d944d8366a139de" translate="yes" xml:space="preserve">
          <source>The input temporal object may be in a calendar system other than ISO. Implementations may choose to document compatibility with other calendar systems, or reject non-ISO temporal objects by &lt;a href=&quot;temporalqueries#chronology--&quot;&gt;&lt;code&gt;querying the chronology&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 시간 객체는 ISO 이외의 캘린더 시스템에있을 수 있습니다. 구현은 다른 달력 시스템과의 호환성을 문서화하거나 &lt;a href=&quot;temporalqueries#chronology--&quot;&gt; &lt;code&gt;querying the chronology&lt;/code&gt; &lt;/a&gt; 를 쿼리하여 비 ISO 시간 객체를 거부하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="821545cbe636d66216bdce755849750bfe359d8c" translate="yes" xml:space="preserve">
          <source>The instance of the &lt;code&gt;BeanPersistenceDelegate&lt;/code&gt; class is returned for the &lt;code&gt;Bean&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;BeanPersistenceDelegate&lt;/code&gt; 클래스 의 인스턴스 는 &lt;code&gt;Bean&lt;/code&gt; 클래스에 대해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe35d64909d53ad3510a2a12bb002668399923b1" translate="yes" xml:space="preserve">
          <source>The instance registered in the platform &lt;code&gt;MBeanServer&lt;/code&gt; is also a &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt;&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플랫폼 &lt;code&gt;MBeanServer&lt;/code&gt; 에 등록 된 인스턴스 도 &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt; &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8034f1687833a6f8c4d1326d8592f90018f9b440" translate="yes" xml:space="preserve">
          <source>The instance registered in the platform &lt;code&gt;MBeanServer&lt;/code&gt; with this &lt;code&gt;ObjectName&lt;/code&gt; implements all attributes defined by &lt;a href=&quot;../../util/logging/loggingmxbean&quot;&gt;&lt;code&gt;LoggingMXBean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;ObjectName&lt;/code&gt; 으로 플랫폼 &lt;code&gt;MBeanServer&lt;/code&gt; 에 등록 된 인스턴스 는 &lt;a href=&quot;../../util/logging/loggingmxbean&quot;&gt; &lt;code&gt;LoggingMXBean&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 모든 속성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d1fbeab41e2aa5267a94fe378603af36274b8722" translate="yes" xml:space="preserve">
          <source>The instant epoch-seconds.</source>
          <target state="translated">즉각적인 시대.</target>
        </trans-unit>
        <trans-unit id="7901aafd15bf23c3b39d73b5e02e372acef541aa" translate="yes" xml:space="preserve">
          <source>The instant is obtained using &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; and optionally (@code NANO_OF_SECOND). The value of &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; may be outside the maximum range of &lt;code&gt;LocalDateTime&lt;/code&gt;.</source>
          <target state="translated">인스턴트는 &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 및 선택적으로 (@code NANO_OF_SECOND)를 사용하여 얻습니다 . &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 값이 최대 &lt;code&gt;LocalDateTime&lt;/code&gt; 범위 를 벗어날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30129dac0e1c5b07ebec910099af96e81c4f9dd8" translate="yes" xml:space="preserve">
          <source>The instantiateChild method is a convenience hook in BeanContext to simplify the task of instantiating a Bean, nested, into a &lt;code&gt;BeanContext&lt;/code&gt;.</source>
          <target state="translated">instantiateChild 메소드는 상자로 콩, 인스턴스의 작업을 단순화하는 BeanContext의 간이 훅입니다 &lt;code&gt;BeanContext&lt;/code&gt; 의를 .</target>
        </trans-unit>
        <trans-unit id="f77c078c5f9aeaf66bf15d02253d245e615ac88d" translate="yes" xml:space="preserve">
          <source>The instrument must be part of a soundbank that this &lt;code&gt;Synthesizer&lt;/code&gt; supports. (To make sure, you can use the &lt;code&gt;getSoundbank&lt;/code&gt; method of &lt;code&gt;Instrument&lt;/code&gt; and the &lt;code&gt;isSoundbankSupported&lt;/code&gt; method of &lt;code&gt;Synthesizer&lt;/code&gt;.)</source>
          <target state="translated">악기는이 &lt;code&gt;Synthesizer&lt;/code&gt; 지원 하는 사운드 뱅크의 일부 여야 합니다. (확실히하기 위해 &lt;code&gt;Instrument&lt;/code&gt; 의 &lt;code&gt;getSoundbank&lt;/code&gt; 메소드 와 &lt;code&gt;Synthesizer&lt;/code&gt; 의 &lt;code&gt;isSoundbankSupported&lt;/code&gt; 메소드를 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="9a37a2eb226e14bcfb598f5019503fb1c263149a" translate="yes" xml:space="preserve">
          <source>The int at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에있는 int</target>
        </trans-unit>
        <trans-unit id="f399009c35348dad1f9b984754bb8ad44cf2f1fa" translate="yes" xml:space="preserve">
          <source>The int at the given index</source>
          <target state="translated">주어진 인덱스의 int</target>
        </trans-unit>
        <trans-unit id="cd5bd83985b7ab506a14fd7d1fe1f37e7e280658" translate="yes" xml:space="preserve">
          <source>The int value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치의 int 값</target>
        </trans-unit>
        <trans-unit id="1ad78d2b15738eeaffcdd43ad90d8ea023e56b29" translate="yes" xml:space="preserve">
          <source>The int value at the given index</source>
          <target state="translated">주어진 인덱스의 int 값</target>
        </trans-unit>
        <trans-unit id="5853f3fa53f15931c8c19c152516c6b810652678" translate="yes" xml:space="preserve">
          <source>The integer part of &lt;code&gt;this / divisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this / divisor&lt;/code&gt; 의 정수 부분 .</target>
        </trans-unit>
        <trans-unit id="7b3962a31770a8a1a3dd88816d3e71b6159a620d" translate="yes" xml:space="preserve">
          <source>The intention is to allow developers to turn on voluminous logging, but to limit the messages that are sent to certain &lt;code&gt;Handlers&lt;/code&gt;.</source>
          <target state="translated">개발자가 대량 로깅을 켤 수 있지만 특정 &lt;code&gt;Handlers&lt;/code&gt; 로 전송되는 메시지를 제한하는 것이 목적 입니다.</target>
        </trans-unit>
        <trans-unit id="7ae57ebccdbb22db556eaf3cff8f99142d9c282e" translate="yes" xml:space="preserve">
          <source>The interactions of &lt;code&gt;getTarget&lt;/code&gt; with memory are the same as of a read from a &lt;code&gt;volatile&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;getTarget&lt;/code&gt; 과 메모리 의 상호 작용은 &lt;code&gt;volatile&lt;/code&gt; 필드 에서 읽은 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e26c912cdad75eed02864256ebb606789bb54554" translate="yes" xml:space="preserve">
          <source>The interactions of &lt;code&gt;getTarget&lt;/code&gt; with memory are the same as of a read from an ordinary variable, such as an array element or a non-volatile, non-final field.</source>
          <target state="translated">&lt;code&gt;getTarget&lt;/code&gt; 과 메모리 의 상호 작용은 배열 요소 또는 비 휘발성, 최종 필드와 같은 일반 변수에서 읽은 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dbd4770385ec4ef685776fb36c773c630df22d7a" translate="yes" xml:space="preserve">
          <source>The interactions with memory are the same as of a write to a volatile field. In particular, any threads is guaranteed to see the updated target the next time it calls &lt;code&gt;getTarget&lt;/code&gt;.</source>
          <target state="translated">메모리와의 상호 작용은 휘발성 필드에 쓰는 것과 동일합니다. 특히, 모든 스레드는 다음에 &lt;code&gt;getTarget&lt;/code&gt; 을 호출 할 때 업데이트 된 대상을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52462e55d1986519fb9c0c7702ec405729f552d" translate="yes" xml:space="preserve">
          <source>The interactions with memory are the same as of a write to an ordinary variable, such as an array element or a non-volatile, non-final field.</source>
          <target state="translated">메모리와의 상호 작용은 배열 요소 또는 비 휘발성 비 최종 필드와 같은 일반 변수에 쓰는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="014408c9d911a7844a8b809c1365a12d70d22469" translate="yes" xml:space="preserve">
          <source>The interface for an annotation processor.</source>
          <target state="translated">주석 처리기의 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b4d2d968b034bed958f5e02e5377b1b7679e8e20" translate="yes" xml:space="preserve">
          <source>The interface must be public. No additional access checks are performed.</source>
          <target state="translated">인터페이스는 공용이어야합니다. 추가 액세스 확인이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b83e5587b5e3268f7bd3121d72946c5268c5087e" translate="yes" xml:space="preserve">
          <source>The interface to a DSA public key.</source>
          <target state="translated">DSA 공개 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9ed25013cc4c4ff6dfb08741855f976f636b0905" translate="yes" xml:space="preserve">
          <source>The interface to a DSA public key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA 공개 키에 대한 인터페이스입니다. DSA (Digital Signature Algorithm)는 NIST의 FIPS-186에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="463dbbe10e7a119d6739cd125d3ac314683f9e4d" translate="yes" xml:space="preserve">
          <source>The interface to a DSA public or private key.</source>
          <target state="translated">DSA 공개 또는 개인 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="044208746fb44cc724fe5c2f514ca19e29568745" translate="yes" xml:space="preserve">
          <source>The interface to a DSA public or private key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA 공개 또는 개인 키에 대한 인터페이스입니다. DSA (Digital Signature Algorithm)는 NIST의 FIPS-186에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="adefbd72188ceac085b3c4a9f4be42b94848b3ce" translate="yes" xml:space="preserve">
          <source>The interface to a Diffie-Hellman key.</source>
          <target state="translated">Diffie-Hellman 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0e7434107d0fa07c24f0a582e03af6e48009d021" translate="yes" xml:space="preserve">
          <source>The interface to a Diffie-Hellman private key.</source>
          <target state="translated">Diffie-Hellman 개인 키에 대한 인터페이스입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
