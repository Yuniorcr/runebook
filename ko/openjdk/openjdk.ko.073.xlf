<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="e982851c7c5c4136cdaa4ba7b98867e7e1d69a54" translate="yes" xml:space="preserve">
          <source>This is useful in the case where a random IV was created, or in the context of password-based encryption or decryption, where the IV is derived from a user-supplied password.</source>
          <target state="translated">이는 무작위 IV가 생성 된 경우 또는 IV가 사용자 제공 암호에서 파생 된 암호 기반 암호화 또는 암호 해독의 컨텍스트에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e2535746cccdbbca1ab930ed4fcdb0c529016428" translate="yes" xml:space="preserve">
          <source>This is useful in the context of password-based encryption or decryption, where the IV is derived from a user-provided passphrase.</source>
          <target state="translated">이것은 암호 기반 암호화 또는 암호 해독의 컨텍스트에서 유용합니다. IV는 사용자가 제공 한 암호에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="9cf54f5c44b9b05526dc556c0af31e68f521cdb6" translate="yes" xml:space="preserve">
          <source>This is where MXBeans differ from Standard MBeans. Although we define the management interface in almost exactly the same way, the MXBean framework &lt;em&gt;converts&lt;/em&gt; model-specific classes into standard classes from the Java platform. Using arrays and the &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;openmbean/tabulardata&quot;&gt;&lt;code&gt;TabularData&lt;/code&gt;&lt;/a&gt; classes from the standard &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt; package, it is possible to build data structures of arbitrary complexity using only standard classes.</source>
          <target state="translated">MXBean과 표준 MBean이 다른 곳입니다. 거의 동일한 방식으로 관리 인터페이스를 정의하지만 MXBean 프레임 워크 &lt;em&gt;는&lt;/em&gt; 모델 별 클래스를 Java 플랫폼에서 표준 클래스로 &lt;em&gt;변환&lt;/em&gt; 합니다. 표준 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; &lt;/a&gt; 패키지의 배열과 &lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;openmbean/tabulardata&quot;&gt; &lt;code&gt;TabularData&lt;/code&gt; &lt;/a&gt; 클래스를 사용하면 표준 클래스 만 사용하여 임의의 복잡한 데이터 구조를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151df2660c7d755c42534037d205d93fbee51de1" translate="yes" xml:space="preserve">
          <source>This iterator iterates over a sequence of collation elements that were built from the string. Because there isn't necessarily a one-to-one mapping from characters to collation elements, this doesn't mean the same thing as &quot;return the collation element [or ordering priority] of the next character in the string&quot;.</source>
          <target state="translated">이 반복자는 문자열에서 만들어진 일련의 데이터 정렬 요소를 반복합니다. 문자에서 데이터 정렬 요소로의 일대일 맵핑이 반드시 필요한 것은 아니기 때문에 &quot;문자열에서 다음 문자의 데이터 정렬 요소 (또는 순서 우선 순위)를 리턴&quot;과 동일한 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd4de962aa64b9c7d9a0ab672023e53024308e67" translate="yes" xml:space="preserve">
          <source>This iterator iterates over a sequence of collation elements that were built from the string. Because there isn't necessarily a one-to-one mapping from characters to collation elements, this doesn't mean the same thing as &quot;return the collation element [or ordering priority] of the previous character in the string&quot;.</source>
          <target state="translated">이 반복자는 문자열에서 만들어진 일련의 데이터 정렬 요소를 반복합니다. 문자에서 데이터 정렬 요소로의 일대일 맵핑이 반드시 필요한 것은 아니기 때문에 &quot;문자열에서 이전 문자의 데이터 정렬 요소 (또는 순서 우선 순위)를 리턴&quot;과 동일한 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8df0ad3bbb219e858791d7f90e24949d640b25d9" translate="yes" xml:space="preserve">
          <source>This job K octets attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 K octets 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="d940bed118346ee64706ad2f7d87e1ab7995a09d" translate="yes" xml:space="preserve">
          <source>This job K octets processed attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 K octets 처리 된 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f65bbab161b42056574e749ee8d56462819b331" translate="yes" xml:space="preserve">
          <source>This job K octets supported attribute's members and &lt;code&gt;object&lt;/code&gt;'s members are the same.</source>
          <target state="translated">이 작업 K octets 지원되는 속성의 멤버와 &lt;code&gt;object&lt;/code&gt; 의 멤버는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="172b8f5af9b5cdedc44a30285eeb85b93f0b0cb8" translate="yes" xml:space="preserve">
          <source>This job hold until attribute's &lt;a href=&quot;../../../../java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; value and &lt;code&gt;object&lt;/code&gt;'s &lt;a href=&quot;../../../../java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; value are equal.</source>
          <target state="translated">이 작업은 속성의 &lt;a href=&quot;../../../../java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 값과 &lt;code&gt;object&lt;/code&gt; 의 &lt;a href=&quot;../../../../java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 값이 같아 질 때까지 보류 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae1c3b0410efd951e802d6b4307d1b876418adf" translate="yes" xml:space="preserve">
          <source>This job impressions attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 노출 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="827ef65f7ef707c073e8c41d3ef72aa77843b894" translate="yes" xml:space="preserve">
          <source>This job impressions completed attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 노출 완료 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6139b149f601585bc21d4753f1e2e0c7d403119" translate="yes" xml:space="preserve">
          <source>This job impressions supported attribute's members and &lt;code&gt;object&lt;/code&gt;'s members are the same.</source>
          <target state="translated">이 작업 노출 지원 속성의 구성원과 &lt;code&gt;object&lt;/code&gt; 의 구성원이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6be0f8fe2fb5cb41ae59c02f23e0143618bcf3fa" translate="yes" xml:space="preserve">
          <source>This job is retained and is currently able to be restarted. If JOB_RESTARTABLE is contained in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, then the printer must accept a request to restart that job. This value should be supported if restarting jobs is supported.</source>
          <target state="translated">이 작업은 유지되며 현재 다시 시작할 수 있습니다. JOB_RESTARTABLE이 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 포함 된 경우 프린터는 해당 작업을 다시 시작하라는 요청을 수락해야합니다. 작업 재시작이 지원되는 경우이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="838273e4d4c3afa680e7aa83ec4385dfa9583961" translate="yes" xml:space="preserve">
          <source>This job media sheets attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 매체 시트 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="de3deada5978343c7ae28bc382eaaa4eb7708954" translate="yes" xml:space="preserve">
          <source>This job media sheets completed attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 매체 시트 완료 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="3afb14ae1e4acf07802173b3536b7644e4debc03" translate="yes" xml:space="preserve">
          <source>This job media sheets supported attribute's members and &lt;code&gt;object&lt;/code&gt;'s members are the same.</source>
          <target state="translated">지원되는이 작업 매체 시트 속성의 구성원과 &lt;code&gt;object&lt;/code&gt; 의 구성원이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8a08e608bc977b9b4c6038b4fce830163c750672" translate="yes" xml:space="preserve">
          <source>This job message from operator attribute's locale and &lt;code&gt;object&lt;/code&gt;'s locale are equal.</source>
          <target state="translated">운영자 속성의 로케일 및 &lt;code&gt;object&lt;/code&gt; 로케일의이 작업 메시지 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f81935108ca14648fd5fad2a9b90d65078401d36" translate="yes" xml:space="preserve">
          <source>This job message from operator attribute's underlying string and &lt;code&gt;object&lt;/code&gt;'s underlying string are equal.</source>
          <target state="translated">운영자 속성의 기본 문자열과 &lt;code&gt;object&lt;/code&gt; 의 기본 문자열에서이 작업 메시지 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8573b3ffcede7e8f93e17d6c8fa2e94259da36e3" translate="yes" xml:space="preserve">
          <source>This job name attribute's locale and &lt;code&gt;object&lt;/code&gt;'s locale are equal.</source>
          <target state="translated">이 작업 이름 속성의 로케일과 &lt;code&gt;object&lt;/code&gt; 의 로케일이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0cfe10df41cbc7462d16efc16bfb69a3ecea7ed1" translate="yes" xml:space="preserve">
          <source>This job name attribute's underlying string and &lt;code&gt;object&lt;/code&gt;'s underlying string are equal.</source>
          <target state="translated">이 작업 이름 속성의 기본 문자열과 &lt;code&gt;object&lt;/code&gt; 의 기본 문자열이 같습니다.</target>
        </trans-unit>
        <trans-unit id="220af8d7a532aa9546a31fa0bbdde8d8f26c2ba7" translate="yes" xml:space="preserve">
          <source>This job originating user name attribute's locale and &lt;code&gt;object&lt;/code&gt;'s locale are equal.</source>
          <target state="translated">이 작업 시작 사용자 이름 속성의 로케일과 &lt;code&gt;object&lt;/code&gt; 의 로케일이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1a933d56df8aa13ad4b227fc833465d27d5a99ef" translate="yes" xml:space="preserve">
          <source>This job originating user name attribute's underlying string and &lt;code&gt;object&lt;/code&gt;'s underlying string are equal.</source>
          <target state="translated">이 작업 시작 사용자 이름 속성의 기본 문자열과 &lt;code&gt;object&lt;/code&gt; 의 기본 문자열이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="acec6d0fcdfe71ac2627f8c9ce9ce5d904d8207b" translate="yes" xml:space="preserve">
          <source>This job priority attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 우선 순위 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="d30066dbd2bd1b6a5282fdcccde9d53715f165f6" translate="yes" xml:space="preserve">
          <source>This job priority supported attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 작업 우선 순위 지원 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="d08bff79d7efea86b07bb2462680f681632d9396" translate="yes" xml:space="preserve">
          <source>This key's channel</source>
          <target state="translated">이 키의 채널</target>
        </trans-unit>
        <trans-unit id="c9ff12ff91ae98cc554261912b7101e293f6eae9" translate="yes" xml:space="preserve">
          <source>This key's interest set</source>
          <target state="translated">이 키의 관심사</target>
        </trans-unit>
        <trans-unit id="484578ab393992ca6b35a256c926024ac4dc1ee9" translate="yes" xml:space="preserve">
          <source>This key's ready-operation set</source>
          <target state="translated">이 키의 준비된 작동 세트</target>
        </trans-unit>
        <trans-unit id="2bd50f3229021f6ed4b5ed6fc741de067a259d3f" translate="yes" xml:space="preserve">
          <source>This key's selector</source>
          <target state="translated">이 키의 선택기</target>
        </trans-unit>
        <trans-unit id="73baf2dac208aeeefd239b512ce83c57bf5fb818" translate="yes" xml:space="preserve">
          <source>This language model follows a</source>
          <target state="translated">이 언어 모델은</target>
        </trans-unit>
        <trans-unit id="4c2c3e90746d07e042f7de1d3edae0977de2cab2" translate="yes" xml:space="preserve">
          <source>This leniency value is overwritten by a call to &lt;a href=&quot;dateformat#setCalendar-java.util.Calendar-&quot;&gt;&lt;code&gt;setCalendar()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 leniency 값은 &lt;a href=&quot;dateformat#setCalendar-java.util.Calendar-&quot;&gt; &lt;code&gt;setCalendar()&lt;/code&gt; &lt;/a&gt; 호출로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9976da2e9bb71e18b5f5ad51885abc1487df76aa" translate="yes" xml:space="preserve">
          <source>This list must be modifiable, but need not be resizable.</source>
          <target state="translated">이 목록은 수정 가능해야하지만 크기를 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae4f32d527341dc4907dea7f8ce1ed40f9011233" translate="yes" xml:space="preserve">
          <source>This loads the rules for the specified zone ID. The provider implementation must validate that the zone ID is valid and available, throwing a &lt;code&gt;ZoneRulesException&lt;/code&gt; if it is not. The result of the method in the valid case depends on the caching flag.</source>
          <target state="translated">지정된 영역 ID에 대한 규칙을로드합니다. 제공자 구현은 영역 ID가 유효하고 사용 가능한지 유효성을 검증해야하며 &lt;code&gt;ZoneRulesException&lt;/code&gt; 않은 경우 ZoneRulesException을 발생 시킵니다 . 유효한 경우 메소드의 결과는 캐싱 플래그에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="39fc7580f18990809098420829cd6895c80668b4" translate="yes" xml:space="preserve">
          <source>This lock allows both readers and writers to reacquire read or write locks in the style of a &lt;a href=&quot;reentrantlock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt;. Non-reentrant readers are not allowed until all write locks held by the writing thread have been released.</source>
          <target state="translated">이 잠금을 사용하면 리더와 작성자가 &lt;a href=&quot;reentrantlock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;/a&gt; 스타일의 읽기 또는 쓰기 잠금을 다시 획득 할 수 있습니다 . 쓰기 스레드가 보유한 모든 쓰기 잠금이 해제 될 때까지 재진입 할 ​​수없는 판독기는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f17de85a2537643f6e3bf98800bfe94fe213e92" translate="yes" xml:space="preserve">
          <source>This lock supports a maximum of 2147483647 recursive locks by the same thread. Attempts to exceed this limit result in &lt;a href=&quot;../../../lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; throws from locking methods.</source>
          <target state="translated">이 잠금은 동일한 스레드에서 최대 2147483647 재귀 잠금을 지원합니다. 이 한계를 초과하면 잠금 메소드 에서 &lt;a href=&quot;../../../lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8a9c4c5c4bd80a6e77a206482c5c4028f099b12" translate="yes" xml:space="preserve">
          <source>This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in &lt;a href=&quot;../../../lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; throws from locking methods.</source>
          <target state="translated">이 잠금은 최대 65535 재귀 쓰기 잠금 및 65535 읽기 잠금을 지원합니다. 이러한 한계를 초과하면 잠금 방법 에서 &lt;a href=&quot;../../../lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5f0ec25fdf5dc877766df703b934928f678dda94" translate="yes" xml:space="preserve">
          <source>This makes it possible for a MBeanServer implementation to wrap another MBeanServer implementation, in order to implement, e.g, security checks, or to prevent access to the actual MBeanServer implementation by returning a pointer to a wrapping object.</source>
          <target state="translated">이것에 의해, MBeanServer 구현은, 예를 들어 시큐리티 체크를 구현하거나 랩핑 객체에의 포인터를 돌려 실제의 MBeanServer 구현에의 액세스를 막기 위해서 다른 MBeanServer 구현을 랩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad52a127b76c9d66c4665870a7f2db773ae8df39" translate="yes" xml:space="preserve">
          <source>This makes it possible to decouple configuration from KeyStore object creation and e.g. delay a password prompt until it is needed.</source>
          <target state="translated">이를 통해 KeyStore 객체 생성과 구성을 분리 할 수 ​​있으며 필요할 때까지 비밀번호 프롬프트를 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c6eed4b0728c771888a382dcda28f5cacc2ab26" translate="yes" xml:space="preserve">
          <source>This manageable usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead. Usage threshold may not be appropriate for some memory pools. For example, a generational garbage collector, a common garbage collection algorithm used in many Java virtual machine implementations, manages two or more generations segregating objects by age. Most of the objects are allocated in the &lt;em&gt;youngest generation&lt;/em&gt; (say a nursery memory pool). The nursery memory pool is designed to be filled up and collecting the nursery memory pool will free most of its memory space since it is expected to contain mostly short-lived objects and mostly are unreachable at garbage collection time. In this case, it is more appropriate for the nursery memory pool not to support a usage threshold. In addition, if the cost of an object allocation in one memory pool is very low (for example, just atomic pointer exchange), the Java virtual machine would probably not support the usage threshold for that memory pool since the overhead in comparing the usage with the threshold is higher than the cost of object allocation.</source>
          <target state="translated">이 관리 가능한 사용 임계 값 속성은 낮은 오버 헤드로 증가하는 메모리 사용 추세를 모니터링하기 위해 설계되었습니다. 일부 메모리 풀에는 사용 임계 값이 적절하지 않을 수 있습니다. 예를 들어, 많은 Java 가상 머신 구현에 사용되는 공통 가비지 콜렉션 알고리즘 인 세대 가비지 콜렉터는 연령별로 오브젝트를 분리하는 둘 이상의 세대를 관리합니다. 대부분의 객체는 &lt;em&gt;가장 어린 세대에&lt;/em&gt; 할당됩니다&lt;em&gt;&lt;/em&gt;(보육실 메모리 풀). 보육 메모리 풀은 채워지도록 설계되었으며 보육 메모리 풀을 수집하면 대부분 수명이 짧은 오브젝트를 포함하고 가비지 콜렉션 시간에 도달 할 수 없기 때문에 대부분의 메모리 공간을 비 웁니다. 이 경우, 보육 메모리 풀이 사용 임계 값을 지원하지 않는 것이 더 적절합니다. 또한 하나의 메모리 풀에서 객체 할당 비용이 매우 낮은 경우 (예 : 원자 포인터 교환) Java 가상 머신은 사용량을 비교하는 오버 헤드 때문에 해당 메모리 풀의 사용량 임계 값을 지원하지 않을 수 있습니다. 임계 값은 오브젝트 할당 비용보다 높습니다.</target>
        </trans-unit>
        <trans-unit id="35481535999e219226ed7260bb8d577155df60a6" translate="yes" xml:space="preserve">
          <source>This mandatory attribute specifies one or more &lt;code&gt;.jar&lt;/code&gt; files containing MBeans or other resources used by the MBean to be obtained. One of the &lt;code&gt;.jar&lt;/code&gt; files must contain the file specified by the &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;OBJECT&lt;/code&gt; attribute. If archivelist contains more than one file:</source>
          <target state="translated">이 필수 속성은 MBean 또는 확보 할 MBean에서 사용하는 기타 자원을 포함하는 하나 이상의 &lt;code&gt;.jar&lt;/code&gt; 파일을 지정합니다 . &lt;code&gt;.jar&lt;/code&gt; 파일 중 하나는 &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;OBJECT&lt;/code&gt; 속성으로 지정된 파일을 포함해야합니다 . archivelist에 둘 이상의 파일이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="f5524cba1eecadcebc8c35911aae88ca196ee038" translate="yes" xml:space="preserve">
          <source>This map contains a mapping of the IDs that is in line with TZDB 2005r and later, where 'EST', 'MST' and 'HST' map to IDs which do not include daylight savings.</source>
          <target state="translated">이 맵에는 TZDB 2005r 이상과 일치하는 ID의 맵핑이 포함되어 있습니다. 여기서 'EST', 'MST'및 'HST'는 일광 절약 시간이 포함되지 않은 ID에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="911207d2c588140463ecb8b52de79e69fce22112" translate="yes" xml:space="preserve">
          <source>This maps as follows:</source>
          <target state="translated">이것은 다음과 같이 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a13882774a3d179decff4a601406ffbfefc228" translate="yes" xml:space="preserve">
          <source>This matcher</source>
          <target state="translated">이 매처</target>
        </trans-unit>
        <trans-unit id="a9b4a4dab6a1c51f10cbe63188a2e2e3478a17cb" translate="yes" xml:space="preserve">
          <source>This may change the behavior or disable execution of other parts of the program. If a provider subsequently requested by the program has been removed, execution may fail. Also, if the removed provider is not explicitly requested by the rest of the program, but it would normally be the provider chosen when a cryptography service is requested (due to its previous order in the list of providers), a different provider will be chosen instead, or no suitable provider will be found, thereby resulting in program failure.</source>
          <target state="translated">이로 인해 동작이 변경되거나 프로그램의 다른 부분이 실행되지 않을 수 있습니다. 이후에 프로그램에서 요청한 공급자가 제거 된 경우 실행이 실패 할 수 있습니다. 또한 제거 된 공급자가 프로그램의 나머지 부분에서 명시 적으로 요청되지 않지만 암호화 서비스가 요청 될 때 (제공자 목록의 이전 순서로 인해) 일반적으로 선택되는 공급자 인 경우 다른 공급자가 선택됩니다. 대신 적절한 공급자를 찾지 못해 프로그램이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cf34dce9122aca3b2ff13e553ac77235975bd1d1" translate="yes" xml:space="preserve">
          <source>This may include making use of any preferences API that is available as part of the Java or native platform. This algorithm may be overridden by a user setting the property javax.print.defaultPrinter. A service specified must be discovered to be valid and currently available to be returned as the default.</source>
          <target state="translated">여기에는 Java 또는 기본 플랫폼의 일부로 사용 가능한 환경 설정 API를 사용하는 것이 포함될 수 있습니다. 이 알고리즘은 사용자가 javax.print.defaultPrinter 특성을 설정하여 대체 할 수 있습니다. 지정된 서비스가 유효하고 현재 기본값으로 리턴 될 수 있음을 발견해야합니다.</target>
        </trans-unit>
        <trans-unit id="2eb64e6727cd33a0bb000ac74e42189ae9a791c4" translate="yes" xml:space="preserve">
          <source>This may return a &lt;code&gt;NumberFormat&lt;/code&gt; instance with the Thai numbering system, instead of the Latin numbering system.</source>
          <target state="translated">라틴어 번호 시스템 대신 태국어 번호 시스템을 사용 하여 &lt;code&gt;NumberFormat&lt;/code&gt; 인스턴스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a1de890dcb2dc4d84e3222192853c0d1e45fd8" translate="yes" xml:space="preserve">
          <source>This means a minimum of 2 integer digits, 1 fraction digit, and a maximum of 2 fraction digits.</source>
          <target state="translated">이는 최소 2 자리 정수, 1 자리, 최대 2 자리를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a91841d75e767a08d26a9cbfb4237550b49254a5" translate="yes" xml:space="preserve">
          <source>This means:</source>
          <target state="translated">이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="175c122d043e36e6f1bd35d5db17f5a3f55b8e3d" translate="yes" xml:space="preserve">
          <source>This mechanism may be used to obtain &lt;code&gt;ImageReaders&lt;/code&gt; that will generated non-pixel meta-data (see &lt;code&gt;IIOExtraDataInfo&lt;/code&gt;) in a structure understood by an &lt;code&gt;ImageWriter&lt;/code&gt;. By reading the image and obtaining this data from one of the &lt;code&gt;ImageReaders&lt;/code&gt; obtained with this method and passing it on to the &lt;code&gt;ImageWriter&lt;/code&gt;, a client program can read an image, modify it in some way, and write it back out preserving all meta-data, without having to understand anything about the internal structure of the meta-data, or even about the image format.</source>
          <target state="translated">이 메커니즘은 &lt;code&gt;ImageWriter&lt;/code&gt; 가 이해하는 구조에서 비 픽셀 메타 데이터 ( &lt;code&gt;IIOExtraDataInfo&lt;/code&gt; 참조 )를 생성하는 &lt;code&gt;ImageReaders&lt;/code&gt; 를 얻는 데 사용될 수 있습니다 . 클라이언트 프로그램은 이 메소드로 얻은 &lt;code&gt;ImageReaders&lt;/code&gt; 중 하나 에서 이미지를 읽고이 데이터를 가져와 &lt;code&gt;ImageWriter&lt;/code&gt; 로 전달 함으로써 이미지를 읽고 어떤 방식 으로든 수정 한 후 모든 메타 데이터를 보존하여 다시 쓸 수 있습니다. 메타 데이터의 내부 구조 나 이미지 형식에 대해 전혀 이해할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9477ec011ccc6cd62b18edb4a3330853eab03d19" translate="yes" xml:space="preserve">
          <source>This mechanism may be used to obtain &lt;code&gt;ImageWriters&lt;/code&gt; that will understand the internal structure of non-pixel meta-data (see &lt;code&gt;IIOTreeInfo&lt;/code&gt;) generated by an &lt;code&gt;ImageReader&lt;/code&gt;. By obtaining this data from the &lt;code&gt;ImageReader&lt;/code&gt; and passing it on to one of the &lt;code&gt;ImageWriters&lt;/code&gt; obtained with this method, a client program can read an image, modify it in some way, and write it back out while preserving all meta-data, without having to understand anything about the internal structure of the meta-data, or even about the image format.</source>
          <target state="translated">이 메커니즘은 &lt;code&gt;ImageReader&lt;/code&gt; 에 의해 생성 된 비 픽셀 메타 데이터 ( &lt;code&gt;IIOTreeInfo&lt;/code&gt; 참조 ) 의 내부 구조를 이해하는 &lt;code&gt;ImageWriters&lt;/code&gt; 를 얻는 데 사용될 수 있습니다 . 클라이언트 프로그램은 &lt;code&gt;ImageReader&lt;/code&gt; 에서이 데이터를 가져 &lt;code&gt;ImageWriters&lt;/code&gt; 방법으로 얻은 ImageWriter 중 하나로 전달 함으로써 이미지를 읽고 어떤 방식 으로든 수정 한 후 모든 메타 데이터를 보존하면서 다시 쓸 수 있습니다. 메타 데이터의 내부 구조 또는 이미지 형식에 대해 이해합니다.</target>
        </trans-unit>
        <trans-unit id="fff14e76e51b02ad662012f54442a58e001ebfca" translate="yes" xml:space="preserve">
          <source>This media size attribute's X dimension is equal to &lt;code&gt;object&lt;/code&gt;'s X dimension.</source>
          <target state="translated">이 미디어 크기 속성의 X 차원은 &lt;code&gt;object&lt;/code&gt; 의 X 차원과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2d5678d6bc3b126d851653c58af1c418b754a3c4" translate="yes" xml:space="preserve">
          <source>This media size attribute's Y dimension is equal to &lt;code&gt;object&lt;/code&gt;'s Y dimension.</source>
          <target state="translated">이 미디어 크기 속성의 Y 치수는 &lt;code&gt;object&lt;/code&gt; 의 Y 치수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ea82da6b140a0e965f6a617a910099dd753b8f82" translate="yes" xml:space="preserve">
          <source>This membership key</source>
          <target state="translated">이 멤버쉽 키</target>
        </trans-unit>
        <trans-unit id="4e4d250127621f81a309496eef97f9c17361e687" translate="yes" xml:space="preserve">
          <source>This message may be either the final text or a localization key.</source>
          <target state="translated">이 메시지는 최종 텍스트이거나 현지화 키일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1add261afe876410ef3a22a8c296c2d87752408e" translate="yes" xml:space="preserve">
          <source>This method (which varies in argument types across different classes) atomically sets a variable to the &lt;code&gt;updateValue&lt;/code&gt; if it currently holds the &lt;code&gt;expectedValue&lt;/code&gt;, reporting &lt;code&gt;true&lt;/code&gt; on success. The classes in this package also contain methods to get and unconditionally set values, as well as a weaker conditional atomic update operation &lt;code&gt;weakCompareAndSet&lt;/code&gt; described below.</source>
          <target state="translated">(클래스가 다르면 인수의 형태도 다르다)이 방법은 원자 적으로 변수 설정 &lt;code&gt;updateValue&lt;/code&gt; 에를 가 현재 보유하고있는 경우 &lt;code&gt;expectedValue&lt;/code&gt; 를을 보고, &lt;code&gt;true&lt;/code&gt; 성공. 이 패키지의 클래스에는 아래에 설명 된 약한 조건부 원자 업데이트 작업 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 뿐만 아니라 값을 가져오고 무조건 설정하는 메소드도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="676abcf10cf3f6ca400c78527f174dc0cfff75a2" translate="yes" xml:space="preserve">
          <source>This method &lt;em&gt;does not&lt;/em&gt; close the provided &lt;code&gt;ImageOutputStream&lt;/code&gt; after the write operation has completed; it is the responsibility of the caller to close the stream, if desired.</source>
          <target state="translated">이 메소드 &lt;em&gt;는&lt;/em&gt; 쓰기 작업이 완료된 후 제공된 &lt;code&gt;ImageOutputStream&lt;/code&gt; 을 닫지 &lt;em&gt;않습니다&lt;/em&gt; . 원하는 경우 스트림을 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3aa6518e55bff6393254c8f4353f326d6df08b81" translate="yes" xml:space="preserve">
          <source>This method &lt;em&gt;does not&lt;/em&gt; close the provided &lt;code&gt;InputStream&lt;/code&gt; after the read operation has completed; it is the responsibility of the caller to close the stream, if desired.</source>
          <target state="translated">이 메소드 &lt;em&gt;는&lt;/em&gt; 읽기 조작이 완료된 후 제공된 &lt;code&gt;InputStream&lt;/code&gt; 을 닫지 &lt;em&gt;않습니다&lt;/em&gt; . 원하는 경우 스트림을 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="173872128eb75c92df9c4eedf694b762d8282c0d" translate="yes" xml:space="preserve">
          <source>This method &lt;em&gt;does not&lt;/em&gt; close the provided &lt;code&gt;OutputStream&lt;/code&gt; after the write operation has completed; it is the responsibility of the caller to close the stream, if desired.</source>
          <target state="translated">이 메소드 &lt;em&gt;는&lt;/em&gt; 쓰기 조작이 완료된 후 제공된 &lt;code&gt;OutputStream&lt;/code&gt; 을 닫지 &lt;em&gt;않습니다&lt;/em&gt; . 원하는 경우 스트림을 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="849cc220f7f2288d02ac0a0d016b42c4a03abbb3" translate="yes" xml:space="preserve">
          <source>This method accepts a year value from the proleptic ISO calendar system.</source>
          <target state="translated">이 방법은 다발 ISO 달력 시스템에서 연도 값을받습니다.</target>
        </trans-unit>
        <trans-unit id="5f33e5832c8e17748897d2fe1a31b7c8f5a1edc2" translate="yes" xml:space="preserve">
          <source>This method accepts block names in the following forms:</source>
          <target state="translated">이 방법은 다음 형식의 블록 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1d4934e321968b6b5737a20b8db7eb111c01aa8b" translate="yes" xml:space="preserve">
          <source>This method acts as bridge between array-based and collection-based APIs.</source>
          <target state="translated">이 방법은 배열 기반 API와 컬렉션 기반 API 간의 브리지 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="3af30e48dd60471f402029a6e08b9337cffb2e47" translate="yes" xml:space="preserve">
          <source>This method adds the specified amount in weeks to the days field incrementing the month and year fields as necessary to ensure the result remains valid. The result is only invalid if the maximum/minimum year is exceeded.</source>
          <target state="translated">이 방법은 결과를 유효하게 유지하기 위해 필요한만큼 주 단위로 지정된 양을 일 필드에 추가하여 월 및 연도 필드를 증가시킵니다. 최대 / 최소 연도를 초과 한 경우에만 결과가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78e0e942f2ca0740ef7acb28824e1b9f833fdf85" translate="yes" xml:space="preserve">
          <source>This method adds the specified amount to the days field incrementing the month and year fields as necessary to ensure the result remains valid. The result is only invalid if the maximum/minimum year is exceeded.</source>
          <target state="translated">이 방법은 결과를 유효하게 유지하기 위해 필요에 따라 월과 연도 필드를 증가시켜 지정된 양을 일 필드에 추가합니다. 최대 / 최소 연도를 초과 한 경우에만 결과가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cffdf06049808a33bc8bcf6006cc27ef38580c8b" translate="yes" xml:space="preserve">
          <source>This method adds the specified amount to the months field in three steps:</source>
          <target state="translated">이 방법은 지정된 금액을 월 필드에 세 단계로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="af609df000243b0ab0dcffce4951b5476af479ce" translate="yes" xml:space="preserve">
          <source>This method adds the specified amount to the years field in three steps:</source>
          <target state="translated">이 방법은 세 단계로 지정된 금액을 연도 필드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1651391ffaab46b132075603bdd32cb42a6eeb1a" translate="yes" xml:space="preserve">
          <source>This method allows an application to request that the providers check for any updates to the provided rules. After calling this method, the offset stored in any &lt;a href=&quot;../zoneddatetime&quot;&gt;&lt;code&gt;ZonedDateTime&lt;/code&gt;&lt;/a&gt; may be invalid for the zone ID.</source>
          <target state="translated">이 방법을 통해 응용 프로그램은 공급자가 제공된 규칙에 대한 업데이트를 확인하도록 요청할 수 있습니다. 이 메서드를 호출 한 후 &lt;a href=&quot;../zoneddatetime&quot;&gt; &lt;code&gt;ZonedDateTime&lt;/code&gt; 에&lt;/a&gt; 저장된 오프셋 은 영역 ID에 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda444d0e2b0fbe233bda8959023b04aee5aa9f8" translate="yes" xml:space="preserve">
          <source>This method allows an arbitrary number of nanoseconds to be passed in. The factory will alter the values of the second and nanosecond in order to ensure that the stored nanosecond is in the range 0 to 999,999,999. For example, the following will result in the exactly the same duration:</source>
          <target state="translated">이 방법을 사용하면 임의의 수의 나노초가 전달 될 수 있습니다. 팩토리는 저장된 나노초가 0에서 999,999,999 범위에 있도록 초와 나노초의 값을 변경합니다. 예를 들어 다음과 같은 기간은 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97d0e4aaa0ceccd00c8a59cdcb938962da99c44" translate="yes" xml:space="preserve">
          <source>This method allows an arbitrary number of nanoseconds to be passed in. The factory will alter the values of the second and nanosecond in order to ensure that the stored nanosecond is in the range 0 to 999,999,999. For example, the following will result in the exactly the same instant:</source>
          <target state="translated">이 방법을 사용하면 임의의 수의 나노초가 전달 될 수 있습니다. 팩토리는 저장된 나노초가 0에서 999,999,999 범위에 있도록 초와 나노초의 값을 변경합니다. 예를 들어, 다음과 같은 순간이됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5b63419c8ca9a087d2129fc95966034700e350" translate="yes" xml:space="preserve">
          <source>This method allows formats that normally apply a color conversion, such as JPEG, and formats that do not normally have an associated colorspace, such as remote sensing or medical imaging data, to provide access to raw pixel data.</source>
          <target state="translated">이 방법을 사용하면 JPEG와 같은 일반적으로 색상 변환을 적용하는 형식과 원격 감지 또는 의료 영상 데이터와 같이 일반적으로 관련 색 공간이없는 형식으로 원시 픽셀 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd483899cb392f14434b2761f591f0dae8034ac" translate="yes" xml:space="preserve">
          <source>This method allows sophisticated applications to extend a PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; or &lt;code&gt;CertPathBuilder&lt;/code&gt;. Each of the specified &lt;code&gt;PKIXCertPathChecker&lt;/code&gt;s will be called, in turn, by a PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; or &lt;code&gt;CertPathBuilder&lt;/code&gt; for each certificate processed or validated.</source>
          <target state="translated">이 방법을 사용하면 정교한 응용 프로그램에서 PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; 또는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 를 확장 할 수 있습니다 . 지정된 각 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 는 차례로 처리 또는 검증 된 각 인증서에 대해 PKIX &lt;code&gt;CertPathValidator&lt;/code&gt; 또는 &lt;code&gt;CertPathBuilder&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d8556797fba1b77cd0451d414905190015a4f00" translate="yes" xml:space="preserve">
          <source>This method allows the caller to add a name to the set of issuer names which &lt;code&gt;X509CRLs&lt;/code&gt; may contain. The specified name is added to any previous value for the issuerNames criterion. If the specified name is a duplicate, it may be ignored.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 &lt;code&gt;X509CRLs&lt;/code&gt; 포함 할 수있는 발행자 이름 세트에 이름을 추가 할 수 있습니다. 지정된 이름이 issuerNames 기준의 이전 값에 추가됩니다. 지정된 이름이 중복되면 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a53dd998739b4376f63ebea8a55616b55400bdc8" translate="yes" xml:space="preserve">
          <source>This method allows the caller to add a name to the set of issuer names which &lt;code&gt;X509CRLs&lt;/code&gt; may contain. The specified name is added to any previous value for the issuerNames criterion. If the specified name is a duplicate, it may be ignored. If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 &lt;code&gt;X509CRLs&lt;/code&gt; 포함 할 수있는 발행자 이름 세트에 이름을 추가 할 수 있습니다. 지정된 이름이 issuerNames 기준의 이전 값에 추가됩니다. 지정된 이름이 중복되면 무시 될 수 있습니다. 이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER 인코딩 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad13d13006adb44bd6041030d8f05a1aedf5e56" translate="yes" xml:space="preserve">
          <source>This method allows the caller to add a name to the set of names which the &lt;code&gt;X509Certificates&lt;/code&gt;'s name constraints must permit. The specified name is added to any previous value for the pathToNames criterion. If the name is a duplicate, it may be ignored.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 &lt;code&gt;X509Certificates&lt;/code&gt; 의 이름 제한 조건이 허용해야하는 이름 세트에 이름을 추가 할 수 있습니다. 지정된 이름이 pathToNames 기준의 이전 값에 추가됩니다. 이름이 중복되면 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e4632e39bbefa94b32729bd5a8212dd3b42660c" translate="yes" xml:space="preserve">
          <source>This method allows the caller to add a name to the set of subject alternative names. The specified name is added to any previous value for the subjectAlternativeNames criterion. If the specified name is a duplicate, it may be ignored.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 주제 대체 이름 세트에 이름을 추가 할 수 있습니다. 지정된 이름이 subjectAlternativeNames 기준의 이전 값에 추가됩니다. 지정된 이름이 중복되면 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbce34c15635b1a6ca7855d219a5cbcefd189b29" translate="yes" xml:space="preserve">
          <source>This method allows the caller to specify, with a single method call, the complete set of issuer names which &lt;code&gt;X509CRLs&lt;/code&gt; may contain. The specified value replaces the previous value for the issuerNames criterion.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 단일 메소드 호출로 &lt;code&gt;X509CRLs&lt;/code&gt; 포함될 수있는 완전한 발행자 이름 세트를 지정할 수 있습니다. 지정된 값이 issuerNames 기준의 이전 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4aefaf491baf8c4e5456b621b5c0a498daa636e0" translate="yes" xml:space="preserve">
          <source>This method allows the caller to specify, with a single method call, the complete set of names which the &lt;code&gt;X509Certificates&lt;/code&gt;'s name constraints must permit. The specified value replaces the previous value for the pathToNames criterion.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 단일 메소드 호출로 &lt;code&gt;X509Certificates&lt;/code&gt; 의 이름 제한 조건이 허용해야하는 완전한 이름 세트를 지정할 수 있습니다. 지정된 값이 pathToNames 기준의 이전 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0bd4362610e1ac10a2f64be47d995751ffb00a8d" translate="yes" xml:space="preserve">
          <source>This method allows the caller to specify, with a single method call, the complete set of subject alternative names for the subjectAlternativeNames criterion. The specified value replaces the previous value for the subjectAlternativeNames criterion.</source>
          <target state="translated">이 메소드를 사용하면 호출자가 단일 메소드 호출로 subjectAlternativeNames 기준에 대한 완전한 대체 주제 이름 세트를 지정할 수 있습니다. 지정된 값이 subjectAlternativeNames 기준의 이전 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1c705334a0f7cff751d14c4a4a21383e06465e76" translate="yes" xml:space="preserve">
          <source>This method also provides a convenient way to create a fixed-size list initialized to contain several elements:</source>
          <target state="translated">이 방법은 또한 여러 요소를 포함하도록 초기화 된 고정 크기 목록을 작성하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fa62a2a0ad1a06eae0027923f56e07ec351d22f" translate="yes" xml:space="preserve">
          <source>This method always replaces malformed-input and unmappable-character sequences with the default replacement string for the platform's default character set. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;CharsetDecoder&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">이 방법은 항상 잘못된 입력 및 매핑 할 수없는 문자 시퀀스를 플랫폼의 기본 문자 세트에 대한 기본 대체 문자열로 바꿉니다. &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;CharsetDecoder의&lt;/a&gt; 부호화 처리 된 데이터를 복호화하는 과정을 더 제어 할 필요가있는 경우, 클래스를 사용하여야한다.</target>
        </trans-unit>
        <trans-unit id="2a3f7738d52d60d9dab45317ecb84bee2edd004d" translate="yes" xml:space="preserve">
          <source>This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement byte array. In order to detect such sequences, use the &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;CharsetDecoder.decode(java.nio.ByteBuffer)&lt;/code&gt;&lt;/a&gt; method directly.</source>
          <target state="translated">이 메소드는 항상 잘못된 입력 및 매핑 할 수없는 문자 시퀀스를이 문자 세트의 기본 대체 바이트 배열로 바꿉니다. 이러한 시퀀스를 감지하려면 &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;CharsetDecoder.decode(java.nio.ByteBuffer)&lt;/code&gt; &lt;/a&gt; 메소드를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="38587c881fb9338bfc5f7b0b4c57b21c51ed6440" translate="yes" xml:space="preserve">
          <source>This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement byte array. The &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt;&lt;code&gt;CharsetEncoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the encoding process is required.</source>
          <target state="translated">이 메소드는 항상 잘못된 입력 및 매핑 불가능 문자 시퀀스를이 문자 세트의 기본 대체 바이트 배열로 바꿉니다. &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt; &lt;code&gt;CharsetEncoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리를 더 제어 할 필요가있는 경우, 클래스가 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="1f13faeb3f76e5dd8cc2f8d9308ca1a600558991" translate="yes" xml:space="preserve">
          <source>This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string. In order to detect such sequences, use the &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;CharsetEncoder.encode(java.nio.CharBuffer)&lt;/code&gt;&lt;/a&gt; method directly.</source>
          <target state="translated">이 방법은 항상 잘못된 입력 및 매핑 할 수없는 문자 시퀀스를이 문자 세트의 기본 대체 문자열로 바꿉니다. 이러한 시퀀스를 감지하려면 &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;CharsetEncoder.encode(java.nio.CharBuffer)&lt;/code&gt; &lt;/a&gt; 메소드를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="be8bfafc52125e8313cc18e3a05d6ae74e1d8f25" translate="yes" xml:space="preserve">
          <source>This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;&lt;code&gt;CharsetDecoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">이 방법은 항상 잘못된 입력 및 매핑 할 수없는 문자 시퀀스를이 문자 세트의 기본 대체 문자열로 바꿉니다. &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt; &lt;code&gt;CharsetDecoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리 된 데이터를 복호화하는 과정을 더 제어 할 필요가있는 경우, 클래스를 사용하여야한다.</target>
        </trans-unit>
        <trans-unit id="cc60d1f3bbc26c7042daee639e5042e34e0d52e8" translate="yes" xml:space="preserve">
          <source>This method always returns false for unresolved permissions. That is, an UnresolvedPermission is never considered to imply another permission.</source>
          <target state="translated">이 메소드는 해결되지 않은 권한에 대해 항상 false를 리턴합니다. 즉, UnresolvedPermission은 다른 권한을 의미하는 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16225678abeadf71c6cbee077427074f7b270d0a" translate="yes" xml:space="preserve">
          <source>This method and/or the code it invokes may need to read some data from the stream to determine whether its data format is supported. The implementation may therefore need to mark the stream, read enough data to determine whether it is in a supported format, and reset the stream's read pointer to its original position. If the input stream does not permit this set of operations, this method may fail with an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">이 메소드 및 / 또는 그것이 호출하는 코드는 데이터 형식이 지원되는지 여부를 판별하기 위해 스트림에서 일부 데이터를 읽어야 할 수도 있습니다. 따라서 구현시 스트림을 표시하고, 지원되는 형식인지 여부를 판별하기 위해 충분한 데이터를 읽고, 스트림의 읽기 포인터를 원래 위치로 재설정해야합니다. 입력 스트림이이 오퍼레이션 세트를 허가하지 않는 경우,이 메소드는 &lt;code&gt;IOException&lt;/code&gt; 로 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4da6da35c7250af512899cb384b862226dc445d2" translate="yes" xml:space="preserve">
          <source>This method applies the current rules for leap years across the whole time-line. In general, a year is a leap year if it is divisible by four without remainder. However, years divisible by 100, are not leap years, with the exception of years divisible by 400 which are.</source>
          <target state="translated">이 방법은 전체 기간에 걸쳐 윤년에 대한 현재 규칙을 적용합니다. 일반적으로 1 년은 나머지없이 4로 나눌 수있는 윤년입니다. 그러나 100으로 나눌 수있는 연도는 윤년이 아니며, 400으로 나눌 수있는 연도는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="268718a6011dcfbddd887deca0fb0a458bf3d563" translate="yes" xml:space="preserve">
          <source>This method assigns a default &lt;a href=&quot;../security/protectiondomain&quot;&gt;&lt;code&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; to the newly defined class. The &lt;code&gt;ProtectionDomain&lt;/code&gt; is effectively granted the same set of permissions returned when &lt;a href=&quot;../security/policy#getPermissions-java.security.CodeSource-&quot;&gt;&lt;code&gt;&lt;code&gt;Policy.getPolicy().getPermissions(new CodeSource(null, null))&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; is invoked. The default domain is created on the first invocation of &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-&quot;&gt;&lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;, and re-used on subsequent invocations.</source>
          <target state="translated">이 메소드는 기본 &lt;a href=&quot;../security/protectiondomain&quot;&gt; &lt;code&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 을 새로 정의 된 클래스에 지정합니다. &lt;code&gt;ProtectionDomain&lt;/code&gt; 효과적으로 때 반환 권한의 동일한 집합이 부여됩니다 &lt;a href=&quot;../security/policy#getPermissions-java.security.CodeSource-&quot;&gt; &lt;code&gt;&lt;code&gt;Policy.getPolicy().getPermissions(new CodeSource(null, null))&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 호출을. 기본 도메인은 &lt;a href=&quot;classloader#defineClass-java.lang.String-byte:A-int-int-&quot;&gt; &lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 의 첫 번째 호출에서 작성 되고 후속 호출에서 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f426f8160bb66663f3038acb7b0ab97dfff5f242" translate="yes" xml:space="preserve">
          <source>This method attempts to match the given certificate with each keystore entry. If the entry being considered was created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the given certificate is compared to that entry's certificate.</source>
          <target state="translated">이 메소드는 지정된 인증서를 각 키 저장소 항목과 일치 시키려고합니다. 항목이 호출에 의해 생성 된 것으로 간주되는 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를 한 후 지정된 증명서는 그 엔트리의 인증서와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="17c6875b40f8854d2e8c9c961692d842b35cddb4" translate="yes" xml:space="preserve">
          <source>This method behaves exactly as &lt;code&gt;Subject.doAs&lt;/code&gt;, except that instead of retrieving the current Thread's &lt;code&gt;AccessControlContext&lt;/code&gt;, it uses the provided &lt;code&gt;AccessControlContext&lt;/code&gt;. If the provided &lt;code&gt;AccessControlContext&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method instantiates a new &lt;code&gt;AccessControlContext&lt;/code&gt; with an empty collection of ProtectionDomains.</source>
          <target state="translated">이 메소드 는 현재 Thread의 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 검색하는 대신 제공된 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 사용하는 것을 제외하고는 &lt;code&gt;Subject.doAs&lt;/code&gt; 와 동일하게 작동합니다 . 제공된 &lt;code&gt;AccessControlContext&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 ,이 메소드 는 비어있는 ProtectionDomain 컬렉션으로 새로운 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="7ab20aadadf75efe0ea98bf999bdd4234990df0e" translate="yes" xml:space="preserve">
          <source>This method behaves the same as &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;newMBeanProxy(MBeanServerConnection, ObjectName, Class)&lt;/code&gt;&lt;/a&gt;, but additionally, if &lt;code&gt;notificationEmitter&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the MBean is assumed to be a &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; and the returned proxy will implement &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; as well as &lt;code&gt;interfaceClass&lt;/code&gt;. A call to &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;NotificationBroadcaster.addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)&lt;/code&gt;&lt;/a&gt; on the proxy will result in a call to &lt;a href=&quot;mbeanserverconnection#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;MBeanServerConnection.addNotificationListener(ObjectName,
 NotificationListener, NotificationFilter, Object)&lt;/code&gt;&lt;/a&gt;, and likewise for the other methods of &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;newMBeanProxy(MBeanServerConnection, ObjectName, Class)&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동 하지만, &lt;code&gt;notificationEmitter&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 MBean은 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; 로&lt;/a&gt; 간주되며 리턴 된 프록시는 &lt;code&gt;interfaceClass&lt;/code&gt; 뿐만 아니라 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 를 구현 합니다. 프록시 에서 &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;NotificationBroadcaster.addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)&lt;/code&gt; &lt;/a&gt; 를 호출하면 &lt;a href=&quot;mbeanserverconnection#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;MBeanServerConnection.addNotificationListener(ObjectName, NotificationListener, NotificationFilter, Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.또한 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 의 다른 방법에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="040a2b5e4aeb36e7b9a8f65a99d90ff3a5e5bc95" translate="yes" xml:space="preserve">
          <source>This method behaves the same as &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;newMXBeanProxy(MBeanServerConnection, ObjectName, Class)&lt;/code&gt;&lt;/a&gt;, but additionally, if &lt;code&gt;notificationEmitter&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the MXBean is assumed to be a &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; and the returned proxy will implement &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; as well as &lt;code&gt;interfaceClass&lt;/code&gt;. A call to &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;NotificationBroadcaster.addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)&lt;/code&gt;&lt;/a&gt; on the proxy will result in a call to &lt;a href=&quot;mbeanserverconnection#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;MBeanServerConnection.addNotificationListener(ObjectName,
 NotificationListener, NotificationFilter, Object)&lt;/code&gt;&lt;/a&gt;, and likewise for the other methods of &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;newMXBeanProxy(MBeanServerConnection, ObjectName, Class)&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동 하지만, &lt;code&gt;notificationEmitter&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 MXBean은 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; 로&lt;/a&gt; 간주되며 반환 된 프록시는 &lt;code&gt;interfaceClass&lt;/code&gt; 뿐만 아니라 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 를 구현 합니다. 프록시 에서 &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;NotificationBroadcaster.addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)&lt;/code&gt; &lt;/a&gt; 를 호출하면 &lt;a href=&quot;mbeanserverconnection#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;MBeanServerConnection.addNotificationListener(ObjectName, NotificationListener, NotificationFilter, Object)&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.또한 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 의 다른 방법에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="2a3a050dc4ad75c04fab2f530821a2d8b2826a19" translate="yes" xml:space="preserve">
          <source>This method behaves the same as calling &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-java.lang.ClassLoader-java.util.ResourceBundle.Control-&quot;&gt;&lt;code&gt;getBundle(String, Locale, ClassLoader, Control)&lt;/code&gt;&lt;/a&gt; passing a default instance of &lt;a href=&quot;resourcebundle.control&quot;&gt;&lt;code&gt;ResourceBundle.Control&lt;/code&gt;&lt;/a&gt; unless another &lt;a href=&quot;resourcebundle.control&quot;&gt;&lt;code&gt;ResourceBundle.Control&lt;/code&gt;&lt;/a&gt; is provided with the &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt;&lt;code&gt;ResourceBundleControlProvider&lt;/code&gt;&lt;/a&gt; SPI. Refer to the description of &lt;a href=&quot;#modify_default_behavior&quot;&gt;modifying the default behavior&lt;/a&gt;.</source>
          <target state="translated">이 메소드 는 다른 &lt;a href=&quot;resourcebundle.control&quot;&gt; &lt;code&gt;ResourceBundle.Control&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt; &lt;code&gt;ResourceBundleControlProvider&lt;/code&gt; &lt;/a&gt; SPI 와 함께 제공 되지 않는 한 &lt;a href=&quot;resourcebundle.control&quot;&gt; &lt;code&gt;ResourceBundle.Control&lt;/code&gt; &lt;/a&gt; 의 기본 인스턴스를 전달하는 &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-java.lang.ClassLoader-java.util.ResourceBundle.Control-&quot;&gt; &lt;code&gt;getBundle(String, Locale, ClassLoader, Control)&lt;/code&gt; &lt;/a&gt; 호출과 동일하게 작동합니다 . &lt;a href=&quot;#modify_default_behavior&quot;&gt;기본 동작 수정&lt;/a&gt; 에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ef540b8fd24f2da7b9e12b97b85f8eda555b2c9" translate="yes" xml:space="preserve">
          <source>This method blocks until a datagram is received. The &lt;code&gt;length&lt;/code&gt; field of the datagram packet object contains the length of the received message. If the message is longer than the packet's length, the message is truncated.</source>
          <target state="translated">이 방법은 데이터 그램이 수신 될 때까지 차단됩니다. 데이터 그램 패킷 객체 의 &lt;code&gt;length&lt;/code&gt; 필드는 수신 된 메시지의 길이를 포함한다. 메시지가 패킷 길이보다 길면 메시지가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="9edb264cc1a33d9820b53af8c3cdc1fb275ae554" translate="yes" xml:space="preserve">
          <source>This method blocks until a newline character is read, a carriage return and the byte following it are read (to see if it is a newline), the end of the file is reached, or an exception is thrown.</source>
          <target state="translated">이 메소드는 개행 문자를 읽을 때, 캐리지 리턴 및 그 뒤에 오는 바이트를 읽거나 (줄 바꿈인지 확인하기 위해), 파일 끝에 도달하거나 예외가 발생할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="65d90c85a52039a4ff19c943ccb3cb5f594c3337" translate="yes" xml:space="preserve">
          <source>This method blocks until all the bytes are read, the end of the stream is detected, or an exception is thrown.</source>
          <target state="translated">이 메소드는 모든 바이트를 읽을 때까지, 스트림의 끝이 감지되거나 예외가 발생 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="8613d9e28f1e50e06732c3a04ed3315fc4de1b49" translate="yes" xml:space="preserve">
          <source>This method blocks until input data is available, end of file is detected, or an exception is thrown.</source>
          <target state="translated">이 방법은 입력 데이터를 사용할 수 있거나 파일 끝이 감지되거나 예외가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="69d6a4f6358b50ecc853876960af6eed4f3af288" translate="yes" xml:space="preserve">
          <source>This method blocks until one of the following conditions occurs:</source>
          <target state="translated">이 방법은 다음 조건 중 하나가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="d24e22ae204bbffb1aae51350c2b8591a89a1031" translate="yes" xml:space="preserve">
          <source>This method blocks until the byte is read, the end of the stream is detected, or an exception is thrown.</source>
          <target state="translated">이 메소드는 바이트를 읽을 때, 스트림의 끝이 감지되거나 예외가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2aa5b3b05ad6ab736997f223584ea0ea01792a" translate="yes" xml:space="preserve">
          <source>This method blocks until the eight bytes are read, the end of the stream is detected, or an exception is thrown.</source>
          <target state="translated">이 메소드는 8 바이트를 읽거나 스트림의 끝이 감지되거나 예외가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb676367f81fc57a11814f7fb38d025266194d0" translate="yes" xml:space="preserve">
          <source>This method blocks until the four bytes are read, the end of the stream is detected, or an exception is thrown.</source>
          <target state="translated">이 메소드는 4 바이트를 읽거나 스트림의 끝이 감지되거나 예외가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="3d5091fd6af7b86eae2699fd1b079cbd872ffc42" translate="yes" xml:space="preserve">
          <source>This method blocks until the group has terminated, or the timeout occurs, or the current thread is interrupted, whichever happens first.</source>
          <target state="translated">이 방법은 그룹이 종료되거나 시간 초과가 발생하거나 현재 스레드가 중단 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="8079da03ae0f8ee6fddde7359cb926ba4859755c" translate="yes" xml:space="preserve">
          <source>This method blocks until the two bytes are read, the end of the stream is detected, or an exception is thrown.</source>
          <target state="translated">이 메소드는 2 바이트를 읽을 때까지, 스트림의 끝이 감지되거나 예외가 발생 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="f7db78271a125ac89c34ce9bb6bd2d9c603fda06" translate="yes" xml:space="preserve">
          <source>This method by default throws OperationNotSupportedException. A subclass should override this method if it supports schema.</source>
          <target state="translated">이 메소드는 기본적으로 OperationNotSupportedException을 발생시킵니다. 서브 클래스가 스키마를 지원하는 경우이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b0c83cb3f14b5f9ba0e18c88bd5ebf12a4ae946" translate="yes" xml:space="preserve">
          <source>This method calculates the maximum value of &lt;a href=&quot;calendar#WEEK_OF_YEAR&quot;&gt;&lt;code&gt;WEEK_OF_YEAR&lt;/code&gt;&lt;/a&gt; based on the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; (calendar year) value, not the &lt;a href=&quot;#week_year&quot;&gt;week year&lt;/a&gt;. Call &lt;a href=&quot;gregoriancalendar#getWeeksInWeekYear--&quot;&gt;&lt;code&gt;getWeeksInWeekYear()&lt;/code&gt;&lt;/a&gt; to get the maximum value of &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; in the week year of this &lt;code&gt;GregorianCalendar&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;#week_year&quot;&gt;week year가&lt;/a&gt; 아니라 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; (calendar year) 값을 기반으로 &lt;a href=&quot;calendar#WEEK_OF_YEAR&quot;&gt; &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; &lt;/a&gt; 의 최대 값을 계산합니다 . 이 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 주중 에 &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; 의 최대 값을 얻으려면 &lt;a href=&quot;gregoriancalendar#getWeeksInWeekYear--&quot;&gt; &lt;code&gt;getWeeksInWeekYear()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="269bea040be761a329f2dcd426e9e7e5650eee88" translate="yes" xml:space="preserve">
          <source>This method calls &lt;a href=&quot;calendar#complete--&quot;&gt;&lt;code&gt;Calendar.complete()&lt;/code&gt;&lt;/a&gt; before adding the amount so that all the calendar fields are normalized. If there is any calendar field having an out-of-range value in non-lenient mode, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 메소드는 모든 캘린더 필드가 정규화되도록 금액을 추가하기 전에 &lt;a href=&quot;calendar#complete--&quot;&gt; &lt;code&gt;Calendar.complete()&lt;/code&gt; &lt;/a&gt; 를 호출합니다 . 무소음 모드에서 범위를 벗어난 값을 가진 달력 필드가 있으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37051f601b556b3395026e8474644866b3636c1d" translate="yes" xml:space="preserve">
          <source>This method calls &lt;a href=&quot;calendar#complete--&quot;&gt;&lt;code&gt;Calendar.complete()&lt;/code&gt;&lt;/a&gt; before calculating the week year.</source>
          <target state="translated">이 메소드는 주년을 계산하기 전에 &lt;a href=&quot;calendar#complete--&quot;&gt; &lt;code&gt;Calendar.complete()&lt;/code&gt; &lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3d2e8eda130fd16fedb0d019fdddb0fc7a855cfa" translate="yes" xml:space="preserve">
          <source>This method calls &lt;a href=&quot;simplejavafileobject#getKind--&quot;&gt;&lt;code&gt;getKind()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simplejavafileobject#toUri--&quot;&gt;&lt;code&gt;toUri()&lt;/code&gt;&lt;/a&gt; and does not access the fields &lt;a href=&quot;simplejavafileobject#uri&quot;&gt;&lt;code&gt;uri&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simplejavafileobject#kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;simplejavafileobject#getKind--&quot;&gt; &lt;code&gt;getKind()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;simplejavafileobject#toUri--&quot;&gt; &lt;code&gt;toUri()&lt;/code&gt; &lt;/a&gt; 호출 하며 &lt;a href=&quot;simplejavafileobject#uri&quot;&gt; &lt;code&gt;uri&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;simplejavafileobject#kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; 필드에 직접 액세스하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e06fe40c6f4df5c5dacf982a86322e1fc4b787d1" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;AccessController.checkPermission&lt;/code&gt; with the given permission.</source>
          <target state="translated">이 메소드 는 주어진 권한으로 &lt;code&gt;AccessController.checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="19738604ec6313155cae470a190e14c1867fe9c5" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;AWTPermission(&quot;accessClipboard&quot;)&lt;/code&gt; permission. In the case of subset Profiles of Java SE that do not include the &lt;code&gt;java.awt&lt;/code&gt; package, &lt;code&gt;checkPermission&lt;/code&gt; is instead called to check the permission &lt;code&gt;java.security.AllPermission&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;AWTPermission(&quot;accessClipboard&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . &lt;code&gt;java.awt&lt;/code&gt; 패키지를 포함하지 않는 Java SE의 서브 세트 프로파일의 경우 &lt;code&gt;java.security.AllPermission&lt;/code&gt; 권한을 확인하기 위해 &lt;code&gt;checkPermission&lt;/code&gt; 이 대신 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="73c694fe3a42693c434e002d948fff87adb94657" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; permission. In the case of subset Profiles of Java SE that do not include the &lt;code&gt;java.awt&lt;/code&gt; package, &lt;code&gt;checkPermission&lt;/code&gt; is instead called to check the permission &lt;code&gt;java.security.AllPermission&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . &lt;code&gt;java.awt&lt;/code&gt; 패키지를 포함하지 않는 Java SE의 서브 세트 프로파일의 경우 &lt;code&gt;java.security.AllPermission&lt;/code&gt; 권한을 확인하기 위해 &lt;code&gt;checkPermission&lt;/code&gt; 이 대신 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae3f7d9a114a9c3d1fc1ce191ace01aa23dfb43f" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; permission, and returns &lt;code&gt;true&lt;/code&gt; if a SecurityException is not thrown, otherwise it returns &lt;code&gt;false&lt;/code&gt;. In the case of subset Profiles of Java SE that do not include the &lt;code&gt;java.awt&lt;/code&gt; package, &lt;code&gt;checkPermission&lt;/code&gt; is instead called to check the permission &lt;code&gt;java.security.AllPermission&lt;/code&gt;.</source>
          <target state="translated">이 방법은 호출 &lt;code&gt;checkPermission&lt;/code&gt; 와 &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; 의 허가, 반환 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 반환는 SecurityException가 슬로우되지 않는 경우 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;java.awt&lt;/code&gt; 패키지를 포함하지 않는 Java SE의 서브 세트 프로파일의 경우 &lt;code&gt;java.security.AllPermission&lt;/code&gt; 권한을 확인하기 위해 &lt;code&gt;checkPermission&lt;/code&gt; 이 대신 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fdeff44c78d3902723ee823eaba70d551148962" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;FilePermission(cmd,&quot;execute&quot;)&lt;/code&gt; permission if cmd is an absolute path, otherwise it calls &lt;code&gt;checkPermission&lt;/code&gt; with &lt;code&gt;FilePermission(&quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot;,&quot;execute&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 방법은 호출 &lt;code&gt;checkPermission&lt;/code&gt; 으로 &lt;code&gt;FilePermission(cmd,&quot;execute&quot;)&lt;/code&gt; 그렇지 않으면 호출 (CMD)가 절대 경로이면 권한 &lt;code&gt;checkPermission&lt;/code&gt; 함께 &lt;code&gt;FilePermission(&quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot;,&quot;execute&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4090e1573f03a7b969ed4eb8baecc6269248e94" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;FilePermission(file,&quot;delete&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;FilePermission(file,&quot;delete&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5b08355483b5bd71a870e28cb3c5b9be8d105425" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bf80d8cebcf2bce202e03e26fa56b4fb477a5349" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;FilePermission(file,&quot;write&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;FilePermission(file,&quot;write&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cd2746d5381e5e48e2b8bdaa68b516a5e32229e4" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9f92e0c9ec1b3265d4a078b50f0f7c17f3b27464" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;PropertyPermission(key, &quot;read&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;PropertyPermission(key, &quot;read&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="443e1d17071c8a6b440e7feff746619b08781cc6" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;createClassLoader&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;createClassLoader&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fd341d2c15b82687c519829666f6ea5af730951d" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;exitVM.&quot;+status)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;exitVM.&quot;+status)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bd503776cdbf3af7134033cff2c250360e0eb170" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;loadLibrary.&quot;+lib)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;loadLibrary.&quot;+lib)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9a5f72e1a355b0bee29959fa41870127a6a77604" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2c5a22c480aa72ad9bdd63094f6d01b22499680f" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;readFileDescriptor&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;readFileDescriptor&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1805302599444c237841bd5b2fcf4b128fb3e5b9" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2f2885e0544d4e73448a66b931e57fddd504ba67" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;writeFileDescriptor&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;RuntimePermission(&quot;writeFileDescriptor&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6f6f908bf811b7f71042ad9e5310f118a65335bb" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)&lt;/code&gt; 과 함께 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a6588ddd0d20ef53b4230dba57c169828b93e1b8" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5782c7b7162da363323088e4f1544e5232ea96f2" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; permission if the port is not equal to -1. If the port is equal to -1, then it calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 포트가 -1이 아닌 경우 &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . 포트가 -1 인 경우 &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4fafc2d6e9c84a5d190a2a437331af72604794ee" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
 &quot;accept,connect&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(), &quot;accept,connect&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e5f703172d1163aa6fd1c5af5682264111ba8e" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;flush&lt;/code&gt;, writes the closing postamble and then closes the output stream associated with this stream.</source>
          <target state="translated">이 메소드는 &lt;code&gt;flush&lt;/code&gt; 를 호출 하고 닫는 포스트 앰블을 쓴 다음이 스트림과 연관된 출력 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="056704de3f264617d5178595663f8c57cdd5f1d0" translate="yes" xml:space="preserve">
          <source>This method calls the &lt;code&gt;exit&lt;/code&gt; method in class &lt;code&gt;Runtime&lt;/code&gt;. This method never returns normally.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Runtime&lt;/code&gt; 클래스 에서 &lt;code&gt;exit&lt;/code&gt; 메소드를 호출합니다 . 이 메소드는 정상적으로 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c466e2b5d2a812ecbc3c46657a8721f4dcfe360" translate="yes" xml:space="preserve">
          <source>This method calls the method &lt;a href=&quot;rmiserverimpl#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on the connector server's &lt;code&gt;RMIServerImpl&lt;/code&gt; object.</source>
          <target state="translated">이 메소드 는 커넥터 서버의 &lt;code&gt;RMIServerImpl&lt;/code&gt; 오브젝트 에서 메소드 &lt;a href=&quot;rmiserverimpl#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="03584ad9df1ca13639c4652a28102939262933ab" translate="yes" xml:space="preserve">
          <source>This method calls the various &lt;code&gt;getStandard*Node&lt;/code&gt; methods to supply each of the subtrees rooted at the children of the root node. If any of those methods returns &lt;code&gt;null&lt;/code&gt;, the corresponding subtree will be omitted. If all of them return &lt;code&gt;null&lt;/code&gt;, a tree consisting of a single root node will be returned.</source>
          <target state="translated">이 메소드는 다양한 &lt;code&gt;getStandard*Node&lt;/code&gt; 메소드를 호출 하여 루트 노드의 하위에있는 각 서브 트리를 제공합니다. 이러한 메소드 중 하나가 &lt;code&gt;null&lt;/code&gt; 을 리턴 하면 해당 서브 트리가 생략됩니다. 모두 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 단일 루트 노드로 구성된 트리가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce3397a67d6e7430b7581b0bc7e5b19cf215832d" translate="yes" xml:space="preserve">
          <source>This method can also be overridden in a subclass. It is recommended to use the &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt;&lt;code&gt;Formatter.formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">이 메소드는 서브 클래스에서 재정의 될 수도 있습니다. 메시지 필드를 현지화하고 &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt; &lt;code&gt;Formatter.formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 하려면 Formatter.formatMessage (java.util.logging.LogRecord) 편의 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0d3a331e5b72dbd387cdfa97e259d07f1ffd3519" translate="yes" xml:space="preserve">
          <source>This method can be called at most once. It is generally called from within the constructor, or immediately after creating the throwable. If this throwable was created with &lt;a href=&quot;../../../java/lang/throwable#Throwable-java.lang.Throwable-&quot;&gt;&lt;code&gt;Throwable.Throwable(Throwable)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/lang/throwable#Throwable-java.lang.String-java.lang.Throwable-&quot;&gt;&lt;code&gt;Throwable.Throwable(String,Throwable)&lt;/code&gt;&lt;/a&gt;, this method cannot be called even once.</source>
          <target state="translated">이 메소드는 최대 한 번 호출 할 수 있습니다. 일반적으로 생성자 내에서 또는 Throwable을 만든 직후에 호출됩니다. 이 Throwable이 &lt;a href=&quot;../../../java/lang/throwable#Throwable-java.lang.Throwable-&quot;&gt; &lt;code&gt;Throwable.Throwable(Throwable)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/throwable#Throwable-java.lang.String-java.lang.Throwable-&quot;&gt; &lt;code&gt;Throwable.Throwable(String,Throwable)&lt;/code&gt; &lt;/a&gt; 로 작성된 경우이 메소드는 한 번도 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9eceeaff05ffa1d9d5a81b7c43ae8cfaa35608b7" translate="yes" xml:space="preserve">
          <source>This method can be called at most once. It is generally called from within the constructor, or immediately after creating the throwable. If this throwable was created with &lt;a href=&quot;throwable#Throwable-java.lang.Throwable-&quot;&gt;&lt;code&gt;Throwable(Throwable)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-&quot;&gt;&lt;code&gt;Throwable(String,Throwable)&lt;/code&gt;&lt;/a&gt;, this method cannot be called even once.</source>
          <target state="translated">이 메소드는 최대 한 번 호출 할 수 있습니다. 일반적으로 생성자 내에서 또는 Throwable을 만든 직후에 호출됩니다. 이 Throwable이 &lt;a href=&quot;throwable#Throwable-java.lang.Throwable-&quot;&gt; &lt;code&gt;Throwable(Throwable)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-&quot;&gt; &lt;code&gt;Throwable(String,Throwable)&lt;/code&gt; &lt;/a&gt; 로 작성된 경우이 메소드를 한 번도 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60b50eff7937b117f5a61dbded0f8ffb05cfc95d" translate="yes" xml:space="preserve">
          <source>This method can be called by multiple threads concurrently. Each invocation of this method enables or disables the verbose output globally.</source>
          <target state="translated">이 메소드는 여러 스레드에서 동시에 호출 할 수 있습니다. 이 메소드를 호출 할 때마다 상세 출력을 전체적으로 사용 가능 또는 사용 불가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="299c4e6667b32b99868f975c8bd6dd86e470f87b" translate="yes" xml:space="preserve">
          <source>This method can be called even if the &lt;code&gt;Sequencer&lt;/code&gt; is closed.</source>
          <target state="translated">&lt;code&gt;Sequencer&lt;/code&gt; 가 닫혀 있어도이 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04935a12b0a22b12bf855a5e71e19bb9c50c2083" translate="yes" xml:space="preserve">
          <source>This method can be called more than once with different &lt;a href=&quot;../mbeanserverforwarder&quot;&gt;&lt;code&gt;MBeanServerForwarder&lt;/code&gt;&lt;/a&gt; objects. The result is a chain of forwarders. The last forwarder added is the first in the chain. In more detail:</source>
          <target state="translated">이 메소드는 다른 &lt;a href=&quot;../mbeanserverforwarder&quot;&gt; &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;/a&gt; 오브젝트로 두 번 이상 호출 될 수 있습니다 . 결과는 전달자 체인입니다. 추가 된 마지막 전달자는 체인에서 첫 번째 전달자입니다. 더 자세하게:</target>
        </trans-unit>
        <trans-unit id="4098755630331cc7cc4951a664fbc922c3cd70b1" translate="yes" xml:space="preserve">
          <source>This method can be called more than once with different &lt;a href=&quot;mbeanserverforwarder&quot;&gt;&lt;code&gt;MBeanServerForwarder&lt;/code&gt;&lt;/a&gt; objects. The result is a chain of forwarders. The last forwarder added is the first in the chain. In more detail:</source>
          <target state="translated">이 메소드는 다른 &lt;a href=&quot;mbeanserverforwarder&quot;&gt; &lt;code&gt;MBeanServerForwarder&lt;/code&gt; &lt;/a&gt; 오브젝트로 두 번 이상 호출 될 수 있습니다 . 결과는 전달자 체인입니다. 추가 된 마지막 전달자는 체인에서 첫 번째 전달자입니다. 더 자세하게:</target>
        </trans-unit>
        <trans-unit id="a41b91d7e4f07f0f6f9df115255c343bbf1f9c4a" translate="yes" xml:space="preserve">
          <source>This method can be overridden if the policy implementation supports returning a set of permissions granted to a ProtectionDomain.</source>
          <target state="translated">정책 구현이 ProtectionDomain에 부여 된 일련의 권한 반환을 지원하는 경우이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac5849453ee153448b53e320bc46f0e17e938bb7" translate="yes" xml:space="preserve">
          <source>This method can be overridden in a subclass. It is recommended to use the &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt;&lt;code&gt;Formatter.formatMessage(java.util.logging.LogRecord)&lt;/code&gt;&lt;/a&gt; convenience method to localize and format the message field.</source>
          <target state="translated">이 메소드는 서브 클래스에서 재정의 될 수 있습니다. 메시지 필드를 현지화하고 &lt;a href=&quot;formatter#formatMessage-java.util.logging.LogRecord-&quot;&gt; &lt;code&gt;Formatter.formatMessage(java.util.logging.LogRecord)&lt;/code&gt; &lt;/a&gt; 하려면 Formatter.formatMessage (java.util.logging.LogRecord) 편의 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="28bf6b4f8f117dd9ab0d5110d4b86315aa73bdee" translate="yes" xml:space="preserve">
          <source>This method can be used as part of a chain to produce a date:</source>
          <target state="translated">이 방법은 날짜를 생성하기 위해 체인의 일부로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db24ab0dd8e2925069a021f43db80a3535884cf5" translate="yes" xml:space="preserve">
          <source>This method can be used by a server application that needs to observe the inbound data but still create valid SSL/TLS connections: for example, inspection of Server Name Indication (SNI) extensions (See section 3 of &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC6066)&lt;/a&gt;). Data that has been already removed from the underlying &lt;a href=&quot;../../../java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt; should be loaded into the &lt;code&gt;consumed&lt;/code&gt; stream before this method is called, perhaps using a &lt;a href=&quot;../../../java/io/bytearrayinputstream&quot;&gt;&lt;code&gt;ByteArrayInputStream&lt;/code&gt;&lt;/a&gt;. When this &lt;a href=&quot;../../../java/net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; begins handshaking, it will read all of the data in &lt;code&gt;consumed&lt;/code&gt; until it reaches &lt;code&gt;EOF&lt;/code&gt;, then all further data is read from the underlying &lt;a href=&quot;../../../java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt; as usual.</source>
          <target state="translated">이 방법은 인바운드 데이터를 관찰해야하지만 여전히 유효한 SSL / TLS 연결을 작성해야하는 서버 애플리케이션에서 사용할 수 있습니다 (예 : SNI (Server Name Indication) 확장 검사 &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;(RFC6066)&lt;/a&gt; 섹션 3 참조 ). 기본이되는 &lt;a href=&quot;../../../java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 로부터 이미 삭제 된 데이터 는, 아마도 &lt;a href=&quot;../../../java/io/bytearrayinputstream&quot;&gt; &lt;code&gt;ByteArrayInputStream&lt;/code&gt; 를 사용해이&lt;/a&gt; 메소드를 호출하기 전에 , &lt;code&gt;consumed&lt;/code&gt; 스트림에 로드 될 필요가 있습니다 . 이 &lt;a href=&quot;../../../java/net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 이 핸드 쉐이킹을 시작 하면 &lt;code&gt;EOF&lt;/code&gt; 에 도달 할 때까지 &lt;code&gt;consumed&lt;/code&gt; 모든 데이터를 읽은 다음 평소대로 기본 &lt;a href=&quot;../../../java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 에서 모든 추가 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="213b3625cf6d5ba07208869fbd5adce1b71d45df" translate="yes" xml:space="preserve">
          <source>This method can be used by a server to verify the acceptable &lt;code&gt;SNIHostName&lt;/code&gt;s. For example,</source>
          <target state="translated">이 메소드는 서버가 허용 가능한 &lt;code&gt;SNIHostName&lt;/code&gt; 을 확인하는 데 사용할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="928c1d271faddcde95dcea8e56f6185dffe614f5" translate="yes" xml:space="preserve">
          <source>This method can be used in conjunction with the &lt;a href=&quot;httpurlconnection#getHeaderFieldKey-int-&quot;&gt;&lt;code&gt;getHeaderFieldKey&lt;/code&gt;&lt;/a&gt; method to iterate through all the headers in the message.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;httpurlconnection#getHeaderFieldKey-int-&quot;&gt; &lt;code&gt;getHeaderFieldKey&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용되어 메시지의 모든 헤더를 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f703d7479b308d8360a4a0178f9318bbca19adae" translate="yes" xml:space="preserve">
          <source>This method can be used in conjunction with the &lt;a href=&quot;urlconnection#getHeaderFieldKey-int-&quot;&gt;&lt;code&gt;getHeaderFieldKey&lt;/code&gt;&lt;/a&gt; method to iterate through all the headers in the message.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;urlconnection#getHeaderFieldKey-int-&quot;&gt; &lt;code&gt;getHeaderFieldKey&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용되어 메시지의 모든 헤더를 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e38dd709c7fd1e6574c35d57d28c8173d7ce0bb" translate="yes" xml:space="preserve">
          <source>This method can be used to lookup CRL entries in indirect CRLs, that means CRLs that contain entries from issuers other than the CRL issuer. The default implementation will only return entries for certificates issued by the CRL issuer. Subclasses that wish to support indirect CRLs should override this method.</source>
          <target state="translated">이 방법은 간접 CRL에서 CRL 항목을 조회하는 데 사용할 수 있습니다. 즉, CRL 발급자 이외의 발급자의 항목이 포함 된 CRL을 의미합니다. 기본 구현은 CRL 발급자가 발급 한 인증서에 대한 항목 만 반환합니다. 간접 CRL을 지원하려는 서브 클래스는이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="515dbc83a9d17200131e255617345851e1d91d97" translate="yes" xml:space="preserve">
          <source>This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrary</source>
          <target state="translated">이 방법은 경과 시간을 측정하는 데만 사용할 수 있으며 다른 시스템 또는 벽시계 시간 개념과 관련이 없습니다. 반환 값은 고정되었지만 임의이므로 임의의 나노초를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4fec536b3f6a191347ba70d3121bfd0d2cb06db2" translate="yes" xml:space="preserve">
          <source>This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt; becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">이 메소드는 현재 스레드 ( &lt;var&gt;T&lt;/var&gt; 라고 함 )가이 오브젝트에 대한 대기 세트에 자신을 배치 한 다음이 오브젝트에 대한 모든 동기화 청구를 포기합니다. 스레드 &lt;var&gt;T&lt;/var&gt; 는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 4 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8fb0901563ffb631d201729498da3e444ca3d2" translate="yes" xml:space="preserve">
          <source>This method causes this Configuration object to refresh/reload its contents in an implementation-dependent manner. For example, if this Configuration object stores its entries in a file, calling &lt;code&gt;refresh&lt;/code&gt; may cause the file to be re-read.</source>
          <target state="translated">이 메소드는이 Configuration 객체가 구현에 따라 내용을 새로 고치거나 다시로드합니다. 예를 들어,이 Configuration 객체가 해당 항목을 파일에 저장하는 경우 &lt;code&gt;refresh&lt;/code&gt; 를 호출 하면 파일을 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fddc8f5ad8ea28f9d3e410df7981f8dccd5dffee" translate="yes" xml:space="preserve">
          <source>This method causes this matcher to lose information about the groups of the last match that occurred. The matcher's position in the input is maintained and its last append position is unaffected.</source>
          <target state="translated">이 방법을 사용하면이 매처는 마지막으로 발생한 일치 그룹에 대한 정보를 유실합니다. 입력에서 매처의 위치는 유지되며 마지막 추가 위치는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d1f81bab3a52524ce08c86b4332e81bfd92c55c" translate="yes" xml:space="preserve">
          <source>This method causes this object to refresh/reload its current Policy. This is implementation-dependent. For example, if the Policy object is stored in a file, calling &lt;code&gt;refresh&lt;/code&gt; will cause the file to be re-read.</source>
          <target state="translated">이 방법을 사용하면이 개체가 현재 정책을 새로 고치거나 다시로드합니다. 이것은 구현에 따라 다릅니다. 예를 들어, 정책 개체가 파일에 저장된 경우 &lt;code&gt;refresh&lt;/code&gt; 를 호출 하면 파일을 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="3296a2f999228f4cc6234021423bf4c10e89c1da" translate="yes" xml:space="preserve">
          <source>This method changes the time-zone and retains the instant. This normally results in a change to the local date-time.</source>
          <target state="translated">이 방법은 시간대를 변경하고 순간을 유지합니다. 이로 인해 일반적으로 현지 날짜-시간이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="6d0f6dec553a6941b395b610d1f5cce0efbd8f9b" translate="yes" xml:space="preserve">
          <source>This method changes the time-zone and retains the local date-time. The local date-time is only changed if it is invalid for the new zone, determined using the same approach as &lt;a href=&quot;zoneddatetime#ofLocal-java.time.LocalDateTime-java.time.ZoneId-java.time.ZoneOffset-&quot;&gt;&lt;code&gt;ofLocal(LocalDateTime, ZoneId, ZoneOffset)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 시간대를 변경하고 현지 날짜-시간을 유지합니다. 로컬 날짜-시간은 새 지역에 대해 유효하지 않은 경우에만 변경되며 &lt;a href=&quot;zoneddatetime#ofLocal-java.time.LocalDateTime-java.time.ZoneId-java.time.ZoneOffset-&quot;&gt; &lt;code&gt;ofLocal(LocalDateTime, ZoneId, ZoneOffset)&lt;/code&gt; &lt;/a&gt; 과 동일한 접근 방식을 사용하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="46a23253baf38b2f1c044ac18305191965f3786a" translate="yes" xml:space="preserve">
          <source>This method changes the time-zone and retains the local date-time. The local date-time is only changed if it is invalid for the new zone.</source>
          <target state="translated">이 방법은 시간대를 변경하고 현지 날짜-시간을 유지합니다. 로컬 날짜-시간은 새 영역에 유효하지 않은 경우에만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5310049153ef893dddbedcbaea486c6508e001ef" translate="yes" xml:space="preserve">
          <source>This method checks against the range of the field in the ISO-8601 calendar system. This range may be incorrect for other calendar systems. Use &lt;a href=&quot;../chrono/chronology#range-java.time.temporal.ChronoField-&quot;&gt;&lt;code&gt;Chronology.range(ChronoField)&lt;/code&gt;&lt;/a&gt; to access the correct range for a different calendar system.</source>
          <target state="translated">이 방법은 ISO-8601 달력 시스템에서 필드의 범위를 확인합니다. 다른 달력 시스템에서는이 범위가 올바르지 않을 수 있습니다. 사용 &lt;a href=&quot;../chrono/chronology#range-java.time.temporal.ChronoField-&quot;&gt; &lt;code&gt;Chronology.range(ChronoField)&lt;/code&gt; &lt;/a&gt; 다른 달력 시스템에 대한 올바른 범위에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c857b14e72d1582778eab33648b7bb93672a7ba7" translate="yes" xml:space="preserve">
          <source>This method checks if the &lt;code&gt;LogRecord&lt;/code&gt; has an appropriate &lt;code&gt;Level&lt;/code&gt; and whether it satisfies any &lt;code&gt;Filter&lt;/code&gt;. It also may make other &lt;code&gt;Handler&lt;/code&gt; specific checks that might prevent a handler from logging the &lt;code&gt;LogRecord&lt;/code&gt;. It will return false if the &lt;code&gt;LogRecord&lt;/code&gt; is null.</source>
          <target state="translated">이 메소드는 &lt;code&gt;LogRecord&lt;/code&gt; 에 적절한 &lt;code&gt;Level&lt;/code&gt; 있고 &lt;code&gt;Filter&lt;/code&gt; 만족하는지 여부를 확인합니다 . 또한 핸들러가 &lt;code&gt;LogRecord&lt;/code&gt; 를 로깅하지 못하게하는 다른 &lt;code&gt;Handler&lt;/code&gt; 특정 점검을 수행 할 수도 있습니다 . &lt;code&gt;LogRecord&lt;/code&gt; 가 null이면 false를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b9cae628e4cbb314ffd27f1df73f8bc56609f660" translate="yes" xml:space="preserve">
          <source>This method checks if the &lt;code&gt;LogRecord&lt;/code&gt; has an appropriate level and whether it satisfies any &lt;code&gt;Filter&lt;/code&gt;. However it does &lt;b&gt;not&lt;/b&gt; check whether the &lt;code&gt;LogRecord&lt;/code&gt; would result in a &quot;push&quot; of the buffer contents. It will return false if the &lt;code&gt;LogRecord&lt;/code&gt; is null.</source>
          <target state="translated">이 메소드는 &lt;code&gt;LogRecord&lt;/code&gt; 에 적절한 레벨이 있고 &lt;code&gt;Filter&lt;/code&gt; 만족하는지 여부를 확인합니다 . 그러나 &lt;code&gt;LogRecord&lt;/code&gt; 로 인해 버퍼 내용이 &quot;푸시&quot; 되는지 여부는 확인 하지 &lt;b&gt;않습니다&lt;/b&gt; . &lt;code&gt;LogRecord&lt;/code&gt; 가 null이면 false를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="7d654c3b8bd21b790c01a40658ed4f6204877578" translate="yes" xml:space="preserve">
          <source>This method checks if the &lt;code&gt;LogRecord&lt;/code&gt; has an appropriate level and whether it satisfies any &lt;code&gt;Filter&lt;/code&gt;. It will also return false if no output stream has been assigned yet or the LogRecord is null.</source>
          <target state="translated">이 메소드는 &lt;code&gt;LogRecord&lt;/code&gt; 에 적절한 레벨이 있고 &lt;code&gt;Filter&lt;/code&gt; 만족하는지 여부를 확인합니다 . 출력 스트림이 아직 할당되지 않았거나 LogRecord가 null 인 경우에도 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74391c52a27ced5a9b2079a0933c22c720eef4b2" translate="yes" xml:space="preserve">
          <source>This method checks that &lt;code&gt;cmdarray&lt;/code&gt; is a valid operating system command. Which commands are valid is system-dependent, but at the very least the command must be a non-empty list of non-null strings.</source>
          <target state="translated">이 방법은 &lt;code&gt;cmdarray&lt;/code&gt; 가 유효한 운영 체제 명령인지 확인합니다. 유효한 명령은 시스템에 따라 다르지만 최소한 명령은 비어 있지 않은 문자열이 아닌 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="02b9f2626413e81b573bfe50d50d41f41858234a" translate="yes" xml:space="preserve">
          <source>This method checks that the command is a valid operating system command. Which commands are valid is system-dependent, but at the very least the command must be a non-empty list of non-null strings.</source>
          <target state="translated">이 방법은 명령이 유효한 운영 체제 명령인지 확인합니다. 유효한 명령은 시스템에 따라 다르지만 최소한 명령은 비어 있지 않은 문자열이 아닌 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="80106af0f11970b7bc5d84c28e2c9715b1421695" translate="yes" xml:space="preserve">
          <source>This method checks the existence of a file and that this Java virtual machine has appropriate privileges that would allow it access the file according to all of access modes specified in the &lt;code&gt;modes&lt;/code&gt; parameter as follows:</source>
          <target state="translated">이 메소드는 파일의 존재를 확인하고이 Java 가상 머신에 다음과 같이 &lt;code&gt;modes&lt;/code&gt; 매개 변수에 지정된 모든 액세스 모드에 따라 파일에 액세스 할 수있는 적절한 권한이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="813e7219d13ff3f0ff1e399420f1630dd4d45425" translate="yes" xml:space="preserve">
          <source>This method checks whether this month and day and the input year form a valid date. This can only return false for February 29th.</source>
          <target state="translated">이 방법은이 월과 일 및 입력 연도가 유효한 날짜를 형성하는지 확인합니다. 2 월 29 일에 대해서만 false를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ca0ea3874885ad825737fe01643853174112aeb" translate="yes" xml:space="preserve">
          <source>This method checks whether this year and month and the input day form a valid date.</source>
          <target state="translated">이 방법은 올해와 월 및 입력 날짜가 유효한 날짜인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b0ae8ca0a80a5b42c94d0b36381fb9056daa9563" translate="yes" xml:space="preserve">
          <source>This method checks whether this year and the input month and day form a valid date.</source>
          <target state="translated">이 방법은 올해와 입력 월 및 일이 유효한 날짜를 형성하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9d7cfe6c5917eedcd56be0220cd20dbf8d413d0c" translate="yes" xml:space="preserve">
          <source>This method closes the input stream associated with this stream.</source>
          <target state="translated">이 메소드는이 스트림과 연관된 입력 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="dff493e06662208f386fd8c2f9ff5678c725d551" translate="yes" xml:space="preserve">
          <source>This method combines &lt;a href=&quot;valuerange#isIntValue--&quot;&gt;&lt;code&gt;isIntValue()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;valuerange#isValidValue-long-&quot;&gt;&lt;code&gt;isValidValue(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;valuerange#isIntValue--&quot;&gt; &lt;code&gt;isIntValue()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;valuerange#isValidValue-long-&quot;&gt; &lt;code&gt;isValidValue(long)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1dd6469ce58e7474eb9aedf9925e9c38c3d7f088" translate="yes" xml:space="preserve">
          <source>This method completes a 2-phase authentication process by calling each configured LoginModule's &lt;code&gt;commit&lt;/code&gt; method if the overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT, and OPTIONAL LoginModules succeeded), or by calling each configured LoginModule's &lt;code&gt;abort&lt;/code&gt; method if the overall authentication failed. If authentication succeeded, each successful LoginModule's &lt;code&gt;commit&lt;/code&gt; method associates the relevant Principals and Credentials with the &lt;code&gt;Subject&lt;/code&gt;. If authentication failed, each LoginModule's &lt;code&gt;abort&lt;/code&gt; method removes/destroys any previously stored state.</source>
          <target state="translated">이 메소드 는 전체 인증이 성공한 경우 (관련된 REQUIRED, REQUISITE, SUFFICIENT 및 OPTIONAL LoginModule이 성공한 경우) 구성된 각 LoginModule의 &lt;code&gt;commit&lt;/code&gt; 메소드를 호출하거나 전체 인증이 실패한 경우 구성된 각 LoginModule의 &lt;code&gt;abort&lt;/code&gt; 메소드 를 호출 하여 2 단계 인증 프로세스를 완료합니다 . 인증이 성공한 경우, 성공적인 각 LoginModule의 &lt;code&gt;commit&lt;/code&gt; 메소드는 관련 프린시 펄 및 신임 정보를 &lt;code&gt;Subject&lt;/code&gt; 와 연관시킵니다 . 인증이 실패하면 각 LoginModule의 &lt;code&gt;abort&lt;/code&gt; 메소드는 이전에 저장된 상태를 제거 / 파기합니다.</target>
        </trans-unit>
        <trans-unit id="0bdf3031aebd241da3e146a392f7cd34da1b30e8" translate="yes" xml:space="preserve">
          <source>This method computes an approximation of the containment relation: If it returns &lt;code&gt;true&lt;/code&gt; then the given charset is known to be contained by this charset; if it returns &lt;code&gt;false&lt;/code&gt;, however, then it is not necessarily the case that the given charset is not contained in this charset.</source>
          <target state="translated">이 메소드는 포함 관계의 근사값을 계산합니다. &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 주어진 문자 세트가이 문자 세트에 포함 된 것으로 알려져 있습니다. 그러나 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우, 지정된 캐릭터 세트가이 캐릭터 세트에 포함되어 있지 않은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="016880e8460b7fc1d677359206f7ba9fb7006a7b" translate="yes" xml:space="preserve">
          <source>This method constructs a new watch service that may be used to watch registered objects for changes and events.</source>
          <target state="translated">이 방법은 등록 된 객체의 변경 및 이벤트를 감시하는 데 사용할 수있는 새로운 감시 서비스를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e45582cbf00c605da5516a5f1e3f215544800cb8" translate="yes" xml:space="preserve">
          <source>This method constructs an absolute &lt;a href=&quot;../../net/uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt; equal to the URI scheme that identifies the provider. The exact form of the scheme specific part is highly provider dependent.</source>
          <target state="translated">이 메소드 는 제공자를 식별하는 URI 스킴과 동일한 &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 으로 절대 &lt;a href=&quot;../../net/uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 구성합니다 . 체계 특정 부분의 정확한 형식은 공급자에 따라 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="72795cabb6417067cf089969a9efc76ccd71e6d0" translate="yes" xml:space="preserve">
          <source>This method converts using the type of this enum. The output is defined relative to the 'before' offset of the transition.</source>
          <target state="translated">이 메소드는이 열거 형의 유형을 사용하여 변환합니다. 출력은 전환의 '이전'오프셋과 관련하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1e1c030bc0362fbc369e8636af9a9c47b0f469" translate="yes" xml:space="preserve">
          <source>This method copies a file to the target file with the &lt;code&gt;options&lt;/code&gt; parameter specifying how the copy is performed. By default, the copy fails if the target file already exists or is a symbolic link, except if the source and target are the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file, in which case the method completes without copying the file. File attributes are not required to be copied to the target file. If symbolic links are supported, and the file is a symbolic link, then the final target of the link is copied. If the file is a directory then it creates an empty directory in the target location (entries in the directory are not copied). This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to copy a directory and all entries in the directory, or an entire</source>
          <target state="translated">이 방법 은 복사 수행 방법을 지정하는 &lt;code&gt;options&lt;/code&gt; 매개 변수를 사용하여 파일을 대상 파일로 복사합니다. 기본적으로, 대상 파일이 이미 존재하거나 소스와 대상이 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 인 경우를 제외하고 기호 링크 인 경우 복사에 실패합니다.이 경우 파일 을 복사하지 않고 메소드가 완료됩니다. 파일 속성은 대상 파일로 복사 할 필요가 없습니다. 심볼릭 링크가 지원되고 파일이 심볼릭 링크 인 경우 링크의 최종 대상이 복사됩니다. 파일이 디렉토리 인 경우 대상 위치에 빈 디렉토리가 작성됩니다 (디렉토리의 항목은 복사되지 않습니다). 이 메소드는 &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체를 복사 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8310f53ea86c0c1e41a135195fbc40f3bcfaa980" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;SecurityPermission&lt;/code&gt; object for the given permission target name and calls &lt;code&gt;checkPermission&lt;/code&gt; with it.</source>
          <target state="translated">이 메소드 는 주어진 권한 대상 이름에 대한 &lt;code&gt;SecurityPermission&lt;/code&gt; 오브젝트를 작성하고이를 사용하여 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="21728d2edb7d5eff2049d493420b1c7bc5fe6356" translate="yes" xml:space="preserve">
          <source>This method creates a cipher for the algorithm that had been used in the sealing operation, using an implementation of that algorithm from the given &lt;code&gt;provider&lt;/code&gt;. The Cipher object is initialized for decryption, using the given &lt;code&gt;key&lt;/code&gt; and the parameters (if any) that had been used in the sealing operation.</source>
          <target state="translated">이 메소드는, 지정된 &lt;code&gt;provider&lt;/code&gt; 알고리즘의 구현을 사용해, 실링 조작에 사용 된 알고리즘의 암호를 작성합니다 . 지정된 &lt;code&gt;key&lt;/code&gt; 와 봉인 작업에 사용 된 매개 변수 (있는 경우)를 사용하여 암호 개체가 해독을 위해 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="5900f0bafbcd4b92904f8343617b0ece38d9cf8f" translate="yes" xml:space="preserve">
          <source>This method creates a cipher for the algorithm that had been used in the sealing operation. If the default provider package provides an implementation of that algorithm, an instance of Cipher containing that implementation is used. If the algorithm is not available in the default package, other packages are searched. The Cipher object is initialized for decryption, using the given &lt;code&gt;key&lt;/code&gt; and the parameters (if any) that had been used in the sealing operation.</source>
          <target state="translated">이 방법은 봉인 작업에 사용 된 알고리즘의 암호를 만듭니다. 기본 제공자 패키지가 해당 알고리즘의 구현을 제공하는 경우 해당 구현을 포함하는 Cipher 인스턴스가 사용됩니다. 기본 패키지에서 알고리즘을 사용할 수 없으면 다른 패키지가 검색됩니다. 지정된 &lt;code&gt;key&lt;/code&gt; 와 봉인 작업에 사용 된 매개 변수 (있는 경우)를 사용하여 암호 개체가 암호 해독을 위해 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="996ced6827ff26e8c9efb36b41525f3db595392c" translate="yes" xml:space="preserve">
          <source>This method creates a new MBeanServer implementation object. When creating a new MBeanServer the &lt;a href=&quot;mbeanserverfactory&quot;&gt;&lt;code&gt;MBeanServerFactory&lt;/code&gt;&lt;/a&gt; first calls &lt;code&gt;newMBeanServerDelegate()&lt;/code&gt; in order to obtain a new &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt; for the new MBeanServer. Then it calls &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; passing the &lt;var&gt;delegate&lt;/var&gt; that should be used by the MBeanServer implementation.</source>
          <target state="translated">이 메소드는 새로운 MBeanServer 구현 오브젝트를 작성합니다. 새의 MBeanServer 작성시 &lt;a href=&quot;mbeanserverfactory&quot;&gt; &lt;code&gt;MBeanServerFactory&lt;/code&gt; 는이&lt;/a&gt; 최초 호출 &lt;code&gt;newMBeanServerDelegate()&lt;/code&gt; 새로 획득하기 위해 &lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 가이&lt;/a&gt; 새로운 MBeanServer에 대한. 그런 다음 MBeanServer 구현에서 사용해야 하는 &lt;var&gt;delegate&lt;/var&gt; 를 전달하여 &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bed9906b1f8929561794f9981e9f989e7b4781de" translate="yes" xml:space="preserve">
          <source>This method creates a new MBeanServerDelegate for a new MBeanServer. When creating a new MBeanServer the &lt;a href=&quot;mbeanserverfactory&quot;&gt;&lt;code&gt;MBeanServerFactory&lt;/code&gt;&lt;/a&gt; first calls this method in order to create a new MBeanServerDelegate.</source>
          <target state="translated">이 메소드는 새로운 MBeanServer를위한 새로운 MBeanServerDelegate를 작성합니다. 새로운 MBeanServer를 작성시 &lt;a href=&quot;mbeanserverfactory&quot;&gt; &lt;code&gt;MBeanServerFactory&lt;/code&gt; &lt;/a&gt; 먼저 새 MBeanServerDelegate를을 생성하기 위해이 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c8a8a426401075bfebe76bd1131b78e727507772" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying date and not the chronology. This allows dates in different calendar systems to be compared based on the time-line position. This is equivalent to using &lt;code&gt;date1.toEpochDay() &amp;gt; date2.toEpochDay()&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 연대기가 아닌 기본 날짜 만 비교한다는 점 에서 &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이를 통해 다른 달력 시스템의 날짜를 타임 라인 위치를 기준으로 비교할 수 있습니다. 이것은 &lt;code&gt;date1.toEpochDay() &amp;gt; date2.toEpochDay()&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d865ce7bbce8731f8919dcc191c99881dc0763b3" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying date and not the chronology. This allows dates in different calendar systems to be compared based on the time-line position. This is equivalent to using &lt;code&gt;date1.toEpochDay() &amp;lt; date2.toEpochDay()&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 연대기가 아닌 기본 날짜 만 비교한다는 점 에서 &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이를 통해 다른 달력 시스템의 날짜를 타임 라인 위치를 기준으로 비교할 수 있습니다. 이것은 &lt;code&gt;date1.toEpochDay() &amp;lt; date2.toEpochDay()&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e67dfebd9078f7bbd8a4464632831ff22f4db473" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying date and not the chronology. This allows dates in different calendar systems to be compared based on the time-line position. This is equivalent to using &lt;code&gt;date1.toEpochDay() == date2.toEpochDay()&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 연대기가 아닌 기본 날짜 만 비교한다는 점 에서 &lt;a href=&quot;chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이를 통해 다른 달력 시스템의 날짜를 타임 라인 위치를 기준으로 비교할 수 있습니다. 이것은 &lt;code&gt;date1.toEpochDay() == date2.toEpochDay()&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="73af9e0f5eb7c76b238b4f76e4874c7da82c1c8e" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying date and time and not the chronology. This allows date-times in different calendar systems to be compared based on the time-line position.</source>
          <target state="translated">이 메소드는 연대기가 아닌 기본 날짜와 시간 만 비교한다는 점 에서 &lt;a href=&quot;chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이를 통해 다른 캘린더 시스템의 날짜-시간을 타임 라인 위치를 기준으로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e422892980a4143434c4a33271842f6ca101b62" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying date-time and not the chronology. This allows dates in different calendar systems to be compared based on the time-line position.</source>
          <target state="translated">이 메소드는 연대기가 아니라 기본 날짜-시간 만 비교한다는 점 에서 &lt;a href=&quot;chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이를 통해 다른 달력 시스템의 날짜를 타임 라인 위치를 기준으로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69679f35e3a14abac97b704557a6a28c58d1d819" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronozoneddatetime#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().equals(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;chronozoneddatetime#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().equals(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다. .</target>
        </trans-unit>
        <trans-unit id="2a310bdbafb8caf48753a75e15e9d61ad7c49945" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().isAfter(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().isAfter(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="2efc5d8ad2ddce9136c3cbf23a4408d68bae821e" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().isBefore(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().isBefore(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="1c0acca56b765b2bc1764861b9d596c46bdc9784" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsetdatetime#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().equals(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;offsetdatetime#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().equals(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다. .</target>
        </trans-unit>
        <trans-unit id="95bd83ca10b6e2e579e7453880a4102248c15b52" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsetdatetime#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().isAfter(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;offsetdatetime#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().isAfter(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="b9b67c6d81b67989e43d00b4d9e11db5649e4712" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the date-time. This is equivalent to using &lt;code&gt;dateTime1.toInstant().isBefore(dateTime2.toInstant());&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 날짜-시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이것은 &lt;code&gt;dateTime1.toInstant().isBefore(dateTime2.toInstant());&lt;/code&gt; 를 사용하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="276e0dc62cdc78db144c25c794c005156b01d95b" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt;&lt;/a&gt; in that it only compares the underlying instant.</source>
          <target state="translated">이 메소드는 기본 인스턴트 만 비교한다는 점 에서 &lt;a href=&quot;offsetdatetime#compareTo-java.time.OffsetDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetDateTime)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b4a8edd55adb2adcee3e7f94c3d11b7b90edd30" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsettime#compareTo-java.time.OffsetTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetTime)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsettime#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(java.lang.Object)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the time. This is equivalent to converting both times to an instant using the same date and comparing the instants.</source>
          <target state="translated">이 메소드는 시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;offsettime#compareTo-java.time.OffsetTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetTime)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;offsettime#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(java.lang.Object)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이는 동일한 날짜를 사용하여 두 시간을 순간으로 변환하고 순간을 비교하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4e5de1c223ead70e6f5f63ebf13ad79c5ab57cd" translate="yes" xml:space="preserve">
          <source>This method differs from the comparison in &lt;a href=&quot;offsettime#compareTo-java.time.OffsetTime-&quot;&gt;&lt;code&gt;compareTo(java.time.OffsetTime)&lt;/code&gt;&lt;/a&gt; in that it only compares the instant of the time. This is equivalent to converting both times to an instant using the same date and comparing the instants.</source>
          <target state="translated">이 메소드는 시간의 순간 만 비교한다는 점 에서 &lt;a href=&quot;offsettime#compareTo-java.time.OffsetTime-&quot;&gt; &lt;code&gt;compareTo(java.time.OffsetTime)&lt;/code&gt; &lt;/a&gt; 의 비교와 다릅니다 . 이는 동일한 날짜를 사용하여 두 시간을 순간으로 변환하고 순간을 비교하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81446ff3de29ce70008e0ee03dc5c04c4486f1e7" translate="yes" xml:space="preserve">
          <source>This method discovers the attributes and operations that an MBean exposes for management.</source>
          <target state="translated">이 메소드는 MBean이 관리를 위해 공개하는 속성 및 조작을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="5c4b9860d67fd6071459494762d41825a9131b33" translate="yes" xml:space="preserve">
          <source>This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return.</source>
          <target state="translated">이 메소드는 메소드를 리턴 한 원인을보고 하지 &lt;em&gt;않습니다&lt;/em&gt; . 발신자는 실이 먼저 멈춘 원인을 다시 확인해야합니다. 호출자는 또한 예를 들어 리턴시 스레드의 인터럽트 상태를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bcd6d36fb527564bc407ca010b1b0701d5a9c43" translate="yes" xml:space="preserve">
          <source>This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the current time upon return.</source>
          <target state="translated">이 메소드는 메소드를 리턴 한 원인을보고 하지 &lt;em&gt;않습니다&lt;/em&gt; . 발신자는 실이 먼저 멈춘 원인을 다시 확인해야합니다. 호출자는 예를 들어 스레드의 인터럽트 상태 또는 리턴시 현재 시간을 결정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f230e6ae839a96b93aabb4880473f2a0be743de0" translate="yes" xml:space="preserve">
          <source>This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the elapsed time upon return.</source>
          <target state="translated">이 메소드는 메소드를 리턴 한 원인을보고 하지 &lt;em&gt;않습니다&lt;/em&gt; . 발신자는 실이 먼저 멈춘 원인을 다시 확인해야합니다. 호출자는 예를 들어 스레드의 인터럽트 상태 또는 리턴시 경과 시간을 결정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec668043a6e942ad250bbeefecd6bb8d8002b6b" translate="yes" xml:space="preserve">
          <source>This method does not access the file system; the path may not locate a file that exists. Eliminating &quot;&lt;code&gt;..&lt;/code&gt;&quot; and a preceding name from a path may result in the path that locates a different file than the original path. This can arise when the preceding name is a symbolic link.</source>
          <target state="translated">이 방법은 파일 시스템에 액세스하지 않습니다. 경로가 존재하는 파일을 찾지 못할 수 있습니다. 경로에서 &quot; &lt;code&gt;..&lt;/code&gt; &quot;및 선행 이름을 제거 하면 원래 경로와 다른 파일을 찾는 경로가 생성 될 수 있습니다. 위의 이름이 기호 링크 인 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29efc8d1d0a975c0106803bf392fa8e4c9140058" translate="yes" xml:space="preserve">
          <source>This method does not actually erase the data in the buffer, but it is named as if it did because it will most often be used in situations in which that might as well be the case.</source>
          <target state="translated">이 방법은 실제로 버퍼의 데이터를 지우지는 않지만 그럴 수있는 상황에서 가장 자주 사용되기 때문에 마치 마치 마치 마치 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d0462f8cd40a193807741b2a955105e488b1a6dc" translate="yes" xml:space="preserve">
          <source>This method does not attempt to locate &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from a &lt;code&gt;File&lt;/code&gt;; that may be accomplished using &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;File&lt;/code&gt; 로부터 직접 읽을 수있는 &lt;code&gt;ImageReader&lt;/code&gt; 를 찾지 않습니다 . &lt;code&gt;IIORegistry&lt;/code&gt; 및 &lt;code&gt;ImageReaderSpi&lt;/code&gt; 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5028ce13fc5fa887cf07e88a999f30391cac7a8" translate="yes" xml:space="preserve">
          <source>This method does not attempt to locate &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from a &lt;code&gt;URL&lt;/code&gt;; that may be accomplished using &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;URL&lt;/code&gt; 로부터 직접 읽을 수있는 &lt;code&gt;ImageReader&lt;/code&gt; 를 찾지 않습니다 . &lt;code&gt;IIORegistry&lt;/code&gt; 및 &lt;code&gt;ImageReaderSpi&lt;/code&gt; 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08d84f5481057ffe75137ea92fd191d915f3dd45" translate="yes" xml:space="preserve">
          <source>This method does not attempt to locate &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from an &lt;code&gt;InputStream&lt;/code&gt;; that may be accomplished using &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;InputStream&lt;/code&gt; 로부터 직접 읽을 수있는 &lt;code&gt;ImageReader&lt;/code&gt; 를 찾지 않습니다 . &lt;code&gt;IIORegistry&lt;/code&gt; 및 &lt;code&gt;ImageReaderSpi&lt;/code&gt; 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fac3576c4d1c22034682c222249823c14a504b13" translate="yes" xml:space="preserve">
          <source>This method does not block. An invocation always returns immediately, either having acquired a lock on the requested region or having failed to do so. If it fails to acquire a lock because an overlapping lock is held by another program then it returns &lt;code&gt;null&lt;/code&gt;. If it fails to acquire a lock for any other reason then an appropriate exception is thrown.</source>
          <target state="translated">이 방법은 차단되지 않습니다. 요청 된 영역에서 잠금을 획득했거나 실패한 경우 항상 호출이 즉시 리턴됩니다. 겹치는 잠금이 다른 프로그램에 의해 보류되어 잠금을 획득하지 못하면 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 . 다른 이유로 잠금을 획득하지 못하면 적절한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="776db5599544763bcd336fd173724144761f8aed" translate="yes" xml:space="preserve">
          <source>This method does not cause any initialization except that which would occur under the customary JVM semantics. In other words, redefining a class does not cause its initializers to be run. The values of static variables will remain as they were prior to the call.</source>
          <target state="translated">이 메소드는 일반적인 JVM 시맨틱에서 발생하는 것을 제외하고는 초기화를 일으키지 않습니다. 다시 말해, 클래스를 재정의해도 초기화 프로그램이 실행되지는 않습니다. 정적 변수의 값은 호출 이전과 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="029519cbdd36144790d6e5a27b657276f60210ce" translate="yes" xml:space="preserve">
          <source>This method does not change the value of &lt;code&gt;java.class.path&lt;/code&gt;&lt;a href=&quot;../system#getProperties--&quot;&gt;&lt;code&gt;system property&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;java.class.path&lt;/code&gt; &lt;a href=&quot;../system#getProperties--&quot;&gt; &lt;code&gt;system property&lt;/code&gt; &lt;/a&gt; 의 값을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="16cbeb9b6b383c135b9d4fffaae8b1ac2d8b8242" translate="yes" xml:space="preserve">
          <source>This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are transferred. If the source channel has a position then bytes are read starting at that position and then the position is incremented by the number of bytes read.</source>
          <target state="translated">이 방법은이 채널의 위치를 ​​수정하지 않습니다. 주어진 위치가 파일의 현재 크기보다 크면 바이트가 전송되지 않습니다. 소스 채널에 위치가 있으면 해당 위치에서 시작하여 바이트를 읽고 읽은 바이트 수만큼 위치를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="2f6fb75afad10086596870671066a96fdeb3f586" translate="yes" xml:space="preserve">
          <source>This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are transferred. If the target channel has a position then bytes are written starting at that position and then the position is incremented by the number of bytes written.</source>
          <target state="translated">이 방법은이 채널의 위치를 ​​수정하지 않습니다. 주어진 위치가 파일의 현재 크기보다 크면 바이트가 전송되지 않습니다. 대상 채널에 위치가 있으면 해당 위치에서 시작하여 바이트가 기록되고 그 위치는 기록 된 바이트 수만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="799659d1b1680f85ef944208828233ac6460e32e" translate="yes" xml:space="preserve">
          <source>This method does not offer real-time guarantees: It schedules the timeout as if by invoking the &lt;a href=&quot;../../lang/object#wait-long-&quot;&gt;&lt;code&gt;Object.wait(long)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 실시간 보증을 제공하지 않습니다. &lt;a href=&quot;../../lang/object#wait-long-&quot;&gt; &lt;code&gt;Object.wait(long)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼 시간 종료를 스케줄합니다 .</target>
        </trans-unit>
        <trans-unit id="423dc1fb5fa90201dd1f3386013a35af973fbed0" translate="yes" xml:space="preserve">
          <source>This method does not offer real-time guarantees: It schedules the timeout as if by invoking the &lt;a href=&quot;../object#wait-long-&quot;&gt;&lt;code&gt;Object.wait(long)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 실시간 보증을 제공하지 않습니다. &lt;a href=&quot;../object#wait-long-&quot;&gt; &lt;code&gt;Object.wait(long)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼 시간 종료를 스케줄합니다 .</target>
        </trans-unit>
        <trans-unit id="0cfca155e4fe2088fe576ea1b39061a44946c4ff" translate="yes" xml:space="preserve">
          <source>This method does not wait for actively executing tasks to terminate. Use &lt;a href=&quot;executorservice#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;awaitTermination&lt;/code&gt;&lt;/a&gt; to do that.</source>
          <target state="translated">이 방법은 적극적으로 실행중인 작업이 종료 될 때까지 기다리지 않습니다. &lt;a href=&quot;executorservice#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;awaitTermination&lt;/code&gt; &lt;/a&gt; 위해 awaitTermination 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae53fc019903cb63e96647acf94b63258487c8dc" translate="yes" xml:space="preserve">
          <source>This method does not wait for actively executing tasks to terminate. Use &lt;a href=&quot;threadpoolexecutor#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;awaitTermination&lt;/code&gt;&lt;/a&gt; to do that.</source>
          <target state="translated">이 방법은 적극적으로 실행중인 작업이 종료 될 때까지 기다리지 않습니다. &lt;a href=&quot;threadpoolexecutor#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;awaitTermination&lt;/code&gt; &lt;/a&gt; 위해 awaitTermination 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6845b8bb705b91430417229ccdbccb9324f99e41" translate="yes" xml:space="preserve">
          <source>This method does not wait for previously submitted tasks to complete execution. Use &lt;a href=&quot;executorservice#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;awaitTermination&lt;/code&gt;&lt;/a&gt; to do that.</source>
          <target state="translated">이 방법은 이전에 제출 된 작업이 실행을 완료하기를 기다리지 않습니다. &lt;a href=&quot;executorservice#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;awaitTermination&lt;/code&gt; &lt;/a&gt; 위해 awaitTermination 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8b986bb2830801c1c0e469068e7bda1db7a0f3a" translate="yes" xml:space="preserve">
          <source>This method does not wait for previously submitted tasks to complete execution. Use &lt;a href=&quot;threadpoolexecutor#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;awaitTermination&lt;/code&gt;&lt;/a&gt; to do that.</source>
          <target state="translated">이 방법은 이전에 제출 된 작업이 실행을 완료하기를 기다리지 않습니다. &lt;a href=&quot;threadpoolexecutor#awaitTermination-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;awaitTermination&lt;/code&gt; &lt;/a&gt; 위해 awaitTermination 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a04f810e9c905f9c1329c7a9c73fea317cca2c2f" translate="yes" xml:space="preserve">
          <source>This method doesn't block, i.e. no reverse name service lookup is performed.</source>
          <target state="translated">이 방법은 차단되지 않습니다. 즉, 역방향 이름 서비스 조회가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b35853e0da75c2dd9285f53bc7ad476eb18426a5" translate="yes" xml:space="preserve">
          <source>This method doesn't validate the specified character to be a valid Unicode code point. The caller must validate the character value using &lt;a href=&quot;character#isValidCodePoint-int-&quot;&gt;&lt;code&gt;isValidCodePoint&lt;/code&gt;&lt;/a&gt; if necessary.</source>
          <target state="translated">이 메서드는 지정된 문자가 유효한 유니 코드 코드 포인트인지 확인하지 않습니다. 필요한 경우 호출자는 &lt;a href=&quot;character#isValidCodePoint-int-&quot;&gt; &lt;code&gt;isValidCodePoint&lt;/code&gt; 를&lt;/a&gt; 사용하여 문자 값의 유효성을 검사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b0d757f872c8992ebbba76f2a37b8cb57802645" translate="yes" xml:space="preserve">
          <source>This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by operating on a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List:</source>
          <target state="translated">이 방법을 사용하면 명시적인 범위 연산 (배열에 일반적으로 존재하는 정렬)이 필요하지 않습니다. List를 예상하는 모든 작업은 전체 List 대신 하위 목록보기에서 작동하여 범위 작업으로 사용할 수 있습니다. 예를 들어 다음 관용구는 목록에서 다양한 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b87f0cb9c5df7254ccafa323a476c57fb867a722" translate="yes" xml:space="preserve">
          <source>This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list:</source>
          <target state="translated">이 방법을 사용하면 명시적인 범위 연산 (배열에 일반적으로 존재하는 정렬)이 필요하지 않습니다. 목록을 기대하는 모든 작업은 전체 목록 대신 하위 목록보기를 전달하여 범위 작업으로 사용할 수 있습니다. 예를 들어 다음 관용구는 목록에서 다양한 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d1c6c7c0a3f0e3d56a14189ead8dc65d2d8ca336" translate="yes" xml:space="preserve">
          <source>This method enables the current &lt;code&gt;BeanInfo&lt;/code&gt; object to return an arbitrary collection of other &lt;code&gt;BeanInfo&lt;/code&gt; objects that provide additional information about the current bean.</source>
          <target state="translated">이 메소드를 사용하면 현재 &lt;code&gt;BeanInfo&lt;/code&gt; 오브젝트가 현재 Bean에 대한 추가 정보를 제공하는 다른 &lt;code&gt;BeanInfo&lt;/code&gt; 오브젝트 의 임의 콜렉션을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78b1fe125c73b5076363add79751d8af78528e7f" translate="yes" xml:space="preserve">
          <source>This method encapsulates the basic decoding loop, decoding as many bytes as possible until it either runs out of input, runs out of room in the output buffer, or encounters a decoding error. This method is invoked by the &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; method, which handles result interpretation and error recovery.</source>
          <target state="translated">이 방법은 기본 디코딩 루프를 캡슐화하여 입력이 부족하거나 출력 버퍼의 공간이 부족하거나 디코딩 오류가 발생할 때까지 가능한 한 많은 바이트를 디코딩합니다. 이 메소드는 결과 해석 및 오류 복구를 처리 하는 &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="34cc00ba57c172360457e325a1b154234e6f6295" translate="yes" xml:space="preserve">
          <source>This method encapsulates the basic encoding loop, encoding as many characters as possible until it either runs out of input, runs out of room in the output buffer, or encounters an encoding error. This method is invoked by the &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; method, which handles result interpretation and error recovery.</source>
          <target state="translated">이 방법은 기본 인코딩 루프를 캡슐화하여 입력이 부족하거나 출력 버퍼의 공간이 부족하거나 인코딩 오류가 발생할 때까지 가능한 한 많은 문자를 인코딩합니다. 이 메소드는 결과 해석 및 오류 복구를 처리 하는 &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt; &lt;code&gt;encode&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="74ace9a4696b375af288eedb658c5a0479b2c340" translate="yes" xml:space="preserve">
          <source>This method evaluates the &lt;em&gt;existential quantification&lt;/em&gt; of the predicate over the elements of the stream (for some x P(x)).</source>
          <target state="translated">이 메소드 는 스트림 요소에 대한 술어 의 &lt;em&gt;존재 수량&lt;/em&gt; 을 평가합니다 (일부 x P (x)에 대해).</target>
        </trans-unit>
        <trans-unit id="8e29b39c37d9f0876c9909a031c3012531b4c71c" translate="yes" xml:space="preserve">
          <source>This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the negated predicate over the elements of the stream (for all x ~P(x)). If the stream is empty, the quantification is said to be vacuously satisfied and is always &lt;code&gt;true&lt;/code&gt;, regardless of P(x).</source>
          <target state="translated">이 메소드 는 스트림 요소에 대해 부정 된 술어의 전체 &lt;em&gt;정량&lt;/em&gt; 을 평가합니다 (모든 x ~ P (x)에 대해). 스트림이 비어있는 경우 P (x)에 관계없이 수량 화가 빈틈 없이 충족되고 항상 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7db2070540c2c562f74f31f3655c1a32f3083a2" translate="yes" xml:space="preserve">
          <source>This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the predicate over the elements of the stream (for all x P(x)). If the stream is empty, the quantification is said to be &lt;em&gt;vacuously satisfied&lt;/em&gt; and is always &lt;code&gt;true&lt;/code&gt; (regardless of P(x)).</source>
          <target state="translated">이 방법 은 스트림 요소에 대한 술어 의 &lt;em&gt;범용 정량&lt;/em&gt; 을 평가합니다 (모든 x P (x)에 대해). 스트림이 비어있는 경우 수량화는 &lt;em&gt;완전히 만족&lt;/em&gt; 한다고하며 항상 P (x)에 관계없이 &lt;code&gt;true&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="16cf4a1fcc5d6973ae156692d6317157013b5c90" translate="yes" xml:space="preserve">
          <source>This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline:</source>
          <target state="translated">이 방법은 주로 디버깅을 지원하기 위해 존재하며 파이프 라인의 특정 지점을지나 가면서 요소를 확인하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="982c59d7cd4f643b57742247e7e55732ba66ae60" translate="yes" xml:space="preserve">
          <source>This method exists primarily for writing test cases. Non test-code will typically use other methods to create an offset time. &lt;code&gt;LocalDateTime&lt;/code&gt; has five additional convenience variants of the equivalent factory method taking fewer arguments. They are not provided here to reduce the footprint of the API.</source>
          <target state="translated">이 방법은 주로 테스트 사례를 작성하기 위해 존재합니다. 테스트 코드가 아닌 코드는 일반적으로 다른 방법을 사용하여 오프셋 시간을 만듭니다. &lt;code&gt;LocalDateTime&lt;/code&gt; 에는 인수를 덜 사용하는 동등한 팩토리 메소드의 5 가지 추가 편의 변형이 있습니다. API의 설치 공간을 줄이기 위해 여기에 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd1761201ffb394e8a819ed4bce3831fbbee5af5" translate="yes" xml:space="preserve">
          <source>This method exists primarily for writing test cases. Non test-code will typically use other methods to create an offset time. &lt;code&gt;LocalTime&lt;/code&gt; has two additional convenience variants of the equivalent factory method taking fewer arguments. They are not provided here to reduce the footprint of the API.</source>
          <target state="translated">이 방법은 주로 테스트 사례를 작성하기 위해 존재합니다. 테스트 코드가 아닌 코드는 일반적으로 다른 방법을 사용하여 오프셋 시간을 만듭니다. &lt;code&gt;LocalTime&lt;/code&gt; 에는 더 적은 인수를 사용하는 동등한 팩토리 메소드의 두 가지 추가 편리한 변형이 있습니다. API의 설치 공간을 줄이기 위해 여기에 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b58458b6cd02ffd97fdf8240b91b18bd00bcd97" translate="yes" xml:space="preserve">
          <source>This method exists to be used as a &lt;a href=&quot;function/predicate&quot;&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;filter(Objects::isNull)&lt;/code&gt;</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;function/predicate&quot;&gt; &lt;code&gt;Predicate&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;filter(Objects::isNull)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad117920c2cdf44107f517b6de5ada3dbf71681f" translate="yes" xml:space="preserve">
          <source>This method exists to be used as a &lt;a href=&quot;function/predicate&quot;&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;filter(Objects::nonNull)&lt;/code&gt;</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;function/predicate&quot;&gt; &lt;code&gt;Predicate&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;filter(Objects::nonNull)&lt;/code&gt; 로 사용하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3567eed99c163537118a86339bf638abc11755d6" translate="yes" xml:space="preserve">
          <source>This method finds deadlocks involving only object monitors. To find deadlocks involving both object monitors and &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;ownable synchronizers&lt;/a&gt;, the &lt;a href=&quot;threadmxbean#findDeadlockedThreads--&quot;&gt;&lt;code&gt;findDeadlockedThreads&lt;/code&gt;&lt;/a&gt; method should be used.</source>
          <target state="translated">이 메소드는 오브젝트 모니터 만 포함하는 교착 상태를 찾습니다. 객체 모니터 모두 포함 교착 찾으려면 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 가능한 싱크로 나이저를&lt;/a&gt; 의 &lt;a href=&quot;threadmxbean#findDeadlockedThreads--&quot;&gt; &lt;code&gt;findDeadlockedThreads&lt;/code&gt; 의&lt;/a&gt; 방법이 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="2b4dc1a8cd711f7f3fa89cb707ce5c4e33beea21" translate="yes" xml:space="preserve">
          <source>This method finds the desired calendar system by in a manner equivalent to passing &quot;ca&quot; to &lt;a href=&quot;../../util/locale#getUnicodeLocaleType-java.lang.String-&quot;&gt;&lt;code&gt;Locale.getUnicodeLocaleType(String)&lt;/code&gt;&lt;/a&gt;. If the &quot;ca&quot; key is not present, then &lt;code&gt;IsoChronology&lt;/code&gt; is returned.</source>
          <target state="translated">이 메소드는 &quot;ca&quot;를 &lt;a href=&quot;../../util/locale#getUnicodeLocaleType-java.lang.String-&quot;&gt; &lt;code&gt;Locale.getUnicodeLocaleType(String)&lt;/code&gt; &lt;/a&gt; 에 전달하는 것과 동일한 방식으로 원하는 달력 시스템을 찾습니다 . &quot;ca&quot;키가 없으면 &lt;code&gt;IsoChronology&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2780f49595166eb2ccf26df44113b129089ef21e" translate="yes" xml:space="preserve">
          <source>This method first attempts to locate an installed provider in exactly the same manner as the &lt;a href=&quot;filesystems#newFileSystem-java.net.URI-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt;&lt;/a&gt; method. If none of the installed providers support the URI scheme then an attempt is made to locate the provider using the given class loader. If a provider supporting the URI scheme is located then its &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt;&lt;/a&gt; is invoked to construct the new file system.</source>
          <target state="translated">이 메소드는 먼저 &lt;a href=&quot;filesystems#newFileSystem-java.net.URI-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 설치된 제공자를 찾으려고합니다 . 설치된 프로 바이더 중 어느 것도 URI 스킴을 지원하지 않는 경우, 지정된 클래스 로더를 사용해 프로 바이더를 찾으려고합니다. URI 스킴을 지원하는 제공자가있는 경우 새 파일 시스템을 구성하기 위해 &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1798d4617d377c84e9b80df321391c4d2c5cf3ad" translate="yes" xml:space="preserve">
          <source>This method first calls &lt;a href=&quot;standardmbean#getCachedMBeanInfo--&quot;&gt;&lt;code&gt;getCachedMBeanInfo()&lt;/code&gt;&lt;/a&gt; in order to retrieve the cached MBeanInfo for this MBean, if any. If the MBeanInfo returned by &lt;a href=&quot;standardmbean#getCachedMBeanInfo--&quot;&gt;&lt;code&gt;getCachedMBeanInfo()&lt;/code&gt;&lt;/a&gt; is not null, then it is returned.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;standardmbean#getCachedMBeanInfo--&quot;&gt; &lt;code&gt;getCachedMBeanInfo()&lt;/code&gt; &lt;/a&gt; MBean에 대해 캐시 된 MBeanInfo를 검색하기 위해 getCachedMBeanInfo () 를 호출 합니다. &lt;a href=&quot;standardmbean#getCachedMBeanInfo--&quot;&gt; &lt;code&gt;getCachedMBeanInfo()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 MBeanInfo 가 널이 아닌 경우 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59140a76baec806eb4e690ef3b6f858bd5d141de" translate="yes" xml:space="preserve">
          <source>This method first determines the content type of the object by calling the &lt;code&gt;getContentType&lt;/code&gt; method. If this is the first time that the application has seen that specific content type, a content handler for that content type is created:</source>
          <target state="translated">이 메소드는 먼저 &lt;code&gt;getContentType&lt;/code&gt; 메소드 를 호출하여 오브젝트의 컨텐츠 유형을 판별합니다 . 애플리케이션이 특정 컨텐츠 유형을 처음 본 경우 해당 컨텐츠 유형에 대한 컨텐츠 핸들러가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="76c12afd2f5682a61d6b55898ae3f3e4274be13b" translate="yes" xml:space="preserve">
          <source>This method first encodes all input bytes into a base64 encoded byte array and then constructs a new String by using the encoded byte array and the &lt;a href=&quot;../nio/charset/standardcharsets#ISO_8859_1&quot;&gt;&lt;code&gt;ISO-8859-1&lt;/code&gt;&lt;/a&gt; charset.</source>
          <target state="translated">이 메소드는 먼저 모든 입력 바이트를 base64로 인코딩 된 바이트 배열로 인코딩 한 다음 인코딩 된 바이트 배열과 &lt;a href=&quot;../nio/charset/standardcharsets#ISO_8859_1&quot;&gt; &lt;code&gt;ISO-8859-1&lt;/code&gt; &lt;/a&gt; 문자 세트 를 사용하여 새 문자열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="428e7d1173d67880a9e00fdf54335f66d0af40dd" translate="yes" xml:space="preserve">
          <source>This method first gets a list of restricted packages by obtaining a comma-separated list from a call to &lt;code&gt;java.security.Security.getProperty(&quot;package.access&quot;)&lt;/code&gt;, and checks to see if &lt;code&gt;pkg&lt;/code&gt; starts with or equals any of the restricted packages. If it does, then &lt;code&gt;checkPermission&lt;/code&gt; gets called with the &lt;code&gt;RuntimePermission(&quot;accessClassInPackage.&quot;+pkg)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드는 먼저 &lt;code&gt;java.security.Security.getProperty(&quot;package.access&quot;)&lt;/code&gt; 에 대한 호출에서 쉼표로 구분 된 목록을 가져 와서 제한된 패키지 목록을 가져오고 &lt;code&gt;pkg&lt;/code&gt; 가 제한된 패키지로 시작 하는지 확인 합니다. . 그렇다면 &lt;code&gt;checkPermission&lt;/code&gt; 은 &lt;code&gt;RuntimePermission(&quot;accessClassInPackage.&quot;+pkg)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd34702b84494134e43e3bafa9dd777fc7c1bdd2" translate="yes" xml:space="preserve">
          <source>This method first gets a list of restricted packages by obtaining a comma-separated list from a call to &lt;code&gt;java.security.Security.getProperty(&quot;package.definition&quot;)&lt;/code&gt;, and checks to see if &lt;code&gt;pkg&lt;/code&gt; starts with or equals any of the restricted packages. If it does, then &lt;code&gt;checkPermission&lt;/code&gt; gets called with the &lt;code&gt;RuntimePermission(&quot;defineClassInPackage.&quot;+pkg)&lt;/code&gt; permission.</source>
          <target state="translated">이 메소드는 먼저 &lt;code&gt;java.security.Security.getProperty(&quot;package.definition&quot;)&lt;/code&gt; 에 대한 호출에서 쉼표로 구분 된 목록을 가져 와서 제한된 패키지 목록을 가져 와서 &lt;code&gt;pkg&lt;/code&gt; 이 제한된 패키지로 시작 하는지 확인 합니다. . 그렇다면 &lt;code&gt;checkPermission&lt;/code&gt; 은 &lt;code&gt;RuntimePermission(&quot;defineClassInPackage.&quot;+pkg)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="dee20129dc59e859025bd28928a1b166bb308aac" translate="yes" xml:space="preserve">
          <source>This method first resets this matcher. It then scans the input sequence looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt;&lt;code&gt;appendReplacement&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 방법은 먼저이 매처를 재설정합니다. 그런 다음 패턴과 일치하는 입력 시퀀스를 스캔합니다. 일치하지 않는 문자는 결과 문자열에 직접 추가됩니다. 일치하는 결과는 대체 문자열로 대체됩니다. 교체 문자열에는 &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt; &lt;code&gt;appendReplacement&lt;/code&gt; &lt;/a&gt; 메서드 에서와 같이 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26f6cb3387c41fe104f31644a6b216b8ba0d8140" translate="yes" xml:space="preserve">
          <source>This method first resets this matcher. It then scans the input sequence looking for matches of the pattern. Characters that are not part of any match are appended directly to the result string; each match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt;&lt;code&gt;appendReplacement&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 방법은 먼저이 매처를 재설정합니다. 그런 다음 패턴과 일치하는 입력 시퀀스를 스캔합니다. 일치하지 않는 문자는 결과 문자열에 직접 추가됩니다. 각 일치 항목은 결과에서 대체 문자열로 대체됩니다. 교체 문자열에는 &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt; &lt;code&gt;appendReplacement&lt;/code&gt; &lt;/a&gt; 메서드 에서와 같이 캡처 된 하위 시퀀스에 대한 참조가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="454b55b13454df1ffb7a9f545d399b9998fbac9f" translate="yes" xml:space="preserve">
          <source>This method first retrieves the current Thread's &lt;code&gt;AccessControlContext&lt;/code&gt; via &lt;code&gt;AccessController.getContext&lt;/code&gt;, and then instantiates a new &lt;code&gt;AccessControlContext&lt;/code&gt; using the retrieved context along with a new &lt;code&gt;SubjectDomainCombiner&lt;/code&gt; (constructed using the provided &lt;code&gt;Subject&lt;/code&gt;). Finally, this method invokes &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;, passing it the provided &lt;code&gt;PrivilegedAction&lt;/code&gt;, as well as the newly constructed &lt;code&gt;AccessControlContext&lt;/code&gt;.</source>
          <target state="translated">이 방법은 먼저 현재의 쓰레드의 검색 &lt;code&gt;AccessControlContext&lt;/code&gt; 통해 &lt;code&gt;AccessController.getContext&lt;/code&gt; 하고 새 인스턴스 &lt;code&gt;AccessControlContext&lt;/code&gt; 새로운 따라 검색된 컨텍스트를 사용 &lt;code&gt;SubjectDomainCombiner&lt;/code&gt; 에 (제공된하여 구성 &lt;code&gt;Subject&lt;/code&gt; ). 마지막으로이 메소드는 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 를 호출 하여 제공된 &lt;code&gt;PrivilegedAction&lt;/code&gt; 과 새로 구성된 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="37b325e60cde38d418deb1d8e962ea5c6de2a359" translate="yes" xml:space="preserve">
          <source>This method first retrieves the current Thread's &lt;code&gt;AccessControlContext&lt;/code&gt; via &lt;code&gt;AccessController.getContext&lt;/code&gt;, and then instantiates a new &lt;code&gt;AccessControlContext&lt;/code&gt; using the retrieved context along with a new &lt;code&gt;SubjectDomainCombiner&lt;/code&gt; (constructed using the provided &lt;code&gt;Subject&lt;/code&gt;). Finally, this method invokes &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;, passing it the provided &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt;, as well as the newly constructed &lt;code&gt;AccessControlContext&lt;/code&gt;.</source>
          <target state="translated">이 방법은 먼저 현재의 쓰레드의 검색 &lt;code&gt;AccessControlContext&lt;/code&gt; 통해 &lt;code&gt;AccessController.getContext&lt;/code&gt; 하고 새 인스턴스 &lt;code&gt;AccessControlContext&lt;/code&gt; 새로운 따라 검색된 컨텍스트를 사용 &lt;code&gt;SubjectDomainCombiner&lt;/code&gt; 에 (제공된하여 구성 &lt;code&gt;Subject&lt;/code&gt; ). 마지막으로이 메소드는 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 를 호출 하여 제공된 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 및 새로 구성된 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="3721220fa080e7d6464d6c7eb00c8b6d61b5f653" translate="yes" xml:space="preserve">
          <source>This method first verifies that this channel is open and that the given initial interest set is valid.</source>
          <target state="translated">이 방법은 먼저이 채널이 열려 있고 지정된 초기 관심사 세트가 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7d0c6e67c905619f3119435a65c48ff048cc99c1" translate="yes" xml:space="preserve">
          <source>This method follows symbolic links if the file referenced by this object is a symbolic link. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. To determine the effective access to a file may require access to several attributes and so in some implementations this method may not be atomic with respect to other file system operations.</source>
          <target state="translated">이 객체가 참조하는 파일이 심볼릭 링크 인 경우이 메소드는 심볼릭 링크를 따릅니다. 구현에 따라이 방법은 파일에 대한 효과적인 액세스를 확인하기 위해 파일 권한, 액세스 제어 목록 또는 기타 파일 속성을 읽어야 할 수 있습니다. 파일에 대한 효과적인 액세스를 결정하려면 여러 속성에 대한 액세스가 필요할 수 있으므로 일부 구현에서이 방법은 다른 파일 시스템 작업과 관련하여 원 자성이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d162285c691fe9ba58164f60c01d1f90afda5b8d" translate="yes" xml:space="preserve">
          <source>This method gets called when a bound property is changed.</source>
          <target state="translated">바인딩 된 속성이 변경되면이 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e0a919a268cd80181fb6acbf66f00fc444540914" translate="yes" xml:space="preserve">
          <source>This method gets called when a child node is added.</source>
          <target state="translated">이 메소드는 자식 노드가 추가 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9efef61dcaca2310dfb7656d4109520bd8413f" translate="yes" xml:space="preserve">
          <source>This method gets called when a child node is removed.</source>
          <target state="translated">이 메소드는 자식 노드가 제거 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c696073c099d1d3c7484136336e5c0f85bdff14b" translate="yes" xml:space="preserve">
          <source>This method gets called when a constrained property is changed.</source>
          <target state="translated">제한된 속성이 변경되면이 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd1ac397c8871de42362b11036ea73cbe290206" translate="yes" xml:space="preserve">
          <source>This method gets called when a preference is added, removed or when its value is changed.</source>
          <target state="translated">이 메소드는 환경 설정이 추가, 제거 또는 값이 변경 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9c6bfc3827438059a1a5628710ed9ab1b5dbd71f" translate="yes" xml:space="preserve">
          <source>This method has been superseded by the &lt;a href=&quot;filelock#acquiredBy--&quot;&gt;&lt;code&gt;acquiredBy&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 방법에 의해 대체되었습니다 &lt;a href=&quot;filelock#acquiredBy--&quot;&gt; &lt;code&gt;acquiredBy&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="88bebe56fe3ff2e1591dbb7a6b5405ca671ad816" translate="yes" xml:space="preserve">
          <source>This method has the same effect as appending each of the constituent parts directly to this builder surrounded by an &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 둘러싸인 각 구성 요소를이 빌더에 직접 추가하는 것과 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="96db534ebadbf295dac57f668d2d340d0f0dede6" translate="yes" xml:space="preserve">
          <source>This method has the same effect as appending each of the constituent parts of the formatter directly to this builder.</source>
          <target state="translated">이 방법은 포맷터의 각 구성 부분을이 빌더에 직접 추가하는 것과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="51bbeed2db8fef426d1e1af8073829b7c5b2411c" translate="yes" xml:space="preserve">
          <source>This method implements &lt;a href=&quot;dynamicmbean#getMBeanInfo--&quot;&gt;&lt;code&gt;DynamicMBean.getMBeanInfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;dynamicmbean#getMBeanInfo--&quot;&gt; &lt;code&gt;DynamicMBean.getMBeanInfo()&lt;/code&gt; &lt;/a&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="8cfae46a7f5456687b8a16dfbdd9df59a7d55d3a" translate="yes" xml:space="preserve">
          <source>This method implements an entire &lt;a href=&quot;#steps&quot;&gt;decoding operation&lt;/a&gt;; that is, it resets this decoder, then it decodes the bytes in the given byte buffer, and finally it flushes this decoder. This method should therefore not be invoked if a decoding operation is already in progress.</source>
          <target state="translated">이 방법은 전체 &lt;a href=&quot;#steps&quot;&gt;디코딩 작업을&lt;/a&gt; 구현합니다 . 즉,이 디코더를 재설정 한 다음 지정된 바이트 버퍼의 바이트를 디코딩 한 다음이 디코더를 플러시합니다. 따라서 디코딩 작업이 이미 진행중인 경우이 방법을 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4ac9435c198b287b7c60fc48bf877b6db17d492c" translate="yes" xml:space="preserve">
          <source>This method implements an entire &lt;a href=&quot;#steps&quot;&gt;encoding operation&lt;/a&gt;; that is, it resets this encoder, then it encodes the characters in the given character buffer, and finally it flushes this encoder. This method should therefore not be invoked if an encoding operation is already in progress.</source>
          <target state="translated">이 방법은 전체 &lt;a href=&quot;#steps&quot;&gt;인코딩 작업을&lt;/a&gt; 구현합니다 . 즉,이 인코더를 재설정 한 다음 주어진 문자 버퍼에서 문자를 인코딩 한 다음이 인코더를 플러시합니다. 따라서 인코딩 작업이 이미 진행중인 경우이 메서드를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a217daaac530aeb0811702d8e5b97de7db1d9da9" translate="yes" xml:space="preserve">
          <source>This method implements the general contract of the corresponding &lt;code&gt;&lt;a href=&quot;inputstream#read-byte:A-int-int-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;&lt;a href=&quot;inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; class. As an additional convenience, it attempts to read as many bytes as possible by repeatedly invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream. This iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following conditions becomes true:</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&lt;a href=&quot;inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 클래스 의 해당 &lt;code&gt;&lt;a href=&quot;inputstream#read-byte:A-int-int-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드의 일반 계약을 구현합니다 . 추가 편의상, 기본 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드를 반복적으로 호출하여 가능한 많은 바이트를 읽으려고 시도 합니다. 이 반복 &lt;code&gt;read&lt;/code&gt; 는 다음 조건 중 하나에 해당 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="d79db10c8a15dc4c5930fc6d96d770f283377867" translate="yes" xml:space="preserve">
          <source>This method implements the general contract of the corresponding &lt;code&gt;&lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;&lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; class. As an additional convenience, it attempts to read as many characters as possible by repeatedly invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream. This iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following conditions becomes true:</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 클래스 의 해당 &lt;code&gt;&lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드의 일반 계약을 구현합니다 . 추가 편의 를 위해 기본 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드를 반복적으로 호출하여 가능한 많은 문자를 읽으려고 시도 합니다. 이 반복 &lt;code&gt;read&lt;/code&gt; 는 다음 조건 중 하나에 해당 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="bef6cd50581d421dc0e551ac77328ee9c627639c" translate="yes" xml:space="preserve">
          <source>This method indicates to the service provider that it is free to release resources associated with the enumeration, and can notify servers to cancel any outstanding requests. The &lt;code&gt;close()&lt;/code&gt; method is a hint to implementations for managing their resources. Implementations are encouraged to use appropriate algorithms to manage their resources when client omits the &lt;code&gt;close()&lt;/code&gt; calls.</source>
          <target state="translated">이 메서드는 열거와 관련된 리소스를 자유롭게 해제 할 수 있음을 서비스 공급자에게 알리고 미해결 요청을 취소하도록 서버에 알릴 수 있습니다. &lt;code&gt;close()&lt;/code&gt; 메소드는 자신의 자원을 관리하는 구현에의 힌트입니다. 클라이언트가 &lt;code&gt;close()&lt;/code&gt; 호출을 생략 할 때 적절한 알고리즘을 사용하여 리소스를 관리하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2a35fe7383019769b12946558370f4e4eb84750d" translate="yes" xml:space="preserve">
          <source>This method initiates a read of up to</source>
          <target state="translated">이 방법은 최대 읽기를 시작합니다</target>
        </trans-unit>
        <trans-unit id="195dc1ea9cd446d54f70fa3ceb58eae15f2abec4" translate="yes" xml:space="preserve">
          <source>This method initiates a write of up to</source>
          <target state="translated">이 방법은 최대 쓰기를 시작합니다</target>
        </trans-unit>
        <trans-unit id="5b4a146fe1db63f22764c064f29188fc4be633a5" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous operation to accept a connection made to this channel's socket. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when a connection is accepted (or the operation fails). The result passed to the completion handler is the &lt;a href=&quot;asynchronoussocketchannel&quot;&gt;&lt;code&gt;AsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; to the new connection.</source>
          <target state="translated">이 메소드는이 채널의 소켓에 대한 연결을 승인하기 위해 비동기 조작을 시작합니다. &lt;code&gt;handler&lt;/code&gt; 파라미터 연결이 허용된다 (또는 조작이 실패) 때 호출되는 핸들러가 완료된다. 완료 핸들러로 전달 된 결과 는 새 연결에 대한 &lt;a href=&quot;asynchronoussocketchannel&quot;&gt; &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36c77446ccad13303c3b9fd58465698d5f302634" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous operation to accept a connection made to this channel's socket. The method behaves in exactly the same manner as the &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;accept(Object, CompletionHandler)&lt;/code&gt;&lt;/a&gt; method except that instead of specifying a completion handler, this method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the &lt;a href=&quot;asynchronoussocketchannel&quot;&gt;&lt;code&gt;AsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; to the new connection on successful completion.</source>
          <target state="translated">이 메소드는이 채널의 소켓에 대한 연결을 승인하기 위해 비동기 조작을 시작합니다. 이 메소드 는 완료 핸들러를 지정하는 대신 보류중인 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 리턴한다는 점을 제외 하면 &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;accept(Object, CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 방식으로 작동 합니다 . &lt;code&gt;Future&lt;/code&gt; 의는 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 방법 반환 &lt;a href=&quot;asynchronoussocketchannel&quot;&gt; &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 을&lt;/a&gt; 성공적으로 완료에 새 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ee6e1a56838a97e25f3a78eccf440495412459ce" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or &lt;code&gt;-1&lt;/code&gt; if no bytes could be read because the channel has reached end-of-stream.</source>
          <target state="translated">이 메소드는 비동기 읽기 조작을 시작하여이 채널에서 지정된 버퍼로 바이트 시퀀스를 읽습니다. &lt;code&gt;handler&lt;/code&gt; 파라미터는 동작이 완료 될 때 호출 읽기 (혹은 실패)하는 종료 핸들러이다. 완료 핸들러에 전달 된 결과는 읽은 바이트 수 또는 채널이 스트림 끝에 도달하여 읽을 수있는 바이트가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4e5adf06733fe348da70a4c4ad9658c1cbcbd4f" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The method behaves in exactly the same manner as the &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;read(ByteBuffer,Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method except that instead of specifying a completion handler, this method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the number of bytes read or &lt;code&gt;-1&lt;/code&gt; if no bytes could be read because the channel has reached end-of-stream.</source>
          <target state="translated">이 메소드는 비동기 읽기 조작을 시작하여이 채널에서 지정된 버퍼로 바이트 시퀀스를 읽습니다. 이 메소드 는 완료 핸들러를 지정하는 대신 보류중인 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 리턴한다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;read(ByteBuffer,Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 방식으로 작동 합니다 . &lt;code&gt;Future&lt;/code&gt; 의는 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메서드가 반환 바이트 수를 읽거나 &lt;code&gt;-1&lt;/code&gt; 채널이 스트림의 마지막에 도달 때문에 바이트를 읽어 들일 수 있다면.</target>
        </trans-unit>
        <trans-unit id="884f1eed34505d79db8e140611a1bda7f4feda2c" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written.</source>
          <target state="translated">이 메소드는 비동기 쓰기 조작을 시작하여 지정된 버퍼에서이 채널에 바이트 시퀀스를 기록합니다. &lt;code&gt;handler&lt;/code&gt; 파라미터는 기록 동작이 완료 (또는 실패) 때 호출되는 핸들러가 완료된다. 완료 핸들러에 전달 된 결과는 쓴 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="425dcdb9947c1226ce9e013431356c819774a519" translate="yes" xml:space="preserve">
          <source>This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The method behaves in exactly the same manner as the &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;write(ByteBuffer,Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method except that instead of specifying a completion handler, this method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the number of bytes written.</source>
          <target state="translated">이 메소드는 비동기 쓰기 조작을 시작하여 지정된 버퍼에서이 채널에 바이트 시퀀스를 기록합니다. 이 메소드 는 완료 핸들러를 지정하는 대신 보류중인 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 리턴한다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;write(ByteBuffer,Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 방식으로 작동 합니다 . &lt;code&gt;Future&lt;/code&gt; 의 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 방법은 기록 된 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d69bc96e539dc381a9fbbd2f36f985610a68eafc" translate="yes" xml:space="preserve">
          <source>This method initiates an operation to acquire a lock on the given region of this channel's file. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the lock is acquired (or the operation fails). The result passed to the completion handler is the resulting &lt;code&gt;FileLock&lt;/code&gt;.</source>
          <target state="translated">이 방법은이 채널 파일의 지정된 영역에서 잠금을 획득하는 작업을 시작합니다. &lt;code&gt;handler&lt;/code&gt; 파라미터는 로크가 획득된다 (또는 조작이 실패) 때 호출되는 핸들러가 완료된다. 완료 핸들러에 전달 된 결과는 결과 &lt;code&gt;FileLock&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ade494af179c7fa5dd56b70c37320ff095534a3d" translate="yes" xml:space="preserve">
          <source>This method initiates an operation to acquire a lock on the given region of this channel's file. The method behaves in exactly the same manner as the &lt;a href=&quot;asynchronousfilechannel#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;lock(long, long, boolean, Object, CompletionHandler)&lt;/code&gt;&lt;/a&gt; method except that instead of specifying a completion handler, this method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the &lt;a href=&quot;filelock&quot;&gt;&lt;code&gt;FileLock&lt;/code&gt;&lt;/a&gt; on successful completion.</source>
          <target state="translated">이 방법은이 채널 파일의 지정된 영역에서 잠금을 획득하는 작업을 시작합니다. 이 메소드 는 완료 핸들러를 지정하는 대신 보류중인 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 리턴한다는 점을 제외하고 &lt;a href=&quot;asynchronousfilechannel#lock-long-long-boolean-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;lock(long, long, boolean, Object, CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 방식으로 작동 합니다 . &lt;code&gt;Future&lt;/code&gt; 의 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;filelock&quot;&gt; &lt;code&gt;FileLock&lt;/code&gt; &lt;/a&gt; 성공적인 완료에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8efe04b7e4bd5e33dc579eaa5a2c7ba89e20c9d8" translate="yes" xml:space="preserve">
          <source>This method initiates an operation to acquire an exclusive lock on this channel's file. The method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result of the operation. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the &lt;a href=&quot;filelock&quot;&gt;&lt;code&gt;FileLock&lt;/code&gt;&lt;/a&gt; on successful completion.</source>
          <target state="translated">이 메소드는이 채널 파일에 대한 독점 잠금을 획득하기위한 조작을 시작합니다. 이 메소드는 보류중인 작업 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 반환 합니다. &lt;code&gt;Future&lt;/code&gt; 의 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;filelock&quot;&gt; &lt;code&gt;FileLock&lt;/code&gt; &lt;/a&gt; 성공적인 완료에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccec9e8297a340fc281d8a33e5acb34845e0008f" translate="yes" xml:space="preserve">
          <source>This method initiates an operation to connect this channel. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the connection is successfully established or connection cannot be established. If the connection cannot be established then the channel is closed.</source>
          <target state="translated">이 방법은이 채널을 연결하는 작업을 시작합니다. &lt;code&gt;handler&lt;/code&gt; 매개 변수는 성공적으로 연결하거나 연결을 설정할 수없는 때 호출되는 완료 핸들러입니다. 연결을 설정할 수 없으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="fa8f92f210402ec46afc6ff1e5c2f4ed013064dd" translate="yes" xml:space="preserve">
          <source>This method initiates an operation to connect this channel. This method behaves in exactly the same manner as the &lt;a href=&quot;asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;connect(SocketAddress, Object, CompletionHandler)&lt;/code&gt;&lt;/a&gt; method except that instead of specifying a completion handler, this method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns &lt;code&gt;null&lt;/code&gt; on successful completion.</source>
          <target state="translated">이 방법은이 채널을 연결하는 작업을 시작합니다. 이 메소드 는 완료 핸들러를 지정하는 대신 보류중인 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 리턴한다는 점을 제외 하면 &lt;a href=&quot;asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;connect(SocketAddress, Object, CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 방식으로 작동 합니다 . &lt;code&gt;Future&lt;/code&gt; 의 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; 을 성공적으로 완료에.</target>
        </trans-unit>
        <trans-unit id="30130f900e70b9de0cdf13b5d4484fc27d0cf423" translate="yes" xml:space="preserve">
          <source>This method initiates the reading of a sequence of bytes from this channel into the given buffer, starting at the given file position. The result of the read is the number of bytes read or &lt;code&gt;-1&lt;/code&gt; if the given position is greater than or equal to the file's size at the time that the read is attempted.</source>
          <target state="translated">이 방법은 주어진 파일 위치에서 시작하여이 채널에서 주어진 버퍼로의 바이트 시퀀스 읽기를 시작합니다. 읽은 결과는 읽은 바이트 수 또는 지정된 위치가 읽은 시간에 파일 크기보다 크거나 같은 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3264d07d05d29bee8f76107fdf7105ffffe704b" translate="yes" xml:space="preserve">
          <source>This method initiates the reading of a sequence of bytes from this channel into the given buffer, starting at the given file position. This method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result of the operation. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the number of bytes read or &lt;code&gt;-1&lt;/code&gt; if the given position is greater than or equal to the file's size at the time that the read is attempted.</source>
          <target state="translated">이 방법은 주어진 파일 위치에서 시작하여이 채널에서 주어진 버퍼로의 바이트 시퀀스 읽기를 시작합니다. 이 메소드는 보류중인 작업 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 반환 합니다. &lt;code&gt;Future&lt;/code&gt; 의는 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메서드가 반환하는 바이트 수를 읽거나 &lt;code&gt;-1&lt;/code&gt; 주어진 위치 또는 읽기가 시도되는 시간에 파일의 크기와 동일보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="4c8aa12f9311f3afdff1963436aba815aca9a681" translate="yes" xml:space="preserve">
          <source>This method initiates the writing of a sequence of bytes to this channel from the given buffer, starting at the given file position. The method returns a &lt;code&gt;Future&lt;/code&gt; representing the pending result of the write operation. The &lt;code&gt;Future&lt;/code&gt;'s &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method returns the number of bytes written.</source>
          <target state="translated">이 메소드는 주어진 파일 위치에서 시작하여 주어진 버퍼에서이 채널에 바이트 시퀀스 쓰기를 시작합니다. 이 메소드는 쓰기 작업의 보류 결과를 나타내는 &lt;code&gt;Future&lt;/code&gt; 를 반환 합니다. &lt;code&gt;Future&lt;/code&gt; 의 &lt;a href=&quot;../../util/concurrent/future#get--&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 방법은 기록 된 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46a4338713f2d071fd29cd8ad8a5faced93b314e" translate="yes" xml:space="preserve">
          <source>This method instructs the bean that it is OK to use the Gui.</source>
          <target state="translated">이 메소드는 Bean에 Gui를 사용하는 것이 좋다고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="d03ba6b1925fc9e4d5bdab71fe41aa59137b4d30" translate="yes" xml:space="preserve">
          <source>This method instructs the bean that it should not use the Gui.</source>
          <target state="translated">이 메소드는 Bean에 Gui를 사용해서는 안된다고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="eeff678a91716b0a42e47201bdbc4ceb988bbbf1" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetdecoder#implFlush-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;implFlush&lt;/code&gt;&lt;/a&gt; method to perform the actual flushing operation.</source>
          <target state="translated">이 메소드는 실제 플러시 조작을 수행하기 위해 &lt;a href=&quot;charsetdecoder#implFlush-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;implFlush&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc4bc54886d6e859dfb0a0349c595e5484237ea" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetdecoder#implOnMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;implOnMalformedInput&lt;/code&gt;&lt;/a&gt; method, passing the new action.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetdecoder#implOnMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;implOnMalformedInput&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 새 조치를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9382f3d508bb3cdc2b89496be0a551dc47ca8836" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetdecoder#implOnUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;implOnUnmappableCharacter&lt;/code&gt;&lt;/a&gt; method, passing the new action.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetdecoder#implOnUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;implOnUnmappableCharacter&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 새 조치를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="31054bfe51b35fcc9c6c84d577625707b866633a" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetdecoder#implReplaceWith-java.lang.String-&quot;&gt;&lt;code&gt;implReplaceWith&lt;/code&gt;&lt;/a&gt; method, passing the new replacement, after checking that the new replacement is acceptable.</source>
          <target state="translated">이 메소드는 새 교체가 허용 &lt;a href=&quot;charsetdecoder#implReplaceWith-java.lang.String-&quot;&gt; &lt;code&gt;implReplaceWith&lt;/code&gt; &lt;/a&gt; 확인한 후 implReplaceWith 메소드를 호출하여 새 교체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5c104f7fb6d4a6bc7f7c359da6bb8e5370594817" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetencoder#implFlush-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;implFlush&lt;/code&gt;&lt;/a&gt; method to perform the actual flushing operation.</source>
          <target state="translated">이 메소드는 실제 플러시 조작을 수행하기 위해 &lt;a href=&quot;charsetencoder#implFlush-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;implFlush&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1d68eb989e6b2cec48fb1d9608b53360e33c5501" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetencoder#implOnMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;implOnMalformedInput&lt;/code&gt;&lt;/a&gt; method, passing the new action.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetencoder#implOnMalformedInput-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;implOnMalformedInput&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 새 조치를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="afd6d10a1b1e6193932849b08ddb519274872dcb" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetencoder#implOnUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;&lt;code&gt;implOnUnmappableCharacter&lt;/code&gt;&lt;/a&gt; method, passing the new action.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetencoder#implOnUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt; &lt;code&gt;implOnUnmappableCharacter&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 새 조치를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0b72b131850d9b320a093c2e3604e8be32c2042c" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;charsetencoder#implReplaceWith-byte:A-&quot;&gt;&lt;code&gt;implReplaceWith&lt;/code&gt;&lt;/a&gt; method, passing the new replacement, after checking that the new replacement is acceptable.</source>
          <target state="translated">이 메소드는 새 교체가 허용 &lt;a href=&quot;charsetencoder#implReplaceWith-byte:A-&quot;&gt; &lt;code&gt;implReplaceWith&lt;/code&gt; &lt;/a&gt; 확인한 후 implReplaceWith 메소드를 호출하여 새 교체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ad0ffa02b5be5094d7b4978dfaa39f5914c1520b" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;a href=&quot;filelock#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method. It was added to the class so that it could be used in conjunction with the automatic resource management block construct.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;filelock#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 . 자동 자원 관리 블록 구성과 함께 사용될 수 있도록 클래스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d38c44073f00644ab9b57c3ea55d3a7eda2d72b" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;code&gt;doFinal&lt;/code&gt; method of the encapsulated cipher object, which causes any bytes buffered by the encapsulated cipher to be processed. The result is written out by calling the &lt;code&gt;flush&lt;/code&gt; method of this output stream.</source>
          <target state="translated">이 메소드는 캡슐화 된 암호 오브젝트 의 &lt;code&gt;doFinal&lt;/code&gt; 메소드를 호출하여 캡슐화 된 암호로 버퍼링 된 바이트를 처리합니다. 이 출력 스트림 의 &lt;code&gt;flush&lt;/code&gt; 메소드를 호출 해 결과를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1bdb46a893dfa0483a9c4bd9290f9f4065057bd2" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;code&gt;login&lt;/code&gt; method for each LoginModule configured for the</source>
          <target state="translated">이 메소드는 에 대해 구성된 각 LoginModule에 대한 &lt;code&gt;login&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="945890c31957c102b30f2abb295e38f3d7c96e8d" translate="yes" xml:space="preserve">
          <source>This method invokes the &lt;code&gt;logout&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; configured for this &lt;code&gt;LoginContext&lt;/code&gt;. Each &lt;code&gt;LoginModule&lt;/code&gt; performs its respective logout procedure which may include removing/destroying &lt;code&gt;Principal&lt;/code&gt; and &lt;code&gt;Credential&lt;/code&gt; information from the &lt;code&gt;Subject&lt;/code&gt; and state cleanup.</source>
          <target state="translated">이 메소드는 이 &lt;code&gt;LoginContext&lt;/code&gt; 에 대해 구성된 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대해 &lt;code&gt;logout&lt;/code&gt; 메소드를 호출합니다 . 각 &lt;code&gt;LoginModule&lt;/code&gt; / 제거 파괴 포함 각각의 로그 아웃 절차를 수행하는 &lt;code&gt;Principal&lt;/code&gt; 및 &lt;code&gt;Credential&lt;/code&gt; 로부터 정보 &lt;code&gt;Subject&lt;/code&gt; 및 상태 정리.</target>
        </trans-unit>
        <trans-unit id="fdb1880895c894bfd297246b1aa1118ff40e8627" translate="yes" xml:space="preserve">
          <source>This method is a synonym for &lt;a href=&quot;imageoutputstream#writeShort-int-&quot;&gt;&lt;code&gt;writeShort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;imageoutputstream#writeShort-int-&quot;&gt; &lt;code&gt;writeShort&lt;/code&gt; 와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="a5cc06003433eebab8325177aa608d991144029e" translate="yes" xml:space="preserve">
          <source>This method is a way to explicitly initiate an LDAP &quot;bind&quot; operation. For example, you can use this method to set request controls for the LDAP &quot;bind&quot; operation, or to explicitly connect to the server to get response controls returned by the LDAP &quot;bind&quot; operation.</source>
          <target state="translated">이 방법은 LDAP &quot;바인드&quot;작업을 명시 적으로 시작하는 방법입니다. 예를 들어,이 방법을 사용하여 LDAP &quot;바인드&quot;조작에 대한 요청 제어를 설정하거나 LDAP &quot;바인드&quot;조작으로 리턴 된 응답 제어를 얻기 위해 서버에 명시 적으로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f682cfd7ed488d6df08e1bbda8fd4a9615756c5f" translate="yes" xml:space="preserve">
          <source>This method is also equivalent to the following code:</source>
          <target state="translated">이 방법은 다음 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="026f6f13a19bcd38af6d3577b7bac7af7a220278" translate="yes" xml:space="preserve">
          <source>This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread.</source>
          <target state="translated">이 메소드는 항상 획득을 수행하는 스레드에 의해 호출됩니다. 이 메소드가 실패를보고하는 경우, 획득 메소드는 스레드가 아직 큐에없는 경우 다른 스레드의 릴리스에서 신호를 보낼 때까지 큐를 대기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="854e9e724162b78faf1d56eae1beffd001d61340" translate="yes" xml:space="preserve">
          <source>This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread. This can be used to implement method &lt;a href=&quot;lock#tryLock--&quot;&gt;&lt;code&gt;Lock.tryLock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 항상 획득을 수행하는 스레드에 의해 호출됩니다. 이 메소드가 실패를보고하는 경우, 취득 메소드는 스레드가 아직 큐에없는 경우 다른 스레드의 릴리스에 의해 신호를 보낼 때까지 큐를 대기 할 수 있습니다. &lt;a href=&quot;lock#tryLock--&quot;&gt; &lt;code&gt;Lock.tryLock()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c66c1667c9809f5bac5c98e29f63d17cebc866ae" translate="yes" xml:space="preserve">
          <source>This method is always invoked by the thread performing release.</source>
          <target state="translated">이 메소드는 항상 릴리스를 수행하는 스레드에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2837baf09f33244695dcef0eb90a4fa45160bf" translate="yes" xml:space="preserve">
          <source>This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. If the preferences at this node are modified concurrently with an invocation of this method, the exported preferences comprise a &quot;fuzzy snapshot&quot; of the preferences contained in the node; some of the concurrent modifications may be reflected in the exported data while others may not.</source>
          <target state="translated">이 메소드는이 클래스에서 여러 메소드를 동시에 실행 한 결과가 일부 직렬 실행과 동등한 결과를 생성한다는 일반 규칙의 예외입니다. 이 노드의 환경 설정이이 메소드의 호출과 동시에 수정되는 경우, 내 보낸 환경 설정은 노드에 포함 된 환경 설정의 &quot;퍼지 스냅 샷&quot;을 포함합니다. 동시 수정 중 일부는 내 보낸 데이터에 반영 될 수 있지만 나머지는 수정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64dc8b5021c31bbaac7e73e665736fe1345660d5" translate="yes" xml:space="preserve">
          <source>This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. If the preferences or nodes in the subtree rooted at this node are modified concurrently with an invocation of this method, the exported preferences comprise a &quot;fuzzy snapshot&quot; of the subtree; some of the concurrent modifications may be reflected in the exported data while others may not.</source>
          <target state="translated">이 메소드는이 클래스에서 여러 메소드를 동시에 실행 한 결과가 일부 직렬 실행과 동등한 결과를 생성한다는 일반 규칙의 예외입니다. 이 노드를 기반으로하는 서브 트리의 환경 설정 또는 노드가이 메소드의 호출과 동시에 수정되는 경우, 내 보낸 환경 설정은 서브 트리의 &quot;퍼지 스냅 샷&quot;을 포함합니다. 동시 수정 중 일부는 내 보낸 데이터에 반영 될 수 있지만 나머지는 수정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21fb541cdce5155c0679500a74475ea5393d42c3" translate="yes" xml:space="preserve">
          <source>This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. The method behaves as if implemented on top of the other public methods in this class, notably &lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt;&lt;code&gt;node(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;put(String, String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는이 클래스에서 여러 메소드를 동시에 실행 한 결과가 일부 직렬 실행과 동등한 결과를 생성한다는 일반 규칙의 예외입니다. 이 메소드는이 클래스의 다른 공용 메소드, 특히 &lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt; &lt;code&gt;node(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;put(String, String)&lt;/code&gt; &lt;/a&gt; 위에서 구현 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e8542852fa3bffcff27089b4783d473c11ff3d44" translate="yes" xml:space="preserve">
          <source>This method is based on retaining the same instant, thus gaps and overlaps in the local time-line have no effect on the result.</source>
          <target state="translated">이 방법은 동일한 순간을 유지하는 것을 기반으로하므로 로컬 타임 라인의 간격과 겹침은 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7ba826bf2926f9d34022ed208953d3cd0c31bdc" translate="yes" xml:space="preserve">
          <source>This method is called after an object has been read but before it is returned from readObject. The default resolveObject method just returns the same object.</source>
          <target state="translated">이 메소드는 오브젝트를 읽은 후 readObject에서 리턴하기 전에 호출됩니다. 기본 resolveObject 메소드는 동일한 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="79425ac1087fb3dd51e651191d4533cb7b19b8da" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; for each listener in order to send the notification to that listener. It can be overridden in subclasses to change the behavior of notification delivery, for instance to deliver the notification in a separate thread.</source>
          <target state="translated">이 메소드는 통지를 해당 리스너에게 보내기 위해 각 리스너에 대해 &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; 에 의해 호출됩니다 . 알림 전달 동작을 변경하기 위해 서브 클래스에서 재정의 할 수 있습니다 (예 : 별도의 스레드에서 알림을 전달하기 위해).</target>
        </trans-unit>
        <trans-unit id="1ee68b73f449a54624673c8c02a1a403a8f6e744" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanAttributeInfo-&quot;&gt;&lt;code&gt;getDescription(MBeanAttributeInfo)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanOperationInfo-&quot;&gt;&lt;code&gt;getDescription(MBeanOperationInfo)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanConstructorInfo-&quot;&gt;&lt;code&gt;getDescription(MBeanConstructorInfo)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanAttributeInfo-&quot;&gt; &lt;code&gt;getDescription(MBeanAttributeInfo)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanOperationInfo-&quot;&gt; &lt;code&gt;getDescription(MBeanOperationInfo)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardmbean#getDescription-javax.management.MBeanConstructorInfo-&quot;&gt; &lt;code&gt;getDescription(MBeanConstructorInfo)&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3de0b2e3cdbdaf07c4fa04462cd483d787e7bcde" translate="yes" xml:space="preserve">
          <source>This method is called by the &lt;code&gt;LoginContext&lt;/code&gt; after this &lt;code&gt;LoginModule&lt;/code&gt; has been instantiated. The purpose of this method is to initialize this &lt;code&gt;LoginModule&lt;/code&gt; with the relevant information. If this &lt;code&gt;LoginModule&lt;/code&gt; does not understand any of the data stored in &lt;code&gt;sharedState&lt;/code&gt; or &lt;code&gt;options&lt;/code&gt; parameters, they can be ignored.</source>
          <target state="translated">이 메소드는 이 &lt;code&gt;LoginModule&lt;/code&gt; 이 인스턴스화 된 후에 &lt;code&gt;LoginContext&lt;/code&gt; 에 의해 호출됩니다 . 이 방법의 목적은 관련 정보를 사용 하여이 &lt;code&gt;LoginModule&lt;/code&gt; 을 초기화하는 것입니다 . 이 &lt;code&gt;LoginModule&lt;/code&gt; 이 &lt;code&gt;sharedState&lt;/code&gt; 또는 &lt;code&gt;options&lt;/code&gt; 매개 변수에 저장된 데이터를 이해하지 못하면 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e11ab4932ac374e31fa0b944a33cd4ccc0325ce4" translate="yes" xml:space="preserve">
          <source>This method is called by the &lt;code&gt;clear&lt;/code&gt; operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can</source>
          <target state="translated">이 메소드는 이리스트 및 해당 서브리스트 에 대한 &lt;code&gt;clear&lt;/code&gt; 조작으로 호출됩니다 . 리스트 구현의 내부를 이용하기 위해이 메소드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07cced3d72aa75fe15d69546e9ed868a56713ecf" translate="yes" xml:space="preserve">
          <source>This method is called by trusted subclasses of ObjectOutputStream that constructed ObjectOutputStream using the protected no-arg constructor. The subclass is expected to provide an override method with the modifier &quot;final&quot;.</source>
          <target state="translated">이 메소드는, 인수 없음의 protected 생성자를 사용해 ObjectOutputStream를 구축 한 ObjectOutputStream의 신뢰할 수있는 서브 클래스에 의해 불려갑니다. 서브 클래스는 수정 자 &quot;final&quot;을 갖는 대체 메소드를 제공 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0d0e648fcdb59d9e3a7ce6bcb5edadfe481a4723" translate="yes" xml:space="preserve">
          <source>This method is called exactly once for each unique proxy class descriptor in the stream.</source>
          <target state="translated">이 메소드는 스트림의 각 고유 프록시 클래스 설명자에 대해 정확히 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4902d3756b01e69bda499308c33de60ca1a4f179" translate="yes" xml:space="preserve">
          <source>This method is called exactly once for each unique proxy class descriptor in the stream. The default implementation of this method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.</source>
          <target state="translated">이 메소드는 스트림의 각 고유 프록시 클래스 디스크립터에 대해 정확히 한 번 호출됩니다. &lt;code&gt;ObjectOutputStream&lt;/code&gt; 에서이 메소드의 기본 구현 은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f62861d342032164149b4be32e3cdb512c31df69" translate="yes" xml:space="preserve">
          <source>This method is called if the LoginContext's overall authentication failed. (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed).</source>
          <target state="translated">LoginContext의 전체 인증에 실패한 경우이 메소드가 호출됩니다. (필요한 필수, 필수, 충분하고 선택적인 로그인 모듈이 성공하지 못했습니다).</target>
        </trans-unit>
        <trans-unit id="d7098aa1df43974ecddcceb11655f6df1d3b3f56" translate="yes" xml:space="preserve">
          <source>This method is called if the LoginContext's overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules succeeded).</source>
          <target state="translated">LoginContext의 전체 인증에 성공하면 (관련된 REQUIRED, REQUISITE, SUFFICIENT 및 OPTIONAL LoginModule이 성공한 경우)이 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c368290535afffaa4821caf905a0e01d5eba0b7" translate="yes" xml:space="preserve">
          <source>This method is called only once when each object is first encountered. All subsequent references to the object will be redirected to the new object.</source>
          <target state="translated">이 메소드는 각 오브젝트가 처음 발견 될 때 한 번만 호출됩니다. 객체에 대한 모든 후속 참조는 새 객체로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="33de51ae564d5ca1f29b4fe2db0bfe64dafb039f" translate="yes" xml:space="preserve">
          <source>This method is called only once when each object is first encountered. All subsequent references to the object will be redirected to the new object. This method should return the object to be substituted or the original object.</source>
          <target state="translated">이 메소드는 각 오브젝트가 처음 발견 될 때 한 번만 호출됩니다. 객체에 대한 모든 후속 참조는 새 객체로 리디렉션됩니다. 이 메소드는 대체 할 오브젝트 또는 원래 오브젝트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7ddcda585d8eb0c34c43752ae7410aca0f78d51" translate="yes" xml:space="preserve">
          <source>This method is called when a recoverable exception has been caught.</source>
          <target state="translated">이 메소드는 복구 가능한 예외가 발생했을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9cca6ab3d4da2b086f82ba0002c0396f03a4b119" translate="yes" xml:space="preserve">
          <source>This method is called whenever the observed object is changed. An application calls an &lt;code&gt;Observable&lt;/code&gt; object's &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's observers notified of the change.</source>
          <target state="translated">이 메소드는 관찰 된 객체가 변경 될 때마다 호출됩니다. 응용 프로그램은 &lt;code&gt;Observable&lt;/code&gt; 객체의 &lt;code&gt;notifyObservers&lt;/code&gt; 메서드를 호출하여 모든 객체의 관찰자에게 변경 사항을 알립니다.</target>
        </trans-unit>
        <trans-unit id="fffb1c56a63b52b2e43abc2fb4153ff4c28cc913" translate="yes" xml:space="preserve">
          <source>This method is caller sensitive, which means that it may return different values to different callers.</source>
          <target state="translated">이 방법은 호출자에 민감하므로 다른 호출자에게 다른 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e1c5173e7f3fa222c06c11b3cc371c7b3d31b73" translate="yes" xml:space="preserve">
          <source>This method is defined as:</source>
          <target state="translated">이 방법은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ae19898917349a14a11291ce84b8e211a3d13306" translate="yes" xml:space="preserve">
          <source>This method is defined for compatibility with &lt;code&gt;java.util.Random&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;java.util.Random&lt;/code&gt; 과의 호환성을 위해 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bf2642771743581deaaba7d7e735661a814734f8" translate="yes" xml:space="preserve">
          <source>This method is defined so that performance-sensitive Java code can allocate direct buffers with the same byte order as the hardware. Native code libraries are often more efficient when such buffers are used.</source>
          <target state="translated">이 방법은 성능에 민감한 Java 코드가 하드웨어와 동일한 바이트 순서로 직접 버퍼를 할당 할 수 있도록 정의됩니다. 이러한 버퍼를 사용할 때 기본 코드 라이브러리가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="aa45c2b02a519a2f2aaaeb85a745efe28f883b9c" translate="yes" xml:space="preserve">
          <source>This method is defined so that the &lt;code&gt;String&lt;/code&gt; class can implement the &lt;a href=&quot;charsequence&quot;&gt;&lt;code&gt;CharSequence&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는 &lt;code&gt;String&lt;/code&gt; 클래스가 &lt;a href=&quot;charsequence&quot;&gt; &lt;code&gt;CharSequence&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현할 수 있도록 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="fe5b6f57087b04e0bc121233831d03f60237e3e6" translate="yes" xml:space="preserve">
          <source>This method is designed for troubleshooting use, but not for synchronization control. It might be an expensive operation.</source>
          <target state="translated">이 방법은 문제 해결 용도로 설계되었지만 동기화 제어에는 적합하지 않습니다. 비용이 많이 드는 작업 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b65be200e753f327578c45c2734dd4d51b4756f" translate="yes" xml:space="preserve">
          <source>This method is designed for use in monitoring system memory usage and detecting low memory condition.</source>
          <target state="translated">이 방법은 시스템 메모리 사용량 모니터링 및 메모리 부족 상태 감지에 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d3f0f88baf42118de72db535c5af7f9c932197f" translate="yes" xml:space="preserve">
          <source>This method is designed to allow a program to assert that the current thread already holds a specified lock:</source>
          <target state="translated">이 메소드는 프로그램이 현재 스레드가 이미 지정된 잠금을 보유하고 있다고 주장하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="a685d5c3b4c812a26f26b2438180d21020a9a02c" translate="yes" xml:space="preserve">
          <source>This method is designed to be invoked by &lt;em&gt;other&lt;/em&gt; tasks. To terminate the current task, you can just return or throw an unchecked exception from its computation method, or invoke &lt;a href=&quot;forkjointask#completeExceptionally-java.lang.Throwable-&quot;&gt;&lt;code&gt;completeExceptionally(Throwable)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;em&gt;다른&lt;/em&gt; 작업에 의해 호출되도록 설계되었습니다 . 현재 작업을 종료하려면 계산 방법에서 확인되지 않은 예외를 반환하거나 throw하거나 &lt;a href=&quot;forkjointask#completeExceptionally-java.lang.Throwable-&quot;&gt; &lt;code&gt;completeExceptionally(Throwable)&lt;/code&gt; &lt;/a&gt; 호출하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="74ee81fb970e8086cdb6cbd89cb3cb795e9c4467" translate="yes" xml:space="preserve">
          <source>This method is designed to be used by a fair synchronizer to avoid &lt;a href=&quot;abstractqueuedsynchronizer#barging&quot;&gt;barging&lt;/a&gt;. Such a synchronizer's &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt;&lt;code&gt;tryAcquire(long)&lt;/code&gt;&lt;/a&gt; method should return &lt;code&gt;false&lt;/code&gt;, and its &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt;&lt;code&gt;tryAcquireShared(long)&lt;/code&gt;&lt;/a&gt; method should return a negative value, if this method returns &lt;code&gt;true&lt;/code&gt; (unless this is a reentrant acquire). For example, the &lt;code&gt;tryAcquire&lt;/code&gt; method for a fair, reentrant, exclusive mode synchronizer might look like this:</source>
          <target state="translated">이 방법은 피하기 위해 공정한 동기에 의해 사용할 수 있도록 설계 &lt;a href=&quot;abstractqueuedsynchronizer#barging&quot;&gt;화물 운반선을&lt;/a&gt; . 이러한 동기의 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt; &lt;code&gt;tryAcquire(long)&lt;/code&gt; &lt;/a&gt; 방법은 반환해야 &lt;code&gt;false&lt;/code&gt; , 그 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt; &lt;code&gt;tryAcquireShared(long)&lt;/code&gt; &lt;/a&gt; , 방법은 음의 값을 반환해야하는 경우이 방법을 반환 &lt;code&gt;true&lt;/code&gt; (이 재진입 획득하지 않는 한). 예를 들어, 공정하고 재진입 가능한 독점 모드 동기화 기 의 &lt;code&gt;tryAcquire&lt;/code&gt; 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b59e8c2df3bab79c2fe16e6644745f396fb521c8" translate="yes" xml:space="preserve">
          <source>This method is designed to be used by a fair synchronizer to avoid &lt;a href=&quot;abstractqueuedsynchronizer#barging&quot;&gt;barging&lt;/a&gt;. Such a synchronizer's &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt;&lt;code&gt;tryAcquire(int)&lt;/code&gt;&lt;/a&gt; method should return &lt;code&gt;false&lt;/code&gt;, and its &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;&lt;/a&gt; method should return a negative value, if this method returns &lt;code&gt;true&lt;/code&gt; (unless this is a reentrant acquire). For example, the &lt;code&gt;tryAcquire&lt;/code&gt; method for a fair, reentrant, exclusive mode synchronizer might look like this:</source>
          <target state="translated">이 방법은 피하기 위해 공정한 동기에 의해 사용할 수 있도록 설계 &lt;a href=&quot;abstractqueuedsynchronizer#barging&quot;&gt;화물 운반선을&lt;/a&gt; . 이러한 동기의 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt; &lt;code&gt;tryAcquire(int)&lt;/code&gt; &lt;/a&gt; 방법은 반환해야 &lt;code&gt;false&lt;/code&gt; , 그 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt; &lt;code&gt;tryAcquireShared(int)&lt;/code&gt; &lt;/a&gt; , 방법은 음의 값을 반환해야하는 경우이 방법을 반환 &lt;code&gt;true&lt;/code&gt; (이 재진입 획득하지 않는 한). 예를 들어, 공정하고 재진입 가능한 독점 모드 동기화 기 의 &lt;code&gt;tryAcquire&lt;/code&gt; 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fccbd3e6989670e486a81b6121525638bef59a71" translate="yes" xml:space="preserve">
          <source>This method is designed to provide a hint about the system load and may be queried frequently. The load average may be unavailable on some platform where it is expensive to implement this method.</source>
          <target state="translated">이 방법은 시스템로드에 대한 힌트를 제공하도록 설계되었으며 자주 쿼리 될 수 있습니다. 이 방법을 구현하는 데 비용이 많이 드는 일부 플랫폼에서는로드 평균을 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f36f108ff8beab249af70da0aac7e6ec0abfce" translate="yes" xml:space="preserve">
          <source>This method is equivalent to</source>
          <target state="translated">이 방법은</target>
        </trans-unit>
        <trans-unit id="59627a0a952b2c96182d0298341a95db1edd5251" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../../java/lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt;&lt;code&gt;Proxy.newProxyInstance&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(interfaceClass.getClassLoader(),
 interfaces, handler)&lt;/code&gt;. Here &lt;code&gt;handler&lt;/code&gt; is the result of &lt;a href=&quot;mbeanserverinvocationhandler#MBeanServerInvocationHandler-javax.management.MBeanServerConnection-javax.management.ObjectName-boolean-&quot;&gt;&lt;code&gt;new
 MBeanServerInvocationHandler(connection, objectName)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;interfaces&lt;/code&gt; is an array that has one element if &lt;code&gt;notificationBroadcaster&lt;/code&gt; is false and two if it is true. The first element of &lt;code&gt;interfaces&lt;/code&gt; is &lt;code&gt;interfaceClass&lt;/code&gt; and the second, if present, is &lt;code&gt;NotificationEmitter.class&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../java/lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt; &lt;code&gt;Proxy.newProxyInstance&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(interfaceClass.getClassLoader(), interfaces, handler)&lt;/code&gt; 합니다. 여기서 &lt;code&gt;handler&lt;/code&gt; 는 &lt;a href=&quot;mbeanserverinvocationhandler#MBeanServerInvocationHandler-javax.management.MBeanServerConnection-javax.management.ObjectName-boolean-&quot;&gt; &lt;code&gt;new MBeanServerInvocationHandler(connection, objectName)&lt;/code&gt; &lt;/a&gt; 의 결과이며 , &lt;code&gt;interfaces&lt;/code&gt; 는 &lt;code&gt;notificationBroadcaster&lt;/code&gt; 가 false이면 true이고, 2이면 true 인 요소를 갖는 배열입니다 . 첫 번째 요소 &lt;code&gt;interfaces&lt;/code&gt; 이다 &lt;code&gt;interfaceClass&lt;/code&gt; 및 제 존재하는 경우이다 &lt;code&gt;NotificationEmitter.class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41b871bbf5ed8b253ef9f92469346969fa3beca5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#addFirst-E-&quot;&gt;&lt;code&gt;Deque.addFirst(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#addFirst-E-&quot;&gt; &lt;code&gt;Deque.addFirst(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2dcee12da93abc3c7af5ad4ce14c0019e041a784" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#getFirst--&quot;&gt;&lt;code&gt;Deque.getFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#getFirst--&quot;&gt; &lt;code&gt;Deque.getFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="745e5cfa13c0d688770b3801419f42026f19e039" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#getFirst--&quot;&gt;&lt;code&gt;getFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#getFirst--&quot;&gt; &lt;code&gt;getFirst&lt;/code&gt; &lt;/a&gt; 와 동등 합니다 .</target>
        </trans-unit>
        <trans-unit id="c382bb82fc2e86926ecec5c28b84071b57312910" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#peekFirst--&quot;&gt;&lt;code&gt;Deque.peekFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#peekFirst--&quot;&gt; &lt;code&gt;Deque.peekFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0631034b9db85350b6d3a5a0b58236179b145fe8" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#peekFirst--&quot;&gt;&lt;code&gt;peekFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;../deque#peekFirst--&quot;&gt; &lt;code&gt;peekFirst&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6d08a898f9783931fa0e55d9366a8934ed8f7cb8" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#pollFirst--&quot;&gt;&lt;code&gt;Deque.pollFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#pollFirst--&quot;&gt; &lt;code&gt;Deque.pollFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b38d19681d4dc401a29728e6d548c221f5bcb79a" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#removeFirst--&quot;&gt;&lt;code&gt;Deque.removeFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#removeFirst--&quot;&gt; &lt;code&gt;Deque.removeFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="40f5c20b5451ca28023239544a541050d97c7b30" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;../deque#removeFirst--&quot;&gt;&lt;code&gt;removeFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../deque#removeFirst--&quot;&gt; &lt;code&gt;removeFirst&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f0366b7f34e5dd9a4ece4eca4d17b633c707b1f9" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#add-E-&quot;&gt;&lt;code&gt;add(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#add-E-&quot;&gt; &lt;code&gt;add(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="84aeefd9475793e355aa463fe4f64ffd579c71ff" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#addFirst-E-&quot;&gt;&lt;code&gt;addFirst(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#addFirst-E-&quot;&gt; &lt;code&gt;addFirst(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d3ff6d9782be86d95408c2001495dc4a2426d21b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#addLast-E-&quot;&gt;&lt;code&gt;addLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#addLast-E-&quot;&gt; &lt;code&gt;addLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="48503c548c56fcf06a9686103f293ac0edb786bc" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#getFirst--&quot;&gt;&lt;code&gt;getFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#getFirst--&quot;&gt; &lt;code&gt;getFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6b2f5465d56163a7753c4189e32633114cefa009" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#offerLast-E-&quot;&gt;&lt;code&gt;offerLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#offerLast-E-&quot;&gt; &lt;code&gt;offerLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8f71cf790974f6f2687330e58932a14065507a97" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#peekFirst--&quot;&gt;&lt;code&gt;peekFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#peekFirst--&quot;&gt; &lt;code&gt;peekFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0c02821bab241c240b3f857eee16cb26153365c4" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#pollFirst--&quot;&gt;&lt;code&gt;pollFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#pollFirst--&quot;&gt; &lt;code&gt;pollFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="45f21773493dfaad2f57844a4677ad0e0c138742" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#removeFirst--&quot;&gt;&lt;code&gt;removeFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#removeFirst--&quot;&gt; &lt;code&gt;removeFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="14466d27f8fb0ddd3e20e6a928313d060fc8e944" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;arraydeque#removeFirstOccurrence-java.lang.Object-&quot;&gt;&lt;code&gt;removeFirstOccurrence(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;arraydeque#removeFirstOccurrence-java.lang.Object-&quot;&gt; &lt;code&gt;removeFirstOccurrence(Object)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e26727ec89566260b76ce72249e4f122264c8810" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#addFirst-E-&quot;&gt;&lt;code&gt;addFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#addFirst-E-&quot;&gt; &lt;code&gt;addFirst&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4b1fa66f69196026a4f61822989e06cfa76d5a44" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#addLast-E-&quot;&gt;&lt;code&gt;addLast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#addLast-E-&quot;&gt; &lt;code&gt;addLast&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="15686caf1a02fd0b22268428a9ac9ff79b6814b4" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#offerLast-E-&quot;&gt;&lt;code&gt;offerLast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#offerLast-E-&quot;&gt; &lt;code&gt;offerLast&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2d723e78205a7c25f18be4193f3f7c567b99f050" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#offerLast-E-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;offerLast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#offerLast-E-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;offerLast&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="532967591efc91576fc6e010529bea850ce4cea5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#pollFirst-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;pollFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#pollFirst-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;pollFirst&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="034c5b9ff9c457c13d6709bfd488955a171c19be" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#putLast-E-&quot;&gt;&lt;code&gt;putLast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#putLast-E-&quot;&gt; &lt;code&gt;putLast&lt;/code&gt; &lt;/a&gt; 와 동등합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c53069740e2e09f72f107766aba77990158398" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#removeFirstOccurrence-java.lang.Object-&quot;&gt;&lt;code&gt;removeFirstOccurrence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#removeFirstOccurrence-java.lang.Object-&quot;&gt; &lt;code&gt;removeFirstOccurrence&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="efa03c367d161f342aabff9967b488c6bb7165c6" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;blockingdeque#takeFirst--&quot;&gt;&lt;code&gt;takeFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;blockingdeque#takeFirst--&quot;&gt; &lt;code&gt;takeFirst&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2224c7eb479604f0ecca5e9a1e2c87ba0d1c5fe9" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;concurrentlinkeddeque#add-E-&quot;&gt;&lt;code&gt;add(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;concurrentlinkeddeque#add-E-&quot;&gt; &lt;code&gt;add(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e1b6ac92f7a4569794ef3ba9510df764461fb67f" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#add-E-&quot;&gt;&lt;code&gt;add(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#add-E-&quot;&gt; &lt;code&gt;add(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fc7c08304f720f2c778b85321913e4057f82db47" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#addFirst-E-&quot;&gt;&lt;code&gt;addFirst(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#addFirst-E-&quot;&gt; &lt;code&gt;addFirst(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f2a34939e65bb98ed731d8feb7d4b3c6b715405f" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#addLast-E-&quot;&gt;&lt;code&gt;addLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#addLast-E-&quot;&gt; &lt;code&gt;addLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7b56a92dcbc2c2ae04921fa93ee4fa2b9be3a456" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#getFirst--&quot;&gt;&lt;code&gt;getFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#getFirst--&quot;&gt; &lt;code&gt;getFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2772efc22ade84a9481f3bf8c55e91f9cbd1c008" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#offerLast-E-&quot;&gt;&lt;code&gt;offerLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#offerLast-E-&quot;&gt; &lt;code&gt;offerLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="396765a86fbb7bdfb4abb942856005cf95afa374" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#peekFirst--&quot;&gt;&lt;code&gt;peekFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#peekFirst--&quot;&gt; &lt;code&gt;peekFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3c429a0973aed6b85b67e3b540ed30b9cfc5b3b5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#pollFirst--&quot;&gt;&lt;code&gt;pollFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#pollFirst--&quot;&gt; &lt;code&gt;pollFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3029d057d6dc59b232e7eed0a4af8f56540dbddf" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#removeFirst--&quot;&gt;&lt;code&gt;removeFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#removeFirst--&quot;&gt; &lt;code&gt;removeFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="24b009d11c7b1a8b9f8ac1e9ae63463a43aeac15" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;deque#removeFirstOccurrence-java.lang.Object-&quot;&gt;&lt;code&gt;removeFirstOccurrence(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;deque#removeFirstOccurrence-java.lang.Object-&quot;&gt; &lt;code&gt;removeFirstOccurrence(Object)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="59f9a2170534a464fa749a403663fbd5a466cafb" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2109fc69a4aa29cb9580c5f081baad0a3c197997" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-boolean-&quot;&gt;&lt;code&gt;newMBeanProxy(connection, objectName, interfaceClass,
 false)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-boolean-&quot;&gt; &lt;code&gt;newMBeanProxy(connection, objectName, interfaceClass, false)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c341b0dac95e5c31e97ed0423dc9ed28097f483d" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-boolean-&quot;&gt;&lt;code&gt;newMXBeanProxy(connection, objectName, interfaceClass,
 false)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-boolean-&quot;&gt; &lt;code&gt;newMXBeanProxy(connection, objectName, interfaceClass, false)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2b318b118677eaab0a3ce1f299e1cb60ca177f38" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;connect(serviceURL, null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;connect(serviceURL, null)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f74c047cfd571c36fd5612482e89d051e7303e33" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedblockingdeque#addLast-E-&quot;&gt;&lt;code&gt;addLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedblockingdeque#addLast-E-&quot;&gt; &lt;code&gt;addLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb02af00d191e0b898003f4e3593065418c52b8" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedblockingdeque#getFirst--&quot;&gt;&lt;code&gt;getFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedblockingdeque#getFirst--&quot;&gt; &lt;code&gt;getFirst&lt;/code&gt; &lt;/a&gt; 와 동등 합니다 .</target>
        </trans-unit>
        <trans-unit id="7bac904e167d9f58308622a82640847f1c3cdf55" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedblockingdeque#removeFirst--&quot;&gt;&lt;code&gt;removeFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedblockingdeque#removeFirst--&quot;&gt; &lt;code&gt;removeFirst&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f58b8153cbaeb760942f5eecf4040c8767c9217e" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedblockingdeque#removeFirstOccurrence-java.lang.Object-&quot;&gt;&lt;code&gt;removeFirstOccurrence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedblockingdeque#removeFirstOccurrence-java.lang.Object-&quot;&gt; &lt;code&gt;removeFirstOccurrence&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0a4edf0d1327f9808d462cef4f47a06f648fb8a1" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedlist#add-E-&quot;&gt;&lt;code&gt;add(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedlist#add-E-&quot;&gt; &lt;code&gt;add(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9353ad6d61cd960f6a999e78739cde0f5bea707a" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedlist#addFirst-E-&quot;&gt;&lt;code&gt;addFirst(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedlist#addFirst-E-&quot;&gt; &lt;code&gt;addFirst(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7e3f9512237b529fd32d60838c5948d2fa44965b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedlist#addLast-E-&quot;&gt;&lt;code&gt;addLast(E)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedlist#addLast-E-&quot;&gt; &lt;code&gt;addLast(E)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5d6cfd107c0067d4ee4827243702402a98a58351" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;linkedlist#removeFirst--&quot;&gt;&lt;code&gt;removeFirst()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;linkedlist#removeFirst--&quot;&gt; &lt;code&gt;removeFirst()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="480913a4e825d16bba5cf2d5136bbd710a8bef4c" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8b6532c4d4626b0bb3bc299757ff1efa04249f1" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f36ce6c9cc788422d65e5cda5aef1d9b37146ed5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f72a850286a9f076e2ecc148078b95355283f7" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;mbeanserver#instantiate-java.lang.String-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;instantiate(className, (Object[]) null, (String[]) null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;mbeanserver#instantiate-java.lang.String-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;instantiate(className, (Object[]) null, (String[]) null)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="635a12545432754314cfce59bd929ae63656163d" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;mbeanserver#instantiate-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;instantiate(className, loaderName, (Object[]) null, (String[])
 null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;mbeanserver#instantiate-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;instantiate(className, loaderName, (Object[]) null, (String[]) null)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89c45209680bfeca1fdbc673b25290f6aa7ca2f2" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;mbeanserverconnection#createMBean-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;createMBean(className, name, (Object[]) null, (String[])
 null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;mbeanserverconnection#createMBean-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;createMBean(className, name, (Object[]) null, (String[]) null)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8cafac796cf6cc290c7cdd9b8110c234115831f" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;mbeanserverconnection#createMBean-java.lang.String-javax.management.ObjectName-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;createMBean(className, name, loaderName, (Object[]) null,
 (String[]) null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;mbeanserverconnection#createMBean-java.lang.String-javax.management.ObjectName-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;createMBean(className, name, loaderName, (Object[]) null, (String[]) null)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9814bf1be3d3dad27dd8c2c505eec033f65cf893" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;offsetdatetime#ofInstant-java.time.Instant-java.time.ZoneId-&quot;&gt;&lt;code&gt;OffsetDateTime.ofInstant(this, offset)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;offsetdatetime#ofInstant-java.time.Instant-java.time.ZoneId-&quot;&gt; &lt;code&gt;OffsetDateTime.ofInstant(this, offset)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6d59d8223469f3ae35b0245e0bff1fcceb2ea55" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf56d3e110cc76842dd75c2fd043ba980b3ad666" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fce96be4ee850ad719075e237d19a3e8ef9d43d2" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbff0b66132998944d5c7ce65390d17c579c87a7" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9dcad95eef5e1f66a6642d3074dd0f7a03a518a" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;zoneddatetime#ofInstant-java.time.Instant-java.time.ZoneId-&quot;&gt;&lt;code&gt;ZonedDateTime.ofInstant(this, zone)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;zoneddatetime#ofInstant-java.time.Instant-java.time.ZoneId-&quot;&gt; &lt;code&gt;ZonedDateTime.ofInstant(this, zone)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e975e726acee52c4dc0454797ccfac076ba7a0b4" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with the amount negated. See that method for a full description of how addition, and thus subtraction, works.</source>
          <target state="translated">이 방법은 양이 무효화 된 &lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 와 같습니다. 덧셈과 뺄셈의 작동 방식에 대한 자세한 설명은 해당 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cab3b49f8a92934fe2dbdd539367f4a62c851d5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;BitSet.valueOf(ByteBuffer.wrap(bytes))&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;BitSet.valueOf(ByteBuffer.wrap(bytes))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6935f428861ade87e7ea9856a9d29a31becd903" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;BitSet.valueOf(LongBuffer.wrap(longs))&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;BitSet.valueOf(LongBuffer.wrap(longs))&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dffec148cec737fb0cf69df66b436b2e7a053121" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;createMBeanServer(null)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;createMBeanServer(null)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0616a07d400f5772695626b3597ddf043d782260" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;negotiate(null)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;negotiate(null)&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="71235388a486a22b38053dcdde576c9698b499d6" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;newMBeanServer(null)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;newMBeanServer(null)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c85782e3d2b82db588781506096398e47e5e35d5" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;setInput(input,
 seekForwardOnly, false)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;setInput(input, seekForwardOnly, false)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0967c34cd3582219ab8e2f5593c1c9a618143505" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;setInput(input, false,
 false)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;setInput(input, false, false)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3af1ab758c175ff9f79dab21da14b593bfd56d46" translate="yes" xml:space="preserve">
          <source>This method is equivalent to calling &lt;code&gt;getName(X500Principal.RFC2253)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;getName(X500Principal.RFC2253)&lt;/code&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f075d48644547d92366ba397af4b70b741827ced" translate="yes" xml:space="preserve">
          <source>This method is equivalent to calling &lt;code&gt;getSequencer(true)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;getSequencer(true)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ce70f0937eb327212fc0cce93b927154a630551c" translate="yes" xml:space="preserve">
          <source>This method is equivalent to calling the four-argument constructor with the arguments being &lt;code&gt;protocol&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;, and &lt;code&gt;file&lt;/code&gt;. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">이 메소드는 &lt;code&gt;protocol&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;-1&lt;/code&gt; 및 &lt;code&gt;file&lt;/code&gt; 인수를 사용하여 4 개의 인수 생성자를 호출하는 것과 같습니다 . 이 생성자는 입력의 유효성 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a9494d0b0f9f9762ac18a11fa9dbac5b8dede9d" translate="yes" xml:space="preserve">
          <source>This method is equivalent to method &lt;code&gt;navigableKeySet&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;navigableKeySet&lt;/code&gt; 메소드와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9aec895eff1dfa52f137329c0a08508cf3037898" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the expression:</source>
          <target state="translated">이 방법은 다음 표현식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d72ed373e62346cb1d21d1574436bb65f1419e38" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the following call.</source>
          <target state="translated">이 메소드는 다음 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="708149fca6ea3cb8c860f0b39afae0e0706d4773" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the following code (though it may be more efficient):</source>
          <target state="translated">이 방법은 다음 코드와 동일하지만 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0f236b6b979c07fb74ccf1aea85ba1c004c1d6" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the following code (though it may be more efficient): &lt;code&gt;publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)&lt;/code&gt;</source>
          <target state="translated">이 메소드는 다음 코드와 동일합니다 (더 효율적일 수는 있습니다) : &lt;code&gt;publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1c2c4ed439efc36310ee4144d344bd24547f01b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the following code (though it may be more efficient): &lt;code&gt;publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)&lt;/code&gt;</source>
          <target state="translated">이 메소드는 다음 코드와 동일합니다 (더 효율적일 수는 있습니다) : &lt;code&gt;publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1810dc7467cbaffdff093edae9768626e71d3188" translate="yes" xml:space="preserve">
          <source>This method is equivalent to the following code:</source>
          <target state="translated">이 방법은 다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="4666da77ba161f3de91822d32d0e17494546a560" translate="yes" xml:space="preserve">
          <source>This method is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97c9cb5c9d68ff17377cf689580612ca1ea3f89" translate="yes" xml:space="preserve">
          <source>This method is first invoked early in the runtime's startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking &lt;code&gt;Thread&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 런타임의 시작 순서에서 먼저 호출되며,이 시점에서 시스템 클래스 로더를 작성하고이를 호출하는 &lt;code&gt;Thread&lt;/code&gt; 의 컨텍스트 클래스 로더로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b47611efdddda5528d61604e9ecb14293f370ee5" translate="yes" xml:space="preserve">
          <source>This method is functionally equivalent to &lt;a href=&quot;keypairgenerator#genKeyPair--&quot;&gt;&lt;code&gt;genKeyPair&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 기능적으로 &lt;a href=&quot;keypairgenerator#genKeyPair--&quot;&gt; &lt;code&gt;genKeyPair&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="617f5c3ccebe696f11ba21ec03006677d00dacc7" translate="yes" xml:space="preserve">
          <source>This method is functionally equivalent to &lt;a href=&quot;keypairgenerator#generateKeyPair--&quot;&gt;&lt;code&gt;generateKeyPair&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;keypairgenerator#generateKeyPair--&quot;&gt; &lt;code&gt;generateKeyPair&lt;/code&gt; &lt;/a&gt; 와 동등합니다 .</target>
        </trans-unit>
        <trans-unit id="da61400ab9b3619e2b481cbdab8b36bcaba8770b" translate="yes" xml:space="preserve">
          <source>This method is idempotent. It succeeds even if the terminal atomic name is not bound in the target context, but throws &lt;code&gt;NameNotFoundException&lt;/code&gt; if any of the intermediate contexts do not exist.</source>
          <target state="translated">이 방법은 dem 등원입니다. 터미널 원자 이름이 대상 컨텍스트에 바인딩되지 않은 경우에도 성공하지만 중간 컨텍스트가 존재하지 않으면 &lt;code&gt;NameNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b1468159ff67e9e35f87b3d898eb55e55866de7" translate="yes" xml:space="preserve">
          <source>This method is idempotent: if the inbound side has already been closed, this method does not do anything.</source>
          <target state="translated">이 메소드는 dem 등원입니다. 인바운드 측이 이미 닫혀 있으면이 메소드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a96ed950b6f8413be59b1869a08784b43f0f1cc" translate="yes" xml:space="preserve">
          <source>This method is idempotent: if the outbound side has already been closed, this method does not do anything.</source>
          <target state="translated">이 메소드는 dem 등원입니다. 아웃 바운드 측이 이미 닫혀 있으면이 메소드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f89a0125ece62c8e80accaec6b65003e4e7847d" translate="yes" xml:space="preserve">
          <source>This method is idempotent: invoking it on a context that has already been closed has no effect. Invoking any other method on a closed context is not allowed, and results in undefined behaviour.</source>
          <target state="translated">이 메소드는 dem 등원입니다. 이미 닫힌 컨텍스트에서 호출하면 아무 효과가 없습니다. 닫힌 컨텍스트에서 다른 메소드를 호출하는 것은 허용되지 않으며 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b7f8b066278a49110a120a172d5b2d1cc50d1fbb" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#add-E-&quot;&gt;&lt;code&gt;add(E)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">이 메소드는 기능면에서 &lt;a href=&quot;vector#add-E-&quot;&gt; &lt;code&gt;add(E)&lt;/code&gt; &lt;/a&gt; 메소드와 동일 합니다 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부 임 ).</target>
        </trans-unit>
        <trans-unit id="f6e8c2ec5f9d3776676bdd1e96762993efde14a2" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#add-int-E-&quot;&gt;&lt;code&gt;add(int, E)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface). Note that the &lt;code&gt;add&lt;/code&gt; method reverses the order of the parameters, to more closely match array usage.</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#add-int-E-&quot;&gt; &lt;code&gt;add(int, E)&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 . 참고 것을 &lt;code&gt;add&lt;/code&gt; 방법은 배열의 사용법에 맞게 파라미터의 순서를 반대로.</target>
        </trans-unit>
        <trans-unit id="8c5c7161e7093035bed197c62042d876b08cbc54" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#clear--&quot;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#clear--&quot;&gt; &lt;code&gt;clear()&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="248f15d5c49956df5bced339988c5dad95b3a64e" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#get-int-&quot;&gt;&lt;code&gt;get(int)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#get-int-&quot;&gt; &lt;code&gt;get(int)&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a2982a6e0030405d050482ff6439411d226693f3" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#remove-int-&quot;&gt;&lt;code&gt;remove(int)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface). Note that the &lt;code&gt;remove&lt;/code&gt; method returns the old value that was stored at the specified position.</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#remove-int-&quot;&gt; &lt;code&gt;remove(int)&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 . 있습니다 &lt;code&gt;remove&lt;/code&gt; 방법은 지정된 위치에 저장되어, 이전의 값을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="a8b0ddb1136f50bf36b43142a1a91f316859d48a" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#remove-java.lang.Object-&quot;&gt;&lt;code&gt;remove(Object)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#remove-java.lang.Object-&quot;&gt; &lt;code&gt;remove(Object)&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="4947e74334cf1ef9246243f25f7ce45ee6aecc29" translate="yes" xml:space="preserve">
          <source>This method is identical in functionality to the &lt;a href=&quot;vector#set-int-E-&quot;&gt;&lt;code&gt;set(int, E)&lt;/code&gt;&lt;/a&gt; method (which is part of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface). Note that the &lt;code&gt;set&lt;/code&gt; method reverses the order of the parameters, to more closely match array usage. Note also that the &lt;code&gt;set&lt;/code&gt; method returns the old value that was stored at the specified position.</source>
          <target state="translated">이 메소드는 기능적으로 &lt;a href=&quot;vector#set-int-E-&quot;&gt; &lt;code&gt;set(int, E)&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부)와 동일합니다 . 참고 것으로 &lt;code&gt;set&lt;/code&gt; 방법은 배열의 사용법에 맞게 파라미터의 순서를 반대로. 참고 또한 것을 &lt;code&gt;set&lt;/code&gt; 방법은 지정된 위치에 저장되어, 이전의 값을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5d8cfb1ecfe96aaa633ec2985723445104f457b7" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;doubles(Long.MAX_VALUE)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;doubles(Long.MAX_VALUE)&lt;/code&gt; 와 동등하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="d774eca6c70ab318a999b34374c1f302be72c6eb" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt; 와 동일하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1eaa3b6462f2587caa9b0b63a007f81e062def3" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;ints(Long.MAX_VALUE)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ints(Long.MAX_VALUE)&lt;/code&gt; 와 동등하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="776423884188a5de467d32d7ccc7ac4a4bf23b42" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt; 와 동일하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dadb179484f532302f62a5a21c610466f03dbf7" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;longs(Long.MAX_VALUE)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;longs(Long.MAX_VALUE)&lt;/code&gt; 와 동일하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7218ab89b33a392c6cae55e44ad99bfb181e31b" translate="yes" xml:space="preserve">
          <source>This method is implemented to be equivalent to &lt;code&gt;longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)&lt;/code&gt; 와 동일하게 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="0195b9102301990b008836c7ca780253a6771874" translate="yes" xml:space="preserve">
          <source>This method is included for the benefit of applications that must generate bytecodes that process method handles and &lt;code&gt;invokedynamic&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 메소드 핸들 및 &lt;code&gt;invokedynamic&lt;/code&gt; 을 처리하는 바이트 코드를 생성해야하는 애플리케이션의 이점을 위해 포함되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d0bfcc10c84de0711d864c8e459e9011660e2955" translate="yes" xml:space="preserve">
          <source>This method is included for the benefit of applications that must generate bytecodes that process method handles and &lt;code&gt;invokedynamic&lt;/code&gt;. &lt;a href=&quot;methodtype#fromMethodDescriptorString-java.lang.String-java.lang.ClassLoader-&quot;&gt;&lt;code&gt;fromMethodDescriptorString&lt;/code&gt;&lt;/a&gt;, because the latter requires a suitable class loader argument.</source>
          <target state="translated">이 메소드는 메소드 핸들 및 &lt;code&gt;invokedynamic&lt;/code&gt; 을 처리하는 바이트 코드를 생성해야하는 애플리케이션의 이점을 위해 포함되었습니다 . &lt;a href=&quot;methodtype#fromMethodDescriptorString-java.lang.String-java.lang.ClassLoader-&quot;&gt; &lt;code&gt;fromMethodDescriptorString&lt;/code&gt; &lt;/a&gt; 은 후자에 적합한 클래스 로더 인수가 필요하기 때문에.</target>
        </trans-unit>
        <trans-unit id="c566821b9cdc6bbfa2e33b7ce636566920420064" translate="yes" xml:space="preserve">
          <source>This method is intended for advanced use cases that need access to the internal state during parsing. Typical application code should use &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-&quot;&gt;&lt;code&gt;parse(CharSequence, TemporalQuery)&lt;/code&gt;&lt;/a&gt; or the parse method on the target type.</source>
          <target state="translated">이 방법은 구문 분석 중에 내부 상태에 액세스해야하는 고급 사용 사례를위한 것입니다. 일반적인 응용 프로그램 코드는 &lt;a href=&quot;datetimeformatter#parse-java.lang.CharSequence-java.time.temporal.TemporalQuery-&quot;&gt; &lt;code&gt;parse(CharSequence, TemporalQuery)&lt;/code&gt; &lt;/a&gt; 또는 대상 유형에 대한 구문 분석 방법을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c3b35f39e1a5e894c4728e815a308eff1a6b773" translate="yes" xml:space="preserve">
          <source>This method is intended for specialized providers of pseudo file systems where the contents of one or more files is treated as a file system. The &lt;code&gt;env&lt;/code&gt; parameter is a map of provider specific properties to configure the file system.</source>
          <target state="translated">이 방법은 하나 이상의 파일 내용이 파일 시스템으로 취급되는 의사 파일 시스템의 전문 공급자를위한 것입니다. &lt;code&gt;env&lt;/code&gt; 매개 변수는 파일 시스템을 구성하는 제공자 특정 속성의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="0b627e1f077ce06326312f5cf7918cdfbe9812fb" translate="yes" xml:space="preserve">
          <source>This method is intended for use in instrumentation, as described in the &lt;a href=&quot;instrumentation&quot;&gt;class specification&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;instrumentation&quot;&gt;클래스 사양에&lt;/a&gt; 설명 된대로 계측에 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="febe9ff23e771d0525155c8a2bdf3a90b71b1657" translate="yes" xml:space="preserve">
          <source>This method is intended for use in situations in which new providers can be installed into a running Java virtual machine.</source>
          <target state="translated">이 메소드는 실행중인 Java 가상 머신에 새 제공자를 설치할 수있는 상황에서 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="29908003546e6618a5f23538e570774746bf2f2b" translate="yes" xml:space="preserve">
          <source>This method is intended for use when generating Java code to set the value of the property. It should return a fragment of Java code that can be used to initialize a variable with the current property value.</source>
          <target state="translated">이 메소드는 Java 코드를 생성하여 특성 값을 설정할 때 사용하기위한 것입니다. 현재 속성 값으로 변수를 초기화하는 데 사용할 수있는 Java 코드 조각을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="9743ec5c9b55fa59675a11f76e383d047cec5291" translate="yes" xml:space="preserve">
          <source>This method is intended for use when only installed providers are desired. The resulting service will only find and load providers that have been installed into the current Java virtual machine; providers on the application's class path will be ignored.</source>
          <target state="translated">이 방법은 설치된 공급자 만 필요한 경우에 사용하기위한 것입니다. 결과 서비스는 현재 Java 가상 머신에 설치된 제공자 만 찾아로드합니다. 응용 프로그램 클래스 경로의 공급자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="57c4f5826f4a2b837c1343f09fbeb277251228b4" translate="yes" xml:space="preserve">
          <source>This method is intended to allow array-backed buffers to be passed to native code more efficiently. Concrete subclasses provide more strongly-typed return values for this method.</source>
          <target state="translated">이 방법은 배열 지원 버퍼를 원시 코드에보다 효율적으로 전달할 수 있도록하기위한 것입니다. 구체적 서브 클래스는이 메소드에 대해보다 강력한 형식의 리턴 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="95b5e2f135db0f2c6a0be583cef69b748b09f0e3" translate="yes" xml:space="preserve">
          <source>This method is intended to be used by sophisticated applications, for example, a &lt;a href=&quot;../util/scanner&quot;&gt;&lt;code&gt;Scanner&lt;/code&gt;&lt;/a&gt; object which utilizes the rich parsing/scanning functionality provided by the &lt;code&gt;Scanner&lt;/code&gt;:</source>
          <target state="translated">이 방법은 복잡한 응용 프로그램에 의해 사용하기위한, 예를 들면, &lt;a href=&quot;../util/scanner&quot;&gt; &lt;code&gt;Scanner&lt;/code&gt; &lt;/a&gt; 에 의해 제공되는 다양한 분석 / 스캔 기능을 이용하여 물체 &lt;code&gt;Scanner&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4842539125fa852de7a513bf57d89e4251c10738" translate="yes" xml:space="preserve">
          <source>This method is intended to be used in a loop together with the &lt;a href=&quot;matcher#appendTail-java.lang.StringBuffer-&quot;&gt;&lt;code&gt;appendTail&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; methods. The following code, for example, writes &lt;code&gt;one dog two dogs in the yard&lt;/code&gt; to the standard-output stream:</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;matcher#appendTail-java.lang.StringBuffer-&quot;&gt; &lt;code&gt;appendTail&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 루프에서 사용되도록 고안되었습니다 . 예를 들어 다음 코드 &lt;code&gt;one dog two dogs in the yard&lt;/code&gt; 표준 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e7cc37368a909a063677a40f27331ac1a3e3c348" translate="yes" xml:space="preserve">
          <source>This method is intended to be used where the file store attribute view defines type-safe methods to read or update the file store attributes. The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attribute view required and the method returns an instance of that type if supported.</source>
          <target state="translated">이 방법은 파일 저장소 속성보기가 파일 저장소 속성을 읽거나 업데이트하기 위해 형식에 안전한 방법을 정의하는 경우에 사용됩니다. &lt;code&gt;type&lt;/code&gt; 파라미터는 요구되는 특성 뷰의 타입 및 지원되는 경우에있어서 그 타입의 인스턴스를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="442bb83c7385982c0c16d7c9b9ae2ade98cbb344" translate="yes" xml:space="preserve">
          <source>This method is intended to provide a default, nonlocalized string for the attribute's category. If two attribute objects return the same category from the &lt;code&gt;getCategory()&lt;/code&gt; method, they should return the same name from the &lt;code&gt;getName()&lt;/code&gt; method.</source>
          <target state="translated">이 메소드는 속성 카테고리에 대해 지역화되지 않은 기본 문자열을 제공하기위한 것입니다. 두 개의 속성 오브젝트가 &lt;code&gt;getCategory()&lt;/code&gt; 메소드 에서 동일한 카테고리를 리턴하면 &lt;code&gt;getName()&lt;/code&gt; 메소드 에서 동일한 이름을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a6effdafdbd669952d3019870dc395c4a120ba2" translate="yes" xml:space="preserve">
          <source>This method is invoked by a channel's &lt;a href=&quot;abstractselectablechannel#register-java.nio.channels.Selector-int-java.lang.Object-&quot;&gt;&lt;code&gt;register&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of registering the channel with this selector.</source>
          <target state="translated">이 메소드는 채널 선택기에서 채널을 등록하는 실제 작업을 수행하기 위해 채널의 &lt;a href=&quot;abstractselectablechannel#register-java.nio.channels.Selector-int-java.lang.Object-&quot;&gt; &lt;code&gt;register&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9b18437f520ac587edec02af644dde45af89bb6" translate="yes" xml:space="preserve">
          <source>This method is invoked by the &lt;a href=&quot;../channel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of closing the channel. This method is only invoked if the channel has not yet been closed, and it is never invoked more than once.</source>
          <target state="translated">이 메소드는 채널을 닫는 실제 작업을 수행하기 위해 &lt;a href=&quot;../channel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 . 이 메소드는 채널이 아직 닫히지 않은 경우에만 호출되며 두 번 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0738044224b04c102a6384ffb1756fc7aecf6af" translate="yes" xml:space="preserve">
          <source>This method is invoked by the &lt;a href=&quot;../files#isHidden-java.nio.file.Path-&quot;&gt;&lt;code&gt;isHidden&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../files#isHidden-java.nio.file.Path-&quot;&gt; &lt;code&gt;isHidden&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc15a11184fb53c214106fdc0a5a91b5731b5eaf" translate="yes" xml:space="preserve">
          <source>This method is invoked by the &lt;a href=&quot;abstractinterruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of closing the channel. This method is only invoked if the channel has not yet been closed, and it is never invoked more than once.</source>
          <target state="translated">이 메소드는 채널을 닫는 실제 작업을 수행하기 위해 &lt;a href=&quot;abstractinterruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 . 이 메소드는 채널이 아직 닫히지 않은 경우에만 호출되며 두 번 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52c7c2c640080847215c2102eeea6afb54f18ab1" translate="yes" xml:space="preserve">
          <source>This method is invoked by the &lt;a href=&quot;abstractselectablechannel#configureBlocking-boolean-&quot;&gt;&lt;code&gt;configureBlocking&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of changing the blocking mode. This method is only invoked if the new mode is different from the current mode.</source>
          <target state="translated">이 메소드는 실제 차단 모드 변경 작업을 수행하기 위해 &lt;a href=&quot;abstractselectablechannel#configureBlocking-boolean-&quot;&gt; &lt;code&gt;configureBlocking&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출 됩니다. 이 방법은 새 모드가 현재 모드와 다른 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="981c7e00be3e5127678294b741e3a55d0a5530aa" translate="yes" xml:space="preserve">
          <source>This method is invoked by the &lt;a href=&quot;abstractselector#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of closing the selector. This method is only invoked if the selector has not yet been closed, and it is never invoked more than once.</source>
          <target state="translated">이 메소드는 실렉터를 닫는 실제 작업을 수행하기 위해 &lt;a href=&quot;abstractselector#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출됩니다 . 이 메소드는 선택기가 아직 닫히지 않은 경우에만 호출되며 두 번 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7777bd4dcb30dcce8b1a5a7d1cf514e7513847c" translate="yes" xml:space="preserve">
          <source>This method is invoked by the defineClass method which takes a CodeSource as an argument when it is constructing the ProtectionDomain for the class being defined.</source>
          <target state="translated">이 메소드는 정의중인 클래스에 대한 ProtectionDomain을 구성 할 때 CodeSource를 인수로 사용하는 defineClass 메소드에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="252d8307e33da3f3acb737bd6b3d473c9ed51554" translate="yes" xml:space="preserve">
          <source>This method is invoked during the resolve phase of parsing. It is designed to allow application defined fields to be simplified into more standard fields, such as those on &lt;code&gt;ChronoField&lt;/code&gt;, or into a date.</source>
          <target state="translated">이 메소드는 구문 분석 단계에서 호출됩니다. 응용 프로그램 정의 필드를 &lt;code&gt;ChronoField&lt;/code&gt; 와 같은 표준 필드 나 날짜로 단순화 할 수 있도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f66b64fdce6125433f702322e5314759752efc01" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by methods &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;loadLibrary&lt;/code&gt; of class &lt;code&gt;Runtime&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Runtime&lt;/code&gt; 클래스의 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;loadLibrary&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="067e885fb4901d1e42feae3326bb5fdb7f7e981b" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by the &lt;code&gt;accept&lt;/code&gt; method of class &lt;code&gt;ServerSocket&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ServerSocket&lt;/code&gt; 클래스 의 &lt;code&gt;accept&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3c07e0e28f9eeeebad2e7c5b483a45e361e51e0" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by the &lt;code&gt;delete&lt;/code&gt; method of class &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;File&lt;/code&gt; 클래스 의 &lt;code&gt;delete&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ba612f65f6fc7a86cf6d96195f7ab15a1669bec" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by the &lt;code&gt;exec&lt;/code&gt; methods of class &lt;code&gt;Runtime&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Runtime&lt;/code&gt; 클래스 의 &lt;code&gt;exec&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec9ffca9cf142120f16a0c9c15188b95f3b8786c" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by the &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt;. A status of &lt;code&gt;0&lt;/code&gt; indicates success; other values indicate various errors.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Runtime&lt;/code&gt; 클래스 의 &lt;code&gt;exit&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 . 상태 &lt;code&gt;0&lt;/code&gt; 은 성공을 나타냅니다. 다른 값은 다양한 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5a92dce7bfe9357ee7ad235f4fcc0aff19642c6" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager by the &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;, &lt;code&gt;setPriority&lt;/code&gt;, &lt;code&gt;setName&lt;/code&gt;, and &lt;code&gt;setDaemon&lt;/code&gt; methods of class &lt;code&gt;Thread&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Thread&lt;/code&gt; 클래스 의 &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;suspend&lt;/code&gt; , &lt;code&gt;resume&lt;/code&gt; , &lt;code&gt;setPriority&lt;/code&gt; , &lt;code&gt;setName&lt;/code&gt; 및 &lt;code&gt;setDaemon&lt;/code&gt; 메소드에 의해 현재 보안 관리자에 대해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd63ee99c3f106295572026f7eb63f091d4de29e" translate="yes" xml:space="preserve">
          <source>This method is invoked for the current security manager when a new child thread or child thread group is created, and by the &lt;code&gt;setDaemon&lt;/code&gt;, &lt;code&gt;setMaxPriority&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;, and &lt;code&gt;destroy&lt;/code&gt; methods of class &lt;code&gt;ThreadGroup&lt;/code&gt;.</source>
          <target state="translated">이 방법은 새로운 아이 thread 또는 아이 thread 그룹이 생성되어 현재 보안 관리 프로그램에 대해 호출 및 것입니다 &lt;code&gt;setDaemon&lt;/code&gt; 를 , &lt;code&gt;setMaxPriority&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;suspend&lt;/code&gt; , &lt;code&gt;resume&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt; 클래스의 방법 &lt;code&gt;ThreadGroup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d00bd3c3c711982fe1a577401b8a2303037fe64" translate="yes" xml:space="preserve">
          <source>This method is invoked internally by the &lt;a href=&quot;futuretask#run--&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method upon failure of the computation.</source>
          <target state="translated">이 메소드는 계산 실패시 &lt;a href=&quot;futuretask#run--&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 내부적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="515d79129455d05541c31320e6c442a871df9121" translate="yes" xml:space="preserve">
          <source>This method is invoked internally by the &lt;a href=&quot;futuretask#run--&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method upon successful completion of the computation.</source>
          <target state="translated">이 메소드는 계산이 완료되면 &lt;a href=&quot;futuretask#run--&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 내부적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b95f9ef69b43bd503bb7ea77a685b4ad676c6e40" translate="yes" xml:space="preserve">
          <source>This method is invoked on registered objects when a SSL handshake is completed.</source>
          <target state="translated">이 메소드는 SSL 핸드 셰이크가 완료되면 등록 된 오브젝트에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="abf80fb5a7bd9ff915ab069af80b85354b7bc8e7" translate="yes" xml:space="preserve">
          <source>This method is invoked only by Java code; when the garbage collector clears references it does so directly, without invoking this method.</source>
          <target state="translated">이 메소드는 Java 코드로만 호출됩니다. 가비지 콜렉터가 참조를 지우면이 메소드를 호출하지 않고 직접 참조를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="ea2087e19201815d28efd158cba7a7f4c7fb6b1c" translate="yes" xml:space="preserve">
          <source>This method is invoked only by Java code; when the garbage collector enqueues references it does so directly, without invoking this method.</source>
          <target state="translated">이 메소드는 Java 코드로만 호출됩니다. 가비지 콜렉터가 참조를 큐에 넣을 때이 메소드를 호출하지 않고 직접 참조합니다.</target>
        </trans-unit>
        <trans-unit id="18e36598c1e06c1fc1b22eb430452c8ea351e0b0" translate="yes" xml:space="preserve">
          <source>This method is invoked with the lock held on this node and its parent (and all ancestors that are being removed as a result of a single invocation to &lt;a href=&quot;preferences#removeNode--&quot;&gt;&lt;code&gt;Preferences.removeNode()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 메소드는이 노드와 그 부모 (및 &lt;a href=&quot;preferences#removeNode--&quot;&gt; &lt;code&gt;Preferences.removeNode()&lt;/code&gt; &lt;/a&gt; 에 대한 단일 호출의 결과로 제거되는 모든 조상)에 잠금이 유지 된 상태에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b14d5335917a286b27f3d47d15c501fce77f745" translate="yes" xml:space="preserve">
          <source>This method is invoked with the lock on this node held.</source>
          <target state="translated">이 메소드는이 노드의 잠금이 유지 된 상태에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="923f74bdb174af1caf732ad36234937a6971924e" translate="yes" xml:space="preserve">
          <source>This method is invoked with this node locked. The contract of this method is to force any cached changes in the contents of this preference node to the backing store, guaranteeing their persistence. (It is perfectly possible that this node does not exist on the backing store, either because it has been deleted by another VM, or because it has not yet been created.) Note that this method should</source>
          <target state="translated">이 메소드는이 노드가 잠긴 상태에서 호출됩니다. 이 방법의 계약은이 환경 설정 노드의 컨텐츠에서 캐시 된 변경 사항을 백업 저장소로 강제 변경하여 지속성을 보장하는 것입니다. (이 노드는 다른 VM에 의해 삭제되었거나 아직 생성되지 않았기 때문에 백업 저장소에 존재하지 않을 수 있습니다.)이 방법은</target>
        </trans-unit>
        <trans-unit id="2754e4b4c7dbf5e62fb4bf47d642fe772cb291aa" translate="yes" xml:space="preserve">
          <source>This method is invoked with this node locked. The contract of this method is to synchronize any cached preferences stored at this node with any stored in the backing store. (It is perfectly possible that this node does not exist on the backing store, either because it has been deleted by another VM, or because it has not yet been created.) Note that this method should</source>
          <target state="translated">이 메소드는이 노드가 잠긴 상태에서 호출됩니다. 이 방법의 계약은이 노드에 저장된 캐시 된 기본 설정을 백업 저장소에 저장된 모든 기본 설정과 동기화하는 것입니다. (이 노드는 다른 VM에 의해 삭제되었거나 아직 생성되지 않았기 때문에 백업 저장소에 존재하지 않을 수 있습니다.)이 방법은</target>
        </trans-unit>
        <trans-unit id="15489f38390a103fdf5fe387652f5e0e8b4ccd7e" translate="yes" xml:space="preserve">
          <source>This method is like &lt;code&gt;NamingManager.getStateToBind&lt;/code&gt; except for the following differences:</source>
          <target state="translated">이 메소드는 다음과 같은 차이점을 제외하고 &lt;code&gt;NamingManager.getStateToBind&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e1f7b8cb26774b5d7be3482e73541adce1da018" translate="yes" xml:space="preserve">
          <source>This method is merely a convenience equivalent to calling &lt;code&gt;read(int, ImageReadParam)&lt;/code&gt; with a read param specifying a source region having offsets of &lt;code&gt;tileX*getTileWidth(imageIndex)&lt;/code&gt;, &lt;code&gt;tileY*getTileHeight(imageIndex)&lt;/code&gt; and width and height of &lt;code&gt;getTileWidth(imageIndex)&lt;/code&gt;, &lt;code&gt;getTileHeight(imageIndex)&lt;/code&gt;; and subsampling factors of 1 and offsets of 0. To subsample a tile, call &lt;code&gt;read&lt;/code&gt; with a read param specifying this region and different subsampling parameters.</source>
          <target state="translated">이 방법은 단지 호출하는 편의 동등한 &lt;code&gt;read(int, ImageReadParam)&lt;/code&gt; 판독 PARAM는 소스의 오프셋을 갖는 영역 지정과 &lt;code&gt;tileX*getTileWidth(imageIndex)&lt;/code&gt; , &lt;code&gt;tileY*getTileHeight(imageIndex)&lt;/code&gt; 의 폭과 높이 &lt;code&gt;getTileWidth(imageIndex)&lt;/code&gt; , &lt;code&gt;getTileHeight(imageIndex)&lt;/code&gt; ; 그리고 타일을 표본 1의 요인과 0의 오프셋을 서브 샘플링, 호출은 &lt;code&gt;read&lt;/code&gt; 이 지역과 다른 서브 샘플링 파라미터를 지정하는 read PARAM으로.</target>
        </trans-unit>
        <trans-unit id="74e563b94db60a52200527da0350b2be3483e34b" translate="yes" xml:space="preserve">
          <source>This method is needed because the application class path can theoretically change, or additional plug-ins may become available. Rather than re-scanning the classpath on every invocation of the API, the class path is scanned automatically only on the first invocation. Clients can call this method to prompt a re-scan. Thus this method need only be invoked by sophisticated applications which dynamically make new plug-ins available at runtime.</source>
          <target state="translated">이 메소드는 애플리케이션 클래스 경로가 이론적으로 변경되거나 추가 플러그인을 사용할 수 있기 때문에 필요합니다. API를 호출 할 때마다 클래스 경로를 다시 스캔하지 않고 클래스 경로는 첫 번째 호출에서만 자동으로 스캔됩니다. 클라이언트는이 메소드를 호출하여 재검색을 촉구 할 수 있습니다. 따라서이 메소드는 런타임시 새 플러그인을 동적으로 사용 가능하게하는 정교한 애플리케이션에서만 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fc165fa231bca09f4bc9efac08835902ba7ee3fd" translate="yes" xml:space="preserve">
          <source>This method is normally used to parse the encoded name value in a requested SNI extension.</source>
          <target state="translated">이 방법은 일반적으로 요청 된 SNI 확장에서 인코딩 된 이름 값을 구문 분석하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c21eb92b48c4cd99405dc7f75560e5eaac4d60" translate="yes" xml:space="preserve">
          <source>This method is not needed for the initial handshake, as the &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; methods will implicitly call this method if handshaking has not already begun.</source>
          <target state="translated">핸드 셰이 킹이 아직 시작되지 않은 경우 &lt;code&gt;wrap()&lt;/code&gt; 및 &lt;code&gt;unwrap()&lt;/code&gt; 메소드가 내재적으로이 메소드를 호출 하므로 초기 핸드 셰이크에는이 메소드가 필요 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16619bf63000b90d2aab1ce9b6f494106facc282" translate="yes" xml:space="preserve">
          <source>This method is often used in conjunction with the &lt;a href=&quot;bytebuffer#compact--&quot;&gt;&lt;code&gt;compact&lt;/code&gt;&lt;/a&gt; method when transferring data from one place to another.</source>
          <target state="translated">이 방법은 한 장소에서 다른 장소로 데이터를 전송할 때 종종 &lt;a href=&quot;bytebuffer#compact--&quot;&gt; &lt;code&gt;compact&lt;/code&gt; &lt;/a&gt; 방법 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e292c5787c644ffc4e3dffa1a20d94361016b33" translate="yes" xml:space="preserve">
          <source>This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class.</source>
          <target state="translated">이 메소드는이 클래스에 정의 된 메소드를 통해이 채널의 파일을 강제로 변경하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="e2efb71f28362c6ba94145fb4692a35fb81e2fee" translate="yes" xml:space="preserve">
          <source>This method is only guaranteed to force changes that were made to this channel's file via the methods defined in this class. It may or may not force changes that were made by modifying the content of a &lt;a href=&quot;../mappedbytebuffer&quot;&gt;&lt;code&gt;&lt;i&gt;mapped byte buffer&lt;/i&gt;&lt;/code&gt;&lt;/a&gt; obtained by invoking the &lt;a href=&quot;filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method. Invoking the &lt;a href=&quot;../mappedbytebuffer#force--&quot;&gt;&lt;code&gt;force&lt;/code&gt;&lt;/a&gt; method of the mapped byte buffer will force changes made to the buffer's content to be written.</source>
          <target state="translated">이 메소드는이 클래스에 정의 된 메소드를 통해이 채널의 파일을 강제로 변경하도록 보장됩니다. &lt;a href=&quot;filechannel#map-java.nio.channels.FileChannel.MapMode-long-long-&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 얻은 &lt;a href=&quot;../mappedbytebuffer&quot;&gt; &lt;code&gt;&lt;i&gt;mapped byte buffer&lt;/i&gt;&lt;/code&gt; &lt;/a&gt; 의 컨텐츠를 수정하여 작성된 변경을 강제로 수행 할 수도 있고 수행하지 않을 수도 있습니다 . 매핑 된 바이트 버퍼 의 &lt;a href=&quot;../mappedbytebuffer#force--&quot;&gt; &lt;code&gt;force&lt;/code&gt; &lt;/a&gt; 메서드를 호출하면 버퍼 내용에 대한 변경 내용이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d932d5ffb45ee9273fcd52044f90174a48f5b33d" translate="yes" xml:space="preserve">
          <source>This method is only included for backwards compatibility. The caller is encouraged to use one of the alternative &lt;code&gt;getInstance&lt;/code&gt; methods to obtain a SecureRandom object, and then call the &lt;code&gt;generateSeed&lt;/code&gt; method to obtain seed bytes from that object.</source>
          <target state="translated">이 방법은 이전 버전과의 호환성을 위해서만 포함됩니다. 호출자는 대체 &lt;code&gt;getInstance&lt;/code&gt; 메소드 중 하나를 사용 하여 SecureRandom 오브젝트를 확보 한 다음 &lt;code&gt;generateSeed&lt;/code&gt; 메소드를 호출하여 해당 오브젝트에서 시드 바이트를 확보 하도록 권장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d86047eada462e41e106485f6536537db99992ce" translate="yes" xml:space="preserve">
          <source>This method is only useful to &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;s or &lt;a href=&quot;sslengine&quot;&gt;&lt;code&gt;SSLEngine&lt;/code&gt;&lt;/a&gt;s operating in client mode.</source>
          <target state="translated">이 방법은 클라이언트 모드에서 작동 하는 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sslengine&quot;&gt; &lt;code&gt;SSLEngine&lt;/code&gt; &lt;/a&gt; 에만 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0deda78995079ce571c6fdedc8bcba7a3c9ef0e0" translate="yes" xml:space="preserve">
          <source>This method is only useful to &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;s or &lt;a href=&quot;sslengine&quot;&gt;&lt;code&gt;SSLEngine&lt;/code&gt;&lt;/a&gt;s operating in server mode.</source>
          <target state="translated">이 방법은 서버 모드에서 작동 하는 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sslengine&quot;&gt; &lt;code&gt;SSLEngine&lt;/code&gt; &lt;/a&gt; 에만 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="cc16123913e32d2276fdcb747c706db178320295" translate="yes" xml:space="preserve">
          <source>This method is optionally supported by the platform. A Java virtual machine implementation may not support the compilation time monitoring. The &lt;a href=&quot;compilationmxbean#isCompilationTimeMonitoringSupported--&quot;&gt;&lt;code&gt;isCompilationTimeMonitoringSupported()&lt;/code&gt;&lt;/a&gt; method can be used to determine if the Java virtual machine supports this operation.</source>
          <target state="translated">이 방법은 플랫폼에서 선택적으로 지원됩니다. JVM (Java Virtual Machine) 구현은 컴파일 시간 모니터링을 지원하지 않을 수 있습니다. &lt;a href=&quot;compilationmxbean#isCompilationTimeMonitoringSupported--&quot;&gt; &lt;code&gt;isCompilationTimeMonitoringSupported()&lt;/code&gt; &lt;/a&gt; 메소드는 자바 가상 머신이 동작을 지원하는지 여부를 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="e9eba6216174e6e469eb9028a917a4a068eb5ab8" translate="yes" xml:space="preserve">
          <source>This method is overridden by providers to initialize this signature engine with the specified parameter set.</source>
          <target state="translated">이 메소드는 지정된 매개 변수 세트로이 서명 엔진을 초기화하기 위해 제공자가 대체합니다.</target>
        </trans-unit>
        <trans-unit id="82bae5be04e910bde32956a015712ff6e2661401" translate="yes" xml:space="preserve">
          <source>This method is overridden by providers to return the parameters used with this signature engine, or null if this signature engine does not use any parameters.</source>
          <target state="translated">공급자가이 서명 엔진에 사용 된 매개 변수를 반환하도록이 메서드를 재정의하거나이 서명 엔진이 매개 변수를 사용하지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69310362184bfccb6ad99d4021632a3e603dcaf5" translate="yes" xml:space="preserve">
          <source>This method is particularly useful when it is necessary to match a single certificate. Although other criteria can be specified in conjunction with the certificateEquals criterion, it is usually not practical or necessary.</source>
          <target state="translated">이 방법은 단일 인증서와 일치해야 할 때 특히 유용합니다. certificateEquals 기준과 함께 다른 기준을 지정할 수 있지만 일반적으로 실용적이지 않거나 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf22cca0f65499d090fa691c00a0b8927acdcd66" translate="yes" xml:space="preserve">
          <source>This method is potentially much more efficient than a simple loop that reads from the source channel and writes to this channel. Many operating systems can transfer bytes directly from the source channel into the filesystem cache without actually copying them.</source>
          <target state="translated">이 방법은 소스 채널에서 읽고이 채널에 쓰는 간단한 루프보다 훨씬 효율적입니다. 많은 운영 체제는 실제로 복사하지 않고 소스 채널에서 파일 시스템 캐시로 바이트를 직접 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965338e16ca02ac41bcc11da1b5e5b3d9cc0e44e" translate="yes" xml:space="preserve">
          <source>This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.</source>
          <target state="translated">이 방법은이 채널에서 읽고 대상 채널에 쓰는 간단한 루프보다 훨씬 효율적입니다. 많은 운영 체제는 실제로 복사하지 않고 파일 시스템 캐시에서 대상 채널로 바이트를 직접 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f48d4f8746d1c3929f7fdb278911b125505d722" translate="yes" xml:space="preserve">
          <source>This method is properly synchronized to allow correct use by more than one thread. However, if many threads need to generate pseudorandom numbers at a great rate, it may reduce contention for each thread to have its own pseudorandom-number generator.</source>
          <target state="translated">이 방법은 둘 이상의 스레드가 올바르게 사용할 수 있도록 올바르게 동기화됩니다. 그러나 많은 스레드가 의사 난수를 빠른 속도로 생성해야하는 경우 각 스레드가 자체 의사 난수 생성기를 갖도록 경합을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101600ec7ed55bc43fbc527e8ecb336047d15608" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-T:A-&quot;&gt;&lt;code&gt;Arrays.spliterator(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열에 대한 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-T:A-&quot;&gt; &lt;code&gt;Arrays.spliterator(Object[])&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="233cd71c4f4c3d8494a4f25e6bc13c8ed557b275" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-double:A-&quot;&gt;&lt;code&gt;Arrays.spliterator(double[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열의 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-double:A-&quot;&gt; &lt;code&gt;Arrays.spliterator(double[])&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e52f30a471de78b6d6f563be986bde804603120" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-double:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(double[], int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열의 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-double:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(double[], int, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c73a95d87370936cebde19acb3cc5abd7a766de4" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-int:A-&quot;&gt;&lt;code&gt;Arrays.spliterator(int[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열의 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-int:A-&quot;&gt; &lt;code&gt;Arrays.spliterator(int[])&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c10bc4c13749c2a7d95f8a6a7364d6dcdce4f25" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-int:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(int[], int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열의 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-int:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(int[], int, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa80526e45e313e734391312a3f78373a7fffb1f" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-long:A-&quot;&gt;&lt;code&gt;Arrays.spliterator(long[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열에 대한 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-long:A-&quot;&gt; &lt;code&gt;Arrays.spliterator(long[])&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f6b3004b45f86f57d7db79ba54946c43bd6fde40" translate="yes" xml:space="preserve">
          <source>This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt;&lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 요소의 일부를 어레이에 저장하고 스플리터 특성을 세밀하게 제어해야하는 스플리터의 구현 편의성으로 제공됩니다. 배열의 Spliterator가 필요한 대부분의 다른 상황에서는 &lt;a href=&quot;arrays#spliterator-long:A-int-int-&quot;&gt; &lt;code&gt;Arrays.spliterator(long[], int, int)&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96c33959308c322bb4e3c731a402f9adefbfa7c6" translate="yes" xml:space="preserve">
          <source>This method is provided because the generic URI syntax specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt; cannot always distinguish a malformed server-based authority from a legitimate registry-based authority. It must therefore treat some instances of the former as instances of the latter. The authority component in the URI string &lt;code&gt;&quot;//foo:bar&quot;&lt;/code&gt;, for example, is not a legal server-based authority but it is legal as a registry-based authority.</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396에&lt;/a&gt; 지정된 일반 URI 구문 은 잘못된 형식의 서버 기반 권한을 올바른 레지스트리 기반 권한과 항상 구별 할 수 없기 때문에이 방법이 제공됩니다 . 따라서 전자의 일부 인스턴스를 후자의 인스턴스로 취급해야합니다. 예를 들어, URI 문자열 &lt;code&gt;&quot;//foo:bar&quot;&lt;/code&gt; 의 권한 구성 요소 는 올바른 서버 기반 권한이 아니지만 레지스트리 기반 권한으로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="07060118cedf0a1e147ce625b28596254fb2290b" translate="yes" xml:space="preserve">
          <source>This method is provided for use in situations where it is known that the given string is a legal URI, for example for URI constants declared within in a program, and so it would be considered a programming error for the string not to parse as such. The constructors, which throw &lt;a href=&quot;urisyntaxexception&quot;&gt;&lt;code&gt;URISyntaxException&lt;/code&gt;&lt;/a&gt; directly, should be used situations where a URI is being constructed from user input or from some other source that may be prone to errors.</source>
          <target state="translated">이 메소드는 주어진 문자열이 올바른 URI, 예를 들어 프로그램에서 선언 된 URI 상수에 대해 알려진 상황에서 사용되도록 제공되므로 문자열을 구문 분석하지 않는 프로그래밍 오류로 간주됩니다. 던져 생성자 &lt;a href=&quot;urisyntaxexception&quot;&gt; &lt;code&gt;URISyntaxException&lt;/code&gt; 를&lt;/a&gt; 직접은 URI는 사용자 입력 또는 에러 경향이있을 수있다 다른 소스로부터 생성되는 경우 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="29825b65d703dd90721fbf064db666b8d222af07" translate="yes" xml:space="preserve">
          <source>This method is provided in Beans 1.0 as a hook to allow the addition of more flexible bean behaviour in the future.</source>
          <target state="translated">이 메소드는 Beans 1.0에서 나중에보다 유연한 Bean 동작을 추가 할 수있는 후크로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3f858bd0660b97820fcc102c6ef5e7861fa199" translate="yes" xml:space="preserve">
          <source>This method is provided so that this class can implement the &lt;a href=&quot;charsequence&quot;&gt;&lt;code&gt;CharSequence&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는이 클래스가 &lt;a href=&quot;charsequence&quot;&gt; &lt;code&gt;CharSequence&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현할 수 있도록 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ced8a306ed352d41e2ad9b6c7ba3935c30f1517" translate="yes" xml:space="preserve">
          <source>This method is required to be public, but should never be called explicitly. It performs the main run loop to execute &lt;a href=&quot;forkjointask&quot;&gt;&lt;code&gt;ForkJoinTask&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 메소드는 공용이어야하지만 명시 적으로 호출해서는 안됩니다. &lt;a href=&quot;forkjointask&quot;&gt; &lt;code&gt;ForkJoinTask&lt;/code&gt; &lt;/a&gt; 를 실행하기 위해 기본 실행 루프를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="ffdb81a47c22a3394dc922b8215d2c84d07174fb" translate="yes" xml:space="preserve">
          <source>This method is similar to the &lt;code&gt;wait&lt;/code&gt; method of one argument, but it allows finer control over the amount of time to wait for a notification before giving up. The amount of real time, measured in nanoseconds, is given by:</source>
          <target state="translated">이 메소드는 한 인수 의 &lt;code&gt;wait&lt;/code&gt; 메소드 와 유사 하지만 포기하기 전에 알림을 기다리는 시간을보다 세밀하게 제어 할 수 있습니다. 나노초 단위로 측정 된 실시간 양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c66e555a077ac4020400429a66bf556133088d7b" translate="yes" xml:space="preserve">
          <source>This method is suitable for reading bytes written by the &lt;code&gt;writeChar&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeChar&lt;/code&gt; 메소드로 쓴 바이트를 읽는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="673deb599d2dd33a1e5ca94ec7e660cf61e17e64" translate="yes" xml:space="preserve">
          <source>This method is suitable for reading bytes written by the &lt;code&gt;writeInt&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeInt&lt;/code&gt; 메소드로 쓴 바이트를 읽는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="65d867ab6fa3e8d89edaa5573fb88f5f9205d3e0" translate="yes" xml:space="preserve">
          <source>This method is suitable for reading bytes written by the &lt;code&gt;writeLong&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeLong&lt;/code&gt; 메소드로 쓴 바이트를 읽는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="5492ebe6d0a5b3c366da2e3dab322787fb344b92" translate="yes" xml:space="preserve">
          <source>This method is suitable for reading the bytes written by the &lt;code&gt;writeShort&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt; if the argument to &lt;code&gt;writeShort&lt;/code&gt; was intended to be a value in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;65535&lt;/code&gt;.</source>
          <target state="translated">이 방법에 의해 작성된 바이트 판독 적합 &lt;code&gt;writeShort&lt;/code&gt; 와의 인터페이스에있어서 &lt;code&gt;DataOutput&lt;/code&gt; 에게 인수하는 경우 &lt;code&gt;writeShort&lt;/code&gt; 와이 범위의 값이되도록 &lt;code&gt;0&lt;/code&gt; 을 &lt;code&gt;65535&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dde600a07b50792acdc44c87de16be4fe55e06f9" translate="yes" xml:space="preserve">
          <source>This method is suitable for reading the bytes written by the &lt;code&gt;writeShort&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeShort&lt;/code&gt; 메소드로 쓴 바이트를 읽는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="17df461a168269c9f058c6ae020b2e4100b88035" translate="yes" xml:space="preserve">
          <source>This method is the same as &lt;code&gt;NamingManager.getObjectInstance&lt;/code&gt; except for the following differences:</source>
          <target state="translated">이 메소드는 다음 차이점을 제외하고 &lt;code&gt;NamingManager.getObjectInstance&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="24192bfca73e7b179eecb35ca9ab3868f6216fd1" translate="yes" xml:space="preserve">
          <source>This method is to be overridden when extending this service to support caching and versioning. It is called from &lt;a href=&quot;mlet#getMBeansFromURL-java.net.URL-&quot;&gt;&lt;code&gt;getMBeansFromURL&lt;/code&gt;&lt;/a&gt; when the version, codebase, and jarfile have been extracted from the MLet file, and can be used to verify that it is all right to load the given MBean, or to replace the given URL with a different one.</source>
          <target state="translated">캐싱 및 버전 관리를 지원하기 위해이 서비스를 확장 할 때이 방법을 재정의해야합니다. 버전, 코드베이스 및 jar 파일이 MLet 파일에서 추출 된 경우 &lt;a href=&quot;mlet#getMBeansFromURL-java.net.URL-&quot;&gt; &lt;code&gt;getMBeansFromURL&lt;/code&gt; &lt;/a&gt; 에서 호출되며 지정된 MBean을로드하거나 지정된 URL을 다른 것으로 대체 할 수 있는지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="951395b4b75eb438f62bfbeb152ae6d223075561" translate="yes" xml:space="preserve">
          <source>This method is typically</source>
          <target state="translated">이 방법은 일반적으로</target>
        </trans-unit>
        <trans-unit id="ae63b78449e9e42c635caa7843a810d1aa57cffe" translate="yes" xml:space="preserve">
          <source>This method is typically called from the environment in order to determine if the implementor &quot;needs&quot; a GUI.</source>
          <target state="translated">이 메소드는 구현자가 GUI를 &quot;필요&quot;하는지 판별하기 위해 일반적으로 환경에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b7126e7970c8cf4e25d7d94afe1028c943cd33c1" translate="yes" xml:space="preserve">
          <source>This method is typically invoked from within a task's run method, to determine whether the current execution of the task is sufficiently timely to warrant performing the scheduled activity:</source>
          <target state="translated">이 메소드는 일반적으로 태스크의 실행 메소드에서 호출되어 현재 태스크 실행이 스케줄 된 활동 수행을 보장 할 수있을만큼시기 적절한 지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="a1daf7353acd79b3c1764e98f4066dec0663ce7b" translate="yes" xml:space="preserve">
          <source>This method is typically used for debugging and testing purposes.</source>
          <target state="translated">이 방법은 일반적으로 디버깅 및 테스트 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2251827349b72099d9acb0597d3ef960a5681705" translate="yes" xml:space="preserve">
          <source>This method is unlike others in this and related interfaces. It operates on runtime reflective information &amp;mdash; representations of annotation types currently loaded into the VM &amp;mdash; rather than on the representations defined by and used throughout these interfaces. Consequently, calling methods on the returned annotation object can throw many of the exceptions that can be thrown when calling methods on an annotation object returned by core reflection. This method is intended for callers that are written to operate on a known, fixed set of annotation types.</source>
          <target state="translated">이 방법은이 인터페이스 및 관련 인터페이스의 다른 방법과 다릅니다. 이 인터페이스에서 정의되고 사용되는 표현이 아니라 런타임 반사 정보 (현재 VM에로드 된 주석 유형의 표현)에서 작동합니다. 결과적으로, 리턴 된 주석 오브젝트에서 메소드를 호출하면 코어 리플렉션으로 리턴 된 주석 오브젝트에서 메소드를 호출 할 때 발생할 수있는 많은 예외가 발생할 수 있습니다. 이 방법은 알려진 고정 된 주석 유형 집합에서 작동하도록 작성된 발신자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="aea5a6a6faade2d9a3e9582074c60fe04111f203" translate="yes" xml:space="preserve">
          <source>This method is used by the &lt;code&gt;getProperties&lt;/code&gt; and &lt;code&gt;setProperties&lt;/code&gt; methods of class &lt;code&gt;System&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;System&lt;/code&gt; 클래스 의 &lt;code&gt;getProperties&lt;/code&gt; 및 &lt;code&gt;setProperties&lt;/code&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b98243b99ff34e00c9ef9a60fbb86ed96ec5a16" translate="yes" xml:space="preserve">
          <source>This method is used by the &lt;code&gt;getProperty&lt;/code&gt; method of class &lt;code&gt;System&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;System&lt;/code&gt; 클래스 의 &lt;code&gt;getProperty&lt;/code&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a5905740e8a36aa9964becd355adbc6cf3194d" translate="yes" xml:space="preserve">
          <source>This method is used by the &lt;code&gt;loadClass&lt;/code&gt; method of class loaders.</source>
          <target state="translated">이 메소드는 클래스 로더 의 &lt;code&gt;loadClass&lt;/code&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9667fe0131b3f57e0e230d7f8071e4addf0b27dd" translate="yes" xml:space="preserve">
          <source>This method is used by the &lt;code&gt;loadClass&lt;/code&gt; method of some class loaders.</source>
          <target state="translated">이 메소드는 일부 클래스 로더 의 &lt;code&gt;loadClass&lt;/code&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfe37395eb27f1aaf5b50a8b678a0f630640cc5e" translate="yes" xml:space="preserve">
          <source>This method is used to enable streaming of a HTTP request body without internal buffering, when the content length is &lt;b&gt;not&lt;/b&gt; known in advance. In this mode, chunked transfer encoding is used to send the request body. Note, not all HTTP servers support this mode.</source>
          <target state="translated">이 방법은 컨텐츠 길이 를 미리 알 수 &lt;b&gt;없는&lt;/b&gt; 경우 내부 버퍼링없이 HTTP 요청 본문을 스트리밍 할 수 있도록 합니다. 이 모드에서는 청크 전송 인코딩을 사용하여 요청 본문을 보냅니다. 모든 HTTP 서버가이 모드를 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9c8fdc5fc14c7dbd8f5a8384988f1bd062b27d76" translate="yes" xml:space="preserve">
          <source>This method is used to enable streaming of a HTTP request body without internal buffering, when the content length is known in advance.</source>
          <target state="translated">이 방법은 컨텐츠 길이를 미리 알고있을 때 내부 버퍼링없이 HTTP 요청 본문을 스트리밍 할 수 있도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b55097c024b0b0b02045eedaa78a111259066a" translate="yes" xml:space="preserve">
          <source>This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the associated channel is closed.</source>
          <target state="translated">이 방법은 소켓과 로컬 주소 사이의 연결을 설정하는 데 사용됩니다. 연결이 설정되면 관련 채널이 닫힐 때까지 소켓이 바인딩 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d9dfa7289fc99c05acc6f156086be826f379c086" translate="yes" xml:space="preserve">
          <source>This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed.</source>
          <target state="translated">이 방법은 소켓과 로컬 주소 사이의 연결을 설정하는 데 사용됩니다. 연결이 설정되면 소켓은 채널이 닫힐 때까지 바인딩 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7b394514f43b5846b11c1c15ed38e5c851d06c0d" translate="yes" xml:space="preserve">
          <source>This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the &lt;code&gt;local&lt;/code&gt; parameter has the value &lt;code&gt;null&lt;/code&gt; then the socket will be bound to an address that is assigned automatically.</source>
          <target state="translated">이 방법은 소켓과 로컬 주소 사이의 연결을 설정하는 데 사용됩니다. 연결이 설정되면 소켓은 채널이 닫힐 때까지 바인딩 된 상태로 유지됩니다. 경우 &lt;code&gt;local&lt;/code&gt; 매개 변수 값이 &lt;code&gt;null&lt;/code&gt; 다음 소켓이 자동으로 할당 된 주소에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="2baece6a8ac06e1fc4a9ff2b40d62ea4d61c8a8f" translate="yes" xml:space="preserve">
          <source>This method is used to replace the definition of a class without reference to the existing class file bytes, as one might do when recompiling from source for fix-and-continue debugging. Where the existing class file bytes are to be transformed (for example in bytecode instrumentation) &lt;a href=&quot;instrumentation#retransformClasses-java.lang.Class...-&quot;&gt;&lt;code&gt;retransformClasses&lt;/code&gt;&lt;/a&gt; should be used.</source>
          <target state="translated">이 메소드는 기존 클래스 파일 바이트를 참조하지 않고 클래스 정의를 바꾸는 데 사용됩니다. 수정 및 계속 디버깅을 위해 소스에서 다시 컴파일 할 때 수행 할 수 있습니다. 기존 클래스 파일 바이트를 &lt;a href=&quot;instrumentation#retransformClasses-java.lang.Class...-&quot;&gt; &lt;code&gt;retransformClasses&lt;/code&gt; &lt;/a&gt; 해야하는 경우 (예 : 바이트 코드 계측에서) retransformClasses를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7beea796e1e20476ce67129e3d8dfb3b59481b17" translate="yes" xml:space="preserve">
          <source>This method is used with indirect CRLs. The default implementation always returns null. Subclasses that wish to support indirect CRLs should override it.</source>
          <target state="translated">이 방법은 간접 CRL과 함께 사용됩니다. 기본 구현은 항상 null을 반환합니다. 간접 CRL을 지원하려는 서브 클래스는이를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="246cc95dbbc3e601d773b72cc235c82bbbfeaff8" translate="yes" xml:space="preserve">
          <source>This method is useful for clients which have only dimensions and want to find a Media which corresponds to the dimensions.</source>
          <target state="translated">이 방법은 차원 만 있고 차원에 해당하는 미디어를 찾으려는 클라이언트에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e84c50c958c46a9102a7f8120bd2674f50221c85" translate="yes" xml:space="preserve">
          <source>This method is useful for implementing &lt;a href=&quot;../lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; on objects containing multiple fields. For example, if an object that has three fields, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, one could write:</source>
          <target state="translated">이 메소드는 여러 필드를 포함하는 객체에서 &lt;a href=&quot;../lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 를 구현하는 데 유용 합니다. 예를 들어, 세 개의 필드 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 가있는 객체는 다음 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b747ebeeb82d358021370528749c1fdbd9859486" translate="yes" xml:space="preserve">
          <source>This method is useful to help locate a service that can print a &lt;code&gt;MultiDoc&lt;/code&gt; in which the elements may be different flavors. An application could perform this itself by multiple lookups on each &lt;code&gt;DocFlavor&lt;/code&gt; in turn and collating the results, but the lookup service may be able to do this more efficiently.</source>
          <target state="translated">이 방법은 요소가 다른 풍미 일 수 있는 &lt;code&gt;MultiDoc&lt;/code&gt; 을 인쇄 할 수있는 서비스를 찾는 데 유용합니다 . 응용 프로그램은 각 &lt;code&gt;DocFlavor&lt;/code&gt; 에서 여러 번 조회 하여 결과를 조합 하여이 작업을 자체적으로 수행 할 수 있지만 조회 서비스가이를보다 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ce74596c8f01cac825f66644d842ba43ddd4b9" translate="yes" xml:space="preserve">
          <source>This method is useful when a client needs to &quot;narrow&quot; the type of a &lt;code&gt;Class&lt;/code&gt; object to pass it to an API that restricts the &lt;code&gt;Class&lt;/code&gt; objects that it is willing to accept. A cast would generate a compile-time warning, as the correctness of the cast could not be checked at runtime (because generic types are implemented by erasure).</source>
          <target state="translated">이 메소드는 클라이언트가 &lt;code&gt;Class&lt;/code&gt; 객체 의 유형을 &quot;좁히고&quot; 수용 할 &lt;code&gt;Class&lt;/code&gt; 객체를 제한하는 API로 전달 해야 할 때 유용합니다 . 캐스트는 런타임에 캐스트의 정확성을 확인할 수 없으므로 컴파일 시간 경고를 생성합니다 (일반 유형은 삭제로 구현되기 때문).</target>
        </trans-unit>
        <trans-unit id="443baa96b0aa5c9903d7dc90504d8dd2b62d5718" translate="yes" xml:space="preserve">
          <source>This method is usually used to check key size and key usage.</source>
          <target state="translated">이 방법은 일반적으로 키 크기와 키 사용을 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb16de8796afac4493e5774b44ae736259861eaa" translate="yes" xml:space="preserve">
          <source>This method iterates over the &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt;&lt;code&gt;installed&lt;/code&gt;&lt;/a&gt; providers to locate the provider that is identified by the URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt; of the given URI. URI schemes are compared without regard to case. If the provider is found then its &lt;a href=&quot;spi/filesystemprovider#getPath-java.net.URI-&quot;&gt;&lt;code&gt;getPath&lt;/code&gt;&lt;/a&gt; method is invoked to convert the URI.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt; &lt;code&gt;installed&lt;/code&gt; &lt;/a&gt; 제공자를 반복 하여 지정된 URI 의 URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 으로 식별되는 제공자를 찾습니다 . URI 스킴은 대소 문자와 상관없이 비교됩니다. 제공자를 찾으면 &lt;a href=&quot;spi/filesystemprovider#getPath-java.net.URI-&quot;&gt; &lt;code&gt;getPath&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 URI를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8cd1a28468ba1f52b37e42cb2a38da8ff584a3cb" translate="yes" xml:space="preserve">
          <source>This method iterates over the &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt;&lt;code&gt;installed&lt;/code&gt;&lt;/a&gt; providers to locate the provider that is identified by the URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt; of the given URI. URI schemes are compared without regard to case. The exact form of the URI is highly provider dependent. If found, the provider's &lt;a href=&quot;spi/filesystemprovider#getFileSystem-java.net.URI-&quot;&gt;&lt;code&gt;getFileSystem&lt;/code&gt;&lt;/a&gt; method is invoked to obtain a reference to the &lt;code&gt;FileSystem&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt; &lt;code&gt;installed&lt;/code&gt; &lt;/a&gt; 제공자를 반복 하여 지정된 URI 의 URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 으로 식별되는 제공자를 찾습니다 . URI 스킴은 대소 문자와 상관없이 비교됩니다. URI의 정확한 형식은 공급자에 따라 크게 다릅니다. 발견되면, 제공자의 &lt;a href=&quot;spi/filesystemprovider#getFileSystem-java.net.URI-&quot;&gt; &lt;code&gt;getFileSystem&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 &lt;code&gt;FileSystem&lt;/code&gt; 에 대한 참조를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="6d4a846b184f75a1e6db8c84642469ea6b00dfb6" translate="yes" xml:space="preserve">
          <source>This method iterates over the &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt;&lt;code&gt;installed&lt;/code&gt;&lt;/a&gt; providers to locate the provider that is identified by the URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt; of the given URI. URI schemes are compared without regard to case. The exact form of the URI is highly provider dependent. If found, the provider's &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt;&lt;/a&gt; method is invoked to construct the new file system.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt; &lt;code&gt;installed&lt;/code&gt; &lt;/a&gt; 제공자를 반복 하여 지정된 URI 의 URI &lt;a href=&quot;../../net/uri#getScheme--&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 으로 식별되는 제공자를 찾습니다 . URI 스킴은 대소 문자와 상관없이 비교됩니다. URI의 정확한 형식은 공급자에 따라 크게 다릅니다. 발견되면 제공자의 &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 새 파일 시스템을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="880033cb82cb31b9387a5336555aa2900c785f59" translate="yes" xml:space="preserve">
          <source>This method iterates over the &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt;&lt;code&gt;installed&lt;/code&gt;&lt;/a&gt; providers. It invokes, in turn, each provider's &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.nio.file.Path-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(Path,Map)&lt;/code&gt;&lt;/a&gt; method with an empty map. If a provider returns a file system then the iteration terminates and the file system is returned. If none of the installed providers return a &lt;code&gt;FileSystem&lt;/code&gt; then an attempt is made to locate the provider using the given class loader. If a provider returns a file system then the lookup terminates and the file system is returned.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;spi/filesystemprovider#installedProviders--&quot;&gt; &lt;code&gt;installed&lt;/code&gt; &lt;/a&gt; 공급자를 반복합니다 . 빈 맵으로 각 제공자의 &lt;a href=&quot;spi/filesystemprovider#newFileSystem-java.nio.file.Path-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(Path,Map)&lt;/code&gt; &lt;/a&gt; 메소드를 차례로 호출합니다 . 제공자가 파일 시스템을 리턴하면 반복이 종료되고 파일 시스템이 리턴됩니다. 설치된 제공자가 &lt;code&gt;FileSystem&lt;/code&gt; 을 리턴하지 않으면 제공된 클래스 로더를 사용하여 제공자를 찾으려고 시도합니다. 공급자가 파일 시스템을 반환하면 조회가 종료되고 파일 시스템이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6df3229f6bcb65c48929367cf8b4e6d901764147" translate="yes" xml:space="preserve">
          <source>This method iterates over the entire collection, hence it requires time proportional to the size of the collection.</source>
          <target state="translated">이 방법은 전체 컬렉션을 반복하므로 컬렉션의 크기에 비례하는 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea8ef674ef4d61ebebe97a398544ed83610076c4" translate="yes" xml:space="preserve">
          <source>This method loads the class through the system class loader (see &lt;a href=&quot;classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;Class&lt;/code&gt; object returned might have more than one &lt;code&gt;ClassLoader&lt;/code&gt; associated with it. Subclasses of &lt;code&gt;ClassLoader&lt;/code&gt; need not usually invoke this method, because most class loaders need to override just &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt;&lt;code&gt;findClass(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 시스템 클래스 로더를 통해 클래스를로드합니다 ( &lt;a href=&quot;classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조 ). 리턴 된 &lt;code&gt;Class&lt;/code&gt; 오브젝트에는 둘 이상의 &lt;code&gt;ClassLoader&lt;/code&gt; 가 연관되어있을 수 있습니다. 대부분의 클래스 로더는 &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt; &lt;code&gt;findClass(String)&lt;/code&gt; &lt;/a&gt; 만 재정의해야하기 때문에 일반적으로 &lt;code&gt;ClassLoader&lt;/code&gt; 의 서브 클래스는 이 메소드를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8d62d43c3776299e4d329c965c00fa4654ac85c4" translate="yes" xml:space="preserve">
          <source>This method locates the implementation class by locating configuration files that have the name:</source>
          <target state="translated">이 메소드는 이름이 다음과 같은 구성 파일을 찾아 구현 클래스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9d0ddb3ec0e9b63b8855a417b281e5a02579b5c0" translate="yes" xml:space="preserve">
          <source>This method makes a best effort to ensure that, when it returns, this buffer's content is resident in physical memory. Invoking this method may cause some number of page faults and I/O operations to occur.</source>
          <target state="translated">이 메소드는 리턴시이 버퍼의 컨텐츠가 실제 메모리에 상주하도록 최선의 노력을합니다. 이 메소드를 호출하면 몇 가지 페이지 결함 및 I / O 조작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9921a4667dc98347a6a5af87ed73e8712213cd69" translate="yes" xml:space="preserve">
          <source>This method makes a copy of the input</source>
          <target state="translated">이 방법은 입력 사본을 만듭니다</target>
        </trans-unit>
        <trans-unit id="d6f231365be0d37f8241f85ca2031c19c3f8582e" translate="yes" xml:space="preserve">
          <source>This method makes use of specialized providers that create pseudo file systems where the contents of one or more files is treated as a file system.</source>
          <target state="translated">이 방법은 하나 이상의 파일 내용이 파일 시스템으로 취급되는 의사 파일 시스템을 작성하는 특수 제공자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87831c1145b7ecfcd50086de895ead157d421184" translate="yes" xml:space="preserve">
          <source>This method marks the group as shutdown. Further attempts to construct channel that binds to this group will throw &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;. The group terminates when all asynchronous channels in the group are closed, all actively executing completion handlers have run to completion, and all resources have been released. This method has no effect if the group is already shutdown.</source>
          <target state="translated">이 방법은 그룹을 종료로 표시합니다. 이 그룹에 바인딩하는 채널을 구성하려고하면 &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 그룹의 모든 비동기 채널이 닫히고 활성으로 실행중인 완료 핸들러가 모두 완료되어 모든 자원이 해제되면 그룹이 종료됩니다. 그룹이 이미 종료 된 경우에는이 방법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bd105ab3143b10410eab88d0e59df3ae5ab16bb" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ChronoLocalDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ChronoLocalDate::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac5120e3bd52460e6e089e4c46c26ce2f1b840e7" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ChronoLocalDateTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ChronoLocalDateTime::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="183368440bb5769b4acd7d313fcc33686e552e51" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ChronoZonedDateTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ChronoZonedDateTime::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d82d20a7a1494a7568e46b779689118249e44bf6" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;Chronology::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;Chronology::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea90316fb88c8c28da4f47c63da7e0a320c1082" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;HijrahDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;HijrahDate::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7be7f49b8bc16966463730f7584f2b9b3152370e" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;JapaneseDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;JapaneseDate::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22e4e2128ff8c1a41cf57413e39c789abdb2efc4" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;MinguoDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;MinguoDate::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ba7885f8f7bf403703ef79cba625829e63b867a" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ThaiBuddhistDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 시그니처와 일치하여 &lt;code&gt;ThaiBuddhistDate::from&lt;/code&gt; 메소드 참조를 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="151a8ab12c11fab6d22dbeb578df6cb816782058" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;aChronology::date&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;aChronology::date&lt;/code&gt; 를 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15f0eca90f7c5cc575db09166254ef53c7276122" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;aChronology::localDateTime&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;aChronology::localDateTime&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3c0b9acbca4d46fca9daf990a80203ee11ec47e" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;../temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;aChronology::zonedDateTime&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;../temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;aChronology::zonedDateTime&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44b767687682694c82976cf1a39c4b2b46cff9af" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;DayOfWeek::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;DayOfWeek::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5cb8f2a059ef45511793934786eaabd023ce42ec" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;Instant::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;Instant::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13154f1a9ecebad2a777e49819a84f24e0e69cb4" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;LocalDate::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;LocalDate::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c9e8d8492bed2fe614fac5fa306ef20277027a7" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;LocalDateTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;LocalDateTime::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f24a5d62e15bf3f67196638710c031a5e203585" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;LocalTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;LocalTime::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bc36efb4efac3db95fb586701f584ff93c74d2e" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;Month::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 인 &lt;code&gt;Month::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a998edc76008d24866649f88e7e9d58793c9ac6" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;MonthDay::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 시그니처와 일치하여 메소드 참조 &lt;code&gt;MonthDay::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f38a7887b37ae3bebb712497a2af95a051e4e28b" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;OffsetDateTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;OffsetDateTime::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9669db98b3799bf0527a97e0cad3ac99b1ee9ac4" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;OffsetTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;OffsetTime::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0f1311c7003c8358466cd838c5637eadee93e4a" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;Year::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;Year::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff52ef986de3006f73c3aab82753ed75019f518e" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;YearMonth::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 &lt;code&gt;YearMonth::from&lt;/code&gt; 메소드 참조를 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd7ded58c5a7c1d96e2b2efb214f272632889b28" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ZoneId::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ZoneId::from&lt;/code&gt; 통해 조회로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45262e36bd147b147a453ec34749097650a697ea" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ZoneOffset::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ZoneOffset::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1550588151e8ce50ca6009abbaa39d79bd38d733" translate="yes" xml:space="preserve">
          <source>This method matches the signature of the functional interface &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; allowing it to be used as a query via method reference, &lt;code&gt;ZonedDateTime::from&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 기능 인터페이스 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 의 서명과 일치하여 메소드 참조 &lt;code&gt;ZonedDateTime::from&lt;/code&gt; 통해 조회로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b16bf47b83723a0f8dab0f28952e13be8b08e85" translate="yes" xml:space="preserve">
          <source>This method may be called at most once.</source>
          <target state="translated">이 메소드는 최대 한 번 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a43de8dae8c31a955a3ede73579346e4f5c7fe" translate="yes" xml:space="preserve">
          <source>This method may be called from multiple threads in parallel. It must be thread-safe when invoked.</source>
          <target state="translated">이 메소드는 여러 스레드에서 병렬로 호출 될 수 있습니다. 호출 될 때 스레드로부터 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="6585c4dd5931dcf510c4f8fae01a67857b8ffc66" translate="yes" xml:space="preserve">
          <source>This method may be called repeatedly; the second and subsequent calls have no effect.</source>
          <target state="translated">이 메소드는 반복적으로 호출 될 수 있습니다. 두 번째 및 후속 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="63ee5b49d5f6750d4acf7a8f7672f0a71d7c5839" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 이 메소드의 호출이 진행되는 동안이 채널에 대한 읽기 또는 쓰기 조작이 호출되면이 호출이 완료 될 때까지 해당 조작이 먼저 차단됩니다. 연결 시도가 실패하는 경우, 즉이 메소드의 호출로 확인 된 예외가 발생하면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c4e7298ffd742d1f317317b55f1bddb77d7a9ae1" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If a read or write operation upon this channel is invoked while an invocation of this method is in progress then that operation will first block until this invocation is complete. If a connection attempt is initiated but fails, that is, if an invocation of this method throws a checked exception, then the channel will be closed.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 이 메소드의 호출이 진행되는 동안이 채널에 대한 읽기 또는 쓰기 조작이 호출되면이 호출이 완료 될 때까지 해당 조작이 먼저 차단됩니다. 연결 시도가 시작되었지만 실패한 경우, 즉이 메소드를 호출하여 확인 된 예외가 발생하면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="bbb6e41f03da9e7796c8ef3b5cfa0d71b7a3b6f2" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 그러나 다른 스레드가이 채널에서 이미 읽기 작업을 시작한 경우 첫 번째 작업이 완료 될 때까지이 메서드의 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="97d8a3cea23f3f5dd331548174018d7613ac9cea" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; method with a parameter of &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 그러나 다른 스레드가이 채널에서 이미 읽기 작업을 시작한 경우 첫 번째 작업이 완료 될 때까지이 메서드의 호출이 차단됩니다. 이 채널의 소켓이 바인드되어 있지 않은 경우,이 메소드는 , 파라미터가 &lt;code&gt;null&lt;/code&gt; 의 &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼, 소켓이 자동적으로 할당 된 주소에 바인드 됩니다.</target>
        </trans-unit>
        <trans-unit id="87dfa6f24f76e26d0921f1573308ed86b584bd10" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 그러나 다른 스레드가이 채널에서 쓰기 작업을 이미 시작한 경우 첫 번째 작업이 완료 될 때까지이 메소드의 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b172c4b318a4900cba6cabc26273027474dce2" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; method with a parameter of &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 그러나 다른 스레드가이 채널에서 쓰기 작업을 이미 시작한 경우 첫 번째 작업이 완료 될 때까지이 메소드의 호출이 차단됩니다. 이 채널의 소켓이 바인드되어 있지 않은 경우,이 메소드는 , 파라미터가 &lt;code&gt;null&lt;/code&gt; 의 &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼, 소켓이 자동적으로 할당 된 주소에 바인드 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0d453cd13881714b408166a430d7ef367765c16" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If some other thread has already invoked it, however, then another invocation will block until the first invocation is complete, after which it will return without effect.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 그러나 다른 스레드가 이미 호출 한 경우 첫 번째 호출이 완료 될 때까지 다른 호출이 차단 된 후 아무런 효과없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8874f15f4ccf8af8534b2ee953d6b106c497b4" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. If this method is invoked while another invocation of this method or of the &lt;a href=&quot;selectablechannel#configureBlocking-boolean-&quot;&gt;&lt;code&gt;configureBlocking&lt;/code&gt;&lt;/a&gt; method is in progress then it will first block until the other operation is complete. This method will then synchronize on the selector's key set and therefore may block if invoked concurrently with another registration or selection operation involving the same selector.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 이 메소드 또는 &lt;a href=&quot;selectablechannel#configureBlocking-boolean-&quot;&gt; &lt;code&gt;configureBlocking&lt;/code&gt; &lt;/a&gt; 메소드 의 다른 호출이 진행되는 동안이 메소드가 호출 되면 다른 조작이 완료 될 때까지 먼저 차단됩니다. 그런 다음이 방법은 선택기의 키 세트에서 동기화되므로 동일한 선택기를 포함하는 다른 등록 또는 선택 작업과 동시에 호출되는 경우 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7815f3c8928d6111c4c25114f73627a45d89a3" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. It synchronizes on the selector's cancelled-key set, and therefore may block briefly if invoked concurrently with a cancellation or selection operation involving the same selector.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 선택기의 취소 된 키 세트에서 동기화되므로 동일한 선택기와 관련된 취소 또는 선택 조작과 동시에 호출되는 경우 잠시 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc88b4f9995e416d1012e6ada90de268269c98dc" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 호출 된 시점에서 이미 진행중인 읽기 또는 쓰기 작업에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e010dba7e883e9cc772c2dfa4328263d83f4af89" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; method with a parameter of &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 호출 된 시점에서 이미 진행중인 읽기 또는 쓰기 작업에는 영향을 미치지 않습니다. 이 채널의 소켓이 바인드되어 있지 않은 경우,이 메소드는 , 파라미터가 &lt;code&gt;null&lt;/code&gt; 의 &lt;a href=&quot;datagramchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼, 소켓이 자동적으로 할당 된 주소에 바인드 됩니다.</target>
        </trans-unit>
        <trans-unit id="c163301ef227ad12e6f276fad354f6797a4c1833" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. Some channel types may not allow more than one read to be outstanding at any given time. If a thread initiates a read operation before a previous read operation has completed then a &lt;a href=&quot;readpendingexception&quot;&gt;&lt;code&gt;ReadPendingException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 일부 채널 유형은 주어진 시간에 하나 이상의 읽기가 미해결되도록 허용하지 않을 수 있습니다. 이전 읽기 작업이 완료되기 전에 스레드가 읽기 작업을 시작하면 &lt;a href=&quot;readpendingexception&quot;&gt; &lt;code&gt;ReadPendingException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7caca2c8037750c753708585aaeb6aaff4c1fbc9" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. Some channel types may not allow more than one write to be outstanding at any given time. If a thread initiates a write operation before a previous write operation has completed then a &lt;a href=&quot;writependingexception&quot;&gt;&lt;code&gt;WritePendingException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 일부 채널 유형은 주어진 시간에 둘 이상의 쓰기가 미해결되도록 허용하지 않을 수 있습니다. 스레드가 이전 쓰기 작업이 완료되기 전에 쓰기 작업을 시작하면 &lt;a href=&quot;writependingexception&quot;&gt; &lt;code&gt;WritePendingException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d2f307030083dd150bccbf7e6545a39340de101" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. The new blocking mode will only affect I/O operations that are initiated after this method returns. For some implementations this may require blocking until all pending I/O operations are complete.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 새로운 차단 모드는이 메소드가 리턴 된 후에 시작된 I / O 조작에만 영향을줍니다. 일부 구현의 경우 보류중인 모든 I / O 작업이 완료 될 때까지 차단이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c46e90da40e0941dca9fb83de2c1c52caf821881" translate="yes" xml:space="preserve">
          <source>This method may be invoked at any time. Whether or not it blocks, and for how long, is implementation-dependent.</source>
          <target state="translated">이 메소드는 언제든지 호출 할 수 있습니다. 차단 여부 및 기간은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fca71c654c6c4a1448dcfc2c9c6cffb17d00042b" translate="yes" xml:space="preserve">
          <source>This method may be overridden by a provider to return the digest length.</source>
          <target state="translated">이 메소드는 다이제스트 길이를 리턴하기 위해 제공자가 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb0bb3c20b7e410c4131d82450240cfb2a11f14" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to provide their own initialization behaviors. When invoked any resources required by the BeanContextChild should be obtained from the current BeanContext.</source>
          <target state="translated">이 메소드는 자체 초기화 동작을 제공하기 위해 서브 클래스에 의해 대체 될 수 있습니다. BeanContextChild에 필요한 자원을 호출하면 현재 BeanContext에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="4a304dadf3249e61c60f51360a60dad3cf993c26" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to provide their own release behaviors. When invoked any resources held by this instance obtained from its current BeanContext property should be released since the object is no longer nested within that BeanContext.</source>
          <target state="translated">이 메소드는 자체의 릴리스 동작을 제공하기 위해 서브 클래스에 의해 대체 될 수 있습니다. 현재 BeanContext 속성에서 얻은이 인스턴스가 보유한 모든 리소스를 호출하면 객체가 해당 BeanContext 내에 더 이상 중첩되지 않으므로 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d55991a1b2e5a6461ba13e37f0f15a127e36842" translate="yes" xml:space="preserve">
          <source>This method may be overridden in subclasses, but if so, must still ensure that these properties hold. In particular, the &lt;code&gt;cancel&lt;/code&gt; method itself must not throw exceptions.</source>
          <target state="translated">이 메소드는 서브 클래스에서 대체 될 수 있지만,이 경우 여전히 이러한 특성을 보유해야합니다. 특히, &lt;code&gt;cancel&lt;/code&gt; 메소드 자체는 예외를 발생시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7cab176de1bca317891395340e0aad5bde002f6c" translate="yes" xml:space="preserve">
          <source>This method may be overridden in subclasses. The default behavior in this base class is that the first call is reported to System.err, and subsequent calls are ignored.</source>
          <target state="translated">이 메소드는 서브 클래스에서 재정의 될 수 있습니다. 이 기본 클래스의 기본 동작은 첫 번째 호출이 System.err에보고되고 후속 호출은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eeeaca67eebbcded76ba0f0bb85b3d4ff245fe26" translate="yes" xml:space="preserve">
          <source>This method may be used by the &lt;a href=&quot;../files#isReadable-java.nio.file.Path-&quot;&gt;&lt;code&gt;isReadable&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../files#isWritable-java.nio.file.Path-&quot;&gt;&lt;code&gt;isWritable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../files#isExecutable-java.nio.file.Path-&quot;&gt;&lt;code&gt;isExecutable&lt;/code&gt;&lt;/a&gt; methods to check the accessibility of a file.</source>
          <target state="translated">이 메소드는 파일의 액세스 가능성을 확인하기 위해 &lt;a href=&quot;../files#isReadable-java.nio.file.Path-&quot;&gt; &lt;code&gt;isReadable&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../files#isWritable-java.nio.file.Path-&quot;&gt; &lt;code&gt;isWritable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../files#isExecutable-java.nio.file.Path-&quot;&gt; &lt;code&gt;isExecutable&lt;/code&gt; &lt;/a&gt; 메소드에 의해 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c5fd44ffb016caed67a281608469ded4a8fe690" translate="yes" xml:space="preserve">
          <source>This method may be used multiple times to add multiple JAR files to be searched in the order that this method was invoked.</source>
          <target state="translated">이 메소드는 여러 번 사용되어이 메소드가 호출 된 순서대로 검색 할 여러 JAR 파일을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="423277e3d8d80a8c7c093ff691fc71c48df5648f" translate="yes" xml:space="preserve">
          <source>This method may be used to iterate over the JapaneseEras as follows:</source>
          <target state="translated">이 방법은 다음과 같이 JapaneseEras를 반복하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555850bf1f4c41d86e90ad7f126646ac30741843" translate="yes" xml:space="preserve">
          <source>This method may be used to trim whitespace (as defined above) from the beginning and end of a string.</source>
          <target state="translated">이 방법은 문자열의 시작과 끝에서 공백을 다듬기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90dc78f52a6b413211264d91d8f20c267620e3a3" translate="yes" xml:space="preserve">
          <source>This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using &lt;code&gt;submit&lt;/code&gt; might be converted into a form that maintains &lt;code&gt;Future&lt;/code&gt; status. However, in such cases, method &lt;a href=&quot;threadpoolexecutor#purge--&quot;&gt;&lt;code&gt;purge()&lt;/code&gt;&lt;/a&gt; may be used to remove those Futures that have been cancelled.</source>
          <target state="translated">이 방법은 취소 체계의 일부로 유용 할 수 있습니다. 내부 큐에 배치하기 전에 다른 양식으로 변환 된 태스크를 제거하지 못할 수 있습니다. 예를 들어, &lt;code&gt;submit&lt;/code&gt; 사용하여 입력 한 작업은 &lt;code&gt;Future&lt;/code&gt; 상태 를 유지하는 양식으로 변환 될 수 있습니다 . 그러나 그러한 경우, &lt;a href=&quot;threadpoolexecutor#purge--&quot;&gt; &lt;code&gt;purge()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 취소 된 선물을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6e4bcf82780178dbb5ca3daf924e68571ff49b" translate="yes" xml:space="preserve">
          <source>This method may be useful when forcing completion as soon as any one (versus all) of several subtask results are obtained. However, in the common (and recommended) case in which &lt;code&gt;setRawResult&lt;/code&gt; is not overridden, this effect can be obtained more simply using &lt;code&gt;quietlyCompleteRoot();&lt;/code&gt;.</source>
          <target state="translated">이 방법은 여러 하위 작업 결과 중 하나 (모두가 아닌)를 얻 자마자 강제로 완료 할 때 유용 할 수 있습니다. 그러나 &lt;code&gt;setRawResult&lt;/code&gt; 를 재정의하지 않는 일반적인 (권장되는) 경우에는 &lt;code&gt;quietlyCompleteRoot();&lt;/code&gt; 를 사용 하여이 효과를보다 간단하게 얻을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="ee8a33b2b584d58f65acd3ef5b5a9bac75888fef" translate="yes" xml:space="preserve">
          <source>This method may block indefinitely reading from the input stream (or writing to the file). The behavior for the case that the input stream is</source>
          <target state="translated">이 메소드는 입력 스트림에서 무한히 읽거나 파일에 쓰는 것을 차단할 수 있습니다. 입력 스트림이 다음과 같은 경우의 동작</target>
        </trans-unit>
        <trans-unit id="5d30c9f7712a31b657a7bbb8d54ff8b8b2c7ec98" translate="yes" xml:space="preserve">
          <source>This method may block indefinitely writing to the output stream (or reading from the file). The behavior for the case that the output stream is</source>
          <target state="translated">이 메소드는 출력 스트림에 무기한 쓰기 (또는 파일에서 읽기)를 차단할 수 있습니다. 출력 스트림이 다음과 같은 경우의 동작</target>
        </trans-unit>
        <trans-unit id="f0ca405bc454d65a30fcfaba1f7467fa23cbbab5" translate="yes" xml:space="preserve">
          <source>This method may fail for a number of reasons. For example, the track number specified may not be valid for the current sequence, or the sequencer may not support this functionality. An application which needs to verify whether this operation succeeded should follow this call with a call to &lt;code&gt;&lt;a href=&quot;sequencer#getTrackSolo-int-&quot;&gt;&lt;code&gt;getTrackSolo(int)&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 방법은 여러 가지 이유로 실패 할 수 있습니다. 예를 들어, 지정된 트랙 번호가 현재 시퀀스에 유효하지 않거나 시퀀서가이 기능을 지원하지 않을 수 있습니다. 이 작업의 성공 여부를 확인해야하는 응용 프로그램은 &lt;code&gt;&lt;a href=&quot;sequencer#getTrackSolo-int-&quot;&gt;&lt;code&gt;getTrackSolo(int)&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 호출로이 호출을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="13cfc0faa9a3698ec0c89cdef689a843a661a929" translate="yes" xml:space="preserve">
          <source>This method may modify this encoder's state; it should therefore not be invoked if an &lt;a href=&quot;#steps&quot;&gt;encoding operation&lt;/a&gt; is already in progress.</source>
          <target state="translated">이 메소드는이 인코더의 상태를 수정할 수 있습니다. 따라서 &lt;a href=&quot;#steps&quot;&gt;인코딩 작업&lt;/a&gt; 이 이미 진행중인 경우에는 호출되지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9290868d82bfe3da4c42554fa0c609defcf62ef1" translate="yes" xml:space="preserve">
          <source>This method may modify this encoder's state; it should therefore not be invoked if an encoding operation is already in progress.</source>
          <target state="translated">이 메소드는이 인코더의 상태를 수정할 수 있습니다. 따라서 인코딩 작업이 이미 진행중인 경우에는 호출되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3037b5311422e5bb406a3be5f52283fd7469d708" translate="yes" xml:space="preserve">
          <source>This method may not be used to compare paths that are associated with different file system providers.</source>
          <target state="translated">이 방법은 다른 파일 시스템 제공자와 연관된 경로를 비교하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="664c8d0c6ff062ca2d0fae072b4046c07d1c92e8" translate="yes" xml:space="preserve">
          <source>This method may only be called after a call to &lt;code&gt;prepareReplacePixels&lt;/code&gt;, or else an &lt;code&gt;IllegalStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">이 메소드는 &lt;code&gt;prepareReplacePixels&lt;/code&gt; 호출 한 후에 만 ​​호출 할 수 있습니다. 그렇지 않으면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80ad7aafeb24194c3ff80c06142118184d24f050" translate="yes" xml:space="preserve">
          <source>This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffer then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the &lt;a href=&quot;readablebytechannel&quot;&gt;&lt;code&gt;ReadableByteChannel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는이 채널의 소켓이 연결되고 소켓의 피어에서 데이터 그램 만 허용하는 경우에만 호출 할 수 있습니다. 데이터 그램에 지정된 버퍼에 남아있는 것보다 많은 바이트가있는 경우 나머지 데이터 그램은 자동으로 삭제됩니다. 그렇지 않으면이 메소드는 &lt;a href=&quot;readablebytechannel&quot;&gt; &lt;code&gt;ReadableByteChannel&lt;/code&gt; &lt;/a&gt; 인터페이스에 지정된대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="85ddf706a00ce13f5d8368ac314ccc092914db90" translate="yes" xml:space="preserve">
          <source>This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffers then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the &lt;a href=&quot;scatteringbytechannel&quot;&gt;&lt;code&gt;ScatteringByteChannel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는이 채널의 소켓이 연결되어 있고 소켓의 피어에서 데이터 그램 만 허용하는 경우에만 호출 할 수 있습니다. 데이터 그램에 주어진 버퍼에 남아있는 것보다 많은 바이트가 있으면 나머지 데이터 그램은 자동으로 삭제됩니다. 그렇지 않으면이 메소드는 &lt;a href=&quot;scatteringbytechannel&quot;&gt; &lt;code&gt;ScatteringByteChannel&lt;/code&gt; &lt;/a&gt; 인터페이스에 지정된대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b8e1350ff2756ae2be28f871fb760f1312c051e0" translate="yes" xml:space="preserve">
          <source>This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the &lt;a href=&quot;gatheringbytechannel&quot;&gt;&lt;code&gt;GatheringByteChannel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는이 채널의 소켓이 연결된 경우에만 호출 할 수 있으며,이 경우 데이터 그램을 소켓의 피어로 직접 보냅니다. 그렇지 않으면 &lt;a href=&quot;gatheringbytechannel&quot;&gt; &lt;code&gt;GatheringByteChannel&lt;/code&gt; &lt;/a&gt; 인터페이스에 지정된대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cad6db78ccecbb36a1013d4c3b22a7787206fa62" translate="yes" xml:space="preserve">
          <source>This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the &lt;a href=&quot;writablebytechannel&quot;&gt;&lt;code&gt;WritableByteChannel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이 메소드는이 채널의 소켓이 연결된 경우에만 호출 할 수 있으며,이 경우 데이터 그램을 소켓의 피어로 직접 보냅니다. 그렇지 않으면 &lt;a href=&quot;writablebytechannel&quot;&gt; &lt;code&gt;WritableByteChannel&lt;/code&gt; &lt;/a&gt; 인터페이스에 지정된대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b3924b1b87bc1f4c339d636c169be3cc7642f217" translate="yes" xml:space="preserve">
          <source>This method may return &lt;code&gt;null&lt;/code&gt; for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.</source>
          <target state="translated">이 메소드는 공허함, 순회 시작 후 분할 불가능, 데이터 구조 제한 조건 및 효율성 고려 사항을 포함하여 어떤 이유로 든 &lt;code&gt;null&lt;/code&gt; 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b7eca330f8927162ece445852015aeb622c5901" translate="yes" xml:space="preserve">
          <source>This method may return &lt;code&gt;null&lt;/code&gt; for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations. This implementation permits limited parallelism.</source>
          <target state="translated">이 메소드는 공허함, 순회 시작 후 분할 불가능, 데이터 구조 제한 조건 및 효율성 고려 사항을 포함하여 어떤 이유로 든 &lt;code&gt;null&lt;/code&gt; 을 리턴 할 수 있습니다 . 이 구현은 제한된 병렬 처리를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2ca689601a61123c0cfd011d20cb2a44d99c79b3" translate="yes" xml:space="preserve">
          <source>This method may return a &lt;code&gt;Referenceable&lt;/code&gt; object. The service provider obtaining this object may choose to store it directly, or to extract its reference (using &lt;code&gt;Referenceable.getReference()&lt;/code&gt;) and store that instead.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Referenceable&lt;/code&gt; 객체를 반환 할 수 있습니다 . 이 객체를 얻는 서비스 제공자는 직접 저장하거나 참조를 추출하여 ( &lt;code&gt;Referenceable.getReference()&lt;/code&gt; ) 대신 저장 하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da7254c2e453139e7d81c839c28178b8c6fa54f3" translate="yes" xml:space="preserve">
          <source>This method may return different results at different times if new charset providers are dynamically made available to the current Java virtual machine. In the absence of such changes, the charsets returned by this method are exactly those that can be retrieved via the &lt;a href=&quot;charset#forName-java.lang.String-&quot;&gt;&lt;code&gt;forName&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">현재 Java 가상 머신에서 새로운 문자 세트 제공자를 동적으로 사용할 수있게되면이 메소드는 다른 시간에 다른 결과를 리턴 할 수 있습니다. 이러한 변경이없는 경우이 메소드가 리턴 한 문자 세트는 &lt;a href=&quot;charset#forName-java.lang.String-&quot;&gt; &lt;code&gt;forName&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 할 수있는 문자 세트 입니다.</target>
        </trans-unit>
        <trans-unit id="7f24bb45581493e48b7f661a1b82a7f31f609480" translate="yes" xml:space="preserve">
          <source>This method may skip more bytes than what are remaining in the backing file. This produces no exception and the number of bytes skipped may include some number of bytes that were beyond the EOF of the backing file. Attempting to read from the stream after skipping past the end will result in -1 indicating the end of the file.</source>
          <target state="translated">이 방법은 백업 파일에 남아있는 것보다 많은 바이트를 건너 뛸 수 있습니다. 이로 인해 예외는 발생하지 않으며 건너 뛴 바이트 수에는 백업 파일의 EOF를 초과하는 바이트 수가 포함될 수 있습니다. 끝을지나 건너 뛴 후 스트림에서 읽으려고하면 파일의 끝을 나타내는 -1이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="923be3cc88e0a663d7b51f4ac429f46de54928ec" translate="yes" xml:space="preserve">
          <source>This method may skip over some smaller number of bytes, possibly zero. This may result from any of a number of conditions; reaching end of file before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one possibility. This method never throws an &lt;code&gt;EOFException&lt;/code&gt;. The actual number of bytes skipped is returned. If &lt;code&gt;n&lt;/code&gt; is negative, no bytes are skipped.</source>
          <target state="translated">이 방법은 0보다 작은 바이트 수를 건너 뛸 수 있습니다. 여러 조건 중 하나에서 발생할 수 있습니다. &lt;code&gt;n&lt;/code&gt; 바이트를 건너 뛰기 전에 파일 끝에 도달 하면 한 가지 가능성이 있습니다. 이 메소드는 &lt;code&gt;EOFException&lt;/code&gt; 을 발생 시키지 않습니다 . 건너 뛴 실제 바이트 수가 반환됩니다. 경우 &lt;code&gt;n&lt;/code&gt; 이 부의 경우, 바이트는 스킵되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dc8470ea65d899fbd4dd0997bc48338122f1883" translate="yes" xml:space="preserve">
          <source>This method merely returns its input argument, and should be overridden if a different behavior is desired.</source>
          <target state="translated">이 메소드는 입력 인수 만 리턴하며 다른 동작이 필요한 경우 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bd8c6cf18e8e46ae4a0cc3b0f01ad2aa17751cb" translate="yes" xml:space="preserve">
          <source>This method modifies the failure handling of native method resolution by allowing retry with a prefix applied to the name. When used with the &lt;a href=&quot;classfiletransformer&quot;&gt;&lt;code&gt;ClassFileTransformer&lt;/code&gt;&lt;/a&gt;, it enables native methods to be instrumented.</source>
          <target state="translated">이 메소드는 이름에 접 두부가 적용된 재 시도를 허용하여 고유 메소드 분석의 실패 처리를 수정합니다. &lt;a href=&quot;classfiletransformer&quot;&gt; &lt;code&gt;ClassFileTransformer&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 원시 메소드를 인스트루먼트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53988dcf2de030bbb27d66e1d6c644d3b1170749" translate="yes" xml:space="preserve">
          <source>This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this engine.</source>
          <target state="translated">핸드 셰이 킹이 발생하기 전에이 메소드를 호출해야합니다. 핸드 쉐이킹이 시작되면이 엔진 수명 동안 모드를 재설정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e83ca4f94b5e856bf345a5a28a34bbb8222496f0" translate="yes" xml:space="preserve">
          <source>This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this socket.</source>
          <target state="translated">핸드 셰이 킹이 발생하기 전에이 메소드를 호출해야합니다. 핸드 쉐이킹이 시작되면이 소켓의 수명 동안 모드를 재설정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6714c3f6386191bb9adf91778e4996153817aa27" translate="yes" xml:space="preserve">
          <source>This method must be called before the URLConnection is connected.</source>
          <target state="translated">URLConnection이 연결되기 전에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d88e48c68fa8723650976667e833fbbfd253899" translate="yes" xml:space="preserve">
          <source>This method must be invoked before the thread is started.</source>
          <target state="translated">스레드가 시작되기 전에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c537a6163a608514f6803c2d83a2e684e7049a56" translate="yes" xml:space="preserve">
          <source>This method must be invoked by the selector for each channel that it deregisters.</source>
          <target state="translated">이 메소드는 등록 해제 한 각 채널에 대해 선택기가 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e8908d2562fe196f4aef565cdc960976a82fcba" translate="yes" xml:space="preserve">
          <source>This method obtains a snapshot of the thread information for each thread including:</source>
          <target state="translated">이 메소드는 다음을 포함하여 각 스레드에 대한 스레드 정보의 스냅 샷을 확보합니다.</target>
        </trans-unit>
        <trans-unit id="fbc6751ae1120e298b55963c4065a790ece5e6a4" translate="yes" xml:space="preserve">
          <source>This method only considers the position of the two date-times on the local time-line. It does not take into account the chronology, or calendar system. This is different from the comparison in &lt;a href=&quot;localdatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;compareTo(ChronoLocalDateTime)&lt;/code&gt;&lt;/a&gt;, but is the same approach as &lt;a href=&quot;chrono/chronolocaldatetime#timeLineOrder--&quot;&gt;&lt;code&gt;ChronoLocalDateTime.timeLineOrder()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 로컬 타임 라인에서 두 날짜-시간의 위치 만 고려합니다. 연대기 또는 달력 시스템은 고려하지 않습니다. 이것은 &lt;a href=&quot;localdatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;compareTo(ChronoLocalDateTime)&lt;/code&gt; &lt;/a&gt; 의 비교 와 &lt;a href=&quot;chrono/chronolocaldatetime#timeLineOrder--&quot;&gt; &lt;code&gt;ChronoLocalDateTime.timeLineOrder()&lt;/code&gt; &lt;/a&gt; 와 동일한 접근 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="585cc4b707d09b7dc8558a4982a674f3f799b6ed" translate="yes" xml:space="preserve">
          <source>This method only considers the position of the two dates on the local time-line. It does not take into account the chronology, or calendar system. This is different from the comparison in &lt;a href=&quot;localdate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;compareTo(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt; but is the same approach as &lt;a href=&quot;chrono/chronolocaldate#timeLineOrder--&quot;&gt;&lt;code&gt;ChronoLocalDate.timeLineOrder()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 현지 타임 라인에서 두 날짜의 위치 만 고려합니다. 연대기 또는 달력 시스템은 고려하지 않습니다. 이것은 &lt;a href=&quot;localdate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;compareTo(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 의 비교와는 다르지만 &lt;a href=&quot;chrono/chronolocaldate#timeLineOrder--&quot;&gt; &lt;code&gt;ChronoLocalDate.timeLineOrder()&lt;/code&gt; &lt;/a&gt; 와 동일한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="8ea0ec144dd39297131d80af6503e189f30d9178" translate="yes" xml:space="preserve">
          <source>This method only considers the position of the two dates on the local time-line. It does not take into account the chronology, or calendar system. This is different from the comparison in &lt;a href=&quot;localdate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;compareTo(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;, but is the same approach as &lt;a href=&quot;chrono/chronolocaldate#timeLineOrder--&quot;&gt;&lt;code&gt;ChronoLocalDate.timeLineOrder()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 현지 타임 라인에서 두 날짜의 위치 만 고려합니다. 연대기 또는 달력 시스템은 고려하지 않습니다. 이것은 &lt;a href=&quot;localdate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;compareTo(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 의 비교 와 &lt;a href=&quot;chrono/chronolocaldate#timeLineOrder--&quot;&gt; &lt;code&gt;ChronoLocalDate.timeLineOrder()&lt;/code&gt; &lt;/a&gt; 와 동일한 접근 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="40f3da24e5f000fd999ef612e2bc133df542fe7d" translate="yes" xml:space="preserve">
          <source>This method only has any effect when the local time-line overlaps, such as at an autumn daylight savings cutover. In this scenario, there are two valid offsets for the local date-time. Calling this method will return a zoned date-time with the earlier of the two selected.</source>
          <target state="translated">이 방법은 가을 일광 절약 시간제 컷 오버와 같이 로컬 타임 라인이 겹치는 경우에만 효과가 있습니다. 이 시나리오에서는 현지 날짜-시간에 대해 두 개의 유효한 오프셋이 있습니다. 이 메서드를 호출하면 두 날짜 중 빠른 날짜가 선택된 존 날짜 / 시간이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09d63e9b31f13d4f1052dfa79b756cd792c270b5" translate="yes" xml:space="preserve">
          <source>This method only has any effect when the local time-line overlaps, such as at an autumn daylight savings cutover. In this scenario, there are two valid offsets for the local date-time. Calling this method will return a zoned date-time with the later of the two selected.</source>
          <target state="translated">이 방법은 가을 일광 절약 시간제 컷 오버와 같이 로컬 타임 라인이 겹치는 경우에만 효과가 있습니다. 이 시나리오에서는 현지 날짜-시간에 대해 두 개의 유효한 오프셋이 있습니다. 이 메소드를 호출하면 두 날짜 중 나중에 선택된 시간대 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="436833a5dfb55f56eaeb20dd9bec11e5315c4a12" translate="yes" xml:space="preserve">
          <source>This method opens or creates a file in exactly the manner specified by the &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newByteChannel&lt;/code&gt;&lt;/a&gt; method with the exception that the &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; option may not be present in the array of options. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt; if it exists.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 옵션이 옵션 배열에 없을 수 있다는 점을 제외 하고 &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newByteChannel&lt;/code&gt; &lt;/a&gt; 메소드에 의해 지정된 방식으로 파일을 열거 나 작성합니다 . 옵션이 없으면이 메소드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 파일을 작성하기 위해 파일을 열거 나 존재하지 않는 경우 파일을 작성하거나 기존 &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 존재하는 경우 크기를 &lt;code&gt;0&lt;/code&gt; 으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="37e62c39d9a09d082fe370715e30bf0eabb2249a" translate="yes" xml:space="preserve">
          <source>This method opens or creates a file in exactly the manner specified by the &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newByteChannel&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newByteChannel&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 방식으로 파일을 열거 나 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="feec24e706b56315c8dded7e31f8035d74b253c7" translate="yes" xml:space="preserve">
          <source>This method operates on a set in order to allow interdependent changes to more than one class at the same time (a redefinition of class A can require a redefinition of class B).</source>
          <target state="translated">이 방법은 동시에 하나 이상의 클래스에 대한 상호 의존적 인 변경을 허용하기 위해 세트에서 작동합니다 (클래스 A의 재정의에는 클래스 B의 재정의가 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="56443cbcb58f600320fc73c90bcfbc2314029f70" translate="yes" xml:space="preserve">
          <source>This method operates on a set in order to allow interdependent changes to more than one class at the same time (a retransformation of class A can require a retransformation of class B).</source>
          <target state="translated">이 방법은 동시에 하나 이상의 클래스에 대한 상호 의존적 인 변경을 허용하기 위해 세트에서 작동합니다 (클래스 A의 재 변환에는 클래스 B의 재 변환이 필요할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9b88b0314e8964d6f6880b1f7449e849c27699b2" translate="yes" xml:space="preserve">
          <source>This method otherwise behaves exactly as specified by the &lt;a href=&quot;channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">그렇지 않으면이 메소드는 &lt;a href=&quot;channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 인터페이스에서 지정한대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e8dab872b8c34f5edb3cbf1f8640b7748f6cc2ad" translate="yes" xml:space="preserve">
          <source>This method otherwise behaves exactly as specified by the &lt;a href=&quot;channel#close--&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">그렇지 않으면이 메소드는 &lt;a href=&quot;channel#close--&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 인터페이스에서 지정한대로 정확하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7058d06e3fc1267459142e765dad5a92635b33b3" translate="yes" xml:space="preserve">
          <source>This method outputs the comments, properties keys and values in the same format as specified in &lt;a href=&quot;properties#store-java.io.Writer-java.lang.String-&quot;&gt;&lt;code&gt;store(Writer)&lt;/code&gt;&lt;/a&gt;, with the following differences:</source>
          <target state="translated">이 메소드 는 다음과 같은 차이점을 제외 하고 설명, 특성 키 및 값을 &lt;a href=&quot;properties#store-java.io.Writer-java.lang.String-&quot;&gt; &lt;code&gt;store(Writer)&lt;/code&gt; &lt;/a&gt; 지정된 것과 동일한 형식으로 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="58cffd3c9019d2e4ede3c3ad5f623a893866df11" translate="yes" xml:space="preserve">
          <source>This method parses the ID producing a &lt;code&gt;ZoneId&lt;/code&gt; or &lt;code&gt;ZoneOffset&lt;/code&gt;. A &lt;code&gt;ZoneOffset&lt;/code&gt; is returned if the ID is 'Z', or starts with '+' or '-'. The result will always be a valid ID for which &lt;a href=&quot;zone/zonerules&quot;&gt;&lt;code&gt;ZoneRules&lt;/code&gt;&lt;/a&gt; can be obtained.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ZoneId&lt;/code&gt; 또는 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 생성하는 ID를 구문 분석합니다 . &lt;code&gt;ZoneOffset&lt;/code&gt; ID가 'Z가', 또는 '+'또는로 시작하면 반환 '-'. 결과는 항상 &lt;a href=&quot;zone/zonerules&quot;&gt; &lt;code&gt;ZoneRules&lt;/code&gt; &lt;/a&gt; 를 얻을 수 있는 유효한 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="48ad44d8a5bf7e11a75450148c73fef22e59b63b" translate="yes" xml:space="preserve">
          <source>This method parses the string ID of a &lt;code&gt;ZoneOffset&lt;/code&gt; to return an instance. The parsing accepts all the formats generated by &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;getId()&lt;/code&gt;&lt;/a&gt;, plus some additional formats:</source>
          <target state="translated">이 메소드는 &lt;code&gt;ZoneOffset&lt;/code&gt; 의 문자열 ID를 구문 분석하여 인스턴스를 리턴합니다. 구문 분석은 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;getId()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 모든 형식 과 몇 가지 추가 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fe868bd6b02f7ad834e8d18908b4c4ad798f17e8" translate="yes" xml:space="preserve">
          <source>This method performs a blocking &lt;a href=&quot;#selop&quot;&gt;selection operation&lt;/a&gt;. It returns only after at least one channel is selected, this selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method is invoked, or the current thread is interrupted, whichever comes first.</source>
          <target state="translated">이 방법은 차단 &lt;a href=&quot;#selop&quot;&gt;선택 작업을&lt;/a&gt; 수행합니다 . 적어도 하나의 채널을 선택 &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 선택기의 웨이크 업 메소드가 호출되거나 현재 스레드가 중단 된 후에 만 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="995d74d48d8205b07e29e9b4d9aeec3abd63ffd5" translate="yes" xml:space="preserve">
          <source>This method performs a blocking &lt;a href=&quot;#selop&quot;&gt;selection operation&lt;/a&gt;. It returns only after at least one channel is selected, this selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method is invoked, the current thread is interrupted, or the given timeout period expires, whichever comes first.</source>
          <target state="translated">이 방법은 차단 &lt;a href=&quot;#selop&quot;&gt;선택 작업을&lt;/a&gt; 수행합니다 . 적어도 하나의 채널이 선택 &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 선택기의 웨이크 업 메소드가 호출되거나, 현재 스레드가 중단되거나, 주어진 시간 종료 기간이 만료되는 시간 중 빠른 시간 이 지난 후에 만 ​​리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f1c48d1d6f643589c8e5dfbf396b20d53c18035" translate="yes" xml:space="preserve">
          <source>This method performs a non-blocking &lt;a href=&quot;#selop&quot;&gt;selection operation&lt;/a&gt;. If no channels have become selectable since the previous selection operation then this method immediately returns zero.</source>
          <target state="translated">이 방법은 비 차단 &lt;a href=&quot;#selop&quot;&gt;선택 작업을 수행&lt;/a&gt; 합니다. 이전 선택 작업 이후에 채널을 선택할 수없는 경우이 방법은 즉시 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc6edcbc87057fff025dbac12e99fd1dfdb47135" translate="yes" xml:space="preserve">
          <source>This method performs a syntactic check for each language range in the given &lt;code&gt;ranges&lt;/code&gt; but doesn't do validation using the IANA Language Subtag Registry.</source>
          <target state="translated">이 방법은 지정된 &lt;code&gt;ranges&lt;/code&gt; 의 각 언어 범위에 대해 구문 검사를 수행 하지만 IANA 언어 하위 태그 레지스트리를 사용한 유효성 검사는 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1490e8bf02e1e8ec06bbe4a69f024c77a32d1d14" translate="yes" xml:space="preserve">
          <source>This method performs exactly the same security checks as the &lt;a href=&quot;../../net/datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method of the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class. That is, if a security manager has been installed then this method verifies that its &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; methods permit datagrams to be received from and sent to, respectively, the given remote address.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;../../net/datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 보안 검사를 수행합니다 . 즉, 보안 관리자가 설치된 경우이 메소드는 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 메소드가 지정된 원격 주소에서 각각 데이터 그램을주고받을 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b34fa94141bd53502816c1a7c36fa40fbe9dd13b" translate="yes" xml:space="preserve">
          <source>This method performs exactly the same security checks as the &lt;a href=&quot;../../net/datagramsocket#receive-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; method of the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram received this method verifies that the source's address and port number are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The overhead of this security check can be avoided by first connecting the socket via the &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;../../net/datagramsocket#receive-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 보안 검사를 수행합니다 . 즉, 소켓이 특정 원격 주소에 연결되어 있지 않고 보안 관리자가 설치된 경우이 방법은 수신 된 각 데이터 그램에 대해 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드 가 소스의 주소와 포트 번호를 허용하는지 확인합니다 . 이 보안 점검의 오버 헤드는 먼저 &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 소켓을 연결하여 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84c7f96be391461742d324fc5929d8e5e241b5cb" translate="yes" xml:space="preserve">
          <source>This method performs exactly the same security checks as the &lt;a href=&quot;../../net/datagramsocket#send-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method of the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt; class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram sent this method verifies that the target address and port number are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method. The overhead of this security check can be avoided by first connecting the socket via the &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;../../net/datagramsocket#send-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 보안 검사를 수행합니다 . 즉, 소켓이 특정 원격 주소에 연결되어 있지 않고 보안 관리자가 설치된 경우 전송 된 각 데이터 그램에 대해이 방법은 대상 주소 및 포트 번호가 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 메소드에 의해 허용되는지 확인합니다 . 이 보안 점검의 오버 헤드는 먼저 &lt;a href=&quot;datagramchannel#connect-java.net.SocketAddress-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 소켓을 연결하여 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f059baa160af6899136476c6121861e8e6b93831" translate="yes" xml:space="preserve">
          <source>This method performs exactly the same security checks as the &lt;a href=&quot;../../net/serversocket#accept--&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; method of the &lt;a href=&quot;../../net/serversocket&quot;&gt;&lt;code&gt;ServerSocket&lt;/code&gt;&lt;/a&gt; class. That is, if a security manager has been installed then for each new connection this method verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드 는 &lt;a href=&quot;../../net/serversocket&quot;&gt; &lt;code&gt;ServerSocket&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;../../net/serversocket#accept--&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일한 보안 검사를 수행합니다 . 즉, 보안 관리자가 설치된 경우이 방법은 각각의 새 연결마다 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드 가 연결 원격 엔드 포인트의 주소와 포트 번호를 허용하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3581cb3ee69a23bdc1d1589a872169572eda0976" translate="yes" xml:space="preserve">
          <source>This method performs exactly the same security checks as the &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; class. That is, if a security manager has been installed then this method verifies that its &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method permits connecting to the address and port number of the given remote endpoint.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 클래스 와 정확히 동일한 보안 검사를 수행합니다 . 즉, 보안 관리자가 설치된 경우이 메소드는 해당 &lt;a href=&quot;../../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 메소드가 지정된 원격 엔드 포인트의 주소 및 포트 번호에 대한 연결을 허용 하는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="92712482a935d3fa1a3b59d278f7294891b7d579" translate="yes" xml:space="preserve">
          <source>This method performs the following actions:</source>
          <target state="translated">이 방법은 다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="af5b75c5ecc81d005d5130dff470200fcc7ba52b" translate="yes" xml:space="preserve">
          <source>This method predates the general-purpose exception chaining facility. The &lt;a href=&quot;../lang/throwable#getCause--&quot;&gt;&lt;code&gt;Throwable.getCause()&lt;/code&gt;&lt;/a&gt; method is now the preferred means of obtaining this information.</source>
          <target state="translated">이 방법은 범용 예외 체인 기능보다 우선합니다. &lt;a href=&quot;../lang/throwable#getCause--&quot;&gt; &lt;code&gt;Throwable.getCause()&lt;/code&gt; &lt;/a&gt; 메소드는이 정보를 취득하는 수단이다.</target>
        </trans-unit>
        <trans-unit id="2b05cccacb51c29a4e6bffd776c9f16cec879898" translate="yes" xml:space="preserve">
          <source>This method predates the general-purpose exception chaining facility. The &lt;a href=&quot;../throwable#getCause--&quot;&gt;&lt;code&gt;Throwable.getCause()&lt;/code&gt;&lt;/a&gt; method is now the preferred means of obtaining this information.</source>
          <target state="translated">이 방법은 범용 예외 체인 기능보다 우선합니다. &lt;a href=&quot;../throwable#getCause--&quot;&gt; &lt;code&gt;Throwable.getCause()&lt;/code&gt; &lt;/a&gt; 메소드는이 정보를 취득하는 수단이다.</target>
        </trans-unit>
        <trans-unit id="fb7620b7a48c3aac8b2b5e687ba34d8d1041c708" translate="yes" xml:space="preserve">
          <source>This method predates the general-purpose exception chaining facility. The &lt;a href=&quot;namingexception#getCause--&quot;&gt;&lt;code&gt;getCause()&lt;/code&gt;&lt;/a&gt; method is now the preferred means of obtaining this information.</source>
          <target state="translated">이 방법은 범용 예외 체인 기능보다 우선합니다. &lt;a href=&quot;namingexception#getCause--&quot;&gt; &lt;code&gt;getCause()&lt;/code&gt; &lt;/a&gt; 메소드는이 정보를 취득하는 수단이다.</target>
        </trans-unit>
        <trans-unit id="373217f3d07b9fda22da4e0651b44b4fdd46e48f" translate="yes" xml:space="preserve">
          <source>This method predates the general-purpose exception chaining facility. The &lt;a href=&quot;namingexception#initCause-java.lang.Throwable-&quot;&gt;&lt;code&gt;initCause(Throwable)&lt;/code&gt;&lt;/a&gt; method is now the preferred means of recording this information.</source>
          <target state="translated">이 방법은 범용 예외 체인 기능보다 우선합니다. &lt;a href=&quot;namingexception#initCause-java.lang.Throwable-&quot;&gt; &lt;code&gt;initCause(Throwable)&lt;/code&gt; &lt;/a&gt; 방법에 대하여 정보를 기록하는 바람직한 방법이다.</target>
        </trans-unit>
        <trans-unit id="fbf2fe4967250206a8a0d1a3d7fd4e6d5e552ad7" translate="yes" xml:space="preserve">
          <source>This method predates the general-purpose exception chaining facility. The &lt;a href=&quot;throwable#getCause--&quot;&gt;&lt;code&gt;Throwable.getCause()&lt;/code&gt;&lt;/a&gt; method is now the preferred means of obtaining this information.</source>
          <target state="translated">이 방법은 범용 예외 체인 기능보다 우선합니다. &lt;a href=&quot;throwable#getCause--&quot;&gt; &lt;code&gt;Throwable.getCause()&lt;/code&gt; &lt;/a&gt; 메소드는이 정보를 취득하는 수단이다.</target>
        </trans-unit>
        <trans-unit id="b342dd4724387234090a73bf50e3764b58ff071f" translate="yes" xml:space="preserve">
          <source>This method preserves the current AccessControlContext's DomainCombiner (which may be null) while the action is performed.</source>
          <target state="translated">이 메소드는 조치가 수행되는 동안 현재 AccessControlContext의 DomainCombiner (널 (NULL) 일 수 있음)를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9b0bde80ac998fee7b533914832671e2ab4251bd" translate="yes" xml:space="preserve">
          <source>This method produces a &lt;code&gt;String&lt;/code&gt; that can be used to create a &lt;code&gt;Pattern&lt;/code&gt; that would match the string &lt;code&gt;s&lt;/code&gt; as if it were a literal pattern.</source>
          <target state="translated">이 방법은 생산 &lt;code&gt;String&lt;/code&gt; 만드는 데 사용할 수있는 &lt;code&gt;Pattern&lt;/code&gt; 문자열과 일치하는 것 &lt;code&gt;s&lt;/code&gt; 이 리터럴 패턴 인 것처럼합니다.</target>
        </trans-unit>
        <trans-unit id="8b590b33bf81c5fed93e036b46ef32102a1975f9" translate="yes" xml:space="preserve">
          <source>This method produces the same result as if it computed:</source>
          <target state="translated">이 방법은 계산 한 것과 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3bb45c5229f937a8cf28f92735d469e00c18386e" translate="yes" xml:space="preserve">
          <source>This method provides access to locale sensitive decimal style symbols.</source>
          <target state="translated">이 방법을 사용하면 로케일 구분 10 진수 스타일 기호에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe02ffca9e772110145211893f0c71c659baf0f" translate="yes" xml:space="preserve">
          <source>This method provides early access to the &lt;code&gt;SSLSession&lt;/code&gt; being constructed. Depending on how far the handshake has progressed, some data may not yet be available for use. For example, if a remote server will be sending a Certificate chain, but that chain has yet not been processed, the &lt;code&gt;getPeerCertificates&lt;/code&gt; method of &lt;code&gt;SSLSession&lt;/code&gt; will throw a SSLPeerUnverifiedException. Once that chain has been processed, &lt;code&gt;getPeerCertificates&lt;/code&gt; will return the proper value.</source>
          <target state="translated">이 방법은 구성중인 &lt;code&gt;SSLSession&lt;/code&gt; 에 대한 초기 액세스를 제공합니다 . 핸드 셰이크가 진행된 거리에 따라 일부 데이터를 아직 사용하지 못할 수 있습니다. 예를 들어, 원격 서버가 인증서 체인을 보내지 만 해당 체인이 아직 처리되지 않은 경우 &lt;code&gt;SSLSession&lt;/code&gt; 의 &lt;code&gt;getPeerCertificates&lt;/code&gt; 메소드 는 SSLPeerUnverifiedException을 발생시킵니다. 해당 체인이 처리되면 &lt;code&gt;getPeerCertificates&lt;/code&gt; 는 적절한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40b582df3b5fd7d10f84d86c84b12eb337cb2c75" translate="yes" xml:space="preserve">
          <source>This method provides full control of the numeric formatting, including zero-padding and the positive/negative sign.</source>
          <target state="translated">이 방법을 사용하면 제로 패딩 및 양수 / 음수 부호를 포함하여 숫자 서식을 완벽하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48698f60ade726ad6887fc4e010d8d648c0827f" translate="yes" xml:space="preserve">
          <source>This method provides nanosecond precision, but not necessarily nanosecond resolution (that is, how frequently the value changes) - no guarantees are made except that the resolution is at least as good as that of &lt;a href=&quot;system#currentTimeMillis--&quot;&gt;&lt;code&gt;currentTimeMillis()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 나노초 정밀도를 제공하지만 반드시 나노초 분해능 일 필요는 없습니다 (즉, 값이 얼마나 자주 변경되는지). 해상도가 적어도 &lt;a href=&quot;system#currentTimeMillis--&quot;&gt; &lt;code&gt;currentTimeMillis()&lt;/code&gt; &lt;/a&gt; 의 분해능보다 우수하다는 것 외에는 보장 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e50d87a069c78cb97c4c3335c0fe7321e57a5ea6" translate="yes" xml:space="preserve">
          <source>This method provides only part of a temporary-file facility. To arrange for a file created by this method to be deleted automatically, use the &lt;code&gt;&lt;a href=&quot;file#deleteOnExit--&quot;&gt;&lt;code&gt;deleteOnExit()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">이 방법은 임시 파일 기능의 일부만 제공합니다. 이 메소드로 작성된 파일이 자동으로 삭제 &lt;code&gt;&lt;a href=&quot;file#deleteOnExit--&quot;&gt;&lt;code&gt;deleteOnExit()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 하려면 deleteOnExit () 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2adabfd1769b7ee012ef820eff09872bd1de51a" translate="yes" xml:space="preserve">
          <source>This method provides the crucial behavioral difference between &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt; and plain, inexact &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;. The two methods perform the same steps when the caller's type descriptor exactly m atches the callee's, but when the types differ, plain &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; also calls &lt;code&gt;asType&lt;/code&gt; (or some internal equivalent) in order to match up the caller's and callee's types.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 와 일반의 정확하지 않은 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 사이의 결정적인 동작 차이를 제공합니다 . 두 가지 방법은 호출자의 유형 설명자가 호출자의 유형을 정확하게 처리 할 때 동일한 단계를 수행하지만 유형이 다르면 일반 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 도 호출자와 호출자의 유형을 일치시키기 위해 &lt;code&gt;asType&lt;/code&gt; (또는 일부 내부 동등)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="95a70b87ad9186a2bd67cf2e1713ebf2096743a4" translate="yes" xml:space="preserve">
          <source>This method provides the opportunity for a provider to dynamically recheck the underlying data provider to find the latest rules. This could be used to load new rules without stopping the JVM. Dynamic behavior is entirely optional and most providers do not support it.</source>
          <target state="translated">이 방법을 사용하면 공급자가 기본 데이터 공급자를 동적으로 다시 확인하여 최신 규칙을 찾을 수 있습니다. JVM을 중지하지 않고 새 규칙을로드하는 데 사용할 수 있습니다. 동적 동작은 전적으로 선택 사항이며 대부분의 공급자가이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="049c1d2839e24541bb971c957e2c2e05dfa2c27a" translate="yes" xml:space="preserve">
          <source>This method quietly returns if the access request is permitted, or throws a suitable AccessControlException otherwise.</source>
          <target state="translated">이 메소드는 액세스 요청이 허용되면 자동으로 리턴하거나 그렇지 않으면 적절한 AccessControlException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="572f87a523bb0d73773cc2dc794c878b1676de15" translate="yes" xml:space="preserve">
          <source>This method reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It is intended to be invoked after one or more invocations of the &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt;&lt;code&gt;appendReplacement&lt;/code&gt;&lt;/a&gt; method in order to copy the remainder of the input sequence.</source>
          <target state="translated">이 메소드는 추가 위치에서 시작하여 입력 시퀀스에서 문자를 읽고 주어진 문자열 버퍼에 추가합니다. 입력 시퀀스의 나머지 부분을 복사하기 위해 &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt; &lt;code&gt;appendReplacement&lt;/code&gt; &lt;/a&gt; 메소드를 한 번 이상 호출 한 후에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="652c63ff48c563db809e64870889ccb394b4ee92" translate="yes" xml:space="preserve">
          <source>This method reads the value of the attribute into the given buffer as a sequence of bytes, failing if the number of bytes remaining in the buffer is insufficient to read the complete attribute value. The number of bytes transferred into the buffer is &lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the attribute value. The first byte in the sequence is at index &lt;code&gt;p&lt;/code&gt; and the last byte is at index &lt;code&gt;p + n - 1&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is the buffer's position. Upon return the buffer's position will be equal to &lt;code&gt;p + n&lt;/code&gt;; its limit will not have changed.</source>
          <target state="translated">이 메소드는 속성 값을 주어진 버퍼에 바이트 시퀀스로 읽습니다. 버퍼에 남아있는 바이트 수가 전체 속성 값을 읽기에 충분하지 않은 경우 실패합니다. 버퍼에 전송 된 바이트 수는 &lt;code&gt;n&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 속성 값의 크기입니다. 시퀀스의 첫 번째 바이트는 인덱스 &lt;code&gt;p&lt;/code&gt; 에 있고 마지막 바이트는 인덱스 &lt;code&gt;p + n - 1&lt;/code&gt; 에 있습니다. 여기서 &lt;code&gt;p&lt;/code&gt; 는 버퍼의 위치입니다. 리턴시 버퍼의 위치는 &lt;code&gt;p + n&lt;/code&gt; 과 같습니다 . 한도는 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a1da4c3d651c3ca5da497e0fea90ae1b5f4dc6e2" translate="yes" xml:space="preserve">
          <source>This method recognizes the following as line terminators:</source>
          <target state="translated">이 방법은 다음을 라인 종결 자로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="3f6abde40b619fbe1c03871b6834fc2f750f80a9" translate="yes" xml:space="preserve">
          <source>This method relies on time-zone data provider files that are configured. These are loaded using a &lt;code&gt;ServiceLoader&lt;/code&gt;.</source>
          <target state="translated">이 방법은 구성된 표준 시간대 데이터 공급자 파일을 사용합니다. 이것들은 &lt;code&gt;ServiceLoader&lt;/code&gt; 를 사용하여로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b334a9e756939b80cb0fc7832f8ab972905fb6b" translate="yes" xml:space="preserve">
          <source>This method removes one or more &lt;code&gt;NotificationListener&lt;/code&gt;s from a given MBean in the MBean server.</source>
          <target state="translated">이 메소드는 MBean 서버 내의 지정된 MBean로부터 하나 이상의 &lt;code&gt;NotificationListener&lt;/code&gt; 를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="69a9cccb73fd1dcaec810b50ba17145dcc1f1eb4" translate="yes" xml:space="preserve">
          <source>This method repeatedly calls &lt;code&gt;blocker.isReleasable()&lt;/code&gt; and &lt;code&gt;blocker.block()&lt;/code&gt; until either method returns &lt;code&gt;true&lt;/code&gt;. Every call to &lt;code&gt;blocker.block()&lt;/code&gt; is preceded by a call to &lt;code&gt;blocker.isReleasable()&lt;/code&gt; that returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 각 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 할 때까지 &lt;code&gt;blocker.isReleasable()&lt;/code&gt; 및 &lt;code&gt;blocker.block()&lt;/code&gt; 반복적으로 호출 합니다 . &lt;code&gt;blocker.block()&lt;/code&gt; 호출 할 때마다 &lt;code&gt;false&lt;/code&gt; 를 반환 한 &lt;code&gt;blocker.isReleasable()&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b7853e76105b8b5bdb8f93921dcc5e269386e0ab" translate="yes" xml:space="preserve">
          <source>This method requests the Java virtual machine to make a best-effort estimate of the current memory usage of this memory pool. For some memory pools, this method may be an expensive operation that requires some computation to determine the estimate. An implementation should document when this is the case.</source>
          <target state="translated">이 메소드는 Java 가상 머신에이 메모리 풀의 현재 메모리 사용량을 최대한 활용하도록 요청합니다. 일부 메모리 풀의 경우,이 방법은 추정치를 결정하기 위해 계산이 필요한 고가의 작업 일 수 있습니다. 이 경우 구현시 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c4c7250f9cf0a282672d75a0f1ac355d7c1e3bd" translate="yes" xml:space="preserve">
          <source>This method requires a fully initialized &lt;code&gt;Cipher&lt;/code&gt; object, initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object.</source>
          <target state="translated">이 방법에는 객체를 봉인하는 데 사용 된 것과 동일한 알고리즘, 키, 패딩 방식 등으로 초기화 된 완전히 초기화 된 &lt;code&gt;Cipher&lt;/code&gt; 객체 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="cf8256397909468ce6e62017714de03a52f18861" translate="yes" xml:space="preserve">
          <source>This method resets charset-independent state and also invokes the &lt;a href=&quot;charsetdecoder#implReset--&quot;&gt;&lt;code&gt;implReset&lt;/code&gt;&lt;/a&gt; method in order to perform any charset-specific reset actions.</source>
          <target state="translated">이 메소드는 문자 세트 독립 상태를 재설정하고 문자 세트 별 재설정 조치를 수행하기 위해 &lt;a href=&quot;charsetdecoder#implReset--&quot;&gt; &lt;code&gt;implReset&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3c367e5aecd4d457c426f9823a705f02c40e3ba0" translate="yes" xml:space="preserve">
          <source>This method resets charset-independent state and also invokes the &lt;a href=&quot;charsetencoder#implReset--&quot;&gt;&lt;code&gt;implReset&lt;/code&gt;&lt;/a&gt; method in order to perform any charset-specific reset actions.</source>
          <target state="translated">이 메소드는 문자 세트 독립 상태를 재설정하고 문자 세트 별 재설정 조치를 수행하기 위해 &lt;a href=&quot;charsetencoder#implReset--&quot;&gt; &lt;code&gt;implReset&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e2d347d8a78945c1f4bfc96bfe2d38b4f2f7d750" translate="yes" xml:space="preserve">
          <source>This method resets the encapsulated cipher object to its initial state and calls the &lt;code&gt;close&lt;/code&gt; method of the underlying output stream.</source>
          <target state="translated">이 메소드는 캡슐화 된 암호 오브젝트를 초기 상태로 재설정 하고 기본 출력 스트림 의 &lt;code&gt;close&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b0014eaf85a34018f0b1ffca15df447a2ff5af67" translate="yes" xml:space="preserve">
          <source>This method resets this &lt;code&gt;KeyAgreement&lt;/code&gt; object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the &lt;code&gt;init&lt;/code&gt; methods, the same private information and algorithm parameters will be used for subsequent key agreements.</source>
          <target state="translated">이 메소드는이 &lt;code&gt;KeyAgreement&lt;/code&gt; 오브젝트를 재설정 하여 추가 키 계약에 재사용 할 수 있습니다. 이 키 계약이 &lt;code&gt;init&lt;/code&gt; 메소드 중 하나로 다시 초기화되지 않는 한 동일한 개인 정보 및 알고리즘 매개 변수가 후속 키 계약에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2af47a7eb2c65c1b4226311342f5caaa4f6fd55d" translate="yes" xml:space="preserve">
          <source>This method resets this &lt;code&gt;KeyAgreementSpi&lt;/code&gt; object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the &lt;code&gt;engineInit&lt;/code&gt; methods, the same private information and algorithm parameters will be used for subsequent key agreements.</source>
          <target state="translated">이 메소드는이 &lt;code&gt;KeyAgreementSpi&lt;/code&gt; 오브젝트를 재설정 하여 추가 키 계약에 재사용 할 수 있습니다. 이 키 계약이 &lt;code&gt;engineInit&lt;/code&gt; 메소드 중 하나를 사용하여 다시 초기화되지 않는 한 동일한 개인 정보 및 알고리즘 매개 변수가 후속 키 계약에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3816a78b2c5c245cc0677d29fbd42432e5fa590" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;&quot;null&quot;&lt;/code&gt; if the specified array is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 배열이 &lt;code&gt;null&lt;/code&gt; 의 경우, 이 메소드는 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="a9347d39073409bd55de2e353e3ba943be21291d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;false&lt;/code&gt; if the given character is a surrogate character; such characters can be interpreted only when they are members of a pair consisting of a high surrogate followed by a low surrogate. The &lt;a href=&quot;charsetencoder#canEncode-java.lang.CharSequence-&quot;&gt;&lt;code&gt;canEncode(CharSequence)&lt;/code&gt;&lt;/a&gt; method may be used to test whether or not a character sequence can be encoded.</source>
          <target state="translated">주어진 문자가 서로 게이트 문자이면 이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다. 이러한 문자는 상위 서로 게이트와 하위 서로 게이트로 구성된 쌍의 구성원 인 경우에만 해석 할 수 있습니다. &lt;a href=&quot;charsetencoder#canEncode-java.lang.CharSequence-&quot;&gt; &lt;code&gt;canEncode(CharSequence)&lt;/code&gt; &lt;/a&gt; 방법은 문자 시퀀스가 인코딩 될 수 있는지의 여부를 테스트하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d19bf57702f6a86acc5e2101dc28f0546eeb843d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;null&lt;/code&gt; if the thread is not in any of the above conditions.</source>
          <target state="translated">스레드가 위의 조건에 속하지 않으면 이 메소드는 &lt;code&gt;null&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3ecf4e22b67d369d7123e504ea55b1efe7496a5a" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;var&gt;obj&lt;/var&gt; is not null and &lt;var&gt;obj&lt;/var&gt;'s class name is the same as the className field defined for this &lt;code&gt;SimpleType&lt;/code&gt; instance (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method).</source>
          <target state="translated">이 메소드는 &lt;var&gt;obj&lt;/var&gt; 가 null이 아니고 &lt;var&gt;obj&lt;/var&gt; 클래스 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스에 대해 정의 된 className 필드와 같은 경우에만 &lt;code&gt;true&lt;/code&gt; 를 돌려줍니다 (즉, &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드가 돌려주는 클래스 명 ).</target>
        </trans-unit>
        <trans-unit id="6694646d2b9be9f9e17ce0555751ce403d83976d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;var&gt;obj&lt;/var&gt; is not null, &lt;var&gt;obj&lt;/var&gt; is an array and any one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">이 메소드는 &lt;var&gt;obj&lt;/var&gt; 가 null이 아니고 &lt;var&gt;obj&lt;/var&gt; 가 배열이고 다음 중 하나 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 true를 리턴 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434ad6018f88106e270997a09fba944128dfdee4" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; if this matcher uses</source>
          <target state="translated">이 매 처가 다음을 사용하는 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a9f4740e1d967f29b8a591631fdce83ae9b599e9" translate="yes" xml:space="preserve">
          <source>This method returns Strings in the format as specified in &lt;a href=&quot;x500principal#getName-java.lang.String-&quot;&gt;&lt;code&gt;getName(String)&lt;/code&gt;&lt;/a&gt; and also emits additional attribute type keywords for OIDs that have entries in the &lt;code&gt;oidMap&lt;/code&gt; parameter. OID entries in the oidMap take precedence over the default OIDs recognized by &lt;code&gt;getName(String)&lt;/code&gt;. Improperly specified OIDs are ignored; however if an OID in the name maps to an improperly specified keyword, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;x500principal#getName-java.lang.String-&quot;&gt; &lt;code&gt;getName(String)&lt;/code&gt; &lt;/a&gt; 지정된 형식으로 문자열을 리턴 하고 &lt;code&gt;oidMap&lt;/code&gt; 매개 변수에 항목이있는 OID에 대한 추가 속성 유형 키워드를 생성합니다 . oidMap의 OID 항목은 &lt;code&gt;getName(String)&lt;/code&gt; 인식하는 기본 OID보다 우선합니다 . 잘못 지정된 OID는 무시됩니다. 그러나 이름의 OID가 잘못 지정된 키워드에 매핑되면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f775b32d8b84056f67ed090a303c87ddab0e3e05" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination, in the same manner as the &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; method. Most implementations of this method will handle decoding errors by returning an appropriate result object for interpretation by the &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; method. An optimized implementation may instead examine the relevant error action and implement that action itself.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt; 객체를 리턴 하여 &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 종료 이유를 설명합니다 . 이 방법의 대부분의 구현은 &lt;a href=&quot;charsetdecoder#decode-java.nio.ByteBuffer-java.nio.CharBuffer-boolean-&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 방법으로 해석하기 위해 적절한 결과 객체를 반환하여 디코딩 오류를 처리합니다 . 최적화 된 구현은 대신 관련 오류 조치를 조사하고 해당 조치 자체를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7492e94d777f895b648e30cde9e372fc30473a" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination, in the same manner as the &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; method. Most implementations of this method will handle encoding errors by returning an appropriate result object for interpretation by the &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; method. An optimized implementation may instead examine the relevant error action and implement that action itself.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt; &lt;code&gt;encode&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 종료 이유를 설명하기 위해 &lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt; 오브젝트를 리턴합니다 . 이 메소드의 대부분의 구현은 &lt;a href=&quot;charsetencoder#encode-java.nio.CharBuffer-java.nio.ByteBuffer-boolean-&quot;&gt; &lt;code&gt;encode&lt;/code&gt; &lt;/a&gt; 메소드로 해석하기 위해 적절한 결과 오브젝트를 리턴하여 인코딩 오류를 처리합니다 . 최적화 된 구현은 대신 관련 오류 조치를 조사하고 해당 조치 자체를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc0807b65e2e62098494bdaecf746a629ac404f" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;code&gt;ThreadInfo&lt;/code&gt; object representing the thread information for the thread of the specified ID. The stack trace, locked monitors, and locked synchronizers in the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will be empty. If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">이 메소드는 지정된 ID의 스레드에 대한 스레드 정보를 나타내는 &lt;code&gt;ThreadInfo&lt;/code&gt; 오브젝트를 리턴합니다 . 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체 의 스택 추적, 잠긴 모니터 및 잠긴 동기화 프로그램은 비어 있습니다. 주어진 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 스레드가 시작되었지만 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4598419cdffeadc400039e9736ba9ad1774a776c" translate="yes" xml:space="preserve">
          <source>This method returns a copy of the retrieved password.</source>
          <target state="translated">이 메소드는 검색된 비밀번호의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd1f9c6ab0d681cc17bde0986b4f2d3f4c2a5336" translate="yes" xml:space="preserve">
          <source>This method returns a historically correct offset if an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical Daylight Saving Time schedule and GMT offset changes.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 서브 클래스가 역사적인 일광 절약 시간제 스케줄 및 GMT 오프셋 변경을 지원 하는 경우이 메소드는 역사적으로 올바른 오프셋을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="578877b97e2dd9db3f5a4d5ba6e568b208ee1d00" translate="yes" xml:space="preserve">
          <source>This method returns a historically correct offset value if an underlying TimeZone implementation subclass supports historical Daylight Saving Time schedule and GMT offset changes.</source>
          <target state="translated">기본 TimeZone 구현 서브 클래스가 역사적인 일광 절약 시간제 스케줄 및 GMT 오프셋 변경을 지원하는 경우이 메소드는 역사적으로 올바른 오프셋 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf880fb085eb8e006866ff6bc11e25f2fdc4f18d" translate="yes" xml:space="preserve">
          <source>This method returns a new object based on this one with the specified period added. For example, on a &lt;code&gt;LocalDate&lt;/code&gt;, this could be used to add a number of years, months or days. The returned object will have the same observable type as this object.</source>
          <target state="translated">이 메소드는 지정된 기간이 추가 된이 오브젝트를 기반으로 새 오브젝트를 리턴합니다. 예를 들어 &lt;code&gt;LocalDate&lt;/code&gt; 의 경우 몇 년, 몇 달 또는 몇 일을 추가하는 데 사용할 수 있습니다. 반환 된 객체는이 객체와 동일한 관찰 가능 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ce46bbe6b70b68c4de2951301dcd5af3392b7067" translate="yes" xml:space="preserve">
          <source>This method returns a new object based on this one with the specified period subtracted. For example, on a &lt;code&gt;LocalDate&lt;/code&gt;, this could be used to subtract a number of years, months or days. The returned object will have the same observable type as this object.</source>
          <target state="translated">이 메소드는 지정된 기간을 빼면이 오브젝트를 기반으로 새 오브젝트를 리턴합니다. 예를 들어, &lt;code&gt;LocalDate&lt;/code&gt; 의 경우 몇 년, 몇 달 또는 몇 일을 뺄 때 사용할 수 있습니다. 반환 된 객체는이 객체와 동일한 관찰 가능 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4995e2e9d492fba15617d1713716ea64da919048" translate="yes" xml:space="preserve">
          <source>This method returns a positive duration by effectively removing the sign from any negative total length. For example, &lt;code&gt;PT-1.3S&lt;/code&gt; will be returned as &lt;code&gt;PT1.3S&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 음의 총 길이에서 부호를 효과적으로 제거하여 양의 지속 시간을 리턴합니다. 예를 들어, &lt;code&gt;PT-1.3S&lt;/code&gt; 반환됩니다 &lt;code&gt;PT1.3S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98a2bc5ef45c3b2175e8511a4543985d9ec14d2" translate="yes" xml:space="preserve">
          <source>This method returns a reference to a &lt;code&gt;FileSystem&lt;/code&gt; that was created by invoking the &lt;a href=&quot;filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt;&lt;/a&gt; method. File systems created the &lt;a href=&quot;filesystemprovider#newFileSystem-java.nio.file.Path-java.util.Map-&quot;&gt;&lt;code&gt;newFileSystem(Path,Map)&lt;/code&gt;&lt;/a&gt; method are not returned by this method. The file system is identified by its &lt;code&gt;URI&lt;/code&gt;. Its exact form is highly provider dependent. In the case of the default provider the URI's path component is &lt;code&gt;&quot;/&quot;&lt;/code&gt; and the authority, query and fragment components are undefined (Undefined components are represented by &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;filesystemprovider#newFileSystem-java.net.URI-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(URI,Map)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 작성된 &lt;code&gt;FileSystem&lt;/code&gt; 에 대한 참조를 리턴합니다 . &lt;a href=&quot;filesystemprovider#newFileSystem-java.nio.file.Path-java.util.Map-&quot;&gt; &lt;code&gt;newFileSystem(Path,Map)&lt;/code&gt; &lt;/a&gt; 메소드를 작성한 파일 시스템 은이 메소드에 의해 리턴되지 않습니다. 파일 시스템은 &lt;code&gt;URI&lt;/code&gt; 로 식별됩니다 . 정확한 형식은 공급자에 따라 다릅니다. 기본 제공자의 경우 URI의 경로 구성 요소는 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 이고 권한, 조회 및 단편 구성 요소는 정의되지 않습니다 (정의되지 않은 구성 요소는 &lt;code&gt;null&lt;/code&gt; 로 표시됨).</target>
        </trans-unit>
        <trans-unit id="d3d9e3f858796b64acde060879ce45b8d881f617" translate="yes" xml:space="preserve">
          <source>This method returns all the printing attribute categories this print service supports for any possible job. Some categories may not be supported in a particular context (ie for a particular &lt;code&gt;DocFlavor&lt;/code&gt;). Use one of the methods that include a &lt;code&gt;DocFlavor&lt;/code&gt; to validate the request before submitting it, such as &lt;code&gt;getSupportedAttributeValues(..)&lt;/code&gt;.</source>
          <target state="translated">이 방법은이 인쇄 서비스가 가능한 모든 작업에 대해 지원하는 모든 인쇄 속성 범주를 반환합니다. 특정 범주 (예 : 특정 &lt;code&gt;DocFlavor&lt;/code&gt; ) 에서는 일부 범주가 지원되지 않을 수 있습니다 . &lt;code&gt;DocFlavor&lt;/code&gt; 가 포함 된 메소드 중 하나를 사용 하여 요청을 제출하기 전에 확인하십시오 &lt;code&gt;getSupportedAttributeValues(..)&lt;/code&gt; 예 : getSupportedAttributeValues ​​(..)) .</target>
        </trans-unit>
        <trans-unit id="a27e98ed975b6fbde54735985b3c18e81ef5eb5f" translate="yes" xml:space="preserve">
          <source>This method returns an Object because different printing attribute categories indicate the supported attribute values in different ways. The documentation for each printing attribute in package &lt;a href=&quot;attribute/standard/package-summary&quot;&gt;&lt;code&gt;javax.print.attribute.standard&lt;/code&gt;&lt;/a&gt; describes how each attribute indicates its supported values. Possible ways of indicating support include:</source>
          <target state="translated">다른 인쇄 속성 범주가 지원되는 속성 값을 다른 방식으로 나타 내기 때문에이 메소드는 Object를 리턴합니다. &lt;a href=&quot;attribute/standard/package-summary&quot;&gt; &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; &lt;/a&gt; 패키지의 각 인쇄 속성의 문서에, 각 속성이 지원되는 값을 나타내는 방법이 설명되어 있습니다. 지원을 나타내는 가능한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22e7584f26d52ab68f8f1bfdea8be12715c8e2f2" translate="yes" xml:space="preserve">
          <source>This method returns an array of &lt;a href=&quot;threadinfo&quot;&gt;&lt;code&gt;ThreadInfo&lt;/code&gt;&lt;/a&gt; objects as specified in the &lt;a href=&quot;threadmxbean#getThreadInfo-long:A-boolean-boolean-&quot;&gt;&lt;code&gt;getThreadInfo(long[], boolean, boolean)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;threadmxbean#getThreadInfo-long:A-boolean-boolean-&quot;&gt; &lt;code&gt;getThreadInfo(long[], boolean, boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 지정된대로 &lt;a href=&quot;threadinfo&quot;&gt; &lt;code&gt;ThreadInfo&lt;/code&gt; &lt;/a&gt; 오브젝트 의 배열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="96cee8a868089e071178e8cf360a91b1597daac9" translate="yes" xml:space="preserve">
          <source>This method returns an array of &lt;code&gt;File&lt;/code&gt; objects that denote the root directories of the available filesystem roots. It is guaranteed that the canonical pathname of any file physically present on the local machine will begin with one of the roots returned by this method.</source>
          <target state="translated">이 메소드는 사용 가능한 파일 시스템 루트의 루트 디렉토리를 나타내는 &lt;code&gt;File&lt;/code&gt; 객체 의 배열을 반환합니다 . 로컬 시스템에 실제로 존재하는 파일의 표준 경로 이름은이 방법으로 반환 된 루트 중 하나로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="6fd82c48fff0fda384c4e3bd2af562ca71729df9" translate="yes" xml:space="preserve">
          <source>This method returns an array of the &lt;code&gt;ThreadInfo&lt;/code&gt; objects, each is the thread information about the thread with the same index as in the &lt;code&gt;ids&lt;/code&gt; array. If a thread of the given ID is not alive or does not exist, &lt;code&gt;null&lt;/code&gt; will be set in the corresponding element in the returned array. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ThreadInfo&lt;/code&gt; 오브젝트 의 배열을 리턴 합니다. 각각은 &lt;code&gt;ids&lt;/code&gt; 배열 에서와 동일한 색인을 가진 스레드에 대한 스레드 정보 입니다. 주어진 ID의 스레드가 존재하지 않거나 존재하지 않으면 반환 된 배열의 해당 요소에 &lt;code&gt;null&lt;/code&gt; 이 설정됩니다. 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ad388440ab095ed3394cdf7678373f9ea4ea5481" translate="yes" xml:space="preserve">
          <source>This method returns an array of the &lt;code&gt;ThreadInfo&lt;/code&gt; objects. The stack trace, locked monitors, and locked synchronizers in each &lt;code&gt;ThreadInfo&lt;/code&gt; object will be empty. If a thread of a given ID is not alive or does not exist, the corresponding element in the returned array will contain &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체 의 배열을 반환 합니다. 각 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체 의 스택 추적, 잠긴 모니터 및 잠긴 동기화 프로그램 이 비어 있습니다. 지정된 ID의 스레드가 존재하지 않거나 존재하지 않으면 반환 된 배열의 해당 요소에 &lt;code&gt;null&lt;/code&gt; 이 포함 됩니다. 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="12443d584bf87eece4a46bc4cf8d68cee84e25c5" translate="yes" xml:space="preserve">
          <source>This method returns an asynchronous server socket channel that is bound to the &lt;em&gt;default group&lt;/em&gt;. This method is equivalent to evaluating the expression:</source>
          <target state="translated">이 메소드는 &lt;em&gt;디폴트 그룹에&lt;/em&gt; 바인드 된 비동기 서버 소켓 채널을 리턴합니다 . 이 방법은 표현식을 평가하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58d374dd65abe2c7947b9e4d26a095f7bb3a058e" translate="yes" xml:space="preserve">
          <source>This method returns an asynchronous socket channel that is bound to the &lt;em&gt;default group&lt;/em&gt;.This method is equivalent to evaluating the expression:</source>
          <target state="translated">이 메소드는 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인드 된 비동기 소켓 채널을 리턴합니다. 이 메소드는 표현식을 평가하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c859aadae0914b45b901176e23d5c1e0ed5ebaa9" translate="yes" xml:space="preserve">
          <source>This method returns an enumeration of the results. Each element in the enumeration contains the name of the object and other information about the object (see &lt;code&gt;SearchResult&lt;/code&gt;). The name is either relative to the target context of the search (which is named by the &lt;code&gt;name&lt;/code&gt; parameter), or it is a URL string. If the target context is included in the enumeration (as is possible when &lt;code&gt;cons&lt;/code&gt; specifies a search scope of &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; or &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt;), its name is the empty string.</source>
          <target state="translated">이 메소드는 결과의 열거를 리턴합니다. 열거의 각 요소에는 객체의 이름과 객체에 대한 기타 정보가 포함됩니다 ( &lt;code&gt;SearchResult&lt;/code&gt; 참조 ). 이름은 검색의 대상 컨텍스트 ( &lt;code&gt;name&lt;/code&gt; 매개 변수로 이름 지정)에 상대적 이거나 URL 문자열입니다. 대상 컨텍스트가 열거에 포함 된 경우 ( &lt;code&gt;cons&lt;/code&gt; 가 &lt;code&gt;SearchControls.OBJECT_SCOPE&lt;/code&gt; 또는 &lt;code&gt;SearchControls.SUBSTREE_SCOPE&lt;/code&gt; 의 검색 범위를 지정할 때 가능한 것처럼 ) 해당 이름은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d3c94a8386b6094a7f526c48d273a5ef05aedd02" translate="yes" xml:space="preserve">
          <source>This method returns an object with the same &lt;code&gt;LocalDateTime&lt;/code&gt; and the specified &lt;code&gt;ZoneOffset&lt;/code&gt;. No calculation is needed or performed. For example, if this time represents &lt;code&gt;2007-12-03T10:30+02:00&lt;/code&gt; and the offset specified is &lt;code&gt;+03:00&lt;/code&gt;, then this method will return &lt;code&gt;2007-12-03T10:30+03:00&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 동일한 &lt;code&gt;LocalDateTime&lt;/code&gt; 및 지정된 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 가진 오브젝트를 리턴합니다 . 계산이 필요하지 않습니다. 예를 들어,이 시간이 &lt;code&gt;2007-12-03T10:30+02:00&lt;/code&gt; 이고 지정된 오프셋이 &lt;code&gt;+03:00&lt;/code&gt; 이면이 메서드는 &lt;code&gt;2007-12-03T10:30+03:00&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9e49dbda5e113fb188bcad6045907c72611fa6f8" translate="yes" xml:space="preserve">
          <source>This method returns an object with the same &lt;code&gt;LocalTime&lt;/code&gt; and the specified &lt;code&gt;ZoneOffset&lt;/code&gt;. No calculation is needed or performed. For example, if this time represents &lt;code&gt;10:30+02:00&lt;/code&gt; and the offset specified is &lt;code&gt;+03:00&lt;/code&gt;, then this method will return &lt;code&gt;10:30+03:00&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 동일한 &lt;code&gt;LocalTime&lt;/code&gt; 및 지정된 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 가진 오브젝트를 리턴합니다 . 계산이 필요하지 않습니다. 예를 들어,이 시간이 &lt;code&gt;10:30+02:00&lt;/code&gt; 이고 지정된 오프셋이 &lt;code&gt;+03:00&lt;/code&gt; 이면이 메서드는 &lt;code&gt;10:30+03:00&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="64a2375be194ab393d8128f2ae1822212679d38f" translate="yes" xml:space="preserve">
          <source>This method returns an object with the specified &lt;code&gt;ZoneOffset&lt;/code&gt; and a &lt;code&gt;LocalDateTime&lt;/code&gt; adjusted by the difference between the two offsets. This will result in the old and new objects representing the same instant. This is useful for finding the local time in a different offset. For example, if this time represents &lt;code&gt;2007-12-03T10:30+02:00&lt;/code&gt; and the offset specified is &lt;code&gt;+03:00&lt;/code&gt;, then this method will return &lt;code&gt;2007-12-03T11:30+03:00&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 지정된 &lt;code&gt;ZoneOffset&lt;/code&gt; 및 &lt;code&gt;LocalDateTime&lt;/code&gt; 이 두 오프셋의 차이로 조정 된 개체를 반환 합니다. 이로 인해 동일한 순간을 나타내는 이전 및 새 객체가 생성됩니다. 다른 오프셋에서 현지 시간을 찾는 데 유용합니다. 예를 들어,이 시간이 &lt;code&gt;2007-12-03T10:30+02:00&lt;/code&gt; 이고 지정된 오프셋이 &lt;code&gt;+03:00&lt;/code&gt; 이면이 메서드는 &lt;code&gt;2007-12-03T11:30+03:00&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9a3492f34f21944e0c97ecddfccefeb8d27d851d" translate="yes" xml:space="preserve">
          <source>This method returns an object with the specified &lt;code&gt;ZoneOffset&lt;/code&gt; and a &lt;code&gt;LocalTime&lt;/code&gt; adjusted by the difference between the two offsets. This will result in the old and new objects representing the same instant on an implied day. This is useful for finding the local time in a different offset. For example, if this time represents &lt;code&gt;10:30+02:00&lt;/code&gt; and the offset specified is &lt;code&gt;+03:00&lt;/code&gt;, then this method will return &lt;code&gt;11:30+03:00&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 지정된 &lt;code&gt;ZoneOffset&lt;/code&gt; 과 &lt;code&gt;LocalTime&lt;/code&gt; 이 두 오프셋의 차이로 조정 된 객체를 반환 합니다. 이로 인해 묵시적인 날에 동일한 순간을 나타내는 이전 및 새 객체가 생성됩니다. 다른 오프셋에서 현지 시간을 찾는 데 유용합니다. 예를 들어,이 시간이 &lt;code&gt;10:30+02:00&lt;/code&gt; 이고 지정된 오프셋이 &lt;code&gt;+03:00&lt;/code&gt; 이면이 메서드는 &lt;code&gt;11:30+03:00&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e54179eaa20151601ee66ab0815237b92d95925c" translate="yes" xml:space="preserve">
          <source>This method returns silently if the provider is not installed or if name is null.</source>
          <target state="translated">이 메소드는 제공자가 설치되지 않았거나 name이 널인 경우 자동으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="096a799e0be99bdebe843ad2f3fe72056fb193da" translate="yes" xml:space="preserve">
          <source>This method returns the channel obtained by invoking the &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt;&lt;code&gt;inheritedChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;../nio/channels/spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이 메소드는 시스템 전체의 기본 &lt;a href=&quot;../nio/channels/spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt; &lt;code&gt;inheritedChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻은 채널을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a22965859dd87dbbfbd8a3a69d4390902caf6f26" translate="yes" xml:space="preserve">
          <source>This method returns the enum &lt;a href=&quot;dayofweek&quot;&gt;&lt;code&gt;DayOfWeek&lt;/code&gt;&lt;/a&gt; for the day-of-week. This avoids confusion as to what &lt;code&gt;int&lt;/code&gt; values mean. If you need access to the primitive &lt;code&gt;int&lt;/code&gt; value then the enum provides the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;int value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;dayofweek&quot;&gt; &lt;code&gt;DayOfWeek&lt;/code&gt; &lt;/a&gt; 대한 열거 형 DayOfWeek 를 리턴합니다 . 이것은 &lt;code&gt;int&lt;/code&gt; 값의 의미 에 대한 혼란을 피 합니다. 프리미티브 &lt;code&gt;int&lt;/code&gt; 값에 액세스해야하는 경우 열거 형은 &lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;int value&lt;/code&gt; &lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f094b9734e58036cc7f0d7e749cf03913864efae" translate="yes" xml:space="preserve">
          <source>This method returns the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; for the month. This avoids confusion as to what &lt;code&gt;int&lt;/code&gt; values mean. If you need access to the primitive &lt;code&gt;int&lt;/code&gt; value then the enum provides the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;int value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 해당 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 의 enum Month 를 리턴합니다 . 이것은 &lt;code&gt;int&lt;/code&gt; 값의 의미 에 대한 혼란을 피 합니다. 프리미티브 &lt;code&gt;int&lt;/code&gt; 값에 액세스해야하는 경우 열거 형은 &lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;int value&lt;/code&gt; &lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0e14b1a452ffeac588fdbd1918c1e714acd4a2e7" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;localdate#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;localdate#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="ec0b53bcb0115598582f28d1f5dd31562d18e95b" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;localdatetime#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;localdatetime#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="2c9518bbc958f1ef7f4a5267280c5f3b9fa7fda7" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;monthday#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;monthday#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="99f4fa75f86be0f9d463226662b550280e30d1b9" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;offsetdatetime#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;offsetdatetime#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="49a67cf97747e94dc55b5045ecbe797e55b95f85" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;yearmonth#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;yearmonth#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="288036dec84bf41e4662838cf6f6a387c34d127d" translate="yes" xml:space="preserve">
          <source>This method returns the month as an &lt;code&gt;int&lt;/code&gt; from 1 to 12. Application code is frequently clearer if the enum &lt;a href=&quot;month&quot;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/a&gt; is used by calling &lt;a href=&quot;zoneddatetime#getMonth--&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 월 을 1에서 12 사이 의 &lt;code&gt;int&lt;/code&gt; 로 리턴합니다 . 열거 형 &lt;a href=&quot;month&quot;&gt; &lt;code&gt;Month&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;zoneddatetime#getMonth--&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용되는 경우 애플리케이션 코드가 더 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="e357cbe7c592cbedd71e3376d507bbe920a84b6a" translate="yes" xml:space="preserve">
          <source>This method returns the most recently pushed-back byte, if there is one, and otherwise calls the &lt;code&gt;read&lt;/code&gt; method of its underlying input stream and returns whatever value that method returns.</source>
          <target state="translated">이 메소드는 가장 최근에 푸시 백 된 바이트를 리턴합니다 (있는 경우). 그렇지 않으면 기본 입력 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드를 호출하고 해당 메소드가 리턴하는 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="729f3b81efc551b47dff0322bf0b3bb789bab6b5" translate="yes" xml:space="preserve">
          <source>This method returns the nearest extant parent in the namespace. Thus if a Logger is called &quot;a.b.c.d&quot;, and a Logger called &quot;a.b&quot; has been created but no logger &quot;a.b.c&quot; exists, then a call of getParent on the Logger &quot;a.b.c.d&quot; will return the Logger &quot;a.b&quot;.</source>
          <target state="translated">이 메서드는 네임 스페이스에서 가장 가까운 부모를 반환합니다. 따라서 로거의 이름이 &quot;abcd&quot;이고 &quot;ab&quot;라는 로거가 작성되었지만 로거 &quot;abc&quot;가없는 경우 로거 &quot;abcd&quot;의 getParent 호출은 로거 &quot;ab&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="62c2e246cd63848e32d79eb7a1cd9cf138d6edac" translate="yes" xml:space="preserve">
          <source>This method returns the object on which it is called. A subclass can override it to return another object provided the contract is respected.</source>
          <target state="translated">이 메소드는 호출 된 오브젝트를 리턴합니다. 계약이 준수되는 경우 서브 클래스는이를 대체하여 다른 오브젝트를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd103f3dca089e4d35de20f77ab1d677952eaeb" translate="yes" xml:space="preserve">
          <source>This method returns the primitive &lt;code&gt;int&lt;/code&gt; value for the day-of-month.</source>
          <target state="translated">이 메소드는 월의 기본 &lt;code&gt;int&lt;/code&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="29fb4873a53454ba01b371258b2e1a0c98256b61" translate="yes" xml:space="preserve">
          <source>This method returns the primitive &lt;code&gt;int&lt;/code&gt; value for the day-of-year.</source>
          <target state="translated">이 메소드는 일의 프리미티브 &lt;code&gt;int&lt;/code&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0f84492756296babe253a083a8521646c91691af" translate="yes" xml:space="preserve">
          <source>This method returns the primitive &lt;code&gt;int&lt;/code&gt; value for the year.</source>
          <target state="translated">이 메소드는 연도 의 기본 &lt;code&gt;int&lt;/code&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1b1e63827aa9afce63f0a20e64e75169de9e06a3" translate="yes" xml:space="preserve">
          <source>This method returns the range of the field in the ISO-8601 calendar system. This range may be incorrect for other calendar systems. Use &lt;a href=&quot;../chrono/chronology#range-java.time.temporal.ChronoField-&quot;&gt;&lt;code&gt;Chronology.range(ChronoField)&lt;/code&gt;&lt;/a&gt; to access the correct range for a different calendar system.</source>
          <target state="translated">이 방법은 ISO-8601 달력 시스템에서 필드의 범위를 반환합니다. 다른 달력 시스템에서는이 범위가 올바르지 않을 수 있습니다. 사용 &lt;a href=&quot;../chrono/chronology#range-java.time.temporal.ChronoField-&quot;&gt; &lt;code&gt;Chronology.range(ChronoField)&lt;/code&gt; &lt;/a&gt; 다른 달력 시스템에 대한 올바른 범위에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef945f86886260debb2ff15cd741dd7793da2f87" translate="yes" xml:space="preserve">
          <source>This method returns the result of &lt;a href=&quot;filterinputstream#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;.available().</source>
          <target state="translated">이 방법의 결과 반환 &lt;a href=&quot;filterinputstream#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; .available을 ().</target>
        </trans-unit>
        <trans-unit id="66f8ce7dec95f661d4f4f0bccc846817dc7f8e4b" translate="yes" xml:space="preserve">
          <source>This method returns the root of the schema information tree that is applicable to the named object. Several named objects (or even an entire directory) might share the same schema.</source>
          <target state="translated">이 메소드는 이름 지정된 오브젝트에 적용 할 수있는 스키마 정보 트리의 루트를 리턴합니다. 여러 명명 된 객체 (또는 전체 디렉토리)가 동일한 스키마를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28209e46b3fdb11909e0140c20b5d382144e1f6a" translate="yes" xml:space="preserve">
          <source>This method returns the same result as the two-argument versions of &lt;code&gt;setScale&lt;/code&gt;, but saves the caller the trouble of specifying a rounding mode in cases where it is irrelevant.</source>
          <target state="translated">이 메소드는 두 개의 인수 버전의 &lt;code&gt;setScale&lt;/code&gt; 과 동일한 결과를 리턴 하지만 호출자가 관련이없는 경우 반올림 모드를 지정하는 문제점을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="78972b2eb2f19e3407ffa2b185d202106f9914d5" translate="yes" xml:space="preserve">
          <source>This method returns the singleton era of the correct type for the specified era value.</source>
          <target state="translated">이 메소드는 지정된 연대 값에 대한 올바른 유형의 싱글 톤 연대를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8d66232cfe68fdef26fee7b852c91a2f6edfc6e2" translate="yes" xml:space="preserve">
          <source>This method returns the string &lt;code&gt;&quot;BIG_ENDIAN&quot;&lt;/code&gt; for &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&quot;LITTLE_ENDIAN&quot;&lt;/code&gt; for &lt;a href=&quot;byteorder#LITTLE_ENDIAN&quot;&gt;&lt;code&gt;LITTLE_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 문자열을 반환합니다 &lt;code&gt;&quot;BIG_ENDIAN&quot;&lt;/code&gt; 에 대한 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&quot;LITTLE_ENDIAN&quot;&lt;/code&gt; 에 대한 &lt;a href=&quot;byteorder#LITTLE_ENDIAN&quot;&gt; &lt;code&gt;LITTLE_ENDIAN&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97dea25a4738ecf811b303cb1add7be21f8f9310" translate="yes" xml:space="preserve">
          <source>This method returns the sum of the number of bytes remaining to be read in the buffer (&lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;) and the result of calling the &lt;a href=&quot;filterinputstream#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;.available().</source>
          <target state="translated">이 메소드는 버퍼에서 읽을 나머지 바이트 수 ( &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt; )와 &lt;a href=&quot;filterinputstream#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; .available () 호출 결과의 합계를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6fee1b06b53ec9221ddb54c84e056343046d2b24" translate="yes" xml:space="preserve">
          <source>This method returns true if:</source>
          <target state="translated">이 메소드는 다음과 같은 경우에 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e72419101078d515fd0561eb0c03a7b646ae4d97" translate="yes" xml:space="preserve">
          <source>This method runs in linear time.</source>
          <target state="translated">이 방법은 선형 시간으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9eda0757c2e5646daa119a8994ecb3f23d0d9dc7" translate="yes" xml:space="preserve">
          <source>This method runs in linear time. If the specified list does not implement the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a &quot;sequential access&quot; list in place.</source>
          <target state="translated">이 방법은 선형 시간으로 실행됩니다. 지정된리스트가 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않고 큰 경우,이 구현은 지정된리스트를 셔플하기 전에 배열에 덤프하고, 셔플 된 배열을리스트에 다시 덤프합니다. 이렇게하면 &quot;순차 액세스&quot;목록을 섞어 2 차 동작을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a775b01962d956b9e06ebfef16fc5299acbcfd95" translate="yes" xml:space="preserve">
          <source>This method runs in log(n) time for a &quot;random access&quot; list (which provides near-constant-time positional access). If the specified list does not implement the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.</source>
          <target state="translated">이 방법은 &quot;랜덤 액세스&quot;목록에 대해 log (n) 시간으로 실행됩니다 (이는 거의 일정한 시간의 위치 액세스를 제공합니다). 지정된리스트가 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않고 큰 경우,이 메소드는 O (n) 링크 순회 및 O (log n) 요소 비교를 수행하는 반복자 기반 2 진 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b4aad462284b0b19c7043f83c4a15cf73ee5dfa1" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;a href=&quot;../../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals&lt;/code&gt; &lt;/a&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="8696ca26ca420ff769671a0d6b061a7afc412d55" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;a href=&quot;../../../lang/object#hashCode--&quot;&gt;&lt;code&gt;Object.hashCode()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../../lang/object#hashCode--&quot;&gt; &lt;code&gt;Object.hashCode()&lt;/code&gt; &lt;/a&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9afb334f76f0709fbefa834912b0ae8d6392ded6" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals&lt;/code&gt; &lt;/a&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="50382711bd8e19aa7d035d616ce22135cd5083d4" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt;&lt;code&gt;Comparable.compareTo&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt; &lt;code&gt;Comparable.compareTo&lt;/code&gt; &lt;/a&gt; 방법 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="5331897f818caac3e947824f50a47ff5791d467a" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;a href=&quot;../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals&lt;/code&gt; &lt;/a&gt; 메소드 의 일반 계약을 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="30058877bdc80d4a153b8f7b71619a6b02f026a5" translate="yes" xml:space="preserve">
          <source>This method searches through the input up to the specified search horizon, ignoring delimiters. If the pattern is found the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected then the null is returned and the scanner's position remains unchanged. This method may block waiting for input that matches the pattern.</source>
          <target state="translated">이 메소드는 구분 기호를 무시하고 지정된 검색 범위까지 입력을 검색합니다. 패턴이 발견되면 스캐너는 일치하는 입력을지나 진행하고 패턴과 일치하는 문자열을 반환합니다. 이러한 패턴이 감지되지 않으면 null이 반환되고 스캐너 위치는 변경되지 않습니다. 이 메소드는 패턴과 일치하는 입력 대기를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709c2c3d093fae94c2903fbaba8d914b5b9a56a2" translate="yes" xml:space="preserve">
          <source>This method sets this context's &lt;code&gt;connCtls&lt;/code&gt; to be its new connection request controls. This context's context request controls are not affected. After this method has been invoked, any subsequent implicit reconnections will be done using &lt;code&gt;connCtls&lt;/code&gt;. &lt;code&gt;connCtls&lt;/code&gt; are also used as connection request controls for new context instances derived from this context. These connection request controls are not affected by &lt;code&gt;setRequestControls()&lt;/code&gt;.</source>
          <target state="translated">이 메소드는이 컨텍스트의 &lt;code&gt;connCtls&lt;/code&gt; 를 새로운 연결 요청 제어로 설정합니다. 이 컨텍스트의 컨텍스트 요청 컨트롤은 영향을받지 않습니다. 이 메소드가 호출 된 후, 후속 암시 적 재 연결은 &lt;code&gt;connCtls&lt;/code&gt; 를 사용하여 수행됩니다 . &lt;code&gt;connCtls&lt;/code&gt; 은이 컨텍스트에서 파생 된 새 컨텍스트 인스턴스에 대한 연결 요청 제어로도 사용됩니다. 이러한 연결 요청 제어는 &lt;code&gt;setRequestControls()&lt;/code&gt; 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c5cf5b5df3f5436f31b3c3798c9cc9d254a6cd57" translate="yes" xml:space="preserve">
          <source>This method should be called during construction or initialization of this instance, and before the MBean is registered with the MBeanServer.</source>
          <target state="translated">이 메소드는이 인스턴스의 구성 또는 초기화 중에 그리고 MBean이 MBeanServer에 등록되기 전에 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9572d56dcaaaaccd2ff117f06e1d6fb367780859" translate="yes" xml:space="preserve">
          <source>This method should be implemented consistently with &lt;code&gt;equals(Object)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;equals(Object)&lt;/code&gt; 일관되게 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="29f95933a9e570bfb500b6330c648329a4a69d82" translate="yes" xml:space="preserve">
          <source>This method should be invoked in tandem with the &lt;a href=&quot;abstractinterruptiblechannel#begin--&quot;&gt;&lt;code&gt;begin&lt;/code&gt;&lt;/a&gt; method, using a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block as shown &lt;a href=&quot;#be&quot;&gt;above&lt;/a&gt;, in order to implement asynchronous closing and interruption for this channel.</source>
          <target state="translated">이 메소드는 이 채널에 대한 비동기 닫기 및 인터럽트를 구현하기 위해 &lt;a href=&quot;#be&quot;&gt;위에&lt;/a&gt; 표시된 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록을 사용하여 &lt;a href=&quot;abstractinterruptiblechannel#begin--&quot;&gt; &lt;code&gt;begin&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57bd5eaeb3f6b692eb98dc238b586a5a1f86c7e9" translate="yes" xml:space="preserve">
          <source>This method should be invoked in tandem with the &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method, using a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block as shown &lt;a href=&quot;#be&quot;&gt;above&lt;/a&gt;, in order to implement asynchronous closing and interruption for this channel.</source>
          <target state="translated">이 메소드는 이 채널에 대한 비동기 닫기 및 인터럽트를 구현하기 위해 &lt;a href=&quot;#be&quot;&gt;위에&lt;/a&gt; 표시된 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록을 사용하여 &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eae9ee327988c66b884eb64e681ed0fec1f0d6e6" translate="yes" xml:space="preserve">
          <source>This method should be invoked in tandem with the &lt;a href=&quot;abstractselector#begin--&quot;&gt;&lt;code&gt;begin&lt;/code&gt;&lt;/a&gt; method, using a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block as shown &lt;a href=&quot;#be&quot;&gt;above&lt;/a&gt;, in order to implement interruption for this selector.</source>
          <target state="translated">이 선택기의 중단을 구현하려면 &lt;a href=&quot;#be&quot;&gt;위에&lt;/a&gt; 표시된 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록을 사용하여 &lt;a href=&quot;abstractselector#begin--&quot;&gt; &lt;code&gt;begin&lt;/code&gt; &lt;/a&gt; 메소드 와 함께이 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b25d0709861a8dbe12e01ad2ffac5fcd56174e7" translate="yes" xml:space="preserve">
          <source>This method should be invoked in tandem with the &lt;a href=&quot;abstractselector#end--&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method, using a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block as shown &lt;a href=&quot;#be&quot;&gt;above&lt;/a&gt;, in order to implement interruption for this selector.</source>
          <target state="translated">이 선택기의 인터럽트를 구현하려면 &lt;a href=&quot;#be&quot;&gt;위&lt;/a&gt; 의 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록을 사용하여 &lt;a href=&quot;abstractselector#end--&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드 와 함께이 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f79ea4505b47cfd8c99b8b4476c5daf765147e5" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses.</source>
          <target state="translated">이 메소드는 서브 클래스로 대체되어야합니다.</target>
        </trans-unit>
        <trans-unit id="29dc02668476fabab14ab7501af66787f6a7ae58" translate="yes" xml:space="preserve">
          <source>This method should be overridden when the &lt;a href=&quot;collection#spliterator--&quot;&gt;&lt;code&gt;spliterator()&lt;/code&gt;&lt;/a&gt; method cannot return a spliterator that is &lt;code&gt;IMMUTABLE&lt;/code&gt;, &lt;code&gt;CONCURRENT&lt;/code&gt;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &lt;a href=&quot;collection#spliterator--&quot;&gt;&lt;code&gt;spliterator()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">&lt;a href=&quot;collection#spliterator--&quot;&gt; &lt;code&gt;spliterator()&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;IMMUTABLE&lt;/code&gt; , &lt;code&gt;CONCURRENT&lt;/code&gt; 또는 &lt;em&gt;late-binding&lt;/em&gt; 스플리터를 리턴 할 수없는 경우이 메소드를 대체해야합니다 . 자세한 내용은 &lt;a href=&quot;collection#spliterator--&quot;&gt; &lt;code&gt;spliterator()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71d658a46ff3d502e0136280d62ea4fc06d64da9" translate="yes" xml:space="preserve">
          <source>This method should be used instead of the other two overloaded forms when the caller needs to supply request controls for creating the referral context. It might need to do this, for example, when it needs to supply special controls relating to authentication.</source>
          <target state="translated">호출자가 참조 컨텍스트를 작성하기 위해 요청 제어를 제공해야하는 경우 다른 두 개의 오버로드 된 양식 대신이 메소드를 사용해야합니다. 예를 들어 인증과 관련된 특수 제어를 제공해야 할 때이를 수행해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34ab78e281e8fce22d2a69b13041e7e7c4d990cb" translate="yes" xml:space="preserve">
          <source>This method should be used with extreme caution. Unlike the &lt;code&gt;&lt;a href=&quot;runtime#exit-int-&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method, this method does not cause shutdown hooks to be started and does not run uninvoked finalizers if finalization-on-exit has been enabled. If the shutdown sequence has already been initiated then this method does not wait for any running shutdown hooks or finalizers to finish their work.</source>
          <target state="translated">이 방법은 매우주의해서 사용해야합니다. &lt;code&gt;&lt;a href=&quot;runtime#exit-int-&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 방법 과 달리이 방법은 종료 후크를 시작하지 않고 종료시 종료가 활성화 된 경우 호출되지 않은 종료자를 실행하지 않습니다. 종료 시퀀스가 ​​이미 시작된 경우이 방법은 실행중인 종료 후크 또는 종료자가 작업을 완료 할 때까지 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7079e3fbbfe7b9e60114d849e0b0a1f8315cef28" translate="yes" xml:space="preserve">
          <source>This method should only be called by a thread that is the owner of this object's monitor. A thread becomes the owner of the object's monitor in one of three ways:</source>
          <target state="translated">이 메소드는이 객체 모니터의 소유자 인 스레드에 의해서만 호출되어야합니다. 스레드는 다음 세 가지 방법 중 하나로 객체 모니터의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="777feaab7923a263f03277b89549cf426a833739" translate="yes" xml:space="preserve">
          <source>This method should only be called by a thread that is the owner of this object's monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a description of the ways in which a thread can become the owner of a monitor.</source>
          <target state="translated">이 메소드는이 객체 모니터의 소유자 인 스레드에 의해서만 호출되어야합니다. 스레드가 모니터의 소유자가 될 수있는 방법에 대한 설명은 &lt;code&gt;notify&lt;/code&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd0da8ef1149610edaaec69e689e2ca993719641" translate="yes" xml:space="preserve">
          <source>This method should only be invoked within the context of initializing a persistence delegate or setting up an encoder to read from a resource bundle.</source>
          <target state="translated">이 메소드는 지속성 위임을 초기화하거나 자원 번들에서 읽도록 인코더를 설정하는 컨텍스트 내에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="238ce84423ce68f3a96955f6c483908adb7bd7e6" translate="yes" xml:space="preserve">
          <source>This method should only be invoked within the context of initializing a persistence delegate.</source>
          <target state="translated">이 메소드는 지속성 위임 초기화 컨텍스트 내에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4b807876fe6997c88b6b5ad84a05abb4afe4cb8" translate="yes" xml:space="preserve">
          <source>This method simply calls &lt;code&gt;available&lt;/code&gt; of the current underlying input stream and returns the result.</source>
          <target state="translated">이 메소드는 단순히 현재 기본 입력 스트림의 &lt;code&gt;available&lt;/code&gt; 을 호출 하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5dee1c64dcb117f68fed752a842221d52473559" translate="yes" xml:space="preserve">
          <source>This method simply calls &lt;code&gt;get((Object[]) key)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;get((Object[]) key)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8e8e8c8f040b562297c09db4df4590a4dcf57a91" translate="yes" xml:space="preserve">
          <source>This method simply calls &lt;code&gt;put((CompositeData) value)&lt;/code&gt; and therefore ignores its &lt;var&gt;key&lt;/var&gt; parameter which can be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;put((CompositeData) value)&lt;/code&gt; 호출 하므로 &lt;code&gt;null&lt;/code&gt; 이 될 수있는 &lt;var&gt;key&lt;/var&gt; 매개 변수를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e8a1d0ec1e1a366794c4c1949a880fb97db20a" translate="yes" xml:space="preserve">
          <source>This method simply calls &lt;code&gt;remove((Object[]) key)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;remove((Object[]) key)&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="bc6bc0fc425ab494d2ecac76297d1e62f6fb1eb3" translate="yes" xml:space="preserve">
          <source>This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;in.mark(readlimit)&lt;/code&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="f46e89ba359a12a65dcf2acfbb614e6e1a9ffc1c" translate="yes" xml:space="preserve">
          <source>This method simply performs &lt;code&gt;in.read()&lt;/code&gt; and returns the result.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;in.read()&lt;/code&gt; 를 수행 하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7bee99ea682b5ebdba1502480d4d3571110116cc" translate="yes" xml:space="preserve">
          <source>This method simply performs &lt;code&gt;in.read(b, off, len)&lt;/code&gt; and returns the result.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;in.read(b, off, len)&lt;/code&gt; 를 수행 하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8edf0a88f05440a5392c7d0c3e3f37a8797689df" translate="yes" xml:space="preserve">
          <source>This method simply performs &lt;code&gt;in.reset()&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;in.reset()&lt;/code&gt; 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="17f994e59a98ce2feb35ffc74454bfbbc2a97137" translate="yes" xml:space="preserve">
          <source>This method simply performs &lt;code&gt;in.skip(n)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;in.skip(n)&lt;/code&gt; 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="1edc42660d60900aa92eba9fe33b01f48322fd87" translate="yes" xml:space="preserve">
          <source>This method simply performs the call &lt;code&gt;read(b, 0, b.length)&lt;/code&gt; and returns the result. It is important that it does</source>
          <target state="translated">이 메소드는 단순히 &lt;code&gt;read(b, 0, b.length)&lt;/code&gt; 호출을 수행 하고 결과를 리턴합니다. 그것이 중요하다</target>
        </trans-unit>
        <trans-unit id="b4556d9ecf323d07c8124b74db08512b40320a22" translate="yes" xml:space="preserve">
          <source>This method starts at the beginning of this matcher's region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match.</source>
          <target state="translated">이 메소드는이 매처 영역의 시작 부분에서 시작하거나, 메소드의 이전 호출이 완료되고 이후에 일치 프로그램이 재설정되지 않은 경우, 이전 문자와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="17094ba13ee4a3a748a03c765e3399bae3e18ac5" translate="yes" xml:space="preserve">
          <source>This method subtracts the specified amount from the days field decrementing the month and year fields as necessary to ensure the result remains valid. The result is only invalid if the maximum/minimum year is exceeded.</source>
          <target state="translated">이 방법은 결과를 유효하게 유지하기 위해 필요에 따라 월 및 연도 필드를 감소시키는 일 필드에서 지정된 양을 뺍니다. 최대 / 최소 연도를 초과 한 경우에만 결과가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="794983e28b53204c2dfb6c7bc67152872b7333dd" translate="yes" xml:space="preserve">
          <source>This method subtracts the specified amount from the months field in three steps:</source>
          <target state="translated">이 방법은 개월 필드에서 지정된 양을 세 단계로 뺍니다.</target>
        </trans-unit>
        <trans-unit id="01ab275252deaae430470917667d8e1be68a9d79" translate="yes" xml:space="preserve">
          <source>This method subtracts the specified amount from the years field in three steps:</source>
          <target state="translated">이 방법은 세 단계에서 연도 필드에서 지정된 양을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="22318c29d0133d2101a84aaa0d0f6a6b1ec2afcf" translate="yes" xml:space="preserve">
          <source>This method subtracts the specified amount in weeks from the days field decrementing the month and year fields as necessary to ensure the result remains valid. The result is only invalid if the maximum/minimum year is exceeded.</source>
          <target state="translated">이 방법은 결과를 유효하게 유지하기 위해 필요에 따라 월 및 연도 필드를 감소시키는 일 필드에서 지정된 주 단위의 양을 뺍니다. 최대 / 최소 연도를 초과 한 경우에만 결과가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfd44cbba3ac7f729ff2df76b583aea70712cc43" translate="yes" xml:space="preserve">
          <source>This method supports a special technique of parsing known as 'adjacent value parsing'. This technique solves the problem where a value, variable or fixed width, is followed by one or more fixed length values. The standard parser is greedy, and thus it would normally steal the digits that are needed by the fixed width value parsers that follow the variable width one.</source>
          <target state="translated">이 방법은 '인접 값 구문 분석'이라는 특수한 구문 분석 기술을 지원합니다. 이 기술은 변수 또는 고정 너비 값 뒤에 하나 이상의 고정 길이 값이 따르는 문제를 해결합니다. 표준 파서는 욕심이 많으므로 일반적으로 가변 너비 1을 따르는 고정 너비 값 파서에 필요한 숫자를 훔칩니다.</target>
        </trans-unit>
        <trans-unit id="c150abc03144234b22efe8cbbae37477c8cfbbcf" translate="yes" xml:space="preserve">
          <source>This method supports post-processing on optional values, without the need to explicitly check for a return status. For example, the following code traverses a stream of file names, selects one that has not yet been processed, and then opens that file, returning an &lt;code&gt;Optional&amp;lt;FileInputStream&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이 메소드는 명시 적으로 리턴 상태를 확인할 필요없이 선택적 값에 대한 사후 처리를 지원합니다. 예를 들어 다음 코드는 파일 이름 스트림을 통과하고 아직 처리되지 않은 파일 이름을 선택한 다음 해당 파일을 열어 &lt;code&gt;Optional&amp;lt;FileInputStream&amp;gt;&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f74504c00f8a1676aab5ce7b90c92c2414f54075" translate="yes" xml:space="preserve">
          <source>This method supports three Type/format combinations:</source>
          <target state="translated">이 방법은 세 가지 유형 / 형식 조합을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ad744206021f227827ab73bf72c46e244315e010" translate="yes" xml:space="preserve">
          <source>This method swaps the sign of the total length of this duration. For example, &lt;code&gt;PT1.3S&lt;/code&gt; will be returned as &lt;code&gt;PT-1.3S&lt;/code&gt;.</source>
          <target state="translated">이 방법은이 기간의 총 길이 부호를 바꿉니다. 예를 들어 &lt;code&gt;PT1.3S&lt;/code&gt; 는 &lt;code&gt;PT-1.3S&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b826eca69467428f720b33ccfa8e6a22178be3fd" translate="yes" xml:space="preserve">
          <source>This method synchronizes on &lt;code&gt;this&lt;/code&gt;, the destination object, but does not synchronize on the source (&lt;code&gt;s&lt;/code&gt;).</source>
          <target state="translated">에이 메소드를 동기화 &lt;code&gt;this&lt;/code&gt; 대상 객체 있지만, 소스 (에 동기화되지 않습니다 &lt;code&gt;s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="781a90ba86b28c4eca13fb9ec17885d2aef64f54" translate="yes" xml:space="preserve">
          <source>This method synchronizes on &lt;code&gt;this&lt;/code&gt;, the destination object, but does not synchronize on the source (&lt;code&gt;sb&lt;/code&gt;).</source>
          <target state="translated">에이 메소드를 동기화 &lt;code&gt;this&lt;/code&gt; 대상 객체는하지만, 소스 (에 동기화되지 않습니다 &lt;code&gt;sb&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bacc286ded4e8325bb4d5d723224404336be0ccd" translate="yes" xml:space="preserve">
          <source>This method takes a &quot;snapshot&quot; of the current calling context, which includes the current Thread's inherited AccessControlContext and any limited privilege scope, and places it in an AccessControlContext object. This context may then be checked at a later point, possibly in another thread.</source>
          <target state="translated">이 메소드는 현재 스레드의 상속 된 AccessControlContext 및 제한된 권한 범위를 포함하는 현재 호출 컨텍스트의 &quot;스냅 샷&quot;을 가져 와서 AccessControlContext 오브젝트에 배치합니다. 이 컨텍스트는 나중에 다른 스레드에서 나중에 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e9702b57e95947764ed431bf7ffa0b25100c5e" translate="yes" xml:space="preserve">
          <source>This method takes no arguments, and opens the line with the current settings. For &lt;code&gt;&lt;a href=&quot;sourcedataline&quot;&gt;&lt;code&gt;SourceDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;targetdataline&quot;&gt;&lt;code&gt;TargetDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; objects, this means that the line is opened with default settings. For a &lt;code&gt;&lt;a href=&quot;clip&quot;&gt;&lt;code&gt;Clip&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;, however, the buffer size is determined when data is loaded. Since this method does not allow the application to specify any data to load, an IllegalArgumentException is thrown. Therefore, you should instead use one of the &lt;code&gt;open&lt;/code&gt; methods provided in the &lt;code&gt;Clip&lt;/code&gt; interface to load data into the &lt;code&gt;Clip&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 인수를 사용하지 않고 현재 설정으로 행을 엽니 다. 대한 &lt;code&gt;&lt;a href=&quot;sourcedataline&quot;&gt;&lt;code&gt;SourceDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;targetdataline&quot;&gt;&lt;code&gt;TargetDataLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 의 객체, 라인이 기본 설정으로 열 것을이 의미합니다. A에 대한 &lt;code&gt;&lt;a href=&quot;clip&quot;&gt;&lt;code&gt;Clip&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 데이터가로드되는 경우, 그러나, 상기 버퍼의 크기가 결정된다. 이 메소드는 애플리케이션이로드 할 데이터를 지정할 수 없으므로 IllegalArgumentException이 발생합니다. 따라서, 대신 중 하나를 사용한다 &lt;code&gt;open&lt;/code&gt; 에서 제공 방법 &lt;code&gt;Clip&lt;/code&gt; 로 데이터를로드하는 인터페이스를 &lt;code&gt;Clip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="749999b26511eb37fdf759572bbebb73b6f7719a" translate="yes" xml:space="preserve">
          <source>This method then calls the &lt;code&gt;interrupt&lt;/code&gt; method on all the threads in this thread group and in all of its subgroups.</source>
          <target state="translated">그런 다음이 메소드 는이 스레드 그룹과 모든 하위 그룹의 모든 스레드에서 &lt;code&gt;interrupt&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c6078753d6cb08e2fd72e832d8ed0a44dfeda009" translate="yes" xml:space="preserve">
          <source>This method then calls the &lt;code&gt;resume&lt;/code&gt; method on all the threads in this thread group and in all of its sub groups.</source>
          <target state="translated">그런 다음이 메소드 는이 스레드 그룹과 모든 하위 그룹의 모든 스레드에서 &lt;code&gt;resume&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9ac488b98809ce75c359b89f89dafde31807a97a" translate="yes" xml:space="preserve">
          <source>This method then calls the &lt;code&gt;stop&lt;/code&gt; method on all the threads in this thread group and in all of its subgroups.</source>
          <target state="translated">그런 다음이 메소드 는이 스레드 그룹과 모든 하위 그룹의 모든 스레드에서 &lt;code&gt;stop&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcee260a54e7063d2c3bb8e2ee245593a9d6c0c" translate="yes" xml:space="preserve">
          <source>This method then calls the &lt;code&gt;suspend&lt;/code&gt; method on all the threads in this thread group and in all of its subgroups.</source>
          <target state="translated">그런 다음이 메소드 는이 스레드 그룹 및 모든 하위 그룹의 모든 스레드에서 &lt;code&gt;suspend&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e350f9ae8035727aaa40eabef55881cb72192e3b" translate="yes" xml:space="preserve">
          <source>This method throws &lt;a href=&quot;../filesystemalreadyexistsexception&quot;&gt;&lt;code&gt;FileSystemAlreadyExistsException&lt;/code&gt;&lt;/a&gt; if the file system already exists because it was previously created by an invocation of this method. Once a file system is &lt;a href=&quot;../filesystem#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt; it is provider-dependent if the provider allows a new file system to be created with the same URI as a file system it previously created.</source>
          <target state="translated">파일 시스템이 이미이 메소드의 호출에 의해 작성 되었기 때문에 파일 시스템이 이미 존재하면 이 메소드는 &lt;a href=&quot;../filesystemalreadyexistsexception&quot;&gt; &lt;code&gt;FileSystemAlreadyExistsException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 파일 시스템이 &lt;a href=&quot;../filesystem#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 제공자가 이전에 작성한 파일 시스템과 동일한 URI로 새 파일 시스템을 작성할 수 있도록하는 경우 제공자에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="937bce123445844f695ad61bb19f55c226141aa5" translate="yes" xml:space="preserve">
          <source>This method throws &lt;a href=&quot;invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; when the path string cannot be converted to a path. Where possible, and where applicable, the exception is created with an &lt;a href=&quot;invalidpathexception#getIndex--&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; value indicating the first position in the &lt;code&gt;path&lt;/code&gt; parameter that caused the path string to be rejected.</source>
          <target state="translated">이 메소드는 경로 문자열을 경로로 변환 할 수없는 경우 &lt;a href=&quot;invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 가능한 경우, 그리고 해당되는 경우를 제외하고는 함께 작성된 &lt;a href=&quot;invalidpathexception#getIndex--&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 필드에 첫 번째 위치를 나타내는 값 &lt;code&gt;path&lt;/code&gt; 경로 문자열 거부 원인 파라미터.</target>
        </trans-unit>
        <trans-unit id="01d5015aba13924f7d366d34e50b6072f63a415e" translate="yes" xml:space="preserve">
          <source>This method throws no reflective or security exceptions.</source>
          <target state="translated">이 메소드는 반사 또는 보안 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afa7b41cf80e53d8a9c59aa94a72f31c8ffd5d02" translate="yes" xml:space="preserve">
          <source>This method transfers bytes from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 대상 배열로 바이트를 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="23c829a65a69986b9504ae064aa8799e136296a8" translate="yes" xml:space="preserve">
          <source>This method transfers bytes from this buffer into the given destination array. If there are fewer bytes remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no bytes are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 대상 배열로 바이트를 전송합니다. 버퍼에 남아있는 바이트 수가 요청을 충족시키는 데 필요한 것보다 적습니다. 즉, &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 바이트가 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd9758e168b771cfdd859292d3cdfe5982626280" translate="yes" xml:space="preserve">
          <source>This method transfers bytes into this buffer from the given source array. If there are more bytes to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no bytes are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 바이트를 전송합니다. 배열에서이 버퍼에 남아있는 것보다 더 많은 바이트가 복사되는 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우 바이트가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8b34fcf121ff7537825a07c54335656d27ce21a" translate="yes" xml:space="preserve">
          <source>This method transfers chars from the given string into this buffer. If there are more chars to be copied from the string than remain in this buffer, that is, if &lt;code&gt;end - start&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no chars are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 문자열에서이 버퍼로 문자를 전송합니다. 이 버퍼에 남아있는 것보다 문자열에서 복사 할 문자가 더 많으면 (즉, &lt;code&gt;end - start&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 문자가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b95d50f138da0740f549ca688c52b4927caa5285" translate="yes" xml:space="preserve">
          <source>This method transfers chars from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 문자를이 버퍼에서 지정된 대상 배열로 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="3f8c88edee67356ee7c4251fc51e9e6ba295d78f" translate="yes" xml:space="preserve">
          <source>This method transfers chars from this buffer into the given destination array. If there are fewer chars remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no chars are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 문자를이 버퍼에서 지정된 대상 배열로 전송합니다. 요청을 충족시키는 데 필요한 것보다 적은 수의 문자가 버퍼에 남아있는 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우 문자가 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3012d3613f04886d312ce45ee107e50ccf089df1" translate="yes" xml:space="preserve">
          <source>This method transfers chars into this buffer from the given source array. If there are more chars to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no chars are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 문자를 전송합니다. 이 버퍼에 남아있는 것보다 배열에서 복사 할 수있는 문자가 더 많으면 (즉, &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 경우 ) 문자가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8efb19b9bbf42d5fed4580afdec34e08217d1b71" translate="yes" xml:space="preserve">
          <source>This method transfers doubles from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 대상 배열로 double을 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ea42b6931ed452e79de4ca7d32554ef05bc44f68" translate="yes" xml:space="preserve">
          <source>This method transfers doubles from this buffer into the given destination array. If there are fewer doubles remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no doubles are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 대상 배열로 double을 전송합니다. 버퍼에 남아있는 double이 요청을 충족시키는 데 필요한 것보다 적다면, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 double이 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f1007ee256143a7348ae5c099b14be06bffa094" translate="yes" xml:space="preserve">
          <source>This method transfers doubles into this buffer from the given source array. If there are more doubles to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no doubles are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 double을 전송합니다. 이 버퍼에 남아있는 것보다 배열에서 복사 할 복식 수가 더 많으면, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 복식이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4983f8341c20dd98ab215a5a53d2f9c87b50fa9f" translate="yes" xml:space="preserve">
          <source>This method transfers floats from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 목적지 배열로 float를 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="add5cb82464e8b75c258298fde36da297219276c" translate="yes" xml:space="preserve">
          <source>This method transfers floats from this buffer into the given destination array. If there are fewer floats remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no floats are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 목적지 배열로 float를 전송합니다. 요청을 충족시키는 데 필요한 수보다 적은 수의 부동 소수점이 버퍼에 남아있는 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 부동 소수점이 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4fc9f59d05784966f764ab2e2c5fe51cf2314ac4" translate="yes" xml:space="preserve">
          <source>This method transfers floats into this buffer from the given source array. If there are more floats to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no floats are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 float를 전송합니다. 이 버퍼에 남아있는 것보다 배열에서 복사 할 수있는 부동 수가 더 많은 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 부동 수가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54c6e5d2f9f2435bc5e8e097104969c5662d59d8" translate="yes" xml:space="preserve">
          <source>This method transfers ints from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 정수를이 버퍼로부터 지정된 배열에 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="f8ce58e3a68123d420ce741c3e93388150cf02be" translate="yes" xml:space="preserve">
          <source>This method transfers ints from this buffer into the given destination array. If there are fewer ints remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no ints are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 정수를이 버퍼로부터 지정된 배열에 전송합니다. 요청을 충족시키는 데 필요한 것보다 적은 수의 int가 버퍼에 남아있는 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 int가 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c39e97914ca9f39e7e5755ada34160a831f9f95" translate="yes" xml:space="preserve">
          <source>This method transfers ints into this buffer from the given source array. If there are more ints to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no ints are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 정수를 전송합니다. 이 버퍼에 남아있는 것보다 배열에서 복사 할 int가 더 많은 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 int가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed25aff7206e1ea3ed6b8e66687a723da874494d" translate="yes" xml:space="preserve">
          <source>This method transfers longs from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 목적지 배열로 long을 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="1c71b94a511f607f31b7e517994edefcafb15346" translate="yes" xml:space="preserve">
          <source>This method transfers longs from this buffer into the given destination array. If there are fewer longs remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no longs are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는이 버퍼에서 지정된 목적지 배열로 long을 전송합니다. 버퍼에 남아있는 long이 요청을 충족시키는 데 필요한 것보다 적습니다. 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 long이 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="235f9f51f2e81977ac8385277f847cdacf4591f0" translate="yes" xml:space="preserve">
          <source>This method transfers longs into this buffer from the given source array. If there are more longs to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no longs are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 long을 전송합니다. 배열에서 복사 할 long이이 버퍼에 남아있는 것보다 &lt;code&gt;length&lt;/code&gt; 경우, 즉 length &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 long이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ae439e1e93a92a0c2298225fb8873abfbe47ad79" translate="yes" xml:space="preserve">
          <source>This method transfers shorts from this buffer into the given destination array. An invocation of this method of the form &lt;code&gt;src.get(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는,이 버퍼로부터 지정된 배열에 단락을 전송합니다. &lt;code&gt;src.get(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다</target>
        </trans-unit>
        <trans-unit id="9a5a04ef1fb09ba05b99dbc6155064d0adf4c685" translate="yes" xml:space="preserve">
          <source>This method transfers shorts from this buffer into the given destination array. If there are fewer shorts remaining in the buffer than are required to satisfy the request, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no shorts are transferred and a &lt;a href=&quot;bufferunderflowexception&quot;&gt;&lt;code&gt;BufferUnderflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는,이 버퍼로부터 지정된 배열에 단락을 전송합니다. 요청을 충족시키는 데 필요한 것보다 버퍼에 남아있는 쇼트가 적다면, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우 쇼트가 전송되지 않고 &lt;a href=&quot;bufferunderflowexception&quot;&gt; &lt;code&gt;BufferUnderflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3892f4cc3ee489fb57481ae2cea50a60d83c6a0c" translate="yes" xml:space="preserve">
          <source>This method transfers shorts into this buffer from the given source array. If there are more shorts to be copied from the array than remain in this buffer, that is, if &lt;code&gt;length&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no shorts are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 배열에서이 버퍼로 단락을 전송합니다. 이 버퍼에 남아있는 것보다 배열에서 복사 할 단락이 더 많은 경우, 즉 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우에는 단락이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62e29eda608a76b16972e15c68e2cf9b0d250160" translate="yes" xml:space="preserve">
          <source>This method transfers the bytes remaining in the given source buffer into this buffer. If there are more bytes remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no bytes are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 바이트를이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 바이트 수가 더 많은 경우, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우 바이트가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="67ba7be4645ff33297ca783caab7891d1960958c" translate="yes" xml:space="preserve">
          <source>This method transfers the chars remaining in the given source buffer into this buffer. If there are more chars remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no chars are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 문자를이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 문자가 더 많은 경우, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 인 경우 문자가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc8d7052596d61ae0c55b04ff32cece33816fa5f" translate="yes" xml:space="preserve">
          <source>This method transfers the doubles remaining in the given source buffer into this buffer. If there are more doubles remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no doubles are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 double을이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 double이 더 많으면, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 double이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ba7d656045cc2c93c5545bdae075a188982a5c6" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source byte array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 바이트 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1a8b2f59b1257b32202326e6a296a00c0a2c4831" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source char array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 char 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f85a7eb3902ecf44fe65e88d3415a7fb2c63d8be" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source double array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 double 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be0526012b1df9e6548573ee94cf3d148c55c57d" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source float array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 float 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="831c91291ae9f3040ba1e15151b6327beda90324" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source int array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 int 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bd2e143f258ecd0d927757c41d6b2d8027096e66" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source long array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 long 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c2efc54a18e7bd6cc6030ca162da5ee2a9086d4f" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source short array into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(a)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 지정된 소스 쇼트 배열의 전체 내용을이 버퍼에 전송합니다. &lt;code&gt;dst.put(a)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cf07eb60f080b3daa1fafadf1e62a320445dc073" translate="yes" xml:space="preserve">
          <source>This method transfers the entire content of the given source string into this buffer. An invocation of this method of the form &lt;code&gt;dst.put(s)&lt;/code&gt; behaves in exactly the same way as the invocation</source>
          <target state="translated">이 메소드는 주어진 소스 문자열의 전체 내용을이 버퍼로 전송합니다. &lt;code&gt;dst.put(s)&lt;/code&gt; 형식의이 메소드 호출은 호출과 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a7e8d2693c4c7919f019fc03e508dc0d5323f922" translate="yes" xml:space="preserve">
          <source>This method transfers the floats remaining in the given source buffer into this buffer. If there are more floats remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no floats are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 float를이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 float가 더 많은 경우, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 float가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74f84fb40f856ee9bcde48b317e90434d189c396" translate="yes" xml:space="preserve">
          <source>This method transfers the ints remaining in the given source buffer into this buffer. If there are more ints remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no ints are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 정수를이 버퍼에 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 정수가 더 많으면, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 정수가 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf156e58f7f2faea5e78527ce5d350c9f9b1e427" translate="yes" xml:space="preserve">
          <source>This method transfers the longs remaining in the given source buffer into this buffer. If there are more longs remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no longs are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 주어진 소스 버퍼에 남아있는 long을이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 더 긴 long이 남아있는 경우, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면 더 이상 long이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6275e6cdadf99dcd9699c2abf6e9c8f15ea87718" translate="yes" xml:space="preserve">
          <source>This method transfers the shorts remaining in the given source buffer into this buffer. If there are more shorts remaining in the source buffer than in this buffer, that is, if &lt;code&gt;src.remaining()&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;remaining()&lt;/code&gt;, then no shorts are transferred and a &lt;a href=&quot;bufferoverflowexception&quot;&gt;&lt;code&gt;BufferOverflowException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 메소드는 지정된 소스 버퍼에 남아있는 단락을이 버퍼로 전송합니다. 이 버퍼보다 ​​소스 버퍼에 남아있는 단락이 더 많은 경우, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;remaining()&lt;/code&gt; 이면, 단락이 전송 &lt;a href=&quot;bufferoverflowexception&quot;&gt; &lt;code&gt;BufferOverflowException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a4ee60b3895a6a487dacc74792ace15f9baee8c4" translate="yes" xml:space="preserve">
          <source>This method transforms the name of the given service class into a provider-configuration filename as described in the class comment and then uses the &lt;code&gt;getResources&lt;/code&gt; method of the given class loader to find all available files with that name. These files are then read and parsed to produce a list of provider-class names. The iterator that is returned uses the given class loader to look up and then instantiate each element of the list.</source>
          <target state="translated">이 메소드는 클래스 주석에 설명 된대로 지정된 서비스 클래스의 이름을 제공자 구성 파일 이름으로 변환 한 다음 제공된 클래스 로더 의 &lt;code&gt;getResources&lt;/code&gt; 메소드 를 사용하여 해당 이름을 가진 사용 가능한 모든 파일을 찾습니다. 그런 다음이 파일을 읽고 구문 분석하여 제공자 클래스 이름 목록을 생성합니다. 리턴 된 반복자는 주어진 클래스 로더를 사용하여 목록의 각 요소를 찾아 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="0e20f22914845cefe6c7ffc1b8c01c71a6ad302c" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new AlgorithmParameterGenerator object encapsulating the AlgorithmParameterGeneratorSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 최초의 프로 바이더로부터 AlgorithmParameterGeneratorSpi 구현을 캡슐화하는 새로운 AlgorithmParameterGenerator 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="861bf1ddb45b5f5a0f444b57fb796617403bff70" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new AlgorithmParameters object encapsulating the AlgorithmParametersSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 AlgorithmParametersSpi 구현을 캡슐화하는 새로운 AlgorithmParameters 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64d2235fe5c1102582764745f2a042a3742b5103" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new CertPathBuilder object encapsulating the CertPathBuilderSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 최초의 Provider로부터 CertPathBuilderSpi 구현을 캡슐화하는 새로운 CertPathBuilder 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="bb4e8caa4b0e5ae83ddf7619b6a4660f90e91651" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new CertPathValidator object encapsulating the CertPathValidatorSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 최초의 Provider로부터 CertPathValidatorSpi 구현을 캡슐화하는 새로운 CertPathValidator 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="70cdc12e5335367106038cfbcf17f66666510e89" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new CertStore object encapsulating the CertStoreSpi implementation from the first Provider that supports the specified type is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 형식을 지원하는 첫 번째 공급자의 CertStoreSpi 구현을 캡슐화하는 새로운 CertStore 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b035a3126fc179ccecea1573350ca6adb1eef540" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new CertificateFactory object encapsulating the CertificateFactorySpi implementation from the first Provider that supports the specified type is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 형식을 지원하는 첫 번째 공급자의 CertificateFactorySpi 구현을 캡슐화하는 새 CertificateFactory 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a4f8b9f224da98416657ddc681032df9ad7502" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Cipher object encapsulating the CipherSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 제공자의 CipherSpi 구현을 캡슐화하는 새 Cipher 오브젝트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="abc13eba8b4098f245111a4713ba335645f40638" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new ExemptionMechanism object encapsulating the ExemptionMechanismSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 ExemptionMechanismSpi 구현을 캡슐화하는 새로운 ExemptionMechanism 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac976f1ac6eae73943e67c6b13b9a978c32b598" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 제공자의 KeyAgreementSpi 구현을 캡슐화하는 새로운 KeyAgreement 오브젝트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="269faf6fc5a11a627d2c78ca4fa05ee8ddcff60b" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyFactory object encapsulating the KeyFactorySpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 KeyFactorySpi 구현을 캡슐화하는 새로운 KeyFactory 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9680c754a5982fcf19547802ad41f748f39d6c95" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyGenerator object encapsulating the KeyGeneratorSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 KeyGeneratorSpi 구현을 캡슐화하는 새로운 KeyGenerator 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="05a476b6f146e1e764724c3725cd2eddecf486e6" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyManagerFactory object encapsulating the KeyManagerFactorySpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 최초의 Provider로부터 KeyManagerFactorySpi 구현을 캡슐화하는 새로운 KeyManagerFactory 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="4e6ede446bcde0dd0d53e13cc1f70412538c6dfd" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyPairGenerator object encapsulating the KeyPairGeneratorSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 KeyPairGeneratorSpi 구현을 캡슐화하는 새로운 KeyPairGenerator 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1130ebd67c10415c74551edfb65dedc7e1429e91" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyStore object encapsulating the KeyStoreSpi implementation from the first Provider that supports the specified type is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 형식을 지원하는 첫 번째 공급자의 KeyStoreSpi 구현을 캡슐화하는 새로운 KeyStore 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="17e781ebbe3b6ae6b015bda00c96dc377e2b949a" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Mac object encapsulating the MacSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 MacSpi 구현을 캡슐화하는 새로운 Mac 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="87eb869d88b8269b9030d46317da4a090e82ef8a" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new MessageDigest object encapsulating the MessageDigestSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 MessageDigestSpi 구현을 캡슐화하는 새로운 MessageDigest 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dced037fdf454bc1808c04019b299b4b7ad46c4e" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new SSLContext object encapsulating the SSLContextSpi implementation from the first Provider that supports the specified protocol is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 프로토콜을 지원하는 첫 번째 제공자의 SSLContextSpi 구현을 캡슐화하는 새로운 SSLContext 오브젝트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2e2d4fb613416e23035530cb8e29bc024108eb" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new SecretKeyFactory object encapsulating the SecretKeyFactorySpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 최초의 Provider로부터 SecretKeyFactorySpi 구현을 캡슐화하는 새로운 SecretKeyFactory 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="a992e79992c091682f89e2161d9518c8dabb5067" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new SecureRandom object encapsulating the SecureRandomSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 제공자의 SecureRandomSpi 구현을 캡슐화하는 새로운 SecureRandom 오브젝트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="319ec56b8541176cc1565c9bd60099f7ab2ba15a" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Signature object encapsulating the SignatureSpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 공급자의 SignatureSpi 구현을 캡슐화하는 새로운 Signature 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="39cd453c6b8f21fce09148fa3a2085c191cadac4" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security Providers, starting with the most preferred Provider. A new TrustManagerFactory object encapsulating the TrustManagerFactorySpi implementation from the first Provider that supports the specified algorithm is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 알고리즘을 지원하는 첫 번째 제공자의 TrustManagerFactorySpi 구현을 캡슐화하는 새 TrustManagerFactory 오브젝트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="64547557e19cc6a474eb34baeea233207c4f9d00" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security providers, starting with the most preferred Provider. A new Configuration object encapsulating the ConfigurationSpi implementation from the first Provider that supports the specified type is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 형식을 지원하는 첫 번째 공급자의 ConfigurationSpi 구현을 캡슐화하는 새로운 Configuration 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b3f003fe3131053435b502ff056cd34745faa289" translate="yes" xml:space="preserve">
          <source>This method traverses the list of registered security providers, starting with the most preferred Provider. A new Policy object encapsulating the PolicySpi implementation from the first Provider that supports the specified type is returned.</source>
          <target state="translated">이 방법은 가장 선호되는 제공자로 시작하여 등록 된 보안 제공자 목록을 순회합니다. 지정된 유형을 지원하는 첫 번째 공급자의 PolicySpi 구현을 캡슐화하는 새 정책 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="330118e6c243a9fbc3db9baecbe25b03b457aab9" translate="yes" xml:space="preserve">
          <source>This method tries to read one character from the current substream. If it reaches the end of the stream, it calls the &lt;code&gt;close&lt;/code&gt; method of the current substream and begins reading from the next substream.</source>
          <target state="translated">이 메소드는 현재 서브 스트림에서 한 문자를 읽으려고합니다. 스트림의 끝에 도달하면 현재 서브 스트림 의 &lt;code&gt;close&lt;/code&gt; 메소드를 호출 하고 다음 서브 스트림에서 읽기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="10734c290b53c0effa88e0a90e362fce2b806c6d" translate="yes" xml:space="preserve">
          <source>This method typically does not modify the map in any way, instead allowing the map to modify itself as directed by its return value. It</source>
          <target state="translated">이 방법은 일반적으로지도를 어떤 식 으로든 수정하지 않고 대신 반환 값에 따라지도를 수정할 수 있습니다. 그것</target>
        </trans-unit>
        <trans-unit id="c068b17d7cd1a40020333c0031878fe78af5800e" translate="yes" xml:space="preserve">
          <source>This method updates the file's timestamp attributes. The values are converted to the epoch and precision supported by the file system. Converting from finer to coarser granularities result in precision loss. The behavior of this method when attempting to set a timestamp that is not supported or to a value that is outside the range supported by the underlying file store is not defined. It may or not fail by throwing an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">이 방법은 파일의 타임 스탬프 속성을 업데이트합니다. 값은 파일 시스템에서 지원하는 신기원과 정밀도로 변환됩니다. 더 미세한 입자를 더 세밀한 입자로 변환하면 정밀한 손실이 발생합니다. 지원되지 않는 타임 스탬프를 설정하거나 기본 파일 저장소에서 지원하는 범위를 벗어난 값으로 설정하려는 경우이 방법의 동작은 정의되지 않습니다. &lt;code&gt;IOException&lt;/code&gt; 을 발생시켜 실패하거나 실패하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca98706202417f601d9a75f9aab39ea80b754077" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;deflater#NO_FLUSH&quot;&gt;&lt;code&gt;NO_FLUSH&lt;/code&gt;&lt;/a&gt; as its compression flush mode. An invocation of this method of the form &lt;code&gt;deflater.deflate(b)&lt;/code&gt; yields the same result as the invocation of &lt;code&gt;deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH)&lt;/code&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;deflater#NO_FLUSH&quot;&gt; &lt;code&gt;NO_FLUSH&lt;/code&gt; &lt;/a&gt; 를 압축 플러시 모드로 사용 합니다. &lt;code&gt;deflater.deflate(b)&lt;/code&gt; 형식의이 메소드를 호출하면 &lt;code&gt;deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH)&lt;/code&gt; 호출과 동일한 결과가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="07ab2be0ecd985ea652ab80e0c9de591cb58c95b" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;deflater#NO_FLUSH&quot;&gt;&lt;code&gt;NO_FLUSH&lt;/code&gt;&lt;/a&gt; as its compression flush mode. An invocation of this method of the form &lt;code&gt;deflater.deflate(b, off, len)&lt;/code&gt; yields the same result as the invocation of &lt;code&gt;deflater.deflate(b, off, len, Deflater.NO_FLUSH)&lt;/code&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;deflater#NO_FLUSH&quot;&gt; &lt;code&gt;NO_FLUSH&lt;/code&gt; &lt;/a&gt; 를 압축 플러시 모드로 사용 합니다. &lt;code&gt;deflater.deflate(b, off, len)&lt;/code&gt; 형식의이 메소드를 호출하면 &lt;code&gt;deflater.deflate(b, off, len, Deflater.NO_FLUSH)&lt;/code&gt; 호출과 동일한 결과가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="38447029b3f80e6af72b910f78b202f9398ca5ec" translate="yes" xml:space="preserve">
          <source>This method uses the installed &lt;a href=&quot;spi/filetypedetector&quot;&gt;&lt;code&gt;FileTypeDetector&lt;/code&gt;&lt;/a&gt; implementations to probe the given file to determine its content type. Each file type detector's &lt;a href=&quot;spi/filetypedetector#probeContentType-java.nio.file.Path-&quot;&gt;&lt;code&gt;probeContentType&lt;/code&gt;&lt;/a&gt; is invoked, in turn, to probe the file type. If the file is recognized then the content type is returned. If the file is not recognized by any of the installed file type detectors then a system-default file type detector is invoked to guess the content type.</source>
          <target state="translated">이 메소드는 설치된 &lt;a href=&quot;spi/filetypedetector&quot;&gt; &lt;code&gt;FileTypeDetector&lt;/code&gt; &lt;/a&gt; 구현을 사용하여 지정된 파일을 검사하여 컨텐츠 유형을 판별합니다. 각 파일 유형 검출기의 &lt;a href=&quot;spi/filetypedetector#probeContentType-java.nio.file.Path-&quot;&gt; &lt;code&gt;probeContentType&lt;/code&gt; &lt;/a&gt; 이 차례로 호출되어 파일 유형을 프로브합니다. 파일이 인식되면 컨텐츠 유형이 리턴됩니다. 설치된 파일 유형 감지기에서 파일을 인식하지 못하면 컨텐츠 유형을 추측하기 위해 시스템 기본 파일 유형 감지기가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="898c65c53674ccde27230059a0d836d532ebb58e" translate="yes" xml:space="preserve">
          <source>This method uses the specified state factories in the &lt;code&gt;Context.STATE_FACTORIES&lt;/code&gt; property from the environment properties, and from the provider resource file associated with &lt;code&gt;nameCtx&lt;/code&gt;, in that order. The value of this property is a colon-separated list of factory class names that are tried in order, and the first one that succeeds in returning the object's state is the one used. If no object's state can be retrieved in this way, return the object itself. If an exception is encountered while retrieving the state, the exception is passed up to the caller.</source>
          <target state="translated">이 메소드는 환경 특성과 &lt;code&gt;nameCtx&lt;/code&gt; 와 연관된 제공자 자원 파일 의 &lt;code&gt;Context.STATE_FACTORIES&lt;/code&gt; 특성에서 지정된 상태 팩토리 를 순서대로 사용합니다. 이 속성의 값은 순서대로 시도 된 콜론으로 구분 된 팩토리 클래스 이름 목록이며, 객체의 상태를 반환하는 데 성공한 첫 번째는 사용 된 이름입니다. 이런 방식으로 객체 상태를 검색 할 수 없으면 객체 자체를 반환합니다. 상태를 검색하는 동안 예외가 발생하면 예외가 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8a84288afc4ef56ac95fa54ce28f59cc8758819e" translate="yes" xml:space="preserve">
          <source>This method walks a file tree rooted at a given starting file. The file tree traversal is &lt;em&gt;depth-first&lt;/em&gt; with the given &lt;a href=&quot;filevisitor&quot;&gt;&lt;code&gt;FileVisitor&lt;/code&gt;&lt;/a&gt; invoked for each file encountered. File tree traversal completes when all accessible files in the tree have been visited, or a visit method returns a result of &lt;a href=&quot;filevisitresult#TERMINATE&quot;&gt;&lt;code&gt;TERMINATE&lt;/code&gt;&lt;/a&gt;. Where a visit method terminates due an &lt;code&gt;IOException&lt;/code&gt;, an uncaught error, or runtime exception, then the traversal is terminated and the error or exception is propagated to the caller of this method.</source>
          <target state="translated">이 방법은 주어진 시작 파일에 기반을 둔 파일 트리를 안내합니다. 파일 트리 순회는 발생하는 각 파일에 대해 지정된 &lt;a href=&quot;filevisitor&quot;&gt; &lt;code&gt;FileVisitor&lt;/code&gt; 가&lt;/a&gt; 호출 된 상태에서 &lt;em&gt;깊이 우선&lt;/em&gt; 입니다 . 트리의 액세스 가능한 모든 파일을 방문했거나 방문 메소드가 &lt;a href=&quot;filevisitresult#TERMINATE&quot;&gt; &lt;code&gt;TERMINATE&lt;/code&gt; &lt;/a&gt; 결과를 리턴하면 파일 트리 순회가 완료됩니다 . &lt;code&gt;IOException&lt;/code&gt; , 포착되지 않은 오류 또는 런타임 예외 로 인해 방문 메소드가 종료 되면 순회가 종료되고 오류 또는 예외가이 메소드의 호출자에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="07587ec8793bc110ca2ed6b1a01f5862917816af" translate="yes" xml:space="preserve">
          <source>This method walks the file tree in exactly the manner specified by the &lt;a href=&quot;files#walk-java.nio.file.Path-int-java.nio.file.FileVisitOption...-&quot;&gt;&lt;code&gt;walk&lt;/code&gt;&lt;/a&gt; method. For each file encountered, the given &lt;a href=&quot;../../util/function/bipredicate&quot;&gt;&lt;code&gt;BiPredicate&lt;/code&gt;&lt;/a&gt; is invoked with its &lt;a href=&quot;path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;attribute/basicfileattributes&quot;&gt;&lt;code&gt;BasicFileAttributes&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;Path&lt;/code&gt; object is obtained as if by &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolving&lt;/code&gt;&lt;/a&gt; the relative path against &lt;code&gt;start&lt;/code&gt; and is only included in the returned &lt;a href=&quot;../../util/stream/stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; if the &lt;code&gt;BiPredicate&lt;/code&gt; returns true. Compare to calling &lt;a href=&quot;../../util/stream/stream#filter-java.util.function.Predicate-&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; on the &lt;code&gt;Stream&lt;/code&gt; returned by &lt;code&gt;walk&lt;/code&gt; method, this method may be more efficient by avoiding redundant retrieval of the &lt;code&gt;BasicFileAttributes&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;files#walk-java.nio.file.Path-int-java.nio.file.FileVisitOption...-&quot;&gt; &lt;code&gt;walk&lt;/code&gt; &lt;/a&gt; 메소드에 의해 지정된 방식으로 파일 트리를 걷습니다 . 발견 된 각 파일에 대해 주어진 &lt;a href=&quot;../../util/function/bipredicate&quot;&gt; &lt;code&gt;BiPredicate&lt;/code&gt; &lt;/a&gt; 가 해당 &lt;a href=&quot;path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;attribute/basicfileattributes&quot;&gt; &lt;code&gt;BasicFileAttributes&lt;/code&gt; 로&lt;/a&gt; 호출됩니다 . &lt;code&gt;Path&lt;/code&gt; 객체에 의해 것처럼 얻어 &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolving&lt;/code&gt; &lt;/a&gt; 에 대한 상대 경로 &lt;code&gt;start&lt;/code&gt; 만 반환에 포함되어 &lt;a href=&quot;../../util/stream/stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;BiPredicate&lt;/code&gt; 가 true를 반환합니다. &lt;code&gt;walk&lt;/code&gt; 메소드에 의해 리턴 된 &lt;code&gt;Stream&lt;/code&gt; 에서 &lt;a href=&quot;../../util/stream/stream#filter-java.util.function.Predicate-&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것과 비교 하여이 메소드는 &lt;code&gt;BasicFileAttributes&lt;/code&gt; 의 중복 검색을 피함으로써 더 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c96cbac1ce71994c1502c052604dbfd689d21d9" translate="yes" xml:space="preserve">
          <source>This method was added to version 1.4 of the Java 2 Platform Standard Edition. In order to maintain backwards compatibility with existing service providers, this method cannot be &lt;code&gt;abstract&lt;/code&gt; and by default throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 방법은 Java 2 Platform Standard Edition 버전 1.4에 추가되었습니다. 기존 서비스 제공 업체와의 호환성을 유지하기 위해이 메소드는 &lt;code&gt;abstract&lt;/code&gt; 수 없으며 기본적으로 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="646647deb0c95e19113854f668991dfe58a46511" translate="yes" xml:space="preserve">
          <source>This method was added to version 1.4 of the Java 2 Platform Standard Edition. In order to maintain backwards compatibility with existing service providers, this method is not &lt;code&gt;abstract&lt;/code&gt; and it provides a default implementation. Subclasses should override this method with a correct implementation.</source>
          <target state="translated">이 방법은 Java 2 Platform Standard Edition 버전 1.4에 추가되었습니다. 기존 서비스 제공 업체와의 호환성을 유지하기 위해이 방법은 &lt;code&gt;abstract&lt;/code&gt; 이지 않으며 기본 구현을 제공합니다. 서브 클래스는 올바른 구현으로이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dcffec8464f4cfecef5fdd4f8360fb78fb1fd0d" translate="yes" xml:space="preserve">
          <source>This method was added to version 1.8 of the Java Platform Standard Edition. In order to maintain backwards compatibility with existing service providers, this method cannot be &lt;code&gt;abstract&lt;/code&gt; and by default throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 Java Platform Standard Edition 버전 1.8에 추가되었습니다. 기존 서비스 제공 업체와의 호환성을 유지하기 위해이 메소드는 &lt;code&gt;abstract&lt;/code&gt; 수 없으며 기본적으로 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e22ad565b9276d2c64dd81c7c016357cbdd9bd58" translate="yes" xml:space="preserve">
          <source>This method was added to version 1.8 of the Java Platform Standard Edition. In order to maintain backwards compatibility with existing service providers, this method cannot be abstract and by default throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 Java Platform Standard Edition 버전 1.8에 추가되었습니다. 기존 서비스 제공 업체와의 호환성을 유지하기 위해이 메소드는 추상적 일 수 없으며 기본적으로 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="342c773ec2e87fc177a5aa9af9b63a84e94c590d" translate="yes" xml:space="preserve">
          <source>This method will allow trusted subclasses of ObjectInputStream to substitute one object for another during deserialization. Replacing objects is disabled until enableResolveObject is called. The enableResolveObject method checks that the stream requesting to resolve object can be trusted. Every reference to serializable objects is passed to resolveObject. To insure that the private state of objects is not unintentionally exposed only trusted streams may use resolveObject.</source>
          <target state="translated">이 메소드를 사용하면 직렬화 해제 중에 ObjectInputStream의 신뢰할 수있는 서브 클래스가 한 오브젝트를 다른 오브젝트로 대체 할 수 있습니다. enableResolveObject가 호출 될 때까지 객체 교체가 비활성화됩니다. enableResolveObject 메서드는 객체 확인 요청 스트림을 신뢰할 수 있는지 확인합니다. 직렬화 가능 객체에 대한 모든 참조는 resolveObject로 전달됩니다. 객체의 개인 상태가 실수로 노출되지 않도록하려면 신뢰할 수있는 스트림 만 resolveObject를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19a1ca10d56e8668efe2fb611286d49ab3dd4578" translate="yes" xml:space="preserve">
          <source>This method will allow trusted subclasses of ObjectOutputStream to substitute one object for another during serialization. Replacing objects is disabled until enableReplaceObject is called. The enableReplaceObject method checks that the stream requesting to do replacement can be trusted. The first occurrence of each object written into the serialization stream is passed to replaceObject. Subsequent references to the object are replaced by the object returned by the original call to replaceObject. To ensure that the private state of objects is not unintentionally exposed, only trusted streams may use replaceObject.</source>
          <target state="translated">이 메소드를 사용하면 직렬화 중에 ObjectOutputStream의 신뢰할 수있는 서브 클래스가 한 오브젝트를 다른 오브젝트로 대체 할 수 있습니다. enableReplaceObject가 호출 될 때까지 객체 교체가 비활성화됩니다. enableReplaceObject 메소드는 교체를 요청하는 스트림을 신뢰할 수 있는지 확인합니다. 직렬화 스트림에 기록 된 각 객체의 첫 번째 항목은 replaceObject로 전달됩니다. 객체에 대한 후속 참조는 replaceObject에 대한 원래 호출로 반환 된 객체로 대체됩니다. 객체의 개인 상태가 실수로 노출되지 않도록하려면 신뢰할 수있는 스트림 만 replaceObject를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c27c2f10702143a6756e5dbce224fb2f266b502" translate="yes" xml:space="preserve">
          <source>This method will always read an integral number of frames. If &lt;code&gt;len&lt;/code&gt; does not specify an integral number of frames, a maximum of &lt;code&gt;len - (len % frameSize)
 &lt;/code&gt; bytes will be read.</source>
          <target state="translated">이 방법은 항상 정수의 프레임을 읽습니다. 경우 &lt;code&gt;len&lt;/code&gt; 프레임의 정수, 최대 지정하지 않습니다 &lt;code&gt;len - (len % frameSize) &lt;/code&gt; 바이트를 읽어됩니다.</target>
        </trans-unit>
        <trans-unit id="a869932e634c911cd9144a80eb52838c63564e87" translate="yes" xml:space="preserve">
          <source>This method will always read an integral number of frames. If the length of the array is not an integral number of frames, a maximum of &lt;code&gt;b.length - (b.length % frameSize)
 &lt;/code&gt; bytes will be read.</source>
          <target state="translated">이 방법은 항상 정수의 프레임을 읽습니다. 배열의 길이가 정수 프레임 수가 아닌 경우 최대 &lt;code&gt;b.length - (b.length % frameSize) &lt;/code&gt; 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9b30e52019d3213e3c2609683448a29ced2c0233" translate="yes" xml:space="preserve">
          <source>This method will attempt to consume one complete SSL/TLS network packet, but will never consume more than the sum of the bytes remaining in the buffers. Each &lt;code&gt;ByteBuffer&lt;/code&gt;'s position is updated to reflect the amount of data consumed or produced. The limits remain the same.</source>
          <target state="translated">이 방법은 하나의 완전한 SSL / TLS 네트워크 패킷을 사용하려고 시도하지만 버퍼에 남아있는 바이트의 합을 초과하여 사용하지는 않습니다. 각 &lt;code&gt;ByteBuffer&lt;/code&gt; 의 위치는 소비되거나 생성되는 데이터의 양을 반영하여 업데이트됩니다. 한계는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e28d69322e01ed6ceb66bdee0acbea95ff6bbbce" translate="yes" xml:space="preserve">
          <source>This method will attempt to produce SSL/TLS records, and will consume as much source data as possible, but will never consume more than the sum of the bytes remaining in each buffer. Each &lt;code&gt;ByteBuffer&lt;/code&gt;'s position is updated to reflect the amount of data consumed or produced. The limits remain the same.</source>
          <target state="translated">이 방법은 SSL / TLS 레코드를 생성하려고 시도하고 가능한 한 많은 소스 데이터를 소비하지만 각 버퍼에 남아있는 바이트의 합보다 더 많이 소비하지는 않습니다. 각 &lt;code&gt;ByteBuffer&lt;/code&gt; 의 위치는 소비되거나 생성되는 데이터의 양을 반영하여 업데이트됩니다. 한계는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8f918371c98671b9620e0549e5bc6fc24ae0e167" translate="yes" xml:space="preserve">
          <source>This method will be invoked within the first thread that accesses the value with the &lt;a href=&quot;classvalue#get-java.lang.Class-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;classvalue#get-java.lang.Class-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드로 값에 액세스하는 첫 번째 스레드 내에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="22454f54424ac0425295bb1b7c4c0c7b02e19e6d" translate="yes" xml:space="preserve">
          <source>This method will cause subsequent invocations of &lt;a href=&quot;printstream#checkError--&quot;&gt;&lt;code&gt;checkError()&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;false&lt;/code&gt; until another write operation fails and invokes &lt;a href=&quot;printstream#setError--&quot;&gt;&lt;code&gt;setError()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 다른 쓰기 조작이 실패하고 &lt;a href=&quot;printstream#setError--&quot;&gt; &lt;code&gt;setError()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 &lt;a href=&quot;printstream#checkError--&quot;&gt; &lt;code&gt;checkError()&lt;/code&gt; &lt;/a&gt; 의 후속 호출이 &lt;code&gt;false&lt;/code&gt; 를 리턴하게 합니다 .</target>
        </trans-unit>
        <trans-unit id="0f3fe52cec4ed5c62b654ad2e7e08c4f49989342" translate="yes" xml:space="preserve">
          <source>This method will cause subsequent invocations of &lt;a href=&quot;printstream#checkError--&quot;&gt;&lt;code&gt;checkError()&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;true&lt;/code&gt; until &lt;a href=&quot;printstream#clearError--&quot;&gt;&lt;code&gt;clearError()&lt;/code&gt;&lt;/a&gt; is invoked.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;printstream#checkError--&quot;&gt; &lt;code&gt;checkError()&lt;/code&gt; &lt;/a&gt; 의 후속 호출이 &lt;a href=&quot;printstream#clearError--&quot;&gt; &lt;code&gt;clearError()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때까지 &lt;code&gt;true&lt;/code&gt; 를 리턴하게 합니다 .</target>
        </trans-unit>
        <trans-unit id="b48d9418c05d19aff8ec8631b1debfac763c87cf" translate="yes" xml:space="preserve">
          <source>This method will cause subsequent invocations of &lt;a href=&quot;printwriter#checkError--&quot;&gt;&lt;code&gt;checkError()&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;false&lt;/code&gt; until another write operation fails and invokes &lt;a href=&quot;printwriter#setError--&quot;&gt;&lt;code&gt;setError()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 다른 쓰기 조작이 실패하고 &lt;a href=&quot;printwriter#setError--&quot;&gt; &lt;code&gt;setError()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 &lt;a href=&quot;printwriter#checkError--&quot;&gt; &lt;code&gt;checkError()&lt;/code&gt; &lt;/a&gt; 의 후속 호출이 &lt;code&gt;false&lt;/code&gt; 를 리턴하게 합니다 .</target>
        </trans-unit>
        <trans-unit id="47f729f00024e35a9de98e956d4deb97fb2c191c" translate="yes" xml:space="preserve">
          <source>This method will cause subsequent invocations of &lt;a href=&quot;printwriter#checkError--&quot;&gt;&lt;code&gt;checkError()&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;true&lt;/code&gt; until &lt;a href=&quot;printwriter#clearError--&quot;&gt;&lt;code&gt;clearError()&lt;/code&gt;&lt;/a&gt; is invoked.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;printwriter#checkError--&quot;&gt; &lt;code&gt;checkError()&lt;/code&gt; &lt;/a&gt; 의 후속 호출이 &lt;a href=&quot;printwriter#clearError--&quot;&gt; &lt;code&gt;clearError()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때까지 &lt;code&gt;true&lt;/code&gt; 를 리턴하게 합니다 .</target>
        </trans-unit>
        <trans-unit id="d4f3ee30d84b2eec94c2f48c2e18ba63a39e2104" translate="yes" xml:space="preserve">
          <source>This method will continue to return the set of options even after the channel has been closed.</source>
          <target state="translated">이 방법은 채널이 닫힌 후에도 옵션 세트를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55bcb28f3b35747462d71e2c7fb1036108c5c393" translate="yes" xml:space="preserve">
          <source>This method will create a formatter based on a simple &lt;a href=&quot;#patterns&quot;&gt;pattern of letters and symbols&lt;/a&gt; as described in the class documentation. For example, &lt;code&gt;d MMM uuuu&lt;/code&gt; will format 2011-12-03 as '3 Dec 2011'.</source>
          <target state="translated">이 메소드는 클래스 문서에 설명 된대로 간단한 &lt;a href=&quot;#patterns&quot;&gt;문자 및 기호 패턴을&lt;/a&gt; 기반으로 포맷터를 작성합니다 . 예를 들어, &lt;code&gt;d MMM uuuu&lt;/code&gt; 는 2011-12-03의 형식을 '2011 년 12 월 3 일'로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="370c438905ce1a92b71c0ea98edd24464fd0bb80" translate="yes" xml:space="preserve">
          <source>This method will first search the parent class loader for the resource; if the parent is &lt;code&gt;null&lt;/code&gt; the path of the class loader built-in to the virtual machine is searched. That failing, this method will invoke &lt;a href=&quot;classloader#findResource-java.lang.String-&quot;&gt;&lt;code&gt;findResource(String)&lt;/code&gt;&lt;/a&gt; to find the resource.</source>
          <target state="translated">이 메소드는 먼저 상위 클래스 로더에서 자원을 검색합니다. 부모가 &lt;code&gt;null&lt;/code&gt; 인 경우, 가상 머신에 내장 된 클래스 로더의 경로가 검색됩니다. 실패하면,이 메소드는 &lt;a href=&quot;classloader#findResource-java.lang.String-&quot;&gt; &lt;code&gt;findResource(String)&lt;/code&gt; &lt;/a&gt; 를 호출 하여 자원을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e22bc5b12358cd9ed2b2e4b4eda7b2f13e5a5fcf" translate="yes" xml:space="preserve">
          <source>This method will initiate the initial handshake if necessary and then block until the handshake has been established.</source>
          <target state="translated">이 방법은 필요한 경우 초기 핸드 셰이크를 시작한 다음 핸드 셰이크가 설정 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="2b6fb4cec5310ed7b8799c65e0e6a81271c9aae4" translate="yes" xml:space="preserve">
          <source>This method will modify &lt;code&gt;environment&lt;/code&gt; and save a reference to it. The caller may no longer modify it.</source>
          <target state="translated">이 방법은 &lt;code&gt;environment&lt;/code&gt; 을 수정 하고 이에 대한 참조를 저장합니다. 발신자가 더 이상 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7b2abdca9a7c0af8a5c125ae4c9b4ef88001f88" translate="yes" xml:space="preserve">
          <source>This method will not cause a connection to be initiated. If the connection was not connected, or if the server did not have an error while connecting or if the server had an error but no error data was sent, this method will return null. This is the default.</source>
          <target state="translated">이 방법으로 연결이 시작되지는 않습니다. 연결이 연결되지 않았거나 연결하는 동안 서버에 오류가 없거나 서버에 오류가 있지만 오류 데이터가 전송되지 않은 경우이 메소드는 널을 리턴합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9e7f49dd9f508918d6801e6f7eb970e438d414c6" translate="yes" xml:space="preserve">
          <source>This method will return -1 in the following three cases:</source>
          <target state="translated">이 메소드는 다음 세 가지 경우에 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="edcfcea6d04841d9ed0bb5de222b4eb4d98438dc" translate="yes" xml:space="preserve">
          <source>This method will return &lt;code&gt;null&lt;/code&gt; if this thread is not blocked waiting for any object or if the object is not owned by any thread.</source>
          <target state="translated">이 메소드는 이 스레드가 객체를 기다리는 동안 차단되지 않았거나 객체가 스레드에 의해 소유되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="997d1e3c558fa4f7ecd051b0c70ae4a27ce69f5b" translate="yes" xml:space="preserve">
          <source>This method will return &lt;code&gt;null&lt;/code&gt; in the following three cases:</source>
          <target state="translated">이 메서드는 다음 세 가지 경우에 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="81c178e68a361bc411f4196a67d165e4297f65b0" translate="yes" xml:space="preserve">
          <source>This method will return a result whether or not the chronology supports the field.</source>
          <target state="translated">이 메소드는 연대기가 필드를 지원하는지 여부에 대한 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf72858f6d5ab0f6806f6ba29dc39dac2862dcd4" translate="yes" xml:space="preserve">
          <source>This method will return an instance of the first implementation class that it is able to load and instantiate successfully from the list of class names collected from the configuration files. This method uses the calling thread's context classloader to find the configuration files and to load the implementation class.</source>
          <target state="translated">이 메소드는 구성 파일에서 수집 한 클래스 이름 목록에서로드하고 인스턴스화 할 수있는 첫 번째 구현 클래스의 인스턴스를 리턴합니다. 이 메소드는 호출 스레드의 컨텍스트 클래스 로더를 사용하여 구성 파일을 찾고 구현 클래스를로드합니다.</target>
        </trans-unit>
        <trans-unit id="a22fb6cb28a1c2ffe0e2c125002bf45c2ce42483" translate="yes" xml:space="preserve">
          <source>This method works as if by invoking the two-argument &lt;a href=&quot;pattern#split-java.lang.CharSequence-int-&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method with the given input sequence and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array.</source>
          <target state="translated">이 메소드 는 주어진 입력 시퀀스와 한계 인수가 0 인 두 인수 &lt;a href=&quot;pattern#split-java.lang.CharSequence-int-&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼 작동 합니다. 따라서 후행 빈 문자열은 결과 배열에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb6cb3b94903416fb88ff0f1bfde615391fee91" translate="yes" xml:space="preserve">
          <source>This method works as if by invoking the two-argument &lt;a href=&quot;string#split-java.lang.String-int-&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array.</source>
          <target state="translated">이 메소드 는 주어진 표현식과 한계 인수가 0 인 두 인수 &lt;a href=&quot;string#split-java.lang.String-int-&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼 작동 합니다. 따라서 후행 빈 문자열은 결과 배열에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b98c5be79fe3631e10feeff93134f4ae1b95df3" translate="yes" xml:space="preserve">
          <source>This method works as if invoking it were equivalent to evaluating the expression:</source>
          <target state="translated">이 메소드는 호출하는 것이 표현식을 평가하는 것과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7454290376119065d709322b3967277568221e6a" translate="yes" xml:space="preserve">
          <source>This method works by invoking the &lt;a href=&quot;charsetdecoder#decodeLoop-java.nio.ByteBuffer-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;decodeLoop&lt;/code&gt;&lt;/a&gt; method, interpreting its results, handling error conditions, and reinvoking it as necessary.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetdecoder#decodeLoop-java.nio.ByteBuffer-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;decodeLoop&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하고 결과를 해석하고 오류 조건을 처리 한 후 필요에 따라 다시 호출하여 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a2868d5c75c3ba78e01fe4c6fd94f3e0f922600f" translate="yes" xml:space="preserve">
          <source>This method works by invoking the &lt;a href=&quot;charsetencoder#encodeLoop-java.nio.CharBuffer-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;encodeLoop&lt;/code&gt;&lt;/a&gt; method, interpreting its results, handling error conditions, and reinvoking it as necessary.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;charsetencoder#encodeLoop-java.nio.CharBuffer-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;encodeLoop&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하고 결과를 해석하고 오류 조건을 처리 한 후 필요에 따라 다시 호출하여 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="37a8d53b4f6a1321f049b1ed691bbc3e4062f584" translate="yes" xml:space="preserve">
          <source>This method works in a similar manner to &lt;a href=&quot;files#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; method when the &lt;a href=&quot;standardcopyoption#ATOMIC_MOVE&quot;&gt;&lt;code&gt;ATOMIC_MOVE&lt;/code&gt;&lt;/a&gt; option is specified. That is, this method moves a file as an atomic file system operation. If the &lt;code&gt;srcpath&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then it locates the source file. If the parameter is a relative path then it is located relative to this open directory. If the &lt;code&gt;targetpath&lt;/code&gt; parameter is absolute then it locates the target file (the &lt;code&gt;targetdir&lt;/code&gt; parameter is ignored). If the parameter is a relative path it is located relative to the open directory identified by the &lt;code&gt;targetdir&lt;/code&gt; parameter. In all cases, if the target file exists then it is implementation specific if it is replaced or this method fails.</source>
          <target state="translated">이 방법은 유사한 방식으로 작동하는 &lt;a href=&quot;files#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt; 때 방법을 &lt;a href=&quot;standardcopyoption#ATOMIC_MOVE&quot;&gt; &lt;code&gt;ATOMIC_MOVE&lt;/code&gt; 의&lt;/a&gt; 옵션을 지정합니다. 즉,이 방법은 파일을 원자 파일 시스템 조작으로 이동시킵니다. 경우] &lt;code&gt;srcpath&lt;/code&gt; 의 파라미터가있다 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 그때는 소스 파일을 찾아서. 매개 변수가 상대 경로이면이 열린 디렉토리에 상대적으로 위치합니다. 경우] &lt;code&gt;targetpath&lt;/code&gt; 파라미터 절대 다음 대상 파일을 찾으면된다합니다 ( &lt;code&gt;targetdir&lt;/code&gt; 파라미터는 무시된다). 매개 변수가 상대 경로 인 경우 &lt;code&gt;targetdir&lt;/code&gt; 에 의해 식별 된 열린 디렉토리에 상대적으로 위치합니다.매개 변수. 모든 경우에, 대상 파일이 존재하는 경우, 대체되거나이 메소드가 실패하면 구현 고유의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="6582bf91ac2daba1bab0f7e3e1f2b7ae6e47e42e" translate="yes" xml:space="preserve">
          <source>This method works in exactly the manner specified by &lt;a href=&quot;files#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createTempDirectory(Path,String,FileAttribute[])&lt;/code&gt;&lt;/a&gt; method for the case that the &lt;code&gt;dir&lt;/code&gt; parameter is the temporary-file directory.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;dir&lt;/code&gt; 매개 변수가 임시 파일 디렉토리 인 경우 &lt;a href=&quot;files#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createTempDirectory(Path,String,FileAttribute[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 지정된 방식으로 정확하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="cfb8b1f167ebd230d3d00c4cbc7ac7f5b4a612c2" translate="yes" xml:space="preserve">
          <source>This method works in exactly the manner specified by the &lt;a href=&quot;files#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createTempFile(Path,String,String,FileAttribute[])&lt;/code&gt;&lt;/a&gt; method for the case that the &lt;code&gt;dir&lt;/code&gt; parameter is the temporary-file directory.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;dir&lt;/code&gt; 매개 변수가 임시 파일 디렉토리 인 경우 &lt;a href=&quot;files#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createTempFile(Path,String,String,FileAttribute[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 지정된 방식으로 정확하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="1ea541f8c42c220b9d86951a4fa49aad31c612a1" translate="yes" xml:space="preserve">
          <source>This method works in exactly the manner specified by the &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;Files.newByteChannel&lt;/code&gt;&lt;/a&gt; method for the case that the &lt;code&gt;path&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path. When the parameter is a relative path then the file to open or create is relative to this open directory. In addition to the options defined by the &lt;code&gt;Files.newByteChannel&lt;/code&gt; method, the &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option may be used to ensure that this method fails if the file is a symbolic link.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;path&lt;/code&gt; 매개 변수가 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 인 경우 &lt;a href=&quot;files#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;Files.newByteChannel&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 방식으로 정확하게 작동 합니다. 매개 변수가 상대 경로 인 경우 열거 나 작성할 파일은이 열린 디렉토리에 상대적입니다. &lt;code&gt;Files.newByteChannel&lt;/code&gt; 메소드에 의해 정의 된 옵션 외에 , 파일이 기호 링크 인 경우 &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여이 메소드가 실패하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f83f0d9238b18b32a0d1cb59bc36f251647ecf6" translate="yes" xml:space="preserve">
          <source>This method works in exactly the manner specified by the &lt;a href=&quot;files#newDirectoryStream-java.nio.file.Path-&quot;&gt;&lt;code&gt;newDirectoryStream&lt;/code&gt;&lt;/a&gt; method for the case that the &lt;code&gt;path&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path. When the parameter is a relative path then the directory to open is relative to this open directory. The &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option may be used to ensure that this method fails if the file is a symbolic link.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;path&lt;/code&gt; 매개 변수가 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로 인 경우 &lt;a href=&quot;files#newDirectoryStream-java.nio.file.Path-&quot;&gt; &lt;code&gt;newDirectoryStream&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 방식으로 정확하게 작동 합니다. 매개 변수가 상대 경로 인 경우 열려는 디렉토리는이 열려있는 디렉토리에 상대적입니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 파일이 심볼릭 링크의 경우이 방법이 실패 할 수 있도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="418ab9ef88ce864f3d7a73b1fc1d345d0f0046f2" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;AsynchronousByteChannel.read(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method, except that bytes are read starting at the given file position. If the given file position is greater than the file's size at the time that the read is attempted then no bytes are read.</source>
          <target state="translated">이 메소드 는 지정된 파일 위치에서 시작하여 바이트를 읽는다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;AsynchronousByteChannel.read(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동 합니다. 지정된 파일 위치가 읽기를 시도 할 때 파일 크기보다 크면 바이트를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2136f114f7d0bd16461ba147740ed385feec2a2a" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method, except that bytes are read starting at the given file position. If the given file position is greater than the file's size at the time that the read is attempted then no bytes are read.</source>
          <target state="translated">이 메소드 는 지정된 파일 위치에서 바이트를 읽는다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동 합니다. 지정된 파일 위치가 읽기를 시도 할 때 파일 크기보다 크면 바이트를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e2548085e2dbea138a9ac8061c89ac77484eb8c" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;AsynchronousByteChannel.write(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method, except that bytes are written starting at the given file position. If the given position is greater than the file's size, at the time that the write is attempted, then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.</source>
          <target state="translated">이 메소드는 바이트가 주어진 파일 위치에서 시작하여 작성된다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;AsynchronousByteChannel.write(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동 합니다. 주어진 위치가 파일의 크기보다 큰 경우, 쓰기가 시도 될 때 파일은 새로운 바이트를 수용하도록 확장됩니다. 이전 파일 끝과 새로 작성된 바이트 사이의 바이트 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdb689127866a66bd7f98916fdf141ecf0832dab" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler)&lt;/code&gt;&lt;/a&gt; method, except that bytes are written starting at the given file position. If the given position is greater than the file's size, at the time that the write is attempted, then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.</source>
          <target state="translated">이 메소드는 바이트가 지정된 파일 위치에서 시작하여 작성된다는 점을 제외하고 &lt;a href=&quot;asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동 합니다. 주어진 위치가 파일의 크기보다 큰 경우, 쓰기가 시도 될 때 파일은 새로운 바이트를 수용하도록 확장됩니다. 이전 파일 끝과 새로 쓴 바이트 사이의 바이트 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9219a92c97d7960e93769f3d0f297e4fdcf261dd" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;filechannel#read-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;read(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method, except that bytes are read starting at the given file position rather than at the channel's current position. This method does not modify this channel's position. If the given position is greater than the file's current size then no bytes are read.</source>
          <target state="translated">이 메소드 는 채널의 현재 위치가 아닌 지정된 파일 위치에서 시작하여 바이트를 읽는다는 점을 제외하고 &lt;a href=&quot;filechannel#read-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;read(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동합니다 . 이 방법은이 채널의 위치를 ​​수정하지 않습니다. 주어진 위치가 파일의 현재 크기보다 크면 바이트를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee607bed83b2db68d329cfe1f02aaaec99d3d49f" translate="yes" xml:space="preserve">
          <source>This method works in the same manner as the &lt;a href=&quot;filechannel#write-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method, except that bytes are written starting at the given file position rather than at the channel's current position. This method does not modify this channel's position. If the given position is greater than the file's current size then the file will be grown to accommodate the new bytes; the values of any bytes between the previous end-of-file and the newly-written bytes are unspecified.</source>
          <target state="translated">이 메소드는 바이트가 채널의 현재 위치가 아닌 지정된 파일 위치에서 시작한다는 점을 제외하고 &lt;a href=&quot;filechannel#write-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write(ByteBuffer)&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 작동합니다 . 이 방법은이 채널의 위치를 ​​수정하지 않습니다. 주어진 위치가 파일의 현재 크기보다 크면 파일은 새로운 바이트를 수용하도록 확장됩니다. 이전 파일 끝과 새로 작성된 바이트 사이의 바이트 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bbf2c6adcc9220204f66129d37a79f36955e554" translate="yes" xml:space="preserve">
          <source>This method writes out the preamble associated with the XML encoding if it has not been written already and then writes out all of the values that been written to the stream since the last time &lt;code&gt;flush&lt;/code&gt; was called. After flushing, all internal references to the values that were written to this stream are cleared.</source>
          <target state="translated">이 메소드는 XML 인코딩과 연관된 프리앰블을 아직 기록하지 않은 경우 기록한 다음 마지막 &lt;code&gt;flush&lt;/code&gt; 가 호출 된 이후 스트림에 기록 된 모든 값을 기록합니다 . 플러시 후이 스트림에 기록 된 값에 대한 모든 내부 참조가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="94823e0e57cb0baf233d121072c13efb2a18234f" translate="yes" xml:space="preserve">
          <source>This method writes the value of the attribute from a given buffer as a sequence of bytes. The size of the value to transfer is &lt;code&gt;r&lt;/code&gt;, where &lt;code&gt;r&lt;/code&gt; is the number of bytes remaining in the buffer, that is &lt;code&gt;src.remaining()&lt;/code&gt;. The sequence of bytes is transferred from the buffer starting at index &lt;code&gt;p&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is the buffer's position. Upon return, the buffer's position will be equal to &lt;code&gt;p + n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bytes transferred; its limit will not have changed.</source>
          <target state="translated">이 메소드는 주어진 버퍼에서 속성 값을 바이트 시퀀스로 기록합니다. 전송할 값의 크기는 &lt;code&gt;r&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;r&lt;/code&gt; 은 버퍼에 남아있는 바이트 수, 즉 &lt;code&gt;src.remaining()&lt;/code&gt; 입니다. 바이트 순서는 인덱스 &lt;code&gt;p&lt;/code&gt; 에서 시작하여 버퍼에서 전송됩니다. 여기서 &lt;code&gt;p&lt;/code&gt; 는 버퍼의 위치입니다. 돌아 왔을 때, 버퍼의 위치는 &lt;code&gt;p + n&lt;/code&gt; 과 같습니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 전송 된 바이트 수입니다. 한도는 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="38d65d304e01b25e0003846872bfad7b7661d75f" translate="yes" xml:space="preserve">
          <source>This method, which is specified in the &lt;a href=&quot;abstractinterruptiblechannel&quot;&gt;&lt;code&gt;AbstractInterruptibleChannel&lt;/code&gt;&lt;/a&gt; class and is invoked by the &lt;a href=&quot;../channel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method, in turn invokes the &lt;a href=&quot;abstractselectablechannel#implCloseSelectableChannel--&quot;&gt;&lt;code&gt;implCloseSelectableChannel&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of closing this channel. It then cancels all of this channel's keys.</source>
          <target state="translated">&lt;a href=&quot;abstractinterruptiblechannel&quot;&gt; &lt;code&gt;AbstractInterruptibleChannel&lt;/code&gt; &lt;/a&gt; 클래스에 지정되고 &lt;a href=&quot;../channel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출되는이 메소드는이 채널을 닫는 실제 작업을 수행하기 위해 &lt;a href=&quot;abstractselectablechannel#implCloseSelectableChannel--&quot;&gt; &lt;code&gt;implCloseSelectableChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 . 그런 다음이 채널의 모든 키를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="af2efb0256661192d4849878e10c0e265dec4210" translate="yes" xml:space="preserve">
          <source>This method, which simply returns this &lt;code&gt;BigDecimal&lt;/code&gt; is included for symmetry with the unary minus method &lt;a href=&quot;bigdecimal#negate--&quot;&gt;&lt;code&gt;negate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;BigDecimal&lt;/code&gt; 을 리턴하는이 메소드 는 단항 빼기 메소드 &lt;a href=&quot;bigdecimal#negate--&quot;&gt; &lt;code&gt;negate()&lt;/code&gt; &lt;/a&gt; 와의 대칭에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9378f1ab56e018a71aa81af9bef43ae951ea75f" translate="yes" xml:space="preserve">
          <source>This might be confusing for the code calling &lt;code&gt;createMBean()&lt;/code&gt; or &lt;code&gt;registerMBean()&lt;/code&gt;, as such code might assume that MBean registration has failed when such an exception is raised. Therefore it is recommended that implementations of &lt;code&gt;postRegister&lt;/code&gt; do not throw Runtime Exceptions or Errors if it can be avoided.</source>
          <target state="translated">&lt;code&gt;createMBean()&lt;/code&gt; 또는 &lt;code&gt;registerMBean()&lt;/code&gt; 호출하는 코드에서는 혼동 될 수 있습니다. 이러한 코드는 예외가 발생할 때 MBean 등록이 실패했다고 가정 할 수 있습니다. 따라서 &lt;code&gt;postRegister&lt;/code&gt; 구현을 피할 수있는 경우 런타임 예외 또는 오류가 발생하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d54e9cf4654f9242161858e0d36bcf06ab7a33d3" translate="yes" xml:space="preserve">
          <source>This might be confusing for the code calling &lt;code&gt;unregisterMBean()&lt;/code&gt;, as it might assume that MBean deregistration has failed. Therefore it is recommended that implementations of &lt;code&gt;postDeregister&lt;/code&gt; do not throw Runtime Exceptions or Errors if it can be avoided.</source>
          <target state="translated">MBean 등록 해제가 실패했다고 가정 할 수 있으므로 &lt;code&gt;unregisterMBean()&lt;/code&gt; 호출하는 코드에서는 혼동 될 수 있습니다 . 따라서 &lt;code&gt;postDeregister&lt;/code&gt; 의 구현은 피할 수있는 경우 런타임 예외 또는 오류를 발생시키지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="336b1605ee24a5053590abde120e729abeca1ace" translate="yes" xml:space="preserve">
          <source>This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.]</source>
          <target state="translated">이것은 더 나은 것은 아니지만 동등하게 보일지 모르지만 실제로는 부동 소수점 숫자의 반올림으로 인해 큰 불균일성이 발생했습니다. 유효성의 하위 비트가 0 일 가능성의 3 배 그것보다 1이 될 것입니다! 이 불균일성은 실제로는 그다지 중요하지 않지만 완벽을 위해 노력합니다.]</target>
        </trans-unit>
        <trans-unit id="e8c8d7884f9527b04b2c04f8b6fb7fcd86eae98c" translate="yes" xml:space="preserve">
          <source>This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.]</source>
          <target state="translated">이것은 더 나은 것은 아니지만 동등한 것으로 보이지만 실제로는 부동 소수점 숫자의 반올림으로 인해 약간의 불균일이 발생했습니다. 유효성의 하위 비트가 0보다 약간 더 높았습니다. 1이 될 것입니다.]</target>
        </trans-unit>
        <trans-unit id="28ec2481fd35a60681fb797a739b051f340bf847" translate="yes" xml:space="preserve">
          <source>This month-day will be passed to the formatter to produce a string.</source>
          <target state="translated">이 달은 문자열을 생성하기 위해 포맷터로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a69b212000ba0a1bd05ed46b95cd13dc75a4427d" translate="yes" xml:space="preserve">
          <source>This must be a positive integer that identifies the particular interface and scope as understood by the system. Usually, the numeric values can be determined through administration tools on the system. Each interface may have multiple values, one for each scope. If the scope is unspecified, then the default value used is zero.</source>
          <target state="translated">시스템이 이해하는 특정 인터페이스 및 범위를 식별하는 양의 정수 여야합니다. 일반적으로 숫자 값은 시스템의 관리 도구를 통해 결정될 수 있습니다. 각 인터페이스에는 범위마다 하나씩 여러 값이있을 수 있습니다. 범위가 지정되지 않은 경우 사용되는 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="04f19103171bb230328568d99520d154dd3e52e4" translate="yes" xml:space="preserve">
          <source>This must be implemented by subclasses of Permission, as they are the only ones that can impose semantics on a Permission object.</source>
          <target state="translated">이것은 Permission 객체에 의미를 부여 할 수있는 유일한 클래스이므로 Permission의 서브 클래스에 의해 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="438254d585668962ffe1d950b1670de89316768b" translate="yes" xml:space="preserve">
          <source>This must be the exact string that is returned by &lt;a href=&quot;networkinterface#getName--&quot;&gt;&lt;code&gt;NetworkInterface.getName()&lt;/code&gt;&lt;/a&gt; for the particular interface in question. When an Inet6Address is created in this way, the numeric scope-id is determined at the time the object is created by querying the relevant NetworkInterface.</source>
          <target state="translated">이것은 특정 인터페이스에 대해 &lt;a href=&quot;networkinterface#getName--&quot;&gt; &lt;code&gt;NetworkInterface.getName()&lt;/code&gt; &lt;/a&gt; 에 의해 리턴되는 정확한 문자열이어야합니다 . 이 방법으로 Inet6Address를 만들면 관련 NetworkInterface를 쿼리하여 개체를 만들 때 숫자 scope-id가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c449e6fc67060b977c87bc7eba4910e405eb7032" translate="yes" xml:space="preserve">
          <source>This new pseudorandom-number generator is used thereafter for all calls to this method and is used nowhere else.</source>
          <target state="translated">이 새로운 의사 난수 생성기는 이후이 메소드에 대한 모든 호출에 사용되며 다른 곳에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c02ee81fb9b238ae20c25f183eaf2e6e0d91401" translate="yes" xml:space="preserve">
          <source>This normalizes the years and months units, leaving the days unit unchanged. The months unit is adjusted to have an absolute value less than 11, with the years unit being adjusted to compensate. For example, a period of &quot;1 Year and 15 months&quot; will be normalized to &quot;2 years and 3 months&quot;.</source>
          <target state="translated">이것은 년과 월 단위를 정규화하고 일 단위는 변경하지 않습니다. 월 단위는 11 미만의 절대 값을 갖도록 조정되며 년 단위는 보정하도록 조정됩니다. 예를 들어 &quot;1 년 15 개월&quot;기간은 &quot;2 년 3 개월&quot;로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d59fc415d1ea0a63c23130c4d50721f8e3b046" translate="yes" xml:space="preserve">
          <source>This notification will be emitted when the memory usage of a memory pool is greater than or equal to its &lt;a href=&quot;memorypoolmxbean#CollectionThreshold&quot;&gt; collection usage threshold&lt;/a&gt; after the Java virtual machine has expended effort in recycling unused objects in that memory pool.</source>
          <target state="translated">Java 가상 머신이 해당 메모리 풀에서 사용하지 않는 오브젝트를 재활용하는 데 노력을 기울인 후 메모리 풀의 메모리 사용량이 &lt;a href=&quot;memorypoolmxbean#CollectionThreshold&quot;&gt;콜렉션 사용량 임계 값&lt;/a&gt; 이상인 경우이 알림 이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="0a57b8162b18d42e492dc1dc2b4b075556527f18" translate="yes" xml:space="preserve">
          <source>This notification will be emitted when the memory usage of a memory pool is increased and has reached or exceeded its &lt;a href=&quot;memorypoolmxbean#UsageThreshold&quot;&gt; usage threshold&lt;/a&gt; value. Subsequent crossing of the usage threshold value does not cause further notification until the memory usage has returned to become less than the usage threshold value.</source>
          <target state="translated">이 알림은 메모리 풀의 메모리 사용량이 증가하고 &lt;a href=&quot;memorypoolmxbean#UsageThreshold&quot;&gt;사용량 임계&lt;/a&gt; 값에 도달하거나 초과하면 발생 합니다 . 이후에 사용 임계 값을 초과해도 메모리 사용이 사용 임계 값보다 작아 질 때까지 추가 알림이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c75f46fd5b5682704648d10104cd4d35072f008" translate="yes" xml:space="preserve">
          <source>This number of documents attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 문서 수 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d414da6ffde7bce6ec2a682cea696a1fb21152b" translate="yes" xml:space="preserve">
          <source>This number of intervening jobs attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 개입 작업 수 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="c975ed78d38b34ff292997aa770e8afc80f98970" translate="yes" xml:space="preserve">
          <source>This number up attribute's value and &lt;code&gt;object&lt;/code&gt;'s value are equal.</source>
          <target state="translated">이 숫자 업 속성 값과 &lt;code&gt;object&lt;/code&gt; 값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a0218e7fb4f50bb8de50aed21bfb52b65a7709c" translate="yes" xml:space="preserve">
          <source>This number up supported attribute's members and &lt;code&gt;object&lt;/code&gt;'s members are the same.</source>
          <target state="translated">이 지원되는 속성의 멤버와 &lt;code&gt;object&lt;/code&gt; 의 멤버는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4a66f64fd858be9aa293ec75d8e49a1a263eb7cc" translate="yes" xml:space="preserve">
          <source>This object</source>
          <target state="translated">이 개체</target>
        </trans-unit>
        <trans-unit id="c525a27749e67173595a6249d7ff51a90d7e9905" translate="yes" xml:space="preserve">
          <source>This object (which is already a string!) is itself returned.</source>
          <target state="translated">이 객체 (이미 문자열 임)가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9adb36ceb763ae4a292da81dcfe8ce0f5a409ec0" translate="yes" xml:space="preserve">
          <source>This object needs to know the Relation Service expected to handle the relation. So it has to know the MBean Server where the Relation Service is registered.</source>
          <target state="translated">이 개체는 관계를 처리 할 것으로 예상되는 관계 서비스를 알아야합니다. 따라서 관계 서비스가 등록 된 MBean 서버를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="bc9b220ed374a130f3e4dc2725ea527f11bdc81b" translate="yes" xml:space="preserve">
          <source>This object's protocol (getLocation().getProtocol()) must be equal to</source>
          <target state="translated">이 객체의 프로토콜 (getLocation (). getProtocol ())은</target>
        </trans-unit>
        <trans-unit id="81ae2fb150449b6c9b6803ea3c391efc06fd6a91" translate="yes" xml:space="preserve">
          <source>This object.</source>
          <target state="translated">이 객체.</target>
        </trans-unit>
        <trans-unit id="8238c12bc966286f9ebaf86a9a53378f498dd187" translate="yes" xml:space="preserve">
          <source>This obtains a chronology based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;Chronology&lt;/code&gt;.</source>
          <target state="translated">지정된 시간에 따라 연대기를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;Chronology&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287698e1a835eb0ac9ae3bbfadc46d1e5e7f050f" translate="yes" xml:space="preserve">
          <source>This obtains a date in the Hijrah calendar system based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;HijrahDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 Hijrah 일정 시스템에서 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;HijrahDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0d38e5c4260a892ffe699a9892b9fbf69b62aa72" translate="yes" xml:space="preserve">
          <source>This obtains a date in the Japanese calendar system based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;JapaneseDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 일본어 달력 시스템에서 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;JapaneseDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="cf55c9ddc36374789f950113e62c9eba93629679" translate="yes" xml:space="preserve">
          <source>This obtains a date in the Minguo calendar system based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;MinguoDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 Minguo 일정 시스템에서 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;MinguoDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="211270c5c60d8302e3c4e1e0bd5f3db31a768790" translate="yes" xml:space="preserve">
          <source>This obtains a date in the Thai Buddhist calendar system based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ThaiBuddhistDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 태국 불교 달력 시스템의 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ThaiBuddhistDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d63d938408c738d7497bbdbd8bc18bbb2d57c1f5" translate="yes" xml:space="preserve">
          <source>This obtains a date in this chronology based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ChronoLocalDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로이 연대기의 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3cb73ff77f8180b5f5b71cdaa26c8a4b69324bb8" translate="yes" xml:space="preserve">
          <source>This obtains a date-time in this chronology based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ChronoLocalDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로이 연대기의 날짜-시간을 가져옵니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1a841677746e1dcbc730487e0f048036907a65a1" translate="yes" xml:space="preserve">
          <source>This obtains a day-of-week based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;DayOfWeek&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 요일을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 나타내는 변환 &lt;code&gt;DayOfWeek&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f59ecd54b7544d299a158b780196d483fc88b4" translate="yes" xml:space="preserve">
          <source>This obtains a duration based on the specified amount. A &lt;code&gt;TemporalAmount&lt;/code&gt; represents an amount of time, which may be date-based or time-based, which this factory extracts to a duration.</source>
          <target state="translated">지정된 양을 기준으로 지속 시간을 얻습니다. &lt;code&gt;TemporalAmount&lt;/code&gt; 는 이 공장은 추출 시간에 날짜 기반 또는 시간 기반이 될 수 있습니다 시간의 양을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="744b9378dcec8913127823d474e8ab2211625767" translate="yes" xml:space="preserve">
          <source>This obtains a local date based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ChronoLocalDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 현지 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f336f4d854c716810eee21b19d13c14e911a1473" translate="yes" xml:space="preserve">
          <source>This obtains a local date based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 현지 날짜를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;LocalDate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b66ecc75e8f7fb3d4ee7fb3204291e7480a804e" translate="yes" xml:space="preserve">
          <source>This obtains a local date-time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ChronoLocalDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 현지 날짜-시간을 가져옵니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8a06a7013d88b4e8e0ba5da28075494a3d12c153" translate="yes" xml:space="preserve">
          <source>This obtains a local date-time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;LocalDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 현지 날짜-시간을 가져옵니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;LocalDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="bd21b3dab9e6c5958fa6db61b3447f15b5516c16" translate="yes" xml:space="preserve">
          <source>This obtains a local time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 현지 시간을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타내는 &lt;code&gt;LocalTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99522942282d6b253092e37f4f95749ad2309ce9" translate="yes" xml:space="preserve">
          <source>This obtains a month based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;Month&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 한 달을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타내는 &lt;code&gt;Month&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f62737fb99090237f99074647deead6b4e72d895" translate="yes" xml:space="preserve">
          <source>This obtains a month-day based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;MonthDay&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 월-일을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;MonthDay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8dab7d66d9f1c3b1052ec6fb3c9a7c1f94bd0e7" translate="yes" xml:space="preserve">
          <source>This obtains a period based on the specified amount. A &lt;code&gt;TemporalAmount&lt;/code&gt; represents an amount of time, which may be date-based or time-based, which this factory extracts to a &lt;code&gt;Period&lt;/code&gt;.</source>
          <target state="translated">지정된 금액을 기준으로 기간을 얻습니다. &lt;code&gt;TemporalAmount&lt;/code&gt; 는 이 공장은 추출에 날짜 기반 또는 시간 기반이 될 수 있습니다 시간의 양을 나타냅니다 &lt;code&gt;Period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af136aeb8710a7cab98d15314af7155f9049974e" translate="yes" xml:space="preserve">
          <source>This obtains a year based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;Year&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 1 년을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 날짜 및 시간 정보의 임의 설정이 공장은 회심 나타냅니다 &lt;code&gt;Year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4602bacf9db201bfce8a2960e9c5a1d68b35484" translate="yes" xml:space="preserve">
          <source>This obtains a year-month based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;YearMonth&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 년-월을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;YearMonth&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1be70af6e55545e4996b776e4c19c92b5e98b2e" translate="yes" xml:space="preserve">
          <source>This obtains a zone based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ZoneId&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 영역을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ZoneId&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="66d6f9e59ee5fd63456b513e62cd5ebe0d27dcfa" translate="yes" xml:space="preserve">
          <source>This obtains a zoned date-time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ZonedDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 존 날짜 / 시간을 가져옵니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ZonedDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="60f62815954ffb88291022f1cc7ddef5506ebc32" translate="yes" xml:space="preserve">
          <source>This obtains a zoned date-time in this chronology based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ChronoZonedDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로이 연대기에서 존 날짜-시간을 가져옵니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f20480c0d583422f46a90cbbc88cff541678fc22" translate="yes" xml:space="preserve">
          <source>This obtains a zoned date-time with the same instant as that specified.</source>
          <target state="translated">이렇게하면 지정된 것과 동일한 순간으로 영역 날짜-시간이 구해집니다.</target>
        </trans-unit>
        <trans-unit id="205f71d656832530060d655129d875de55c0cc08" translate="yes" xml:space="preserve">
          <source>This obtains an instant based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;Instant&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 인스턴트를 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 날짜 및 시간 정보의 임의 설정이 공장은 회심 나타냅니다 &lt;code&gt;Instant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2337d76b69b0fa771af86c983aae860198618d7f" translate="yes" xml:space="preserve">
          <source>This obtains an offset based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 오프셋을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;ZoneOffset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f561b2a8cee1aa3fac6ee47687865aac724a0c00" translate="yes" xml:space="preserve">
          <source>This obtains an offset date-time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;OffsetDateTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 오프셋 날짜-시간을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;OffsetDateTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ae864b2577bfba144fe827f11ed48cdd9cf7b02e" translate="yes" xml:space="preserve">
          <source>This obtains an offset time based on the specified temporal. A &lt;code&gt;TemporalAccessor&lt;/code&gt; represents an arbitrary set of date and time information, which this factory converts to an instance of &lt;code&gt;OffsetTime&lt;/code&gt;.</source>
          <target state="translated">지정된 시간을 기준으로 오프셋 시간을 얻습니다. &lt;code&gt;TemporalAccessor&lt;/code&gt; 는 인스턴스에 대한 날짜 및 시간 정보의 임의의 집합이 공장 변환 나타낸다 &lt;code&gt;OffsetTime&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="39507a10969bf4a3fcc0e594bfbac392ee408041" translate="yes" xml:space="preserve">
          <source>This obtains the IDs that this &lt;code&gt;ZoneRulesProvider&lt;/code&gt; provides. A provider should provide data for at least one zone ID.</source>
          <target state="translated">이것은이 &lt;code&gt;ZoneRulesProvider&lt;/code&gt; 가 제공 하는 ID를 얻습니다 . 공급자는 하나 이상의 영역 ID에 대한 데이터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="726b2168462e543038ab100b82593b7827fdac8b" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding one hour will always be a duration of one hour later. This may cause the local date-time to change by an amount other than one hour. Note that this is a different approach to that used by days, months and years, thus adding one day is not the same as adding 24 hours.</source>
          <target state="translated">이는 즉시 타임 라인에서 작동하므로 1 시간을 추가하면 항상 1 시간 후에 지속됩니다. 이로 인해 현지 날짜-시간이 1 시간 이외의 양만큼 변경 될 수 있습니다. 이는 일, 월 및 년에 사용되는 방식과 다른 방식이므로 하루를 추가하는 것은 24 시간을 추가하는 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="449d8d28ba022862276b2c7e5af0f20294264586" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding one minute will always be a duration of one minute later. This may cause the local date-time to change by an amount other than one minute. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이는 즉시 타임 라인에서 작동하므로 1 분을 추가하면 항상 1 분 후에 지속됩니다. 이로 인해 현지 날짜-시간이 1 분이 아닌 양만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0c40b8e389146e2efe2832e92eb788736be1dd53" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding one nano will always be a duration of one nano later. This may cause the local date-time to change by an amount other than one nano. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이것은 즉시 타임 라인에서 작동하므로 하나의 나노를 추가하는 것은 항상 1 나노의 지속 시간이 될 것입니다. 이로 인해 현지 날짜 시간이 1 나노 이외의 양만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c4cd8c7a66c2ff78bac947e7da499aba9a3cfabc" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding one second will always be a duration of one second later. This may cause the local date-time to change by an amount other than one second. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이는 즉시 타임 라인에서 작동하므로 1 초를 추가하면 항상 1 초 후에 지속됩니다. 이로 인해 현지 날짜-시간이 1 초 이외의 시간만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8094300af297e6ec99960bb5cacb5d9690ac223c" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that subtracting one hour will always be a duration of one hour earlier. This may cause the local date-time to change by an amount other than one hour. Note that this is a different approach to that used by days, months and years, thus subtracting one day is not the same as adding 24 hours.</source>
          <target state="translated">이것은 즉시 타임 라인에서 작동하므로 1 시간을 빼는 것이 항상 1 시간 일찍 지속됩니다. 이로 인해 현지 날짜-시간이 1 시간 이외의 양만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다른 방식이므로 하루를 빼는 것은 24 시간을 더하는 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="10f01b9e77cb1e1c8db208e9714286d57b4421be" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that subtracting one minute will always be a duration of one minute earlier. This may cause the local date-time to change by an amount other than one minute. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이것은 순간 타임 라인에서 작동하므로 1 분을 빼는 것이 항상 1 분 일찍 지속됩니다. 이로 인해 현지 날짜-시간이 1 분이 아닌 양만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d62d67baa570ea1b5107178e38aa8d3f9a718ceb" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that subtracting one nano will always be a duration of one nano earlier. This may cause the local date-time to change by an amount other than one nano. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이것은 순간 타임 라인에서 작동하므로 1 나노를 빼는 것이 항상 1 나노 빨리 지속됩니다. 이로 인해 현지 날짜 시간이 1 나노 이외의 양만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="34d507fb2b9c644d312a6f37599ff469c6b10fef" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that subtracting one second will always be a duration of one second earlier. This may cause the local date-time to change by an amount other than one second. Note that this is a different approach to that used by days, months and years.</source>
          <target state="translated">이것은 순간 타임 라인에서 작동하므로 1 초를 빼는 것이 항상 1 초 일찍 지속됩니다. 이로 인해 현지 날짜-시간이 1 초 이외의 시간만큼 변경 될 수 있습니다. 이 방법은 일, 월 및 년에 사용되는 방식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="66b8dc37ce4c05d1efd10e8876dfc44c6e707b67" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#minusDays-long-&quot;&gt;&lt;code&gt;subtracting days&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간으로 &lt;a href=&quot;localdatetime#minusDays-long-&quot;&gt; &lt;code&gt;subtracting days&lt;/code&gt; &lt;/a&gt; 을 뺍니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca4c248820f44b41c189bfb723340d212343290a" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#minusMonths-long-&quot;&gt;&lt;code&gt;subtracting months&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동하여 &lt;a href=&quot;localdatetime#minusMonths-long-&quot;&gt; &lt;code&gt;subtracting months&lt;/code&gt; &lt;/a&gt; 을 현지 날짜-시간으로 뺍니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="65883238bc7ce4bedf1473ad433bb1914555ab68" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#minusWeeks-long-&quot;&gt;&lt;code&gt;subtracting weeks&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하며 현지 날짜-시간으로 &lt;a href=&quot;localdatetime#minusWeeks-long-&quot;&gt; &lt;code&gt;subtracting weeks&lt;/code&gt; &lt;/a&gt; 를 뺍니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="51d89fe7d5a43be02048737835733e66860321ee" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#minusYears-long-&quot;&gt;&lt;code&gt;subtracting years&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동하여 &lt;a href=&quot;localdatetime#minusYears-long-&quot;&gt; &lt;code&gt;subtracting years&lt;/code&gt; &lt;/a&gt; 을 현지 날짜-시간으로 뺍니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6cc088b6807de06b101c0bc63dc04a4384f4af58" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;adding days&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이는 현지 타임 라인에서 작동 하여 현지 날짜-시간에 날짜를 &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;adding days&lt;/code&gt; &lt;/a&gt; 합니다. 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="20c98d62bce69123ea5d2767637fa5f450b0c087" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#plusMonths-long-&quot;&gt;&lt;code&gt;adding months&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간에 &lt;a href=&quot;localdatetime#plusMonths-long-&quot;&gt; &lt;code&gt;adding months&lt;/code&gt; &lt;/a&gt; 을 추가 합니다. 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="154b94da779e6c9cca22e9bc1b3bd4a89ae143b7" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#plusWeeks-long-&quot;&gt;&lt;code&gt;adding weeks&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하며 현지 날짜-시간에 &lt;a href=&quot;localdatetime#plusWeeks-long-&quot;&gt; &lt;code&gt;adding weeks&lt;/code&gt; &lt;/a&gt; 를 추가 합니다. 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="45fe7be19a0012d0ba56803bcbf31c9663206351" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#plusYears-long-&quot;&gt;&lt;code&gt;adding years&lt;/code&gt;&lt;/a&gt; to the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간에 &lt;a href=&quot;localdatetime#plusYears-long-&quot;&gt; &lt;code&gt;adding years&lt;/code&gt; &lt;/a&gt; 를 추가 합니다. 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="59068d62d04b8a462fc519bbf7cef54ddca45f64" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#truncatedTo-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;truncating&lt;/code&gt;&lt;/a&gt; the underlying local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">로컬 타임 라인에서 작동 하여 기본 로컬 날짜-시간을 &lt;a href=&quot;localdatetime#truncatedTo-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;truncating&lt;/code&gt; &lt;/a&gt; . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2353d120e6f9cf824344af701e898fe4d833a945" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withDayOfMonth-int-&quot;&gt;&lt;code&gt;changing the day-of-month&lt;/code&gt;&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간의 &lt;a href=&quot;localdatetime#withDayOfMonth-int-&quot;&gt; &lt;code&gt;changing the day-of-month&lt;/code&gt; &lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="26526dbba6c58095452f330104b3a779b3c7deeb" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withDayOfYear-int-&quot;&gt;&lt;code&gt;changing the day-of-year&lt;/code&gt;&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은, 로컬 타임 라인에서 작동 &lt;a href=&quot;localdatetime#withDayOfYear-int-&quot;&gt; &lt;code&gt;changing the day-of-year&lt;/code&gt; &lt;/a&gt; 의 날짜 - 시간을. 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b24c9a53236448d5cfe67d31c6294336296d5fb2" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withHour-int-&quot;&gt;changing the time&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간 &lt;a href=&quot;localdatetime#withHour-int-&quot;&gt;의 시간&lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7bddee3f8c089c5dcdead4c23d773a93ab0a5335" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withMinute-int-&quot;&gt;changing the time&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간 &lt;a href=&quot;localdatetime#withMinute-int-&quot;&gt;의 시간&lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c784867c4312cbfaf1befb2ef2959e681ad4f6bb" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withMonth-int-&quot;&gt;&lt;code&gt;changing the month&lt;/code&gt;&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하며 현지 날짜-시간 &lt;a href=&quot;localdatetime#withMonth-int-&quot;&gt; &lt;code&gt;changing the month&lt;/code&gt; &lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="670e4fcf509e7f294939494905091949b46f4dfa" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withNano-int-&quot;&gt;changing the time&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간 &lt;a href=&quot;localdatetime#withNano-int-&quot;&gt;의 시간&lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c44437b58ea1355b204a4983f39255944580cb3" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withSecond-int-&quot;&gt;changing the time&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하여 현지 날짜-시간 &lt;a href=&quot;localdatetime#withSecond-int-&quot;&gt;의 시간&lt;/a&gt; 을 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="932e29e07a81cf46bd3252bcfbdcbbcefe33c300" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, &lt;a href=&quot;localdatetime#withYear-int-&quot;&gt;&lt;code&gt;changing the year&lt;/code&gt;&lt;/a&gt; of the local date-time. This is then converted back to a &lt;code&gt;ZonedDateTime&lt;/code&gt;, using the zone ID to obtain the offset.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동 하며 현지 날짜-시간 &lt;a href=&quot;localdatetime#withYear-int-&quot;&gt; &lt;code&gt;changing the year&lt;/code&gt; &lt;/a&gt; 를 변경합니다 . 그런 다음 오프셋을 얻기 위해 영역 ID를 사용하여 &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3931784f6c0e8b591248f49ca648b15f7331490" translate="yes" xml:space="preserve">
          <source>This operates separately on the years, months and days. No normalization is performed.</source>
          <target state="translated">이것은 년, 월 및 일에 개별적으로 작동합니다. 정규화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="625602f5cdf633de6c29c8bfb0d06f91051c7694" translate="yes" xml:space="preserve">
          <source>This operation can only succeed for files of a type which can be parsed by an installed file reader. It may fail with an InvalidMidiDataException even for valid files if no compatible file reader is installed. It will also fail with an InvalidMidiDataException if a compatible file reader is installed, but encounters errors while constructing the &lt;code&gt;Sequence&lt;/code&gt; object from the file data.</source>
          <target state="translated">이 작업은 설치된 파일 판독기에서 구문 분석 할 수있는 유형의 파일에 대해서만 성공할 수 있습니다. 호환 가능한 파일 리더가 설치되어 있지 않으면 유효한 파일의 경우에도 InvalidMidiDataException으로 실패 할 수 있습니다. 호환되는 파일 판독기가 설치된 경우 파일 데이터에서 &lt;code&gt;Sequence&lt;/code&gt; 객체 를 구성하는 동안 오류가 발생하면 InvalidMidiDataException과 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="c4d7f1e9d4a54ab542f03bcd4ed5e2326793f267" translate="yes" xml:space="preserve">
          <source>This operation can only succeed for files of a type which can be parsed by an installed file reader. It may fail with an InvalidMidiDataException even for valid files if no compatible file reader is installed. It will also fail with an InvalidMidiDataException if a compatible file reader is installed, but encounters errors while determining the file format.</source>
          <target state="translated">이 작업은 설치된 파일 판독기에서 구문 분석 할 수있는 유형의 파일에 대해서만 성공할 수 있습니다. 호환 가능한 파일 리더가 설치되어 있지 않으면 유효한 파일의 경우에도 InvalidMidiDataException으로 실패 할 수 있습니다. 호환 가능한 파일 리더가 설치되어 있지만 파일 형식을 결정하는 동안 오류가 발생하면 InvalidMidiDataException과 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d54588074a1e11ae361882bd83f1aaf57821015a" translate="yes" xml:space="preserve">
          <source>This operation does not reverse any calls that have already started on an old target value. (Java supports &lt;a href=&quot;../object#wait--&quot;&gt;forward time travel&lt;/a&gt; only.)</source>
          <target state="translated">이 작업은 이전 대상 값에서 이미 시작된 호출을 되 돌리지 않습니다. (자바는 &lt;a href=&quot;../object#wait--&quot;&gt;순방향 여행&lt;/a&gt; 만 지원합니다 .)</target>
        </trans-unit>
        <trans-unit id="ca395761d99f0b08de70ba0393d88e99153be428" translate="yes" xml:space="preserve">
          <source>This operation is likely to be expensive and should be used sparingly. If possible, it should be buffered for batch processing on sets of call sites.</source>
          <target state="translated">이 작업은 비용이 많이 들며 드물게 사용해야합니다. 가능하면 일련의 호출 사이트에서 일괄 처리를 위해 버퍼링해야합니다.</target>
        </trans-unit>
        <trans-unit id="02be43302caaff86fda5dec97c8ad5be7c15d0bd" translate="yes" xml:space="preserve">
          <source>This operation is likely to be expensive and should be used sparingly. If possible, it should be buffered for batch processing on sets of switch points.</source>
          <target state="translated">이 작업은 비용이 많이 들며 드물게 사용해야합니다. 가능하면 스위치 포인트 세트에서 일괄 처리를 위해 버퍼링해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a524ee340747c59b0f3db2184034b2ce40ed0ab" translate="yes" xml:space="preserve">
          <source>This operation is not supported</source>
          <target state="translated">이 작업은 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="40db6c6ece4e6e62d9f67621684a40a8a8b14bd7" translate="yes" xml:space="preserve">
          <source>This operation is often useful when constructing a document containing URIs that must be made relative to the base URI of the document wherever possible. For example, relativizing the URI</source>
          <target state="translated">이 작업은 가능한 경우 문서의 기본 URI와 관련하여 작성해야하는 URI를 포함하는 문서를 구성 할 때 종종 유용합니다. 예를 들어 URI 재배치</target>
        </trans-unit>
        <trans-unit id="0243326f9ee0e4f8f83e0164b36c8f99b7f61d86" translate="yes" xml:space="preserve">
          <source>This operation is unsupported since this class is immutable. If this call would change a mutable descriptor with the same contents, then a &lt;a href=&quot;runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../java/lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; is thrown. Otherwise, the behavior is the same as it would be for a mutable descriptor: either an exception is thrown because of illegal parameters, or there is no effect.</source>
          <target state="translated">이 클래스는 변경할 수 없으므로이 작업은 지원되지 않습니다. 이 호출이 동일한 내용으로 변경 가능한 설명자를 변경 하면 &lt;a href=&quot;../../java/lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을&lt;/a&gt; 랩핑하는 &lt;a href=&quot;runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그렇지 않으면, 동작은 변경 가능한 설명자에서와 동일합니다. 잘못된 매개 변수로 인해 예외가 발생하거나 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2eaf656a5ffc82c4c6faa7253ed6faf3f17eac63" translate="yes" xml:space="preserve">
          <source>This operation processes the elements one at a time, in encounter order if one exists. Performing the action for one element &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses.</source>
          <target state="translated">이 작업은 요소가있는 경우 발생 순서대로 한 번에 하나씩 요소를 처리합니다. 한 요소에 대한 조치 수행은 후속 요소에 대한 조치를 수행 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;하기 전에 발생&lt;/i&gt;&lt;/a&gt; 하지만 주어진 요소에 대해 라이브러리가 선택한 스레드에서 조치를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f19d262e3403282ac8f6dcc22ee150db5930978" translate="yes" xml:space="preserve">
          <source>This option &lt;b&gt;must&lt;/b&gt; be specified in the constructor.</source>
          <target state="translated">이 옵션 &lt;b&gt;은&lt;/b&gt; 생성자에서 지정 &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6d32536e467e28e80c04c9eb713697cc4116f77e" translate="yes" xml:space="preserve">
          <source>This option enables or disables local loopback of multicast datagrams. This option is enabled by default for Multicast Sockets.</source>
          <target state="translated">이 옵션은 멀티 캐스트 데이터 그램의 로컬 루프백을 활성화 또는 비활성화합니다. 이 옵션은 멀티 캐스트 소켓에 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ed25d6258a5b644c3c2d337a3649a2b109a7441" translate="yes" xml:space="preserve">
          <source>This option sets the type-of-service or traffic class field in the IP header for a TCP or UDP socket.</source>
          <target state="translated">이 옵션은 TCP 또는 UDP 소켓의 IP 헤더에서 서비스 유형 또는 트래픽 클래스 필드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="29d701dac4b5f5387fd788367c0ae036eefdd7c7" translate="yes" xml:space="preserve">
          <source>This optional attribute specifies a list of one or more parameters for the MBean to be instantiated. This list describes the parameters to be passed the MBean's constructor. Use the following syntax to specify each item in &lt;var&gt;arglist&lt;/var&gt;:</source>
          <target state="translated">이 선택적 속성은 인스턴스화 할 MBean에 대한 하나 이상의 매개 변수 목록을 지정합니다. 이 목록은 MBean의 생성자에 전달 될 매개 변수를 설명합니다. 다음 구문을 사용하여 &lt;var&gt;arglist&lt;/var&gt; 에서 각 항목을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="217df13fc7d9dc7e8aba7c53c26dbed2086caa9b" translate="yes" xml:space="preserve">
          <source>This optional attribute specifies the code base URL of the MBean to be obtained. It identifies the directory that contains the &lt;code&gt;.jar&lt;/code&gt; files specified by the &lt;code&gt;ARCHIVE&lt;/code&gt; attribute. Specify this attribute only if the &lt;code&gt;.jar&lt;/code&gt; files are not in the same directory as the m-let text file. If this attribute is not specified, the base URL of the m-let text file is used.</source>
          <target state="translated">이 선택적 속성은 확보 할 MBean의 코드 기본 URL을 지정합니다. &lt;code&gt;ARCHIVE&lt;/code&gt; 속성으로 지정된 &lt;code&gt;.jar&lt;/code&gt; 파일 이 포함 된 디렉토리를 식별 합니다. &lt;code&gt;.jar&lt;/code&gt; 파일이 m-let 텍스트 파일과 동일한 디렉토리에없는 경우에만이 속성을 지정 하십시오. 이 속성을 지정하지 않으면 m-let 텍스트 파일의 기본 URL이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5eb4392dd4a10514090d62b90d330a14ec889d6e" translate="yes" xml:space="preserve">
          <source>This optional attribute specifies the object name to be assigned to the MBean instance when the m-let service registers it. If &lt;var&gt;mbeanname&lt;/var&gt; starts with the colon character (:), the domain part of the object name is the default domain of the MBean server, as returned by &lt;a href=&quot;../mbeanserver#getDefaultDomain--&quot;&gt;&lt;code&gt;MBeanServer.getDefaultDomain()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 선택적 속성은 m-let 서비스가 등록 할 때 MBean 인스턴스에 지정 될 오브젝트 이름을 지정합니다. &lt;var&gt;mbeanname&lt;/var&gt; 이 콜론 문자 (:)로 시작하는 경우 , 오브젝트 이름의 도메인 부분은 &lt;a href=&quot;../mbeanserver#getDefaultDomain--&quot;&gt; &lt;code&gt;MBeanServer.getDefaultDomain()&lt;/code&gt; &lt;/a&gt; 의해 리턴되는 MBean 서버의 기본 도메인입니다 .</target>
        </trans-unit>
        <trans-unit id="c63c9c16af322931cb8e523d804c7487124f85be" translate="yes" xml:space="preserve">
          <source>This optional attribute specifies the version number of the MBean and associated &lt;code&gt;.jar&lt;/code&gt; files to be obtained. This version number can be used to specify that the &lt;code&gt;.jar&lt;/code&gt; files are loaded from the server to update those stored locally in the cache the next time the m-let text file is loaded. &lt;var&gt;version&lt;/var&gt; must be a series of non-negative decimal integers each separated by a period from the one that precedes it.</source>
          <target state="translated">이 선택적 속성은 획득 할 MBean 및 연관된 &lt;code&gt;.jar&lt;/code&gt; 파일 의 버전 번호를 지정합니다 . 이 버전 번호는 &lt;code&gt;.jar&lt;/code&gt; 파일이 서버에서로드되어 다음에 m-let 텍스트 파일이로드 될 때 캐시에 로컬로 저장된 파일을 업데이트 하도록 지정하는 데 사용할 수 있습니다 . &lt;var&gt;version&lt;/var&gt; 은 각각 마침표로 구분 된 음이 아닌 10 진 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7343cebf8089c891c832f1c4b657d1ed99e55aa4" translate="yes" xml:space="preserve">
          <source>This output device assigned attribute's locale and &lt;code&gt;object&lt;/code&gt;'s locale are equal.</source>
          <target state="translated">이 출력 장치 할당 속성의 로케일과 &lt;code&gt;object&lt;/code&gt; 의 로케일이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa627cb296bb9d5368d8b160c534107054430e92" translate="yes" xml:space="preserve">
          <source>This output device assigned attribute's underlying string and &lt;code&gt;object&lt;/code&gt;'s underlying string are equal.</source>
          <target state="translated">이 출력 장치에 할당 된 속성의 기본 문자열과 &lt;code&gt;object&lt;/code&gt; 의 기본 문자열이 같습니다.</target>
        </trans-unit>
        <trans-unit id="287a69e23ad8907d5aa30e1d22463d996c8d458c" translate="yes" xml:space="preserve">
          <source>This output stream</source>
          <target state="translated">이 출력 스트림</target>
        </trans-unit>
        <trans-unit id="1c5acb8dcc86af6da6a34303cfc1229c0c0664b0" translate="yes" xml:space="preserve">
          <source>This outputs the formatted date-time to the specified destination. &lt;a href=&quot;../../lang/appendable&quot;&gt;&lt;code&gt;Appendable&lt;/code&gt;&lt;/a&gt; is a general purpose interface that is implemented by all key character output classes including &lt;code&gt;StringBuffer&lt;/code&gt;, &lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;PrintStream&lt;/code&gt; and &lt;code&gt;Writer&lt;/code&gt;.</source>
          <target state="translated">형식화 된 날짜-시간을 지정된 대상으로 출력합니다. &lt;a href=&quot;../../lang/appendable&quot;&gt; &lt;code&gt;Appendable&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;StringBuffer&lt;/code&gt; , &lt;code&gt;StringBuilder&lt;/code&gt; , &lt;code&gt;PrintStream&lt;/code&gt; 및 &lt;code&gt;Writer&lt;/code&gt; 를 포함한 모든 주요 문자 출력 클래스에 의해 구현되는 범용 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="1126a6ede333e4f57bf3aa4d5dfb3c5e9ece413e" translate="yes" xml:space="preserve">
          <source>This package allows applications to retrieve and update attributes associated with objects stored in a directory, and to search for objects using specified attributes.</source>
          <target state="translated">이 패키지를 통해 응용 프로그램은 디렉토리에 저장된 객체와 관련된 속성을 검색 및 업데이트하고 지정된 속성을 사용하여 객체를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="288497f7814e08d4e47a22ea9f9b66e03e7eadc4" translate="yes" xml:space="preserve">
          <source>This package allows applications to store and retrieve user and system preference and configuration data.</source>
          <target state="translated">이 패키지를 통해 응용 프로그램은 사용자 및 시스템 환경 설정 및 구성 데이터를 저장하고 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e97097447b348c1e4a246b902f0475a5f2f816c2" translate="yes" xml:space="preserve">
          <source>This package allows applications to store and retrieve user and system preference and configuration data. This data is stored persistently in an implementation-dependent backing store. There are two separate trees of preference nodes, one for user preferences and one for system preferences.</source>
          <target state="translated">이 패키지를 통해 응용 프로그램은 사용자 및 시스템 환경 설정 및 구성 데이터를 저장하고 검색 할 수 있습니다. 이 데이터는 구현 종속 백업 저장소에 지속적으로 저장됩니다. 환경 설정 노드에는 사용자 환경 설정과 시스템 환경 설정을위한 두 개의 별도 트리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa64250076574831d90b6de36c8cbfcab3ec1a3d" translate="yes" xml:space="preserve">
          <source>This package contains some support classes for the built-in JPEG reader and writer plug-ins. Classes are provided for representing quantization and Huffman tables, and extensions of &lt;code&gt;ImageReadParam&lt;/code&gt; and &lt;code&gt;ImageWriteParam&lt;/code&gt; are provided to supply tables during the reading and writing process. For more information about the operation of the built-in JPEG plug-ins, see the JPEG metadata format specification and usage notes.</source>
          <target state="translated">이 패키지에는 내장 JPEG 리더 및 라이터 플러그인에 대한 일부 지원 클래스가 포함되어 있습니다. 양자화 및 허프만 테이블을 나타내는 클래스가 제공되며 , 읽기 및 쓰기 프로세스 중에 테이블을 제공하기 위해 &lt;code&gt;ImageReadParam&lt;/code&gt; 및 &lt;code&gt;ImageWriteParam&lt;/code&gt; 의 확장 이 제공됩니다. 내장 JPEG 플러그인 작동에 대한 자세한 내용은 JPEG 메타 데이터 형식 사양 및 사용 메모를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f276402586baaea7f6e39ec7543eba119f71a5f" translate="yes" xml:space="preserve">
          <source>This package contains the basic classes and interfaces for describing the contents of image files, including metadata and thumbnails (&lt;code&gt;IIOImage&lt;/code&gt;); for controlling the image reading process (&lt;code&gt;ImageReader&lt;/code&gt;, &lt;code&gt;ImageReadParam&lt;/code&gt;, and &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;) and image writing process (&lt;code&gt;ImageWriter&lt;/code&gt; and &lt;code&gt;ImageWriteParam&lt;/code&gt;); for performing transcoding between formats (&lt;code&gt;ImageTranscoder&lt;/code&gt;), and for reporting errors (&lt;code&gt;IIOException&lt;/code&gt;).</source>
          <target state="translated">이 패키지에는 메타 데이터 및 썸네일 ( &lt;code&gt;IIOImage&lt;/code&gt; )을 포함하여 이미지 파일의 내용을 설명하기위한 기본 클래스 및 인터페이스가 포함되어 있습니다 . 이미지 판독 프로세스 ( &lt;code&gt;ImageReader&lt;/code&gt; , &lt;code&gt;ImageReadParam&lt;/code&gt; 및 &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; ) 및 이미지 작성 프로세스 ( &lt;code&gt;ImageWriter&lt;/code&gt; 및 &lt;code&gt;ImageWriteParam&lt;/code&gt; )를 제어하기 위해; 형식 간 트랜스 코딩 수행 ( &lt;code&gt;ImageTranscoder&lt;/code&gt; ) 및 오류보고 ( &lt;code&gt;IIOException&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1bc4439ea20d876f9aaaeb46de959fb166bd1dd9" translate="yes" xml:space="preserve">
          <source>This package contains the classes that should be used to store X500 Principal and X500 Private Credentials in a</source>
          <target state="translated">이 패키지에는 X500 프린시 펄 및 X500 개인 신임 정보를 저장하는 데 사용해야하는 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bcd3e5baa32173a996e3505e09482e17dac00f3" translate="yes" xml:space="preserve">
          <source>This package contains utility classes related to the Kerberos network authentication protocol.</source>
          <target state="translated">이 패키지에는 Kerberos 네트워크 인증 프로토콜과 관련된 유틸리티 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b65cce3e590cd8472c69914c23535be7185cb1" translate="yes" xml:space="preserve">
          <source>This package contains utility classes related to the Kerberos network authentication protocol. They do not provide much Kerberos support themselves.</source>
          <target state="translated">이 패키지에는 Kerberos 네트워크 인증 프로토콜과 관련된 유틸리티 클래스가 포함되어 있습니다. Kerberos 자체를 많이 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="704d234d7ca4c6cc11b14edd6d51dc302731e56a" translate="yes" xml:space="preserve">
          <source>This package defines a &lt;code&gt;NamingEvent&lt;/code&gt; class to represent an event that is generated by a naming/directory service. It also defines subinterfaces of &lt;code&gt;Context&lt;/code&gt; and &lt;code&gt;DirContext&lt;/code&gt;, called &lt;code&gt;EventContext&lt;/code&gt; and &lt;code&gt;EventDirContext&lt;/code&gt;, through which applications can register their interest in events fired by the context.</source>
          <target state="translated">이 패키지는 네이밍 / 디렉토리 서비스에 의해 생성 된 이벤트를 나타 내기 위해 &lt;code&gt;NamingEvent&lt;/code&gt; 클래스를 정의합니다 . 또한 &lt;code&gt;Context&lt;/code&gt; 및 &lt;code&gt;DirContext&lt;/code&gt; 의 하위 인터페이스 ( &lt;code&gt;EventContext&lt;/code&gt; 및 &lt;code&gt;EventDirContext&lt;/code&gt; )를 정의하여 애플리케이션이 컨텍스트에 의해 발생 된 이벤트에 대한 관심을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a5725a6e15257c679b593154e3b56862b3d964" translate="yes" xml:space="preserve">
          <source>This package defines asynchronous-channel classes that are connected to a stream-oriented connecting or listening socket, or a datagram-oriented socket. It also defines the &lt;a href=&quot;asynchronousfilechannel&quot;&gt;&lt;code&gt;AsynchronousFileChannel&lt;/code&gt;&lt;/a&gt; class for asynchronous reading, writing, and manipulating a file. As with the &lt;a href=&quot;filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt; it supports operations to truncate the file to a specific size, force updates to the file to be written to the storage device, or acquire locks on the whole file or on a specific region of the file. Unlike the &lt;code&gt;FileChannel&lt;/code&gt; it does not define methods for mapping a region of the file directly into memory. Where memory mapped I/O is required, then a &lt;code&gt;FileChannel&lt;/code&gt; can be used.</source>
          <target state="translated">이 패키지는 스트림 지향 연결 또는 청취 소켓 또는 데이터 그램 지향 소켓에 연결된 비동기 채널 클래스를 정의합니다. 또한 파일을 비동기 적으로 읽고 쓰고 조작하기위한 &lt;a href=&quot;asynchronousfilechannel&quot;&gt; &lt;code&gt;AsynchronousFileChannel&lt;/code&gt; &lt;/a&gt; 클래스를 정의 합니다. &lt;a href=&quot;filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 파일을 특정 크기로 자르거나 파일에 대한 업데이트를 저장 장치에 쓰거나 전체 파일 또는 파일의 특정 영역에서 잠금을 획득하는 작업을 지원합니다. &lt;code&gt;FileChannel&lt;/code&gt; 과 달리 파일 영역을 메모리에 직접 매핑하는 방법을 정의하지 않습니다. 메모리 매핑 된 I / O가 필요한 경우 &lt;code&gt;FileChannel&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bd1981873ec43b1bb6c9505b7f4ee48a2fd78f" translate="yes" xml:space="preserve">
          <source>This package defines selectable-channel classes corresponding to the &lt;a href=&quot;../../net/datagramsocket&quot;&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../net/serversocket&quot;&gt;&lt;code&gt;ServerSocket&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../net/socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; classes defined in the &lt;code&gt;&lt;a href=&quot;../../net/package-summary&quot;&gt;&lt;code&gt;java.net&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; package. Minor changes to these classes have been made in order to support sockets that are associated with channels. This package also defines a simple class that implements unidirectional pipes. In all cases, a new selectable channel is created by invoking the static &lt;code&gt;open&lt;/code&gt; method of the corresponding class. If a channel needs an associated socket then a socket will be created as a side effect of this operation.</source>
          <target state="translated">이 패키지는 &lt;code&gt;&lt;a href=&quot;../../net/package-summary&quot;&gt;&lt;code&gt;java.net&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 패키지에 정의 된 &lt;a href=&quot;../../net/datagramsocket&quot;&gt; &lt;code&gt;DatagramSocket&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../net/serversocket&quot;&gt; &lt;code&gt;ServerSocket&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../net/socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt; 클래스에 대응하는 선택 가능한 채널 클래스를 정의 합니다. 채널과 관련된 소켓을 지원하기 위해 이러한 클래스를 약간 변경했습니다. 이 패키지는 또한 단방향 파이프를 구현하는 간단한 클래스를 정의합니다. 모든 경우에 해당하는 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메소드를 호출하여 선택 가능한 새 채널이 작성됩니다 . 채널에 관련 소켓이 필요한 경우이 작업의 부작용으로 소켓이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a677b4e249a5e3217b3f33f6b841b9bcaec5fd" translate="yes" xml:space="preserve">
          <source>This package defines the directory operations of the Java Naming and Directory Interface&lt;sup&gt;TM&lt;/sup&gt; (JNDI). JNDI provides naming and directory functionality to applications written in the Java programming language. It is designed to be independent of any specific naming or directory service implementation. Thus a variety of services--new, emerging, and already deployed ones--can be accessed in a common way.</source>
          <target state="translated">이 패키지는 JNDI ( Java Naming and Directory Interface &lt;sup&gt;TM&lt;/sup&gt; ) 의 디렉토리 작업을 정의합니다 . JNDI는 Java 프로그래밍 언어로 작성된 애플리케이션에 이름 지정 및 디렉토리 기능을 제공합니다. 특정 이름 지정 또는 디렉토리 서비스 구현과 독립적으로 설계되었습니다. 따라서 새로운 서비스, 이미 구축 된 서비스 등 다양한 서비스에 공통적 인 방식으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc76b26c25cc3460f4a70f06429a24f2196d9b6" translate="yes" xml:space="preserve">
          <source>This package defines the event notification operations of the Java Naming and Directory Interface&lt;sup&gt;TM&lt;/sup&gt; (JNDI). JNDI provides naming and directory functionality to applications written in the Java programming language. It is designed to be independent of any specific naming or directory service implementation. Thus a variety of services--new, emerging, and already deployed ones--can be accessed in a common way.</source>
          <target state="translated">이 패키지는 JNDI ( Java Naming and Directory Interface &lt;sup&gt;TM&lt;/sup&gt; ) 의 이벤트 알림 작업을 정의합니다 . JNDI는 Java 프로그래밍 언어로 작성된 애플리케이션에 이름 지정 및 디렉토리 기능을 제공합니다. 특정 이름 지정 또는 디렉토리 서비스 구현과 독립적으로 설계되었습니다. 따라서 새로운 서비스, 이미 구축 된 서비스 등 다양한 서비스에 공통적 인 방식으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8c341e63d2743b2371e2edc9e4e1f75c5e0347" translate="yes" xml:space="preserve">
          <source>This package defines the interface &lt;code&gt;Control&lt;/code&gt; to represent an LDAPv3 control. It can be a control that is sent to an LDAP server (&lt;em&gt;request control&lt;/em&gt;) or a control returned by an LDAP server (&lt;em&gt;response control&lt;/em&gt;). Unlike extended requests and responses, there is not necessarily any pairing between request controls and response controls. You can send request controls and expect no response controls back, or receive response controls without sending any request controls.</source>
          <target state="translated">이 패키지는 인터페이스 인터페이스를 정의하여 LDAPv3 &lt;code&gt;Control&lt;/code&gt; 을 나타냅니다. LDAP 서버로 전송되는 &lt;em&gt;제어&lt;/em&gt; ( &lt;em&gt;요청 제어&lt;/em&gt; ) 또는 LDAP 서버가 리턴 한 &lt;em&gt;제어&lt;/em&gt; ( &lt;em&gt;응답 제어&lt;/em&gt; ) 일 수 있습니다. 확장 요청 및 응답과 달리 요청 제어와 응답 제어간에 쌍이있을 필요는 없습니다. 요청 제어를 보내고 응답 제어를 다시 기대하지 않거나 요청 제어를 보내지 않고 응답 제어를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16558c590d65c082b7a5ba1c6f2b177b4b9024b" translate="yes" xml:space="preserve">
          <source>This package defines the interface &lt;code&gt;ExtendedRequest&lt;/code&gt; to represent the argument to an extended operation, and the interface &lt;code&gt;ExtendedResponse&lt;/code&gt; to represent the result of the extended operation. An extended response is always paired with an extended request but not necessarily vice versa. That is, you can have an extended request that has no corresponding extended response.</source>
          <target state="translated">이 패키지는 인터페이스 정의 &lt;code&gt;ExtendedRequest&lt;/code&gt; 확장 조작의 인수를 나타내는, 그리고 인터페이스 &lt;code&gt;ExtendedResponse&lt;/code&gt; 확장 연산의 결과를 나타내는. 확장 된 응답은 항상 확장 된 요청과 쌍을 이루어야하지만 반드시 그 반대 일 필요는 없습니다. 즉, 해당 확장 응답이없는 확장 요청이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c93855822dcf49856f49aea1ae426c2c724905" translate="yes" xml:space="preserve">
          <source>This package defines the naming operations of the Java Naming and Directory Interface&lt;sup&gt;TM&lt;/sup&gt; (JNDI). JNDI provides naming and directory functionality to applications written in the Java programming language. It is designed to be independent of any specific naming or directory service implementation. Thus a variety of services--new, emerging, and already deployed ones--can be accessed in a common way.</source>
          <target state="translated">이 패키지는 JNDI ( Java Naming and Directory Interface &lt;sup&gt;TM&lt;/sup&gt; ) 의 이름 지정 작업을 정의합니다 . JNDI는 Java 프로그래밍 언어로 작성된 애플리케이션에 이름 지정 및 디렉토리 기능을 제공합니다. 특정 이름 지정 또는 디렉토리 서비스 구현과 독립적으로 설계되었습니다. 따라서 새로운 서비스, 이미 구축 된 서비스 등 다양한 서비스에 공통적 인 방식으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c39362433065d0862c75d77b590b48f243dd902" translate="yes" xml:space="preserve">
          <source>This package defines the notion of a &lt;em&gt;context&lt;/em&gt;, represented by the &lt;code&gt;Context&lt;/code&gt; interface. A context consists of a set of name-to-object &lt;em&gt;bindings&lt;/em&gt;. &lt;code&gt;Context&lt;/code&gt; is the core interface for looking up, binding, unbinding, and renaming objects, and for creating and destroying subcontexts.</source>
          <target state="translated">이 패키지는 &lt;code&gt;Context&lt;/code&gt; 인터페이스로 표현되는 &lt;em&gt;context&lt;/em&gt; 개념을 정의합니다 . 컨텍스트는 일련의 이름 대 오브젝트 &lt;em&gt;바인딩으로 구성&lt;/em&gt; 됩니다. &lt;code&gt;Context&lt;/code&gt; 는 객체를 찾고, 바인딩하고, 바인딩을 해제하고, 이름을 바꾸고 하위 컨텍스트를 작성하고 삭제하기위한 핵심 인터페이스입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c09aa5004534aa01c2386228535bf3dff65f59c" translate="yes" xml:space="preserve">
          <source>This package expands on the base package to provide additional functionality for more powerful use cases. Support is included for:</source>
          <target state="translated">이 패키지는 기본 패키지에서 확장되어보다 강력한 사용 사례를위한 추가 기능을 제공합니다. 다음에 대한 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="800c70232f472c7fdce77e7b4637fe7f97636d11" translate="yes" xml:space="preserve">
          <source>This package extends the directory operations of the Java Naming and Directory Interface&lt;sup&gt;TM&lt;/sup&gt; (JNDI). JNDI provides naming and directory functionality to applications written in the Java programming language. It is designed to be independent of any specific naming or directory service implementation. Thus a variety of services--new, emerging, and already deployed ones--can be accessed in a common way.</source>
          <target state="translated">이 패키지는 JNDI ( Java Naming and Directory Interface &lt;sup&gt;TM&lt;/sup&gt; )의 디렉토리 작업을 확장합니다 . JNDI는 Java 프로그래밍 언어로 작성된 애플리케이션에 이름 지정 및 디렉토리 기능을 제공합니다. 특정 이름 지정 또는 디렉토리 서비스 구현과 독립적으로 설계되었습니다. 따라서 새로운 서비스, 이미 구축 된 서비스 등 다양한 서비스에 공통적 인 방식으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bbc67e0bae46ec040c3f0acf3bc0f96c93ab907" translate="yes" xml:space="preserve">
          <source>This package is for applications and service providers that deal with LDAPv3 extended operations and controls, as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251&lt;/a&gt;. The core interface in this package is &lt;code&gt;LdapContext&lt;/code&gt;, which defines methods on a context for performing extended operations and handling controls.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251에&lt;/a&gt; 정의 된 대로 LDAPv3 확장 조작 및 제어를 처리하는 애플리케이션 및 서비스 제공자를위한 것 입니다. 이 패키지의 핵심 인터페이스는 &lt;code&gt;LdapContext&lt;/code&gt; 로 , 확장 조작을 수행하고 제어를 처리하기위한 컨텍스트에서 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3ce7eb06804bb9e19fffc97ccc2e50928d63635b" translate="yes" xml:space="preserve">
          <source>This package is the home of the Java programming language compiler framework. This framework allows clients of the framework to locate and run compilers from programs. The framework also provides Service Provider Interfaces (SPI) for structured access to diagnostics (&lt;a href=&quot;diagnosticlistener&quot;&gt;DiagnosticListener&lt;/a&gt;) as well as a file abstraction for overriding file access (&lt;a href=&quot;javafilemanager&quot;&gt;JavaFileManager&lt;/a&gt; and &lt;a href=&quot;javafileobject&quot;&gt;JavaFileObject&lt;/a&gt;). See &lt;a href=&quot;javacompiler&quot;&gt;JavaCompiler&lt;/a&gt; for more details on using the SPI.</source>
          <target state="translated">이 패키지는 Java 프로그래밍 언어 컴파일러 프레임 워크의 홈입니다. 이 프레임 워크를 사용하면 프레임 워크 클라이언트가 프로그램에서 컴파일러를 찾아 실행할 수 있습니다. 프레임 워크는 진단에 대한 구조화 된 액세스 ( &lt;a href=&quot;diagnosticlistener&quot;&gt;DiagnosticListener&lt;/a&gt; ) 및 파일 액세스 대체 ( &lt;a href=&quot;javafilemanager&quot;&gt;JavaFileManager&lt;/a&gt; 및 &lt;a href=&quot;javafileobject&quot;&gt;JavaFileObject&lt;/a&gt; )에 대한 파일 추상화를위한 SPI (Service Provider Interfaces)를 제공합니다 . SPI 사용에 대한 자세한 내용 은 &lt;a href=&quot;javacompiler&quot;&gt;JavaCompiler&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
