<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="e9a292b0abb8b658c9e2e0d1f64563e868d31f7c" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.getWaitQueueLength()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.getWaitQueueLength()</target>
        </trans-unit>
        <trans-unit id="cdcbad6d579d96ccdadfc92cdd59f11e77f75257" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.getWaitingThreads()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.getWaitingThreads()</target>
        </trans-unit>
        <trans-unit id="f36fe35e2b8f6acdbb5b536a457f18974773c9ae" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.hasContended()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.hasContended()</target>
        </trans-unit>
        <trans-unit id="bc795af3aba8758d1f0c9e684404fd2c73593424" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.hasQueuedPredecessors()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.hasQueuedPredecessors()</target>
        </trans-unit>
        <trans-unit id="b466918a9d9365218eef25234b7eb28dd71493a1" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.hasQueuedThreads()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.hasQueuedThreads()</target>
        </trans-unit>
        <trans-unit id="cfc5cac20f8755487cb929b11276486d2de0d9a0" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.hasWaiters()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.hasWaiters()</target>
        </trans-unit>
        <trans-unit id="a9d51b36bb8570eaa5567535c60a0a490e8f6388" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.isHeldExclusively()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.isHeldExclusively()</target>
        </trans-unit>
        <trans-unit id="e9b8dd626711ff88b91a1ae4b4bd2b26cc4e440d" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.isQueued()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.isQueued()</target>
        </trans-unit>
        <trans-unit id="963a99ea05a970f7e9ced0fff4aed062e48fdc03" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.owns()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.owns()</target>
        </trans-unit>
        <trans-unit id="269fbc1f8bcfaf5499043cf7981a59a648c8a798" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.release()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.release()</target>
        </trans-unit>
        <trans-unit id="2b0a8959497f3d3f57fde7336febbf83879ff5a4" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.releaseShared()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.releaseShared()</target>
        </trans-unit>
        <trans-unit id="39d400312495ce1dbe218d0930f36ef2fbbef214" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.setState()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.setState()</target>
        </trans-unit>
        <trans-unit id="41b70cd2bca5c0655e2e8d7cb36166a809f79fb3" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.toString()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.toString()</target>
        </trans-unit>
        <trans-unit id="6cc91c4c8d022cc0d901c847fa9821bf63022a04" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryAcquire()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryAcquire()</target>
        </trans-unit>
        <trans-unit id="f59034bd3217f40e0e69f810ad87a9c5d15058ed" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryAcquireNanos()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryAcquireNanos()</target>
        </trans-unit>
        <trans-unit id="6e3324d1ee2e3c7f7e6bab7e9cab0fa7d239a69d" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryAcquireShared()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryAcquireShared()</target>
        </trans-unit>
        <trans-unit id="f9fb51896e5f5065ae0ac1df46cbccd2ab0d7ed7" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryAcquireSharedNanos()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryAcquireSharedNanos()</target>
        </trans-unit>
        <trans-unit id="76a4a5cfaa6620e96cd1eb5ec81a28bdc32cb19a" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryRelease()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryRelease()</target>
        </trans-unit>
        <trans-unit id="85c883655678b85f98052435b07448cf2e6d633a" translate="yes" xml:space="preserve">
          <source>AbstractQueuedLongSynchronizer.tryReleaseShared()</source>
          <target state="translated">AbstractQueuedLongSynchronizer.tryReleaseShared()</target>
        </trans-unit>
        <trans-unit id="5d867571c2a58d597bb22863544f51902fbbd9c9" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer</source>
          <target state="translated">AbstractQueuedSynchronizer</target>
        </trans-unit>
        <trans-unit id="268f1c5fcb231c19c27673f68cfe2c3b96ebcb8f" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject</target>
        </trans-unit>
        <trans-unit id="c588c6aff8db43715a7693635bd07c44353f1419" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.await()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.await()</target>
        </trans-unit>
        <trans-unit id="6872c57116ceda5212f6d65cefc5a4ff37ccd3b8" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.awaitNanos()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.awaitNanos()</target>
        </trans-unit>
        <trans-unit id="5805f7ba39bdcaa1f4c0c8310ec074ff3a02bfdb" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.awaitUninterruptibly()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.awaitUninterruptibly()</target>
        </trans-unit>
        <trans-unit id="9df452ad5ea234eafb48fe2e4ace01d0d70ad5e7" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.awaitUntil()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.awaitUntil()</target>
        </trans-unit>
        <trans-unit id="1668ab1209204493112081cb8f811630519327b2" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.getWaitQueueLength()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.getWaitQueueLength()</target>
        </trans-unit>
        <trans-unit id="21c62d07b36779080e5c027fbab0b338bb0d03a0" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.getWaitingThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.getWaitingThreads()</target>
        </trans-unit>
        <trans-unit id="71e89e0b6bc98f29c00f69e01b4edf1ad1653bcb" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.hasWaiters()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.hasWaiters()</target>
        </trans-unit>
        <trans-unit id="4de29f5a03f49987d56323dbee0786e5f0bfc61f" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.signal()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.signal()</target>
        </trans-unit>
        <trans-unit id="c1d8dc096a543120bca834d88db8ad3d62345fb8" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.ConditionObject.signalAll()</source>
          <target state="translated">AbstractQueuedSynchronizer.ConditionObject.signalAll()</target>
        </trans-unit>
        <trans-unit id="fbfa94fe56c0e879d5f94b7628bfaf0be2eedd86" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.acquire()</source>
          <target state="translated">AbstractQueuedSynchronizer.acquire()</target>
        </trans-unit>
        <trans-unit id="bce9fb0bc8ccc3fcebaffedb7de5d737f32ddc5d" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.acquireInterruptibly()</source>
          <target state="translated">AbstractQueuedSynchronizer.acquireInterruptibly()</target>
        </trans-unit>
        <trans-unit id="7471c91775d59ed03086bcd84f93223c29e4b46a" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.acquireShared()</source>
          <target state="translated">AbstractQueuedSynchronizer.acquireShared()</target>
        </trans-unit>
        <trans-unit id="5895b78fa9e5cd02fd2272b532f37cb8ef6ff933" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.acquireSharedInterruptibly()</source>
          <target state="translated">AbstractQueuedSynchronizer.acquireSharedInterruptibly()</target>
        </trans-unit>
        <trans-unit id="783e00c00bf83eb2b826e742a7314c48322b8d98" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.compareAndSetState()</source>
          <target state="translated">AbstractQueuedSynchronizer.compareAndSetState()</target>
        </trans-unit>
        <trans-unit id="7e288f1698fde4d10d117b341ca3761ca2150e49" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getExclusiveQueuedThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.getExclusiveQueuedThreads()</target>
        </trans-unit>
        <trans-unit id="5f42840a20480eac67ab5fa618d7b28016636c69" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getFirstQueuedThread()</source>
          <target state="translated">AbstractQueuedSynchronizer.getFirstQueuedThread()</target>
        </trans-unit>
        <trans-unit id="5fbf8baf0c89a3095d6e7efb3827b9748ea15cf2" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getQueueLength()</source>
          <target state="translated">AbstractQueuedSynchronizer.getQueueLength()</target>
        </trans-unit>
        <trans-unit id="043b009f8575ecb795f46b775e1b8cff84f8b1d8" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getQueuedThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.getQueuedThreads()</target>
        </trans-unit>
        <trans-unit id="9b0d9415c9a80433fb807e0288de17277442a628" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getSharedQueuedThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.getSharedQueuedThreads()</target>
        </trans-unit>
        <trans-unit id="29f9da9c00e770f88287e533df187ae6087c5e77" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getState()</source>
          <target state="translated">AbstractQueuedSynchronizer.getState()</target>
        </trans-unit>
        <trans-unit id="c68402d6c810ff4a01cc8a4cca6eedaea6d4a00f" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getWaitQueueLength()</source>
          <target state="translated">AbstractQueuedSynchronizer.getWaitQueueLength()</target>
        </trans-unit>
        <trans-unit id="ea1cc5e3170e5f868917fe57af9e9a9780eca498" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.getWaitingThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.getWaitingThreads()</target>
        </trans-unit>
        <trans-unit id="ef5e89aad1d23430b19580218455b75cd069ce22" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.hasContended()</source>
          <target state="translated">AbstractQueuedSynchronizer.hasContended()</target>
        </trans-unit>
        <trans-unit id="c90d3ac9428aba57a716ab1a29d587982430f8f5" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.hasQueuedPredecessors()</source>
          <target state="translated">AbstractQueuedSynchronizer.hasQueuedPredecessors()</target>
        </trans-unit>
        <trans-unit id="4381a84057417af4ca2ec1b416ce28268d08eac8" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.hasQueuedThreads()</source>
          <target state="translated">AbstractQueuedSynchronizer.hasQueuedThreads()</target>
        </trans-unit>
        <trans-unit id="8a82823763592c561af5f197504c0cd6fa2caa7f" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.hasWaiters()</source>
          <target state="translated">AbstractQueuedSynchronizer.hasWaiters()</target>
        </trans-unit>
        <trans-unit id="61bb301fe96783e5a9db094a44b2f07ebc13a0ff" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.isHeldExclusively()</source>
          <target state="translated">AbstractQueuedSynchronizer.isHeldExclusively()</target>
        </trans-unit>
        <trans-unit id="e32765342d314e381ab3dc7fdee85964dab4c374" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.isQueued()</source>
          <target state="translated">AbstractQueuedSynchronizer.isQueued()</target>
        </trans-unit>
        <trans-unit id="062ed747178136eccd0c200c3961f0059526a3be" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.owns()</source>
          <target state="translated">AbstractQueuedSynchronizer.owns()</target>
        </trans-unit>
        <trans-unit id="7004ca98a014dbc648f7202dd6f8cc9dbdba60cb" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.release()</source>
          <target state="translated">AbstractQueuedSynchronizer.release()</target>
        </trans-unit>
        <trans-unit id="7c2e6688f31784d4ad877e35234b6e8f4e5f19aa" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.releaseShared()</source>
          <target state="translated">AbstractQueuedSynchronizer.releaseShared()</target>
        </trans-unit>
        <trans-unit id="a5484a90556b6597e47d922f6f3bb9d20d13ce2d" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.setState()</source>
          <target state="translated">AbstractQueuedSynchronizer.setState()</target>
        </trans-unit>
        <trans-unit id="dfd6b1e607d52b83797dd5e116a94f1c4218aade" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.toString()</source>
          <target state="translated">AbstractQueuedSynchronizer.toString()</target>
        </trans-unit>
        <trans-unit id="787c0394f517671d42080907018b0439f3e4ed88" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryAcquire()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryAcquire()</target>
        </trans-unit>
        <trans-unit id="ea28bca6baecd8f6c91a0e276b9af53201e1ab9d" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryAcquireNanos()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryAcquireNanos()</target>
        </trans-unit>
        <trans-unit id="ea3542870cc929da72320b98d588a9bdb30db890" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryAcquireShared()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryAcquireShared()</target>
        </trans-unit>
        <trans-unit id="f43b377696235119cf3e0505657e3992f39807e5" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryAcquireSharedNanos()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryAcquireSharedNanos()</target>
        </trans-unit>
        <trans-unit id="6ffa45b0880e9daf9626de65a5fde1c9f85be6c4" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryRelease()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryRelease()</target>
        </trans-unit>
        <trans-unit id="9edfabaf3edb8a7443d121b7cf9f5a7d8af6e876" translate="yes" xml:space="preserve">
          <source>AbstractQueuedSynchronizer.tryReleaseShared()</source>
          <target state="translated">AbstractQueuedSynchronizer.tryReleaseShared()</target>
        </trans-unit>
        <trans-unit id="5e83eb9f9fb95ee635fee0b9aa39f12cc18c703a" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine</source>
          <target state="translated">AbstractScriptEngine</target>
        </trans-unit>
        <trans-unit id="84b1e671b470bbd94881bf2a696576ea2819968f" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.eval()</source>
          <target state="translated">AbstractScriptEngine.eval()</target>
        </trans-unit>
        <trans-unit id="5210e276106ec7d5250ec8e62e95c2155e79ce1f" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.get()</source>
          <target state="translated">AbstractScriptEngine.get()</target>
        </trans-unit>
        <trans-unit id="276dd2627207cebb1b030e8b3570e990257df0b9" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.getBindings()</source>
          <target state="translated">AbstractScriptEngine.getBindings()</target>
        </trans-unit>
        <trans-unit id="e36fc7bcce77f5a193b8e4ee1af1709e45d88601" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.getContext()</source>
          <target state="translated">AbstractScriptEngine.getContext()</target>
        </trans-unit>
        <trans-unit id="24bc78b1d86f5e25c80360483b8223156ff09614" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.getScriptContext()</source>
          <target state="translated">AbstractScriptEngine.getScriptContext()</target>
        </trans-unit>
        <trans-unit id="cc51be4251fbf098197c9c094bd1e99088fab805" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.put()</source>
          <target state="translated">AbstractScriptEngine.put()</target>
        </trans-unit>
        <trans-unit id="c232c0b1fd670710d8c8a1d28a9002730fb66baf" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.setBindings()</source>
          <target state="translated">AbstractScriptEngine.setBindings()</target>
        </trans-unit>
        <trans-unit id="0f5bd955d2ccbecbe1761cd9dd3f796e26477a3a" translate="yes" xml:space="preserve">
          <source>AbstractScriptEngine.setContext()</source>
          <target state="translated">AbstractScriptEngine.setContext()</target>
        </trans-unit>
        <trans-unit id="5a2696019b73009f238825b444af34e543701a66" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel</source>
          <target state="translated">AbstractSelectableChannel</target>
        </trans-unit>
        <trans-unit id="40f815ba5f93dd5bdfb5c71896d30fed2c822b2c" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.blockingLock()</source>
          <target state="translated">AbstractSelectableChannel.blockingLock()</target>
        </trans-unit>
        <trans-unit id="9bd0fc5a90beb5ba89a470b5954bfcadc54435f2" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.configureBlocking()</source>
          <target state="translated">AbstractSelectableChannel.configureBlocking()</target>
        </trans-unit>
        <trans-unit id="a9c9ecc1d2928be72a23939db88dcfc7534e3098" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.implCloseChannel()</source>
          <target state="translated">AbstractSelectableChannel.implCloseChannel()</target>
        </trans-unit>
        <trans-unit id="350d5e75b246e9637871b4d09d3f583fd340d6ec" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.implCloseSelectableChannel()</source>
          <target state="translated">AbstractSelectableChannel.implCloseSelectableChannel()</target>
        </trans-unit>
        <trans-unit id="5b018b1d7dfdb3a3af3911d7ba54fd2c248f0c4a" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.implConfigureBlocking()</source>
          <target state="translated">AbstractSelectableChannel.implConfigureBlocking()</target>
        </trans-unit>
        <trans-unit id="e874ec5023a70bc2a641f81dbef44e312b3f14d8" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.isBlocking()</source>
          <target state="translated">AbstractSelectableChannel.isBlocking()</target>
        </trans-unit>
        <trans-unit id="fffe1955942c1f052ecfdd0254fa8540c6b12887" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.isRegistered()</source>
          <target state="translated">AbstractSelectableChannel.isRegistered()</target>
        </trans-unit>
        <trans-unit id="07cdf1efb5357b1930d7cb032755b7eaadf743fb" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.keyFor()</source>
          <target state="translated">AbstractSelectableChannel.keyFor()</target>
        </trans-unit>
        <trans-unit id="4d691fc4b402ae9d8543d4d402e7c5d2c0b76e93" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.provider()</source>
          <target state="translated">AbstractSelectableChannel.provider()</target>
        </trans-unit>
        <trans-unit id="de9f0d4572781aee13b6f96c239143351902a2c2" translate="yes" xml:space="preserve">
          <source>AbstractSelectableChannel.register()</source>
          <target state="translated">AbstractSelectableChannel.register()</target>
        </trans-unit>
        <trans-unit id="91158943463abc06abf1f00e83e13de52f8b6f9a" translate="yes" xml:space="preserve">
          <source>AbstractSelectionKey</source>
          <target state="translated">AbstractSelectionKey</target>
        </trans-unit>
        <trans-unit id="21bfeaa0646645d2ccdc01de966341095a71ff83" translate="yes" xml:space="preserve">
          <source>AbstractSelectionKey.cancel()</source>
          <target state="translated">AbstractSelectionKey.cancel()</target>
        </trans-unit>
        <trans-unit id="ae6589798bc47fede660acf6d8b41453cd462f0b" translate="yes" xml:space="preserve">
          <source>AbstractSelectionKey.isValid()</source>
          <target state="translated">AbstractSelectionKey.isValid()</target>
        </trans-unit>
        <trans-unit id="c0e439c68428359f13c51941a842a8c14dd53c99" translate="yes" xml:space="preserve">
          <source>AbstractSelector</source>
          <target state="translated">AbstractSelector</target>
        </trans-unit>
        <trans-unit id="683b1411db43662802f063abd867841fbce85f78" translate="yes" xml:space="preserve">
          <source>AbstractSelector.begin()</source>
          <target state="translated">AbstractSelector.begin()</target>
        </trans-unit>
        <trans-unit id="0f9fc840482c4adb0df4f9b1ba5c4f2471ffaea8" translate="yes" xml:space="preserve">
          <source>AbstractSelector.cancelledKeys()</source>
          <target state="translated">AbstractSelector.cancelledKeys()</target>
        </trans-unit>
        <trans-unit id="8d0ea7d0d8561d62e824ded19c656844229a7193" translate="yes" xml:space="preserve">
          <source>AbstractSelector.close()</source>
          <target state="translated">AbstractSelector.close()</target>
        </trans-unit>
        <trans-unit id="2fcafd3c05e4bef6b49e259625dbf5efa478226a" translate="yes" xml:space="preserve">
          <source>AbstractSelector.deregister()</source>
          <target state="translated">AbstractSelector.deregister()</target>
        </trans-unit>
        <trans-unit id="4f27c6c44a00f7b5d0e45942938ba52a88332111" translate="yes" xml:space="preserve">
          <source>AbstractSelector.end()</source>
          <target state="translated">AbstractSelector.end()</target>
        </trans-unit>
        <trans-unit id="e413862f03c19c6c5dd60b2d53fbd49341ef833f" translate="yes" xml:space="preserve">
          <source>AbstractSelector.implCloseSelector()</source>
          <target state="translated">AbstractSelector.implCloseSelector()</target>
        </trans-unit>
        <trans-unit id="9b4feb0b286daad9865d6ba023e5ab2317509c62" translate="yes" xml:space="preserve">
          <source>AbstractSelector.isOpen()</source>
          <target state="translated">AbstractSelector.isOpen()</target>
        </trans-unit>
        <trans-unit id="65a384d882590387397216768a849553b54dba76" translate="yes" xml:space="preserve">
          <source>AbstractSelector.provider()</source>
          <target state="translated">AbstractSelector.provider()</target>
        </trans-unit>
        <trans-unit id="05ea9a662f83027c0584df97c76ca4b3d4d81df6" translate="yes" xml:space="preserve">
          <source>AbstractSelector.register()</source>
          <target state="translated">AbstractSelector.register()</target>
        </trans-unit>
        <trans-unit id="3e4f0d478ebfb2d91c32a3ff8223226b42744334" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList</source>
          <target state="translated">AbstractSequentialList</target>
        </trans-unit>
        <trans-unit id="28c38129ea5580724bd3cbc20dc9e633031835c4" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.add()</source>
          <target state="translated">AbstractSequentialList.add()</target>
        </trans-unit>
        <trans-unit id="7fe1b83f9d18866f5ad6cefb855aaea94472020b" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.addAll()</source>
          <target state="translated">AbstractSequentialList.addAll()</target>
        </trans-unit>
        <trans-unit id="0db9e62b16b1b4d0ce11e64ea100fee27a3b1d7f" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.get()</source>
          <target state="translated">AbstractSequentialList.get()</target>
        </trans-unit>
        <trans-unit id="7994485ef77a0d81cd922e248d8113f7269a3d72" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.iterator()</source>
          <target state="translated">AbstractSequentialList.iterator()</target>
        </trans-unit>
        <trans-unit id="3f9ad9dc71bd7ec785e3649c2f52549f7fee71d5" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.listIterator()</source>
          <target state="translated">AbstractSequentialList.listIterator()</target>
        </trans-unit>
        <trans-unit id="8f50d01ba666a44a7cd462c31755664f9ef4a918" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.remove()</source>
          <target state="translated">AbstractSequentialList.remove()</target>
        </trans-unit>
        <trans-unit id="eb4c9361eccfd30ab1497d7bea11e7a8969b5fa4" translate="yes" xml:space="preserve">
          <source>AbstractSequentialList.set()</source>
          <target state="translated">AbstractSequentialList.set()</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="4b135a50ff14fcb7e4ffabf2825d3a5b3c930cc5" translate="yes" xml:space="preserve">
          <source>AbstractSet.equals()</source>
          <target state="translated">AbstractSet.equals()</target>
        </trans-unit>
        <trans-unit id="3c82243397e3a7bbdb31460b1ee1994956920082" translate="yes" xml:space="preserve">
          <source>AbstractSet.hashCode()</source>
          <target state="translated">AbstractSet.hashCode()</target>
        </trans-unit>
        <trans-unit id="fdfb39298a10609fef8d47f8a717e6d55a7abf38" translate="yes" xml:space="preserve">
          <source>AbstractSet.removeAll()</source>
          <target state="translated">AbstractSet.removeAll()</target>
        </trans-unit>
        <trans-unit id="5193d1f46379e92b3fff1156a8e5d576cbf11e36" translate="yes" xml:space="preserve">
          <source>AbstractSpliterator</source>
          <target state="translated">AbstractSpliterator</target>
        </trans-unit>
        <trans-unit id="cd85225c332c52078b4e040cb3f3f56c9bd7c16b" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor6</source>
          <target state="translated">AbstractTypeVisitor6</target>
        </trans-unit>
        <trans-unit id="8b367a677aa40ff6459cfba3ff89e88b9ebe5602" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor6.visit()</source>
          <target state="translated">AbstractTypeVisitor6.visit()</target>
        </trans-unit>
        <trans-unit id="0395e0de3d99663cdc374799a346e705b73de4b4" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor6.visitIntersection()</source>
          <target state="translated">AbstractTypeVisitor6.visitIntersection()</target>
        </trans-unit>
        <trans-unit id="07b2a37d7b9267956365a4ddcc1cbd965e267777" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor6.visitUnion()</source>
          <target state="translated">AbstractTypeVisitor6.visitUnion()</target>
        </trans-unit>
        <trans-unit id="99e7d508b0f1d1a2827328f724bf8d25fe392b42" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor6.visitUnknown()</source>
          <target state="translated">AbstractTypeVisitor6.visitUnknown()</target>
        </trans-unit>
        <trans-unit id="7639675104a2424c9c1d7381962b758fd974c0ea" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor7</source>
          <target state="translated">AbstractTypeVisitor7</target>
        </trans-unit>
        <trans-unit id="36c0a7fa0203902441398f71bcadf572df6121a0" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor7.visitUnion()</source>
          <target state="translated">AbstractTypeVisitor7.visitUnion()</target>
        </trans-unit>
        <trans-unit id="99b86879c91a845e556c962d2c7b9b16c7b5a238" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor8</source>
          <target state="translated">AbstractTypeVisitor8</target>
        </trans-unit>
        <trans-unit id="f0a8746aec6d1f03e2c9907f76409f02a1573ba7" translate="yes" xml:space="preserve">
          <source>AbstractTypeVisitor8.visitIntersection()</source>
          <target state="translated">AbstractTypeVisitor8.visitIntersection()</target>
        </trans-unit>
        <trans-unit id="a83878fe072017f6fe98b08ffc3e8fe9a7e3c547" translate="yes" xml:space="preserve">
          <source>AcceptPendingException</source>
          <target state="translated">AcceptPendingException</target>
        </trans-unit>
        <trans-unit id="9c73b668b53049dffabd71cc4610d86991f7e191" translate="yes" xml:space="preserve">
          <source>Accepts a connection made to this channel's socket.</source>
          <target state="translated">이 채널의 소켓에 대한 연결을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b78375f5f1749b0c4463a1d5ee609178465feb0f" translate="yes" xml:space="preserve">
          <source>Accepts a connection.</source>
          <target state="translated">연결을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="b0ae7fe614d0a5bf55a5d093288b9238f9e92427" translate="yes" xml:space="preserve">
          <source>Accepts a function that extracts a &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; sort key from a type &lt;code&gt;T&lt;/code&gt;, and returns a &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; that compares by that sort key.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 정렬 키 를 추출하고 해당 정렬 키로 &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; 하는 Comparator &amp;lt;T&amp;gt; 를 리턴 하는 함수를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="481c63cc91c699f31c6d214d459026f23f16905a" translate="yes" xml:space="preserve">
          <source>Accepts a function that extracts a &lt;code&gt;double&lt;/code&gt; sort key from a type &lt;code&gt;T&lt;/code&gt;, and returns a &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; that compares by that sort key.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;double&lt;/code&gt; 정렬 키 를 추출하고 해당 정렬 키로 &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; 하는 Comparator &amp;lt;T&amp;gt; 를 반환 하는 함수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="c3ad732e3c6c73828869c44b7c525c6c7269b354" translate="yes" xml:space="preserve">
          <source>Accepts a function that extracts a &lt;code&gt;long&lt;/code&gt; sort key from a type &lt;code&gt;T&lt;/code&gt;, and returns a &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; that compares by that sort key.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;long&lt;/code&gt; 정렬 키 를 추출하고 해당 정렬 키로 &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; 하는 Comparator &amp;lt;T&amp;gt; 를 리턴 하는 함수를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="6ec44a4bb8440dcfcb609dd392df50e849114a5c" translate="yes" xml:space="preserve">
          <source>Accepts a function that extracts a sort key from a type &lt;code&gt;T&lt;/code&gt;, and returns a &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; that compares by that sort key using the specified &lt;a href=&quot;comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에서 정렬 키를 추출 하고 지정된 &lt;a href=&quot;comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; 를&lt;/a&gt; 사용하여 해당 정렬 키로 비교 하는 &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; 를 반환 하는 함수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="388c92a4605575398629e9e04f13a130afbed801" translate="yes" xml:space="preserve">
          <source>Accepts a function that extracts an &lt;code&gt;int&lt;/code&gt; sort key from a type &lt;code&gt;T&lt;/code&gt;, and returns a &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; that compares by that sort key.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; 정렬 키 를 추출하고 해당 정렬 키로 &lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt; 하는 Comparator &amp;lt;T&amp;gt; 를 반환 하는 함수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4e8d413ffb047fa2c343c54f9947292e17e506d1" translate="yes" xml:space="preserve">
          <source>Access checking</source>
          <target state="translated">액세스 점검</target>
        </trans-unit>
        <trans-unit id="a8acba31bfcc1343595abd9bc6ead7252eff60c7" translate="yes" xml:space="preserve">
          <source>Access checks are applied in the factory methods of &lt;code&gt;Lookup&lt;/code&gt;, when a method handle is created. This is a key difference from the Core Reflection API, since &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt; performs access checking against every caller, on every call.</source>
          <target state="translated">메소드 핸들이 작성 될 때 &lt;code&gt;Lookup&lt;/code&gt; 의 팩토리 메소드에 액세스 점검이 적용됩니다 . &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 는 모든 호출에서 모든 호출에 대해 액세스 확인을 수행 하므로 이는 Core Reflection API 와의 주요 차이점입니다 .</target>
        </trans-unit>
        <trans-unit id="5b37760bc4a647d0fd91d279591c6c6b52ec8cda" translate="yes" xml:space="preserve">
          <source>Access indicates a new connection being established using session data. Application level operations, such as getting or setting a value associated with the session, are not reflected in this access time.</source>
          <target state="translated">액세스는 세션 데이터를 사용하여 새 연결이 설정되었음을 나타냅니다. 세션과 관련된 값 가져 오기 또는 설정과 같은 응용 프로그램 수준 작업은이 액세스 시간에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d51f1907709f98d3179437ec07962d3fce65332e" translate="yes" xml:space="preserve">
          <source>Access to binary data</source>
          <target state="translated">이진 데이터에 액세스</target>
        </trans-unit>
        <trans-unit id="b2bba6dc854f93c910b0db62db31560f60b97db7" translate="yes" xml:space="preserve">
          <source>Access to date and time using fields and units, and date time adjusters.</source>
          <target state="translated">필드와 단위 및 날짜 시간 조정자를 사용하여 날짜와 시간에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="94d461797263393103dbc4e9642a73ce523d3a27" translate="yes" xml:space="preserve">
          <source>Access to the declared members of a class</source>
          <target state="translated">선언 된 클래스 멤버에 액세스</target>
        </trans-unit>
        <trans-unit id="b2b574ae0bf69c3ff1b6f50c3e3bf21d71692ea6" translate="yes" xml:space="preserve">
          <source>Access to the program file was denied.</source>
          <target state="translated">프로그램 파일에 대한 액세스가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="61b64b3a93dca53c8680c6d345bb4a3de590ab9e" translate="yes" xml:space="preserve">
          <source>Access to the specified package via a class loader's &lt;code&gt;loadClass&lt;/code&gt; method when that class loader calls the SecurityManager &lt;code&gt;checkPackageAccess&lt;/code&gt; method</source>
          <target state="translated">클래스 로더가 SecurityManager &lt;code&gt;checkPackageAccess&lt;/code&gt; 메소드를 호출 할 때 클래스 로더의 &lt;code&gt;loadClass&lt;/code&gt; 메소드 를 통해 지정된 패키지에 액세스</target>
        </trans-unit>
        <trans-unit id="dff06279225d42ba92cb99b7afbbc61c394fe14e" translate="yes" xml:space="preserve">
          <source>AccessControlContext</source>
          <target state="translated">AccessControlContext</target>
        </trans-unit>
        <trans-unit id="254819f3c87d6d404cf4829a80bf977df827453f" translate="yes" xml:space="preserve">
          <source>AccessControlContext itself has a &lt;code&gt;checkPermission&lt;/code&gt; method that makes access decisions based on the context</source>
          <target state="translated">AccessControlContext 자체에는 컨텍스트를 기반으로 액세스 결정을 내리는 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a8452b8c90def81e4c27d11bfae3bc5cc03b27" translate="yes" xml:space="preserve">
          <source>AccessControlContext.checkPermission()</source>
          <target state="translated">AccessControlContext.checkPermission()</target>
        </trans-unit>
        <trans-unit id="8cde4aaf7d99b472004e93b5aceb5e42f2da758f" translate="yes" xml:space="preserve">
          <source>AccessControlContext.equals()</source>
          <target state="translated">AccessControlContext.equals()</target>
        </trans-unit>
        <trans-unit id="c46880c439bb11c72494b32b564461a3693906a0" translate="yes" xml:space="preserve">
          <source>AccessControlContext.getDomainCombiner()</source>
          <target state="translated">AccessControlContext.getDomainCombiner()</target>
        </trans-unit>
        <trans-unit id="7b61216c67ffeff6170d0f60be169ae96eac6f91" translate="yes" xml:space="preserve">
          <source>AccessControlContext.hashCode()</source>
          <target state="translated">AccessControlContext.hashCode()</target>
        </trans-unit>
        <trans-unit id="a7e5ff6d5ca669ff300527312bdbcdbaeb7373bb" translate="yes" xml:space="preserve">
          <source>AccessControlException</source>
          <target state="translated">AccessControlException</target>
        </trans-unit>
        <trans-unit id="7bc6b612e77f171958bd839e0a3c35851d52b691" translate="yes" xml:space="preserve">
          <source>AccessControlException.getPermission()</source>
          <target state="translated">AccessControlException.getPermission()</target>
        </trans-unit>
        <trans-unit id="81b184ff2734b487d650e26f2652ad99a149e504" translate="yes" xml:space="preserve">
          <source>AccessController</source>
          <target state="translated">AccessController</target>
        </trans-unit>
        <trans-unit id="139fc4971c6b75b67d5328ee13ed356f7aa66043" translate="yes" xml:space="preserve">
          <source>AccessController.checkPermission()</source>
          <target state="translated">AccessController.checkPermission()</target>
        </trans-unit>
        <trans-unit id="f28e22628b086c266067ffd93ebb2014531ecfae" translate="yes" xml:space="preserve">
          <source>AccessController.doPrivileged()</source>
          <target state="translated">AccessController.doPrivileged()</target>
        </trans-unit>
        <trans-unit id="79ef1c0bbe248663dd2a28d9ac5e39f72472c47b" translate="yes" xml:space="preserve">
          <source>AccessController.doPrivilegedWithCombiner()</source>
          <target state="translated">AccessController.doPrivilegedWithCombiner()</target>
        </trans-unit>
        <trans-unit id="55711830943a963b65e0ac87b00c881f55485c7e" translate="yes" xml:space="preserve">
          <source>AccessController.getContext()</source>
          <target state="translated">AccessController.getContext()</target>
        </trans-unit>
        <trans-unit id="062b46dbf1f59a76df58f1a799356641383d7198" translate="yes" xml:space="preserve">
          <source>AccessDeniedException</source>
          <target state="translated">AccessDeniedException</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="57d940879ca961bec94e165313faf6ca03f0c164" translate="yes" xml:space="preserve">
          <source>AccessMode.valueOf()</source>
          <target state="translated">AccessMode.valueOf()</target>
        </trans-unit>
        <trans-unit id="d006992b8769ea8a36da0f96d38a4922ed38ceca" translate="yes" xml:space="preserve">
          <source>AccessMode.values()</source>
          <target state="translated">AccessMode.values()</target>
        </trans-unit>
        <trans-unit id="1b93cd9211c5b36220078df5652314068ad95d25" translate="yes" xml:space="preserve">
          <source>AccessibleObject</source>
          <target state="translated">AccessibleObject</target>
        </trans-unit>
        <trans-unit id="f493fb7b41b34f736a326653e8b0a88be4251ec8" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getAnnotation()</source>
          <target state="translated">AccessibleObject.getAnnotation()</target>
        </trans-unit>
        <trans-unit id="df486ff3589c790816b3f08864fb0eb9bacb0376" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getAnnotations()</source>
          <target state="translated">AccessibleObject.getAnnotations()</target>
        </trans-unit>
        <trans-unit id="8d17b93c7861b9951f9d19d7eeb39ba12aed686f" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getAnnotationsByType()</source>
          <target state="translated">AccessibleObject.getAnnotationsByType()</target>
        </trans-unit>
        <trans-unit id="fbdf94eeb4f743800f56c53021a9ecca9b59f22d" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getDeclaredAnnotation()</source>
          <target state="translated">AccessibleObject.getDeclaredAnnotation()</target>
        </trans-unit>
        <trans-unit id="5bc7741758ff0fab6916af31149246d0e0441754" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getDeclaredAnnotations()</source>
          <target state="translated">AccessibleObject.getDeclaredAnnotations()</target>
        </trans-unit>
        <trans-unit id="3177af612cf4993c316260a542843685284ea718" translate="yes" xml:space="preserve">
          <source>AccessibleObject.getDeclaredAnnotationsByType()</source>
          <target state="translated">AccessibleObject.getDeclaredAnnotationsByType()</target>
        </trans-unit>
        <trans-unit id="aea86ffa2d3ef420101188fc58b91bdb76365b55" translate="yes" xml:space="preserve">
          <source>AccessibleObject.isAccessible()</source>
          <target state="translated">AccessibleObject.isAccessible()</target>
        </trans-unit>
        <trans-unit id="6e7215b61ee77854fca408bd908548366e8d7a03" translate="yes" xml:space="preserve">
          <source>AccessibleObject.isAnnotationPresent()</source>
          <target state="translated">AccessibleObject.isAnnotationPresent()</target>
        </trans-unit>
        <trans-unit id="3c8164b02b25bd9370fde6f02bd2189f08497857" translate="yes" xml:space="preserve">
          <source>AccessibleObject.setAccessible()</source>
          <target state="translated">AccessibleObject.setAccessible()</target>
        </trans-unit>
        <trans-unit id="33c3cc509e185e83dc9e8ea6570f2bc2a19bd4f8" translate="yes" xml:space="preserve">
          <source>AccessibleResourceBundle</source>
          <target state="translated">AccessibleResourceBundle</target>
        </trans-unit>
        <trans-unit id="faea2b2b9f23732de551d63b817292b2599e27d4" translate="yes" xml:space="preserve">
          <source>Accessing Files</source>
          <target state="translated">파일 접근</target>
        </trans-unit>
        <trans-unit id="0b692edb57bae5fe6622642f0deebb58ad1b7a3d" translate="yes" xml:space="preserve">
          <source>Accessing MBeans in the MBean Server</source>
          <target state="translated">MBean 서버에서 MBean에 액세스</target>
        </trans-unit>
        <trans-unit id="63cfcf1fbbdb802eace27ba6ed8669bc6cd6c3d1" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the field of a &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 오브젝트 의 필드에 액세스하거나 수정 합니다.</target>
        </trans-unit>
        <trans-unit id="081b055d444278a91fcdc52fd056525afd4590b2" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the slots of &lt;code&gt;null&lt;/code&gt; as if it were an array.</source>
          <target state="translated">배열 인 것처럼 &lt;code&gt;null&lt;/code&gt; 슬롯에 액세스하거나 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="db3409b8c6da7b770a0bbca84e7397c9e1a2b65b" translate="yes" xml:space="preserve">
          <source>According to a limitation, a relation MBean must be registered in the same MBean Server as the Relation Service expected to handle it. So the user relation MBean has to be created and registered, and then the wrapped RelationSupport object can be created within the identified MBean Server.</source>
          <target state="translated">제한 사항에 따라 관계 MBean은 관계 서비스가 처리 할 것으로 예상되는 것과 동일한 MBean 서버에 등록되어야합니다. 따라서 사용자 관계 MBean을 작성하고 등록한 후 식별 된 MBean 서버 내에 랩핑 된 RelationSupport 오브젝트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64684e952aaccd2a7591e197fd9671d0552b6505" translate="yes" xml:space="preserve">
          <source>According to these rules, the following URIs, for example, are allowed:</source>
          <target state="translated">이러한 규칙에 따라 예를 들어 다음과 같은 URI가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bdb363546105f3a0c3603b759b7fdd58b77be521" translate="yes" xml:space="preserve">
          <source>Accordingly, behavioral parameters in stream pipelines whose source might not be concurrent should never modify the stream's data source. A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent data source if it modifies, or causes to be modified, the stream's data source. The need for non-interference applies to all pipelines, not just parallel ones. Unless the stream source is concurrent, modifying a stream's data source during execution of a stream pipeline can cause exceptions, incorrect answers, or nonconformant behavior. For well-behaved stream sources, the source can be modified before the terminal operation commences and those modifications will be reflected in the covered elements. For example, consider the following code:</source>
          <target state="translated">따라서 소스가 동시 적이 지 않은 스트림 파이프 라인의 동작 매개 변수는 스트림의 데이터 소스를 수정하지 않아야합니다. 행동 매개 변수는 스트림의 데이터 소스를 수정하거나 수정하도록하는 경우 비 동시 데이터 소스 를 &lt;em&gt;방해&lt;/em&gt; 한다고합니다 . 비 간섭의 필요성은 병렬 파이프 라인뿐만 아니라 모든 파이프 라인에 적용됩니다. 스트림 소스가 동시가 아닌 한, 스트림 파이프 라인을 실행하는 동안 스트림의 데이터 소스를 수정하면 예외, 오답 또는 부적합한 동작이 발생할 수 있습니다. 올바르게 작동하는 스트림 소스의 경우 터미널 작업이 시작되기 전에 소스를 수정할 수 있으며 해당 수정 사항은 해당 요소에 반영됩니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0a346af444e15d0398d4fe093e702837261fdda9" translate="yes" xml:space="preserve">
          <source>AccountException</source>
          <target state="translated">AccountException</target>
        </trans-unit>
        <trans-unit id="9a0adf01ddc84bcd149d343e6ab1f94667c16813" translate="yes" xml:space="preserve">
          <source>AccountExpiredException</source>
          <target state="translated">AccountExpiredException</target>
        </trans-unit>
        <trans-unit id="e6785ab672fc4706aef7590352ca06cd26ba6be8" translate="yes" xml:space="preserve">
          <source>AccountLockedException</source>
          <target state="translated">AccountLockedException</target>
        </trans-unit>
        <trans-unit id="1cd067d7c2fb400b9c82a69158a86991654a403a" translate="yes" xml:space="preserve">
          <source>AccountNotFoundException</source>
          <target state="translated">AccountNotFoundException</target>
        </trans-unit>
        <trans-unit id="3f93c4498d3a7255dc50f3077271e29958ccf125" translate="yes" xml:space="preserve">
          <source>Acl</source>
          <target state="translated">Acl</target>
        </trans-unit>
        <trans-unit id="8243bea610b237f1204357258951271b596f9701" translate="yes" xml:space="preserve">
          <source>Acl.addEntry()</source>
          <target state="translated">Acl.addEntry()</target>
        </trans-unit>
        <trans-unit id="2ab9df540831c47e4dd79cf200515682f435f81e" translate="yes" xml:space="preserve">
          <source>Acl.checkPermission()</source>
          <target state="translated">Acl.checkPermission()</target>
        </trans-unit>
        <trans-unit id="a3ba3a3f2fefd699ac438ce03bcc3fc22a17a31e" translate="yes" xml:space="preserve">
          <source>Acl.entries()</source>
          <target state="translated">Acl.entries()</target>
        </trans-unit>
        <trans-unit id="bc646cee0ae8f27b3a4f29035ae7578658d593a0" translate="yes" xml:space="preserve">
          <source>Acl.getName()</source>
          <target state="translated">Acl.getName()</target>
        </trans-unit>
        <trans-unit id="284b37fdf259f5e903e3f99ce184d6e3f4a8d32d" translate="yes" xml:space="preserve">
          <source>Acl.getPermissions()</source>
          <target state="translated">Acl.getPermissions()</target>
        </trans-unit>
        <trans-unit id="2da6b4011c7d3c5cd6f627e4fcc236b7045f0b26" translate="yes" xml:space="preserve">
          <source>Acl.removeEntry()</source>
          <target state="translated">Acl.removeEntry()</target>
        </trans-unit>
        <trans-unit id="98131a58496115cd4aee9f4184357f52ffe515f8" translate="yes" xml:space="preserve">
          <source>Acl.setName()</source>
          <target state="translated">Acl.setName()</target>
        </trans-unit>
        <trans-unit id="dc93218466b04aa022806a7c1a23188f3031a6ba" translate="yes" xml:space="preserve">
          <source>Acl.toString()</source>
          <target state="translated">Acl.toString()</target>
        </trans-unit>
        <trans-unit id="7b68249c56a6e62f33931a0279a85bc61d97b69f" translate="yes" xml:space="preserve">
          <source>AclEntry</source>
          <target state="translated">AclEntry</target>
        </trans-unit>
        <trans-unit id="96c757eda675a71e817f720e8328d5c5a68626c0" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder</source>
          <target state="translated">AclEntry.Builder</target>
        </trans-unit>
        <trans-unit id="6c28f4e531c9f11c4f1d226d361d4cdae7ab6163" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder.build()</source>
          <target state="translated">AclEntry.Builder.build()</target>
        </trans-unit>
        <trans-unit id="7fb029e70fadc162b297f6fbbc746571bc30038c" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder.setFlags()</source>
          <target state="translated">AclEntry.Builder.setFlags()</target>
        </trans-unit>
        <trans-unit id="370cf28a581beb12d42bc49b39147250a4b8724e" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder.setPermissions()</source>
          <target state="translated">AclEntry.Builder.setPermissions()</target>
        </trans-unit>
        <trans-unit id="2eca6f4d58c0ade0fd307ef7deb4833726ba560d" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder.setPrincipal()</source>
          <target state="translated">AclEntry.Builder.setPrincipal()</target>
        </trans-unit>
        <trans-unit id="67c7dae2c10d09296de5c8f2776bacfd3abe484e" translate="yes" xml:space="preserve">
          <source>AclEntry.Builder.setType()</source>
          <target state="translated">AclEntry.Builder.setType()</target>
        </trans-unit>
        <trans-unit id="ad1bf979d813eeb468f4b5eec1cb17a943f083d5" translate="yes" xml:space="preserve">
          <source>AclEntry.addPermission()</source>
          <target state="translated">AclEntry.addPermission()</target>
        </trans-unit>
        <trans-unit id="c7fcd9e5ba408c7c08d5649c6c090ca22bdd8e27" translate="yes" xml:space="preserve">
          <source>AclEntry.checkPermission()</source>
          <target state="translated">AclEntry.checkPermission()</target>
        </trans-unit>
        <trans-unit id="cf861bc243c002bb10063d596919f70da588f891" translate="yes" xml:space="preserve">
          <source>AclEntry.clone()</source>
          <target state="translated">AclEntry.clone()</target>
        </trans-unit>
        <trans-unit id="063bc7f5f18cc2f182da96cf35baacd11240baa2" translate="yes" xml:space="preserve">
          <source>AclEntry.equals()</source>
          <target state="translated">AclEntry.equals()</target>
        </trans-unit>
        <trans-unit id="a513eeb26a7cd751237ea572773974641c17e0ab" translate="yes" xml:space="preserve">
          <source>AclEntry.flags()</source>
          <target state="translated">AclEntry.flags()</target>
        </trans-unit>
        <trans-unit id="70abb79d9321f3e5e1b149d767e766f5febea574" translate="yes" xml:space="preserve">
          <source>AclEntry.getPrincipal()</source>
          <target state="translated">AclEntry.getPrincipal()</target>
        </trans-unit>
        <trans-unit id="58251698263b08d7297c1fe3a8073863e7d208d6" translate="yes" xml:space="preserve">
          <source>AclEntry.hashCode()</source>
          <target state="translated">AclEntry.hashCode()</target>
        </trans-unit>
        <trans-unit id="3f69502b61aae04572e3d1111471fe9e35a56c90" translate="yes" xml:space="preserve">
          <source>AclEntry.isNegative()</source>
          <target state="translated">AclEntry.isNegative()</target>
        </trans-unit>
        <trans-unit id="175a6ef7445c2faeae5bdd1b2dcbe1da6dfcc5d9" translate="yes" xml:space="preserve">
          <source>AclEntry.newBuilder()</source>
          <target state="translated">AclEntry.newBuilder()</target>
        </trans-unit>
        <trans-unit id="0b7ff326723ed083b991a8253334fc46cb57d335" translate="yes" xml:space="preserve">
          <source>AclEntry.permissions()</source>
          <target state="translated">AclEntry.permissions()</target>
        </trans-unit>
        <trans-unit id="046b52a043b9e3b1c4db81757b1f76979a344116" translate="yes" xml:space="preserve">
          <source>AclEntry.principal()</source>
          <target state="translated">AclEntry.principal()</target>
        </trans-unit>
        <trans-unit id="5d1ac50ab2fa0a76410bcb289b929868bd29aae1" translate="yes" xml:space="preserve">
          <source>AclEntry.removePermission()</source>
          <target state="translated">AclEntry.removePermission()</target>
        </trans-unit>
        <trans-unit id="8c50b826ecd2468fe5cdfed9f5453a2411ca3da2" translate="yes" xml:space="preserve">
          <source>AclEntry.setNegativePermissions()</source>
          <target state="translated">AclEntry.setNegativePermissions()</target>
        </trans-unit>
        <trans-unit id="1f3f359e22d671f31a7ec8c2e0681e79b46578b7" translate="yes" xml:space="preserve">
          <source>AclEntry.setPrincipal()</source>
          <target state="translated">AclEntry.setPrincipal()</target>
        </trans-unit>
        <trans-unit id="70ec3c2f7b02e8e6953ff210c8ca55fc600f5268" translate="yes" xml:space="preserve">
          <source>AclEntry.toString()</source>
          <target state="translated">AclEntry.toString()</target>
        </trans-unit>
        <trans-unit id="3a4dfd3f34900a37be35fe42f7c52254445ef2b5" translate="yes" xml:space="preserve">
          <source>AclEntry.type()</source>
          <target state="translated">AclEntry.type()</target>
        </trans-unit>
        <trans-unit id="d9175c356496869f26c8bb1b6b84b0da993aadd7" translate="yes" xml:space="preserve">
          <source>AclEntryFlag</source>
          <target state="translated">AclEntryFlag</target>
        </trans-unit>
        <trans-unit id="32d552cde83e0069c4bebb5f45c94a109f4fd7df" translate="yes" xml:space="preserve">
          <source>AclEntryFlag.valueOf()</source>
          <target state="translated">AclEntryFlag.valueOf()</target>
        </trans-unit>
        <trans-unit id="2ac09f87ceed9454ad12f553290e801147b70225" translate="yes" xml:space="preserve">
          <source>AclEntryFlag.values()</source>
          <target state="translated">AclEntryFlag.values()</target>
        </trans-unit>
        <trans-unit id="193b657d75c40196408ee5f6e4a4a4b1d036ddac" translate="yes" xml:space="preserve">
          <source>AclEntryPermission</source>
          <target state="translated">AclEntryPermission</target>
        </trans-unit>
        <trans-unit id="d1cdea7951b045d4c12d7ee20d77980eb6ee3a8c" translate="yes" xml:space="preserve">
          <source>AclEntryPermission.valueOf()</source>
          <target state="translated">AclEntryPermission.valueOf()</target>
        </trans-unit>
        <trans-unit id="0e230a600ef99aeec5ad833e37e6c6b3a99e02ab" translate="yes" xml:space="preserve">
          <source>AclEntryPermission.values()</source>
          <target state="translated">AclEntryPermission.values()</target>
        </trans-unit>
        <trans-unit id="37342411f9ad79e6bd80b5c4c26e967e1a34c20c" translate="yes" xml:space="preserve">
          <source>AclEntryType</source>
          <target state="translated">AclEntryType</target>
        </trans-unit>
        <trans-unit id="7f00efde80da655b4d490e91315c8ed1a32fa76d" translate="yes" xml:space="preserve">
          <source>AclEntryType.valueOf()</source>
          <target state="translated">AclEntryType.valueOf()</target>
        </trans-unit>
        <trans-unit id="115e76d8f0dc518dbc4a444eda7cf201188a1002" translate="yes" xml:space="preserve">
          <source>AclEntryType.values()</source>
          <target state="translated">AclEntryType.values()</target>
        </trans-unit>
        <trans-unit id="2c2b8c610336e8f20cc8f04d127e53dce83d5734" translate="yes" xml:space="preserve">
          <source>AclFileAttributeView</source>
          <target state="translated">AclFileAttributeView</target>
        </trans-unit>
        <trans-unit id="36b1e7943a89fba7e4058bbfb1c3a0d53f624954" translate="yes" xml:space="preserve">
          <source>AclFileAttributeView.getAcl()</source>
          <target state="translated">AclFileAttributeView.getAcl()</target>
        </trans-unit>
        <trans-unit id="50245d27baa79d7a6b49ab05dbbc272430dff466" translate="yes" xml:space="preserve">
          <source>AclFileAttributeView.name()</source>
          <target state="translated">AclFileAttributeView.name()</target>
        </trans-unit>
        <trans-unit id="74972ad6721d9eecb0ca24acb475fe32413fde3e" translate="yes" xml:space="preserve">
          <source>AclFileAttributeView.setAcl()</source>
          <target state="translated">AclFileAttributeView.setAcl()</target>
        </trans-unit>
        <trans-unit id="04cf5e927d66ec5231fa968a6465bbc62c126408" translate="yes" xml:space="preserve">
          <source>AclNotFoundException</source>
          <target state="translated">AclNotFoundException</target>
        </trans-unit>
        <trans-unit id="a48d5bf4eb218f7cb7b4b86e7a759d1651de809d" translate="yes" xml:space="preserve">
          <source>Acoustic Lab</source>
          <target state="translated">어쿠스틱 랩</target>
        </trans-unit>
        <trans-unit id="fd13f05617a0ee70fc2ff1ecc7e0aed6823ca087" translate="yes" xml:space="preserve">
          <source>Acquires a lock on the given region of this channel's file.</source>
          <target state="translated">이 채널 파일의 지정된 영역에 대한 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="ec224f419e1e61292e3339ddde59f86308d40b2b" translate="yes" xml:space="preserve">
          <source>Acquires a permit from this semaphore, blocking until one is available, or the thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">이 세마포어에서 허가를 얻어 하나를 사용할 수 있거나 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="a454a25d6bfc9d085d91ef0a7340b0232183e663" translate="yes" xml:space="preserve">
          <source>Acquires a permit from this semaphore, blocking until one is available.</source>
          <target state="translated">이 세마포어에서 허가를 얻어 사용 가능할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="3987d8aa949de6097682a4f35a0ef34785e52ec0" translate="yes" xml:space="preserve">
          <source>Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">주어진 대기 시간 내에 하나를 사용할 수 있고 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않은 경우이 세마포어에서 허가를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="65d04db1359cbe4eabdeea8c8ae3df1e923446c5" translate="yes" xml:space="preserve">
          <source>Acquires a permit from this semaphore, only if one is available at the time of invocation.</source>
          <target state="translated">호출 할 때 사용 가능한 경우에만이 세마포어에서 허가를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="78a946f2af5144fed5b86b701630bc260dd66850" translate="yes" xml:space="preserve">
          <source>Acquires a permit, if one is available and returns immediately, reducing the number of available permits by one.</source>
          <target state="translated">사용 가능한 경우 허가를 획득하고 즉시 반환하여 사용 가능한 허가 수를 하나씩 줄입니다.</target>
        </trans-unit>
        <trans-unit id="32892e6eabda3b4a8205f634d39e67ee839e3ded" translate="yes" xml:space="preserve">
          <source>Acquires a permit, if one is available and returns immediately, with the value &lt;code&gt;true&lt;/code&gt;, reducing the number of available permits by one.</source>
          <target state="translated">사용 가능한 경우 허가를 획득하고 즉시 반환하고 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 사용 가능한 허가 수를 1만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c497ff52fb9a68eefbeec644680eb75aafb735a5" translate="yes" xml:space="preserve">
          <source>Acquires an exclusive lock on this channel's file.</source>
          <target state="translated">이 채널 파일에 대한 독점 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="2cb6768919d0ea6751561a44ddc20ab204eecf00" translate="yes" xml:space="preserve">
          <source>Acquires and returns all permits that are immediately available.</source>
          <target state="translated">즉시 사용 가능한 모든 허가를 획득하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0a25a9c97bbaa0765598970f6e03d2b5cd58a81" translate="yes" xml:space="preserve">
          <source>Acquires in exclusive mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt;&lt;code&gt;tryAcquire(long)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt;&lt;code&gt;tryAcquire(long)&lt;/code&gt;&lt;/a&gt; until success or the thread is interrupted. This method can be used to implement method &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt;&lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단독 모드에서 획득하고 중단되면 중단됩니다. 먼저 인터럽트 상태를 확인한 다음 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt; &lt;code&gt;tryAcquire(long)&lt;/code&gt; &lt;/a&gt; 한 번 호출 하여 성공으로 돌아갑니다. 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제 되어 성공하거나 스레드가 중단 될 때까지 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt; &lt;code&gt;tryAcquire(long)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 메소드는 &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt; &lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5448733bbe55e1a5fd3312f90bf2379d19d51441" translate="yes" xml:space="preserve">
          <source>Acquires in exclusive mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt;&lt;code&gt;tryAcquire(int)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt;&lt;code&gt;tryAcquire(int)&lt;/code&gt;&lt;/a&gt; until success or the thread is interrupted. This method can be used to implement method &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt;&lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단독 모드에서 획득하고 중단되면 중단됩니다. 먼저 인터럽트 상태를 확인한 다음 적어도 한 번 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt; &lt;code&gt;tryAcquire(int)&lt;/code&gt; &lt;/a&gt; 를 호출 하여 성공으로 돌아갑니다. 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제 되어 성공하거나 스레드가 중단 될 때까지 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt; &lt;code&gt;tryAcquire(int)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 메소드는 &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt; &lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2863a7b5733ae6053f60547df9b3d08c9c401392" translate="yes" xml:space="preserve">
          <source>Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt;&lt;code&gt;tryAcquire(long)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt;&lt;code&gt;tryAcquire(long)&lt;/code&gt;&lt;/a&gt; until success. This method can be used to implement method &lt;a href=&quot;lock#lock--&quot;&gt;&lt;code&gt;Lock.lock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트를 무시하고 단독 모드로 획득합니다. &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt; &lt;code&gt;tryAcquire(long)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 성공으로 돌아갑니다. 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제가 반복되며 성공할 때까지 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquire-long-&quot;&gt; &lt;code&gt;tryAcquire(long)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 메소드는 &lt;a href=&quot;lock#lock--&quot;&gt; &lt;code&gt;Lock.lock()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efeeeca5fc333af793f60379a59f28f967a74c4a" translate="yes" xml:space="preserve">
          <source>Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt;&lt;code&gt;tryAcquire(int)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt;&lt;code&gt;tryAcquire(int)&lt;/code&gt;&lt;/a&gt; until success. This method can be used to implement method &lt;a href=&quot;lock#lock--&quot;&gt;&lt;code&gt;Lock.lock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트를 무시하고 단독 모드로 획득합니다. &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt; &lt;code&gt;tryAcquire(int)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 성공으로 돌아갑니다. 그렇지 않으면 스레드가 큐에 대기되어 반복적으로 블로킹 및 차단 해제 되어 성공할 때까지 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquire-int-&quot;&gt; &lt;code&gt;tryAcquire(int)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 메소드는 &lt;a href=&quot;lock#lock--&quot;&gt; &lt;code&gt;Lock.lock()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcc06d5d347477e046442847b341a875b77773cc" translate="yes" xml:space="preserve">
          <source>Acquires in shared mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt;&lt;code&gt;tryAcquireShared(long)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt;&lt;code&gt;tryAcquireShared(long)&lt;/code&gt;&lt;/a&gt; until success or the thread is interrupted.</source>
          <target state="translated">공유 모드에서 획득하여 중단되면 중단됩니다. 인터럽트 상태를 먼저 확인한 다음 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt; &lt;code&gt;tryAcquireShared(long)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 성공하면 다시 구현됩니다. 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제 되어 성공 또는 스레드가 중단 될 때까지 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt; &lt;code&gt;tryAcquireShared(long)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="201904652660cd5f81237fe244f3e11d23894713" translate="yes" xml:space="preserve">
          <source>Acquires in shared mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;&lt;/a&gt; until success or the thread is interrupted.</source>
          <target state="translated">공유 모드에서 획득하여 중단되면 중단됩니다. 먼저 인터럽트 상태를 확인한 다음 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt; &lt;code&gt;tryAcquireShared(int)&lt;/code&gt; &lt;/a&gt; 한 번 호출 하여 성공하면 다시 구현됩니다. 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제 되어 성공하거나 스레드가 중단 될 때까지 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt; &lt;code&gt;tryAcquireShared(int)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fe58eb99792ef9339366c50cd49bdc1db7594b37" translate="yes" xml:space="preserve">
          <source>Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt;&lt;code&gt;tryAcquireShared(long)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt;&lt;code&gt;tryAcquireShared(long)&lt;/code&gt;&lt;/a&gt; until success.</source>
          <target state="translated">인터럽트를 무시하고 공유 모드로 확보합니다. 먼저 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt; &lt;code&gt;tryAcquireShared(long)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 성공으로 돌아 감 으로써 구현됩니다 . 그렇지 않으면 스레드가 큐에 대기하여 반복적으로 블로킹 및 차단 해제가 반복되며 성공할 때까지 &lt;a href=&quot;abstractqueuedlongsynchronizer#tryAcquireShared-long-&quot;&gt; &lt;code&gt;tryAcquireShared(long)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="821d560f1dafb70ef9cfcc2ffe88b873c9801d72" translate="yes" xml:space="preserve">
          <source>Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;&lt;/a&gt;, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;&lt;/a&gt; until success.</source>
          <target state="translated">인터럽트를 무시하고 공유 모드로 확보합니다. &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt; &lt;code&gt;tryAcquireShared(int)&lt;/code&gt; &lt;/a&gt; 한 번 이상 호출 하여 성공 하면 다시 구현함으로써 구현됩니다 . 그렇지 않으면 스레드가 큐에 대기되어 반복적으로 블로킹 및 차단 해제가 반복되며 성공할 때까지 &lt;a href=&quot;abstractqueuedsynchronizer#tryAcquireShared-int-&quot;&gt; &lt;code&gt;tryAcquireShared(int)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="de15e1d9501f07b9de2e8411432ecbae21c4b00a" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">이 세마포어에서 지정된 수의 허가를 획득하여 모두 사용 가능하거나 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="b45dbaa210db6d619a1ab16b31a58f0713c191cc" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits from this semaphore, blocking until all are available.</source>
          <target state="translated">이 세마포어에서 지정된 수의 허가를 얻어 모든 것이 가능할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="8ffeba206b7dab10fc8c491fa87ebb0fc3c008e8" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간 내에 모두 사용 가능하고 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않은 경우이 세마포어에서 지정된 수의 허가를 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="f39a259f414d8902d16a7c2cc6205c29d9859d64" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits from this semaphore, only if all are available at the time of invocation.</source>
          <target state="translated">호출시 모든 사용 가능한 경우에만이 세마포어에서 지정된 수의 허가를 획득합니다.</target>
        </trans-unit>
        <trans-unit id="98a31542c2f7ac5fd884214c70ff4580b521e2f1" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits, if they are available and returns immediately, with the value &lt;code&gt;true&lt;/code&gt;, reducing the number of available permits by the given amount.</source>
          <target state="translated">사용 가능한 허가 수를 확보하고 사용 가능한 경우 즉시 반환하고 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 사용 가능한 허가 수를 주어진 양만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c7fe8580a46603a6df73a4d2171b747032ae96c2" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount.</source>
          <target state="translated">사용 가능한 경우 주어진 수의 허가를 획득하고 즉시 반환하여 사용 가능한 허가 수를 주어진 양만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7a179c2e0a4b9f8e101bf2802a3c2348faf895d0" translate="yes" xml:space="preserve">
          <source>Acquires the given number of permits, if they are available, and returns immediately, with the value &lt;code&gt;true&lt;/code&gt;, reducing the number of available permits by the given amount.</source>
          <target state="translated">사용 가능한 경우 지정된 수의 허가를 획득하고 값을 &lt;code&gt;true&lt;/code&gt; 로하여 즉시 반환 하여 사용 가능한 허가 수를 주어진 양만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="302f6120010d90f11395d04c8e436d8fad956195" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is available and returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 잠금을 사용할 수없는 경우이 메소드는 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="46db809e56a32cb1331991098f699321c7a33ff9" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is available and returns immediately.</source>
          <target state="translated">사용 가능한 경우 잠금을 획득하고 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ee58123f070d34bb43ca293a31ea3579bdbaab5" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is free within the given waiting time and the current thread has not been &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간 내에 잠금이 해제되고 현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않은 경우 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="5382e6b72703d4eb9efab12aafd599207e072dc4" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is not held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;, setting the lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to &lt;code&gt;tryLock()&lt;/code&gt;&lt;em&gt;will&lt;/em&gt; immediately acquire the lock if it is available, whether or not other threads are currently waiting for the lock. This &quot;barging&quot; behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use &lt;a href=&quot;reentrantlock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt;&lt;/a&gt; which is almost equivalent (it also detects interruption).</source>
          <target state="translated">잠금이 다른 스레드에 의해 보류되지 않은 경우 잠금을 획득하고 잠금 값 을 1로 설정하여 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴합니다 . 이 잠금이 공정한 주문 정책을 사용하도록 설정되어있는 경우에서도,를 호출 &lt;code&gt;tryLock()&lt;/code&gt; &lt;em&gt;것입니다&lt;/em&gt; 가능한 경우 즉시 다른 thread가 현재 락을 대기하고 있을지 어떨지, 잠금을 획득. 이러한 &quot;바지 다&quot;행동은 공정성을 위반하더라도 특정 상황에서 유용 할 수 있습니다. 이 잠금에 대한 공평성 설정을 유지하려면 &lt;a href=&quot;reentrantlock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt; &lt;/a&gt; 이는 거의 동일합니다 (중단도 감지 함).</target>
        </trans-unit>
        <trans-unit id="b5bc5456a54981a5295e8a7093ee22686f9f03e1" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is not held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;, setting the lock hold count to one. If this lock has been set to use a fair ordering policy then an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads are waiting for the lock. This is in contrast to the &lt;a href=&quot;reentrantlock#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method. If you want a timed &lt;code&gt;tryLock&lt;/code&gt; that does permit barging on a fair lock then combine the timed and un-timed forms together:</source>
          <target state="translated">잠금이 다른 스레드에 의해 보류되지 않은 경우 잠금을 획득하고 잠금 값 을 1로 설정하여 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴합니다 . 이 잠금이 공정한 주문 정책을 사용하도록 설정된 경우, 다른 스레드가 잠금을 기다리고 있으면 사용 가능한 잠금 &lt;em&gt;이&lt;/em&gt; 획득 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이것은 &lt;a href=&quot;reentrantlock#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드 와 대조적 입니다. 공정한 잠금에 참여할 수 있는 시간 제한 &lt;code&gt;tryLock&lt;/code&gt; 을 원하면 시간 제한 양식과 시간 제한이없는 양식을 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="4a6003c888f4f503518c1bf8086cead903f858d3" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one.</source>
          <target state="translated">다른 스레드가 보유하지 않은 경우 잠금을 획득하고 즉시 리턴하여 잠금 보유 수를 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="00721078088aaa0a43240d8d14cfb9c3b2e26581" translate="yes" xml:space="preserve">
          <source>Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간 내에 다른 스레드가 잠금을 보유하지 않고 현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 되지 않은 경우 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="a76f9a3694d4dc94a1e5ecdd51ee0949e30acfb0" translate="yes" xml:space="preserve">
          <source>Acquires the lock only if it is free at the time of invocation.</source>
          <target state="translated">호출시 잠금이 해제 된 경우에만 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="3a7f55f910a4212aa09e5939d6dd3d966eb1ef26" translate="yes" xml:space="preserve">
          <source>Acquires the lock only if it is not held by another thread at the time of invocation.</source>
          <target state="translated">호출시 다른 스레드가 보유하지 않은 경우에만 잠금을 확보합니다.</target>
        </trans-unit>
        <trans-unit id="a44623dc668d229cd8a349ae4a9e486c97c1031c" translate="yes" xml:space="preserve">
          <source>Acquires the lock unless the current thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않는 한 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="dfb041835b7c66870c39c0a59eee8a8d3d6ac4cb" translate="yes" xml:space="preserve">
          <source>Acquires the lock.</source>
          <target state="translated">잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="771e334dae448e3d3292769649abb5ac6306a84d" translate="yes" xml:space="preserve">
          <source>Acquires the read lock if the write lock is not held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;. Even when this lock has been set to use a fair ordering policy, a call to &lt;code&gt;tryLock()&lt;/code&gt;&lt;em&gt;will&lt;/em&gt; immediately acquire the read lock if it is available, whether or not other threads are currently waiting for the read lock. This &quot;barging&quot; behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use &lt;a href=&quot;reentrantreadwritelock.readlock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt;&lt;/a&gt; which is almost equivalent (it also detects interruption).</source>
          <target state="translated">다른 스레드가 쓰기 잠금을 보유하지 않으면 읽기 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 이 잠금은 공정 순서 정책을 사용하도록 설정되어있는 경우에서도,를 호출 &lt;code&gt;tryLock()&lt;/code&gt; &lt;em&gt;것입니다&lt;/em&gt; 가능하면, 다른 thread가 현재 read 락을 기다리고 있습니다 여부를 즉시 읽기 잠금을 획득. 이러한 &quot;바지 다&quot;행동은 공정성을 위반하더라도 특정 상황에서 유용 할 수 있습니다. 이 잠금에 대한 공평성을 설정하려면 &lt;a href=&quot;reentrantreadwritelock.readlock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt; &lt;/a&gt; 이는 거의 동일합니다 (중단도 감지 함).</target>
        </trans-unit>
        <trans-unit id="45bd0c9ff50819247117132116a806e3a669269c" translate="yes" xml:space="preserve">
          <source>Acquires the read lock if the write lock is not held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If this lock has been set to use a fair ordering policy then an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads are waiting for the lock. This is in contrast to the &lt;a href=&quot;reentrantreadwritelock.readlock#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method. If you want a timed &lt;code&gt;tryLock&lt;/code&gt; that does permit barging on a fair lock then combine the timed and un-timed forms together:</source>
          <target state="translated">다른 스레드가 쓰기 잠금을 보유하지 않은 경우 읽기 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 이 잠금이 공정한 주문 정책을 사용하도록 설정된 경우, 다른 스레드가 잠금을 기다리고 있으면 사용 가능한 잠금 &lt;em&gt;이&lt;/em&gt; 획득 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이것은 &lt;a href=&quot;reentrantreadwritelock.readlock#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드 와 대조적 입니다. 공정한 잠금에 참여할 수 있는 시간 제한 &lt;code&gt;tryLock&lt;/code&gt; 을 원하면 시간 제한 양식과 시간 제한이없는 양식을 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="3bf208a7ed72cb8d95ac99da579ff1e35fa1f99c" translate="yes" xml:space="preserve">
          <source>Acquires the read lock if the write lock is not held by another thread and returns immediately.</source>
          <target state="translated">다른 스레드가 쓰기 잠금을 보유하지 않은 경우 읽기 잠금을 획득하고 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8587f051970f9857dda255716dc23271cf0d8191" translate="yes" xml:space="preserve">
          <source>Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간 내에 다른 스레드가 쓰기 잠금을 보유하지 않고 현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않은 경우 읽기 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="da19d53819ecd4d01bf40ae2f69695175c4dbaba" translate="yes" xml:space="preserve">
          <source>Acquires the read lock only if the write lock is not held by another thread at the time of invocation.</source>
          <target state="translated">호출시 다른 스레드가 쓰기 잠금을 보유하지 않은 경우에만 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="0f9ccc0cba74db1581248b90e1ad8bf10411d8c0" translate="yes" xml:space="preserve">
          <source>Acquires the read lock unless the current thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않으면 읽기 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="8620fd69e97742e29cde17c6902c4d8d7005b6e8" translate="yes" xml:space="preserve">
          <source>Acquires the read lock.</source>
          <target state="translated">읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="351baeefe0c9fee2530ebff5178668e988bdfc9d" translate="yes" xml:space="preserve">
          <source>Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">주어진 대기 시간 내에 다른 스레드가 쓰기 잠금을 보유하지 않고 현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 되지 않은 경우 쓰기 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="39501cc5fabb9bd17416cdeacb12c2d6cd29e3ef" translate="yes" xml:space="preserve">
          <source>Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;, setting the write lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to &lt;code&gt;tryLock()&lt;/code&gt;&lt;em&gt;will&lt;/em&gt; immediately acquire the lock if it is available, whether or not other threads are currently waiting for the write lock. This &quot;barging&quot; behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use &lt;a href=&quot;reentrantreadwritelock.writelock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt;&lt;/a&gt; which is almost equivalent (it also detects interruption).</source>
          <target state="translated">읽기 및 쓰기 잠금이 다른 스레드에 의해 유지되지 않으면 쓰기 잠금을 획득하고 쓰기 잠금 유지 계수를 1로 설정하여 값 &lt;code&gt;true&lt;/code&gt; 로 즉시 리턴합니다 . 이 잠금이 공정한 주문 정책을 사용하도록 설정되어있는 경우에서도,를 호출 &lt;code&gt;tryLock()&lt;/code&gt; &lt;em&gt;것입니다&lt;/em&gt; 가능하면, 다른 thread가 현재 기입 락을 기다리고 있습니다 여부를 즉시 잠금을 획득. 이러한 &quot;바지 다&quot;행동은 공정성을 위반하더라도 특정 상황에서 유용 할 수 있습니다. 이 잠금에 대한 공평성을 설정하려면 &lt;a href=&quot;reentrantreadwritelock.writelock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;tryLock(0, TimeUnit.SECONDS) &lt;/code&gt; &lt;/a&gt; 이는 거의 동일합니다 (중단도 감지 함).</target>
        </trans-unit>
        <trans-unit id="2d8f02c79f2e2dca1da96b04492ca7fdd74425b9" translate="yes" xml:space="preserve">
          <source>Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately with the value &lt;code&gt;true&lt;/code&gt;, setting the write lock hold count to one. If this lock has been set to use a fair ordering policy then an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads are waiting for the write lock. This is in contrast to the &lt;a href=&quot;reentrantreadwritelock.writelock#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method. If you want a timed &lt;code&gt;tryLock&lt;/code&gt; that does permit barging on a fair lock then combine the timed and un-timed forms together:</source>
          <target state="translated">읽기 및 쓰기 잠금이 다른 스레드에 의해 유지되지 않으면 쓰기 잠금을 획득하고 쓰기 잠금 유지 계수를 1로 설정하여 값 &lt;code&gt;true&lt;/code&gt; 로 즉시 리턴합니다 . 이 잠금이 공정한 주문 정책을 사용하도록 설정된 경우 다른 스레드가 쓰기 잠금을 기다리고 있으면 사용 가능한 잠금 &lt;em&gt;을 얻지 못합니다&lt;/em&gt; . 이것은 &lt;a href=&quot;reentrantreadwritelock.writelock#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt; 메소드 와 대조적 입니다. 공정한 잠금에 참여할 수 있는 시간 제한 &lt;code&gt;tryLock&lt;/code&gt; 을 원하면 시간 제한 양식과 시간 제한이없는 양식을 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="ead8bcd81a6f9e8d0dcbc1c299d4a88b18e98102" translate="yes" xml:space="preserve">
          <source>Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately, setting the write lock hold count to one.</source>
          <target state="translated">다른 스레드가 읽기 또는 쓰기 잠금을 보유하지 않은 경우 쓰기 잠금을 획득하고 즉시 리턴하여 쓰기 잠금 유지 계수를 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b2b947d6753229f14d8e3c83039da29d43b3b73f" translate="yes" xml:space="preserve">
          <source>Acquires the write lock only if it is not held by another thread at the time of invocation.</source>
          <target state="translated">호출시 다른 스레드가 보유하지 않은 경우에만 쓰기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="7a80eaf4fccd3ae89d2ec59816f034a4b817fc12" translate="yes" xml:space="preserve">
          <source>Acquires the write lock unless the current thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">현재 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되지 않으면 쓰기 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="4020fefdcbd10a0a1282799a0862b705a9d886bb" translate="yes" xml:space="preserve">
          <source>Acquires the write lock.</source>
          <target state="translated">쓰기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="5dd6ab0b5694c45f9ef3f937e27f2feed0937591" translate="yes" xml:space="preserve">
          <source>Action indicating that a coding error is to be handled by dropping the erroneous input and resuming the coding operation.</source>
          <target state="translated">잘못된 입력을 삭제하고 코딩 작업을 다시 시작하여 코딩 오류가 처리됨을 나타내는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="c270c7be0667743b590e650a17fe07ee88e0b7d6" translate="yes" xml:space="preserve">
          <source>Action indicating that a coding error is to be handled by dropping the erroneous input, appending the coder's replacement value to the output buffer, and resuming the coding operation.</source>
          <target state="translated">잘못된 입력을 제거하고, 코더의 대체 값을 출력 버퍼에 추가하고, 코딩 작업을 재개함으로써 코딩 오류가 처리됨을 나타내는 조치.</target>
        </trans-unit>
        <trans-unit id="eba659a70bcaca6330f075f4fc4758ab5d013e40" translate="yes" xml:space="preserve">
          <source>Action indicating that a coding error is to be reported, either by returning a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object or by throwing a &lt;a href=&quot;charactercodingexception&quot;&gt;&lt;code&gt;CharacterCodingException&lt;/code&gt;&lt;/a&gt;, whichever is appropriate for the method implementing the coding process.</source>
          <target state="translated">&lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt; 객체 를 반환 하거나 코딩 프로세스를 구현하는 메서드에 적합한 &lt;a href=&quot;charactercodingexception&quot;&gt; &lt;code&gt;CharacterCodingException&lt;/code&gt; 을&lt;/a&gt; 발생시켜 코딩 오류가보고됨을 나타내는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="d3cdac7dd379f2acad5afb05bcab5b953b529a69" translate="yes" xml:space="preserve">
          <source>Actions in a thread prior to placing an object into any concurrent collection</source>
          <target state="translated">동시 콜렉션에 오브젝트를 배치하기 전에 스레드에서 조치</target>
        </trans-unit>
        <trans-unit id="15474ae92fdaf7a204e7cb4874889eb5211e010c" translate="yes" xml:space="preserve">
          <source>Actions in a thread prior to the submission of a &lt;code&gt;Runnable&lt;/code&gt; to an &lt;code&gt;Executor&lt;/code&gt;</source>
          <target state="translated">a의 제출하기 전에 스레드에서 작업 &lt;code&gt;Runnable&lt;/code&gt; 에 &lt;code&gt;Executor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e829b693931c63c02eeea64334e5aea9dd8390b1" translate="yes" xml:space="preserve">
          <source>Actions prior to &quot;releasing&quot; synchronizer methods such as &lt;code&gt;Lock.unlock&lt;/code&gt;, &lt;code&gt;Semaphore.release&lt;/code&gt;, and &lt;code&gt;CountDownLatch.countDown&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Lock.unlock&lt;/code&gt; , &lt;code&gt;Semaphore.release&lt;/code&gt; 및 &lt;code&gt;CountDownLatch.countDown&lt;/code&gt; 과 같은 동기화 기 메소드를 &quot;릴리스&quot;하기 전의 조치</target>
        </trans-unit>
        <trans-unit id="a0b117ed687e76a2b5e44097630f7ea049c957a0" translate="yes" xml:space="preserve">
          <source>Actions prior to calling &lt;code&gt;CyclicBarrier.await&lt;/code&gt; and &lt;code&gt;Phaser.awaitAdvance&lt;/code&gt; (as well as its variants)</source>
          <target state="translated">&lt;code&gt;CyclicBarrier.await&lt;/code&gt; 및 &lt;code&gt;Phaser.awaitAdvance&lt;/code&gt; ( 및 변형) 를 호출하기 전에 수행 한 조치</target>
        </trans-unit>
        <trans-unit id="bc5b6e17c1e1ca8a7062c5662920c8545d9c0c8d" translate="yes" xml:space="preserve">
          <source>Actions supplied for dependent completions of &lt;em&gt;non-async&lt;/em&gt; methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method.</source>
          <target state="translated">&lt;em&gt;비동기&lt;/em&gt; 가 &lt;em&gt;아닌&lt;/em&gt; 메소드 의 종속 완료를 위해 제공되는 조치 는 현재 CompletableFuture를 완료하는 스레드 또는 완료 메소드의 다른 호출자가 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12002aaa02b42d96fce8df74ae937d8a266a2c9b" translate="yes" xml:space="preserve">
          <source>Actions taken by the asynchronous computation represented by a &lt;code&gt;Future&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Future&lt;/code&gt; 대표되는 비동기 계산에 의해 취해진 조치</target>
        </trans-unit>
        <trans-unit id="0c3b502c35c5b58d0c05502e41dea80db580812b" translate="yes" xml:space="preserve">
          <source>Activate, and/or mark Applet active. Implementors of this interface shall mark this Applet as active, and optionally invoke its start() method.</source>
          <target state="translated">애플릿을 활성화 및 / 또는 표시합니다. 이 인터페이스의 구현자는,이 애플릿을 액티브로 표시해, 선택적으로 start () 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6a5a156f6b9dadae2b4ebd002d376fde0373e3a2" translate="yes" xml:space="preserve">
          <source>Activates the connector server, that is starts listening for client connections. Calling this method when the connector server is already active has no effect. Calling this method when the connector server has been stopped will generate an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">클라이언트 연결을 수신하기 시작하는 커넥터 서버를 활성화합니다. 커넥터 서버가 이미 활성 상태 일 때이 메소드를 호출해도 효과가 없습니다. 커넥터 서버가 중지되었을 때이 메소드를 호출하면 &lt;code&gt;IOException&lt;/code&gt; 이 생성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="808d7af3c9545e6a91abea71b320a8943f7b38e2" translate="yes" xml:space="preserve">
          <source>Activates the connector server, that is, starts listening for client connections. Calling this method when the connector server is already active has no effect. Calling this method when the connector server has been stopped will generate an &lt;a href=&quot;../../../java/io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커넥터 서버를 활성화합니다. 즉, 클라이언트 연결 수신을 시작합니다. 커넥터 서버가 이미 활성 상태 일 때이 메소드를 호출해도 효과가 없습니다. 커넥터 서버가 중지되었을 때이 메소드를 호출하면 &lt;a href=&quot;../../../java/io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 이 생성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7989f5c2152e852a72fe28ea80aeecc67bf23d1f" translate="yes" xml:space="preserve">
          <source>Activates the controller. If &lt;code&gt;true&lt;/code&gt; is returned, all settings in the &lt;code&gt;IIOMetadata&lt;/code&gt; object should be ready for use in a write operation. If &lt;code&gt;false&lt;/code&gt; is returned, no settings in the &lt;code&gt;IIOMetadata&lt;/code&gt; object will be disturbed (</source>
          <target state="translated">컨트롤러를 활성화합니다. 경우 &lt;code&gt;true&lt;/code&gt; 반환되면, 모든 설정 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체는 쓰기 작업에 사용하기위한 준비를해야합니다. 경우 &lt;code&gt;false&lt;/code&gt; 리턴됩니다에는 설정 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체는 방해되지 않습니다 (</target>
        </trans-unit>
        <trans-unit id="073f319a1e8a35558cb36885a8033748afd3eaa3" translate="yes" xml:space="preserve">
          <source>Activates the controller. If &lt;code&gt;true&lt;/code&gt; is returned, all settings in the &lt;code&gt;IIOParam&lt;/code&gt; object should be ready for use in a read or write operation. If &lt;code&gt;false&lt;/code&gt; is returned, no settings in the &lt;code&gt;IIOParam&lt;/code&gt; object will be disturbed (</source>
          <target state="translated">컨트롤러를 활성화합니다. 경우 &lt;code&gt;true&lt;/code&gt; 로 리턴됩니다의 모든 설정 &lt;code&gt;IIOParam&lt;/code&gt; 의 객체는 읽기 또는 쓰기 작업에 사용하기위한 준비를해야합니다. 경우 &lt;code&gt;false&lt;/code&gt; 리턴됩니다에는 설정 &lt;code&gt;IIOParam&lt;/code&gt; 의 목적은 방해되지 않습니다 (</target>
        </trans-unit>
        <trans-unit id="b8065e378d5bbccf29961f23d04b50dccec57136" translate="yes" xml:space="preserve">
          <source>Activates the installed &lt;code&gt;IIOMetadataController&lt;/code&gt; for this &lt;code&gt;IIOMetadata&lt;/code&gt; object and returns the resulting value. When this method returns &lt;code&gt;true&lt;/code&gt;, all values for this &lt;code&gt;IIOMetadata&lt;/code&gt; object will be ready for the next write operation. If &lt;code&gt;false&lt;/code&gt; is returned, no settings in this object will have been disturbed (</source>
          <target state="translated">이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체에 대해 설치된 &lt;code&gt;IIOMetadataController&lt;/code&gt; 를 활성화하고 결과 값을 반환합니다. 이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 돌려 주면 (자) ,이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체의 모든 값 은 다음의 기입 조작을위한 준비가됩니다. 경우 &lt;code&gt;false&lt;/code&gt; 리턴되며,이 오브젝트에는 설정이 방해되어 있지 않은 것 (</target>
        </trans-unit>
        <trans-unit id="b99bf920733fed862fc08ad6386936376f25a1c4" translate="yes" xml:space="preserve">
          <source>Activates the installed &lt;code&gt;IIOParamController&lt;/code&gt; for this &lt;code&gt;IIOParam&lt;/code&gt; object and returns the resulting value. When this method returns &lt;code&gt;true&lt;/code&gt;, all values for this &lt;code&gt;IIOParam&lt;/code&gt; object will be ready for the next read or write operation. If &lt;code&gt;false&lt;/code&gt; is returned, no settings in this object will have been disturbed (</source>
          <target state="translated">이 &lt;code&gt;IIOParam&lt;/code&gt; 객체에 대해 설치된 &lt;code&gt;IIOParamController&lt;/code&gt; 를 활성화하고 결과 값을 반환합니다. 이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 &lt;code&gt;IIOParam&lt;/code&gt; 객체의 모든 값 은 다음의 읽기 또는 쓰기 조작을위한 준비가됩니다. 경우 &lt;code&gt;false&lt;/code&gt; 리턴되며,이 오브젝트에는 설정이 방해되어 있지 않은 것 (</target>
        </trans-unit>
        <trans-unit id="8a151a3acf240ec7e9e0d937723674da62c3cbeb" translate="yes" xml:space="preserve">
          <source>Adapts a &lt;code&gt;Collector&lt;/code&gt; accepting elements of type &lt;code&gt;U&lt;/code&gt; to one accepting elements of type &lt;code&gt;T&lt;/code&gt; by applying a mapping function to each input element before accumulation.</source>
          <target state="translated">적응은 &lt;code&gt;Collector&lt;/code&gt; 형 소자 수용 &lt;code&gt;U&lt;/code&gt; 형 중 하나로 수락 요소 &lt;code&gt;T&lt;/code&gt; 를 축적하기 전에 각 입력 요소에 매핑 함수를 적용.</target>
        </trans-unit>
        <trans-unit id="fda1fc713397b0eea69b3c8ee2043a1cf2a480d6" translate="yes" xml:space="preserve">
          <source>Adapts a &lt;code&gt;Collector&lt;/code&gt; to perform an additional finishing transformation. For example, one could adapt the &lt;a href=&quot;collectors#toList--&quot;&gt;&lt;code&gt;toList()&lt;/code&gt;&lt;/a&gt; collector to always produce an immutable list with:</source>
          <target state="translated">적응 &lt;code&gt;Collector&lt;/code&gt; 추가로 가공 변환을 수행. 예를 들어, &lt;a href=&quot;collectors#toList--&quot;&gt; &lt;code&gt;toList()&lt;/code&gt; &lt;/a&gt; 콜렉터를 다음과 같이 항상 불변 목록을 생성 하도록 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d393e1e8c924d1d35466f60c6d1b1cb47ee4618" translate="yes" xml:space="preserve">
          <source>Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle). The result of the filter is returned from the adapter.</source>
          <target state="translated">필터 (다른 메소드 핸들)를 사용하여 리턴 값 (있는 경우)을 후 처리하여 대상 메소드 핸들을 조정합니다. 필터 결과가 어댑터에서 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2e2cc51b761ab1ea1519ea83ed24e4cf322c4b6b" translate="yes" xml:space="preserve">
          <source>Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle). The pre-processed arguments are replaced by the result (if any) of the filter function. The target is then called on the modified (usually shortened) argument list.</source>
          <target state="translated">필터를 사용하여 인수의 하위 시퀀스를 사전 처리하여 대상 메소드 핸들을 조정합니다 (다른 메소드 핸들). 사전 처리 된 인수는 필터 함수의 결과 (있는 경우)로 대체됩니다. 그런 다음 수정 된 (일반적으로 단축 된) 인수 목록에서 대상이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d38e99a7406843fb0602f5c6585eb1d91eee852a" translate="yes" xml:space="preserve">
          <source>Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function.</source>
          <target state="translated">하나 이상의 인수를 각각 고유 한 단항 필터 함수로 사전 처리 한 다음 사전 처리 된 각 인수를 해당 필터 함수의 결과로 대체하여 대상을 호출하여 대상 메소드 핸들을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="23a7c5fef350b4b7d1794aedeb47010bb9cb66d7" translate="yes" xml:space="preserve">
          <source>Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments.</source>
          <target state="translated">인수의 일부를 전처리 한 후 원래 처리 순서로 삽입 된 전처리 결과로 대상을 호출하여 대상 메소드 핸들을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="896dc2f0b9b92cef951d4a24972d76fc25156744" translate="yes" xml:space="preserve">
          <source>Add a PropertyChangeListener for a specific property. The listener will be invoked only when a call on firePropertyChange names that specific property. The same listener object may be added more than once. For each property, the listener will be invoked the number of times it was added for that property. If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">특정의 프로퍼티의 PropertyChangeListener를 추가합니다. 리스너는 firePropertyChange에 대한 호출이 해당 특정 특성의 이름을 지정할 때만 호출됩니다. 동일한 리스너 객체가 두 번 이상 추가 될 수 있습니다. 각 속성에 대해 해당 속성에 대해 리스너가 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;propertyName&lt;/code&gt; 형식 또는 &lt;code&gt;listener&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21c11668e768deea9f95a750c8a4e8eb1871fc75" translate="yes" xml:space="preserve">
          <source>Add a PropertyChangeListener for a specific property. The same listener object may be added more than once. For each property, the listener will be invoked the number of times it was added for that property. If &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;pcl&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">특정의 프로퍼티의 PropertyChangeListener를 추가합니다. 동일한 리스너 객체가 두 번 이상 추가 될 수 있습니다. 각 속성에 대해 해당 속성에 대해 리스너가 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;name&lt;/code&gt; 또는 &lt;code&gt;pcl&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d65e78a39caf3ad8f41cb6f63fd641f1c524585" translate="yes" xml:space="preserve">
          <source>Add a PropertyChangeListener to the listener list. The listener is registered for all properties. The same listener object may be added more than once, and will be called as many times as it is added. If &lt;code&gt;listener&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">리스너 목록에 PropertyChangeListener를 추가하십시오. 리스너는 모든 속성에 등록됩니다. 동일한 리스너 객체는 두 번 이상 추가 될 수 있으며 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;listener&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e181428ba72e1632ba56ed3d27d00d86628ddd2" translate="yes" xml:space="preserve">
          <source>Add a VetoableChangeListener for a specific property. The listener will be invoked only when a call on fireVetoableChange names that specific property. The same listener object may be added more than once. For each property, the listener will be invoked the number of times it was added for that property. If &lt;code&gt;propertyName&lt;/code&gt; or &lt;code&gt;listener&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">특정 속성에 VetoableChangeListener를 추가하십시오. 리스너는 fireVetoableChange에 대한 호출이 해당 특정 특성의 이름을 지정할 때만 호출됩니다. 동일한 리스너 객체가 두 번 이상 추가 될 수 있습니다. 각 속성에 대해 해당 속성에 대해 리스너가 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;propertyName&lt;/code&gt; 형식 또는 &lt;code&gt;listener&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea5241de2af1c1431726fc5070c56bf3805c54fb" translate="yes" xml:space="preserve">
          <source>Add a VetoableChangeListener for a specific property. The same listener object may be added more than once. For each property, the listener will be invoked the number of times it was added for that property. If &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;vcl&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">특정 속성에 VetoableChangeListener를 추가하십시오. 동일한 리스너 객체가 두 번 이상 추가 될 수 있습니다. 각 속성에 대해 해당 속성에 대해 리스너가 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;name&lt;/code&gt; 또는 &lt;code&gt;vcl&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63e2e42bfc97c71ead9dc8b0dee50f004d1de234" translate="yes" xml:space="preserve">
          <source>Add a VetoableChangeListener to the listener list. The listener is registered for all properties. The same listener object may be added more than once, and will be called as many times as it is added. If &lt;code&gt;listener&lt;/code&gt; is null, no exception is thrown and no action is taken.</source>
          <target state="translated">리스너 목록에 VetoableChangeListener를 추가하십시오. 리스너는 모든 속성에 등록됩니다. 동일한 리스너 객체는 두 번 이상 추가 될 수 있으며 추가 된 횟수만큼 호출됩니다. 경우 &lt;code&gt;listener&lt;/code&gt; null의 경우, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62a7a14f4480dd566b270aa61358dad3d802d658" translate="yes" xml:space="preserve">
          <source>Add a log Handler to receive logging messages.</source>
          <target state="translated">로깅 메시지를 수신하려면 로그 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="96b9a97a8da357576f084bf0c6e5b63adde210ac" translate="yes" xml:space="preserve">
          <source>Add a named logger. This does nothing and returns false if a logger with the same name is already registered.</source>
          <target state="translated">명명 된 로거를 추가하십시오. 이름이 같은 로거가 이미 등록되어 있으면 아무것도하지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f4ecb07f6f15c265d68e77f63ecb35a0782342a" translate="yes" xml:space="preserve">
          <source>Add a role info. This method of course should not be used after the creation of the relation type, because updating it would invalidate that the relations created associated to that type still conform to it. Can throw a RuntimeException if trying to update a relation type declared in the Relation Service.</source>
          <target state="translated">역할 정보를 추가하십시오. 이 방법은 관계 유형을 만든 후에는 사용하지 않아야합니다. 관계 유형을 업데이트하면 해당 유형과 관련하여 생성 된 관계가 여전히 해당 유형을 준수하는 것이 무효화됩니다. 관계 서비스에 선언 된 관계 유형을 업데이트하려는 경우 RuntimeException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c77ec0ff033f148a51acf4d54d3df44384d4369" translate="yes" xml:space="preserve">
          <source>Add a service. If a service of the same type with the same algorithm name exists and it was added using &lt;a href=&quot;provider#putService-java.security.Provider.Service-&quot;&gt;&lt;code&gt;putService()&lt;/code&gt;&lt;/a&gt;, it is replaced by the new service. This method also places information about this service in the provider's Hashtable values in the format described in the  Java Cryptography Architecture API Specification &amp;amp; Reference .</source>
          <target state="translated">서비스를 추가하십시오. 동일한 알고리즘 이름을 가진 동일한 유형의 서비스가 존재하고 &lt;a href=&quot;provider#putService-java.security.Provider.Service-&quot;&gt; &lt;code&gt;putService()&lt;/code&gt; &lt;/a&gt; 사용하여 추가 된 서비스는 새로운 서비스로 대체됩니다. 이 메소드는이 서비스에 대한 정보를 Java 암호화 아키텍처 API 스펙 및 참조 서에 설명 된 형식으로 제공자의 Hashtable 값에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="1eb528e480b32cb5ce8c77eafef0ace62d028751" translate="yes" xml:space="preserve">
          <source>Add all the elements in &lt;var&gt;values&lt;/var&gt; to this &lt;code&gt;TabularData&lt;/code&gt; instance. If any element in &lt;var&gt;values&lt;/var&gt; does not satisfy the constraints defined in &lt;a href=&quot;tabulardata#put-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;&lt;code&gt;put&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;, or if any two elements in &lt;var&gt;values&lt;/var&gt; have the same index calculated according to this &lt;code&gt;TabularData&lt;/code&gt; instance's &lt;code&gt;TabularType&lt;/code&gt; definition, then an exception describing the failure is thrown and no element of &lt;var&gt;values&lt;/var&gt; is added, thus leaving this &lt;code&gt;TabularData&lt;/code&gt; instance unchanged.</source>
          <target state="translated">&lt;var&gt;values&lt;/var&gt; 모든 요소 를이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스 에 추가하십시오 . 어떤 요소 경우 &lt;var&gt;values&lt;/var&gt; 에 정의 된 제약을 만족하지 않는 &lt;a href=&quot;tabulardata#put-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;&lt;code&gt;put&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 어느 두 요소 경우 또는 &lt;var&gt;values&lt;/var&gt; 이에 따라 계산 동일한 인덱스가 &lt;code&gt;TabularData&lt;/code&gt; 의 인스턴스의 &lt;code&gt;TabularType&lt;/code&gt; 의의 정의를, 그 실패를 나타내는 예외를 발생하고, 어떠한 요소 &lt;var&gt;values&lt;/var&gt; 추가되지 않으며, 따라서이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스를 변경하지 않은 채로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="1c9a5d03924c38cd8848dcc8fe67380a3cbf66a8" translate="yes" xml:space="preserve">
          <source>Add all the elements in &lt;var&gt;values&lt;/var&gt; to this &lt;code&gt;TabularData&lt;/code&gt; instance. If any element in &lt;var&gt;values&lt;/var&gt; does not satisfy the constraints defined in &lt;a href=&quot;tabulardatasupport#put-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;&lt;code&gt;put&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;, or if any two elements in &lt;var&gt;values&lt;/var&gt; have the same index calculated according to this &lt;code&gt;TabularData&lt;/code&gt; instance's &lt;code&gt;TabularType&lt;/code&gt; definition, then an exception describing the failure is thrown and no element of &lt;var&gt;values&lt;/var&gt; is added, thus leaving this &lt;code&gt;TabularData&lt;/code&gt; instance unchanged.</source>
          <target state="translated">&lt;var&gt;values&lt;/var&gt; 모든 요소 를이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스 에 추가하십시오 . 어떤 요소 경우 &lt;var&gt;values&lt;/var&gt; 에 정의 된 제약을 만족하지 않는 &lt;a href=&quot;tabulardatasupport#put-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;&lt;code&gt;put&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 어느 두 요소 경우 또는 &lt;var&gt;values&lt;/var&gt; 이에 따라 계산 동일한 인덱스가 &lt;code&gt;TabularData&lt;/code&gt; 의 인스턴스의 &lt;code&gt;TabularType&lt;/code&gt; 의의 정의를, 그 실패를 나타내는 예외를 발생하고, 어떠한 요소 &lt;var&gt;values&lt;/var&gt; 추가되지 않으며, 따라서이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스를 변경하지 않은 채로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="212a9304ccfe5f94100eb235220aaa874e8a6ec6" translate="yes" xml:space="preserve">
          <source>Add all the values contained in the specified map &lt;var&gt;t&lt;/var&gt; to this &lt;code&gt;TabularData&lt;/code&gt; instance. This method converts the collection of values contained in this map into an array of &lt;code&gt;CompositeData&lt;/code&gt; values, if possible, and then call the method &lt;code&gt;putAll(CompositeData[])&lt;/code&gt;. Note that the keys used in the specified map &lt;var&gt;t&lt;/var&gt; are ignored. This method allows, for example to add the content of another &lt;code&gt;TabularData&lt;/code&gt; instance with the same row type (but possibly different index names) into this instance.</source>
          <target state="translated">지정된 맵 &lt;var&gt;t&lt;/var&gt; 에 포함 된 모든 값 을이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스에 추가합니다. 이 메소드는이 맵에 포함 된 값의 콜렉션을 가능하면 &lt;code&gt;CompositeData&lt;/code&gt; 값 의 배열로 변환 한 다음 &lt;code&gt;putAll(CompositeData[])&lt;/code&gt; 메소드를 호출합니다 . 지정된 맵 &lt;var&gt;t&lt;/var&gt; 에 사용 된 키 는 무시됩니다. 예를 &lt;code&gt;TabularData&lt;/code&gt; 메서드를 사용하면 행 유형이 같지만 색인 이름 이 다른 다른 TabularData 인스턴스 의 내용 을이 인스턴스에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b48942949ba774e5345bfca9f5e7fbef30755e58" translate="yes" xml:space="preserve">
          <source>Add components from 'name' as the last components in remaining name.</source>
          <target state="translated">나머지 이름의 마지막 구성 요소로 'name'의 구성 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="bef5193f5dce6ed63113aa8fca52e7bd63955105" translate="yes" xml:space="preserve">
          <source>Add name as the last component in remaining name.</source>
          <target state="translated">나머지 이름의 마지막 구성 요소로 이름을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3fb731dd06897e3ac30bf931ef1c4347c98f2457" translate="yes" xml:space="preserve">
          <source>Add the input months to the month-of-year field</source>
          <target state="translated">입력 월을 월 필드에 추가</target>
        </trans-unit>
        <trans-unit id="0bc52e2df30d656ed8e4f86c0ab838e3f27d4374" translate="yes" xml:space="preserve">
          <source>Add the input years to the year field</source>
          <target state="translated">연도 필드에 입력 연도 추가</target>
        </trans-unit>
        <trans-unit id="58a5092d7fddaef117efe0ddd8794d99b2bc5bb9" translate="yes" xml:space="preserve">
          <source>Adding New Calendars</source>
          <target state="translated">새 캘린더 추가</target>
        </trans-unit>
        <trans-unit id="c5a03d97ab81f232a2b600b00a6e1d5383072463" translate="yes" xml:space="preserve">
          <source>Adding one hour to 00:30+02:00 will result in 01:30+02:00</source>
          <target state="translated">00 : 30 + 02 : 00에 1 시간을 추가하면 01 : 30 + 02 : 00가됩니다.</target>
        </trans-unit>
        <trans-unit id="e83c0f2a3315ed557f91576cf123a3476bece953" translate="yes" xml:space="preserve">
          <source>Adding one hour to 01:30+01:00 will result in 02:30+01:00</source>
          <target state="translated">01 : 30 + 01 : 00에 1 시간을 추가하면 02 : 30 + 01 : 00이됩니다.</target>
        </trans-unit>
        <trans-unit id="170ff1a374477970fb940293ae6c55119a6af1dd" translate="yes" xml:space="preserve">
          <source>Adding one hour to 01:30+02:00 will result in 01:30+01:00</source>
          <target state="translated">01 : 30 + 02 : 00에 1 시간을 추가하면 01 : 30 + 01 : 00가됩니다.</target>
        </trans-unit>
        <trans-unit id="dfd8427218c4cfe4669499b30c86c69308d5e030" translate="yes" xml:space="preserve">
          <source>Adding three hours to 00:30+02:00 will result in 02:30+01:00</source>
          <target state="translated">00 : 30 + 02 : 00에 3 시간을 추가하면 02 : 30 + 01 : 00이됩니다.</target>
        </trans-unit>
        <trans-unit id="7c8927229825e54692143a5f37f0767762b1c591" translate="yes" xml:space="preserve">
          <source>Addition of a certificate for an Identity</source>
          <target state="translated">아이디에 대한 인증서 추가</target>
        </trans-unit>
        <trans-unit id="c55eb4e267d5341753c1fbd772177c7e1c2b66a9" translate="yes" xml:space="preserve">
          <source>Addition of a new provider</source>
          <target state="translated">새로운 공급자 추가</target>
        </trans-unit>
        <trans-unit id="d02fd2d98d334c219398cfa2ad787b28a0ef793b" translate="yes" xml:space="preserve">
          <source>Addition of a new provider, with the specified name</source>
          <target state="translated">지정된 이름을 가진 새로운 공급자 추가</target>
        </trans-unit>
        <trans-unit id="196e80fef13594e57d57220887f4943702ca308b" translate="yes" xml:space="preserve">
          <source>Additional (implementation specific) options may also be supported.</source>
          <target state="translated">추가 (구현 특정) 옵션도 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48429a57cfdfc1a0ef33220c833755425da66506" translate="yes" xml:space="preserve">
          <source>Additional Specification</source>
          <target state="translated">추가 사양</target>
        </trans-unit>
        <trans-unit id="d587511f359113d8112463a9f721433a1ebfdbad" translate="yes" xml:space="preserve">
          <source>Additional Unicode line terminators may be recognized in future releases.</source>
          <target state="translated">향후 릴리스에서는 추가 유니 코드 줄 종결자가 인식 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="606918f33c44f76262c39d01fe2bbf1fa76c59a3" translate="yes" xml:space="preserve">
          <source>Additional calendar systems may be added to the system. See &lt;a href=&quot;chronology&quot;&gt;&lt;code&gt;Chronology&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">추가 캘린더 시스템이 시스템에 추가 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;chronology&quot;&gt; &lt;code&gt;Chronology&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca3e74a85f3143195dfaa0103288e1143e5b7fbc" translate="yes" xml:space="preserve">
          <source>Additional client or server parameters</source>
          <target state="translated">추가 클라이언트 또는 서버 매개 변수</target>
        </trans-unit>
        <trans-unit id="4ec31180d6e5a53faa23efe2fa4034d3107c6721" translate="yes" xml:space="preserve">
          <source>Additional improvements of such classes might entail precomputing pending counts so that they can be established in constructors, specializing classes for leaf steps, subdividing by say, four, instead of two per iteration, and using an adaptive threshold instead of always subdividing down to single elements.</source>
          <target state="translated">이러한 클래스의 추가 개선은 생성자에서 설정 될 수 있도록 사전 계산 보류 카운트를 수반하여 리프 단계에 대한 클래스를 전문화하고, 반복마다 2 개 대신 4 개로 세분화하며 항상 단일 요소로 세분화하는 대신 적응 임계 값을 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="985bcb2d22d7cf99ddb89d884a9f82a03af6fe8e" translate="yes" xml:space="preserve">
          <source>Additional information can be obtained from the &lt;code&gt;DayOfWeek&lt;/code&gt;. This includes textual names of the values.</source>
          <target state="translated">추가 정보는 &lt;code&gt;DayOfWeek&lt;/code&gt; 에서 얻을 수 있습니다 . 여기에는 값의 텍스트 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dbedbc45b66262d496c80aeb2c2ca7d9c281f1d7" translate="yes" xml:space="preserve">
          <source>Additional input parameters required for executing the check may be specified through constructors of concrete implementations of this class.</source>
          <target state="translated">검사를 실행하는 데 필요한 추가 입력 매개 변수는이 클래스의 구체적인 구현 생성자를 통해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51dc184fe44eb7de9f87c2cbbab054858b03f2f5" translate="yes" xml:space="preserve">
          <source>Additional metadata for a JMX element.</source>
          <target state="translated">JMX 요소에 대한 추가 메타 데이터.</target>
        </trans-unit>
        <trans-unit id="defc5414337d7f2fd31b2a7cee124f837eda92e5" translate="yes" xml:space="preserve">
          <source>Additional metadata for a JMX element. A &lt;code&gt;Descriptor&lt;/code&gt; is associated with a &lt;a href=&quot;mbeaninfo&quot;&gt;&lt;code&gt;MBeanInfo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt;, etc. It consists of a collection of fields. A field is a name and an associated value.</source>
          <target state="translated">JMX 요소에 대한 추가 메타 데이터. &lt;code&gt;Descriptor&lt;/code&gt; 와 연관된 &lt;a href=&quot;mbeaninfo&quot;&gt; &lt;code&gt;MBeanInfo&lt;/code&gt; 에&lt;/a&gt; , &lt;a href=&quot;mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt; IT 영역의 집합으로 구성 등. 필드는 이름과 관련 값입니다.</target>
        </trans-unit>
        <trans-unit id="422beee551f0cd7cc30cb5641d7d926c0251679a" translate="yes" xml:space="preserve">
          <source>Additional methods that depend on the presence or absence of a contained value are provided, such as &lt;a href=&quot;optional#orElse-T-&quot;&gt;&lt;code&gt;orElse()&lt;/code&gt;&lt;/a&gt; (return a default value if value not present) and &lt;a href=&quot;optional#ifPresent-java.util.function.Consumer-&quot;&gt;&lt;code&gt;ifPresent()&lt;/code&gt;&lt;/a&gt; (execute a block of code if the value is present).</source>
          <target state="translated">&lt;a href=&quot;optional#orElse-T-&quot;&gt; &lt;code&gt;orElse()&lt;/code&gt; &lt;/a&gt; (값이 없으면 기본값을 반환 함) 및 &lt;a href=&quot;optional#ifPresent-java.util.function.Consumer-&quot;&gt; &lt;code&gt;ifPresent()&lt;/code&gt; &lt;/a&gt; (값이 있으면 코드 블록을 실행 함 ) 와 같이 포함 된 값의 존재 여부에 의존하는 추가 메소드가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe6d02177dc1f996e6a20df9112c450c35ef9a55" translate="yes" xml:space="preserve">
          <source>Additional methods that depend on the presence or absence of a contained value are provided, such as &lt;a href=&quot;optionaldouble#orElse-double-&quot;&gt;&lt;code&gt;orElse()&lt;/code&gt;&lt;/a&gt; (return a default value if value not present) and &lt;a href=&quot;optionaldouble#ifPresent-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;ifPresent()&lt;/code&gt;&lt;/a&gt; (execute a block of code if the value is present).</source>
          <target state="translated">&lt;a href=&quot;optionaldouble#orElse-double-&quot;&gt; &lt;code&gt;orElse()&lt;/code&gt; &lt;/a&gt; (값이 없으면 기본값을 반환 함) 및 &lt;a href=&quot;optionaldouble#ifPresent-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;ifPresent()&lt;/code&gt; &lt;/a&gt; (값이 있으면 코드 블록을 실행 함 ) 와 같이 포함 된 값의 존재 여부에 의존하는 추가 메소드가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f9d4c2db7a3d6acad6c2570adc46164b3baffe7" translate="yes" xml:space="preserve">
          <source>Additional methods that depend on the presence or absence of a contained value are provided, such as &lt;a href=&quot;optionalint#orElse-int-&quot;&gt;&lt;code&gt;orElse()&lt;/code&gt;&lt;/a&gt; (return a default value if value not present) and &lt;a href=&quot;optionalint#ifPresent-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;ifPresent()&lt;/code&gt;&lt;/a&gt; (execute a block of code if the value is present).</source>
          <target state="translated">&lt;a href=&quot;optionalint#orElse-int-&quot;&gt; &lt;code&gt;orElse()&lt;/code&gt; &lt;/a&gt; (값이 없으면 기본값을 반환 함) 및 &lt;a href=&quot;optionalint#ifPresent-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;ifPresent()&lt;/code&gt; &lt;/a&gt; (값이 있으면 코드 블록을 실행 함 ) 와 같이 포함 된 값의 존재 여부에 의존하는 추가 메소드가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="34cc0eeb9403f3db57efcf7405c0cd9eeb78a06c" translate="yes" xml:space="preserve">
          <source>Additional methods that depend on the presence or absence of a contained value are provided, such as &lt;a href=&quot;optionallong#orElse-long-&quot;&gt;&lt;code&gt;orElse()&lt;/code&gt;&lt;/a&gt; (return a default value if value not present) and &lt;a href=&quot;optionallong#ifPresent-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;ifPresent()&lt;/code&gt;&lt;/a&gt; (execute a block of code if the value is present).</source>
          <target state="translated">&lt;a href=&quot;optionallong#orElse-long-&quot;&gt; &lt;code&gt;orElse()&lt;/code&gt; &lt;/a&gt; (값이 없으면 기본값을 반환 함) 및 &lt;a href=&quot;optionallong#ifPresent-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;ifPresent()&lt;/code&gt; &lt;/a&gt; (값이 있으면 코드 블록을 실행 함 ) 와 같이 포함 된 값의 존재 여부에 의존하는 추가 메소드가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="13464cc8936bbc9b2208d650850d5fac39443545" translate="yes" xml:space="preserve">
          <source>Additional standard formats may be introduced in the future.</source>
          <target state="translated">추후에 추가 표준 형식이 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbb1b7a1bd9bfc66edd6839a4077cee735dd36b" translate="yes" xml:space="preserve">
          <source>Additional stream sources can be provided by third-party libraries using &lt;a href=&quot;package-summary#StreamSources&quot;&gt;these techniques&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;package-summary#StreamSources&quot;&gt;이러한 기술을&lt;/a&gt; 사용하여 타사 라이브러리에서 추가 스트림 소스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="788d5fb9c5c2256c017301e4438f1cb655fe5ebd" translate="yes" xml:space="preserve">
          <source>Additional timer notifications can be added into regularly repeating notifications.</source>
          <target state="translated">정기적으로 반복되는 알림에 추가 타이머 알림을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a10ca49445b1dc381329d54dd290b1aed5605232" translate="yes" xml:space="preserve">
          <source>Additional value types</source>
          <target state="translated">추가 값 유형</target>
        </trans-unit>
        <trans-unit id="8fbd3faa9cf3d8a29570876dcfac7b094cd531b8" translate="yes" xml:space="preserve">
          <source>Additional variants may be available through &lt;a href=&quot;chronology#getAvailableChronologies--&quot;&gt;&lt;code&gt;Chronology.getAvailableChronologies()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chronology#getAvailableChronologies--&quot;&gt; &lt;code&gt;Chronology.getAvailableChronologies()&lt;/code&gt; &lt;/a&gt; 통해 추가 변형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7daa8f8f62d19b63aca128ec51731badb82303d5" translate="yes" xml:space="preserve">
          <source>Additional words may be appended to the result of &lt;code&gt;toString&lt;/code&gt; in the future if more properties are added to this class.</source>
          <target state="translated">이 클래스에 더 많은 속성이 추가되면 향후 &lt;code&gt;toString&lt;/code&gt; 결과에 추가 단어가 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80754834ce60b369e5edb68c1d0d499500fc2339" translate="yes" xml:space="preserve">
          <source>Additionally, a writer can acquire the read lock, but not vice-versa. Among other applications, reentrancy can be useful when write locks are held during calls or callbacks to methods that perform reads under read locks. If a reader tries to acquire the write lock it will never succeed.</source>
          <target state="translated">또한 기록기는 읽기 잠금을 획득 할 수 있지만 그 반대는 불가능합니다. 다른 애플리케이션 중에서도 재진입은 읽기 잠금에서 읽기를 수행하는 메소드에 대한 호출 또는 콜백 중에 쓰기 잠금이 유지 될 때 유용 할 수 있습니다. 리더가 쓰기 잠금을 얻으려고하면 성공하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="c55b1b7ae232d6f0b1ca0077731c09fc6c13f02f" translate="yes" xml:space="preserve">
          <source>Additionally, an &lt;code&gt;MLet&lt;/code&gt; can read a configuration file that specifies a set of MBeans to be registered in the same MBean Server as the &lt;code&gt;MLet&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;MLet&lt;/code&gt; 를는 같은 MBean 서버에 등록하는 복수의 MBean 세트를 지정하는 구성 파일을 판독 할 수 &lt;code&gt;MLet&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="a11766aa1b3dc5a19aa3c525798b1ccdf4495177" translate="yes" xml:space="preserve">
          <source>Additionally, if this PermissionCollection contains the AllPermission, this method will always return true.</source>
          <target state="translated">또한이 PermissionCollection에 AllPermission이 포함되어 있으면이 메서드는 항상 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97e1b88d18d7ac97979173380caf5a08df025f56" translate="yes" xml:space="preserve">
          <source>Additionally, synthetic constructs in a class file, such as accessor methods used in implementing nested classes and bridge methods used in implementing covariant returns, are translation artifacts outside of this model.</source>
          <target state="translated">또한 중첩 클래스 구현에 사용되는 접근 자 메서드 및 공변량 반환 구현에 사용되는 브리지 메서드와 같은 클래스 파일의 합성 구문은이 모델 외부의 번역 아티팩트입니다.</target>
        </trans-unit>
        <trans-unit id="fecf0b6bab60c02a810a2df241485bd364c4f1f1" translate="yes" xml:space="preserve">
          <source>Address types</source>
          <target state="translated">주소 유형</target>
        </trans-unit>
        <trans-unit id="4ca7b9663ad28e00bad95a214ec91b0b6850abe7" translate="yes" xml:space="preserve">
          <source>Addresses</source>
          <target state="translated">Addresses</target>
        </trans-unit>
        <trans-unit id="5a859c9227521491b59649a1e7c84fb31afc14d5" translate="yes" xml:space="preserve">
          <source>Addresses -- This is the address assigned to the loopback interface. Anything sent to this IP address loops around and becomes IP input on the local host. This address is often used when testing a client.</source>
          <target state="translated">주소-루프백 인터페이스에 할당 된 주소입니다. 이 IP 주소로 전송 된 모든 항목은 루핑되어 로컬 호스트에서 IP 입력이됩니다. 이 주소는 종종 클라이언트를 테스트 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af2f815dcc050b5c289da3f0ae762e1844c83c3c" translate="yes" xml:space="preserve">
          <source>Addresses are covered in more detail below.</source>
          <target state="translated">주소는 아래에 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba0964ba70534242de6cf56793213d4f1046513" translate="yes" xml:space="preserve">
          <source>Addresses are used throughout the java.net APIs as either host identifiers, or socket endpoint identifiers.</source>
          <target state="translated">주소는 java.net API 전체에서 호스트 식별자 또는 소켓 엔드 포인트 식별자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b61d39b9f5225d229075b52dae489982a87ee95b" translate="yes" xml:space="preserve">
          <source>Adds (atomically) the given value to the pending count.</source>
          <target state="translated">주어진 값을 대기 수에 (원자 적으로) 추가합니다.</target>
        </trans-unit>
        <trans-unit id="33d0130fd1daf2f613a64874c516c89d62abc445" translate="yes" xml:space="preserve">
          <source>Adds &lt;var&gt;value&lt;/var&gt; to this &lt;code&gt;TabularData&lt;/code&gt; instance. The composite type of &lt;var&gt;value&lt;/var&gt; must be the same as this instance's row type (ie the composite type returned by &lt;code&gt;this.getTabularType().&lt;a href=&quot;tabulartype#getRowType--&quot;&gt;&lt;code&gt;getRowType()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;), and there must not already be an existing value in this &lt;code&gt;TabularData&lt;/code&gt; instance whose index is the same as the one calculated for the &lt;var&gt;value&lt;/var&gt; to be added. The index for &lt;var&gt;value&lt;/var&gt; is calculated according to this &lt;code&gt;TabularData&lt;/code&gt; instance's &lt;code&gt;TabularType&lt;/code&gt; definition (see &lt;code&gt;TabularType.&lt;a href=&quot;tabulartype#getIndexNames--&quot;&gt;&lt;code&gt;getIndexNames()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스에 &lt;var&gt;value&lt;/var&gt; 을 추가합니다 . 복합 유형의 &lt;var&gt;value&lt;/var&gt; 은이 인스턴스의 행 유형과 동일해야합니다 (예 : &lt;code&gt;this.getTabularType().&lt;a href=&quot;tabulartype#getRowType--&quot;&gt;&lt;code&gt;getRowType()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;tabulartype#getRowType--&quot;&gt; &lt;code&gt;getRowType()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 복합 유형 ). 이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스에 색인이 동일한 기존 값이 없어야합니다. 추가 될 &lt;var&gt;value&lt;/var&gt; 에 대해 계산 된 값 으로. &lt;var&gt;value&lt;/var&gt; 인덱스 는이 &lt;code&gt;TabularData&lt;/code&gt; 인스턴스의 &lt;code&gt;TabularType&lt;/code&gt; 정의 에 따라 계산됩니다 ( &lt;code&gt;TabularType.&lt;a href=&quot;tabulartype#getIndexNames--&quot;&gt;&lt;code&gt;getIndexNames()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;tabulartype#getIndexNames--&quot;&gt; &lt;code&gt;getIndexNames()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e96db0787e624247da3e96530e23569743a9638c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;BeanContextServicesListener&lt;/code&gt; to this BeanContext</source>
          <target state="translated">이 BeanContext에 &lt;code&gt;BeanContextServicesListener&lt;/code&gt; 를 추가합니다</target>
        </trans-unit>
        <trans-unit id="af15736f5718544c08a3535dfe092a928ba1ba6b" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;CertStore&lt;/code&gt; to the end of the list of &lt;code&gt;CertStore&lt;/code&gt;s used in finding certificates and CRLs.</source>
          <target state="translated">인증서 및 CRL을 찾는 데 사용되는 &lt;code&gt;CertStore&lt;/code&gt; 목록 끝에 &lt;code&gt;CertStore&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f30a815159eec687b61e841aa7c2adae682cdb" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; to the list of certification path checkers. See the &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; method for more details.</source>
          <target state="translated">인증 경로 검사기 목록에 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 를 추가합니다 . 자세한 내용은 &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="29fde23e9df36894f35bdff333702c7b3943fb33" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to this &lt;code&gt;BeanContextChild&lt;/code&gt; in order to receive a &lt;code&gt;PropertyChangeEvent&lt;/code&gt; whenever the specified property has changed.</source>
          <target state="translated">지정된 프로퍼티가 변경 될 때마다 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 를 받기 &lt;code&gt;BeanContextChild&lt;/code&gt; 에 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="24a6c5b4a9371dfa046fb476786ab303a3a03a13" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;VetoableChangeListener&lt;/code&gt; to this &lt;code&gt;BeanContextChild&lt;/code&gt; to receive events whenever the specified property changes.</source>
          <target state="translated">지정된 프로퍼티가 변경 될 때마다 이벤트를 받기 &lt;code&gt;BeanContextChild&lt;/code&gt; 에 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="20ea900ed2256f79b733bb46ef65688fc8edd433" translate="yes" xml:space="preserve">
          <source>Adds a BeanContextMembershipListener</source>
          <target state="translated">BeanContextMembershipListener를 추가합니다</target>
        </trans-unit>
        <trans-unit id="b073b120340559789592a6db38bfd7a8dbb8db0f" translate="yes" xml:space="preserve">
          <source>Adds a certificate for this identity. If the identity has a public key, the public key in the certificate must be the same, and if the identity does not have a public key, the identity's public key is set to be that specified in the certificate.</source>
          <target state="translated">이 ID에 대한 인증서를 추가합니다. ID에 공개 키가있는 경우 인증서의 공개 키가 같아야하고 ID에 공개 키가 없으면 ID의 공개 키가 인증서에 지정된 키로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8da2bb61b7bb4dc3b78352141a657ca9c4046133" translate="yes" xml:space="preserve">
          <source>Adds a copy of the given &lt;code&gt;CharSequence&lt;/code&gt; value as the next element of the &lt;code&gt;StringJoiner&lt;/code&gt; value. If &lt;code&gt;newElement&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;&quot;null&quot;&lt;/code&gt; is added.</source>
          <target state="translated">지정된 &lt;code&gt;CharSequence&lt;/code&gt; 값 의 복사본을 &lt;code&gt;StringJoiner&lt;/code&gt; 값 의 다음 요소로 추가 합니다. 경우 &lt;code&gt;newElement&lt;/code&gt; 이 있다 &lt;code&gt;null&lt;/code&gt; , 다음, &lt;code&gt;&quot;null&quot;&lt;/code&gt; 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e01bddaa7b73ca2a1bdb8e57d1caa8fe69330587" translate="yes" xml:space="preserve">
          <source>Adds a general request property specified by a key-value pair. This method will not overwrite existing values associated with the same key.</source>
          <target state="translated">키-값 쌍으로 지정된 일반 요청 특성을 추가합니다. 이 방법은 동일한 키와 관련된 기존 값을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d357318fab8169743871ba69100c51256407dfd" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when objects identified by the search filter &lt;code&gt;filter&lt;/code&gt; and filter arguments at the object named by the string target name are modified. See the overload that accepts a &lt;code&gt;Name&lt;/code&gt; for details of how this method behaves.</source>
          <target state="translated">검색 필터 &lt;code&gt;filter&lt;/code&gt; 식별 된 오브젝트 와 문자열 대상 이름으로 이름 지정된 오브젝트에서 인수를 필터링 할 때 발생하는 이름 지정 이벤트를 수신하기위한 리스너를 추가합니다 . 이 메소드의 작동 방식에 대한 자세한 내용은 &lt;code&gt;Name&lt;/code&gt; 을 허용하는 과부하를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d69f1487be358c95decf98ef855a993226b5dcca" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when objects identified by the search filter &lt;code&gt;filter&lt;/code&gt; and filter arguments at the object named by the target are modified. The scope, returningObj flag, and returningAttributes flag from the search controls &lt;code&gt;ctls&lt;/code&gt; are used to control the selection of objects that the listener is interested in, and determines what information is returned in the eventual &lt;code&gt;NamingEvent&lt;/code&gt; object. Note that the requested information to be returned might not be present in the &lt;code&gt;NamingEvent&lt;/code&gt; object if they are unavailable or could not be obtained by the service provider or service.</source>
          <target state="translated">검색 필터 &lt;code&gt;filter&lt;/code&gt; 식별 된 오브젝트 및 대상이 지정한 오브젝트의 인수를 필터링 할 때 발생하는 이름 지정 이벤트를 수신하기위한 리스너를 추가합니다 . 검색 제어 &lt;code&gt;ctls&lt;/code&gt; 에서 scope, returningObj 플래그 및 returningAttributes 플래그 는 리스너가 관심있는 오브젝트의 선택을 제어하고 최종 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 리턴되는 정보를 판별하는 데 사용됩니다 . 요청 된 정보 가 사용 불가능하거나 서비스 제공 업체 또는 서비스에서 확보 할 수없는 경우 &lt;code&gt;NamingEvent&lt;/code&gt; 오브젝트에 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fadd53b76f6130b1bf16e6cb01073d0e03f1da" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when objects identified by the search filter &lt;code&gt;filter&lt;/code&gt; at the object named by target are modified.</source>
          <target state="translated">target으로 명명 된 객체에서 검색 필터 &lt;code&gt;filter&lt;/code&gt; 로 식별 된 객체가 수정 될 때 발생하는 명명 이벤트를 수신하기위한 리스너를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e08383bae797217ce4b5b5b96797d19638493458" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when objects identified by the search filter &lt;code&gt;filter&lt;/code&gt; at the object named by the string target name are modified. See the overload that accepts a &lt;code&gt;Name&lt;/code&gt; for details of how this method behaves.</source>
          <target state="translated">문자열 대상 이름으로 명명 된 객체에서 검색 필터 &lt;code&gt;filter&lt;/code&gt; 로 식별 된 객체가 수정 될 때 발생하는 명명 이벤트를 수신하기위한 리스너를 추가합니다 . 이 메소드의 작동 방식에 대한 자세한 내용은 &lt;code&gt;Name&lt;/code&gt; 을 허용하는 과부하를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="252928a9bd82a2d6b89f4d6fcd79c52a88385e16" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when the object named by the string target name and scope changes. See the overload that accepts a &lt;code&gt;Name&lt;/code&gt; for details.</source>
          <target state="translated">문자열 대상 이름 및 범위로 이름이 지정된 오브젝트가 변경 될 때 시작된 이름 지정 이벤트를 수신하기위한 리스너를 추가합니다. 자세한 내용은 &lt;code&gt;Name&lt;/code&gt; 을 허용하는 과부하를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c6d51b4074a7b0af5bc654520ed36dd550f1fe20" translate="yes" xml:space="preserve">
          <source>Adds a listener for receiving naming events fired when the object(s) identified by a target and scope changes. The event source of those events is this context. See the class description for a discussion on event source and target. See the descriptions of the constants &lt;code&gt;OBJECT_SCOPE&lt;/code&gt;, &lt;code&gt;ONELEVEL_SCOPE&lt;/code&gt;, and &lt;code&gt;SUBTREE_SCOPE&lt;/code&gt; to see how &lt;code&gt;scope&lt;/code&gt; affects the registration.</source>
          <target state="translated">대상과 범위로 식별 된 객체가 변경 될 때 발생하는 명명 이벤트를 수신하기위한 리스너를 추가합니다. 이러한 이벤트의 이벤트 소스는이 컨텍스트입니다. 이벤트 소스 및 대상에 대한 설명은 클래스 설명을 참조하십시오. &lt;code&gt;scope&lt;/code&gt; 가 등록에 미치는 영향 을 보려면 상수 &lt;code&gt;OBJECT_SCOPE&lt;/code&gt; , &lt;code&gt;ONELEVEL_SCOPE&lt;/code&gt; 및 &lt;code&gt;SUBTREE_SCOPE&lt;/code&gt; 에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a58c7d9ecbfbb5807b029ac36028db2d726b57c2" translate="yes" xml:space="preserve">
          <source>Adds a listener for the value change. When the property editor changes its value it should fire a &lt;a href=&quot;propertychangeevent&quot;&gt;&lt;code&gt;PropertyChangeEvent&lt;/code&gt;&lt;/a&gt; on all registered &lt;a href=&quot;propertychangelistener&quot;&gt;&lt;code&gt;PropertyChangeListener&lt;/code&gt;&lt;/a&gt;s, specifying the &lt;code&gt;null&lt;/code&gt; value for the property name and itself as the source.</source>
          <target state="translated">값 변경에 대한 리스너를 추가합니다. 프로퍼티 에디터가 그 값을 변경하면 그것은 발사해야 &lt;a href=&quot;propertychangeevent&quot;&gt; &lt;code&gt;PropertyChangeEvent&lt;/code&gt; &lt;/a&gt; 등록 된 모든에 &lt;a href=&quot;propertychangelistener&quot;&gt; &lt;code&gt;PropertyChangeListener&lt;/code&gt; 를&lt;/a&gt; 지정의를 &lt;code&gt;null&lt;/code&gt; 소스로 속성 이름에 대한 가치와 자신을.</target>
        </trans-unit>
        <trans-unit id="e0a125aab63ba62bb13aba497f255d8d0f0b6672" translate="yes" xml:space="preserve">
          <source>Adds a listener for the value change. When the property editor changes its value it should fire a &lt;a href=&quot;propertychangeevent&quot;&gt;&lt;code&gt;PropertyChangeEvent&lt;/code&gt;&lt;/a&gt; on all registered &lt;a href=&quot;propertychangelistener&quot;&gt;&lt;code&gt;PropertyChangeListener&lt;/code&gt;&lt;/a&gt;s, specifying the &lt;code&gt;null&lt;/code&gt; value for the property name. If the source property is set, it should be used as the source of the event.</source>
          <target state="translated">값 변경에 대한 리스너를 추가합니다. 프로퍼티 에디터가 그 값을 변경하면, 프로퍼티 명의 &lt;code&gt;null&lt;/code&gt; 값을 지정해, 등록 된 모든 &lt;a href=&quot;propertychangeevent&quot;&gt; &lt;code&gt;PropertyChangeEvent&lt;/code&gt; &lt;/a&gt; 에 대해 &lt;a href=&quot;propertychangelistener&quot;&gt; &lt;code&gt;PropertyChangeListener&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. 소스 특성이 설정된 경우 이벤트의 소스로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecd03f2b3982c5462001595a61ae0f259c2072fc" translate="yes" xml:space="preserve">
          <source>Adds a listener to a registered MBean.</source>
          <target state="translated">등록 된 MBean에 리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7550182af13319e3a25386c9241727b3dc7875aa" translate="yes" xml:space="preserve">
          <source>Adds a listener to a registered MBean. Notifications emitted by the MBean will be forwarded to the listener.</source>
          <target state="translated">등록 된 MBean에 리스너를 추가합니다. MBean에 의해 발행 된 통지는 청취자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a04e3045d56fa2939e2e446760cadc61b8e961c2" translate="yes" xml:space="preserve">
          <source>Adds a listener to be informed of changes in connection status. The listener will receive notifications of type &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt;. An implementation can send other types of notifications too.</source>
          <target state="translated">연결 상태 변경을 알리는 리스너를 추가합니다. 리스너는 &lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 유형의 알림을받습니다 . 구현시 다른 유형의 알림도 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942ea01bf71c9794151e18b8fd65ceb4695072d8" translate="yes" xml:space="preserve">
          <source>Adds a listener to be informed of changes in connection status. The listener will receive notifications of type &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt;. An implementation can send other types of notifications too.</source>
          <target state="translated">연결 상태 변경을 알리는 리스너를 추가합니다. 리스너는 &lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 유형의 알림을받습니다 . 구현시 다른 유형의 알림도 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818eeaaedee1309d80930a31c90657f2531a31ce" translate="yes" xml:space="preserve">
          <source>Adds a listener to this MBean.</source>
          <target state="translated">이 MBean에 청취자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="239a32ee9c0a4bc204babeeee5db4ccf664cdf9d" translate="yes" xml:space="preserve">
          <source>Adds a listener to this line. Whenever the line's status changes, the listener's &lt;code&gt;update()&lt;/code&gt; method is called with a &lt;code&gt;LineEvent&lt;/code&gt; object that describes the change.</source>
          <target state="translated">이 행에 리스너를 추가합니다. 라인의 상태가 변경 될 때마다 리스너의 &lt;code&gt;update()&lt;/code&gt; 메소드는 변경을 설명 하는 &lt;code&gt;LineEvent&lt;/code&gt; 객체 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5adb4ce9b17bf87e5ec0ce3fbe5e18df871621f" translate="yes" xml:space="preserve">
          <source>Adds a listener.</source>
          <target state="translated">리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="575ee2177446aca5851551187f25cb8c3b666e0a" translate="yes" xml:space="preserve">
          <source>Adds a name to the issuerNames criterion. The issuer distinguished name in the &lt;code&gt;X509CRL&lt;/code&gt; must match at least one of the specified distinguished names.</source>
          <target state="translated">issuerNames 기준에 이름을 추가합니다. &lt;code&gt;X509CRL&lt;/code&gt; 의 발급자 식별 이름 은 지정된 식별 이름 중 하나 이상과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0d14377817c3c04a5158e5fce845cee98acbe41" translate="yes" xml:space="preserve">
          <source>Adds a name to the pathToNames criterion. The &lt;code&gt;X509Certificate&lt;/code&gt; must not include name constraints that would prohibit building a path to the specified name.</source>
          <target state="translated">pathToNames 기준에 이름을 추가합니다. &lt;code&gt;X509Certificate&lt;/code&gt; 지정된 이름에 대한 경로를 구축하는 것을 금지 이름 제약을 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bbacf8e7198dae3e9e6efabee957f79ecf5fd94b" translate="yes" xml:space="preserve">
          <source>Adds a name to the subjectAlternativeNames criterion. The &lt;code&gt;X509Certificate&lt;/code&gt; must contain all or at least one of the specified subjectAlternativeNames, depending on the value of the matchAllNames flag (see &lt;a href=&quot;x509certselector#setMatchAllSubjectAltNames-boolean-&quot;&gt;&lt;code&gt;setMatchAllSubjectAltNames&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">subjectAlternativeNames 기준에 이름을 추가합니다. &lt;code&gt;X509Certificate&lt;/code&gt; matchAllNames 플래그의 값 (참조에 따라 전부 또는 지정된 subjectAlternativeNames 중 적어도 하나를 포함해야합니다 &lt;a href=&quot;x509certselector#setMatchAllSubjectAltNames-boolean-&quot;&gt; &lt;code&gt;setMatchAllSubjectAltNames&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="730557f6dbffc660ab168fa5e6128b66f087b3a5" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node. If an attribute with that name ( &lt;code&gt;nodeName&lt;/code&gt;) is already present in the element, it is replaced by the new one. Replacing an attribute node by itself has no effect.</source>
          <target state="translated">새로운 속성 노드를 추가합니다. 해당 이름을 가진 속성 ( &lt;code&gt;nodeName&lt;/code&gt; )이 요소에 이미 존재하면 새 속성으로 대체됩니다. 속성 노드 자체를 교체해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5feb4eb9a64db07e328a6d949304fa33675343f" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to a previously defined element that may be set to an arbitrary value.</source>
          <target state="translated">임의의 값으로 설정 될 수있는 이전에 정의 된 요소에 새 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="306fe613c6a6206dcc8f6efde178405d582496e7" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to a previously defined element that will be defined by a list of values.</source>
          <target state="translated">값 목록에 의해 정의 될 이전에 정의 된 요소에 새 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="53da4efd3ccb4092d59506d9b05086dca8367032" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to a previously defined element that will be defined by a range of values.</source>
          <target state="translated">값 범위에 의해 정의 될 이전에 정의 된 요소에 새 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cd1d9b58d87df3e98cc5f9e4f92c872697623ab0" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to a previously defined element that will be defined by a set of enumerated values.</source>
          <target state="translated">열거 된 값 세트에 의해 정의 될 이전에 정의 된 요소에 새 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6a5d44ade2593fd8d14dbe63139095912bacd728" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to a previously defined element that will be defined by the enumerated values &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt;, with a datatype of &lt;code&gt;DATATYPE_BOOLEAN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DATATYPE_BOOLEAN&lt;/code&gt; 데이터 유형을 사용 하여 열거 된 값 &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 에 의해 정의 될 이전에 정의 된 요소에 새 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd9483a49fe08acb03ad508c90be25e85e87a86" translate="yes" xml:space="preserve">
          <source>Adds a new attribute to the attribute set.</source>
          <target state="translated">속성 세트에 새로운 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="409ac2e796de45bc58ab9e8ecd1bde717c160378" translate="yes" xml:space="preserve">
          <source>Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter. This value is a simple string; it is not parsed as it is being set. So any markup (such as syntax to be recognized as an entity reference) is treated as literal text, and needs to be appropriately escaped by the implementation when it is written out. In order to assign an attribute value that contains entity references, the user must create an &lt;code&gt;Attr&lt;/code&gt; node plus any &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;EntityReference&lt;/code&gt; nodes, build the appropriate subtree, and use &lt;code&gt;setAttributeNode&lt;/code&gt; to assign it as the value of an attribute.</source>
          <target state="translated">새로운 속성을 추가합니다. 해당 이름의 속성이 요소에 이미 존재하면 해당 값이 value 매개 변수의 속성으로 변경됩니다. 이 값은 간단한 문자열입니다. 설정된대로 구문 분석되지 않습니다. 따라서 엔티티 참조로 인식되는 구문과 같은 마크 업은 리터럴 텍스트로 취급되며, 작성할 때 구현에서 적절하게 이스케이프해야합니다. 엔티티 참조가 포함 된 속성 값을 지정하려면 사용자는 &lt;code&gt;Attr&lt;/code&gt; 노드와 &lt;code&gt;Text&lt;/code&gt; 및 &lt;code&gt;EntityReference&lt;/code&gt; 노드를 작성하고 적절한 서브 트리를 빌드 한 후 &lt;code&gt;setAttributeNode&lt;/code&gt; 를 사용 하여 속성 값으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a04d8792d87eceaa70115188f476b88febeee8af" translate="yes" xml:space="preserve">
          <source>Adds a new element type to this metadata document format with a child policy of &lt;code&gt;CHILD_POLICY_REPEAT&lt;/code&gt;.</source>
          <target state="translated">하위 정책 &lt;code&gt;CHILD_POLICY_REPEAT&lt;/code&gt; 를 사용하여이 메타 데이터 문서 형식에 새 요소 유형을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fc628c718c01cc55bb7296929aac4431413c5760" translate="yes" xml:space="preserve">
          <source>Adds a new element type to this metadata document format with a child policy other than &lt;code&gt;CHILD_POLICY_REPEAT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CHILD_POLICY_REPEAT&lt;/code&gt; 이외의 하위 정책으로이 메타 데이터 문서 형식에 새 요소 유형을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="55fddc2953b3e6249093ca8fb868829938af8079" translate="yes" xml:space="preserve">
          <source>Adds a new environment property to the environment of this context. If the property already exists, its value is overwritten. See class description for more details on environment properties.</source>
          <target state="translated">이 컨텍스트의 환경에 새로운 환경 프로퍼티를 추가합니다. 속성이 이미 존재하면 해당 값을 덮어 씁니다. 환경 속성에 대한 자세한 내용은 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce6b9539ec6e4ba0dc3813a2e2df2ce54427ebc4" translate="yes" xml:space="preserve">
          <source>Adds a new event to the track. However, if the event is already contained in the track, it is not added again. The list of events is kept in time order, meaning that this event inserted at the appropriate place in the list, not necessarily at the end.</source>
          <target state="translated">트랙에 새로운 이벤트를 추가합니다. 그러나 이벤트가 이미 트랙에 포함되어 있으면 다시 추가되지 않습니다. 이벤트 목록은 시간 순서대로 유지됩니다. 즉,이 이벤트는 목록의 적절한 위치에 삽입 될 필요는 없으며 반드시 끝이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6394a60cdcd434d32b71ef468038c17b75014f63" translate="yes" xml:space="preserve">
          <source>Adds a new provider, at a specified position. The position is the preference order in which providers are searched for requested algorithms. The position is 1-based, that is, 1 is most preferred, followed by 2, and so on.</source>
          <target state="translated">지정된 위치에 새 공급자를 추가합니다. 위치는 제공자가 요청한 알고리즘을 검색하는 우선 순위입니다. 위치는 1을 기준으로합니다. 즉, 1이 가장 선호되고 2가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="828147fc7743b25ba75f82f414fa8ac8d11893aa" translate="yes" xml:space="preserve">
          <source>Adds a new unarrived party to this phaser. If an ongoing invocation of &lt;a href=&quot;phaser#onAdvance-int-int-&quot;&gt;&lt;code&gt;onAdvance(int, int)&lt;/code&gt;&lt;/a&gt; is in progress, this method may await its completion before returning. If this phaser has a parent, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.</source>
          <target state="translated">이 페이저에 도착하지 않은 새로운 파티를 추가합니다. &lt;a href=&quot;phaser#onAdvance-int-int-&quot;&gt; &lt;code&gt;onAdvance(int, int)&lt;/code&gt; &lt;/a&gt; 의 진행중인 호출이 진행중인 경우 ,이 메소드는 리턴하기 전에 완료를 기다릴 수 있습니다. 이 단계에 부모가 있고 이전에 등록 된 당사자가없는 경우이 하위 단계도 부모에 등록됩니다. 이 페이저가 종료되면 등록 시도가 효과가 없으며 음수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="164308b06c883631e224a99f24edf263a9509566" translate="yes" xml:space="preserve">
          <source>Adds a new value to the attribute. If the attribute values are unordered and &lt;code&gt;attrVal&lt;/code&gt; is already in the attribute, this method does nothing. If the attribute values are ordered, &lt;code&gt;attrVal&lt;/code&gt; is added to the end of the list of attribute values.</source>
          <target state="translated">속성에 새로운 값을 추가합니다. 속성 값이 정렬되지 않고 &lt;code&gt;attrVal&lt;/code&gt; 이 속성에 이미 있으면이 메소드는 아무 작업도 수행하지 않습니다. 속성 값이 정렬되면 &lt;code&gt;attrVal&lt;/code&gt; 이 속성 값 목록 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b4c7108d8114f28ac82c1ddc1f60525d8b55d0f" translate="yes" xml:space="preserve">
          <source>Adds a new value to this attribute.</source>
          <target state="translated">이 속성에 새로운 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="339ce1e81fd4581260191f372762fbc00c799c80" translate="yes" xml:space="preserve">
          <source>Adds a permission object to the PermissionCollection for the class the permission belongs to. For example, if</source>
          <target state="translated">권한이 속한 클래스의 PermissionCollection에 권한 개체를 추가합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c608e626dfaeb14a2ecd099b06ca7c4ae7ec4cf3" translate="yes" xml:space="preserve">
          <source>Adds a permission object to the current collection of permission objects.</source>
          <target state="translated">권한 개체를 현재 권한 개체 컬렉션에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="95e1a85f9a25a9153a61c3bae3a50c586db2316f" translate="yes" xml:space="preserve">
          <source>Adds a provider to the next position available.</source>
          <target state="translated">사용 가능한 다음 위치에 공급자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="374b24b89a3a6bd30534cb4cca804e8991c52282" translate="yes" xml:space="preserve">
          <source>Adds a service provider object to the registry. The provider is associated with the given category.</source>
          <target state="translated">서비스 제공자 오브젝트를 레지스트리에 추가합니다. 제공자가 지정된 카테고리와 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a8d1fe273276b7ddbd5629492fc6d45dfbdb4b" translate="yes" xml:space="preserve">
          <source>Adds a service provider object to the registry. The provider is associated within each category present in the registry whose &lt;code&gt;Class&lt;/code&gt; it implements.</source>
          <target state="translated">서비스 제공자 오브젝트를 레지스트리에 추가합니다. 공급자는 해당 &lt;code&gt;Class&lt;/code&gt; 를 구현 하는 레지스트리에있는 각 범주 내에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="d43dda4dfa50cc990def8a702fe317254fa256df" translate="yes" xml:space="preserve">
          <source>Adds a service to this BeanContext. &lt;code&gt;BeanContextServiceProvider&lt;/code&gt;s call this method to register a particular service with this context. If the service has not previously been added, the &lt;code&gt;BeanContextServices&lt;/code&gt; associates the service with the &lt;code&gt;BeanContextServiceProvider&lt;/code&gt; and fires a &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; to all currently registered &lt;code&gt;BeanContextServicesListeners&lt;/code&gt;. The method then returns &lt;code&gt;true&lt;/code&gt;, indicating that the addition of the service was successful. If the given service has already been added, this method simply returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 BeanContext에 서비스를 추가합니다. &lt;code&gt;BeanContextServiceProvider&lt;/code&gt; 는이 메소드를 호출하여이 컨텍스트에 특정 서비스를 등록합니다. 서비스가 이전에 추가되지 않은 경우 &lt;code&gt;BeanContextServices&lt;/code&gt; 와 서비스를 연결합니다 &lt;code&gt;BeanContextServiceProvider&lt;/code&gt; 의를 하고 화재 &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; 를 현재 등록되어 모든에 &lt;code&gt;BeanContextServicesListeners&lt;/code&gt; . 그런 다음 메소드 는 서비스 추가에 성공했음을 나타내는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 지정된 서비스가 이미 추가 된 경우이 메소드는 단순히 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d85d5f4467b49dba34ca220b3cd0169a9da5dd92" translate="yes" xml:space="preserve">
          <source>Adds a set of attributes to a subrange of the string.</source>
          <target state="translated">문자열의 하위 범위에 속성 세트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="833e6568a363139cdb8d1d8dcfec09bd0d6407f1" translate="yes" xml:space="preserve">
          <source>Adds a set of service provider objects, taken from an &lt;code&gt;Iterator&lt;/code&gt; to the registry. Each provider is associated within each category present in the registry whose &lt;code&gt;Class&lt;/code&gt; it implements.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 에서 가져온 서비스 제공자 오브젝트 세트를 레지스트리에 추가합니다. 각 공급자는 해당 &lt;code&gt;Class&lt;/code&gt; 를 구현 하는 레지스트리에있는 각 범주 내에서 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ccc40274a560e11578c88cb99f598977c9c02c2" translate="yes" xml:space="preserve">
          <source>Adds a signed amount to the specified calendar field without changing larger fields. A negative roll amount means to subtract from field without changing larger fields. If the specified amount is 0, this method performs nothing.</source>
          <target state="translated">더 큰 필드를 변경하지 않고 지정된 일정 필드에 부호있는 금액을 추가합니다. 음수 롤 양은 더 큰 필드를 변경하지 않고 필드에서 빼는 것을 의미합니다. 지정된 양이 0이면이 방법은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="057a981d143361ac27495d07c6bdfb3cb336a8c8" translate="yes" xml:space="preserve">
          <source>Adds a single RDN at a specified position within this LDAP name. RDNs of this LDAP name at or after the index (if any) of the new RDN are shifted up by one (away from index 0) to accommodate the new RDN.</source>
          <target state="translated">이 LDAP 이름 내의 지정된 위치에 단일 RDN을 추가합니다. 새 RDN의 인덱스 (있는 경우) 또는 그 이후에이 LDAP 이름의 RDN이 새 RDN을 수용하기 위해 인덱스 0에서 1만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="5e1a58fdf13fd5c18c20c655310c6d2f38f0179d" translate="yes" xml:space="preserve">
          <source>Adds a single RDN to the end of this LDAP name.</source>
          <target state="translated">이 LDAP 이름 끝에 단일 RDN을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e9b9fa4d79eeb99ac367f662a737984230ca035f" translate="yes" xml:space="preserve">
          <source>Adds a single component at a specified position within this LDAP name. Components of this LDAP name at or after the index (if any) of the new component are shifted up by one (away from index 0) to accommodate the new component.</source>
          <target state="translated">이 LDAP 이름 내의 지정된 위치에 단일 구성 요소를 추가합니다. 새 구성 요소의 색인 (있는 경우) 또는 이후에이 LDAP 이름의 구성 요소가 새 구성 요소를 수용하기 위해 색인 0에서 1만큼 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b8bde48d2860eae12c10708717e304488ec7282e" translate="yes" xml:space="preserve">
          <source>Adds a single component at a specified position within this composite name. Components of this composite name at or after the index of the new component are shifted up by one (away from index 0) to accommodate the new component.</source>
          <target state="translated">이 컴퍼 짓 이름 내의 지정된 위치에 단일의 컴퍼넌트를 추가합니다. 새 구성 요소의 색인에서 또는 이후에이 복합 이름의 구성 요소는 새 구성 요소를 수용하기 위해 색인 0에서 1만큼 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="63f0f23b7b980761b39496cba1d4e27c4ffa70a9" translate="yes" xml:space="preserve">
          <source>Adds a single component at a specified position within this compound name. Components of this compound name at or after the index of the new component are shifted up by one (away from index 0) to accommodate the new component.</source>
          <target state="translated">이 복합 명 내의 지정된 위치에 단일의 컴퍼넌트를 추가합니다. 새 구성 요소의 색인에서 또는 이후에이 복합 이름의 구성 요소는 새 구성 요소를 수용하기 위해 색인 0에서 1만큼 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="21483b1aecd485807e580994fa1485d0cef8b3b2" translate="yes" xml:space="preserve">
          <source>Adds a single component at a specified position within this name. Components of this name at or after the index of the new component are shifted up by one (away from index 0) to accommodate the new component.</source>
          <target state="translated">이 이름 내에서 지정된 위치에 단일 구성 요소를 추가합니다. 새 구성 요소의 색인에서 또는 이후에이 이름의 구성 요소는 새 구성 요소를 수용하기 위해 색인 0에서 1만큼 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="37338357e8e96989fb2afbdba6ad04ac842085a6" translate="yes" xml:space="preserve">
          <source>Adds a single component to the end of remaining name.</source>
          <target state="translated">나머지 이름 끝에 단일 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5804d8453b19e17bc26b922c017b95cfc51a107b" translate="yes" xml:space="preserve">
          <source>Adds a single component to the end of this LDAP name.</source>
          <target state="translated">이 LDAP 이름 끝에 단일 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ca5a20c39a0d1a61f9538f8ee5f204bc4f8dd7a6" translate="yes" xml:space="preserve">
          <source>Adds a single component to the end of this composite name.</source>
          <target state="translated">이 컴퍼 짓 이름의 말미에 단일의 컴퍼넌트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="123314bd383899f4562fa607f998e70c6be122dc" translate="yes" xml:space="preserve">
          <source>Adds a single component to the end of this compound name.</source>
          <target state="translated">이 복합 이름의 끝에 단일 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e57c9e29626854a1bbe6f1e099f824428226a75c" translate="yes" xml:space="preserve">
          <source>Adds a single component to the end of this name.</source>
          <target state="translated">이 이름의 끝에 단일 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d16bdb65daeb88a78f109d7b9e9e6f324dede52c" translate="yes" xml:space="preserve">
          <source>Adds a unicode locale attribute, if not already present, otherwise has no effect. The attribute must not be null and must be &lt;a href=&quot;locale#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception is thrown.</source>
          <target state="translated">유니 코드 로캘 속성을 추가합니다 (아직없는 경우). 그렇지 않으면 효과가 없습니다. 속성은 null이 아니어야하며 &lt;a href=&quot;locale#def_locale_extension&quot;&gt;올바른 형식&lt;/a&gt; 이어야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eac0aef7b4c99b1ab9f87b93701550b55257efa9" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)</source>
          <target state="translated">지정된 컬렉션의 모든 요소를이 컬렉션에 추가합니다 (선택적 작업). 작업이 진행되는 동안 지정된 컬렉션이 수정되면이 작업의 동작이 정의되지 않습니다. (이는 지정된 컬렉션이이 컬렉션이고이 컬렉션이 비어 있지 않으면이 호출의 동작이 정의되지 않았 음을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="636f6b701f33d61db1e1c32b27f6392ad8bb54d2" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this queue. Attempts to addAll of a queue to itself result in &lt;code&gt;IllegalArgumentException&lt;/code&gt;. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.</source>
          <target state="translated">지정된 컬렉션의 모든 요소를이 큐에 추가합니다. 자체 큐를 모두 추가하려고하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생 합니다. 또한 작업이 진행되는 동안 지정된 컬렉션을 수정하면이 작업의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1066a2f56002ae4cda68c2fbbc393d3f7f3d1f5f" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this set if they're not already present (optional operation). If the specified collection is also a set, the &lt;code&gt;addAll&lt;/code&gt; operation effectively modifies this set so that its value is the</source>
          <target state="translated">지정된 컬렉션에있는 모든 요소가이 세트에없는 경우 추가합니다 (선택적 조작). 지정된 콜렉션도 세트 인 경우, &lt;code&gt;addAll&lt;/code&gt; 오퍼레이션은이 세트가 그 값이</target>
        </trans-unit>
        <trans-unit id="4451c3691577db784db7eebcb8e196e1023ff62f" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this set if they're not already present. If the specified collection is also a set, the &lt;code&gt;addAll&lt;/code&gt; operation effectively modifies this set so that its value is the</source>
          <target state="translated">지정된 컬렉션의 모든 요소가이 세트에없는 경우이 세트에 추가합니다. 지정된 콜렉션도 세트 인 경우, &lt;code&gt;addAll&lt;/code&gt; 오퍼레이션은이 세트가 그 값이</target>
        </trans-unit>
        <trans-unit id="695badb738f0f94d2e40514ec8b5af0e80eccef5" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this set, as if by calling &lt;a href=&quot;concurrenthashmap.keysetview#add-K-&quot;&gt;&lt;code&gt;add(K)&lt;/code&gt;&lt;/a&gt; on each one.</source>
          <target state="translated">각 요소에서 &lt;a href=&quot;concurrenthashmap.keysetview#add-K-&quot;&gt; &lt;code&gt;add(K)&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 지정된 컬렉션의 모든 요소를이 세트에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="bc9d148cd07d7d6e24cc401f6d619a7e2ef64801" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified collection to this set.</source>
          <target state="translated">지정된 컬렉션의 모든 요소를이 세트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8f14033fc2839d9026fe26e44d308ac7ecb0bac5" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the &lt;a href=&quot;docattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. If none of the categories in the specified set are the same as any categories in this attribute set, the &lt;code&gt;addAll()&lt;/code&gt; operation effectively modifies this attribute set so that its value is the</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. 결과는 &lt;a href=&quot;docattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 조작이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것과 같습니다. 지정된 세트의 카테고리 &lt;code&gt;addAll()&lt;/code&gt; 속성 세트의 카테고리와 동일한 카테고리가없는 경우 addAll () 조작은이 속성 세트를 효과적으로 수정하여 해당 값이</target>
        </trans-unit>
        <trans-unit id="d40625dbed9c7528fb89fd6d633f35a55ecb8a6d" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the &lt;a href=&quot;hashattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. The behavior of the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation is unspecified if the specified set is modified while the operation is in progress.</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. 결과는 &lt;a href=&quot;hashattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 조작이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것과 같습니다. 의 동작 &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 의 동작이 진행되는 동안 지정된 세트가 변경되었을 경우 조작이 지정된다.</target>
        </trans-unit>
        <trans-unit id="f53fcc1ae0a0c9fabb15024bbf198400b8598cf9" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the &lt;a href=&quot;printjobattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. If none of the categories in the specified set are the same as any categories in this attribute set, the &lt;code&gt;addAll()&lt;/code&gt; operation effectively modifies this attribute set so that its value is the</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. 결과는 &lt;a href=&quot;printjobattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 조작이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것과 같습니다. 지정된 세트의 카테고리 &lt;code&gt;addAll()&lt;/code&gt; 속성 세트의 카테고리와 동일한 카테고리가없는 경우 addAll () 조작은이 속성 세트를 효과적으로 수정하여 해당 값이</target>
        </trans-unit>
        <trans-unit id="953a79507344ea1161b5a2a9ae6ed3133644e61a" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the &lt;a href=&quot;printrequestattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. If none of the categories in the specified set are the same as any categories in this attribute set, the &lt;code&gt;addAll()&lt;/code&gt; operation effectively modifies this attribute set so that its value is the</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. 결과는 &lt;a href=&quot;printrequestattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 조작이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것과 같습니다. 지정된 세트의 카테고리 &lt;code&gt;addAll()&lt;/code&gt; 속성 세트의 카테고리와 동일한 카테고리가없는 경우 addAll () 조작은이 속성 세트를 효과적으로 수정하여 해당 값이</target>
        </trans-unit>
        <trans-unit id="1eadf11ce7fbab6638cf7b92bf691e7d8b46bb03" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the &lt;a href=&quot;printserviceattributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. If none of the categories in the specified set are the same as any categories in this attribute set, the &lt;code&gt;addAll()&lt;/code&gt; operation effectively modifies this attribute set so that its value is the</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. 결과는 &lt;a href=&quot;printserviceattributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 조작이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것과 같습니다. 지정된 세트의 카테고리 &lt;code&gt;addAll()&lt;/code&gt; 속성 세트의 카테고리와 동일한 카테고리가없는 경우 addAll () 조작은이 속성 세트를 효과적으로 수정하여 해당 값이</target>
        </trans-unit>
        <trans-unit id="7bcb3907e2b1e5884f1e5b2aeae3881fb6a18260" translate="yes" xml:space="preserve">
          <source>Adds all of the elements in the specified set to this attribute. The outcome is the same as if the = &lt;a href=&quot;attributeset#add-javax.print.attribute.Attribute-&quot;&gt;&lt;code&gt;add(Attribute)&lt;/code&gt;&lt;/a&gt; operation had been applied to this attribute set successively with each element from the specified set. The behavior of the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation is unspecified if the specified set is modified while the operation is in progress.</source>
          <target state="translated">지정된 세트의 모든 요소를이 속성에 추가합니다. = &lt;a href=&quot;attributeset#add-javax.print.attribute.Attribute-&quot;&gt; &lt;code&gt;add(Attribute)&lt;/code&gt; &lt;/a&gt; 연산이 지정된 세트의 각 요소와 함께이 속성 세트에 연속적으로 적용된 것처럼 결과가 동일 합니다. 의 동작 &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 의 동작이 진행되는 동안 지정된 세트가 변경되었을 경우 조작이 지정된다.</target>
        </trans-unit>
        <trans-unit id="dfdd6bb3bca2a0f3c97073f871e0e10654450924" translate="yes" xml:space="preserve">
          <source>Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of &lt;code&gt;c.addAll(Arrays.asList(elements))&lt;/code&gt;, but this method is likely to run significantly faster under most implementations.</source>
          <target state="translated">지정된 모든 요소를 ​​지정된 컬렉션에 추가합니다. 추가 할 요소는 개별적으로 또는 배열로 지정할 수 있습니다. 이 편리한 메소드의 동작은 &lt;code&gt;c.addAll(Arrays.asList(elements))&lt;/code&gt; 의 동작과 동일 하지만이 메소드는 대부분의 구현에서 훨씬 더 빠르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c102668cbe2460cdac0b49935e3de93f94298511" translate="yes" xml:space="preserve">
          <source>Adds all the mappings in a given &lt;code&gt;Map&lt;/code&gt; to this &lt;code&gt;Bindings&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Map&lt;/code&gt; 내의 모든 매핑 을이 &lt;code&gt;Bindings&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="782e67e87fa24d34cbc68d73e51a8b22a4a81352" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;IIOReadProgressListener&lt;/code&gt; to the list of registered progress listeners. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action will be taken.</source>
          <target state="translated">등록 된 진행률 리스너 목록에 &lt;code&gt;IIOReadProgressListener&lt;/code&gt; 를 추가합니다 . &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddd8ca14fd7bf0402f538cec2087601fc28da292" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; to the list of registered update listeners. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action will be taken. The listener will receive notification of pixel updates as images and thumbnails are decoded, including the starts and ends of progressive passes.</source>
          <target state="translated">등록 된 업데이트 리스너 목록에 &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; 를 추가합니다 . &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다. 리스너는 점진적 패스의 시작과 끝을 포함하여 이미지와 썸네일이 디코딩 될 때 픽셀 업데이트 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="6849033d7bfd805ada648c403570ea1dd4b9ebe4" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;IIOReadWarningListener&lt;/code&gt; to the list of registered warning listeners. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action will be taken. Messages sent to the given listener will be localized, if possible, to match the current &lt;code&gt;Locale&lt;/code&gt;. If no &lt;code&gt;Locale&lt;/code&gt; has been set, warning messages may be localized as the reader sees fit.</source>
          <target state="translated">등록 된 경고 리스너 목록에 &lt;code&gt;IIOReadWarningListener&lt;/code&gt; 를 추가합니다 . &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다. 주어진 리스너로 전송 된 메시지는 가능한 경우 현재 &lt;code&gt;Locale&lt;/code&gt; 과 일치하도록 현지화됩니다 . &lt;code&gt;Locale&lt;/code&gt; 이 설정 되지 않은 경우 독자가 알맞게 경고 메시지가 현지화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ab2f706259b9a9eccf6bfd737c4d31695271be" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;IIOWriteProgressListener&lt;/code&gt; to the list of registered progress listeners. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action will be taken.</source>
          <target state="translated">등록 된 진행 리스너 목록에 &lt;code&gt;IIOWriteProgressListener&lt;/code&gt; 를 추가합니다 . &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="586abe09e4e773d30a46e51f9a490cc5984e40dc" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;IIOWriteWarningListener&lt;/code&gt; to the list of registered warning listeners. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action will be taken. Messages sent to the given listener will be localized, if possible, to match the current &lt;code&gt;Locale&lt;/code&gt;. If no &lt;code&gt;Locale&lt;/code&gt; has been set, warning messages may be localized as the writer sees fit.</source>
          <target state="translated">&lt;code&gt;IIOWriteWarningListener&lt;/code&gt; 를 등록 된 경고 리스너 목록에 추가합니다 . &lt;code&gt;listener&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , 예외는 발생하지 않고 아무런 조치도 취해지지 않습니다. 주어진 리스너로 전송 된 메시지는 가능한 경우 현재 &lt;code&gt;Locale&lt;/code&gt; 과 일치하도록 현지화됩니다 . &lt;code&gt;Locale&lt;/code&gt; 이 설정 되지 않은 경우 기록기가 적합하다고 경고 메시지가 현지화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c892cb9792e80007245558b6729adbc5a71aa167" translate="yes" xml:space="preserve">
          <source>Adds an ACL entry to this ACL. An entry associates a principal (e.g., an individual or a group) with a set of permissions. Each principal can have at most one positive ACL entry (specifying permissions to be granted to the principal) and one negative ACL entry (specifying permissions to be denied). If there is already an ACL entry of the same type (negative or positive) already in the ACL, false is returned.</source>
          <target state="translated">이 ACL에 ACL 항목을 추가합니다. 항목은 프린시 펄 (예 : 개인 또는 그룹)을 권한 세트와 연관시킵니다. 각 주체는 최대 하나의 긍정적 ACL 항목 (주체에게 부여 할 권한 지정)과 하나의 부정적인 ACL 항목 (거부 할 권한 지정)을 가질 수 있습니다. ACL에 동일한 유형 (음수 또는 양수)의 ACL 항목이 이미 있으면 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a7e3f7b21d82f78c45773810d3fc8c2be6523f1d" translate="yes" xml:space="preserve">
          <source>Adds an MBean created by the user (and registered by him in the MBean Server) as a relation in the Relation Service.</source>
          <target state="translated">사용자가 작성하고 MBean 서버에 등록한 MBean을 관계 서비스의 관계로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="364c1e48f2b02f23bb10cba802893661c7f59c90" translate="yes" xml:space="preserve">
          <source>Adds an address to the end of the list of addresses.</source>
          <target state="translated">주소 목록 끝에 주소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="610705f3c51002c9287ce59ccec32d284626d559" translate="yes" xml:space="preserve">
          <source>Adds an address to the list of addresses at index posn. All addresses at index posn or greater are shifted up the list by one (away from index 0).</source>
          <target state="translated">인덱스 위치의 주소 목록에 주소를 추가합니다. 인덱스 posn 이상의 모든 주소는 목록 0 씩 올라갑니다 (인덱스 0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="a8e6d134f695c6f2d6ed6bf646466c7c65e0eeac" translate="yes" xml:space="preserve">
          <source>Adds an attribute to a subrange of the string.</source>
          <target state="translated">문자열의 하위 범위에 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4c4b5a49a04e67e1747c7c2a034ec52a2ec63c87" translate="yes" xml:space="preserve">
          <source>Adds an attribute to the entire string.</source>
          <target state="translated">전체 문자열에 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e9f3dab7ec68d21d05803085165396021333764e" translate="yes" xml:space="preserve">
          <source>Adds an attribute value to the ordered list of attribute values. This method adds &lt;code&gt;attrVal&lt;/code&gt; to the list of attribute values at index &lt;code&gt;ix&lt;/code&gt;. Values located at indices at or greater than &lt;code&gt;ix&lt;/code&gt; are shifted down towards the end of the list (and their indices incremented by one). If the attribute values are unordered and already have &lt;code&gt;attrVal&lt;/code&gt;, &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">정렬 된 속성 값 목록에 속성 값을 추가합니다. 이 메소드는 인덱스 &lt;code&gt;ix&lt;/code&gt; 의 속성 값 목록에 &lt;code&gt;attrVal&lt;/code&gt; 을 추가합니다 . &lt;code&gt;ix&lt;/code&gt; 이상의 인덱스에있는 값 은 목록의 끝으로 내려갑니다 (그 인덱스는 1 씩 증가합니다). 속성 값이 순서 붙일 이미있는 경우 &lt;code&gt;attrVal&lt;/code&gt; 를 , &lt;code&gt;IllegalStateException&lt;/code&gt; 이가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="a027ae5fe5e8649848aad6bf6bd8de0d2802b532" translate="yes" xml:space="preserve">
          <source>Adds an element to the stream being built.</source>
          <target state="translated">빌드중인 스트림에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bafc70558c35c1680474f4df692d0b0d4c520e47" translate="yes" xml:space="preserve">
          <source>Adds an event listener to be invoked when the logging properties are re-read. Adding multiple instances of the same event Listener results in multiple entries in the property event listener table.</source>
          <target state="translated">로깅 특성을 다시 읽을 때 호출 할 이벤트 리스너를 추가합니다. 동일한 이벤트 리스너의 여러 인스턴스를 추가하면 특성 이벤트 리스너 테이블에 여러 항목이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="458685d5a0c44d4a3dff32d7b379daef0ba0a8c2" translate="yes" xml:space="preserve">
          <source>Adds an existing element to the list of legal children for a given parent node type.</source>
          <target state="translated">주어진 부모 노드 유형의 법적 자식 목록에 기존 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1067d2f87190d8c26cf106946e04c78ddab7240e" translate="yes" xml:space="preserve">
          <source>Adds an identity to this identity scope.</source>
          <target state="translated">이 ID 범위에 ID를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0e0a7686238b4a3b11aab0c90ca5c4bd3f520cbb" translate="yes" xml:space="preserve">
          <source>Adds an observer to the set of observers for this object, provided that it is not the same as some observer already in the set. The order in which notifications will be delivered to multiple observers is not specified. See the class comment.</source>
          <target state="translated">세트에 이미있는 일부 옵저버와 동일하지 않은 경우이 오브젝트의 옵저버 세트에 옵저버를 추가합니다. 여러 옵저버에게 알림이 전달되는 순서는 지정되지 않았습니다. 수업 댓글을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="210546247fed00df19efddf678bf4cdae638ce2f" translate="yes" xml:space="preserve">
          <source>Adds an owner. Only owners can modify ACL contents. The caller principal must be an owner of the ACL in order to invoke this method. That is, only an owner can add another owner. The initial owner is configured at ACL construction time.</source>
          <target state="translated">소유자를 추가합니다. 소유자 만 ACL 내용을 수정할 수 있습니다. 이 메소드를 호출하려면 호출자 프린시 펄이 ACL의 소유자 여야합니다. 즉, 소유자 만 다른 소유자를 추가 할 수 있습니다. 초기 소유자는 ACL 구성 시간에 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d36763221dc40a19a314ee9d32518b6874f34790" translate="yes" xml:space="preserve">
          <source>Adds components to the end of remaining name.</source>
          <target state="translated">나머지 이름 끝에 구성 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e709ea37614d8b1ec1fcf35d82bb6f6081b4bfc0" translate="yes" xml:space="preserve">
          <source>Adds given object as a relation type. The object is expected to implement the RelationType interface.</source>
          <target state="translated">주어진 객체를 관계 유형으로 추가합니다. 개체는 RelationType 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="df08538eaf996889cde6132c5c6a5aa9e961dff7" translate="yes" xml:space="preserve">
          <source>Adds one HTTP cookie to the store. This is called for every incoming HTTP response.</source>
          <target state="translated">상점에 하나의 HTTP 쿠키를 추가합니다. 이것은 들어오는 모든 HTTP 응답에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2d40297c3a5065c526591a1687d019fad02d3485" translate="yes" xml:space="preserve">
          <source>Adds or replaces descriptors in the ModelMBeanInfo.</source>
          <target state="translated">ModelMBeanInfo에서 디스크립터를 추가하거나 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c2508bfb43021888242f761be2177c432e64c80c" translate="yes" xml:space="preserve">
          <source>Adds or subtracts (up/down) a single unit of time on the given time field without changing larger fields.</source>
          <target state="translated">더 큰 필드를 변경하지 않고 주어진 시간 필드에서 단일 시간 단위를 더하거나 뺍니다 (위 / 아래).</target>
        </trans-unit>
        <trans-unit id="a7ccb23840b5d9a53b3596f54f7524409a5db592" translate="yes" xml:space="preserve">
          <source>Adds or subtracts (up/down) a single unit of time on the given time field without changing larger fields. For example, to roll the current date up by one day, you can achieve it by calling:</source>
          <target state="translated">더 큰 필드를 변경하지 않고 주어진 시간 필드에서 단일 시간 단위를 더하거나 뺍니다 (위 / 아래). 예를 들어, 현재 날짜를 하루 씩 롤업하려면 다음을 호출하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad35e7646ac69d3d4e62f8137cad3c30a84e408" translate="yes" xml:space="preserve">
          <source>Adds or subtracts the specified amount of time to the given calendar field, based on the calendar's rules. For example, to subtract 5 days from the current time of the calendar, you can achieve it by calling:</source>
          <target state="translated">캘린더 규칙에 따라 지정된 캘린더 필드에 지정된 시간을 더하거나 뺍니다. 예를 들어, 달력의 현재 시간에서 5 일을 빼려면 다음을 호출하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9648edc87b62b6806de590e5b19fba83c372fe69" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;Attribute&lt;/code&gt; specified as the last element of the list.</source>
          <target state="translated">목록의 마지막 요소로 지정된 &lt;code&gt;Attribute&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7741aa0afd5fe11742b92c355b8e0320a735875d" translate="yes" xml:space="preserve">
          <source>Adds the RDNs of a name -- in order -- at a specified position within this name. RDNs of this LDAP name at or after the index (if any) of the first new RDN are shifted up (away from index 0) to accommodate the new RDNs.</source>
          <target state="translated">이 이름 내에서 지정된 위치에 이름의 RDN을 순서대로 추가합니다. 새 RDN을 수용하기 위해 첫 번째 새 RDN의 인덱스 (있는 경우) 또는 그 이후에이 LDAP 이름의 RDN이 위로 이동합니다 (인덱스 0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="e886cefd80055a9c7c79962aed059684445805a3" translate="yes" xml:space="preserve">
          <source>Adds the RDNs of a name -- in order -- to the end of this name.</source>
          <target state="translated">이 이름의 끝에 이름의 RDN을 순서대로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ed81420cc31b7ad51003aaf2090695fb486b156e" translate="yes" xml:space="preserve">
          <source>Adds the Role specified as the last element of the list.</source>
          <target state="translated">목록의 마지막 요소로 지정된 역할을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="af8fdbd5d359d3ad36e406179c229eddba16da94" translate="yes" xml:space="preserve">
          <source>Adds the RoleUnresolved specified as the last element of the list.</source>
          <target state="translated">목록의 마지막 요소로 지정된 RoleUnresolved를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5247f0aad1e1a4d0916c5cc4ab18619368dd0d99" translate="yes" xml:space="preserve">
          <source>Adds the amount to the specified temporal object using the logic encapsulated in the implementing class.</source>
          <target state="translated">구현 클래스에 캡슐화 된 논리를 사용하여 지정된 시간 오브젝트에 금액을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="784da8684a9a9d9e614f7b0c9b4e649e0a99b6a7" translate="yes" xml:space="preserve">
          <source>Adds the components of a composite name -- in order -- at a specified position within this composite name. Components of this composite name at or after the index of the first new component are shifted up (away from index 0) to accommodate the new components.</source>
          <target state="translated">이 컴퍼 짓 이름 내의 지정된 위치에 컴퍼 짓 이름의 컴퍼넌트를 순서대로 추가합니다. 새 구성 요소를 수용하기 위해 첫 번째 새 구성 요소의 색인 시점 또는 이후에이 복합 이름의 구성 요소가 위로 이동합니다 (색인 0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="7dcd70e11630d8152db45fd6bd19a3d9b1a9bd52" translate="yes" xml:space="preserve">
          <source>Adds the components of a composite name -- in order -- to the end of this composite name.</source>
          <target state="translated">이 컴퍼 짓 이름의 말미에 컴퍼 짓 이름의 컴퍼넌트를 순서대로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="77ca4e3e1f142b0d69d4f260e8690ba20f4df1d6" translate="yes" xml:space="preserve">
          <source>Adds the components of a compound name -- in order -- at a specified position within this compound name. Components of this compound name at or after the index of the first new component are shifted up (away from index 0) to accommodate the new components.</source>
          <target state="translated">이 복합 이름 내에서 지정된 위치에 복합 이름의 구성 요소를 순서대로 추가합니다. 첫 번째 새 구성 요소의 색인에서 또는 이후에이 복합 이름의 구성 요소가 새 구성 요소를 수용하도록 위로 이동합니다 (색인 0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="5a77648f256d51c21382f560aad6fc9bf9f2b82d" translate="yes" xml:space="preserve">
          <source>Adds the components of a compound name -- in order -- to the end of this compound name.</source>
          <target state="translated">복합 이름의 구성 요소를이 복합 이름의 끝에 순서대로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="136441298e06faf27473a785d31eedb05b19e677" translate="yes" xml:space="preserve">
          <source>Adds the components of a name -- in order -- at a specified position within this name. Components of this LDAP name at or after the index (if any) of the first new component are shifted up (away from index 0) to accommodate the new components.</source>
          <target state="translated">이 이름 내에서 지정된 위치에 이름의 구성 요소를 순서대로 추가합니다. 새 구성 요소를 수용하기 위해 첫 번째 새 구성 요소의 색인 (있는 경우) 또는 그 이후에이 LDAP 이름의 구성 요소가 위로 이동합니다 (인덱스 0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="0f8233144a35f76f40ab1bf91b6d1145a6828927" translate="yes" xml:space="preserve">
          <source>Adds the components of a name -- in order -- at a specified position within this name. Components of this name at or after the index of the first new component are shifted up (away from 0) to accommodate the new components.</source>
          <target state="translated">이 이름 내에서 지정된 위치에 이름의 구성 요소를 순서대로 추가합니다. 첫 번째 새 구성 요소의 색인에서 또는 그 이후에이 이름의 구성 요소가 새 구성 요소를 수용하도록 위로 이동합니다 (0에서 멀어짐).</target>
        </trans-unit>
        <trans-unit id="d6db8622d0b5869b640dfd7e55ea2a8196dc8fe4" translate="yes" xml:space="preserve">
          <source>Adds the components of a name -- in order -- to the end of this name.</source>
          <target state="translated">이름의 구성 요소를 순서대로이 이름의 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b5cb72ad8c38b05cfb75984e2afde28c11d3694" translate="yes" xml:space="preserve">
          <source>Adds the contents of the given &lt;code&gt;StringJoiner&lt;/code&gt; without prefix and suffix as the next element if it is non-empty. If the given &lt;code&gt;StringJoiner&lt;/code&gt; is empty, the call has no effect.</source>
          <target state="translated">지정된 &lt;code&gt;StringJoiner&lt;/code&gt; 의 컨텐츠를 접두어 및 접미 부가 없는 다음 요소가 비어 있지 않은 경우 다음 요소로 추가합니다 . 주어진 &lt;code&gt;StringJoiner&lt;/code&gt; 가 비어 있으면 호출이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8854e0f11d9b0e1845190cc7db61b48df2a221b" translate="yes" xml:space="preserve">
          <source>Adds the given number of new unarrived parties to this phaser. If an ongoing invocation of &lt;a href=&quot;phaser#onAdvance-int-int-&quot;&gt;&lt;code&gt;onAdvance(int, int)&lt;/code&gt;&lt;/a&gt; is in progress, this method may await its completion before returning. If this phaser has a parent, and the given number of parties is greater than zero, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.</source>
          <target state="translated">지정된 수의 새로운 도착하지 않은 당사자를이 단계에 추가합니다. &lt;a href=&quot;phaser#onAdvance-int-int-&quot;&gt; &lt;code&gt;onAdvance(int, int)&lt;/code&gt; &lt;/a&gt; 의 진행중인 호출이 진행중인 경우 ,이 메소드는 리턴하기 전에 완료를 기다릴 수 있습니다. 이 단계에 부모가 있고 주어진 당사자 수가 0보다 크고이 단계에 이전에 등록 된 당사자가없는 경우이 하위 단계도 부모에 등록됩니다. 이 페이저가 종료되면 등록 시도가 효과가 없으며 음수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5196280bdbf0911b832101959c244d31d86f118f" translate="yes" xml:space="preserve">
          <source>Adds the given printer state reason to this printer state reasons attribute, associating it with the given severity level. If this printer state reasons attribute previously contained a mapping for the given printer state reason, the old value is replaced.</source>
          <target state="translated">지정된 프린터 상태 이유를이 프린터 상태 이유 속성에 추가하여 지정된 심각도 수준과 연관시킵니다. 이 프린터 상태 이유 속성에 이전에 지정된 프린터 상태 이유에 대한 맵핑이 포함 된 경우 이전 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="39d46abd35feed4a908dc77eee59e9771185456d" translate="yes" xml:space="preserve">
          <source>Adds the given value.</source>
          <target state="translated">주어진 값을 더합니다.</target>
        </trans-unit>
        <trans-unit id="70cef8cffcc400613b927438d756791afb6aa01b" translate="yes" xml:space="preserve">
          <source>Adds the node &lt;code&gt;newChild&lt;/code&gt; to the end of the list of children of this node.</source>
          <target state="translated">이 노드의 자식 목록 끝에 &lt;code&gt;newChild&lt;/code&gt; 노드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="46236f348081dab53560fca5babce61c19133379" translate="yes" xml:space="preserve">
          <source>Adds the specified (signed) amount of time to the given calendar field, based on the calendar's rules.</source>
          <target state="translated">달력 규칙에 따라 지정된 (서명 된) 시간을 주어진 달력 필드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4e8efb42f5e7f5c07a3e4c987c66a889b6146433" translate="yes" xml:space="preserve">
          <source>Adds the specified (signed) amount to the specified calendar field without changing larger fields. A negative amount means to roll down.</source>
          <target state="translated">더 큰 필드를 변경하지 않고 지정된 (서명 된) 금액을 지정된 일정 필드에 추가합니다. 음수는 롤 다운을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b522972f6c265807bc41d8b03fb286628a87436e" translate="yes" xml:space="preserve">
          <source>Adds the specified &lt;code&gt;BeanContextMembershipListener&lt;/code&gt; to receive &lt;code&gt;BeanContextMembershipEvents&lt;/code&gt; from this &lt;code&gt;BeanContext&lt;/code&gt; whenever it adds or removes a child &lt;code&gt;Component&lt;/code&gt;(s).</source>
          <target state="translated">지정된 추가 &lt;code&gt;BeanContextMembershipListener&lt;/code&gt; 를을 받을 &lt;code&gt;BeanContextMembershipEvents&lt;/code&gt; 이에서 &lt;code&gt;BeanContext&lt;/code&gt; 가 추가 또는 아이 제거 할 때마다 &lt;code&gt;Component&lt;/code&gt; (들).</target>
        </trans-unit>
        <trans-unit id="cfaa0d2e43cb541dc00719f8f6b6affb1855878b" translate="yes" xml:space="preserve">
          <source>Adds the specified attribute to this attribute set if it is not already present, first removing any existing in the same attribute category as the specified attribute value.</source>
          <target state="translated">지정된 속성이없는 경우이 속성 세트에 지정된 속성을 추가하여 지정된 속성 값과 동일한 속성 범주에있는 기존 속성을 먼저 제거합니다.</target>
        </trans-unit>
        <trans-unit id="695f4912181d77a1f14c13b45c8d895d173212eb" translate="yes" xml:space="preserve">
          <source>Adds the specified attribute to this attribute set if it is not already present, first removing any existing value in the same attribute category as the specified attribute value.</source>
          <target state="translated">지정된 속성이없는 경우이 속성 세트에 지정된 속성을 추가하여 지정된 속성 값과 동일한 속성 범주의 기존 값을 먼저 제거합니다.</target>
        </trans-unit>
        <trans-unit id="964cc926937f6fe4b9f8f454249ff5cdb45d2627" translate="yes" xml:space="preserve">
          <source>Adds the specified attribute value to this attribute set if it is not already present, first removing any existing value in the same attribute category as the specified attribute value (optional operation).</source>
          <target state="translated">지정된 속성 값이없는 경우이 속성 세트에 지정된 속성 값을 추가하여 지정된 속성 값과 동일한 속성 범주의 기존 값을 먼저 제거합니다 (선택적 조작).</target>
        </trans-unit>
        <trans-unit id="9d079134144dadea93ef07e4f08261c891e4ea60" translate="yes" xml:space="preserve">
          <source>Adds the specified component to the end of this vector, increasing its size by one. The capacity of this vector is increased if its size becomes greater than its capacity.</source>
          <target state="translated">지정된 구성 요소를이 벡터의 끝에 추가하여 크기를 1만큼 증가시킵니다. 크기가 용량보다 커지면이 벡터의 용량이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a422fb8ecc6a301f88c622f0a8f2274fa3519326" translate="yes" xml:space="preserve">
          <source>Adds the specified element as the tail (last element) of this list.</source>
          <target state="translated">지정된 요소를이 목록의 꼬리 (마지막 요소)로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdb93a6b34afe7e0d88dfbf54ae738a4bf7ec285" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this job state reasons attribute if it is not already present. The element to be added must be an instance of class &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt;. If this job state reasons attribute already contains the specified element, the call leaves this job state reasons attribute unchanged and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 요소를이 작업 상태 이유 속성에 아직 추가하지 않은 경우 추가합니다. 추가 할 요소는 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 여야합니다 . 이 작업 상태 이유 속성에 이미 지정된 요소가 포함 된 경우, 호출은이 작업 상태 이유 속성을 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a6bf38f579a34c41f921fd4871d637039e90aa7f" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this queue, waiting if necessary for another thread to receive it.</source>
          <target state="translated">지정된 요소를이 큐에 추가하고 다른 스레드가이를 수신 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="3e13c6385d2fc62dc197c5c50940afd9cb27a8e0" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element &lt;code&gt;e&lt;/code&gt; to this set if the set contains no element &lt;code&gt;e2&lt;/code&gt; such that &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt;. If this set already contains the element, the call leaves the set unchanged and returns &lt;code&gt;false&lt;/code&gt;. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements.</source>
          <target state="translated">지정된 요소가없는 경우이 세트에 지정된 요소를 추가합니다 (선택적 조작). 더 공식적으로, 세트에 요소 &lt;code&gt;e2&lt;/code&gt; 가 포함되어 있지 않으면 &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt; 와 같이 지정된 요소 &lt;code&gt;e&lt;/code&gt; 를이 세트에 추가합니다 . 이 세트에 이미 요소가 포함되어있는 경우, 호출은 세트를 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 . 생성자에 대한 제한과 결합하여 세트에 중복 요소가 포함되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="e2c656a18a898157ddacdc93f273921484c69930" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this set if it is not already present. More formally, adds the specified element &lt;code&gt;e&lt;/code&gt; to this set if the set contains no element &lt;code&gt;e2&lt;/code&gt; such that &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt;. If this set already contains the element, the call leaves the set unchanged and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 요소가 아직 없으면이 세트에 추가합니다. 더 공식적으로, 세트에 요소 &lt;code&gt;e2&lt;/code&gt; 가 포함되어 있지 않으면 &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt; 와 같이 지정된 요소 &lt;code&gt;e&lt;/code&gt; 를이 세트에 추가합니다 . 이 세트에 이미 요소가 포함되어있는 경우, 호출은 세트를 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="f0c05443b8735e7e608a81b5d7a015723cf03df9" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this set if it is not already present. More formally, adds the specified element &lt;code&gt;e&lt;/code&gt; to this set if the set contains no element &lt;code&gt;e2&lt;/code&gt; such that &lt;code&gt;e.equals(e2)&lt;/code&gt;. If this set already contains the element, the call leaves the set unchanged and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 요소가 아직 없으면이 세트에 추가합니다. 더 공식적으로, 세트 에 &lt;code&gt;e.equals(e2)&lt;/code&gt; 와 같은 요소 &lt;code&gt;e2&lt;/code&gt; 가 없으면 지정된 요소 &lt;code&gt;e&lt;/code&gt; 를이 세트에 추가합니다 . 이 세트에 이미 요소가 포함되어있는 경우, 호출은 세트를 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d6b90a13bdb069c77d7b98b6955762b2bb1e8636" translate="yes" xml:space="preserve">
          <source>Adds the specified element to this set if it is not already present. More formally, adds the specified element &lt;code&gt;e&lt;/code&gt; to this set if this set contains no element &lt;code&gt;e2&lt;/code&gt; such that &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt;. If this set already contains the element, the call leaves the set unchanged and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 요소가 아직 없으면이 세트에 추가합니다. 보다 공식적으로, 이 세트 에 &lt;code&gt;(e==null ? e2==null : e.equals(e2))&lt;/code&gt; 와 같이 요소 &lt;code&gt;e2&lt;/code&gt; 가 포함되어 있지 않으면 지정된 요소 &lt;code&gt;e&lt;/code&gt; 를이 세트에 추가합니다 . 이 세트에 이미 요소가 포함되어있는 경우, 호출은 세트를 변경하지 않고 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d8cab7d0c93e0caab0a11e9bb777b644459aa230" translate="yes" xml:space="preserve">
          <source>Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.</source>
          <target state="translated">정의 된 경우 키를 백업 맵의 기본 맵핑 된 값에 맵핑하여 지정된 키를이 세트보기에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="658e961a2e13c34c739fcc4ceff3d17be0148c27" translate="yes" xml:space="preserve">
          <source>Adds the specified member to the group.</source>
          <target state="translated">지정된 멤버를 그룹에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="902a8ce346b5e159a10babd6f40ae7829cc66196" translate="yes" xml:space="preserve">
          <source>Adds the specified object in the set of observed MBeans, if this object is not already present.</source>
          <target state="translated">이 오브젝트가 존재하지 않는 경우, 감시 대상 MBean 세트에 지정된 오브젝트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="52dce3c64b716e93533cc10ec20d70562527d488" translate="yes" xml:space="preserve">
          <source>Adds the specified object in the set of observed MBeans.</source>
          <target state="translated">감시 대상의 MBean 세트에 지정된 객체를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6d52f9a7a131bc106816fd03c34fd77ad13a9f01" translate="yes" xml:space="preserve">
          <source>Adds the specified permission to this ACL entry. Note: An entry can have multiple permissions.</source>
          <target state="translated">이 ACL 항목에 지정된 권한을 추가합니다. 참고 : 항목에는 여러 권한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86a3796af25197514b4b17fc1fa4866a200f0cbc" translate="yes" xml:space="preserve">
          <source>Adds this duration to the specified temporal object.</source>
          <target state="translated">이 시간을 지정된 시간 객체에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="df05971b7107f02edd3fea422fff04a5942de16f" translate="yes" xml:space="preserve">
          <source>Adds this period to the specified temporal object.</source>
          <target state="translated">지정된 시간 객체에이 기간을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dc650a41f24915b13ffaa0a1b87271c12874d5ca" translate="yes" xml:space="preserve">
          <source>Adds this reference object to the queue with which it is registered, if any.</source>
          <target state="translated">이 참조 객체를 등록 된 큐에 추가합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="6315404bd6e648a5551276de49ee9239ec0fcd61" translate="yes" xml:space="preserve">
          <source>Adds to the specified temporal object.</source>
          <target state="translated">지정된 임시 객체에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e3b0ae153114dc89cbcb7ee4df7f9cd55598503" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;double&lt;/code&gt; values together as per the + operator.</source>
          <target state="translated">+ 연산자에 따라 두 개의 &lt;code&gt;double&lt;/code&gt; 값을 더합니다.</target>
        </trans-unit>
        <trans-unit id="c8ecd5a68a0d864a51a2ab18ec0830c6ae316daf" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;float&lt;/code&gt; values together as per the + operator.</source>
          <target state="translated">+ 연산자에 따라 두 개의 &lt;code&gt;float&lt;/code&gt; 값을 더합니다.</target>
        </trans-unit>
        <trans-unit id="400c508b0357e9e65a3bca36fa601632c14712e2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;long&lt;/code&gt; values together as per the + operator.</source>
          <target state="translated">+ 연산자에 따라 두 개의 &lt;code&gt;long&lt;/code&gt; 값을 더합니다.</target>
        </trans-unit>
        <trans-unit id="99b4dc2099c1857f27780c44d692c7cd88ffc405" translate="yes" xml:space="preserve">
          <source>Adds two integers together as per the + operator.</source>
          <target state="translated">+ 연산자에 따라 두 개의 정수를 더합니다.</target>
        </trans-unit>
        <trans-unit id="71d604b7f7e03c7fa14b46dc3a5a31c6c4cceabd" translate="yes" xml:space="preserve">
          <source>Adds/nests a child within this &lt;code&gt;BeanContext&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;BeanContext&lt;/code&gt; 내에 아이를 추가 또는 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="d4a30f4a2824a23df3c62061f89f979e93398978" translate="yes" xml:space="preserve">
          <source>Adjacent value parsing applies to each set of fixed width not-negative values in the parser that immediately follow any kind of value, variable or fixed width. Calling any other append method will end the setup of adjacent value parsing. Thus, in the unlikely event that you need to avoid adjacent value parsing behavior, simply add the &lt;code&gt;appendValue&lt;/code&gt; to another &lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt; and add that to this builder.</source>
          <target state="translated">인접 값 구문 분석은 파서의 각 고정 너비 비음 수 값 세트에 적용되며, 이는 모든 종류의 값, 가변 또는 고정 너비를 즉시 따릅니다. 다른 append 메소드를 호출하면 인접한 값 구문 분석 설정이 종료됩니다. 따라서 인접 값 구문 분석 동작을 피해야하는 경우가 &lt;code&gt;appendValue&lt;/code&gt; 를 다른 &lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt; 에 추가하고이 빌더에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f8c9b54b60307e0480d7196082d6bca559a05bac" translate="yes" xml:space="preserve">
          <source>Adjust the day-of-month to the last valid day if necessary</source>
          <target state="translated">필요한 경우 날짜를 마지막 유효일로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8679f2df25a840864ad4e3ea21fb87a28303a54f" translate="yes" xml:space="preserve">
          <source>Adjusters are a key tool for modifying temporal objects. They exist to externalize the process of adjustment, permitting different approaches, as per the strategy design pattern. Examples might be an adjuster that sets the date avoiding weekends, or one that sets the date to the last day of the month.</source>
          <target state="translated">조절기는 임시 객체를 수정하기위한 핵심 도구입니다. 전략 설계 패턴에 따라 다양한 접근 방식을 허용하면서 조정 프로세스를 외부화하기 위해 존재합니다. 주말을 피하는 날짜를 설정하는 조정자 또는 날짜를 해당 월의 마지막 날로 설정하는 조정자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d6566fd533156f3fe3ae843c3eaae6428e1c35" translate="yes" xml:space="preserve">
          <source>Adjustment and Query</source>
          <target state="translated">조정 및 쿼리</target>
        </trans-unit>
        <trans-unit id="7a0c0730e23e1c30e36d3d8f6d861d16fcc48523" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same date and time as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 동일한 날짜 및 시간을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="c75f83ec5587e314435d865398e3fd588ba25be4" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same date as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 같은 날짜를 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="d0e78905f722ac0d9d7cbeb8ca0ef556cb3be68e" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same era as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 같은 시대를 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="98df78b89f51ceb8f1459fe00c40d897897516c3" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same offset and time as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 동일한 오프셋 및 시간을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="112c143205816dc84da5c55ea177f93f9b06f78e" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same offset as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 동일한 오프셋을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="009bdbe56851b4a5d1481ba57005dec54f511838" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same offset, date and time as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 동일한 오프셋, 날짜 및 시간을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="02ad018d447bb9659f2e250b5ad5b2dcd59ad80b" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have the same time as this object.</source>
          <target state="translated">지정된 시간 객체가이 객체와 같은 시간을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="d94f1056ed88b91cc1314a23c0eec5487ce00903" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this day-of-week.</source>
          <target state="translated">지정된 시간 객체가이 요일을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="525796e1588d76792457949dbbfd31d7d22aa8cb" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this instant.</source>
          <target state="translated">이 순간을 갖도록 지정된 시간 객체를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="2653e8fe83785530f8bd209fc6ea671cec58bdba" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this month-day.</source>
          <target state="translated">이 달-일을 갖도록 지정된 시간 오브젝트를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="c42e041acc4037d9a408d6fce1404689d047d7a8" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this month-of-year.</source>
          <target state="translated">지정된 시간 객체가이 달을 갖도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="ac4d1b5d1a1e936157e1d8e310b96d98eb1f194e" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this year-month.</source>
          <target state="translated">지정된 시간 개체가 올해 한 달이되도록 조정합니다.</target>
        </trans-unit>
        <trans-unit id="6a0eecc1a88aadcb50b8e9cc8637e8af1c6e873e" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object to have this year.</source>
          <target state="translated">지정된 시간 오브젝트를 올해로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="d7fd3695a2cc1a32d4209e2f69a8536bb67d0387" translate="yes" xml:space="preserve">
          <source>Adjusts the specified temporal object.</source>
          <target state="translated">지정된 시간 객체를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e4adac74ebddef7c16a56b34cb06aa2794b83afd" translate="yes" xml:space="preserve">
          <source>Adjusts this channel's blocking mode.</source>
          <target state="translated">이 채널의 차단 모드를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="15916ea228038978ff5e724cafbd80324fd51736" translate="yes" xml:space="preserve">
          <source>Adler32</source>
          <target state="translated">Adler32</target>
        </trans-unit>
        <trans-unit id="314b3c49a201959df9ad0e3a5ae12910091680b1" translate="yes" xml:space="preserve">
          <source>Adler32.getValue()</source>
          <target state="translated">Adler32.getValue()</target>
        </trans-unit>
        <trans-unit id="c31b81abea2f0d616d56ca6a59c4971a76e112d6" translate="yes" xml:space="preserve">
          <source>Adler32.reset()</source>
          <target state="translated">Adler32.reset()</target>
        </trans-unit>
        <trans-unit id="9df3bc683180f3c68411c5000af71adb45798e06" translate="yes" xml:space="preserve">
          <source>Adler32.update()</source>
          <target state="translated">Adler32.update()</target>
        </trans-unit>
        <trans-unit id="3df7f00c8bc62dd77270ddc5b724d55b08dbb0e4" translate="yes" xml:space="preserve">
          <source>Advances the current stream position by calling &lt;code&gt;seek(getStreamPosition() + n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seek(getStreamPosition() + n)&lt;/code&gt; 을 호출하여 현재 스트림 위치를 전진시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1476cdace0a11bdceb7d379f8e242833f093ec0c" translate="yes" xml:space="preserve">
          <source>Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line.</source>
          <target state="translated">이 스캐너를 현재 줄을 지나서 넘어간 후 건너 뛴 입력을 반환합니다. 이 메소드는 끝에있는 줄 구분 기호를 제외한 나머지 현재 줄을 반환합니다. 위치는 다음 줄의 시작으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="339c67d67296c865aed4bb18f74d35b419152d7c" translate="yes" xml:space="preserve">
          <source>Affected Method</source>
          <target state="translated">영향을받는 방법</target>
        </trans-unit>
        <trans-unit id="66f25fa0688e0f979d969ce2857f8f4d5004cf01" translate="yes" xml:space="preserve">
          <source>Affected Method(s)</source>
          <target state="translated">영향을받는 방법</target>
        </trans-unit>
        <trans-unit id="a5b1371bdd923c16a94d39c1cd7831555f05a2b2" translate="yes" xml:space="preserve">
          <source>After a call to the &lt;code&gt;nextToken&lt;/code&gt; method, this field contains the type of the token just read. For a single character token, its value is the single character, converted to an integer. For a quoted string token, its value is the quote character. Otherwise, its value is one of the following:</source>
          <target state="translated">&lt;code&gt;nextToken&lt;/code&gt; 메소드를 호출 한 후이 필드에는 방금 읽은 토큰 유형이 포함됩니다. 단일 문자 토큰의 경우 해당 값은 단일 문자이며 정수로 변환됩니다. 인용 문자열 토큰의 경우 해당 값은 인용 문자입니다. 그렇지 않으면 그 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="deb4f2ec36793cea1b653c9479f770d64c8091f2" translate="yes" xml:space="preserve">
          <source>After a channel is closed, any further attempt to invoke I/O operations upon it will cause a &lt;a href=&quot;closedchannelexception&quot;&gt;&lt;code&gt;ClosedChannelException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">채널이 닫힌 후, 채널에서 I / O 조작을 추가로 시도하면 &lt;a href=&quot;closedchannelexception&quot;&gt; &lt;code&gt;ClosedChannelException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="143b121780fe7763058875e9edef803ffe913c60" translate="yes" xml:space="preserve">
          <source>After a file system is closed then all subsequent access to the file system, either by methods defined by this class or on objects associated with this file system, throw &lt;a href=&quot;closedfilesystemexception&quot;&gt;&lt;code&gt;ClosedFileSystemException&lt;/code&gt;&lt;/a&gt;. If the file system is already closed then invoking this method has no effect.</source>
          <target state="translated">파일 시스템이 닫힌 후에는이 클래스에 의해 정의 된 메소드 또는이 파일 시스템과 연관된 오브젝트에서 파일 시스템에 대한 모든 후속 액세스가 &lt;a href=&quot;closedfilesystemexception&quot;&gt; &lt;code&gt;ClosedFileSystemException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 파일 시스템이 이미 닫혀 있으면이 방법을 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6485ae1d2e2d9b5d6430d60d07c069b720d3588c" translate="yes" xml:space="preserve">
          <source>After a selector is closed, any further attempt to use it, except by invoking this method or the &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method, will cause a &lt;a href=&quot;closedselectorexception&quot;&gt;&lt;code&gt;ClosedSelectorException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">셀렉터를 닫은 후에는이 메소드 또는 &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하지 않는 한 셀렉터를 사용하려고 하면 &lt;a href=&quot;closedselectorexception&quot;&gt; &lt;code&gt;ClosedSelectorException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9871f70b0b29bf280dca369cdd987a4626aa6e98" translate="yes" xml:space="preserve">
          <source>After a sequence of channel-read or</source>
          <target state="translated">일련의 채널 읽기 또는</target>
        </trans-unit>
        <trans-unit id="64c8cf99b33336bd9712ccb4e03b76962c9a5b98" translate="yes" xml:space="preserve">
          <source>After a watch service is closed, any further attempt to invoke operations upon it will throw &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. If this watch service is already closed then invoking this method has no effect.</source>
          <target state="translated">감시 서비스가 닫힌 후에는 추가 작업을 시도하면 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 이 시계 서비스가 이미 닫힌 경우이 방법을 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4a2fd9f051afd0fdf9ea63168c90b67d3be804b" translate="yes" xml:space="preserve">
          <source>After an explicit open (either before or after implicit opens), the device will not be closed by implicit closing. The only way to close an explicitly opened device is an explicit close.</source>
          <target state="translated">명시 적 열림 후 (암시 적 열림 전후) 장치는 암묵적 닫힘으로 닫히지 않습니다. 명시 적으로 열린 장치를 닫는 유일한 방법은 명시 적으로 닫는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3f13767be49eb869df5704822740a5994f725445" translate="yes" xml:space="preserve">
          <source>After digits are obtained for the integer part, fractional part, and exponent (as appropriate for the data type), the following transformation is applied:</source>
          <target state="translated">정수 부분, 분수 부분 및 지수 (데이터 유형에 적합)에 대해 숫자를 얻은 후 다음 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e596fa70998190425297d1d9f0c9cd8a2a3c131" translate="yes" xml:space="preserve">
          <source>After every group has been converted to a character by this process, the characters are gathered, in the same order in which their corresponding groups were read from the input stream, to form a &lt;code&gt;String&lt;/code&gt;, which is returned.</source>
          <target state="translated">이 프로세스에 의해 모든 그룹이 문자로 변환 된 후, 입력 스트림에서 해당 그룹이 읽히는 순서와 동일한 순서로 문자가 수집되어 &lt;code&gt;String&lt;/code&gt; 을 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="1206b32dd9d29e89d9f7f414072872d7667aad0d" translate="yes" xml:space="preserve">
          <source>After execution of the terminal stream operation there are no guarantees that the reader will be at a specific position from which to read the next character or line.</source>
          <target state="translated">터미널 스트림 작업을 실행 한 후 리더가 다음 문자 나 행을 읽을 특정 위치에 있다고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d093d84f7dd27596bf805dd2fb842a92b9ce9304" translate="yes" xml:space="preserve">
          <source>After invoking this method, subsequent invocations of the &lt;a href=&quot;serviceloader#iterator--&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; method will lazily look up and instantiate providers from scratch, just as is done by a newly-created loader.</source>
          <target state="translated">이 메소드를 호출 한 후, &lt;a href=&quot;serviceloader#iterator--&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt; 메소드 의 후속 호출은 새로 작성된 로더가 수행하는 것처럼 지연없이 제공자를 처음부터 찾아서 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="2cf6137e0108d8328f2a2f6e3a9183eca6828869" translate="yes" xml:space="preserve">
          <source>After membership is dropped it may still be possible to receive datagrams sent to the group. This can arise when datagrams are waiting to be received in the socket's receive buffer. After membership is dropped then the channel may &lt;a href=&quot;multicastchannel#join-java.net.InetAddress-java.net.NetworkInterface-&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; the group again in which case a new membership key is returned.</source>
          <target state="translated">멤버십이 삭제 된 후에도 그룹에 전송 된 데이터 그램을받을 수 있습니다. 소켓의 수신 버퍼에서 데이터 그램 수신을 기다리는 경우에 발생할 수 있습니다. 멤버십이 삭제 된 후 채널이 그룹에 다시 &lt;a href=&quot;multicastchannel#join-java.net.InetAddress-java.net.NetworkInterface-&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 수 있으며이 경우 새 멤버쉽 키가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0c7c44913b874847757b29fb40fc36b8ce2408" translate="yes" xml:space="preserve">
          <source>After passing the initial &quot;level&quot; check, the Logger will call this Filter to check if a log record should really be published.</source>
          <target state="translated">초기 &quot;수준&quot;확인을 통과 한 후 로거는이 필터를 호출하여 로그 레코드가 실제로 게시되어야하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bff9cb64aa8dc580ae6a8f97589fef27a2342f9f" translate="yes" xml:space="preserve">
          <source>After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree.</source>
          <target state="translated">이 초기 (저렴한) 테스트를 통과 한 후 Logger는 로깅 메시지를 설명하기 위해 LogRecord를 할당합니다. 그런 다음 필터 (있는 경우)를 호출하여 레코드를 게시해야하는지에 대한 자세한 검사를 수행합니다. 그것이 통과하면 LogRecord를 출력 핸들러에 게시합니다. 기본적으로 로거는 트리의 재귀 적으로 부모의 처리기에 게시합니다.</target>
        </trans-unit>
        <trans-unit id="0deb0d93fdb81af024261a48e96f24361c11e9df" translate="yes" xml:space="preserve">
          <source>After removing &lt;code&gt;client&lt;/code&gt; from the list of connections, this method calls &lt;a href=&quot;rmiserverimpl#closeClient-javax.management.remote.rmi.RMIConnection-&quot;&gt;&lt;code&gt;closeClient(client)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결 목록에서 &lt;code&gt;client&lt;/code&gt; 를 제거한 후이 메소드는 &lt;a href=&quot;rmiserverimpl#closeClient-javax.management.remote.rmi.RMIConnection-&quot;&gt; &lt;code&gt;closeClient(client)&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fe83bd60b2bd7486dfa9e410144d43cec2b7478e" translate="yes" xml:space="preserve">
          <source>After rounding for the precision, the formatting of the resulting magnitude</source>
          <target state="translated">정밀도를 위해 반올림 한 후 결과 크기의 서식</target>
        </trans-unit>
        <trans-unit id="ea966e6d18ed9dd56bb4519b097bfef392eb9de4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;AccessController.getContext&lt;/code&gt; method receives the combined stack of ProtectionDomains back from the &lt;code&gt;DomainCombiner&lt;/code&gt;, it returns a new AccessControlContext that has both the combined ProtectionDomains as well as the &lt;code&gt;DomainCombiner&lt;/code&gt;.</source>
          <target state="translated">애프터 &lt;code&gt;AccessController.getContext&lt;/code&gt; 의 방법의 ProtectionDomain가 백업으로부터의 합성 수신 스택 &lt;code&gt;DomainCombiner&lt;/code&gt; 를을 , 그것만큼 잘 결합 된 ProtectionDomain 모두 가진 새로운 AccessControlContext에 반환 &lt;code&gt;DomainCombiner&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="fe1ca10488234d21ddb6e9b74892d69adae52cb1" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;finalize&lt;/code&gt; method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded.</source>
          <target state="translated">객체에 대해 &lt;code&gt;finalize&lt;/code&gt; 메소드를 호출 한 후, Java 가상 머신이 가능한 조치를 포함하여 아직 사망하지 않은 스레드가이 오브젝트에 액세스 할 수있는 방법이 더 이상 없음을 다시 판별 할 때까지 추가 조치가 수행되지 않습니다. 완료 될 준비가 된 다른 객체 또는 클래스에 의해 객체가 폐기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb6b56f99b8307503215614d6db7b0af46ca450" translate="yes" xml:space="preserve">
          <source>After the entries have been written, the output stream is flushed. The output stream remains open after this method returns.</source>
          <target state="translated">항목이 작성된 후 출력 스트림이 플러시됩니다. 이 메소드가 리턴 된 후에 출력 스트림은 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="cf37323d83bfa3761ac32673b7214c3204cb9564" translate="yes" xml:space="preserve">
          <source>After the last live reference to a &lt;code&gt;Timer&lt;/code&gt; object goes away</source>
          <target state="translated">&lt;code&gt;Timer&lt;/code&gt; 객체에 대한 마지막 실시간 참조 가 사라진 후</target>
        </trans-unit>
        <trans-unit id="e5e91476b8f641696d56131565cb9eeb909b6b53" translate="yes" xml:space="preserve">
          <source>After the protocol version there must be a space, followed by the implementation name. The format of the implementation name is unspecified. It is recommended that it include an implementation version number. An implementation can use an empty string as its implementation name, for example for security reasons.</source>
          <target state="translated">프로토콜 버전 뒤에는 공백이 있어야하고 구현 이름이 있어야합니다. 구현 이름의 형식이 지정되지 않았습니다. 구현 버전 번호를 포함하는 것이 좋습니다. 구현은 보안상의 이유로 빈 문자열을 구현 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf35a3f00b309b6705097e74eb7fc48ec5414a0" translate="yes" xml:space="preserve">
          <source>After the service provider has sent the extended operation request to the LDAP server, it will receive a response from the server. If the operation failed, the provider will throw a NamingException. If the operation succeeded, the provider will invoke this method using the data that it got back in the response. It is the job of this method to return a class that implements the ExtendedResponse interface that is appropriate for the extended operation request.</source>
          <target state="translated">서비스 제공자는 확장 조작 요청을 LDAP 서버로 보낸 후 서버로부터 응답을 수신합니다. 작업이 실패하면 공급자는 NamingException을 throw합니다. 작업이 성공하면 공급자는 응답에서 반환 된 데이터를 사용하여이 메서드를 호출합니다. 확장 조작 요청에 적합한 ExtendedResponse 인터페이스를 구현하는 클래스를 리턴하는 것이이 메소드의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="293a1f74d8d45ca2cebc7051e8db2eb37adc8b80" translate="yes" xml:space="preserve">
          <source>After this method returns, subsequent calls to &lt;a href=&quot;future#isDone--&quot;&gt;&lt;code&gt;Future.isDone()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;true&lt;/code&gt;. Subsequent calls to &lt;a href=&quot;future#isCancelled--&quot;&gt;&lt;code&gt;Future.isCancelled()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;true&lt;/code&gt; if this method returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 메서드가 반환 된 후 &lt;a href=&quot;future#isDone--&quot;&gt; &lt;code&gt;Future.isDone()&lt;/code&gt; &lt;/a&gt; 후속 호출 은 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;a href=&quot;future#isCancelled--&quot;&gt; &lt;code&gt;Future.isCancelled()&lt;/code&gt; &lt;/a&gt; 후속 호출 은 이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 항상 true를 리턴 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33a51d9c14538f4cc61149c5d78199ca9d382d8f" translate="yes" xml:space="preserve">
          <source>After this method returns, subsequent calls to &lt;a href=&quot;future#isDone--&quot;&gt;&lt;code&gt;isDone()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;true&lt;/code&gt;. Subsequent calls to &lt;a href=&quot;future#isCancelled--&quot;&gt;&lt;code&gt;isCancelled()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;true&lt;/code&gt; if this method returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 리턴 된 후 &lt;a href=&quot;future#isDone--&quot;&gt; &lt;code&gt;isDone()&lt;/code&gt; &lt;/a&gt; 후속 호출 은 항상 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . &lt;a href=&quot;future#isCancelled--&quot;&gt; &lt;code&gt;isCancelled()&lt;/code&gt; &lt;/a&gt; 후속 호출 은 이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 항상 true를 리턴 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3e522b1d45fb8dcd2883efd41da35812fe95ef" translate="yes" xml:space="preserve">
          <source>After this method returns, then any subsequent I/O exception that occurs while reading from the file or when a malformed or unmappable byte sequence is read, is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; that will be thrown from the &lt;a href=&quot;../../util/stream/stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; method that caused the read to take place. In case an &lt;code&gt;IOException&lt;/code&gt; is thrown when closing the file, it is also wrapped as an &lt;code&gt;UncheckedIOException&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 리턴 된 후, 파일에서 읽거나 조작되지 않거나 맵핑 할 수없는 바이트 순서를 읽을 때 발생하는 후속 I / O 예외는 읽기 가 발생하는 &lt;a href=&quot;../../util/stream/stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 메소드 에서 발생 하는 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 에&lt;/a&gt; 랩됩니다. . 경우에 &lt;code&gt;IOException&lt;/code&gt; 가이 파일을 닫을 때, 그것은 또한으로 포장되어 발생합니다 &lt;code&gt;UncheckedIOException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2e54c6cbce2883f6668ea07160954da33b667b" translate="yes" xml:space="preserve">
          <source>After type matching, a call to &lt;code&gt;invokeExact&lt;/code&gt; directly and immediately invoke the method handle's underlying method (or other behavior, as the case may be).</source>
          <target state="translated">형식 일치 후에 &lt;code&gt;invokeExact&lt;/code&gt; 를 직접 호출하면 메서드 핸들의 기본 메서드 (또는 경우에 따라 다른 동작)가 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2fb0050855650fda48e2caa4a41f3a8f52ffa11a" translate="yes" xml:space="preserve">
          <source>Afterwards, the tool calls &lt;a href=&quot;processor#getSupportedAnnotationTypes--&quot;&gt;&lt;code&gt;getSupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;processor#getSupportedOptions--&quot;&gt;&lt;code&gt;getSupportedOptions&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;processor#getSupportedSourceVersion--&quot;&gt;&lt;code&gt;getSupportedSourceVersion&lt;/code&gt;&lt;/a&gt;. These methods are only called once per run, not on each round.</source>
          <target state="translated">그런 다음 도구는 &lt;a href=&quot;processor#getSupportedAnnotationTypes--&quot;&gt; &lt;code&gt;getSupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;processor#getSupportedOptions--&quot;&gt; &lt;code&gt;getSupportedOptions&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;processor#getSupportedSourceVersion--&quot;&gt; &lt;code&gt;getSupportedSourceVersion&lt;/code&gt; 을&lt;/a&gt; 호출합니다 . 이러한 방법은 각 라운드가 아닌 실행 당 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="906b23b764fd3c9144853ac4bdb0ccdb1d7cbfbc" translate="yes" xml:space="preserve">
          <source>AlgorithmConstraints</source>
          <target state="translated">AlgorithmConstraints</target>
        </trans-unit>
        <trans-unit id="42895f9042b99feb9b3979a5d95b5e3f97c49655" translate="yes" xml:space="preserve">
          <source>AlgorithmConstraints.permits()</source>
          <target state="translated">AlgorithmConstraints.permits()</target>
        </trans-unit>
        <trans-unit id="2eb8ac1d3c97074957ddf7f6fa1f9f774fbf9088" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator</source>
          <target state="translated">AlgorithmParameterGenerator</target>
        </trans-unit>
        <trans-unit id="61ddd33c1d909c5b145d43c9d1e1c1e6fdd512c0" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator.generateParameters()</source>
          <target state="translated">AlgorithmParameterGenerator.generateParameters()</target>
        </trans-unit>
        <trans-unit id="b9d0134c1fff2f11908574f91a6af9ef7423d1c4" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator.getAlgorithm()</source>
          <target state="translated">AlgorithmParameterGenerator.getAlgorithm()</target>
        </trans-unit>
        <trans-unit id="144358004d3ac968008dc633237e89c636eacda2" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator.getInstance()</source>
          <target state="translated">AlgorithmParameterGenerator.getInstance()</target>
        </trans-unit>
        <trans-unit id="6555eb9e9d87ca8ba00c25b69c5a277894272e41" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator.getProvider()</source>
          <target state="translated">AlgorithmParameterGenerator.getProvider()</target>
        </trans-unit>
        <trans-unit id="de1ca1cd10ae0fe47c59203f27d894af487eac96" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGenerator.init()</source>
          <target state="translated">AlgorithmParameterGenerator.init()</target>
        </trans-unit>
        <trans-unit id="bac0401f4af05b215eb6d9f1c4463db8930d6fa3" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGeneratorSpi</source>
          <target state="translated">AlgorithmParameterGeneratorSpi</target>
        </trans-unit>
        <trans-unit id="3ce6d50a4cb7f5e2e69a0b4d13bc3b1d0fd1b181" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGeneratorSpi.engineGenerateParameters()</source>
          <target state="translated">AlgorithmParameterGeneratorSpi.engineGenerateParameters()</target>
        </trans-unit>
        <trans-unit id="7e6a83fd5bbac3c1c75e21e3c383d6ba68e0df8a" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterGeneratorSpi.engineInit()</source>
          <target state="translated">AlgorithmParameterGeneratorSpi.engineInit()</target>
        </trans-unit>
        <trans-unit id="35b230a5434390d526484817ecfcee8d495f3bcd" translate="yes" xml:space="preserve">
          <source>AlgorithmParameterSpec</source>
          <target state="translated">AlgorithmParameterSpec</target>
        </trans-unit>
        <trans-unit id="e127f6153f90e2ae93d87fd9ab0b103ec55f7002" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters</source>
          <target state="translated">AlgorithmParameters</target>
        </trans-unit>
        <trans-unit id="b6b1c8cf808fe67d3b739992365c72e753479b12" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.getAlgorithm()</source>
          <target state="translated">AlgorithmParameters.getAlgorithm()</target>
        </trans-unit>
        <trans-unit id="353edec096cac1e7851d4dce582bd231ec403786" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.getEncoded()</source>
          <target state="translated">AlgorithmParameters.getEncoded()</target>
        </trans-unit>
        <trans-unit id="fa35431b268b130e0a9f1f3dbe5c79aa207b6fbb" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.getInstance()</source>
          <target state="translated">AlgorithmParameters.getInstance()</target>
        </trans-unit>
        <trans-unit id="63fd06dad5b0e8e586e6a928f22d49c0a6f35738" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.getParameterSpec()</source>
          <target state="translated">AlgorithmParameters.getParameterSpec()</target>
        </trans-unit>
        <trans-unit id="73da677d3848f9b8bcff1a3616db9c4bb1c9d8af" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.getProvider()</source>
          <target state="translated">AlgorithmParameters.getProvider()</target>
        </trans-unit>
        <trans-unit id="ab5d7418d500948384db57c41498fc03792c6280" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.init()</source>
          <target state="translated">AlgorithmParameters.init()</target>
        </trans-unit>
        <trans-unit id="6fdcbd4ae2641895cbd9a679a886de0354d81036" translate="yes" xml:space="preserve">
          <source>AlgorithmParameters.toString()</source>
          <target state="translated">AlgorithmParameters.toString()</target>
        </trans-unit>
        <trans-unit id="20ba9f742cdf6dc9931981e20ca54d2969526bcb" translate="yes" xml:space="preserve">
          <source>AlgorithmParametersSpi</source>
          <target state="translated">AlgorithmParametersSpi</target>
        </trans-unit>
        <trans-unit id="6d8d02fba71ae38a2d6d2fc14a26e522139750ae" translate="yes" xml:space="preserve">
          <source>AlgorithmParametersSpi.engineGetEncoded()</source>
          <target state="translated">AlgorithmParametersSpi.engineGetEncoded()</target>
        </trans-unit>
        <trans-unit id="3941525735861bbbec5a273a85ae351b754e6542" translate="yes" xml:space="preserve">
          <source>AlgorithmParametersSpi.engineGetParameterSpec()</source>
          <target state="translated">AlgorithmParametersSpi.engineGetParameterSpec()</target>
        </trans-unit>
        <trans-unit id="bf446ba5bb0b12c8b7cc8880981676121dec84fe" translate="yes" xml:space="preserve">
          <source>AlgorithmParametersSpi.engineInit()</source>
          <target state="translated">AlgorithmParametersSpi.engineInit()</target>
        </trans-unit>
        <trans-unit id="43f123e2640b592a35b0b378a022d04a8ae4dfd9" translate="yes" xml:space="preserve">
          <source>AlgorithmParametersSpi.engineToString()</source>
          <target state="translated">AlgorithmParametersSpi.engineToString()</target>
        </trans-unit>
        <trans-unit id="747dd263fc2f85623d217cb46475b214a7e49c00" translate="yes" xml:space="preserve">
          <source>Algorithms (such as DSA, RSA, MD5 or SHA-1).</source>
          <target state="translated">알고리즘 (예 : DSA, RSA, MD5 또는 SHA-1).</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="f2bf450671d09ee002270779776e29097321c774" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and Long apply.</source>
          <target state="translated">Byte, Short, Integer 및 Long에 대해 정의 된 모든 &lt;a href=&quot;#intFlags&quot;&gt;플래그가&lt;/a&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1771c3d834a0c2588eb5b846a29ba40bc160d013" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and Long apply. The &lt;a href=&quot;#intdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are given is the same as for Byte, Short, Integer, and Long.</source>
          <target state="translated">Byte, Short, Integer 및 Long에 대해 정의 된 모든 &lt;a href=&quot;#intFlags&quot;&gt;플래그가&lt;/a&gt; 적용됩니다. 플래그가 제공되지 않을 때 의 &lt;a href=&quot;#intdFlags&quot;&gt;기본 동작&lt;/a&gt; 은 바이트, 쇼트, 정수 및 롱과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f7e396b73becc28e0e8b93e1202e1147515b6de4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;temporalfield&quot;&gt;&lt;code&gt;TemporalField&lt;/code&gt;&lt;/a&gt; instances have a valid range of values. For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31. This class captures that valid range.</source>
          <target state="translated">모든 &lt;a href=&quot;temporalfield&quot;&gt; &lt;code&gt;TemporalField&lt;/code&gt; &lt;/a&gt; 인스턴스는 유효한 값 범위를 갖습니다. 예를 들어, ISO 일수는 1에서 28과 31 사이입니다.이 클래스는 유효한 범위를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="e220b8185985db9a3512e9e2d638a0f9015a9e3f" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&quot;.&quot;&lt;/code&gt; segments are removed.</source>
          <target state="translated">모든 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 세그먼트가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1385e415938e8c44cccf96f3bc4658c8281937f6" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;.jar&lt;/code&gt; files in &lt;var&gt;archivelist&lt;/var&gt; must be stored in the directory specified by the code base URL.</source>
          <target state="translated">&lt;var&gt;archivelist&lt;/var&gt; 의 모든 &lt;code&gt;.jar&lt;/code&gt; 파일 은 코드 기본 URL로 지정된 디렉토리에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9de8ab19dc971275c5bbabf7dfbc03c720a57ff" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CertPath&lt;/code&gt; objects are also &lt;code&gt;Serializable&lt;/code&gt;. &lt;code&gt;CertPath&lt;/code&gt; objects are resolved into an alternate &lt;a href=&quot;certpath.certpathrep&quot;&gt;&lt;code&gt;CertPathRep&lt;/code&gt;&lt;/a&gt; object during serialization. This allows a &lt;code&gt;CertPath&lt;/code&gt; object to be serialized into an equivalent representation regardless of its underlying implementation.</source>
          <target state="translated">모든 &lt;code&gt;CertPath&lt;/code&gt; 객체도 &lt;code&gt;Serializable&lt;/code&gt; 합니다. &lt;code&gt;CertPath&lt;/code&gt; 객체는 직렬화 중에 대체 &lt;a href=&quot;certpath.certpathrep&quot;&gt; &lt;code&gt;CertPathRep&lt;/code&gt; &lt;/a&gt; 객체 로 해석됩니다 . 이것에 의해, &lt;code&gt;CertPath&lt;/code&gt; 객체는 그 기본 구현에 관계없이 동등한 표현으로 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a725c3ada7abe88c4e303e9d9ed90068d1425fa2" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CertPath&lt;/code&gt; objects have a type, a list of &lt;code&gt;Certificate&lt;/code&gt;s, and one or more supported encodings. Because the &lt;code&gt;CertPath&lt;/code&gt; class is immutable, a &lt;code&gt;CertPath&lt;/code&gt; cannot change in any externally visible way after being constructed. This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses.</source>
          <target state="translated">모든 &lt;code&gt;CertPath&lt;/code&gt; 객체에는 유형, &lt;code&gt;Certificate&lt;/code&gt; 목록 및 하나 이상의 지원되는 인코딩이 있습니다. 때문에 &lt;code&gt;CertPath&lt;/code&gt; 클래스는 불변하는 &lt;code&gt;CertPath&lt;/code&gt; 구성 후 임의의 외부에서 볼 수있는 방식으로 변경할 수 없다. 이 규정은이 클래스의 모든 퍼블릭 필드와 메소드 및 서브 클래스에 의해 추가되거나 재정의 된 모든 필드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc77693eac872b4e8f541a6f414b945309c219f0" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CertPath&lt;/code&gt; objects must be thread-safe. That is, multiple threads may concurrently invoke the methods defined in this class on a single &lt;code&gt;CertPath&lt;/code&gt; object (or more than one) with no ill effects. This is also true for the &lt;code&gt;List&lt;/code&gt; returned by &lt;code&gt;CertPath.getCertificates&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;CertPath&lt;/code&gt; 객체는 스레드로부터 안전해야합니다. 즉, 여러 스레드가 동시에이 클래스에 정의 된 메소드를 단일 &lt;code&gt;CertPath&lt;/code&gt; 객체 (또는 둘 이상) 에서 동시에 호출 할 수 있습니다 . &lt;code&gt;CertPath.getCertificates&lt;/code&gt; 에 의해 돌려 주어진 &lt;code&gt;List&lt;/code&gt; 도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="41dad6d8f3332a2a50761f6a507d5d64cfc22ccd" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Lock&lt;/code&gt; implementations &lt;em&gt;must&lt;/em&gt; enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt; The Java Language Specification (17.4 Memory Model)&lt;/a&gt;:</source>
          <target state="translated">모든 &lt;code&gt;Lock&lt;/code&gt; 구현 &lt;em&gt;은 &lt;/em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt;Java 언어 사양 (17.4 메모리 모델)에&lt;/a&gt; 설명 된대로 내장 모니터 잠금에서 제공 한 것과 동일한 메모리 동기화 시맨틱을 적용 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="44be636bc3ec5aa6c5b4fbff9a61ce2a0c343675" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Map.Entry&lt;/code&gt; pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do &lt;em&gt;not&lt;/em&gt; support the &lt;code&gt;Entry.setValue&lt;/code&gt; method. (Note however that it is possible to change mappings in the associated map using &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;putIfAbsent&lt;/code&gt;, or &lt;code&gt;replace&lt;/code&gt;, depending on exactly which effect you need.)</source>
          <target state="translated">이 클래스의 메서드에서 반환 된 모든 &lt;code&gt;Map.Entry&lt;/code&gt; 쌍과 해당 뷰는 생성 당시 매핑의 스냅 샷을 나타냅니다. &lt;code&gt;Entry.setValue&lt;/code&gt; 메소드를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; . (단 , 필요한 효과에 따라 &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;putIfAbsent&lt;/code&gt; 또는 &lt;code&gt;replace&lt;/code&gt; 를 사용하여 연관된 맵에서 매핑을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="68284d0a5ff6c85614eced6cecf11c39abfffb2b" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Map.Entry&lt;/code&gt; pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do &lt;strong&gt;not&lt;/strong&gt; support the &lt;code&gt;Entry.setValue&lt;/code&gt; method. (Note however that it is possible to change mappings in the associated map using &lt;code&gt;put&lt;/code&gt;.)</source>
          <target state="translated">이 클래스의 메서드에서 반환 된 모든 &lt;code&gt;Map.Entry&lt;/code&gt; 쌍과 해당 뷰는 생성 당시 매핑의 스냅 샷을 나타냅니다. &lt;code&gt;Entry.setValue&lt;/code&gt; 메소드를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 그러나 &lt;code&gt;put&lt;/code&gt; 을 사용하여 연관된 맵에서 맵핑을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68926be59fcf50e6ecad024d27ae4ed3547baa84" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;PKIXCertPathBuilderResult&lt;/code&gt; objects contain the certification path constructed by the build algorithm, the valid policy tree and subject public key resulting from the build algorithm, and a &lt;code&gt;TrustAnchor&lt;/code&gt; describing the certification authority (CA) that served as a trust anchor for the certification path.</source>
          <target state="translated">모든 &lt;code&gt;PKIXCertPathBuilderResult&lt;/code&gt; 객체에는 빌드 알고리즘으로 구성된 인증 경로, 빌드 정책으로 인한 유효한 정책 트리 및 주체 공개 키 및 인증 경로의 트러스트 앵커 역할을하는 CA (인증 기관)를 설명 하는 &lt;code&gt;TrustAnchor&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="8721ca15b265ab12cbee59a2ca470cd0729611fc" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;PKIXCertPathValidatorResult&lt;/code&gt; objects contain the valid policy tree and subject public key resulting from the validation algorithm, as well as a &lt;code&gt;TrustAnchor&lt;/code&gt; describing the certification authority (CA) that served as a trust anchor for the certification path.</source>
          <target state="translated">모든 &lt;code&gt;PKIXCertPathValidatorResult&lt;/code&gt; 개체에는 유효성 검사 알고리즘의 결과 인 유효한 정책 트리 및 주체 공개 키와 인증 경로의 신뢰 앵커 역할을하는 인증 기관 (CA)을 설명 하는 &lt;code&gt;TrustAnchor&lt;/code&gt; 가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55e0f24300055bbce9894f55acf8c777578d823e" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;PolicyNode&lt;/code&gt; objects must be immutable and thread-safe. Multiple threads may concurrently invoke the methods defined in this class on a single &lt;code&gt;PolicyNode&lt;/code&gt; object (or more than one) with no ill effects. This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses.</source>
          <target state="translated">모든 &lt;code&gt;PolicyNode&lt;/code&gt; 개체는 변경 불가능하고 스레드로부터 안전해야합니다. 여러 스레드가 &lt;code&gt;PolicyNode&lt;/code&gt; 클래스에 정의 된 메서드를 단일 PolicyNode 개체 (또는 둘 이상) 에서 동시에 호출 할 수 있습니다 . 이 규정은이 클래스의 모든 퍼블릭 필드와 메소드 및 서브 클래스에 의해 추가되거나 재정의 된 모든 필드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3dfef94eadb0f88de4cb1a52ce8b0f0a6cde2e1" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; objects must be immutable and thread-safe. That is, multiple threads may concurrently invoke the methods defined in this class on a single &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; object (or more than one) with no ill effects. Requiring &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; objects to be immutable and thread-safe allows them to be passed around to various pieces of code without worrying about coordinating access.</source>
          <target state="translated">모든 &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; 개체는 변경 불가능하고 스레드로부터 안전해야합니다. 즉, 여러 스레드가 &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; 클래스에 정의 된 메소드를 단일 PolicyQualifierInfo 오브젝트 (또는 둘 이상)에 대해 아무런 영향없이 호출 할 수 있습니다 . &lt;code&gt;PolicyQualifierInfo&lt;/code&gt; 객체를 변경할 수없고 스레드로부터 안전 하도록 요구 하면 액세스 조정에 대한 걱정없이 다양한 코드로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3ffc68db35628f6e195a8ff29d238e67820ec5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;ReadWriteLock&lt;/code&gt; implementations must guarantee that the memory synchronization effects of &lt;code&gt;writeLock&lt;/code&gt; operations (as specified in the &lt;a href=&quot;lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; interface) also hold with respect to the associated &lt;code&gt;readLock&lt;/code&gt;. That is, a thread successfully acquiring the read lock will see all updates made upon previous release of the write lock.</source>
          <target state="translated">모든 &lt;code&gt;ReadWriteLock&lt;/code&gt; 구현은 ( &lt;a href=&quot;lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 인터페이스에 지정된) &lt;code&gt;writeLock&lt;/code&gt; 조작 의 메모리 동기화 효과 도 연관된 &lt;code&gt;readLock&lt;/code&gt; 과 관련하여 유지되도록해야합니다 . 즉, 읽기 잠금을 성공적으로 획득 한 스레드는 쓰기 잠금의 이전 릴리스에서 작성된 모든 업데이트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc43aaae9c87237058ca44ada1e2f3b304d9b0a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Receiver&lt;/code&gt; and &lt;code&gt;Transmitter&lt;/code&gt; instances open from this device are closed. This includes instances retrieved via &lt;code&gt;MidiSystem&lt;/code&gt;.</source>
          <target state="translated">이 장치에서 열린 모든 &lt;code&gt;Receiver&lt;/code&gt; 및 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스가 닫힙니다. 여기에는 &lt;code&gt;MidiSystem&lt;/code&gt; 을 통해 검색된 인스턴스가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9659b2d04503a34866969b5bcc4384b8c2c5b3a4" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TrustAnchor&lt;/code&gt; objects must be immutable and thread-safe. That is, multiple threads may concurrently invoke the methods defined in this class on a single &lt;code&gt;TrustAnchor&lt;/code&gt; object (or more than one) with no ill effects. Requiring &lt;code&gt;TrustAnchor&lt;/code&gt; objects to be immutable and thread-safe allows them to be passed around to various pieces of code without worrying about coordinating access. This stipulation applies to all public fields and methods of this class and any added or overridden by subclasses.</source>
          <target state="translated">모든 &lt;code&gt;TrustAnchor&lt;/code&gt; 오브젝트는 변경 불가능하고 스레드로부터 안전해야합니다. 즉, 여러 스레드가 &lt;code&gt;TrustAnchor&lt;/code&gt; 클래스에 정의 된 메소드를 단일 TrustAnchor 오브젝트 (또는 둘 이상)에 대해 아무런 영향없이 호출 할 수 있습니다 . 요구하는 &lt;code&gt;TrustAnchor&lt;/code&gt; 불변으로 thread에 대해서 안전하지 않으면 사물은 그들에게 액세스의 조정을 의식하는 일없이, 다양한 코드에 건네 줄 수가 있습니다. 이 규정은이 클래스의 모든 퍼블릭 필드와 메소드 및 서브 클래스에 의해 추가되거나 재정의 된 모든 필드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd0aa2c1da85461c43d97ec7d68d651e4bea8bb6" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at &lt;code&gt;input.position()&lt;/code&gt; are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed.</source>
          <target state="translated">모든 &lt;code&gt;input.remaining()&lt;/code&gt; 에서 시작하여 바이트 &lt;code&gt;input.position()&lt;/code&gt; 처리된다. GCM / CCM과 같은 AEAD 모드를 사용하는 경우 암호화의 경우 인증 태그가 추가되거나 암호 해독의 경우 확인됩니다. 결과는 출력 버퍼에 저장됩니다. 돌아 왔을 때, 입력 버퍼의 위치는 그 한계와 같습니다. 한도는 변경되지 않았습니다. 출력 버퍼의 위치는 n만큼 증가합니다. 여기서 n은이 방법으로 반환 된 값입니다. 출력 버퍼의 한계는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326222c23a5fb054de4a234a3333ed1e170e11d3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at &lt;code&gt;input.position()&lt;/code&gt; are processed. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed.</source>
          <target state="translated">모든 &lt;code&gt;input.remaining()&lt;/code&gt; 에서 시작하여 바이트 &lt;code&gt;input.position()&lt;/code&gt; 처리된다. 결과는 출력 버퍼에 저장됩니다. 돌아 왔을 때, 입력 버퍼의 위치는 그 한계와 같습니다. 한도는 변경되지 않았습니다. 출력 버퍼의 위치는 n만큼 증가합니다. 여기서 n은이 방법으로 반환 된 값입니다. 출력 버퍼의 한계는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ef4dcb11b7d6fd436a05f78c6131f66544e4b29" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;schedule&lt;/code&gt; methods accept &lt;em&gt;relative&lt;/em&gt; delays and periods as arguments, not absolute times or dates. It is a simple matter to transform an absolute time represented as a &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to the required form. For example, to schedule at a certain future &lt;code&gt;date&lt;/code&gt;, you can use: &lt;code&gt;schedule(task,
 date.getTime() - System.currentTimeMillis(),
 TimeUnit.MILLISECONDS)&lt;/code&gt;. Beware however that expiration of a relative delay need not coincide with the current &lt;code&gt;Date&lt;/code&gt; at which the task is enabled due to network time synchronization protocols, clock drift, or other factors.</source>
          <target state="translated">모든 &lt;code&gt;schedule&lt;/code&gt; 방법은 절대 시간이나 날짜가 아니라 &lt;em&gt;상대&lt;/em&gt; 지연 및 기간을 인수로 허용 합니다. &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 로 표시된 절대 시간 을 필요한 형식 으로 변환하는 것은 간단한 일 입니다. 예를 들어, 특정 미래 &lt;code&gt;date&lt;/code&gt; 를 예약 하려면 &lt;code&gt;schedule(task, date.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS)&lt;/code&gt; 있습니다. 그러나 상대 지연의 만료는 네트워크 시간 동기화 프로토콜, 클럭 드리프트 또는 기타 요인으로 인해 작업이 활성화 된 현재 &lt;code&gt;Date&lt;/code&gt; 와 일치하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="264a56d62aa5d634b6acceac251bd3490c0dad3d" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;src.remaining()&lt;/code&gt; bytes starting at &lt;code&gt;src.position()&lt;/code&gt; are processed. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed.</source>
          <target state="translated">&lt;code&gt;src.position()&lt;/code&gt; 에서 시작하는 모든 &lt;code&gt;src.remaining()&lt;/code&gt; 바이트 가 처리됩니다. 돌아 왔을 때, 입력 버퍼의 위치는 그 한계와 같습니다. 한도는 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bf8d8ac436d816f6caf5989f4d4f4942f8649360" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;async&lt;/em&gt; methods without an explicit Executor argument are performed using the &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; (unless it does not support a parallelism level of at least two, in which case, a new Thread is created to run each task). To simplify monitoring, debugging, and tracking, all generated asynchronous tasks are instances of the marker interface &lt;a href=&quot;completablefuture.asynchronouscompletiontask&quot;&gt;&lt;code&gt;CompletableFuture.AsynchronousCompletionTask&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명시 적 Executor 인수가없는 모든 &lt;em&gt;비동기&lt;/em&gt; 메소드는 &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 사용하여 수행됩니다 ( 2 개 이상의 병렬 처리 레벨을 지원하지 않는 경우 각 태스크를 실행하기 위해 새 스레드가 작성 됨). 모니터링, 디버깅 및 추적을 단순화하기 위해 생성 된 모든 비동기 작업은 마커 인터페이스 &lt;a href=&quot;completablefuture.asynchronouscompletiontask&quot;&gt; &lt;code&gt;CompletableFuture.AsynchronousCompletionTask&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="97a9d91b0eb23083826f2d2dae8a3823b1dfffeb" translate="yes" xml:space="preserve">
          <source>All ASCII:&lt;code&gt;[\x00-\x7F]&lt;/code&gt;</source>
          <target state="translated">모든 ASCII : &lt;code&gt;[\x00-\x7F]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fb452c940c69e815f8e1b3c17b2efa122b58022" translate="yes" xml:space="preserve">
          <source>All CompletionStage methods are implemented independently of other public methods, so the behavior of one method is not impacted by overrides of others in subclasses.</source>
          <target state="translated">모든 CompletionStage 메소드는 다른 공용 메소드와 독립적으로 구현되므로 한 메소드의 동작은 서브 클래스에서 다른 메소드의 대체에 의해 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f22cf8158dafbb9cf52279bf6954979989f8a3e5" translate="yes" xml:space="preserve">
          <source>All Events are constructed with a reference to the object, the &quot;source&quot;, that is logically deemed to be the object upon which the Event in question initially occurred upon.</source>
          <target state="translated">모든 이벤트는 &quot;소스&quot;라는 객체를 참조하여 구성되며, 해당 이벤트는 처음에 해당 이벤트가 발생한 객체로 논리적으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8488877b006c4252706248bd660893ff0c76fa4d" translate="yes" xml:space="preserve">
          <source>All Identity objects have a name and a public key. Names are immutable. Identities may also be scoped. That is, if an Identity is specified to have a particular scope, then the name and public key of the Identity are unique within that scope.</source>
          <target state="translated">모든 Identity 객체에는 이름과 공개 키가 있습니다. 이름은 변경할 수 없습니다. 신원의 범위도 다를 수 있습니다. 즉, Identity가 특정 범위를 갖도록 지정된 경우 Identity의 이름과 공개 키는 해당 범위 내에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="6064b3f66c3297a431bfc5978ef8cf6299e04c2c" translate="yes" xml:space="preserve">
          <source>All Implemented Interfaces:</source>
          <target state="translated">구현 된 모든 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="35a4949e884de3ba9f88753ed46c753f393b7df8" translate="yes" xml:space="preserve">
          <source>All Kerberos JAAS login modules that authenticate a user to a KDC should use this class. Where available, the login module might even read this information from a ticket cache in the operating system instead of directly communicating with the KDC. During the commit phase of the JAAS authentication process, the JAAS login module should instantiate this class and store the instance in the private credential set of a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">KDC에 대한 사용자를 인증하는 모든 Kerberos JAAS 로그인 모듈은이 클래스를 사용해야합니다. 가능한 경우 로그인 모듈은 KDC와 직접 통신하는 대신 운영 체제의 티켓 캐시에서이 정보를 읽을 수도 있습니다. JAAS 인증 프로세스의 커미트 단계 동안 JAAS 로그인 모듈은이 클래스를 인스턴스화하고 인스턴스를 &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 의 개인 신임 정보 세트에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b93b063cfc6ca9d2b2192950d6f06f92c6aa6f9" translate="yes" xml:space="preserve">
          <source>All Kerberos JAAS login modules that obtain a principal's password and generate the secret key from it should use this class. Sometimes, such as when authenticating a server in the absence of user-to-user authentication, the login module will store an instance of this class in the private credential set of a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; during the commit phase of the authentication process.</source>
          <target state="translated">프린시 펄의 암호를 확보하고 비밀 키를 생성하는 모든 Kerberos JAAS 로그인 모듈은이 클래스를 사용해야합니다. 때때로, 사용자 간 인증이없는 서버를 인증 할 때와 같이, 로그인 모듈은 인증 프로세스의 커밋 단계 동안 이 클래스의 인스턴스를 &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 의 개인 자격 증명 세트에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="9957fd819223c055412379a855818facb9ff8d4c" translate="yes" xml:space="preserve">
          <source>All Known Implementing Classes:</source>
          <target state="translated">알려진 모든 구현 클래스 :</target>
        </trans-unit>
        <trans-unit id="59c4df19306307d346212af08eef032cc77f89df" translate="yes" xml:space="preserve">
          <source>All Known Subinterfaces:</source>
          <target state="translated">알려진 모든 하위 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="ed0203d6946d7c14ba9bce96c8bed4953c201838" translate="yes" xml:space="preserve">
          <source>All Superinterfaces:</source>
          <target state="translated">모든 수퍼 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="985fd2fa747bf37c19b85e98e5abcbfaca99bdef" translate="yes" xml:space="preserve">
          <source>All X.509 certificate extensions that a &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; might possibly be able to process should be included in the set.</source>
          <target state="translated">&lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 가 처리 할 수있는 모든 X.509 인증서 확장이 세트에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25df7a85f48a48078cfb121ea57c1908bc98eb5b" translate="yes" xml:space="preserve">
          <source>All access checks start from a &lt;code&gt;Lookup&lt;/code&gt; object, which compares its recorded lookup class against all requests to create method handles. A single &lt;code&gt;Lookup&lt;/code&gt; object can be used to create any number of access-checked method handles, all checked against a single lookup class.</source>
          <target state="translated">모든 액세스 검사는 &lt;code&gt;Lookup&lt;/code&gt; 객체 에서 시작합니다. Lookup 객체는 기록 된 조회 클래스를 모든 요청과 비교하여 메서드 핸들을 만듭니다. 단일 &lt;code&gt;Lookup&lt;/code&gt; 오브젝트를 사용하여 액세스 점검 된 메소드 핸들을 여러 개 작성할 수 있으며 모두 단일 조회 클래스에 대해 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="1f39b7e957d123a47c723b7390c55932aa8915f1" translate="yes" xml:space="preserve">
          <source>All actions in a thread</source>
          <target state="translated">스레드의 모든 동작</target>
        </trans-unit>
        <trans-unit id="ec7f6cfc30c26fd326068c8642070c7963776d74" translate="yes" xml:space="preserve">
          <source>All arguments to all task methods must be non-null.</source>
          <target state="translated">모든 태스크 메소드에 대한 모든 인수는 널이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="07252f24a126b5177f87013c857d2ec10b383f81" translate="yes" xml:space="preserve">
          <source>All but the first two (FilePermission and SocketPermission) are subclasses of &lt;code&gt;java.security.BasicPermission&lt;/code&gt;, which itself is an abstract subclass of the top-level class for permissions, which is &lt;code&gt;java.security.Permission&lt;/code&gt;. BasicPermission defines the functionality needed for all permissions that contain a name that follows the hierarchical property naming convention (for example, &quot;exitVM&quot;, &quot;setFactory&quot;, &quot;queuePrintJob&quot;, etc). An asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;a.*&quot; or &quot;*&quot; is valid, &quot;*a&quot; or &quot;a*b&quot; is not valid.</source>
          <target state="translated">처음 두 개 (FilePermission 및 SocketPermission)를 제외한 모두는 &lt;code&gt;java.security.BasicPermission&lt;/code&gt; 의 서브 클래스이며 , 그 자체는 권한에 대한 최상위 레벨 클래스의 추상 서브 클래스 인 &lt;code&gt;java.security.Permission&lt;/code&gt; 입니다. BasicPermission은 계층 적 속성 명명 규칙을 따르는 이름 (예 : &quot;exitVM&quot;, &quot;setFactory&quot;, &quot;queuePrintJob&quot;등)을 포함하는 모든 권한에 필요한 기능을 정의합니다. 별표는 이름 끝에 &quot;.&quot;다음에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;a. *&quot;또는 &quot;*&quot;는 유효하고 &quot;* a&quot;또는 &quot;a * b&quot;는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="347f7f827caff153779dd2d9b4af53a94351d1b4" translate="yes" xml:space="preserve">
          <source>All byte values &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt;, and &lt;code&gt;'\u00A0'&lt;/code&gt; through &lt;code&gt;'\u00FF'&lt;/code&gt; are considered to be alphabetic.</source>
          <target state="translated">모든 바이트 값 &lt;code&gt;'A'&lt;/code&gt; ~ &lt;code&gt;'Z'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; ~ &lt;code&gt;'z'&lt;/code&gt; 및 &lt;code&gt;'\u00A0'&lt;/code&gt; ~ &lt;code&gt;'\u00FF'&lt;/code&gt; 는 알파벳으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8552f73b4811345f781343c3994c603e7d7b9574" translate="yes" xml:space="preserve">
          <source>All byte values &lt;code&gt;'\u0000'&lt;/code&gt; through &lt;code&gt;'\u0020'&lt;/code&gt; are considered to be white space.</source>
          <target state="translated">모든 바이트 값 &lt;code&gt;'\u0000'&lt;/code&gt; 에서 &lt;code&gt;'\u0020'&lt;/code&gt; 은 공백으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="919af563f54fc2f298fea28f1737af59bf8fe0e5" translate="yes" xml:space="preserve">
          <source>All cached resource bundles are subject to removal from the cache due to memory constraints of the runtime environment. Returning a large positive value doesn't mean to lock loaded resource bundles in the cache.</source>
          <target state="translated">캐시 된 모든 자원 번들은 런타임 환경의 메모리 제한으로 인해 캐시에서 제거 될 수 있습니다. 큰 양수 값을 반환한다고해서 캐시에로드 된 리소스 번들을 잠그는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="84b7c6fb0baa8e47fe302dcf84277ecf595b3b76" translate="yes" xml:space="preserve">
          <source>All calculations should check for numeric overflow and throw either an &lt;a href=&quot;../../lang/arithmeticexception&quot;&gt;&lt;code&gt;ArithmeticException&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../datetimeexception&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 계산은 숫자 오버플로를 확인하고 &lt;a href=&quot;../../lang/arithmeticexception&quot;&gt; &lt;code&gt;ArithmeticException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../datetimeexception&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5ec61cf807864ba46159aaef3f52f7eef737d022" translate="yes" xml:space="preserve">
          <source>All calculations should check for numeric overflow and throw either an &lt;a href=&quot;../lang/arithmeticexception&quot;&gt;&lt;code&gt;ArithmeticException&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;datetimeexception&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 계산은 숫자 오버플로를 확인하고 &lt;a href=&quot;../lang/arithmeticexception&quot;&gt; &lt;code&gt;ArithmeticException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;datetimeexception&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5b38a41a60083c9bf4ef2472cdf31a0251c2e6a4" translate="yes" xml:space="preserve">
          <source>All characters in the range &lt;code&gt;'\u0001'&lt;/code&gt; to &lt;code&gt;'\u007F'&lt;/code&gt; are represented by a single byte:</source>
          <target state="translated">&lt;code&gt;'\u0001'&lt;/code&gt; ~ &lt;code&gt;'\u007F'&lt;/code&gt; 범위 의 모든 문자 는 단일 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="77e91a244651be93fa0d408db5223b8c2473937d" translate="yes" xml:space="preserve">
          <source>All characters printed by a &lt;code&gt;PrintStream&lt;/code&gt; are converted into bytes using the platform's default character encoding. The &lt;code&gt;&lt;a href=&quot;printwriter&quot;&gt;&lt;code&gt;PrintWriter&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; class should be used in situations that require writing characters rather than bytes.</source>
          <target state="translated">&lt;code&gt;PrintStream&lt;/code&gt; 에 의해 인쇄 된 모든 문자 는 플랫폼의 기본 문자 인코딩을 사용하여 바이트로 변환됩니다. &lt;code&gt;&lt;a href=&quot;printwriter&quot;&gt;&lt;code&gt;PrintWriter&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 클래스는 쓰기 문자가 아닌 바이트를 요구하는 경우에 사용한다.</target>
        </trans-unit>
        <trans-unit id="4d98a2253cf2a7b53c165c7fe7397538cc3860b1" translate="yes" xml:space="preserve">
          <source>All classes implementing this interface and overriding this method must call &lt;code&gt;TemporalAccessor.super.query(query)&lt;/code&gt;. JDK classes may avoid calling super if they provide behavior equivalent to the default behaviour, however non-JDK classes may not utilize this optimization and must call &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">이 인터페이스를 구현하고이 메서드를 재정의하는 모든 클래스는 &lt;code&gt;TemporalAccessor.super.query(query)&lt;/code&gt; 호출해야합니다 . JDK 클래스는 기본 동작과 동등한 동작을 제공하는 경우 super 호출을 피할 수 있지만 비 JDK 클래스는이 최적화를 활용하지 않을 수 있으며 &lt;code&gt;super&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddc738864d493ac55322707fefc811aec7c09ad0" translate="yes" xml:space="preserve">
          <source>All correctly implemented &lt;code&gt;Era&lt;/code&gt; classes are singletons, thus it is valid code to write &lt;code&gt;date.getEra() == SomeChrono.ERA_NAME)&lt;/code&gt;.</source>
          <target state="translated">올바르게 구현 된 모든 &lt;code&gt;Era&lt;/code&gt; 클래스는 싱글 톤이므로 &lt;code&gt;date.getEra() == SomeChrono.ERA_NAME)&lt;/code&gt; 을 작성하는 유효한 코드 입니다.</target>
        </trans-unit>
        <trans-unit id="7d05caa03a70802d51cf172fbd78604d8076431a" translate="yes" xml:space="preserve">
          <source>All default handler implementations must provide a public zero-argument constructor.</source>
          <target state="translated">모든 기본 핸들러 구현은 공개 제로 인수 생성자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d25e69fce8f89e378f4b73ec864e0fa0832ff4a5" translate="yes" xml:space="preserve">
          <source>All elements are permitted, including &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 을 포함한 모든 요소가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="021291174612a3d36a34d1d3420c3f4e0dd8fb5f" translate="yes" xml:space="preserve">
          <source>All elements in the optional section are treated as optional. During formatting, the section is only output if data is available in the &lt;code&gt;TemporalAccessor&lt;/code&gt; for all the elements in the section. During parsing, the whole section may be missing from the parsed string.</source>
          <target state="translated">선택적 섹션의 모든 요소는 선택적으로 처리됩니다. 서식을 지정하는 동안 섹션의 모든 요소에 대해 &lt;code&gt;TemporalAccessor&lt;/code&gt; 에서 데이터를 사용할 수있는 경우에만 섹션이 출력됩니다 . 구문 분석 중 구문 분석 된 문자열에서 전체 섹션이 누락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f48a8ce148ae673117b1fc5ce92640c01d0a42" translate="yes" xml:space="preserve">
          <source>All elements in this list must be</source>
          <target state="translated">이 목록의 모든 요소는</target>
        </trans-unit>
        <trans-unit id="97bbc82155d68179b8de5e9bd38f4f15d093bef3" translate="yes" xml:space="preserve">
          <source>All elements inserted into a sorted set must implement the &lt;code&gt;Comparable&lt;/code&gt; interface (or be accepted by the specified comparator). Furthermore, all such elements must be</source>
          <target state="translated">정렬 된 세트에 삽입 된 모든 요소는 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 구현해야합니다 (또는 지정된 비교기가 승인 해야 함 ). 또한 이러한 모든 요소는</target>
        </trans-unit>
        <trans-unit id="7d0f7352b3fd6692fa00b540af6b227c78a64ea8" translate="yes" xml:space="preserve">
          <source>All externalizable data is written in JDK 1.1 external data format after calling this method. This version is needed to write streams containing Externalizable data that can be read by pre-JDK 1.1.6 JVMs.</source>
          <target state="translated">이 메소드를 호출 한 후 모든 외부화 가능 데이터는 JDK 1.1 외부 데이터 형식으로 작성됩니다. 이 버전은 JDK 1.1.6 이전 JVM에서 읽을 수있는 외부화 가능 데이터가 포함 된 스트림을 작성하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c345fda4bfb8e99c245f9d84ee52953f3d678d46" translate="yes" xml:space="preserve">
          <source>All field names and values are not predefined. New fields can be defined and added by any program. Some fields have been predefined for consistency of implementation and support by the ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo, ModelMBeanNotificationInfo, ModelMBeanOperationInfo and ModelMBean classes.</source>
          <target state="translated">모든 필드 이름과 값은 미리 정의되지 않았습니다. 모든 프로그램에서 새 필드를 정의하고 추가 할 수 있습니다. 일부 필드는 ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo, ModelMBeanNotificationInfo, ModelMBeanOperationInfo 및 ModelMBean 클래스에서 구현 및 지원의 일관성을 위해 사전 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="d85fad7e127c3af759f2f2665bbcd8493251a450" translate="yes" xml:space="preserve">
          <source>All field values should be Strings. If the field values are not Strings, the programmer will have to reset or convert these fields correctly.</source>
          <target state="translated">모든 필드 값은 문자열이어야합니다. 필드 값이 문자열이 아닌 경우 프로그래머는 이러한 필드를 올바르게 재설정하거나 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cd7404f8236d5abbb1494d421551059828da953" translate="yes" xml:space="preserve">
          <source>All fields can be expressed as a &lt;code&gt;long&lt;/code&gt; integer. This method returns an object that describes the valid range for that value.</source>
          <target state="translated">모든 필드는 &lt;code&gt;long&lt;/code&gt; 정수 로 표현 될 수 있습니다 . 이 메소드는 해당 값의 유효 범위를 설명하는 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6274f1fcfa9068e08f4e4272a557aa0b7cef2888" translate="yes" xml:space="preserve">
          <source>All fields can be expressed as a &lt;code&gt;long&lt;/code&gt; integer. This method returns an object that describes the valid range for that value. The value of this temporal object is used to enhance the accuracy of the returned range. If the date-time cannot return the range, because the field is unsupported or for some other reason, an exception will be thrown.</source>
          <target state="translated">모든 필드는 &lt;code&gt;long&lt;/code&gt; 정수 로 표현 될 수 있습니다 . 이 메소드는 해당 값의 유효 범위를 설명하는 오브젝트를 리턴합니다. 이 임시 객체의 값은 반환 된 범위의 정확도를 향상시키는 데 사용됩니다. 필드가 지원되지 않거나 다른 이유로 날짜-시간이 범위를 리턴 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e765c6ae3a942e78e92220042e5f4f6ee431a266" translate="yes" xml:space="preserve">
          <source>All fields can be expressed as a &lt;code&gt;long&lt;/code&gt; integer. This method returns an object that describes the valid range for that value. This method is generally only applicable to the ISO-8601 calendar system.</source>
          <target state="translated">모든 필드는 &lt;code&gt;long&lt;/code&gt; 정수 로 표현 될 수 있습니다 . 이 메소드는 해당 값의 유효 범위를 설명하는 오브젝트를 리턴합니다. 이 방법은 일반적으로 ISO-8601 캘린더 시스템에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="098285efa23d737c9df8c5f9d458a9fcb6895cf4" translate="yes" xml:space="preserve">
          <source>All fields of the locale must be well-formed, see &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로케일의 모든 분야가 잘 형성되어야하며, 참조 &lt;a href=&quot;locale&quot;&gt; &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a94b3ae0dbda55a27778fa69776a7e282f6ab2e" translate="yes" xml:space="preserve">
          <source>All fields, including eras, have an associated numeric value. The meaning of the numeric value for era is determined by the chronology according to these principles:</source>
          <target state="translated">연대를 포함한 모든 필드에는 연관된 숫자 값이 있습니다. 시대의 숫자 값의 의미는 다음 원칙에 따라 연대기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="96f1e09ab0b2e250622dae9ef8db3ecb046003d1" translate="yes" xml:space="preserve">
          <source>All general-purpose &lt;code&gt;Collection&lt;/code&gt; implementation classes (which typically implement &lt;code&gt;Collection&lt;/code&gt; indirectly through one of its subinterfaces) should provide two &quot;standard&quot; constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type &lt;code&gt;Collection&lt;/code&gt;, which creates a new collection with the same elements as its argument. In effect, the latter constructor allows the user to copy any collection, producing an equivalent collection of the desired implementation type. There is no way to enforce this convention (as interfaces cannot contain constructors) but all of the general-purpose &lt;code&gt;Collection&lt;/code&gt; implementations in the Java platform libraries comply.</source>
          <target state="translated">모든 범용 &lt;code&gt;Collection&lt;/code&gt; (일반적으로 구현하는 구현 클래스 &lt;code&gt;Collection&lt;/code&gt; 서브 인터페이스를 개입시켜 간접적)는 두 &quot;표준&quot;생성자를 제공해야 타입의 인수와 하늘의 콜렉션을 작성하는 void (인수 없음) constructor, 및 생성자를 &lt;code&gt;Collection&lt;/code&gt; . 인수와 동일한 요소로 새 콜렉션을 작성합니다. 사실상, 후자의 생성자는 사용자가 임의의 콜렉션을 복사하여 원하는 구현 유형의 동등한 콜렉션을 생성 할 수있게합니다. 인터페이스에 생성자를 포함 할 수 없으므로이 규칙을 적용 할 방법은 없지만 Java 플랫폼 라이브러리의 모든 범용 &lt;code&gt;Collection&lt;/code&gt; 구현이 준수합니다.</target>
        </trans-unit>
        <trans-unit id="33a31e359d470ebf801e50a2a87603e677dd7c83" translate="yes" xml:space="preserve">
          <source>All general-purpose map implementation classes should provide two &quot;standard&quot; constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type &lt;code&gt;Map&lt;/code&gt;, which creates a new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply.</source>
          <target state="translated">모든 범용 맵 구현 클래스는 두 개의 &quot;표준&quot;생성자 : 빈 맵을 작성하는 void (인수 없음) 생성자 및 &lt;code&gt;Map&lt;/code&gt; 유형의 단일 인수를 가진 생성자 , 동일한 키-값으로 새 맵을 작성해야합니다. 인수로서의 매핑 사실상 후자의 생성자는 사용자가 맵을 복사하여 원하는 클래스의 동등한 맵을 생성 할 수 있도록합니다. 인터페이스가 생성자를 포함 할 수 없으므로이 권장 사항을 적용 할 방법은 없지만 JDK의 모든 범용 맵 구현이 준수합니다.</target>
        </trans-unit>
        <trans-unit id="73e770903ea6aaa7acfb2924ee8a0b8f8e5d4ab8" translate="yes" xml:space="preserve">
          <source>All general-purpose sorted map implementation classes should provide four &quot;standard&quot; constructors. It is not possible to enforce this recommendation though as required constructors cannot be specified by interfaces. The expected &quot;standard&quot; constructors for all sorted map implementations are:</source>
          <target state="translated">모든 범용 정렬 맵 구현 클래스는 4 개의 &quot;표준&quot;생성자를 제공해야합니다. 필수 생성자를 인터페이스로 지정할 수는 없지만이 권장 사항을 적용 할 수는 없습니다. 모든 정렬 된 맵 구현에 필요한 &quot;표준&quot;생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c2f0747593ee78c458f79c8168bdc6f498a0588" translate="yes" xml:space="preserve">
          <source>All general-purpose sorted set implementation classes should provide four &quot;standard&quot; constructors: 1) A void (no arguments) constructor, which creates an empty sorted set sorted according to the natural ordering of its elements. 2) A constructor with a single argument of type &lt;code&gt;Comparator&lt;/code&gt;, which creates an empty sorted set sorted according to the specified comparator. 3) A constructor with a single argument of type &lt;code&gt;Collection&lt;/code&gt;, which creates a new sorted set with the same elements as its argument, sorted according to the natural ordering of the elements. 4) A constructor with a single argument of type &lt;code&gt;SortedSet&lt;/code&gt;, which creates a new sorted set with the same elements and the same ordering as the input sorted set. There is no way to enforce this recommendation, as interfaces cannot contain constructors.</source>
          <target state="translated">모든 범용 정렬 집합 구현 클래스는 4 개의 &quot;표준&quot;생성자를 제공해야합니다. 1) void (인수 없음) 생성자. 요소의 자연 순서에 따라 정렬 된 빈 정렬 집합을 만듭니다. 2) &lt;code&gt;Comparator&lt;/code&gt; 유형의 단일 인수를 가진 생성자 . 지정된 비교기에 따라 정렬 된 빈 정렬 세트를 작성합니다. 3) &lt;code&gt;Collection&lt;/code&gt; 타입의 단일 인수를 가진 생성자. 인수 와 동일한 요소를 가진 새로운 정렬 세트를 생성하며, 요소의 자연 순서에 따라 정렬됩니다. 4) &lt;code&gt;SortedSet&lt;/code&gt; 유형의 단일 인수를 가진 생성자입력 정렬 세트와 동일한 요소 및 순서를 갖는 새로운 정렬 세트를 작성합니다. 인터페이스에는 생성자가 포함될 수 없으므로이 권장 사항을 적용 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b943c5b22b105b54ede5510669cd41720361b38" translate="yes" xml:space="preserve">
          <source>All implementations of javax.imageio provide the following standard image format plug-ins:</source>
          <target state="translated">javax.imageio의 모든 구현은 다음과 같은 표준 이미지 형식 플러그인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd19499d4dea9b9f0f3d895b35b3e20f07494810" translate="yes" xml:space="preserve">
          <source>All indices are specified in &lt;code&gt;char&lt;/code&gt; values (Unicode code units).</source>
          <target state="translated">모든 색인은 &lt;code&gt;char&lt;/code&gt; 값 (유니 코드 코드 단위)으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e496530d75d67b79c4066c7e07e73f2da93f94b1" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;MethodType&lt;/code&gt; are immutable. Two instances are completely interchangeable if they compare equal. Equality depends on pairwise correspondence of the return and parameter types and on nothing else.</source>
          <target state="translated">&lt;code&gt;MethodType&lt;/code&gt; 의 모든 인스턴스 는 변경할 수 없습니다. 두 인스턴스가 동일하게 비교되면 완전히 호환됩니다. 평등은 리턴 및 매개 변수 유형의 쌍별 통신에 의존하며 다른 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2a9bb06464c9d0b3025fd79845ccf1bf0cf58bc" translate="yes" xml:space="preserve">
          <source>All key generators share the concepts of a</source>
          <target state="translated">모든 주요 발전기는</target>
        </trans-unit>
        <trans-unit id="f7f8e453c9c57832f465a98b4b5a15b94469f615" translate="yes" xml:space="preserve">
          <source>All key pair generators share the concepts of a keysize and a source of randomness. The keysize is interpreted differently for different algorithms (e.g., in the case of the</source>
          <target state="translated">모든 키 페어 생성기는 키 크기의 개념과 무작위 소스를 공유합니다. 키 크기는 다른 알고리즘에 따라 다르게 해석됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="c5f68021c78bba6a8a8e79ee45b74432c965c67f" translate="yes" xml:space="preserve">
          <source>All keys inserted into a sorted map must implement the &lt;code&gt;Comparable&lt;/code&gt; interface (or be accepted by the specified comparator). Furthermore, all such keys must be &lt;em&gt;mutually comparable&lt;/em&gt;: &lt;code&gt;k1.compareTo(k2)&lt;/code&gt; (or &lt;code&gt;comparator.compare(k1, k2)&lt;/code&gt;) must not throw a &lt;code&gt;ClassCastException&lt;/code&gt; for any keys &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; in the sorted map. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a &lt;code&gt;ClassCastException&lt;/code&gt;.</source>
          <target state="translated">정렬 된 맵에 삽입 된 모든 키는 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 구현해야합니다 (또는 지정된 비교기가 승인 해야 함 ). 또한 이러한 모든 키는 &lt;em&gt;서로 비교 가능&lt;/em&gt; 해야합니다 . &lt;code&gt;k1.compareTo(k2)&lt;/code&gt; (또는 &lt;code&gt;comparator.compare(k1, k2)&lt;/code&gt; )는 정렬 된 맵에서 키 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 에 대해 &lt;code&gt;ClassCastException&lt;/code&gt; 을 발생시키지 않아야합니다 . 이 제한을 위반하려고하면 문제가되는 메소드 또는 생성자 호출이 &lt;code&gt;ClassCastException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="923518859e18050030f48cb37ac8122ddfe1f904" translate="yes" xml:space="preserve">
          <source>All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The characters '#', '{' and '}' are reserved for future use. The characters '[' and ']' indicate optional patterns. The following pattern letters are defined:</source>
          <target state="translated">모든 문자 'A'~ 'Z'및 'a'~ 'z'는 패턴 문자로 예약되어 있습니다. '#', '{'및 '}'문자는 나중에 사용하기 위해 예약되어 있습니다. 문자 '['및 ']'는 선택적 패턴을 나타냅니다. 다음과 같은 패턴 문자가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bdaf1bd028d0de65cdf13a3f7898625cc5f72a4b" translate="yes" xml:space="preserve">
          <source>All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The following pattern letters are defined:</source>
          <target state="translated">모든 문자 'A'~ 'Z'및 'a'~ 'z'는 패턴 문자로 예약되어 있습니다. 다음과 같은 패턴 문자가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a10359baed8cfd3eb8a7b0aba9d25037e17363e4" translate="yes" xml:space="preserve">
          <source>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the</source>
          <target state="translated">모든 리터럴 문자열과 문자열 값 상수 표현식이 인터 닝됩니다. 문자열 리터럴은 섹션 3.10.5에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cd5a9093f9fddcc8e42860d78f0e72c89ff2051f" translate="yes" xml:space="preserve">
          <source>All methods adhere to the above triggering, execution, and exceptional completion specifications (which are not repeated in individual method specifications). Additionally, while arguments used to pass a completion result (that is, for parameters of type &lt;code&gt;T&lt;/code&gt;) for methods accepting them may be null, passing a null value for any other parameter will result in a &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">모든 메소드는 위의 트리거링, 실행 및 예외적 인 완료 스펙 (개별 메소드 스펙에서 반복되지 않음)을 준수합니다. 또한 인수를 허용하는 메소드에 대해 완료 결과 (즉, &lt;code&gt;T&lt;/code&gt; 유형의 매개 변수)를 전달하는 데 사용되는 인수는 널일 수 있지만 다른 매개 변수에 널값을 전달하면 &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c11dd890515b137dee8a92754dfb1d31d3d8bd9e" translate="yes" xml:space="preserve">
          <source>All methods and constructors for this class throw &lt;code&gt;NullPointerException&lt;/code&gt; when passed a &lt;code&gt;null&lt;/code&gt; object reference for any input parameter.</source>
          <target state="translated">이 클래스의 모든 메소드와 생성자는 입력 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 오브젝트 참조를 전달하면 &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ddb2b8177f719b28a29b4b5faddc7c01fef19014" translate="yes" xml:space="preserve">
          <source>All methods and constructors in this class throw &lt;code&gt;NullPointerException&lt;/code&gt; when passed a null object reference for any input parameter. BigInteger must support values in the range -2&lt;sup&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/sup&gt; (exclusive) to +2&lt;sup&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/sup&gt; (exclusive) and may support values outside of that range. The range of probable prime values is limited and may be less than the full supported positive range of &lt;code&gt;BigInteger&lt;/code&gt;. The range must be at least 1 to 2&lt;sup&gt;500000000&lt;/sup&gt;.</source>
          <target state="translated">이 클래스의 모든 메소드와 생성자는 입력 매개 변수에 대해 널 오브젝트 참조를 전달하면 &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시킵니다. BigInteger는 -2 &lt;sup&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/sup&gt; (제외)-+2 &lt;sup&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/sup&gt; (제외) 범위의 값을 지원해야하며 해당 범위 밖의 값을 지원할 수 있습니다. 가능한 소수 값의 범위는 제한적이며 &lt;code&gt;BigInteger&lt;/code&gt; 의 지원되는 양의 범위보다 작을 수 있습니다 . 범위는 1-2 &lt;sup&gt;500000000&lt;/sup&gt; 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b651de6f6f7d41bd9ef3598f5f4aa6d55d9d85f0" translate="yes" xml:space="preserve">
          <source>All methods first check to see if the actual &lt;code&gt;modCount&lt;/code&gt; of the backing list is equal to its expected value, and throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if it is not.</source>
          <target state="translated">모든 메소드는 먼저 지원 목록 의 실제 &lt;code&gt;modCount&lt;/code&gt; 가 예상 값과 같은지 확인하고 그렇지 않은 경우 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d702d10cc4c8262f8d712f634d6178586b4d7bd3" translate="yes" xml:space="preserve">
          <source>All methods in this interface might throw a SecurityException if a security exception occurs.</source>
          <target state="translated">보안 예외가 발생하면이 인터페이스의 모든 메소드에서 SecurityException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2bb2aa00dad5c01cece9b8aa19557210208e7671" translate="yes" xml:space="preserve">
          <source>All methods in this interface might throw a SecurityException.</source>
          <target state="translated">이 인터페이스의 모든 메소드는 SecurityException을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5d910af4c0b85f22763779845ff35b7af0b030" translate="yes" xml:space="preserve">
          <source>All methods on Logger are multi-thread safe.</source>
          <target state="translated">Logger의 모든 메소드는 다중 스레드 안전합니다.</target>
        </trans-unit>
        <trans-unit id="76a5af411b37dcee11d91744a2db9658952f55fe" translate="yes" xml:space="preserve">
          <source>All methods on the LogManager object are multi-thread safe.</source>
          <target state="translated">LogManager 객체의 모든 메소드는 다중 스레드 안전합니다.</target>
        </trans-unit>
        <trans-unit id="88f468470142660d4529763d93539d46450b4c75" translate="yes" xml:space="preserve">
          <source>All methods on the execution stack are from classes defined using the system class loader or one of its ancestors.</source>
          <target state="translated">실행 스택의 모든 메소드는 시스템 클래스 로더 또는 해당 상위 항목 중 하나를 사용하여 정의 된 클래스에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="40f96797ca6ed87401c9d8ee9ed02496523a986f" translate="yes" xml:space="preserve">
          <source>All methods on the execution stack up to the first &quot;privileged&quot; caller (see &lt;a href=&quot;../security/accesscontroller#doPrivileged-java.security.PrivilegedAction-&quot;&gt;&lt;code&gt;AccessController.doPrivileged(java.security.PrivilegedAction&amp;lt;T&amp;gt;)&lt;/code&gt;&lt;/a&gt;) are from classes defined using the system class loader or one of its ancestors.</source>
          <target state="translated">첫 번째 &quot;특권&quot;호출자 ( &lt;a href=&quot;../security/accesscontroller#doPrivileged-java.security.PrivilegedAction-&quot;&gt; &lt;code&gt;AccessController.doPrivileged(java.security.PrivilegedAction&amp;lt;T&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조)까지 실행 스택의 모든 메소드 는 시스템 클래스 로더 또는 해당 상위 항목 중 하나를 사용하여 정의 된 클래스에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="cdbef3e29226d45d25b93bae02d0b37288061b53" translate="yes" xml:space="preserve">
          <source>All methods that request authentication have a default implementation that fails.</source>
          <target state="translated">인증을 요청하는 모든 메소드에는 기본 구현이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b1aa6027831da0ebc5324f16b0e629144705b462" translate="yes" xml:space="preserve">
          <source>All naming operations are relative to a context. The initial context implements the Context interface and provides the starting point for resolution of names.</source>
          <target state="translated">모든 명명 작업은 컨텍스트와 관련이 있습니다. 초기 컨텍스트는 컨텍스트 인터페이스를 구현하고 이름 확인을위한 시작점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2625999a56dbeb04d81faaaef2c32d067ca8abae" translate="yes" xml:space="preserve">
          <source>All non-mentioned characters are at the end of the collation order.</source>
          <target state="translated">언급되지 않은 모든 문자는 데이터 정렬 순서의 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb144667c9048b39032ef53e2588e8ec336f6c3" translate="yes" xml:space="preserve">
          <source>All non-public interfaces must be in the same package; otherwise, it would not be possible for the proxy class to implement all of the interfaces, regardless of what package it is defined in.</source>
          <target state="translated">모든 비 공용 인터페이스는 동일한 패키지에 있어야합니다. 그렇지 않으면 프록시 클래스가 정의 된 패키지에 관계없이 모든 인터페이스를 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8adb3a60e7e306cffb00a22eb577f8094c41614" translate="yes" xml:space="preserve">
          <source>All of FINE, FINER, and FINEST are intended for relatively detailed tracing. The exact meaning of the three levels will vary between subsystems, but in general, FINEST should be used for the most voluminous detailed output, FINER for somewhat less detailed output, and FINE for the lowest volume (and most important) messages.</source>
          <target state="translated">FINE, FINER 및 FINEST는 모두 비교적 자세한 추적을위한 것입니다. 세 가지 수준의 정확한 의미는 하위 시스템마다 다르지만 일반적으로 FINEST는 가장 방대한 세부 출력에, FINER는 다소 세부적인 출력에, FINE은 가장 작은 (가장 중요한) 메시지에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="23ade9879deabada30e535f137ddc690f5965d22" translate="yes" xml:space="preserve">
          <source>All of the &lt;code&gt;Class&lt;/code&gt; objects in the &lt;code&gt;interfaces&lt;/code&gt; array must represent interfaces, not classes or primitive types.</source>
          <target state="translated">&lt;code&gt;interfaces&lt;/code&gt; 배열 의 모든 &lt;code&gt;Class&lt;/code&gt; 객체는 클래스 또는 기본 유형이 아닌 인터페이스를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="b7983cdbbb103644804d92f221efc77397f0dbaf" translate="yes" xml:space="preserve">
          <source>All of the interface types must be visible by name through the specified class loader. In other words, for class loader &lt;code&gt;cl&lt;/code&gt; and every interface &lt;code&gt;i&lt;/code&gt;, the following expression must be true:</source>
          <target state="translated">지정된 클래스 로더를 통해 모든 인터페이스 유형을 이름으로 볼 수 있어야합니다. 다시 말해, 클래스 로더 &lt;code&gt;cl&lt;/code&gt; 및 모든 인터페이스 &lt;code&gt;i&lt;/code&gt; 에 대해 다음 표현식은 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e95d3c836aafe841199e6e8d44b310ce6671fabe" translate="yes" xml:space="preserve">
          <source>All of the methods defined in this class are safe for use by multiple concurrent threads.</source>
          <target state="translated">이 클래스에 정의 된 모든 메소드는 여러 개의 동시 스레드에서 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8be7aa2729f05bf93d281de418392fb18f64d3a6" translate="yes" xml:space="preserve">
          <source>All of the methods in this class are safe for use by multiple concurrent threads.</source>
          <target state="translated">이 클래스의 모든 메소드는 여러 개의 동시 스레드에서 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="380f0f7cb852e52252c1f4cf92128664f4c9c830" translate="yes" xml:space="preserve">
          <source>All of the methods that modify preferences data are permitted to operate asynchronously; they may return immediately, and changes will eventually propagate to the persistent backing store with an implementation-dependent delay. The &lt;code&gt;flush&lt;/code&gt; method may be used to synchronously force updates to the backing store. Normal termination of the Java Virtual Machine will</source>
          <target state="translated">기본 설정 데이터를 수정하는 모든 메소드는 비동기 적으로 작동 할 수 있습니다. 변경 사항이 즉시 반환 될 수 있으며 변경 사항은 구현에 따라 지연되는 영구 백업 저장소로 전파됩니다. &lt;code&gt;flush&lt;/code&gt; 에있어서, 상기 백킹 스토어에 동기 힘 업데이트하는데 사용될 수있다. Java Virtual Machine이 정상적으로 종료되면</target>
        </trans-unit>
        <trans-unit id="363c07f59031bbe3140fefdb870ce2ce67d42f96" translate="yes" xml:space="preserve">
          <source>All of the methods that read preferences from a &lt;code&gt;Preferences&lt;/code&gt; object require the invoker to provide a default value. The default value is returned if no value has been previously set</source>
          <target state="translated">&lt;code&gt;Preferences&lt;/code&gt; 객체 에서 기본 설정 을 읽는 모든 메서드 는 호출자가 기본값을 제공해야합니다. 이전에 값을 설정하지 않은 경우 기본값이 반환됩니다</target>
        </trans-unit>
        <trans-unit id="ec2fb1ea402182e5223f721ce517238970788528" translate="yes" xml:space="preserve">
          <source>All of the newly instantiated ProtectionDomains are combined into a new array. The ProtectionDomains from the</source>
          <target state="translated">새로 인스턴스화 된 ProtectionDomain은 모두 새 배열로 결합됩니다. 의 ProtectionDomains</target>
        </trans-unit>
        <trans-unit id="84ebb415f51fb8e2dc0d78039f349c2c8a2383c7" translate="yes" xml:space="preserve">
          <source>All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</source>
          <target state="translated">모든 작업은 이중 연결 목록에 대해 예상대로 수행됩니다. 목록에 색인을 생성하는 작업은 목록을 시작 또는 끝에서 지정된 색인에 더 가까운 쪽을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="422f5ea3de30f4a6bea070be6ae4c5c434a1b93d" translate="yes" xml:space="preserve">
          <source>All of the units in this class have an estimated duration. Days vary due to daylight saving time, while months have different lengths.</source>
          <target state="translated">이 클래스의 모든 유닛에는 예상 지속 시간이 있습니다. 날짜는 일광 절약 시간제에 따라 다르지만 달의 길이는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="515a0f098ec2318fa18f40e5c4246f849bd5caf3" translate="yes" xml:space="preserve">
          <source>All of these classes extend &lt;a href=&quot;hashattributeset&quot;&gt;HashAttributeSet&lt;/a&gt; and enforce the restriction that the attribute set is only allowed to contain the corresponding kind of attribute.</source>
          <target state="translated">이러한 모든 클래스는 &lt;a href=&quot;hashattributeset&quot;&gt;HashAttributeSet을&lt;/a&gt; 확장 하고 속성 집합에 해당하는 종류의 속성 만 포함 할 수 있도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2cc1cf9f75da034f94dbaf850197c4fef4580a2f" translate="yes" xml:space="preserve">
          <source>All or part of a mapped byte buffer may become inaccessible at any time, for example if the mapped file is truncated. An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content.</source>
          <target state="translated">예를 들어 매핑 된 파일이 잘린 경우 매핑 된 바이트 버퍼의 일부 또는 전부에 액세스 할 수 없게됩니다. 매핑 된 바이트 버퍼의 액세스 할 수없는 영역에 액세스하려고하면 버퍼의 내용이 변경되지 않으며 액세스 시점 또는 나중에 지정되지 않은 예외가 발생합니다. 따라서 파일 내용을 읽거나 쓰는 경우를 제외하고이 프로그램 또는 동시에 실행중인 프로그램에서 매핑 된 파일을 조작하지 않도록 적절한 예방 조치를 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a9a5d581b872357672903834a8a56dd4758220f" translate="yes" xml:space="preserve">
          <source>All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26b43844ef35aaaf5a75622ac2daadd84987bcd9" translate="yes" xml:space="preserve">
          <source>All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e5ecd460a14bffca69194623503e491a2b38dde9" translate="yes" xml:space="preserve">
          <source>All other &lt;code&gt;ChronoUnit&lt;/code&gt; instances will return false.</source>
          <target state="translated">다른 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="018164f166177f0cc3a0df6533050ae1fb82b97b" translate="yes" xml:space="preserve">
          <source>All other &lt;code&gt;ChronoUnit&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">다른 모든 &lt;code&gt;ChronoUnit&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="c771bf25c17c7585c2f68199cafa86277462aa4c" translate="yes" xml:space="preserve">
          <source>All other IDs are parsed as region-based zone IDs. Region IDs must match the regular expression &lt;code&gt;[A-Za-z][A-Za-z0-9~/._+-]+&lt;/code&gt; otherwise a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. If the zone ID is not in the configured set of IDs, &lt;code&gt;ZoneRulesException&lt;/code&gt; is thrown. The detailed format of the region ID depends on the group supplying the data. The default set of data is supplied by the IANA Time Zone Database (TZDB). This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'. This is compatible with most IDs from &lt;a href=&quot;../util/timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 모든 ID는 지역 기반 영역 ID로 구문 분석됩니다. 지역 ID는 정규식 &lt;code&gt;[A-Za-z][A-Za-z0-9~/._+-]+&lt;/code&gt; 와 일치해야합니다 . 그렇지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 영역 ID가 구성된 ID 세트에 &lt;code&gt;ZoneRulesException&lt;/code&gt; 이 발생합니다. 지역 ID의 자세한 형식은 데이터를 제공하는 그룹에 따라 다릅니다. 기본 데이터 세트는 IANA 시간대 데이터베이스 (TZDB)에서 제공합니다. 여기에는 '유럽 / 파리'또는 'America / New_York'와 같은 '{area} / {city}'형식의 지역 ID가 있습니다. &lt;a href=&quot;../util/timezone&quot;&gt; &lt;code&gt;TimeZone&lt;/code&gt; 의&lt;/a&gt; 대부분의 ID와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="58cebd2af2befec7aa1642b49ab70b0577d4f257" translate="yes" xml:space="preserve">
          <source>All other characters are unsafe and are first converted into one or more bytes using some encoding scheme. Then each byte is represented by the 3-character string &quot;</source>
          <target state="translated">다른 모든 문자는 안전하지 않으며 일부 인코딩 체계를 사용하여 먼저 하나 이상의 바이트로 변환됩니다. 그런 다음 각 바이트는 3 자 문자열 &quot;</target>
        </trans-unit>
        <trans-unit id="4aeb95030eb9e091e6634faca32c957c2938c121" translate="yes" xml:space="preserve">
          <source>All other characters match themselves in an implementation dependent manner. This includes characters representing any &lt;a href=&quot;filesystem#getSeparator--&quot;&gt;&lt;code&gt;name-separators&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 모든 문자는 구현에 따라 다릅니다. 여기에는 &lt;a href=&quot;filesystem#getSeparator--&quot;&gt; &lt;code&gt;name-separators&lt;/code&gt; &lt;/a&gt; 나타내는 문자가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a5218bfa16094415d19eebef423dec9763ab343" translate="yes" xml:space="preserve">
          <source>All other properties will be initialized to &quot;null&quot;.</source>
          <target state="translated">다른 모든 속성은 &quot;null&quot;로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="406da96623a6477c8d03c1e50d79373d0ded69b8" translate="yes" xml:space="preserve">
          <source>All parameters are stored by reference.</source>
          <target state="translated">모든 매개 변수는 참조로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb46389b0b5dee93cdccfc11acd6b4b4801f39c" translate="yes" xml:space="preserve">
          <source>All platforms support file-modification times to the nearest second, but some provide more precision. The argument will be truncated to fit the supported precision. If the operation succeeds and no intervening operations on the file take place, then the next invocation of the &lt;code&gt;&lt;a href=&quot;file#lastModified--&quot;&gt;&lt;code&gt;lastModified()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method will return the (possibly truncated) &lt;code&gt;time&lt;/code&gt; argument that was passed to this method.</source>
          <target state="translated">모든 플랫폼은 가장 가까운 초 단위로 파일 수정 시간을 지원하지만 일부 플랫폼은 더 정밀합니다. 지원되는 정밀도에 맞게 인수가 잘립니다. 작업이 성공하고 파일에서 개입 작업이 수행되지 않으면 &lt;code&gt;&lt;a href=&quot;file#lastModified--&quot;&gt;&lt;code&gt;lastModified()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메서드를 다음에 호출 하면이 메서드에 전달 된 (잘려진) &lt;code&gt;time&lt;/code&gt; 인수 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e5029ef268a5caba2f5b9010f3540e631f63dac" translate="yes" xml:space="preserve">
          <source>All properties whose names end with &quot;.level&quot; are assumed to define log levels for Loggers. Thus &quot;foo.level&quot; defines a log level for the logger called &quot;foo&quot; and (recursively) for any of its children in the naming hierarchy. Log Levels are applied in the order they are defined in the properties file. Thus level settings for child nodes in the tree should come after settings for their parents. The property name &quot;.level&quot; can be used to set the level for the root of the tree.</source>
          <target state="translated">이름이 &quot;.level&quot;로 끝나는 모든 속성은 로거의 로그 수준을 정의하는 것으로 간주됩니다. 따라서 &quot;foo.level&quot;은 &quot;foo&quot;라는 로거의 로그 레벨과 이름 계층의 하위 요소에 대한 (재귀 적으로) 로그 레벨을 정의합니다. 로그 레벨은 특성 파일에 정의 된 순서대로 적용됩니다. 따라서 트리의 하위 노드에 대한 레벨 설정은 부모의 설정 다음에 와야합니다. 속성 이름 &quot;.level&quot;을 사용하여 트리의 루트 수준을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03afca2ba7d419c29411ede55a6d3a79e6db2547" translate="yes" xml:space="preserve">
          <source>All public methods of &lt;code&gt;CertStore&lt;/code&gt; objects must be thread-safe. That is, multiple threads may concurrently invoke these methods on a single &lt;code&gt;CertStore&lt;/code&gt; object (or more than one) with no ill effects. This allows a &lt;code&gt;CertPathBuilder&lt;/code&gt; to search for a CRL while simultaneously searching for further certificates, for instance.</source>
          <target state="translated">&lt;code&gt;CertStore&lt;/code&gt; 객체 의 모든 공개 메소드는 thread 세이프가 아니면 안됩니다. 즉, 여러 스레드가 동시에 단일 &lt;code&gt;CertStore&lt;/code&gt; 오브젝트 (또는 둘 이상) 에서 이러한 메소드를 병행 하여 아무런 영향을 미치지 않을 수 있습니다. 이를 통해 &lt;code&gt;CertPathBuilder&lt;/code&gt; 는 예를 들어 추가 인증서를 동시에 검색하면서 CRL을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a29b26788c9af453cc9f4e8adf2aa86c462f0f64" translate="yes" xml:space="preserve">
          <source>All resource bundles loaded are cached by default. Refer to &lt;a href=&quot;resourcebundle.control#getTimeToLive-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;control.getTimeToLive&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">로드 된 모든 자원 번들은 기본적으로 캐시됩니다. 자세한 내용은 &lt;a href=&quot;resourcebundle.control#getTimeToLive-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;control.getTimeToLive&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc6ad14c36aec1e98be4f70bbabd33bcad94e69c" translate="yes" xml:space="preserve">
          <source>All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an &lt;code&gt;OutOfMemoryError&lt;/code&gt;. Otherwise no constraints are placed upon the time at which a soft reference will be cleared or the order in which a set of such references to different objects will be cleared. Virtual machine implementations are, however, encouraged to bias against clearing recently-created or recently-used soft references.</source>
          <target state="translated">가상 머신이 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 를 발생 시키기 전에 도달 가능한 오브젝트에 대한 모든 소프트 참조가 지워 졌음을 보장합니다 . 그렇지 않으면 소프트 참조가 지워지는 시간이나 다른 객체에 대한 이러한 참조 세트가 지워지는 순서에 제약이 없습니다. 그러나 가상 머신 구현은 최근에 생성되었거나 최근에 사용 된 소프트 참조를 지우는 것에 대한 편견을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="35a96308d2316b3d0712845aed8278834e56b3e0" translate="yes" xml:space="preserve">
          <source>All specified exceptions may be thrown by any of the &lt;code&gt;format&lt;/code&gt; methods of &lt;code&gt;Formatter&lt;/code&gt; as well as by any &lt;code&gt;format&lt;/code&gt; convenience methods such as &lt;a href=&quot;../lang/string#format-java.lang.String-java.lang.Object...-&quot;&gt;&lt;code&gt;String.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/printstream#printf-java.lang.String-java.lang.Object...-&quot;&gt;&lt;code&gt;PrintStream.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 모든 예외는 &lt;code&gt;Formatter&lt;/code&gt; 의 &lt;code&gt;format&lt;/code&gt; 메소드 및 &lt;a href=&quot;../lang/string#format-java.lang.String-java.lang.Object...-&quot;&gt; &lt;code&gt;String.format&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/printstream#printf-java.lang.String-java.lang.Object...-&quot;&gt; &lt;code&gt;PrintStream.printf&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;code&gt;format&lt;/code&gt; 편의 메소드에 의해 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="062e58f2c764ab7195ddcee637b8e934de5b11fb" translate="yes" xml:space="preserve">
          <source>All subsequent pages of the document will be printed through and including page</source>
          <target state="translated">문서의 모든 후속 페이지는 페이지를 포함하여 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="726ea9c3f90eee1e73c911d984885abdc207b225" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by a cryptographic service provider who wishes to supply the implementation of a particular message digest algorithm.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 메시지 요약 알고리즘의 구현을 제공하려는 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="2988695fc30788f735bb94b51d3bb8d46d482d52" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply parameter management for a particular algorithm.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 알고리즘에 대한 매개 변수 관리를 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dd34478bb8d135e1026c3596e2a76c1297ccf51" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a key pair generator for a particular algorithm.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 알고리즘에 대한 키 쌍 생성기의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="634b7bb2c2eae438f7b5907e12e7255d275f0d47" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a parameter generator for a particular algorithm.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 알고리즘에 대한 매개 변수 생성기의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c30816907363a3bd15f5d96aa657f0ab844d577" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular SSL context.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 SSL 컨텍스트의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c66a512e321b6222301c55e5d16a27a07fdebb6" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular key manager factory.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 키 관리자 팩토리의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="005e3daa270b1a2ddc307c73e1990fe346bd6f9d" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular signature algorithm.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 서명 알고리즘의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="aff6836f2d229980cf472858aa1b549ac563f40a" translate="yes" xml:space="preserve">
          <source>All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular trust manager factory.</source>
          <target state="translated">이 클래스의 모든 추상 메소드는 특정 신뢰 관리자 팩토리의 구현을 제공하려는 각 암호화 서비스 제공자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0878c8bf97e07317e74f72724ae4839d6bcede1" translate="yes" xml:space="preserve">
          <source>All the implementations supplied by the static methods are immutable.</source>
          <target state="translated">정적 메소드가 제공하는 모든 구현은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43099b2e83f55f5146ba9078759779f72bff0d08" translate="yes" xml:space="preserve">
          <source>All the methods in this interface can throw a &lt;code&gt;NamingException&lt;/code&gt; or any of its subclasses. See &lt;code&gt;NamingException&lt;/code&gt; and their subclasses for details on each exception.</source>
          <target state="translated">이 인터페이스의 모든 메소드는 &lt;code&gt;NamingException&lt;/code&gt; 또는 그 서브 클래스를 Throw 할 수 있습니다 . 각 예외에 대한 자세한 내용 은 &lt;code&gt;NamingException&lt;/code&gt; 및 해당 서브 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ce077aa356a5e80a228ce2885ff9d2590a19c55" translate="yes" xml:space="preserve">
          <source>All the methods in this interface can throw a NamingException or any of its subclasses. See NamingException and their subclasses for details on each exception.</source>
          <target state="translated">이 인터페이스의 모든 메소드는 NamingException 또는 그 서브 클래스를 Throw 할 수 있습니다. 각 예외에 대한 자세한 내용은 NamingException 및 해당 서브 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d22eb5581b223896e0bb3986c669026b6db41f8e" translate="yes" xml:space="preserve">
          <source>All the other logging methods in this class call through this method to actually perform any logging. Subclasses can override this single method to capture all log activity.</source>
          <target state="translated">이 클래스의 다른 모든 로깅 메소드는 실제로이 로깅을 수행하기 위해이 메소드를 호출합니다. 서브 클래스는이 단일 메소드를 대체하여 모든 로그 활동을 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d00965e6dfdd592e7ddee65d6c37e4ba7ff0678" translate="yes" xml:space="preserve">
          <source>All threads that are not daemon threads have died, either by returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">데몬 스레드되지 않은 모든 스레드는 호출에서 반환하여 중, 사망 한 &lt;code&gt;run&lt;/code&gt; 방법이나 넘어 전파한다는 예외를 던져 &lt;code&gt;run&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="423c48c6a66adcf55cfd5f67b0ea151b595ac362" translate="yes" xml:space="preserve">
          <source>All three sets are empty in a newly-created selector.</source>
          <target state="translated">새로 만든 선택기에서 세 세트가 모두 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d2ef58edd015016129b41ee3dd0be947c0f8ad" translate="yes" xml:space="preserve">
          <source>All time units in this class are considered to be accurate, while all date units in this class are considered to be estimated.</source>
          <target state="translated">이 클래스의 모든 시간 단위는 정확한 것으로 간주되는 반면이 클래스의 모든 날짜 단위는 추정 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce2504d5c0e5108408666feb6584e8ed2f9ac3d" translate="yes" xml:space="preserve">
          <source>All told, then, a URI instance has the following nine components:</source>
          <target state="translated">URI 인스턴스에는 다음과 같은 9 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="723bd1bb5afde0886554331ca2c2ecab0333cb0b" translate="yes" xml:space="preserve">
          <source>All units from days to eras inclusive are date-based. Time-based units and &lt;code&gt;FOREVER&lt;/code&gt; return false.</source>
          <target state="translated">날짜부터 시대까지 모든 단위는 날짜 기반입니다. 시간 기반 단위이며 &lt;code&gt;FOREVER&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8180518d51d2459c779c463234e5a7527ec854f4" translate="yes" xml:space="preserve">
          <source>All units from nanos to half-days inclusive are time-based. Date-based units and &lt;code&gt;FOREVER&lt;/code&gt; return false.</source>
          <target state="translated">나노부터 반일까지의 모든 단위는 시간 기반입니다. 날짜 기반 단위이며 &lt;code&gt;FOREVER&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abb8ff28e9876f6765f038cdfb4dbca253dc3a8d" translate="yes" xml:space="preserve">
          <source>All units have a duration, however the duration is not always accurate. For example, days have an estimated duration due to the possibility of daylight saving time changes. This method returns true if the duration is an estimate and false if it is accurate. Note that accurate/estimated ignores leap seconds.</source>
          <target state="translated">모든 단위에는 기간이 있지만 기간이 항상 정확한 것은 아닙니다. 예를 들어, 일광 절약 시간제 변경 가능성으로 인해 예상 기간이 예상됩니다. 이 메소드는 기간이 추정값이면 true를 리턴하고 정확한 경우 false를 리턴합니다. 정확 / 추정은 윤초를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b03cd79445df4a6b3c344b6ff053bc577926a33f" translate="yes" xml:space="preserve">
          <source>All units return a duration measured in standard nanoseconds from this method. The duration will be positive and non-zero. For example, an hour has a duration of &lt;code&gt;60 * 60 * 1,000,000,000ns&lt;/code&gt;.</source>
          <target state="translated">모든 단위는이 방법에서 표준 나노초 단위로 측정 된 지속 시간을 반환합니다. 지속 시간은 양수이고 0이 아닙니다. 예를 들어, 한 시간의 지속 시간은 &lt;code&gt;60 * 60 * 1,000,000,000ns&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d37aff813f354938e32a8fa0074480be7a43975" translate="yes" xml:space="preserve">
          <source>AllPermission</source>
          <target state="translated">AllPermission</target>
        </trans-unit>
        <trans-unit id="6c8faa935a8fbf27213d20a51d1e7579a7dace3f" translate="yes" xml:space="preserve">
          <source>AllPermission.equals()</source>
          <target state="translated">AllPermission.equals()</target>
        </trans-unit>
        <trans-unit id="8a5fdb05bdf8775b91a1647ba7721afe768417e8" translate="yes" xml:space="preserve">
          <source>AllPermission.getActions()</source>
          <target state="translated">AllPermission.getActions()</target>
        </trans-unit>
        <trans-unit id="282fdfead05010951fcba0e66cc861260dac4ed4" translate="yes" xml:space="preserve">
          <source>AllPermission.hashCode()</source>
          <target state="translated">AllPermission.hashCode()</target>
        </trans-unit>
        <trans-unit id="09c789ee830660d92f0ed7ac5aff140cc871c47c" translate="yes" xml:space="preserve">
          <source>AllPermission.implies()</source>
          <target state="translated">AllPermission.implies()</target>
        </trans-unit>
        <trans-unit id="1dd626787fd17604e67248ff5016be9dd5711758" translate="yes" xml:space="preserve">
          <source>AllPermission.newPermissionCollection()</source>
          <target state="translated">AllPermission.newPermissionCollection()</target>
        </trans-unit>
        <trans-unit id="b0102d5545a465557ed2434df9b565c9df2f2a02" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Boolean&lt;/code&gt; object representing the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 인수를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 객체를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="a7cb7a017c485740b5bdae16b91784dc0e0503e4" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Boolean&lt;/code&gt; object representing the value &lt;code&gt;true&lt;/code&gt; if the string argument is not &lt;code&gt;null&lt;/code&gt; and is equal, ignoring case, to the string &lt;code&gt;&quot;true&quot;&lt;/code&gt;. Otherwise, allocate a &lt;code&gt;Boolean&lt;/code&gt; object representing the value &lt;code&gt;false&lt;/code&gt;. Examples:</source>
          <target state="translated">문자열 인수가 &lt;code&gt;null&lt;/code&gt; 이 아니고 대소 문자를 무시하고 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 와 동일한 경우 &lt;code&gt;true&lt;/code&gt; 값을 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 오브젝트를 할당합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 값을 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 객체를 할당하십시오 . 예 :</target>
        </trans-unit>
        <trans-unit id="04d4d8290dd406df6bb52a538b1bfff2196872e8" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that it represents midnight, local time, at the beginning of the day specified by the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 객체를 할당 하고 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;date&lt;/code&gt; 인수로 지정된 날짜의 시작 부분에 자정, 현지 시간을 나타내도록 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="140bbbf0b0c1176e2b2a6f7fabff48d0641523f2" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that it represents the date and time indicated by the string &lt;code&gt;s&lt;/code&gt;, which is interpreted as if by the &lt;a href=&quot;date#parse-java.lang.String-&quot;&gt;&lt;code&gt;parse(java.lang.String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 로 표시된 날짜 및 시간을 나타내 도록 &lt;a href=&quot;date#parse-java.lang.String-&quot;&gt; &lt;code&gt;parse(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 해석되는 것처럼 &lt;code&gt;Date&lt;/code&gt; 객체를 할당 하고 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="51c102fe2ed2f5ad60839c9aba82ff94401ea99f" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that it represents the instant at the start of the minute specified by the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;hrs&lt;/code&gt;, and &lt;code&gt;min&lt;/code&gt; arguments, in the local time zone.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 객체를 할당 하고 현지 시간대에서 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;hrs&lt;/code&gt; 및 &lt;code&gt;min&lt;/code&gt; 인수로 지정된 분의 시작 시점을 나타내도록 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="11ad84624b4fb93fb76d14a294513c85a8313a29" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that it represents the instant at the start of the second specified by the &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;hrs&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;sec&lt;/code&gt; arguments, in the local time zone.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 객체를 할당 하고 현지 시간대에서 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;hrs&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;sec&lt;/code&gt; 인수로 지정된 초가 시작될 때의 순간을 나타내도록 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="a5b5cdf1c2c5b083aabd0860f8d53f937e7fabd4" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond.</source>
          <target state="translated">할당하는 &lt;code&gt;Date&lt;/code&gt; 객체 그래서 그것은 할당 된 시간을 나타내는이 초기화 그것은, 가장 가까운 밀리 초 단위로 측정 하였다.</target>
        </trans-unit>
        <trans-unit id="585781cf114f76a2b6643381d7f90677723b7ef2" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to represent the specified number of milliseconds since the standard base time known as &quot;the epoch&quot;, namely January 1, 1970, 00:00:00 GMT.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 객체를 할당 하고 표준 시간 ( &quot;epoch&quot;, 1970 년 1 월 1 일 00:00:00 GMT) 이후 지정된 밀리 초 수를 나타내도록 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0cf5859a59622db20e3ed46a01095b5294a04c4c" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;String&lt;/code&gt; constructed from a subarray of an array of 8-bit integer values.</source>
          <target state="translated">8 비트 정수 값 배열의 하위 배열로 구성된 새 &lt;code&gt;String&lt;/code&gt; 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="ef953bbc5695959846fba49f20f5d076bccf0fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;String&lt;/code&gt; containing characters constructed from an array of 8-bit integer values. Each character</source>
          <target state="translated">8 비트 정수 값의 배열로 구성된 문자를 포함 하는 새 &lt;code&gt;String&lt;/code&gt; 을 할당 합니다. 각 캐릭터</target>
        </trans-unit>
        <trans-unit id="9c8e596a3ef14be7a18041da1dc3763431308afa" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;String&lt;/code&gt; so that it represents the sequence of characters currently contained in the character array argument. The contents of the character array are copied; subsequent modification of the character array does not affect the newly created string.</source>
          <target state="translated">문자 배열 인수에 현재 포함 된 문자 시퀀스를 나타내도록 새 &lt;code&gt;String&lt;/code&gt; 할당합니다 . 문자 배열의 내용이 복사됩니다. 문자 배열의 후속 수정은 새로 작성된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39c3606961402c3f0c5c6e94bc00e4e9384e40a1" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;String&lt;/code&gt; that contains characters from a subarray of the &lt;a href=&quot;character#unicode&quot;&gt;Unicode code point&lt;/a&gt; array argument. The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first code point of the subarray and the &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray. The contents of the subarray are converted to &lt;code&gt;char&lt;/code&gt;s; subsequent modification of the &lt;code&gt;int&lt;/code&gt; array does not affect the newly created string.</source>
          <target state="translated">&lt;a href=&quot;character#unicode&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; 배열 인수 의 서브 어레이에서 문자를 포함 하는 새 &lt;code&gt;String&lt;/code&gt; 을 할당합니다 . &lt;code&gt;offset&lt;/code&gt; 인자 부분 배열과의 첫 번째 코드 포인트의 인덱스 &lt;code&gt;count&lt;/code&gt; 인자 부분 배열의 길이를 지정한다. 부분 배열의 내용으로 변환 &lt;code&gt;char&lt;/code&gt; 의; &lt;code&gt;int&lt;/code&gt; 배열 의 후속 수정은 새로 작성된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e910397eea6e5262f52da25cdeb4114ce5afb76f" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;String&lt;/code&gt; that contains characters from a subarray of the character array argument. The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first character of the subarray and the &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray. The contents of the subarray are copied; subsequent modification of the character array does not affect the newly created string.</source>
          <target state="translated">문자 배열 인수의 서브 어레이에서 문자를 포함 하는 새 &lt;code&gt;String&lt;/code&gt; 을 할당합니다 . &lt;code&gt;offset&lt;/code&gt; 인자 부분 배열의 선두의 문자의 인덱스 &lt;code&gt;count&lt;/code&gt; 인수 지정 배열의 길이. 하위 배열의 내용이 복사됩니다. 문자 배열의 후속 수정은 새로 작성된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a93ee9c762977870c5261c5d04a97c44d3d8330e" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object so that it has &lt;code&gt;target&lt;/code&gt; as its run object, has the specified &lt;code&gt;name&lt;/code&gt; as its name, and belongs to the thread group referred to by &lt;code&gt;group&lt;/code&gt;, and has the specified</source>
          <target state="translated">할당하는 새로운 &lt;code&gt;Thread&lt;/code&gt; 객체 그래서 가지고 &lt;code&gt;target&lt;/code&gt; , 그 실행 객체로 지정한 &lt;code&gt;name&lt;/code&gt; 의 이름으로, 그리고 스레드 그룹에 의해 참조 속한 &lt;code&gt;group&lt;/code&gt; , 지정된있다</target>
        </trans-unit>
        <trans-unit id="1dd2356c24a92918ee3afd1d3be4053b1fd90923" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object so that it has &lt;code&gt;target&lt;/code&gt; as its run object, has the specified &lt;code&gt;name&lt;/code&gt; as its name, and belongs to the thread group referred to by &lt;code&gt;group&lt;/code&gt;.</source>
          <target state="translated">할당하는 새로운 &lt;code&gt;Thread&lt;/code&gt; 객체는 그래서가 가지고있는 &lt;code&gt;target&lt;/code&gt; 의 실행 객체로, 지정된이 &lt;code&gt;name&lt;/code&gt; 의 이름으로, 그리고 스레드 그룹에 의해 참조 속한 &lt;code&gt;group&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85532a2ac39a192cf876ed81b6b383be867f6006" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(group, null, name)&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(group, null, name)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="254c7cc1416f2423a02692399bfeedf618021117" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(group, target, gname)&lt;/code&gt; ,where &lt;code&gt;gname&lt;/code&gt; is a newly generated name. Automatically generated names are of the form &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(group, target, gname)&lt;/code&gt; 와 동일한 효과를 갖습니다 . 여기서 &lt;code&gt;gname&lt;/code&gt; 은 새로 생성 된 이름입니다. 자동 생성 된 이름은 &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="8a3e7f212962df0ef5ba2e7a85fe1eaae75f2334" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(null, null, gname)&lt;/code&gt;, where &lt;code&gt;gname&lt;/code&gt; is a newly generated name. Automatically generated names are of the form &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(null, null, gname)&lt;/code&gt; 와 동일한 효과를 가지며 , 여기서 &lt;code&gt;gname&lt;/code&gt; 은 새로 생성 된 이름입니다. 자동 생성 된 이름은 &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ec44f0dc0ae0e3fe1397e51a3c7339f90fc04e11" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(null, null, name)&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(null, null, name)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6d8098381ff006509c1aee6e5c093de0ae6ec366" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(null, target, gname)&lt;/code&gt;, where &lt;code&gt;gname&lt;/code&gt; is a newly generated name. Automatically generated names are of the form &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(null, target, gname)&lt;/code&gt; 와 동일한 효과를 가지며 , 여기서 &lt;code&gt;gname&lt;/code&gt; 은 새로 생성 된 이름입니다. 자동 생성 된 이름은 &lt;code&gt;&quot;Thread-&quot;+&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="dbd8afa6f3a21c1eac47f5732e559ded6c4e6d7d" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;Thread&lt;/code&gt; object. This constructor has the same effect as &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread&lt;/a&gt;&lt;code&gt;(null, target, name)&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Thread&lt;/code&gt; 객체를 할당 합니다. 이 생성자는 &lt;a href=&quot;thread#Thread-java.lang.ThreadGroup-java.lang.Runnable-java.lang.String-&quot;&gt;Thread &lt;/a&gt; &lt;code&gt;(null, target, name)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bfe086528a1da079bdc51b0a6e46974a5a7e9e80" translate="yes" xml:space="preserve">
          <source>Allocates a new byte buffer.</source>
          <target state="translated">새로운 바이트 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="705ff5da7a82198c53ef8acfa4a738aed7d53a26" translate="yes" xml:space="preserve">
          <source>Allocates a new char buffer.</source>
          <target state="translated">새로운 문자 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5356afae0b05788555efe7774c40b990b6f58157" translate="yes" xml:space="preserve">
          <source>Allocates a new direct byte buffer.</source>
          <target state="translated">새로운 다이렉트 바이트 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c2651e8e1e3b517c36c2a91f97e2af4053eaf3c0" translate="yes" xml:space="preserve">
          <source>Allocates a new double buffer.</source>
          <target state="translated">새로운 이중 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d9dc346e81c65ad086d86bca3f3ef2ff8bba2ab8" translate="yes" xml:space="preserve">
          <source>Allocates a new float buffer.</source>
          <target state="translated">새로운 float 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="3fd434c48a0303a01e836c1bca44c021088132bb" translate="yes" xml:space="preserve">
          <source>Allocates a new int buffer.</source>
          <target state="translated">새로운 int 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="a4029adfb4a609e1bdd33f482f1e972a4343a43b" translate="yes" xml:space="preserve">
          <source>Allocates a new long buffer.</source>
          <target state="translated">새로운 긴 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="15f7a8bf3f1bbbacf52904e7ead9d27c54956a25" translate="yes" xml:space="preserve">
          <source>Allocates a new short buffer.</source>
          <target state="translated">새로운 짧은 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2b8f8bad1ede05568438b7c371810c33847859a9" translate="yes" xml:space="preserve">
          <source>Allocates a new string that contains the sequence of characters currently contained in the string buffer argument. The contents of the string buffer are copied; subsequent modification of the string buffer does not affect the newly created string.</source>
          <target state="translated">현재 문자열 버퍼 인수에 포함 된 문자 시퀀스를 포함하는 새 문자열을 할당합니다. 문자열 버퍼의 내용이 복사됩니다. 문자열 버퍼의 후속 수정은 새로 작성된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fe969ebeca279477fa7ea95ccd93ca49bc485c8" translate="yes" xml:space="preserve">
          <source>Allocates a new string that contains the sequence of characters currently contained in the string builder argument. The contents of the string builder are copied; subsequent modification of the string builder does not affect the newly created string.</source>
          <target state="translated">현재 문자열 빌더 인수에 포함 된 문자 시퀀스를 포함하는 새 문자열을 할당합니다. 문자열 빌더의 내용이 복사됩니다. 문자열 빌더의 후속 수정은 새로 작성된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b6cf80d865e24487214ba3bd8d3deca4f0f5a9c" translate="yes" xml:space="preserve">
          <source>Allow revocation check to succeed if the revocation status cannot be determined for one of the following reasons:</source>
          <target state="translated">다음 중 하나의 이유로 해지 상태를 확인할 수없는 경우 해지 확인이 성공하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="02a162c68efe6ee94b512fd3efdcee635856a4f1" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast datagrams</source>
          <target state="translated">방송 데이터 그램 전송 허용</target>
        </trans-unit>
        <trans-unit id="52b77d5f25f1894b0a58d912d0d0527f456bcad5" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast datagrams.</source>
          <target state="translated">브로드 캐스트 데이터 그램 전송을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="88303d3c2aa7661c357c333f9298fe4b2c3817bb" translate="yes" xml:space="preserve">
          <source>Allows a line to engage in data I/O. If invoked on a line that is already running, this method does nothing. Unless the data in the buffer has been flushed, the line resumes I/O starting with the first frame that was unprocessed at the time the line was stopped. When audio capture or playback starts, a &lt;code&gt;&lt;a href=&quot;lineevent.type#START&quot;&gt;&lt;code&gt;START&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; event is generated.</source>
          <target state="translated">라인이 데이터 I / O에 관여 할 수 있도록합니다. 이미 실행중인 라인에서 호출 된 경우이 메소드는 아무 작업도 수행하지 않습니다. 버퍼의 데이터가 플러시되지 않는 한, 라인이 중지 될 때 처리되지 않은 첫 번째 프레임부터 라인이 I / O를 다시 시작합니다. 오디오 캡처 또는 재생이 시작되면 &lt;code&gt;&lt;a href=&quot;lineevent.type#START&quot;&gt;&lt;code&gt;START&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4a6a2344cd9571300d256f70ca86f876b04a4076" translate="yes" xml:space="preserve">
          <source>Allows a query to be performed in the context of a specific MBean server.</source>
          <target state="translated">특정 MBean 서버의 컨텍스트에서 쿼리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee26321ae70d1b4fae35493db7173d0543f8f8b" translate="yes" xml:space="preserve">
          <source>Allows an &lt;code&gt;Object&lt;/code&gt; reference of a given class type to be stored in nodes implementing the named element. The value of the &lt;code&gt;Object&lt;/code&gt; is unconstrained other than by its class type.</source>
          <target state="translated">지정된 클래스 타입 의 &lt;code&gt;Object&lt;/code&gt; 참조를, 지정된 요소를 구현하는 노드에 포함 할 수 있습니다. &lt;code&gt;Object&lt;/code&gt; 의 값은 클래스 유형이 아닌 제약이 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb2e832463ffc4d8431a6bcea0192d6a41645f6e" translate="yes" xml:space="preserve">
          <source>Allows an &lt;code&gt;Object&lt;/code&gt; reference of a given class type to be stored in nodes implementing the named element. The value of the &lt;code&gt;Object&lt;/code&gt; must an array of objects of class type given by &lt;code&gt;classType&lt;/code&gt;, with at least &lt;code&gt;arrayMinLength&lt;/code&gt; and at most &lt;code&gt;arrayMaxLength&lt;/code&gt; elements.</source>
          <target state="translated">지정된 클래스 타입 의 &lt;code&gt;Object&lt;/code&gt; 참조를, 지정된 요소를 구현하는 노드에 포함 할 수 있습니다. &lt;code&gt;Object&lt;/code&gt; 의 값은 최소한 &lt;code&gt;arrayMinLength&lt;/code&gt; 와 최대 &lt;code&gt;arrayMaxLength&lt;/code&gt; 요소를 가진 &lt;code&gt;classType&lt;/code&gt; 이 제공하는 클래스 유형의 객체 배열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="559c8256654eeed5ebcd6fdae71d07fff6bc575d" translate="yes" xml:space="preserve">
          <source>Allows an &lt;code&gt;Object&lt;/code&gt; reference of a given class type to be stored in nodes implementing the named element. The value of the &lt;code&gt;Object&lt;/code&gt; must be one of the values given by &lt;code&gt;enumeratedValues&lt;/code&gt;.</source>
          <target state="translated">지정된 클래스 타입 의 &lt;code&gt;Object&lt;/code&gt; 참조를, 지정된 요소를 구현하는 노드에 포함 할 수 있습니다. 의 값 &lt;code&gt;Object&lt;/code&gt; 에 의해 주어진 값 중 하나 여야합니다 &lt;code&gt;enumeratedValues&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="7cce09c38889da034abcff26e11ef369be36c636" translate="yes" xml:space="preserve">
          <source>Allows an &lt;code&gt;Object&lt;/code&gt; reference of a given class type to be stored in nodes implementing the named element. The value of the &lt;code&gt;Object&lt;/code&gt; must be within the range given by &lt;code&gt;minValue&lt;/code&gt; and &lt;code&gt;maxValue&lt;/code&gt;. Furthermore, the class type must implement the &lt;code&gt;Comparable&lt;/code&gt; interface.</source>
          <target state="translated">지정된 클래스 타입 의 &lt;code&gt;Object&lt;/code&gt; 참조를, 지정된 요소를 구현하는 노드에 포함 할 수 있습니다. &lt;code&gt;Object&lt;/code&gt; 의 값은 &lt;code&gt;minValue&lt;/code&gt; 및 &lt;code&gt;maxValue&lt;/code&gt; 가 제공 한 범위 내에 있어야합니다 . 또한 클래스 유형은 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e22108997bf594c2e18d973b2472cb25d50d38c6" translate="yes" xml:space="preserve">
          <source>Allows an action to be invoked on the Dynamic MBean.</source>
          <target state="translated">동적 MBean에서 조치를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6219247faff3fe96fbc0aec2566fb10ffe5eb3b7" translate="yes" xml:space="preserve">
          <source>Allows an application to directly register an instance of a class which implements a print service. The lookup operations for this service will be performed by the PrintServiceLookup class using the attribute values and classes reported by the service. This may be less efficient than a lookup service tuned for that service. Therefore registering a &lt;code&gt;PrintServiceLookup&lt;/code&gt; instance instead is recommended. The method returns true if this service is not previously registered and is now successfully registered. This method should not be called with StreamPrintService instances. They will always fail to register and the method will return false.</source>
          <target state="translated">애플리케이션이 인쇄 서비스를 구현하는 클래스의 인스턴스를 직접 등록 할 수 있도록합니다. 이 서비스에 대한 조회 작업은 서비스가보고 한 속성 값과 클래스를 사용하여 PrintServiceLookup 클래스에 의해 수행됩니다. 이 서비스에 맞게 조정 된 조회 서비스보다 효율성이 떨어질 수 있습니다. 따라서 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 인스턴스를 대신 등록하는 것이 좋습니다. 이 서비스가 이전에 등록되지 않았으며 이제 성공적으로 등록 된 경우 메소드는 true를 리턴합니다. 이 메서드는 StreamPrintService 인스턴스와 함께 호출하면 안됩니다. 항상 등록에 실패하고 메소드는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3980278006c799059e04ff7a9d5a27b6398572b8" translate="yes" xml:space="preserve">
          <source>Allows an application to explicitly register a class that implements lookup services. The registration will not persist across VM invocations. This is useful if an application needs to make a new service available that is not part of the installation. If the lookup service is already registered, or cannot be registered, the method returns false.</source>
          <target state="translated">애플리케이션이 조회 서비스를 구현하는 클래스를 명시 적으로 등록 할 수 있도록합니다. 등록은 VM 호출에서 지속되지 않습니다. 이것은 응용 프로그램이 설치의 일부가 아닌 새 서비스를 사용 가능하게해야하는 경우 유용합니다. 조회 서비스가 이미 등록되었거나 등록 할 수없는 경우이 메소드는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="435580aa8c3c15c52bcf639dae114fb24e093ba6" translate="yes" xml:space="preserve">
          <source>Allows an object instance to be created given a string representation of an object name and the full class name, including the package name.</source>
          <target state="translated">패키지 이름을 포함하여 객체 이름과 전체 클래스 이름을 문자열로 표시하여 객체 인스턴스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f4a5566d3d06ab4cb772828e9b93b9c2d5ea8c" translate="yes" xml:space="preserve">
          <source>Allows an object instance to be created given an object name and the full class name, including the package name.</source>
          <target state="translated">패키지 이름을 포함하여 객체 이름과 전체 클래스 이름이 주어지면 객체 인스턴스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee300bae376dad1dd1989304650ddd33d067eee" translate="yes" xml:space="preserve">
          <source>Allows any resources held by this object to be released. The result of calling any other method (other than &lt;code&gt;finalize&lt;/code&gt;) subsequent to a call to this method is undefined.</source>
          <target state="translated">이 개체가 보유한 모든 리소스를 해제 할 수 있습니다. 이 메소드 에 대한 호출에 이어 &lt;code&gt;finalize&lt;/code&gt; 이외의 다른 메소드를 호출 한 결과 는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5a80de51eede4d56eac8e232993c7d511addc2b" translate="yes" xml:space="preserve">
          <source>Allows the MBean to perform any operations it needs before being registered in the MBean Server. If the name of the MBean is not specified, the MBean can provide a name for its registration. If any exception is raised, the MBean will not be registered in the MBean Server.</source>
          <target state="translated">MBean이 MBean 서버에 등록되기 전에 필요한 조작을 수행 할 수 있도록합니다. MBean의 이름이 지정되지 않은 경우 MBean은 등록 이름을 제공 할 수 있습니다. 예외가 발생하면 MBean이 MBean 서버에 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c11876fabb25cf4cb3d659c5ea736e31311fe1b7" translate="yes" xml:space="preserve">
          <source>Allows the MBean to perform any operations it needs before being registered in the MBean server. If the name of the MBean is not specified, the MBean can provide a name for its registration. If any exception is raised, the MBean will not be registered in the MBean server.</source>
          <target state="translated">MBean이 MBean 서버에 등록되기 전에 필요한 조작을 수행 할 수 있도록합니다. MBean의 이름이 지정되지 않은 경우 MBean은 등록 이름을 제공 할 수 있습니다. 예외가 발생하면 MBean 서버에 MBean이 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c209da0b4fc46f8edab76301df1d908dc2e6844" translate="yes" xml:space="preserve">
          <source>Allows the MBean to perform any operations it needs before being unregistered by the MBean server.</source>
          <target state="translated">MBean 서버에 의해 등록 해제되기 전에 MBean이 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ca574f4bc0f8b644a52b4b165875aa7351e56c07" translate="yes" xml:space="preserve">
          <source>Allows the MBean to perform any operations needed after having been registered in the MBean server or after the registration has failed.</source>
          <target state="translated">MBean 서버에 등록 된 후 또는 등록이 실패한 후 MBean이 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c5c75c591827e4f3ada6fb5fc292939d6419da50" translate="yes" xml:space="preserve">
          <source>Allows the MBean to perform any operations needed after having been unregistered in the MBean server.</source>
          <target state="translated">MBean이 MBean 서버에서 등록 해제 한 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0a183dcdd52f960761710ac32d7ee78373a175b3" translate="yes" xml:space="preserve">
          <source>Allows the m-let to perform any operations it needs before being registered in the MBean server. If the ObjectName is null, the m-let provides a default name for its registration &amp;lt;defaultDomain&amp;gt;:type=MLet</source>
          <target state="translated">m-let이 MBean 서버에 등록되기 전에 필요한 조작을 수행 할 수 있도록합니다. ObjectName이 null 인 경우, m-let은 등록에 대한 기본 이름을 제공합니다. &amp;lt;defaultDomain&amp;gt; : type = MLet</target>
        </trans-unit>
        <trans-unit id="f943e57affa411401e6c43423f95b8394ceeb038" translate="yes" xml:space="preserve">
          <source>Allows the m-let to perform any operations it needs before being unregistered by the MBean server.</source>
          <target state="translated">MBean 서버가 등록 해제하기 전에 m-let이 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7b258188d8243b4d2cbe9d888b0f2c040ae2e739" translate="yes" xml:space="preserve">
          <source>Allows the m-let to perform any operations needed after having been registered in the MBean server or after the registration has failed.</source>
          <target state="translated">MBean 서버가 MBean 서버에 등록 된 후 또는 등록이 실패한 후 필요한 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4fb6d74d6ec1dbe5b60f32c292e2bd985453c6f5" translate="yes" xml:space="preserve">
          <source>Allows the m-let to perform any operations needed after having been unregistered in the MBean server.</source>
          <target state="translated">mBean이 MBean 서버에 등록 해제 된 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="084f6de24ff8ced8c9df8f4258d81a3606e194e2" translate="yes" xml:space="preserve">
          <source>Allows the monitor MBean to perform any operations it needs before being registered in the MBean server.</source>
          <target state="translated">모니터 MBean이 MBean 서버에 등록하기 전에 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5234aeadbc44bd828d168608a5fa5af29572f335" translate="yes" xml:space="preserve">
          <source>Allows the monitor MBean to perform any operations it needs before being unregistered by the MBean server.</source>
          <target state="translated">모니터 MBean가 MBean 서버에 의해 등록 해제하기 전에 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d3a3c3d21372e9d302ede2c671bbc4b8aeb306e3" translate="yes" xml:space="preserve">
          <source>Allows the monitor MBean to perform any operations needed after having been registered in the MBean server or after the registration has failed.</source>
          <target state="translated">모니터 MBean이 MBean 서버에 등록 된 후 또는 등록이 실패한 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2aeaae3a4e464a5b6d844261a6e001d10b28561" translate="yes" xml:space="preserve">
          <source>Allows the monitor MBean to perform any operations needed after having been unregistered by the MBean server.</source>
          <target state="translated">모니터 MBean가 MBean 서버에 의해 등록 해제 한 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="6b6f8ce4e87c4035709f2bbe797971d13a0a9946" translate="yes" xml:space="preserve">
          <source>Allows the timer MBean to perform any operations it needs before being registered in the MBean server.</source>
          <target state="translated">타이머 MBean가 MBean 서버에 등록하기 전에 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9905000485d22ead60bdefc5c060df8caac1658a" translate="yes" xml:space="preserve">
          <source>Allows the timer MBean to perform any operations it needs before being unregistered by the MBean server.</source>
          <target state="translated">타이머 MBean가 MBean 서버에 의해 등록 해제하기 전에 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="356eb44c6cbd3c89d1650e8ad2514b8ea3633db3" translate="yes" xml:space="preserve">
          <source>Allows the timer MBean to perform any operations needed after having been registered in the MBean server or after the registration has failed.</source>
          <target state="translated">타이머 MBean가 MBean 서버에 등록 된 후 또는 등록이 실패한 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5e33792d1cca411c5fd475fdcff135b6a7c97ee7" translate="yes" xml:space="preserve">
          <source>Allows the timer MBean to perform any operations needed after having been unregistered by the MBean server.</source>
          <target state="translated">타이머 MBean가 MBean 서버에 의해 등록 해제 한 후 필요한 조작을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2bddc9dedb5d647fe99cfad540c2e8bb947c5eed" translate="yes" xml:space="preserve">
          <source>Allows you to get the behavior of the decimal separator with integers. (The decimal separator will always appear with decimals.)</source>
          <target state="translated">정수를 사용하여 소수 구분 기호의 동작을 얻을 수 있습니다. 소수점 구분 기호는 항상 소수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6672ccfc2d0f6460194b3a65fefef57d7bb3cf" translate="yes" xml:space="preserve">
          <source>Allows you to instantiate and register one or several MBeans in the MBean server coming from a remote URL.</source>
          <target state="translated">원격 URL에서 오는 MBean 서버에 하나 이상의 MBean을 인스턴스화하고 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0a1488802c70fe3a5b40c50ad3bed0f0fc9324a" translate="yes" xml:space="preserve">
          <source>Allows you to instantiate and register one or several MBeans in the MBean server coming from a remote URL. M-let is a shortcut for management applet. The m-let service does this by loading an m-let text file, which specifies information on the MBeans to be obtained. The information on each MBean is specified in a single instance of a tag, called the MLET tag. The location of the m-let text file is specified by a URL.</source>
          <target state="translated">원격 URL에서 오는 MBean 서버에 하나 이상의 MBean을 인스턴스화하고 등록 할 수 있습니다. M-let은 관리 애플릿의 바로 가기입니다. m-let 서비스는 얻을 MBean에 대한 정보를 지정하는 m-let 텍스트 파일을로드하여이를 수행합니다. 각 MBean에 대한 정보는 MLET 태그라고하는 단일 태그 인스턴스에 지정됩니다. m-let 텍스트 파일의 위치는 URL로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="141c09be24ac8dc0c73efe39d899176f388e7f74" translate="yes" xml:space="preserve">
          <source>Allows you to set the behavior of the decimal separator with integers. (The decimal separator will always appear with decimals.)</source>
          <target state="translated">소수 구분 기호의 동작을 정수로 설정할 수 있습니다. 소수점 구분 기호는 항상 소수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5817f09431f2a2810fc80889dec1d6f0b2a2da" translate="yes" xml:space="preserve">
          <source>Allows you to set the number formatter.</source>
          <target state="translated">숫자 포맷터를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707a85edc66a653109fa80da8910d24c0d7d6d7" translate="yes" xml:space="preserve">
          <source>Alphabetic</source>
          <target state="translated">Alphabetic</target>
        </trans-unit>
        <trans-unit id="1ae3e0056cd784ead2780334dd8d36832de21f5e" translate="yes" xml:space="preserve">
          <source>AlreadyBoundException</source>
          <target state="translated">AlreadyBoundException</target>
        </trans-unit>
        <trans-unit id="bc7323c5305283cae4b34772641fba6048ec0c98" translate="yes" xml:space="preserve">
          <source>AlreadyConnectedException</source>
          <target state="translated">AlreadyConnectedException</target>
        </trans-unit>
        <trans-unit id="c966b9cdb7a6fb661c7c9ca06cb62dccfd7f5bb8" translate="yes" xml:space="preserve">
          <source>Also as of &lt;a href=&quot;../sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, in the reference implementation an &lt;code&gt;IntersectionType&lt;/code&gt; is used to model the explicit target type of a cast expression.</source>
          <target state="translated">또한 &lt;a href=&quot;../sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt; 기준으로, 참조 구현에서 &lt;code&gt;IntersectionType&lt;/code&gt; 은 캐스트 표현식의 명시 적 대상 유형을 모델링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="560fd3ef72e5e9fd9b4771391936c978312d3981" translate="yes" xml:space="preserve">
          <source>Also if DocFlavor is not null it must be a flavor supported by this PrintService, else IllegalArgumentException will be thrown.</source>
          <target state="translated">또한 DocFlavor가 null이 아닌 경우,이 PrintService에 의해 지원되는 플레이버가 아니면 안됩니다. 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="992bca3a4a5a3792b826c12b141a6363324eaddf" translate="yes" xml:space="preserve">
          <source>Also note that the LoginModule-specific options,</source>
          <target state="translated">LoginModule 관련 옵션은</target>
        </trans-unit>
        <trans-unit id="6df6434b764698b3b113972baa6dc107cad3b492" translate="yes" xml:space="preserve">
          <source>Also note that this class stores passwords as char arrays instead of &lt;code&gt;String&lt;/code&gt; objects (which would seem more logical), because the String class is immutable and there is no way to overwrite its internal value when the password stored in it is no longer needed. Hence, this class requests the password as a char array, so it can be overwritten when done.</source>
          <target state="translated">또한이 클래스는 비밀번호가 &lt;code&gt;String&lt;/code&gt; 객체 대신 char 배열로 저장 됩니다 (보다 논리적으로 보임). String 클래스는 변경할 수 없으며 비밀번호가 저장된 비밀번호가 더 이상 필요하지 않은 경우 내부 값을 덮어 쓸 수있는 방법이 없기 때문입니다. 따라서이 클래스는 암호를 char 배열로 요청하므로 완료되면 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f79146b32e806c24e3d8d584c559446565cf54" translate="yes" xml:space="preserve">
          <source>Also note that this is different than the behaviour of the Java runtime when interpreting a stream of bytes as text data. That assumes the default encoding for the user's locale. Thus, when spooling a file in local encoding to a Java Print Service it is important to correctly specify the encoding. Developers working in the English locales should be particularly conscious of this, as their platform encoding corresponds to the default mime charset. By this coincidence that particular case may work without specifying the encoding of platform data.</source>
          <target state="translated">또한 이것은 바이트 스트림을 텍스트 데이터로 해석 할 때 Java 런타임의 동작과 다릅니다. 이는 사용자 로캘의 기본 인코딩을 가정합니다. 따라서 로컬 인코딩의 파일을 Java 인쇄 서비스에 스풀링 할 때 인코딩을 올바르게 지정하는 것이 중요합니다. 영어 로케일에서 작업하는 개발자는 플랫폼 인코딩이 기본 마임 문자 세트에 해당하므로 특히이를 알고 있어야합니다. 이러한 우연의 일치로 특정 사례는 플랫폼 데이터의 인코딩을 지정하지 않고도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="635721d29e61a012f46ed0db479ee83735a9cddc" translate="yes" xml:space="preserve">
          <source>Also, Java treats the language &quot;no&quot; as a synonym of Norwegian Bokm&amp;aring;l &quot;nb&quot;. Except for the single case &lt;code&gt;Locale(&quot;no&quot;,
 &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt; has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the requested language, then using its synonym. For example, &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following candidate list:</source>
          <target state="translated">또한 Java는 언어 &quot;no&quot;를 노르웨이 Bokm&amp;aring;l &quot;nb&quot;의 동의어로 취급합니다. 단일 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (위에서 처리됨)을 제외하고 입력 &lt;code&gt;Locale&lt;/code&gt; 언어가 &quot;no&quot;또는 &quot;nb&quot;인 경우 언어 코드가 &quot;no&quot;및 &quot;nb 인 후보 &lt;code&gt;Locale&lt;/code&gt; &quot;는 요청 된 언어를 사용하여 인터리브 된 다음 동의어를 사용하여 인터리브됩니다. 예를 들어 &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; 은 다음 후보 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2b022799707861a6bf51bb67873edc5f74d0ebdf" translate="yes" xml:space="preserve">
          <source>Also, for service providers that only support registration for existing targets, when the target that a listener has registered for is subsequently removed from the namespace, the listener is notified via a &lt;code&gt;NamingExceptionEvent&lt;/code&gt; (containing a &lt;code&gt;NameNotFoundException&lt;/code&gt;).</source>
          <target state="translated">또한 기존 대상에 대한 등록 만 지원하는 서비스 제공 업체의 경우 리스너가 등록한 대상이 네임 스페이스에서 제거되면 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; ( &lt;code&gt;NameNotFoundException&lt;/code&gt; 포함) 를 통해 리스너에게 알립니다 .</target>
        </trans-unit>
        <trans-unit id="bb09f0f6f8e9dbba923816c9b72371f650027a44" translate="yes" xml:space="preserve">
          <source>Also, if there is a security manager, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values. If the default implementation of &lt;code&gt;checkSecurityAccess&lt;/code&gt; is used (that is, that method is not overriden), then this results in a call to the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SecurityPermission(&quot;putProviderProperty.&quot;+name)&lt;/code&gt; permission.</source>
          <target state="translated">또한 보안 관리자가있는 경우 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드는 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 문자열 ( 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임 )로 호출 되어이 제공자의 특성 값을 설정해도 괜찮은지 확인합니다. &lt;code&gt;checkSecurityAccess&lt;/code&gt; 의 기본 구현 이 사용되는 경우 (즉, 해당 메소드가 대체되지 않음) &lt;code&gt;SecurityPermission(&quot;putProviderProperty.&quot;+name)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b44feffb8d34a6389c30b3d2f510f12839adc6a" translate="yes" xml:space="preserve">
          <source>Also, if there is a security manager, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties. If the default implementation of &lt;code&gt;checkSecurityAccess&lt;/code&gt; is used (that is, that method is not overriden), then this results in a call to the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SecurityPermission(&quot;removeProviderProperty.&quot;+name)&lt;/code&gt; permission.</source>
          <target state="translated">또한 보안 관리자가있는 경우 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 문자열과 함께 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름입니다.이 제공자의 특성을 제거해도 괜찮은지 확인하십시오. &lt;code&gt;checkSecurityAccess&lt;/code&gt; 의 기본 구현 이 사용되는 경우 (즉, 해당 메소드가 대체되지 않음) &lt;code&gt;SecurityPermission(&quot;removeProviderProperty.&quot;+name)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f07719bf4302008e93f03389d457ae7e31f0ca98" translate="yes" xml:space="preserve">
          <source>Alternate &lt;code&gt;CertPath&lt;/code&gt; class for serialization.</source>
          <target state="translated">직렬화를위한 대체 &lt;code&gt;CertPath&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="854c4c0d0d209a005db238dcd881180a6ac22fe7" translate="yes" xml:space="preserve">
          <source>Alternate Certificate class for serialization.</source>
          <target state="translated">직렬화를위한 대체 인증서 클래스.</target>
        </trans-unit>
        <trans-unit id="76904d3b91288fa319395a0997c7224dfc8e1d06" translate="yes" xml:space="preserve">
          <source>Alternative set of begin/end quotes.</source>
          <target state="translated">시작 / 종료 따옴표의 대체 세트.</target>
        </trans-unit>
        <trans-unit id="f2ef1d7cf5e1fdbbdab771fd539a3e091d52f6cf" translate="yes" xml:space="preserve">
          <source>Alternatively, an algorithmic process such as a database lookup or the parsing of a command line could be used as a controller, in which case the &lt;code&gt;activate&lt;/code&gt; method would simply look up or compute the settings, call methods on &lt;code&gt;IIOMetadata&lt;/code&gt; to set its state, and return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">또는 데이터베이스 조회 또는 명령 줄 구문 분석과 같은 알고리즘 프로세스를 컨트롤러로 사용할 수 있습니다.이 경우 &lt;code&gt;activate&lt;/code&gt; 메소드는 단순히 설정을 찾거나 계산하고 &lt;code&gt;IIOMetadata&lt;/code&gt; 에서 메소드를 호출 하여 상태를 설정하고 리턴합니다. &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc7911655e53c1a1de3c03f4258905341e85ad8b" translate="yes" xml:space="preserve">
          <source>Alternatively, an algorithmic process such as a database lookup or the parsing of a command line could be used as a controller, in which case the &lt;code&gt;activate&lt;/code&gt; method would simply look up or compute the settings, call the &lt;code&gt;IIOParam.setXXX&lt;/code&gt; methods, and return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">또는 데이터베이스 조회 또는 명령 줄 구문 분석과 같은 알고리즘 프로세스를 컨트롤러로 사용할 수 있습니다.이 경우 &lt;code&gt;activate&lt;/code&gt; 메소드는 단순히 설정을 찾거나 계산하고 &lt;code&gt;IIOParam.setXXX&lt;/code&gt; 메소드를 호출하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ce2e737cf807e337bfadcc8c52f1e447586bce22" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have a Java interface that corresponds to the management interface for the MBean, you can use an &lt;em&gt;MBean proxy&lt;/em&gt; like this:</source>
          <target state="translated">또는 MBean의 관리 인터페이스에 해당하는 Java 인터페이스가있는 경우 다음 과 같이 &lt;em&gt;MBean 프록시를&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b710f91e002c2cd0de85f107f01b1616b8ac390" translate="yes" xml:space="preserve">
          <source>Alternatively, it can be invoked through a proxy as follows:</source>
          <target state="translated">또는 다음과 같이 프록시를 통해 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ba2008139a8f1ddc57b10e9710b6bbabc8f2c9" translate="yes" xml:space="preserve">
          <source>Alternatively, suppose we want to move a file to new directory, keeping the same file name, and replacing any existing file of that name in the directory:</source>
          <target state="translated">또는 파일을 새 디렉토리로 이동하고 동일한 파일 이름을 유지하고 디렉토리에서 해당 이름의 기존 파일을 바꾸고 싶다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f7b67bf78b555ac6bd469d8f04fb467a6b5734ac" translate="yes" xml:space="preserve">
          <source>Alternatively, suppose we want to read file's POSIX attributes without following symbolic links:</source>
          <target state="translated">또는 다음과 같은 기호 링크없이 파일의 POSIX 속성을 읽으려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ce71aa8b3435b530752e6a94ac8ea87cc535be9d" translate="yes" xml:space="preserve">
          <source>Alternatively, the default implementation may call &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt;&lt;code&gt;getDeclaredAnnotations()&lt;/code&gt;&lt;/a&gt; a single time and the returned array examined for both directly and indirectly present annotations. The results of calling &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt;&lt;code&gt;getDeclaredAnnotations()&lt;/code&gt;&lt;/a&gt; are assumed to be consistent with the results of calling &lt;a href=&quot;annotatedelement#getDeclaredAnnotation-java.lang.Class-&quot;&gt;&lt;code&gt;getDeclaredAnnotation(Class)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 기본 구현에서 &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt; &lt;code&gt;getDeclaredAnnotations()&lt;/code&gt; &lt;/a&gt; 한 번만 호출 하면 반환 된 배열에서 직접 및 간접적으로 존재하는 주석을 모두 검사 할 수 있습니다. 호출의 결과 &lt;a href=&quot;annotatedelement#getDeclaredAnnotations--&quot;&gt; &lt;code&gt;getDeclaredAnnotations()&lt;/code&gt; &lt;/a&gt; 호출의 결과와 일치하는 것으로 가정 &lt;a href=&quot;annotatedelement#getDeclaredAnnotation-java.lang.Class-&quot;&gt; &lt;code&gt;getDeclaredAnnotation(Class)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98759ee1f8c390e76e9161d78ad47ac53a6542bf" translate="yes" xml:space="preserve">
          <source>Alters the internal state of this &lt;code&gt;IIOMetadata&lt;/code&gt; object from a tree of XML DOM &lt;code&gt;Node&lt;/code&gt;s whose syntax is defined by the given metadata format. The previous state is altered only as necessary to accommodate the nodes that are present in the given tree. If the tree structure or contents are invalid, an &lt;code&gt;IIOInvalidTreeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">주어진 메타 데이터 형식으로 구문이 정의 된 XML DOM &lt;code&gt;Node&lt;/code&gt; 트리 에서이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 의 내부 상태를 변경 합니다. 이전 상태는 주어진 트리에있는 노드를 수용하기 위해 필요한 경우에만 변경됩니다. 트리 구조 또는 내용이 유효하지 않은 경우 &lt;code&gt;IIOInvalidTreeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d336e450909c03473f64fcb71912ebf052be23f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Appendable&lt;/code&gt; methods throw an &lt;code&gt;IOException&lt;/code&gt;, this method does not. Instead, any &lt;code&gt;IOException&lt;/code&gt; is wrapped in a runtime exception.</source>
          <target state="translated">&lt;code&gt;Appendable&lt;/code&gt; 메소드는 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키지만 이 메소드는 그렇지 않습니다. 대신, 모든 &lt;code&gt;IOException&lt;/code&gt; 은 런타임 예외에 랩됩니다.</target>
        </trans-unit>
        <trans-unit id="706b4e9ae5c6063fc44a3cb6d22c9916d42ddd8d" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the same way as the &lt;a href=&quot;inputstream#read--&quot;&gt;&lt;code&gt;InputStream.read()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;RandomAccessFile&lt;/code&gt; 의이 서브 클래스 아니다 &lt;code&gt;InputStream&lt;/code&gt; 은 정확히 동일한 방법이 방법 행동한다 &lt;a href=&quot;inputstream#read--&quot;&gt; &lt;code&gt;InputStream.read()&lt;/code&gt; &lt;/a&gt; 방법 &lt;code&gt;InputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52dc1493af2951afd1ad8461bca05f6ed9765f0d" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the same way as the &lt;a href=&quot;inputstream#read-byte:A-&quot;&gt;&lt;code&gt;InputStream.read(byte[])&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;RandomAccessFile&lt;/code&gt; 의이 서브 클래스 아니다 &lt;code&gt;InputStream&lt;/code&gt; 은 정확히 동일한 방법이 방법 행동한다 &lt;a href=&quot;inputstream#read-byte:A-&quot;&gt; &lt;code&gt;InputStream.read(byte[])&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;code&gt;InputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="997ebc234ddf4f17bc2b71c1a3aa08039e972a6f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the same way as the &lt;a href=&quot;inputstream#read-byte:A-int-int-&quot;&gt;&lt;code&gt;InputStream.read(byte[], int, int)&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;RandomAccessFile&lt;/code&gt; 의이 서브 클래스 아니다 &lt;code&gt;InputStream&lt;/code&gt; 은 정확히 동일한 방법이 방법 행동한다 &lt;a href=&quot;inputstream#read-byte:A-int-int-&quot;&gt; &lt;code&gt;InputStream.read(byte[], int, int)&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;code&gt;InputStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15159aadfd03b5c88e9b5b257f6b52833b55293" translate="yes" xml:space="preserve">
          <source>Although all object graphs may be written using just these three tags, the following definitions are included so that common data structures can be expressed more concisely:</source>
          <target state="translated">이 세 가지 태그 만 사용하여 모든 객체 그래프를 작성할 수 있지만 공통 데이터 구조를보다 간결하게 표현할 수 있도록 다음 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c764bc1e5e3badebc4af7d094d1108bc346369" translate="yes" xml:space="preserve">
          <source>Although bytecode instructions can only refer to classes in a related class loader, this API can search for methods in any class, as long as a reference to its &lt;code&gt;Class&lt;/code&gt; object is available. Such cross-loader references are also possible with the Core Reflection API, and are impossible to bytecode instructions such as &lt;code&gt;invokestatic&lt;/code&gt; or &lt;code&gt;getfield&lt;/code&gt;. There is a &lt;a href=&quot;../securitymanager&quot;&gt;security manager API&lt;/a&gt; to allow applications to check such cross-loader references. These checks apply to both the &lt;code&gt;MethodHandles.Lookup&lt;/code&gt; API and the Core Reflection API (as found on &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이트 코드 명령어는 관련 클래스 로더의 클래스 만 참조 할 수 있지만이 API는 해당 &lt;code&gt;Class&lt;/code&gt; 객체에 대한 참조 가 사용 가능한 한 모든 클래스의 메소드를 검색 할 수 있습니다. 이러한 크로스 로더 참조는 Core Reflection API로도 가능하며 &lt;code&gt;invokestatic&lt;/code&gt; 또는 &lt;code&gt;getfield&lt;/code&gt; 와 같은 명령어를 바이트 코드하는 것은 불가능합니다 . 애플리케이션이 이러한 크로스 로더 참조를 확인할 수 있도록 하는 &lt;a href=&quot;../securitymanager&quot;&gt;보안 관리자 API&lt;/a&gt; 가 있습니다. 이러한 검사는 &lt;code&gt;MethodHandles.Lookup&lt;/code&gt; API와 Core Reflection API ( &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; 에 있음&lt;/a&gt; ) 모두에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e6b498ac081c333a5e7dccebc72397f91a7a248" translate="yes" xml:space="preserve">
          <source>Although historically not precise, midnight also belongs to &quot;am&quot;, and noon belongs to &quot;pm&quot;, so on the same day, 12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm</source>
          <target state="translated">역사적으로 정확하지는 않지만 자정은 &quot;am&quot;에 속하고 정오는 &quot;pm&quot;에 속하므로 같은 날 오전 12시 (자정) &amp;lt;12:01 오전 12시 (정오) &amp;lt;12 오후 1시</target>
        </trans-unit>
        <trans-unit id="cbafba975ebbb2b99cbc259699cb4f03d8c590e4" translate="yes" xml:space="preserve">
          <source>Although it is legal according to RFC 2609 to have a &lt;code&gt;&lt;em&gt;url-path&lt;/em&gt;&lt;/code&gt; that begins with a semicolon, not all implementations of SLP allow it, so it is recommended to avoid that syntax.</source>
          <target state="translated">RFC 2609에 따라 세미콜론으로 시작 하는 &lt;code&gt;&lt;em&gt;url-path&lt;/em&gt;&lt;/code&gt; 를 갖는 것이 합법적이지만 모든 SLP 구현에서 허용하지는 않으므로 해당 구문을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b823c941de0f9e2d1d13378c9ba0bedf7c139268" translate="yes" xml:space="preserve">
          <source>Although it is recommended that attribute names be valid Java identifiers, it is possible for an attribute to be called &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt;. This means that an &lt;code&gt;ObservedAttribute&lt;/code&gt; that is &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; could mean that the value to observe is either an attribute of that name, or the property &lt;code&gt;used&lt;/code&gt; within an attribute called &lt;code&gt;HeapMemoryUsage&lt;/code&gt;. So for compatibility reasons, when the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains a period (&lt;code&gt;.&lt;/code&gt;), the monitor will check whether an attribute exists whose name is the full &lt;code&gt;ObservedAttribute&lt;/code&gt; string (&lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; in the example). It does this by calling &lt;a href=&quot;../mbeanserver#getMBeanInfo-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getMBeanInfo&lt;/code&gt;&lt;/a&gt; for the observed MBean and looking for a contained &lt;a href=&quot;../mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt; with the given name. If one is found, then that is what is monitored. If more than one MBean is being observed, the behavior is unspecified if some of them have a &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; attribute and others do not. An implementation may therefore call &lt;code&gt;getMBeanInfo&lt;/code&gt; on just one of the MBeans in this case. The behavior is also unspecified if the result of the check changes while the monitor is active.</source>
          <target state="translated">속성 이름은 유효한 Java 식별자 인 것이 좋지만 속성을 &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; 로 지정할 수 있습니다 . 이는 &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; 인 &lt;code&gt;ObservedAttribute&lt;/code&gt; 가 관찰 할 값이 해당 이름의 속성이거나 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 라는 속성에 &lt;code&gt;used&lt;/code&gt; 된 특성 임을 의미 할 수 있습니다. 따라서 호환성을 위해 &lt;code&gt;ObservedAttribute&lt;/code&gt; 에 마침표 ( &lt;code&gt;.&lt;/code&gt; ) 가 포함되어 있으면 모니터는 이름이 전체 &lt;code&gt;ObservedAttribute&lt;/code&gt; 문자열 ( 예제에서는 &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; ) 인 속성이 있는지 확인합니다 . 전화해서&lt;a href=&quot;../mbeanserver#getMBeanInfo-javax.management.ObjectName-&quot;&gt; &lt;code&gt;getMBeanInfo&lt;/code&gt; &lt;/a&gt;관찰 된 MBean의 getMBeanInfo . 지정된 이름을 가지는&lt;a href=&quot;../mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt; 를 검색합니다. 발견되면 모니터링됩니다. 둘 이상의 MBean이 관찰되는 경우 그 중 일부에 &lt;code&gt;HeapMemoryUsage.used&lt;/code&gt; 속성이 있고 다른 속성이없는 경우 동작이 지정되지않습니다. 따라서 구현 &lt;code&gt;getMBeanInfo&lt;/code&gt; 경우 MBean 중 하나에서만 getMBeanInfo 를호출 할 수 있습니다. 모니터가 활성화 된 상태에서 점검 결과가 변경되면 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d51c916aaa2897c9155c6a2858409731586ff69d" translate="yes" xml:space="preserve">
          <source>Although null is an acceptable value to use in the lookup of stream printing services, it's typical to search for a particular desired format, such as Postscript(TM).</source>
          <target state="translated">스트림 인쇄 서비스 조회에 사용할 수있는 값은 null이지만 Postscript (TM)와 같이 원하는 특정 형식을 검색하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="68256607582007aeadeb4f31286ee85dfce2653f" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;Date&lt;/code&gt; class is intended to reflect coordinated universal time (UTC), it may not do so exactly, depending on the host environment of the Java Virtual Machine. Nearly all modern operating systems assume that 1 day = 24 &amp;times; 60 &amp;times; 60 = 86400 seconds in all cases. In UTC, however, about once every year or two there is an extra second, called a &quot;leap second.&quot; The leap second is always added as the last second of the day, and always on December 31 or June 30. For example, the last minute of the year 1995 was 61 seconds long, thanks to an added leap second. Most computer clocks are not accurate enough to be able to reflect the leap-second distinction.</source>
          <target state="translated">있지만 &lt;code&gt;Date&lt;/code&gt; 클래스는 협정 세계시 (UTC)를 반영하기위한 것입니다, 그렇게 정확하게, Java 가상 머신의 호스트 환경에 따라 할 수 없습니다. 거의 모든 최신 운영 체제는 모든 경우에 1 일 = 24 &amp;times; 60 &amp;times; 60 = 86400 초로 가정합니다. 그러나 UTC에서는 약 1 년에 1 ~ 2 회 정도 &quot;약 2 초&quot;라는 여분의 초가 있습니다. 윤초는 항상 하루의 마지막 초로 추가되고 항상 12 월 31 일 또는 6 월 30 일에 추가됩니다. 예를 들어 1995 년 마지막 순간은 윤초가 추가되어 61 초였습니다. 대부분의 컴퓨터 시계는 윤초를 구별 할 수있을만큼 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e9570dcfac4d179d32d45a3e5686908e47828e6" translate="yes" xml:space="preserve">
          <source>Although the Print Service API does not presently provide standardised support for administering a print service, monitoring of the print service is possible and a UI may provide for private update mechanisms.</source>
          <target state="translated">인쇄 서비스 API는 현재 인쇄 서비스 관리를위한 표준화 된 지원을 제공하지 않지만 인쇄 서비스의 모니터링이 가능하며 UI는 개인 업데이트 메커니즘을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f0cc05040c7530181c29f5081e467b4a163808" translate="yes" xml:space="preserve">
          <source>Although the basic operation of a read-write lock is straight-forward, there are many policy decisions that an implementation must make, which may affect the effectiveness of the read-write lock in a given application. Examples of these policies include:</source>
          <target state="translated">읽기-쓰기 잠금의 기본 작업은 간단하지만 구현시 고려해야 할 많은 정책 결정이 있으며, 이는 주어진 응용 프로그램에서 읽기-쓰기 잠금의 효과에 영향을 줄 수 있습니다. 이러한 정책의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bb5921804d399af5ea77288bf09dd33cf48f190" translate="yes" xml:space="preserve">
          <source>Although the latency is expressed in microseconds, a synthesizer's actual measured delay may vary over a wider range than this resolution suggests. For example, a synthesizer might have a worst-case delay of a few milliseconds or more.</source>
          <target state="translated">지연 시간은 마이크로 초로 표시되지만 신디사이저의 실제 측정 지연은이 해상도가 제안하는 것보다 더 넓은 범위에서 달라질 수 있습니다. 예를 들어, 신시사이저는 최악의 경우 몇 밀리 초 이상의 지연을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a95044f683bd0727b5122897360ca81a92ba466" translate="yes" xml:space="preserve">
          <source>Although this class implements Serializable, attempts to serialize a &lt;code&gt;LineEvent&lt;/code&gt; object will fail.</source>
          <target state="translated">이 클래스는 Serializable을 구현하지만 &lt;code&gt;LineEvent&lt;/code&gt; 객체 를 직렬화하려는 시도 는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a7f385ffe2ff8d164beb295d82218670c35cdc85" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; because a &lt;code&gt;DelayQueue&lt;/code&gt; is not capacity constrained.</source>
          <target state="translated">&lt;code&gt;DelayQueue&lt;/code&gt; 는 용량이 제한되어 있지 않으므로 항상 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c45bd045d65a4df4c0dd414d55062344a9778187" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; because a &lt;code&gt;LinkedTransferQueue&lt;/code&gt; is not capacity constrained.</source>
          <target state="translated">&lt;code&gt;LinkedTransferQueue&lt;/code&gt; 의 용량이 제한되어 있지 않으므로 항상 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b57fa304cd9c670483f8ed783fd0b672996908e5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; because a &lt;code&gt;PriorityBlockingQueue&lt;/code&gt; is not capacity constrained.</source>
          <target state="translated">항상 반환 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 때문에 &lt;code&gt;PriorityBlockingQueue&lt;/code&gt; 용량 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c574375d98cd142b7ad53177ac76c170183c447" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;false&lt;/code&gt; because this input stream does not support the &lt;a href=&quot;deflaterinputstream#mark-int-&quot;&gt;&lt;code&gt;mark()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;deflaterinputstream#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 입력 스트림이 &lt;a href=&quot;deflaterinputstream#mark-int-&quot;&gt; &lt;code&gt;mark()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;deflaterinputstream#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않기 때문에 항상 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8095cb5b5fdb4fc5e113690f76ed9cbd251fddac" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;false&lt;/code&gt;. A &lt;code&gt;SynchronousQueue&lt;/code&gt; has no internal capacity.</source>
          <target state="translated">항상 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . &lt;code&gt;SynchronousQueue&lt;/code&gt; 어떠한 내부 용량이 없다.</target>
        </trans-unit>
        <trans-unit id="e89bec8fb850573de2289bb9dc31383490faf82d" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03fd4a8d8315e9e933881f451e18d885e707d64" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;null&lt;/code&gt;. A &lt;code&gt;SynchronousQueue&lt;/code&gt; does not return elements unless actively waited on.</source>
          <target state="translated">항상 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . &lt;code&gt;SynchronousQueue&lt;/code&gt; 적극적으로에 기다렸다하지 않는 요소를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff3d9c5517735a77232228f1de018b754c387c3c" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt;. A &lt;code&gt;SynchronousQueue&lt;/code&gt; has no internal capacity.</source>
          <target state="translated">항상 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;SynchronousQueue&lt;/code&gt; 어떠한 내부 용량이 없다.</target>
        </trans-unit>
        <trans-unit id="28bb49af2a71608e74996c25d4aeabf4c67c9cac" translate="yes" xml:space="preserve">
          <source>Always returns zero. A &lt;code&gt;SynchronousQueue&lt;/code&gt; has no internal capacity.</source>
          <target state="translated">항상 0을 반환합니다. &lt;code&gt;SynchronousQueue&lt;/code&gt; 어떠한 내부 용량이 없다.</target>
        </trans-unit>
        <trans-unit id="2f2e32b964f816773e5ccdcfec64829cd9034c4f" translate="yes" xml:space="preserve">
          <source>Always throws RejectedExecutionException.</source>
          <target state="translated">항상 RejectedExecutionException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c8a0b7f294232ad12f2ce2f73c040adbce56365" translate="yes" xml:space="preserve">
          <source>Always throws an &lt;a href=&quot;../unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;. This kind of call site cannot change its target.</source>
          <target state="translated">항상 &lt;a href=&quot;../unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 이러한 종류의 콜 사이트는 대상을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="325105d0ca8c8cc88e846c97f7d636745a2ec908" translate="yes" xml:space="preserve">
          <source>Am array of ISO 639 two-letter language codes.</source>
          <target state="translated">ISO 639 2 문자 언어 코드 배열입니다.</target>
        </trans-unit>
        <trans-unit id="50c1dea8baee388447f721913a2bfdf5431c1038" translate="yes" xml:space="preserve">
          <source>Am/pm marker</source>
          <target state="translated">오전 / 오후 마커</target>
        </trans-unit>
        <trans-unit id="29e2c1dccfddb6a4eddc8f7e6df352c49eb9d772" translate="yes" xml:space="preserve">
          <source>Among the applications of this method is to await completion of a set of independent CompletableFutures before continuing a program, as in: &lt;code&gt;CompletableFuture.allOf(c1, c2,
 c3).join();&lt;/code&gt;.</source>
          <target state="translated">이 방법의 응용 프로그램은 다음과 같이 프로그램을 계속하기 전에 독립 CompletableFuture 세트의 완료를 기다리는 것입니다. &lt;code&gt;CompletableFuture.allOf(c1, c2, c3).join();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eedd9d2ea268f140fe29669d45dd24d7b37284c4" translate="yes" xml:space="preserve">
          <source>Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array.</source>
          <target state="translated">&lt;code&gt;System&lt;/code&gt; 클래스가 제공하는 기능 중에는 표준 입력, 표준 출력 및 오류 출력 스트림이 있습니다. 외부 적으로 정의 된 속성 및 환경 변수에 액세스 파일 및 라이브러리를 로딩하는 수단; 및 어레이의 일부를 신속하게 복사하기위한 유틸리티 방법.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="78b893ce6181cb63b5db46249eeb66668483c457" translate="yes" xml:space="preserve">
          <source>An &quot;IndexedPropertyChange&quot; event gets delivered whenever a component that conforms to the JavaBeans&amp;trade; specification (a &quot;bean&quot;) changes a bound indexed property.</source>
          <target state="translated">&quot;Beaned&quot;스펙 ( &quot;bean&quot;)을 준수하는 구성 요소가 바인드 된 색인화 된 특성을 변경할 때마다 &quot;IndexedPropertyChange&quot;이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="eaba1946db1dc9f7ab41cc4bb65e95001a2a2ddf" translate="yes" xml:space="preserve">
          <source>An &quot;IndexedPropertyChange&quot; event gets delivered whenever a component that conforms to the JavaBeans&amp;trade; specification (a &quot;bean&quot;) changes a bound indexed property. This class is an extension of &lt;code&gt;PropertyChangeEvent&lt;/code&gt; but contains the index of the property that has changed.</source>
          <target state="translated">&quot;Beaned&quot;스펙 ( &quot;bean&quot;)을 준수하는 구성 요소가 바인드 된 색인화 된 특성을 변경할 때마다 &quot;IndexedPropertyChange&quot;이벤트가 전달됩니다. 이 클래스는 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 의 확장 이지만 변경된 속성의 인덱스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b37cc07d93916ebf6d69d976e6587bd6bf4aa717" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../java/lang/reflect/invocationhandler&quot;&gt;&lt;code&gt;InvocationHandler&lt;/code&gt;&lt;/a&gt; that forwards getter methods to a &lt;a href=&quot;compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">getter 메소드를 &lt;a href=&quot;compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; 에&lt;/a&gt; 전달 하는 &lt;a href=&quot;../../../java/lang/reflect/invocationhandler&quot;&gt; &lt;code&gt;InvocationHandler&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ea7470fbda70d7692e2d346d7ec92dcfeb136199" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../java/lang/reflect/invocationhandler&quot;&gt;&lt;code&gt;InvocationHandler&lt;/code&gt;&lt;/a&gt; that forwards getter methods to a &lt;a href=&quot;compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. If you have an interface that contains only getter methods (such as &lt;code&gt;String getName()&lt;/code&gt; or &lt;code&gt;boolean isActive()&lt;/code&gt;) then you can use this class in conjunction with the &lt;a href=&quot;../../../java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; class to produce an implementation of the interface where each getter returns the value of the corresponding item in a &lt;code&gt;CompositeData&lt;/code&gt;.</source>
          <target state="translated">getter 메소드를 &lt;a href=&quot;compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; 에&lt;/a&gt; 전달 하는 &lt;a href=&quot;../../../java/lang/reflect/invocationhandler&quot;&gt; &lt;code&gt;InvocationHandler&lt;/code&gt; &lt;/a&gt; 입니다 . getter 메소드 만 포함 된 인터페이스 (예 : &lt;code&gt;String getName()&lt;/code&gt; 또는 &lt;code&gt;boolean isActive()&lt;/code&gt; )가있는 경우이 클래스를 &lt;a href=&quot;../../../java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 클래스 와 함께 사용하여 각 getter의 값을 리턴하는 인터페이스 구현을 작성할 수 있습니다. &lt;code&gt;CompositeData&lt;/code&gt; 내의 대응하는 아이템 .</target>
        </trans-unit>
        <trans-unit id="7918c71a929d07515a8383c376f1c7b452e3d1ac" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; represents an instantaneous point on the time-line. On their own, an instant has insufficient information to allow a local date-time to be obtained. Only when paired with an offset or time-zone can the local date or time be calculated.</source>
          <target state="translated">순간은 타임 라인 의 &lt;a href=&quot;../instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; &lt;/a&gt; 나타냅니다. 자체적으로 인스턴트에는 현지 날짜 시간을 확보 할 수있는 정보가 충분하지 않습니다. 오프셋 또는 시간대와 페어링 된 경우에만 현지 날짜 또는 시간을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c291da958b4f01738011692193a5b1393caec4c4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; occurs while reading a provider-configuration file;</source>
          <target state="translated">&lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 프로 바이더 구성 파일을 읽는 동안 발생;</target>
        </trans-unit>
        <trans-unit id="ddc2cfe54fe2569a712d60c27c4d6401768a7dcc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;coderresult#unmappableForLength-int-&quot;&gt;unmappable-character&lt;/a&gt; result indicates that an unmappable-character error has been detected. The bytes that decode the unmappable character begin at the input buffer's (possibly incremented) position; the number of such bytes may be determined by invoking the result object's &lt;a href=&quot;coderresult#length--&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; method. This case applies only if the &lt;a href=&quot;charsetdecoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;unmappable action&lt;/a&gt; of this decoder is &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;&lt;code&gt;CodingErrorAction.REPORT&lt;/code&gt;&lt;/a&gt;; otherwise the unmappable character will be ignored or replaced, as requested.</source>
          <target state="translated">&lt;a href=&quot;coderresult#unmappableForLength-int-&quot;&gt;맵 불가 문자&lt;/a&gt; 결과 맵 불가 문자 에러가 검출되었음을 나타낸다. 매핑 할 수없는 문자를 디코딩하는 바이트는 입력 버퍼의 (증분 될 수있는) 위치에서 시작합니다. 이러한 바이트 수는 결과 객체의 &lt;a href=&quot;coderresult#length--&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 결정될 수 있습니다 . 이 경우는 이 디코더 의 &lt;a href=&quot;charsetdecoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;매핑&lt;/a&gt; 할 수 없는 액션 이 &lt;a href=&quot;codingerroraction#REPORT&quot;&gt; &lt;code&gt;CodingErrorAction.REPORT&lt;/code&gt; 인&lt;/a&gt; 경우에만 적용됩니다 . 그렇지 않으면 요청에 따라 매핑 할 수없는 문자가 무시되거나 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="24ad5d778674482cb1fadf96bfafeed35f4ee8e7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;coderresult#unmappableForLength-int-&quot;&gt;unmappable-character&lt;/a&gt; result indicates that an unmappable-character error has been detected. The characters that encode the unmappable character begin at the input buffer's (possibly incremented) position; the number of such characters may be determined by invoking the result object's &lt;a href=&quot;coderresult#length--&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; method. This case applies only if the &lt;a href=&quot;charsetencoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;unmappable action&lt;/a&gt; of this encoder is &lt;a href=&quot;codingerroraction#REPORT&quot;&gt;&lt;code&gt;CodingErrorAction.REPORT&lt;/code&gt;&lt;/a&gt;; otherwise the unmappable character will be ignored or replaced, as requested.</source>
          <target state="translated">&lt;a href=&quot;coderresult#unmappableForLength-int-&quot;&gt;맵 불가 문자&lt;/a&gt; 결과 맵 불가 문자 에러가 검출되었음을 나타낸다. 매핑 할 수없는 문자를 인코딩하는 문자는 입력 버퍼의 (증분 될 수있는) 위치에서 시작합니다. 이러한 문자의 수는 결과 객체의 &lt;a href=&quot;coderresult#length--&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 결정될 수 있습니다 . 이 경우는 이 인코더 의 &lt;a href=&quot;charsetencoder#onUnmappableCharacter-java.nio.charset.CodingErrorAction-&quot;&gt;매핑&lt;/a&gt; 할 수 없는 동작 이 &lt;a href=&quot;codingerroraction#REPORT&quot;&gt; &lt;code&gt;CodingErrorAction.REPORT&lt;/code&gt; 인&lt;/a&gt; 경우에만 적용됩니다 . 그렇지 않으면 요청에 따라 매핑 할 수없는 문자가 무시되거나 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="935dcd5e72d6e4581b22e340e57695e0b66b55e7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;exchanger&quot;&gt;&lt;code&gt;Exchanger&lt;/code&gt;&lt;/a&gt; allows two threads to exchange objects at a rendezvous point, and is useful in several pipeline designs.</source>
          <target state="translated">&lt;a href=&quot;exchanger&quot;&gt; &lt;code&gt;Exchanger&lt;/code&gt; &lt;/a&gt; 랑데부 지점에서 교환 개체에 대한 두 개의 스레드를 허용하고, 여러 파이프 라인 설계에 유용하다.</target>
        </trans-unit>
        <trans-unit id="e27c8aaf65d75ce09eff85c14d3c20dce763a054" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; that provides methods to manage termination and methods that can produce a &lt;a href=&quot;future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; for tracking progress of one or more asynchronous tasks.</source>
          <target state="translated">종료를 관리하는 방법과 하나 이상의 비동기 작업의 진행 상황을 추적 하기위한 &lt;a href=&quot;future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 생성 할 수있는 방법을 제공 하는 &lt;a href=&quot;executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="bda0cfcde78543a3931d228fe016db10d680fe51" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; for running &lt;a href=&quot;forkjointask&quot;&gt;&lt;code&gt;ForkJoinTask&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; 를&lt;/a&gt; 실행하기위한 &lt;a href=&quot;forkjointask&quot;&gt; &lt;code&gt;ForkJoinTask&lt;/code&gt; &lt;/a&gt; 들.</target>
        </trans-unit>
        <trans-unit id="bcebfee103ed68fcb7a95dda7ecaff77c1920261" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; for running &lt;a href=&quot;forkjointask&quot;&gt;&lt;code&gt;ForkJoinTask&lt;/code&gt;&lt;/a&gt;s. A &lt;code&gt;ForkJoinPool&lt;/code&gt; provides the entry point for submissions from non-&lt;code&gt;ForkJoinTask&lt;/code&gt; clients, as well as management and monitoring operations.</source>
          <target state="translated">&lt;a href=&quot;executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; 를&lt;/a&gt; 실행하기위한 &lt;a href=&quot;forkjointask&quot;&gt; &lt;code&gt;ForkJoinTask&lt;/code&gt; &lt;/a&gt; 들. &lt;code&gt;ForkJoinPool&lt;/code&gt; 은 비로부터 제출에 대한 진입 점을 제공 &lt;code&gt;ForkJoinTask&lt;/code&gt; 의 고객뿐만 아니라 관리 및 모니터링 작업을.</target>
        </trans-unit>
        <trans-unit id="fb82c3e10e84ea888b99043d94e6f67f83436be9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; that can schedule commands to run after a given delay, or to execute periodically.</source>
          <target state="translated">지정된 지연 후에 실행하거나 주기적으로 실행하도록 명령을 예약 할 수 있는 &lt;a href=&quot;executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fe4373b66e102cf8d9711f250fd25d164ce6bcd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;executorservice&quot;&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; that executes each submitted task using one of possibly several pooled threads, normally configured using &lt;a href=&quot;executors&quot;&gt;&lt;code&gt;Executors&lt;/code&gt;&lt;/a&gt; factory methods.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;executors&quot;&gt; &lt;code&gt;Executors&lt;/code&gt; &lt;/a&gt; 팩토리 메소드를 사용하여 구성된 여러 개의 스레드 된 스레드 중 하나를 사용하여 제출 된 각 태스크를 실행 하는 &lt;a href=&quot;executorservice&quot;&gt; &lt;code&gt;ExecutorService&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c32c64304c28fa379b6726ffcf58f65020dc5a9a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; object that is exported through JRMP and that creates client connections as RMI objects exported through JRMP.</source>
          <target state="translated">&lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; JRMP로부터 export RMI는 JRMP로부터 export 객체로 그 클라이언트 접속을 작성하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="8ee2a66ef29756688ac8031b2103f7bd95c0fbfc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; object that is exported through JRMP and that creates client connections as RMI objects exported through JRMP. User code does not usually reference this class directly.</source>
          <target state="translated">&lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; JRMP로부터 export RMI는 JRMP로부터 export 객체로 그 클라이언트 접속을 작성하는 객체입니다. 사용자 코드는 일반적으로이 클래스를 직접 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d820e40f267bbd7a7c9a292fd4799bfdc72f7d2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rmiserverimpl&quot;&gt;&lt;code&gt;RMIServerImpl&lt;/code&gt;&lt;/a&gt; that is exported through IIOP and that creates client connections as RMI objects exported through IIOP.</source>
          <target state="translated">&lt;a href=&quot;rmiserverimpl&quot;&gt; &lt;code&gt;RMIServerImpl&lt;/code&gt; 의&lt;/a&gt; IIOP로부터 export RMI가 IIOP를 통해 수출 객체로 즉 클라이언트 연결을 생성한다.</target>
        </trans-unit>
        <trans-unit id="80d636756fafe7e42672c7ba5c976b14ff0db59e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rmiserverimpl&quot;&gt;&lt;code&gt;RMIServerImpl&lt;/code&gt;&lt;/a&gt; that is exported through IIOP and that creates client connections as RMI objects exported through IIOP. User code does not usually reference this class directly.</source>
          <target state="translated">&lt;a href=&quot;rmiserverimpl&quot;&gt; &lt;code&gt;RMIServerImpl&lt;/code&gt; 의&lt;/a&gt; IIOP로부터 export RMI가 IIOP를 통해 수출 객체로 즉 클라이언트 연결을 생성한다. 사용자 코드는 일반적으로이 클래스를 직접 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="035897082c5a646c3645fab59021733e8b60b8e2" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;unmodifiable view&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;변경 불가능한 뷰&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="732e341ff398c966399ffe8adede4c2af068b316" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AlgorithmParameters&lt;/code&gt; object for managing the parameters for a particular algorithm can be obtained by calling one of the &lt;code&gt;getInstance&lt;/code&gt; factory methods (static methods that return instances of a given class).</source>
          <target state="translated">&lt;code&gt;AlgorithmParameters&lt;/code&gt; 중 하나를 호출하여 얻을 수있다, 특정 알고리즘에 대한 파라미터를 관리하는 오브젝트 &lt;code&gt;getInstance&lt;/code&gt; (즉, 주어진 클래스의 인스턴스 복귀 정적 메소드) 공장 방법.</target>
        </trans-unit>
        <trans-unit id="32be98b9f0bd655fa83c61c3a17f96f640b0e767" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArithmeticException&lt;/code&gt; exception is thrown if</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;ArithmeticException&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3150a3c54bfdd7c1cc5684dcb0b31ab6d4c013a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArrayType&lt;/code&gt; is assignable from another &lt;code&gt;ArrayType&lt;/code&gt; if they have the same &lt;a href=&quot;arraytype#getDimension--&quot;&gt;dimension&lt;/a&gt;; and both are &lt;a href=&quot;arraytype#isPrimitiveArray--&quot;&gt;primitive arrays&lt;/a&gt; or neither is; and the &lt;a href=&quot;arraytype#getElementOpenType--&quot;&gt;element type&lt;/a&gt; of the first is assignable from the element type of the second.</source>
          <target state="translated">&lt;code&gt;ArrayType&lt;/code&gt; 은 서로 할당 할 &lt;code&gt;ArrayType&lt;/code&gt; 가 동일한 경우 &lt;a href=&quot;arraytype#getDimension--&quot;&gt;차원을&lt;/a&gt; ; 둘 다 &lt;a href=&quot;arraytype#isPrimitiveArray--&quot;&gt;프리미티브 배열&lt;/a&gt; 이거나 아니거나; 상기 &lt;a href=&quot;arraytype#getElementOpenType--&quot;&gt;요소 형&lt;/a&gt; 제의 두 번째 요소의 유형의 할당이다.</target>
        </trans-unit>
        <trans-unit id="153a3fb7efabcd052fc7608e2c4916868820fbd3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AsynchronousFileChannel&lt;/code&gt; is associated with a thread pool to which tasks are submitted to handle I/O events and dispatch to completion handlers that consume the results of I/O operations on the channel. The completion handler for an I/O operation initiated on a channel is guaranteed to be invoked by one of the threads in the thread pool (This ensures that the completion handler is run by a thread with the expected &lt;em&gt;identity&lt;/em&gt;). Where an I/O operation completes immediately, and the initiating thread is itself a thread in the thread pool, then the completion handler may be invoked directly by the initiating thread. When an &lt;code&gt;AsynchronousFileChannel&lt;/code&gt; is created without specifying a thread pool then the channel is associated with a system-dependent default thread pool that may be shared with other channels. The default thread pool is configured by the system properties defined by the &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;code&gt;AsynchronousFileChannel&lt;/code&gt; 는 작업이 채널의 I / O 작업의 결과를 소모 완료 핸들러에 I / O 이벤트와 파견을 처리하기 위해 제출되는 스레드 풀과 연관되어 있습니다. 채널에서 시작된 I / O 조작의 완료 핸들러는 스레드 풀의 스레드 중 하나에 의해 호출되도록 보장됩니다 (이는 완료 &lt;em&gt;ID&lt;/em&gt; 가 예상 &lt;em&gt;ID를&lt;/em&gt; 가진 스레드에 의해 실행되도록합니다 ). I / O 조작이 즉시 완료되고 시작 스레드 자체가 스레드 풀의 스레드 인 경우, 완료 핸들러는 시작 스레드에 의해 직접 호출 될 수 있습니다. 때 &lt;code&gt;AsynchronousFileChannel&lt;/code&gt; 스레드 풀을 지정하지 않고 작성되면 채널이 다른 채널과 공유 될 수있는 시스템 종속 기본 스레드 풀과 연관됩니다. 기본 스레드 풀은 &lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; &lt;/a&gt; 클래스에 의해 정의 된 시스템 특성으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c3db66ad3ba110918b097fd77f4598bc42443d0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AtomicMarkableReference&lt;/code&gt; maintains an object reference along with a mark bit, that can be updated atomically.</source>
          <target state="translated">&lt;code&gt;AtomicMarkableReference&lt;/code&gt; 은 원자 적으로 갱신 가능한 마크 비트와 함께, 객체 참조를 유지한다.</target>
        </trans-unit>
        <trans-unit id="3016ca343ad81aeb0b1615e8d6b447240b35e017" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AtomicStampedReference&lt;/code&gt; maintains an object reference along with an integer &quot;stamp&quot;, that can be updated atomically.</source>
          <target state="translated">&lt;code&gt;AtomicStampedReference&lt;/code&gt; 은 원자 적으로 갱신 할 수있는 정수 &quot;스탬프&quot;와 함께 객체 참조를 유지한다.</target>
        </trans-unit>
        <trans-unit id="5123f30fd658dab6b046fb2838b15fe7fc022ae6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AttributeValueExp&lt;/code&gt; may be used anywhere a &lt;code&gt;ValueExp&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;AttributeValueExp&lt;/code&gt; 를은 어디서나 사용할 수있는 &lt;code&gt;ValueExp&lt;/code&gt; 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8f7495226a71eb28232272eba0ac094ee51a6901" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AttributeValueExp&lt;/code&gt; with a null attribute.</source>
          <target state="translated">널 속성이 있는 &lt;code&gt;AttributeValueExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="279f42bf99952eeaa9b39b58bc837bfab21b9fd6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; allows iteration through both text and related attribute information.</source>
          <target state="translated">&lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 텍스트와 그 텍스트에 관련하는 속성 정보를, 어느 쪽이나 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9854cf7f134e76ab170aa24d1a103b687670ef81" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Attributes&lt;/code&gt;, &lt;code&gt;SearchControls&lt;/code&gt;, or array object passed as a parameter to any method will not be modified by the service provider. The service provider may keep a reference to it for the duration of the operation, including any enumeration of the method's results and the processing of any referrals generated. The caller should not modify the object during this time. An &lt;code&gt;Attributes&lt;/code&gt; object returned by any method is owned by the caller. The caller may subsequently modify it; the service provider will not.</source>
          <target state="translated">메소드에 매개 변수로 전달 된 &lt;code&gt;Attributes&lt;/code&gt; , &lt;code&gt;SearchControls&lt;/code&gt; 또는 배열 오브젝트는 서비스 제공자가 수정하지 않습니다. 서비스 제공자는 메소드 결과의 열거 및 생성 된 참조 처리를 포함하여 작업 기간 동안 참조를 유지할 수 있습니다. 이 시간 동안 호출자는 객체를 수정해서는 안됩니다. 메소드가 리턴 한 &lt;code&gt;Attributes&lt;/code&gt; 오브젝트는 호출자가 소유합니다. 호출자는 나중에이를 수정할 수 있습니다. 서비스 제공 업체는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c952d9d193515a12f408dfc6292651d7f8241a6d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AudioFileFormat&lt;/code&gt; object can include a set of properties. A property is a pair of key and value: the key is of type &lt;code&gt;String&lt;/code&gt;, the associated property value is an arbitrary object. Properties specify additional informational meta data (like a author, copyright, or file duration). Properties are optional information, and file reader and file writer implementations are not required to provide or recognize properties.</source>
          <target state="translated">&lt;code&gt;AudioFileFormat&lt;/code&gt; 의 객체는 속성 집합을 포함 할 수 있습니다. 속성은 키와 값의 쌍입니다. 키는 &lt;code&gt;String&lt;/code&gt; 유형 이고 관련 속성 값은 임의의 개체입니다. 속성은 추가 정보 메타 데이터 (작성자, 저작권 또는 파일 기간 등)를 지정합니다. 등록 정보는 선택적 정보이며 파일 판독기 및 파일 작성기 구현은 등록 정보를 제공하거나 인식 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8267c07578a64bfea8ce9a39a53900834e8cade" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AudioFormat&lt;/code&gt; object can include a set of properties. A property is a pair of key and value: the key is of type &lt;code&gt;String&lt;/code&gt;, the associated property value is an arbitrary object. Properties specify additional format specifications, like the bit rate for compressed formats. Properties are mainly used as a means to transport additional information of the audio format to and from the service providers. Therefore, properties are ignored in the &lt;a href=&quot;audioformat#matches-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;matches(AudioFormat)&lt;/code&gt;&lt;/a&gt; method. However, methods which rely on the installed service providers, like &lt;a href=&quot;audiosystem#isConversionSupported-javax.sound.sampled.AudioFormat.Encoding-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;(AudioFormat, AudioFormat) isConversionSupported&lt;/code&gt;&lt;/a&gt; may consider properties, depending on the respective service provider implementation.</source>
          <target state="translated">&lt;code&gt;AudioFormat&lt;/code&gt; 객체는 속성 집합을 포함 할 수 있습니다. 속성은 키와 값의 쌍입니다. 키는 &lt;code&gt;String&lt;/code&gt; 유형 이고 관련 속성 값은 임의의 개체입니다. 속성은 압축 형식의 비트 전송률과 같은 추가 형식 사양을 지정합니다. 속성은 주로 오디오 형식의 추가 정보를 서비스 공급자와주고받는 수단으로 사용됩니다. 따라서 &lt;a href=&quot;audioformat#matches-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;matches(AudioFormat)&lt;/code&gt; &lt;/a&gt; 메서드 에서는 속성이 무시됩니다 . 그러나 &lt;a href=&quot;audiosystem#isConversionSupported-javax.sound.sampled.AudioFormat.Encoding-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;(AudioFormat, AudioFormat) isConversionSupported&lt;/code&gt; &lt;/a&gt; 와 같이 설치된 서비스 공급자를 사용하는 메서드 는 각 서비스 공급자 구현에 따라 속성을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39254013db75a6318f326d2a81c1b330d357f85e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Encoder&lt;/code&gt; is a class which can be used to create files or streams that encode the state of a collection of JavaBeans in terms of their public APIs.</source>
          <target state="translated">&lt;code&gt;Encoder&lt;/code&gt; 파일을 만드는 데 사용 또는 공개 API의 측면에서 그 인코딩을 JavaBeans 상태를 스트림 할 수있는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="57db16f3208b781807ac71c1c01187fa3e9377be" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Encoder&lt;/code&gt; is a class which can be used to create files or streams that encode the state of a collection of JavaBeans in terms of their public APIs. The &lt;code&gt;Encoder&lt;/code&gt;, in conjunction with its persistence delegates, is responsible for breaking the object graph down into a series of &lt;code&gt;Statements&lt;/code&gt;s and &lt;code&gt;Expression&lt;/code&gt;s which can be used to create it. A subclass typically provides a syntax for these expressions using some human readable form - like Java source code or XML.</source>
          <target state="translated">&lt;code&gt;Encoder&lt;/code&gt; 파일을 만드는 데 사용 또는 공개 API의 측면에서 그 인코딩을 JavaBeans 상태를 스트림 할 수있는 클래스입니다. &lt;code&gt;Encoder&lt;/code&gt; , 지속적인 위양과 함께, 일련의 아래로 객체 그래프를 파괴 할 책임이 &lt;code&gt;Statements&lt;/code&gt; 들과 &lt;code&gt;Expression&lt;/code&gt; 사용될 수들을 생성한다. 서브 클래스는 일반적으로 Java 소스 코드 또는 XML과 같이 사람이 읽을 수있는 형태를 사용하여 이러한 표현식에 대한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a2762916eff2ee0911d64b1e4075c136b4b6a548" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Error&lt;/code&gt; is a subclass of &lt;code&gt;Throwable&lt;/code&gt; that indicates serious problems that a reasonable application should not try to catch.</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; 의 서브 클래스 &lt;code&gt;Throwable&lt;/code&gt; 합리적 응용 프로그램이라면 파악하려고 시도해서는 안 심각한 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48a662260ef3ea122e49b8ef9a4f642585cccde8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Error&lt;/code&gt; is a subclass of &lt;code&gt;Throwable&lt;/code&gt; that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The &lt;code&gt;ThreadDeath&lt;/code&gt; error, though a &quot;normal&quot; condition, is also a subclass of &lt;code&gt;Error&lt;/code&gt; because most applications should not try to catch it.</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; 의 서브 클래스 &lt;code&gt;Throwable&lt;/code&gt; 합리적 응용 프로그램이라면 파악하려고 시도해서는 안 심각한 문제를 나타냅니다. 이러한 오류는 대부분 비정상적인 상태입니다. &lt;code&gt;ThreadDeath&lt;/code&gt; 에러는 「정상」인 상태입니다 만, 또한의 서브 클래스 &lt;code&gt;Error&lt;/code&gt; 대부분의 응용 프로그램에서는 캐치해서는 안되기 때문이다.</target>
        </trans-unit>
        <trans-unit id="b25ba7da66a2e434a31c596e1c9a7682b7d798df" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ExecutorService&lt;/code&gt; can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an &lt;code&gt;ExecutorService&lt;/code&gt;. The &lt;a href=&quot;executorservice#shutdown--&quot;&gt;&lt;code&gt;shutdown()&lt;/code&gt;&lt;/a&gt; method will allow previously submitted tasks to execute before terminating, while the &lt;a href=&quot;executorservice#shutdownNow--&quot;&gt;&lt;code&gt;shutdownNow()&lt;/code&gt;&lt;/a&gt; method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused &lt;code&gt;ExecutorService&lt;/code&gt; should be shut down to allow reclamation of its resources.</source>
          <target state="translated">&lt;code&gt;ExecutorService&lt;/code&gt; 입니다은 이 새 작업을 거부하는 원인이되는, 종료 할 수 있습니다. &lt;code&gt;ExecutorService&lt;/code&gt; 종료를 위해 두 가지 다른 방법이 제공됩니다 . &lt;a href=&quot;executorservice#shutdown--&quot;&gt; &lt;code&gt;shutdown()&lt;/code&gt; &lt;/a&gt; 그동안 방법은 이전에 제출 한 작업을 종료하기 전에 실행 할 수 &lt;a href=&quot;executorservice#shutdownNow--&quot;&gt; &lt;code&gt;shutdownNow()&lt;/code&gt; &lt;/a&gt; 메소드 방지를 시작하고 작업을 실행하는 현재 중지하려는 시도로부터 작업을 기다리고. 종료시 실행자는 현재 실행중인 작업이없고, 실행 대기중인 작업이 없으며, 새 작업을 제출할 수 없습니다. 사용하지 않는 &lt;code&gt;ExecutorService&lt;/code&gt; 를 종료하여 자원을 교정 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="911cc4d361073ce5459c6b73df64355557887a59" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Expression&lt;/code&gt; object represents a primitive expression in which a single method is applied to a target and a set of arguments to return a result - as in &lt;code&gt;&quot;a.getFoo()&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Expression&lt;/code&gt; 처럼 - 오브젝트는 하나의 방법은 타겟 및 결과를 반환하는 인수의 세트에 적용되는 원시 표현 나타내는 &lt;code&gt;&quot;a.getFoo()&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="215a9876e2b623e5944bd9958e1e3ffaf2e78159" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIOInvalidTreeException&lt;/code&gt; is thrown when an attempt by an &lt;code&gt;IIOMetadata&lt;/code&gt; object to parse a tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt;s fails.</source>
          <target state="translated">&lt;code&gt;IIOInvalidTreeException&lt;/code&gt; 의 시도 할 때 발생합니다 &lt;code&gt;IIOMetadata&lt;/code&gt; 의 객체가 나무를 구문 분석 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 를 의 실패.</target>
        </trans-unit>
        <trans-unit id="3c04129b842e0c295a65eac3a6a7fd549c01fba5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIOInvalidTreeException&lt;/code&gt; is thrown when an attempt by an &lt;code&gt;IIOMetadata&lt;/code&gt; object to parse a tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt;s fails. The node that led to the parsing error may be stored. As with any parsing error, the actual error may occur at a different point that that where it is detected. The node returned by &lt;code&gt;getOffendingNode&lt;/code&gt; should merely be considered as a clue to the actual nature of the problem.</source>
          <target state="translated">&lt;code&gt;IIOInvalidTreeException&lt;/code&gt; 의 시도 할 때 발생합니다 &lt;code&gt;IIOMetadata&lt;/code&gt; 의 객체가 나무를 구문 분석 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 를 의 실패. 구문 분석 오류가 발생한 노드가 저장되었을 수 있습니다. 구문 분석 오류와 마찬가지로 실제 오류는 감지 된 위치와 다른 지점에서 발생할 수 있습니다. &lt;code&gt;getOffendingNode&lt;/code&gt; 가 리턴 한 노드 는 문제의 실제 특성에 대한 단서로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ff541d4087da22b8754dd306bbe67f7e60d262ed" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIOMetadata&lt;/code&gt; object containing metadata associated with the image.</source>
          <target state="translated">이미지와 관련된 메타 데이터를 포함 하는 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2a1caceefed4d715e967bc65b486a71ca37b7cfa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIOMetadataController&lt;/code&gt; that is suggested for use as the controller for this &lt;code&gt;IIOMetadata&lt;/code&gt; object. It may be retrieved via &lt;code&gt;getDefaultController&lt;/code&gt;. To install the default controller, call &lt;code&gt;setController(getDefaultController())&lt;/code&gt;. This instance variable should be set by subclasses that choose to provide their own default controller, usually a GUI, for setting parameters.</source>
          <target state="translated">&lt;code&gt;IIOMetadataController&lt;/code&gt; 이의 콘트롤러로서 사용하도록 추천되고 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체입니다. &lt;code&gt;getDefaultController&lt;/code&gt; 를 통해 검색 할 수 있습니다 . 기본 컨트롤러를 설치하려면 &lt;code&gt;setController(getDefaultController())&lt;/code&gt; 호출하십시오 . 이 인스턴스 변수는 매개 변수 설정을 위해 자체 기본 제어기 (일반적으로 GUI)를 제공하도록 선택한 서브 클래스에 의해 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6c85c959befab236390af4d1a3f85834bbfc7544" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IOException&lt;/code&gt; will be thrown if the previous marked position lies in the discarded portion of the stream.</source>
          <target state="translated">&lt;code&gt;IOException&lt;/code&gt; 이는 스트림의 부분 폐기 이전의 표시된 위치에있는 경우 발생한다.</target>
        </trans-unit>
        <trans-unit id="9aca7475e60215da9f707c0ba7ec6f4941f6b472" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the precision section of the string is out of range (&lt;code&gt;&amp;lt; 0&lt;/code&gt;) or the string is not in the format created by the &lt;a href=&quot;mathcontext#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 문자열의 정밀도 부분이 범위 외 (만약 슬로우 &lt;code&gt;&amp;lt; 0&lt;/code&gt; ) 또는 문자열에 의해 생성 된 형식이 아닙니다 &lt;a href=&quot;mathcontext#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="3eff97dad7e057d90c5da902c1c97a2c994b4b70" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ImageReadParam&lt;/code&gt; object is used to specify how an image, or a set of images, will be converted on input from a stream in the context of the Java Image I/O framework. A plug-in for a specific image format will return instances of &lt;code&gt;ImageReadParam&lt;/code&gt; from the &lt;code&gt;getDefaultReadParam&lt;/code&gt; method of its &lt;code&gt;ImageReader&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 객체는 이미지 또는 이미지 세트가, 자바 이미지 I / O 프레임 워크의 컨텍스트에서 스트림로부터 입력으로 변환하는 방법을 지정하는 데 사용됩니다. 특정 이미지 형식의 플러그인 은 &lt;code&gt;ImageReader&lt;/code&gt; 구현 의 &lt;code&gt;getDefaultReadParam&lt;/code&gt; 메소드 에서 &lt;code&gt;ImageReadParam&lt;/code&gt; 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0af56b2a30943a55845e373e8a1c863f3264bfd7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ImageTranscoder&lt;/code&gt; may be used to convert the &lt;code&gt;IIOMetadata&lt;/code&gt; objects supplied by the &lt;code&gt;ImageReader&lt;/code&gt; (representing per-stream and per-image metadata) into corresponding objects suitable for encoding by a particular &lt;code&gt;ImageWriter&lt;/code&gt;. In the case where the methods of this interface are being called directly on an &lt;code&gt;ImageWriter&lt;/code&gt;, the output will be suitable for that writer.</source>
          <target state="translated">&lt;code&gt;ImageTranscoder&lt;/code&gt; 변환하는데 사용될 수있다 &lt;code&gt;IIOMetadata&lt;/code&gt; 에 의해 제공 오브젝트 &lt;code&gt;ImageReader&lt;/code&gt; 를 특정하여 부호화에 적합한 개체에 대응하는 (메타 데이터 스트림마다, 이미지 표현) &lt;code&gt;ImageWriter&lt;/code&gt; . 이 인터페이스의 메소드가 &lt;code&gt;ImageWriter&lt;/code&gt; 로 직접 호출되는 경우, 출력은 해당 라이터에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1b06626b9bc1b7d4424219cb86f9b3a4e96100a9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; to be used to generate a destination image when reading, or to set the output color type when writing. If non has been set the value will be &lt;code&gt;null&lt;/code&gt;. By default, the value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ImageTypeSpecifier&lt;/code&gt; 판독시 대상 화상을 생성 또는 기록 할 때 출력 색상 종류를 설정하기 위해 사용된다. 설정되지 않은 경우 값은 &lt;code&gt;null&lt;/code&gt; 입니다. 기본적으로 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61eb5323f84c50ba0da8ce5e355ef698aa642788" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ImageWriteParam&lt;/code&gt; may optionally be supplied for cases where it may affect thumbnail handling.</source>
          <target state="translated">&lt;code&gt;ImageWriteParam&lt;/code&gt; 선택적으로 썸네일 처리에 영향을 미칠 수있는 경우에 공급 될 수있다.</target>
        </trans-unit>
        <trans-unit id="cef976dbb17b7d66ea0f7ee9c8bea927e951dbbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ImageWriteParam&lt;/code&gt; may optionally be supplied to control the writing process. If &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a default write param will be used.</source>
          <target state="translated">&lt;code&gt;ImageWriteParam&lt;/code&gt; 임의로 기록 프로세스를 제어하기 위해 공급 될 수있다. 경우 &lt;code&gt;param&lt;/code&gt; 있습니다 &lt;code&gt;null&lt;/code&gt; , 기본 쓰기 PARAM이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0676238948674450872f874a2fc5e75fe95516fd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; will be thrown if &lt;code&gt;pos&lt;/code&gt; is smaller than the flushed position (as returned by &lt;code&gt;getflushedPosition&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 가이 경우에 발생한다 &lt;code&gt;pos&lt;/code&gt; (의해 반환 플러시 위치보다 작은 &lt;code&gt;getflushedPosition&lt;/code&gt; 로부터 ).</target>
        </trans-unit>
        <trans-unit id="5c92d6f2dde615de7d5fde4704fe88b05409eb09" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InetAddress&lt;/code&gt; representing the address of the network interface used for multicast packets.</source>
          <target state="translated">&lt;code&gt;InetAddress&lt;/code&gt; 를 멀티 캐스트 패킷에 사용하는 네트워크 인터페이스의 주소를 나타내는.</target>
        </trans-unit>
        <trans-unit id="53aa0eb23f1c7f11a897dd66738bc32f33c521e7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InvalidMidiDataException&lt;/code&gt; indicates that inappropriate MIDI data was encountered.</source>
          <target state="translated">&lt;code&gt;InvalidMidiDataException&lt;/code&gt; 부적절한 MIDI 데이터가 검출 된 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7bba11aa35eb3242c6e0f5f5f48d0e0feed1e04a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InvalidMidiDataException&lt;/code&gt; indicates that inappropriate MIDI data was encountered. This often means that the data is invalid in and of itself, from the perspective of the MIDI specification. An example would be an undefined status byte. However, the exception might simply mean that the data was invalid in the context it was used, or that the object to which the data was given was unable to parse or use it. For example, a file reader might not be able to parse a Type 2 MIDI file, even though that format is defined in the MIDI specification.</source>
          <target state="translated">&lt;code&gt;InvalidMidiDataException&lt;/code&gt; 부적절한 MIDI 데이터가 검출 된 것을 나타냅니다. 이것은 종종 MIDI 사양의 관점에서 데이터 자체가 유효하지 않음을 의미합니다. 예를 들어 정의되지 않은 상태 바이트가 있습니다. 그러나 예외는 단순히 사용 된 컨텍스트에서 데이터가 유효하지 않거나 데이터가 제공된 오브젝트가 구문 분석하거나 사용할 수 없음을 의미 할 수 있습니다. 예를 들어, 파일 판독기는 형식이 MIDI 사양에 정의되어 있어도 형식 2 MIDI 파일을 구문 분석하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876a697241aef30034474ad4bac4fc4eb205beab" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Iterator&lt;/code&gt; that yields provider objects for the given service, in some arbitrary order. The iterator will throw an &lt;code&gt;Error&lt;/code&gt; if a provider-configuration file violates the specified format or if a provider class cannot be found and instantiated.</source>
          <target state="translated">주어진 서비스에 대한 제공자 객체를 임의의 순서로 생성 하는 &lt;code&gt;Iterator&lt;/code&gt; 입니다. 공급자 구성 파일이 지정된 형식을 위반하거나 공급자 클래스를 찾아 인스턴스화 할 수없는 경우 반복자는 &lt;code&gt;Error&lt;/code&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="453a65b4c77bec339c86a663165139d2fc1bc97e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event type is fired when (the contents of) an object has changed. This might mean that its attributes have been modified, added, or removed, and/or that the object itself has been replaced. How the object has changed can be determined by examining the &lt;code&gt;NamingEvent&lt;/code&gt;'s old and new bindings.</source>
          <target state="translated">&lt;code&gt;OBJECT_CHANGED&lt;/code&gt; (의 내용) 오브젝트가 변경되었을 때 이벤트 종류가 시작된다. 이는 해당 속성이 수정, 추가 또는 제거되었거나 개체 자체가 교체되었음을 의미 할 수 있습니다. &lt;code&gt;NamingEvent&lt;/code&gt; 의 기존 바인딩과 새로운 바인딩 을 검사하여 개체가 어떻게 변경되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a1e28654a182eabca6158e76884be34c9fe9e7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.</source>
          <target state="translated">문자열에서 구문 분석 된 &lt;code&gt;Object&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a89fb1fb9e8b9333e018dcdcae26cf8926a94b8e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of error, returns null.</source>
          <target state="translated">문자열에서 구문 분석 된 &lt;code&gt;Object&lt;/code&gt; 배열입니다. 오류가 발생하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44a73feaa1d30e076b53ad0640258478b3baa47a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object&lt;/code&gt; may be supplied to the plug-in at construction time. The nature of the object is entirely plug-in specific.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 건설시 플러그에 공급 될 수있다. 객체의 특성은 전적으로 플러그인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1113d2ff78e48b86013cb0efbe478a6f171736fb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object&lt;/code&gt; parsed from the string.</source>
          <target state="translated">문자열에서 구문 분석 된 &lt;code&gt;Object&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2b2f9a781ddabf1ce08f839641cdac441c5c350" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of error, returns null.</source>
          <target state="translated">문자열에서 구문 분석 된 &lt;code&gt;Object&lt;/code&gt; 입니다. 오류가 발생하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f030ca9d09ead7fca4750fa767a999c981460022" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ObjectFactory&lt;/code&gt; is responsible for creating objects of a specific type. In the above example, you may have a &lt;code&gt;PrinterObjectFactory&lt;/code&gt; for creating &lt;code&gt;Printer&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;ObjectFactory&lt;/code&gt; 를이 특정 유형의 개체를 만들 책임이있다. 위의 예제에서 &lt;code&gt;Printer&lt;/code&gt; 객체 를 만들기 위한 &lt;code&gt;PrinterObjectFactory&lt;/code&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cffd3d33469f003918640de04922cf8a52ea2f4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ObjectFactory&lt;/code&gt; is responsible for creating objects of a specific type. In the above example, you may have a PrinterObjectFactory for creating Printer objects.</source>
          <target state="translated">&lt;code&gt;ObjectFactory&lt;/code&gt; 를이 특정 유형의 개체를 만들 책임이있다. 위의 예제에서 Printer 객체를 만들기위한 PrinterObjectFactory가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2060006d14110cec6851003aef5c5a95b2b3ee84" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ObjectInstance&lt;/code&gt;, containing the &lt;code&gt;ObjectName&lt;/code&gt; and the Java class name of the newly instantiated MBean. If the contained &lt;code&gt;ObjectName&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;, the contained Java class name is &lt;code&gt;&lt;a href=&quot;mbeanserverconnection#getMBeanInfo-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt;.</source>
          <target state="translated">새로 인스턴스화 된 MBean 의 &lt;code&gt;ObjectName&lt;/code&gt; 및 Java 클래스 이름을 포함 하는 &lt;code&gt;ObjectInstance&lt;/code&gt; . 포함 된 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;n&lt;/code&gt; 인 경우 포함 된 Java 클래스 이름은 &lt;code&gt;&lt;a href=&quot;mbeanserverconnection#getMBeanInfo-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt; .getClassName () 입니다.</target>
        </trans-unit>
        <trans-unit id="96af027203337c8583053e59a2730e00e19b4d0b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ObjectInstance&lt;/code&gt;, containing the &lt;code&gt;ObjectName&lt;/code&gt; and the Java class name of the newly instantiated MBean. If the contained &lt;code&gt;ObjectName&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;, the contained Java class name is &lt;code&gt;&lt;a href=&quot;rmiconnection#getMBeanInfo-javax.management.ObjectName-javax.security.auth.Subject-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt;.</source>
          <target state="translated">새로 인스턴스화 된 MBean 의 &lt;code&gt;ObjectName&lt;/code&gt; 및 Java 클래스 이름을 포함 하는 &lt;code&gt;ObjectInstance&lt;/code&gt; . 포함 된 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;n&lt;/code&gt; 인 경우 포함 된 Java 클래스 이름은 &lt;code&gt;&lt;a href=&quot;rmiconnection#getMBeanInfo-javax.management.ObjectName-javax.security.auth.Subject-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt; .getClassName () 입니다.</target>
        </trans-unit>
        <trans-unit id="970d026d5d18357f881129d77dd94b9ddade6ac8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ObjectInstance&lt;/code&gt;, containing the &lt;code&gt;ObjectName&lt;/code&gt; and the Java class name of the newly registered MBean. If the contained &lt;code&gt;ObjectName&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;, the contained Java class name is &lt;code&gt;&lt;a href=&quot;mbeanserver#getMBeanInfo-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt;.</source>
          <target state="translated">새로 등록 된 MBean 의 &lt;code&gt;ObjectName&lt;/code&gt; 및 Java 클래스 이름을 포함 하는 &lt;code&gt;ObjectInstance&lt;/code&gt; . 포함 된 &lt;code&gt;ObjectName&lt;/code&gt; 이 &lt;code&gt;n&lt;/code&gt; 인 경우 포함 된 Java 클래스 이름은 &lt;code&gt;&lt;a href=&quot;mbeanserver#getMBeanInfo-javax.management.ObjectName-&quot;&gt;&lt;code&gt;getMBeanInfo(n)&lt;/code&gt;&lt;/a&gt;.getClassName()&lt;/code&gt; .getClassName () 입니다.</target>
        </trans-unit>
        <trans-unit id="81ed261f51d69e08c9a9a32c6befbbe988d4db6b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;SSLEngine&lt;/code&gt; is created by calling &lt;a href=&quot;sslcontext#createSSLEngine--&quot;&gt;&lt;code&gt;SSLContext.createSSLEngine()&lt;/code&gt;&lt;/a&gt; from an initialized &lt;code&gt;SSLContext&lt;/code&gt;. Any configuration parameters should be set before making the first call to &lt;code&gt;wrap()&lt;/code&gt;, &lt;code&gt;unwrap()&lt;/code&gt;, or &lt;code&gt;beginHandshake()&lt;/code&gt;. These methods all trigger the initial handshake.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 호출함으로써 생성 &lt;a href=&quot;sslcontext#createSSLEngine--&quot;&gt; &lt;code&gt;SSLContext.createSSLEngine()&lt;/code&gt; &lt;/a&gt; 초기화 된으로부터 &lt;code&gt;SSLContext&lt;/code&gt; . &lt;code&gt;wrap()&lt;/code&gt; , &lt;code&gt;unwrap()&lt;/code&gt; 또는 &lt;code&gt;beginHandshake()&lt;/code&gt; 처음 호출하기 전에 모든 구성 매개 변수를 설정해야합니다 . 이 방법들은 모두 초기 핸드 셰이크를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="82c50a07c3818bd2118910613159095eba3080b8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;SSLEngineResult&lt;/code&gt; enum describing the current handshaking state of this &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SSLEngineResult&lt;/code&gt; 의의 이러한 현재의 상태의 핸드 쉐이크 기술 ENUM &lt;code&gt;SSLEngine&lt;/code&gt; 의이 .</target>
        </trans-unit>
        <trans-unit id="2306dcc0e2cc49d8f2ac4ca584af3de2c2e5f9d5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;SSLEngineResult&lt;/code&gt; enum describing the overall result of the &lt;code&gt;SSLEngine&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 오퍼레이션 의 전체 결과를 설명 하는 &lt;code&gt;SSLEngineResult&lt;/code&gt; 열거 입니다.</target>
        </trans-unit>
        <trans-unit id="e4dff761f32721963abd9bcae6634e956ea992e9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;SSLEngineResult&lt;/code&gt; enum describing the overall result of the &lt;code&gt;SSLEngine&lt;/code&gt; operation. The &lt;code&gt;Status&lt;/code&gt; value does not reflect the state of a &lt;code&gt;SSLEngine&lt;/code&gt; handshake currently in progress. The &lt;code&gt;SSLEngineResult's HandshakeStatus&lt;/code&gt; should be consulted for that information.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 오퍼레이션 의 전체 결과를 설명 하는 &lt;code&gt;SSLEngineResult&lt;/code&gt; 열거 입니다. &lt;code&gt;Status&lt;/code&gt; 값은의 상태를 반영하지 않습니다 &lt;code&gt;SSLEngine&lt;/code&gt; 현재 진행 악수. &lt;code&gt;SSLEngineResult's HandshakeStatus&lt;/code&gt; 그 정보를 참고해야한다.</target>
        </trans-unit>
        <trans-unit id="c840d2ce838d86301f730e068fe5a907fa565e45" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; instance contains the undeclared checked exception that was thrown by the invocation handler, and it can be retrieved with the &lt;code&gt;getUndeclaredThrowable()&lt;/code&gt; method. &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; extends &lt;code&gt;RuntimeException&lt;/code&gt;, so it is an unchecked exception that wraps a checked exception.</source>
          <target state="translated">&lt;code&gt;UndeclaredThrowableException&lt;/code&gt; 인스턴스를 호출 핸들러에 의해 발생 된 미표시 체크 예외를 포함하며, 그것은 함께 취득 할 수 &lt;code&gt;getUndeclaredThrowable()&lt;/code&gt; 메소드. &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; 은 &lt;code&gt;RuntimeException&lt;/code&gt; 을 확장 하므로, 체크 된 예외를 랩핑하는 것은 체크되지 않은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="6404023c449522aae0f08ba59857829ecabae11d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;UnsupportedAudioFileException&lt;/code&gt; is an exception indicating that an operation failed because a file did not contain valid data of a recognized file type and format.</source>
          <target state="translated">&lt;code&gt;UnsupportedAudioFileException&lt;/code&gt; 이 파일은 인식 된 파일 타입과 파일 형식의 유효 데이터를 포함하지 않기 위해 (때문에) 조작이 실패한 것을 나타내는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="390ae6ca2cb5769a01bc5b7bd96b2378a316e1c7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; array in which elements may be updated atomically.</source>
          <target state="translated">원소를 원자 적으로 갱신 할 수 있는 &lt;code&gt;int&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="636bcbd0bd917297b196446fb49964dcd0694f31" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; array in which elements may be updated atomically. See the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; package specification for description of the properties of atomic variables.</source>
          <target state="translated">원소를 원자 적으로 갱신 할 수 있는 &lt;code&gt;int&lt;/code&gt; 배열입니다. 원자 변수의 특성에 대한 설명은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; &lt;/a&gt; 패키지 스펙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d2464e93b57920d8573d0d5b1da7fc0b3d251d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; representing the three digit HTTP Status-Code.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 3 자리수의 HTTP 상태 코드를 나타내는.</target>
        </trans-unit>
        <trans-unit id="aabdf49c04659510a730bc939a7453b5036f0534" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; value that may be updated atomically.</source>
          <target state="translated">원자 적으로 업데이트 될 수 있는 &lt;code&gt;int&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="087667c3a645e4575ee0735435442c3f21954505" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; value that may be updated atomically. See the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; package specification for description of the properties of atomic variables. An &lt;code&gt;AtomicInteger&lt;/code&gt; is used in applications such as atomically incremented counters, and cannot be used as a replacement for an &lt;a href=&quot;../../../lang/integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. However, this class does extend &lt;code&gt;Number&lt;/code&gt; to allow uniform access by tools and utilities that deal with numerically-based classes.</source>
          <target state="translated">원자 적으로 업데이트 될 수 있는 &lt;code&gt;int&lt;/code&gt; 값입니다. 원자 변수의 특성에 대한 설명은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; &lt;/a&gt; 패키지 스펙을 참조하십시오 . &lt;code&gt;AtomicInteger&lt;/code&gt; 는 같은 원자 적 증분 카운터와 같은 용도에 사용되며, 그리고 대체로서 사용할 수없는 &lt;a href=&quot;../../../lang/integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; . 그러나이 클래스는 숫자 기반 클래스를 처리하는 도구 및 유틸리티로 균일하게 액세스 할 수 있도록 &lt;code&gt;Number&lt;/code&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="b9fd26bb801718669246b4dc6aedd1d012db6c0d" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;MXBean&lt;/em&gt; is a variant of Standard MBean where complex types are mapped to a standard set of types defined in the &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt; package. MXBeans are appropriate if you would otherwise need to reference application-specific classes in your MBean interface. They are described in detail in the specification for &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;의 MXBean는&lt;/em&gt; 복합 유형이 정의 유형의 표준 집합에 매핑되는 표준의 MBean의 변형입니다 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; 의&lt;/a&gt; 패키지로 제공된다. MBean 인터페이스에서 애플리케이션 특정 클래스를 참조해야하는 경우 MXBean이 적합합니다. 이것들은 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 사양에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="17089ce6d5594e4e7f2e90276d5c9c7249c48e95" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Open MBean&lt;/em&gt; is a kind of Dynamic MBean where the types of attributes and of operation parameters and return values are built using a small set of predefined Java classes. Open MBeans facilitate operation with remote management programs that do not necessarily have access to application-specific types, including non-Java programs. Open MBeans are defined by the package &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;
        javax.management.openmbean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;열기 MBean는,&lt;/em&gt; 속성과 작동 매개 변수 및 반환 값의 유형은 미리 정의 된 자바 클래스를 사용해 구축되는 동적 MBean에의 일종이다. Open MBean은 Java 이외의 프로그램을 포함하여 응용 프로그램 특정 유형에 액세스 할 필요가없는 원격 관리 프로그램으로 조작을 용이하게합니다. 공개 MBean은 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt; javax.management.openmbean&lt;/code&gt; &lt;/a&gt; 패키지에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="048ed8c4104dbbe06b2cff23468329c5ad2ceb71" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;offset&lt;/em&gt; value can be specified. When an observed value exceeds its threshold, the threshold is incremented by the offset, or by a multiple of the offset sufficient to make the threshold greater than the new observed value.</source>
          <target state="translated">&lt;em&gt;오프셋&lt;/em&gt; 값이 지정 될 수있다. 관찰 된 값이 임계 값을 초과하면, 임계 값은 오프셋에 의해 또는 임계 값을 새로운 관찰 된 값보다 크게 만들기에 충분한 오프셋의 배수만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7fcd831e0b42745d917f0bdce05841f7695e04d6" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;unquoted value&lt;/em&gt; is a possibly empty string of characters which may not contain any of the characters comma, equals, colon, or quote.</source>
          <target state="translated">&lt;em&gt;인용 부호로 둘러싸이지 않은 값은&lt;/em&gt; 문자의 쉼표, 등호, 구두점, 인용 부호를 포함 할 수 없습니다 공 문자열의 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2684422286ab1507de4a61572052b079877180b" translate="yes" xml:space="preserve">
          <source>An ACL can be thought of as a data structure with multiple ACL entries. Each ACL entry, of interface type AclEntry, contains a set of permissions associated with a particular principal. (A principal represents an entity such as an individual user or a group). Additionally, each ACL entry is specified as being either positive or negative. If positive, the permissions are to be granted to the associated principal. If negative, the permissions are to be denied.</source>
          <target state="translated">ACL은 여러 개의 ACL 항목이있는 데이터 구조로 생각할 수 있습니다. AclEntry 인터페이스 유형의 각 ACL 항목에는 특정 프린시 펄과 연관된 권한 세트가 있습니다. (주체는 개별 사용자 또는 그룹과 같은 엔티티를 나타냅니다). 또한 각 ACL 항목은 양수 또는 음수로 지정됩니다. 긍정적 인 경우 권한이 연결된 보안 주체에게 부여됩니다. 부정 인 경우 권한이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="c70bcd23d632cd866fc4b69e2bbb462334dd40db" translate="yes" xml:space="preserve">
          <source>An ACL can be thought of as a data structure with multiple ACL entry objects. Each ACL entry object contains a set of permissions associated with a particular principal. (A principal represents an entity such as an individual user or a group). Additionally, each ACL entry is specified as being either positive or negative. If positive, the permissions are to be granted to the associated principal. If negative, the permissions are to be denied. Each principal can have at most one positive ACL entry and one negative entry; that is, multiple positive or negative ACL entries are not allowed for any principal. Note: ACL entries are by default positive. An entry becomes a negative entry only if the &lt;a href=&quot;aclentry#setNegativePermissions--&quot;&gt;&lt;code&gt;setNegativePermissions&lt;/code&gt;&lt;/a&gt; method is called on it.</source>
          <target state="translated">ACL은 여러 ACL 항목 오브젝트가있는 데이터 구조로 생각할 수 있습니다. 각 ACL 항목 오브젝트에는 특정 프린시 펄과 연관된 권한 세트가 있습니다. (주체는 개별 사용자 또는 그룹과 같은 엔티티를 나타냅니다). 또한 각 ACL 항목은 양수 또는 음수로 지정됩니다. 긍정적 인 경우 권한이 연결된 보안 주체에게 부여됩니다. 부정 인 경우 권한이 거부됩니다. 각 주체는 최대 하나의 긍정적 ACL 항목과 하나의 부정적인 항목을 가질 수 있습니다. 즉, 여러 주체에 여러 개의 양수 또는 음수 ACL 항목이 허용되지 않습니다. 참고 : ACL 항목은 기본적으로 양수입니다. &lt;a href=&quot;aclentry#setNegativePermissions--&quot;&gt; &lt;code&gt;setNegativePermissions&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 경우에만 항목이 음수 항목이됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2034ee9043e4468b2456b2b01be34999ea728cc" translate="yes" xml:space="preserve">
          <source>An AccessControlContext is created by calling the &lt;code&gt;AccessController.getContext&lt;/code&gt; method. The &lt;code&gt;getContext&lt;/code&gt; method takes a &quot;snapshot&quot; of the current calling context, and places it in an AccessControlContext object, which it returns. A sample call is the following:</source>
          <target state="translated">AccessControlContext는 &lt;code&gt;AccessController.getContext&lt;/code&gt; 메소드 를 호출하여 작성됩니다 . &lt;code&gt;getContext&lt;/code&gt; 메소드는, 현재의 호출 측 문맥의 「snapshot」를 취득 해,이 메소드가 돌려주는 AccessControlContext 오브젝트에 배치합니다. 샘플 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0ed6e045b2bb8038ede83e1403ef7b9a77879fa" translate="yes" xml:space="preserve">
          <source>An AccessControlContext is used to make system resource access decisions based on the context it encapsulates.</source>
          <target state="translated">AccessControlContext는 캡슐화 된 컨텍스트에 따라 시스템 자원 액세스 결정을 내리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95ea4cab64e636e81805f6e15cc09616f24433e1" translate="yes" xml:space="preserve">
          <source>An Algorithm</source>
          <target state="translated">알고리즘</target>
        </trans-unit>
        <trans-unit id="3e0d7dcf02ff5c3599b845d4f36804d0afc95643" translate="yes" xml:space="preserve">
          <source>An Annotation object is used as a wrapper for a text attribute value if the attribute has annotation characteristics.</source>
          <target state="translated">속성에 주석 특성이있는 경우 Annotation 객체는 텍스트 속성 값의 래퍼로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8855173cc3a9b8d3578e593ef7aaec03c1b426ce" translate="yes" xml:space="preserve">
          <source>An Annotation object is used as a wrapper for a text attribute value if the attribute has annotation characteristics. These characteristics are:</source>
          <target state="translated">속성에 주석 특성이있는 경우 Annotation 객체는 텍스트 속성 값의 래퍼로 사용됩니다. 이러한 특성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38349826443eb5f8b0f145776d6f978e86cac2a5" translate="yes" xml:space="preserve">
          <source>An AttributeModificationException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single AttributeModification instance should lock the object.</source>
          <target state="translated">AttributeModificationException 인스턴스는 동시 다중 스레드 액세스에 대해 동기화되지 않습니다. 단일 AttributeModification 인스턴스에 액세스하고 수정하려는 여러 스레드가 객체를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="b893c9940906556691c2bd941e04be07a66daa05" translate="yes" xml:space="preserve">
          <source>An AttributedString holds text and related attribute information.</source>
          <target state="translated">AttributedString은 텍스트 및 관련 속성 정보를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="bd982501c3c8980f823cdb2bbda7d1230a226b5c" translate="yes" xml:space="preserve">
          <source>An AttributedString holds text and related attribute information. It may be used as the actual data storage in some cases where a text reader wants to access attributed text through the AttributedCharacterIterator interface.</source>
          <target state="translated">AttributedString은 텍스트 및 관련 속성 정보를 보유합니다. 텍스트 리더가 AttributedCharacterIterator 인터페이스를 통해 속성이 지정된 텍스트에 액세스하려는 경우 실제 데이터 저장소로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75aa6cb85fd1dfb867d563d4ef0e8288a7199311" translate="yes" xml:space="preserve">
          <source>An Encoded Form</source>
          <target state="translated">인코딩 된 양식</target>
        </trans-unit>
        <trans-unit id="3bd1b3dcfb3ea555af204a39d90125f75979b9ce" translate="yes" xml:space="preserve">
          <source>An Entry maintaining a key and a value.</source>
          <target state="translated">키와 값을 유지하는 엔트리.</target>
        </trans-unit>
        <trans-unit id="da0746701e8e7695e38c701dca1f984542e011fe" translate="yes" xml:space="preserve">
          <source>An Entry maintaining a key and a value. The value may be changed using the &lt;code&gt;setValue&lt;/code&gt; method. This class facilitates the process of building custom map implementations. For example, it may be convenient to return arrays of &lt;code&gt;SimpleEntry&lt;/code&gt; instances in method &lt;code&gt;Map.entrySet().toArray&lt;/code&gt;.</source>
          <target state="translated">키와 값을 유지하는 엔트리. &lt;code&gt;setValue&lt;/code&gt; 메소드를 사용하여 값을 변경할 수 있습니다 . 이 클래스는 사용자 정의 맵 구현을 빌드하는 프로세스를 용이하게합니다. 예를 들어, &lt;code&gt;SimpleEntry&lt;/code&gt; &lt;code&gt;Map.entrySet().toArray&lt;/code&gt; 메소드에서 SimpleEntry 인스턴스의 배열을 리턴하는 것이 편리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="cacdd53a5669de32a448c704a7d46a63b3a404a9" translate="yes" xml:space="preserve">
          <source>An Entry maintaining an immutable key and value.</source>
          <target state="translated">불변의 키와 값을 유지하는 엔트리.</target>
        </trans-unit>
        <trans-unit id="b46e141a48aa50e234a4e444b9b9b2d5f4ee7a2b" translate="yes" xml:space="preserve">
          <source>An Entry maintaining an immutable key and value. This class does not support method &lt;code&gt;setValue&lt;/code&gt;. This class may be convenient in methods that return thread-safe snapshots of key-value mappings.</source>
          <target state="translated">불변의 키와 값을 유지하는 엔트리. 이 클래스는 &lt;code&gt;setValue&lt;/code&gt; 메소드를 지원하지 않습니다 . 이 클래스는 키-값 매핑의 스레드 안전 스냅 샷을 반환하는 메서드에서 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b27a7be77a8eef346badd76c7e236adbb1f25e" translate="yes" xml:space="preserve">
          <source>An EventSetDescriptor describes a group of events that a given Java bean fires.</source>
          <target state="translated">EventSetDescriptor는 지정된 Java Bean이 실행하는 이벤트 그룹을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="50fd111412d51c66c26ec4a0d0302236610f9a26" translate="yes" xml:space="preserve">
          <source>An Exception thrown by the managed object's getter.</source>
          <target state="translated">관리 대상 객체의 getter에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="be7265a58cd913772cac4b10648d630189d7eaf4" translate="yes" xml:space="preserve">
          <source>An Exception thrown by the managed object's invoked method.</source>
          <target state="translated">관리 객체의 호출 된 메소드에 의해 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c06f5736113d71e86a9d07725f11650d914367b3" translate="yes" xml:space="preserve">
          <source>An Exception thrown by the managed object's setter.</source>
          <target state="translated">관리 객체의 setter에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="ef31b04ee6f5f3ee3b1f97fa7b222fc1b3f61e4c" translate="yes" xml:space="preserve">
          <source>An ExceptionListener is notified of internal exceptions.</source>
          <target state="translated">ExceptionListener에 내부 예외가 통지됩니다.</target>
        </trans-unit>
        <trans-unit id="9e34e0a0992ba82837e6b5076d6ac0f44ba2c3a6" translate="yes" xml:space="preserve">
          <source>An Externalizable instance can designate a substitution object via the writeReplace and readResolve methods documented in the Serializable interface.</source>
          <target state="translated">Externalizable 인스턴스는 Serializable 인터페이스에 문서화 된 writeReplace 및 readResolve 메소드를 통해 대체 객체를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc99a7418140f7781457ca1e35c0aacf327c98c" translate="yes" xml:space="preserve">
          <source>An HttpCookie object represents an HTTP cookie, which carries state information between server and user agent.</source>
          <target state="translated">HttpCookie 객체는 서버와 사용자 에이전트간에 상태 정보를 전달하는 HTTP 쿠키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b91adcfa4da1bf69d335cb8f7dcb94f924bead5" translate="yes" xml:space="preserve">
          <source>An HttpCookie object represents an HTTP cookie, which carries state information between server and user agent. Cookie is widely adopted to create stateful sessions.</source>
          <target state="translated">HttpCookie 객체는 서버와 사용자 에이전트간에 상태 정보를 전달하는 HTTP 쿠키를 나타냅니다. 쿠키는 상태 저장 세션을 생성하기 위해 널리 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="57df2712baa86b0ab625ab0d92b75f132380f39f" translate="yes" xml:space="preserve">
          <source>An I/O error occurs, in which case an &lt;code&gt;IOException&lt;/code&gt; other than &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">I / O 오류가 발생 &lt;code&gt;EOFException&lt;/code&gt; 경우 EOFException 이외 의 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa105b5669c20a7b719a79ac399c1fa631849b9f" translate="yes" xml:space="preserve">
          <source>An IP address is either a 32-bit or 128-bit unsigned number used by IP, a lower-level protocol on which protocols like UDP and TCP are built. The IP address architecture is defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC 790: Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC 1918: Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC 2365: Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC 2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an InetAddress consists of an IP address and possibly its corresponding host name (depending on whether it is constructed with a host name or whether it has already done reverse host name resolution).</source>
          <target state="translated">IP 주소는 UDP 및 TCP와 같은 프로토콜이 구축되는 하위 수준 프로토콜 인 IP에서 사용하는 32 비트 또는 128 비트 부호없는 숫자입니다. IP 주소 아키텍처는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC 790 : 할당 번호&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt;&lt;i&gt;RFC 1918 : 개인 인터넷 주소 할당&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC 2365 : 관리 범위 IP 멀티 캐스트&lt;/i&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC 2373 : IP 버전 6 주소 지정 아키텍처에 의해 정의&lt;/i&gt;&lt;/a&gt; 됩니다. InetAddress의 인스턴스는 IP 주소와 해당 호스트 이름으로 구성됩니다 (호스트 이름으로 구성되었는지 또는 이미 호스트 이름 확인을 수행했는지 여부에 따라 다름). &lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="bcc7a50164ddb8884b98546a09bcb306082cb3fd" translate="yes" xml:space="preserve">
          <source>An IPv6 address enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) and consisting of hexadecimal digits, colon characters (&lt;code&gt;':'&lt;/code&gt;), and possibly an embedded IPv4 address. The full syntax of IPv6 addresses is specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC 2373: IPv6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">대괄호 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; )로 묶고 16 진수, 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; ) 및 포함 된 IPv4 주소로 구성되는 IPv6 주소입니다. IPv6 주소의 전체 구문은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC 2373 : IPv6 주소 지정 아키텍처에 지정되어&lt;/i&gt;&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b6ba7e753778b09202deb8cb3a76118d505043" translate="yes" xml:space="preserve">
          <source>An Identity also has a set of certificates (all certifying its own public key). The Principal names specified in these certificates need not be the same, only the key.</source>
          <target state="translated">또한 Identity에는 일련의 인증서 (모두 자체 공개 키를 인증하는 인증서)가 있습니다. 이 인증서에 지정된 프린시 펄 이름은 동일 할 필요는 없으며 키만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="08138760222bab8a65c785edb15ef4a27c00cb10" translate="yes" xml:space="preserve">
          <source>An Identity can be subclassed, to include postal and email addresses, telephone numbers, images of faces and logos, and so on.</source>
          <target state="translated">우편 및 이메일 주소, 전화 번호, 얼굴 및 로고 이미지 등을 포함하도록 Identity를 서브 클래 싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0e5eeb9681d299c2d79d8577fe365b2ad2c529" translate="yes" xml:space="preserve">
          <source>An IdentityScope can contain Identity objects of all kinds, including Signers. All types of Identity objects can be retrieved, added, and removed using the same methods. Note that it is possible, and in fact expected, that different types of identity scopes will apply different policies for their various operations on the various types of Identities.</source>
          <target state="translated">IdentityScope는 서명자를 포함하여 모든 종류의 Identity 객체를 포함 할 수 있습니다. 동일한 방법을 사용하여 모든 유형의 Identity 객체를 검색, 추가 및 제거 할 수 있습니다. 다른 유형의 ID 범위는 다양한 유형의 ID에 대한 다양한 작업에 대해 서로 다른 정책을 적용 할 수 있으며 실제로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="da188ebd0e395b9cc3eb14df8852e78d9a226473" translate="yes" xml:space="preserve">
          <source>An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.</source>
          <target state="translated">응용 프로그램이 배열 이외의 인스턴스를 반사적으로 만들거나, 필드를 설정 또는 가져 오거나, 메소드를 호출하려고하지만 현재 실행중인 메소드가 지정된 클래스, 필드의 정의에 액세스 할 수없는 경우 IllegalAccessException이 발생합니다. 메소드 또는 생성자.</target>
        </trans-unit>
        <trans-unit id="970e227ba2f568e1aa11350a1043420cee0a541d" translate="yes" xml:space="preserve">
          <source>An IndexedPropertyDescriptor describes a property that acts like an array and has an indexed read and/or indexed write method to access specific elements of the array.</source>
          <target state="translated">IndexedPropertyDescriptor는 배열처럼 작동하고 배열의 특정 요소에 액세스하기 위해 색인화 된 읽기 및 / 또는 색인화 된 쓰기 메소드를 갖는 특성을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b175f82551ee9920e38dde5cadd2fbee393dc94a" translate="yes" xml:space="preserve">
          <source>An InitialContext instance is not synchronized against concurrent access by multiple threads. Multiple threads each manipulating a different InitialContext instance need not synchronize. Threads that need to access a single InitialContext instance concurrently should synchronize amongst themselves and provide the necessary locking.</source>
          <target state="translated">InitialContext 인스턴스는 여러 스레드의 동시 액세스와 동기화되지 않습니다. 각각 다른 InitialContext 인스턴스를 조작하는 여러 스레드는 동기화 할 필요가 없습니다. 단일 InitialContext 인스턴스에 동시에 액세스해야하는 스레드는 서로 동기화하고 필요한 잠금을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="aba9d7808ff6c87be02cfaaa0fe0a751d60ec901" translate="yes" xml:space="preserve">
          <source>An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">InputStreamReader는 바이트 스트림에서 문자 스트림으로의 브릿지입니다 . 지정된 &lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 바이트를 읽고 문자로 디코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="b25c4c44637dd88f8ef581bd6ecb3f8880d4c2b5" translate="yes" xml:space="preserve">
          <source>An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;. The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.</source>
          <target state="translated">InputStreamReader는 바이트 스트림에서 문자 스트림으로의 브릿지입니다 . 지정된 &lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 바이트를 읽고 문자로 디코딩합니다 . 사용하는 문자 세트는 이름으로 지정되거나 명시 적으로 지정되거나 플랫폼의 기본 문자 세트가 승인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3680dbb15da07882a3b83576060c6ac4cc0fc961" translate="yes" xml:space="preserve">
          <source>An InvalidKeyException with a detail message.</source>
          <target state="translated">세부 메시지가있는 InvalidKeyException입니다.</target>
        </trans-unit>
        <trans-unit id="dc59b05409684c3be739fbe664b962af3d646193" translate="yes" xml:space="preserve">
          <source>An InvalidKeyException with no detail message.</source>
          <target state="translated">세부 메시지가없는 InvalidKeyException</target>
        </trans-unit>
        <trans-unit id="f82726191af9e4037f87325b6ef69bc023b200b4" translate="yes" xml:space="preserve">
          <source>An InvalidOpenTypeException with a detail message.</source>
          <target state="translated">세부 메시지가있는 InvalidOpenTypeException입니다.</target>
        </trans-unit>
        <trans-unit id="a337087b8fc07fcd230bf927b149b6cfbe5dcedc" translate="yes" xml:space="preserve">
          <source>An InvalidOpenTypeException with no detail message.</source>
          <target state="translated">세부 메시지가없는 InvalidOpenTypeException입니다.</target>
        </trans-unit>
        <trans-unit id="70a4c3fb116f4cb8fa098f1b416850a522db26c4" translate="yes" xml:space="preserve">
          <source>An Iterator specialized for &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값에 특화된 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="155a282951704944e9cb6e10bac0867700c1d539" translate="yes" xml:space="preserve">
          <source>An Iterator specialized for &lt;code&gt;int&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값에 특화된 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="3bd0758c0ccd2df72b37d50b6c0c974cfde9e265" translate="yes" xml:space="preserve">
          <source>An Iterator specialized for &lt;code&gt;long&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 값에 특화된 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="a53095780f8e1614597cbcccccf5b9f62cf1ff4b" translate="yes" xml:space="preserve">
          <source>An LDAP server can send back response controls with an LDAP operation and also with enumeration results, such as those returned by a list or search operation. The &lt;code&gt;LdapContext&lt;/code&gt; provides a method (&lt;code&gt;getResponseControls()&lt;/code&gt;) for getting the response controls sent with an LDAP operation, while the &lt;code&gt;HasControls&lt;/code&gt; interface is used to retrieve response controls associated with enumeration results.</source>
          <target state="translated">LDAP 서버는 LDAP 조작 및 목록 또는 검색 조작에 의해 리턴 된 것과 같은 열거 결과와 함께 응답 제어를 다시 보낼 수 있습니다. &lt;code&gt;LdapContext&lt;/code&gt; 방법 (제공 &lt;code&gt;getResponseControls()&lt;/code&gt; 그동안, LDAP 조작과 함께 송신 된 응답 제어를 얻기위한) &lt;code&gt;HasControls&lt;/code&gt; 의 용 인터페이스가 열거 결과와 연관된 응답 컨트롤을 검색하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="ab4cc3bdb94a28c189afa2d189dc64d5e1a90c82" translate="yes" xml:space="preserve">
          <source>An LDAP service provider for &lt;code&gt;ctx&lt;/code&gt; uses a &lt;code&gt;DirStateFactory&lt;/code&gt; (indirectly via &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;) and gives it &lt;code&gt;printer&lt;/code&gt; and &lt;code&gt;printerAttrs&lt;/code&gt;. A factory for an LDAP directory might turn &lt;code&gt;printer&lt;/code&gt; into a set of attributes and merge that with &lt;code&gt;printerAttrs&lt;/code&gt;. The service provider then uses the resulting attributes to create an LDAP entry and updates the directory.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 용 LDAP 서비스 제공자 는 &lt;code&gt;DirStateFactory&lt;/code&gt; ( &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; 를 통해 간접적으로 )를 사용하여 &lt;code&gt;printer&lt;/code&gt; 및 &lt;code&gt;printerAttrs&lt;/code&gt; 를 제공합니다 . LDAP 디렉토리의 팩토리는 &lt;code&gt;printer&lt;/code&gt; 를 속성 세트로 &lt;code&gt;printerAttrs&lt;/code&gt; 와 병합 할 수 있습니다 . 그런 다음 서비스 제공자는 결과 속성을 사용하여 LDAP 항목을 작성하고 디렉토리를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="2c6f45db03da3155b831ee0314e342a09c916793" translate="yes" xml:space="preserve">
          <source>An MBean Server can be accessed remotely through a &lt;em&gt;connector&lt;/em&gt;. A connector allows a remote Java application to access an MBean Server in essentially the same way as a local one. The package &lt;a href=&quot;remote/package-summary&quot;&gt;&lt;code&gt;
        javax.management.remote&lt;/code&gt;&lt;/a&gt; defines connectors.</source>
          <target state="translated">MBean 서버는 &lt;em&gt;커넥터를&lt;/em&gt; 통해 원격으로 액세스 할 수 있습니다 . 커넥터를 사용하면 원격 Java 응용 프로그램이 기본적으로 로컬 MBean 서버와 동일한 방식으로 MBean 서버에 액세스 할 수 있습니다. &lt;a href=&quot;remote/package-summary&quot;&gt; &lt;code&gt; javax.management.remote&lt;/code&gt; &lt;/a&gt; 패키지 는 커넥터를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="97948eb279240b610b0044cd0566e39e0defdcce" translate="yes" xml:space="preserve">
          <source>An MBean Server can be queried for MBeans whose names match certain patterns and/or whose attributes meet certain constraints. Name patterns are constructed using the &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt; class and constraints are constructed using the &lt;a href=&quot;query&quot;&gt;&lt;code&gt;Query&lt;/code&gt;&lt;/a&gt; class. The methods &lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; then perform the query.</source>
          <target state="translated">이름이 특정 패턴과 일치하거나 속성이 특정 제한 조건을 충족하는 MBean에 대해 MBean 서버를 조회 할 수 있습니다. 이름 패턴은 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 구성되며 제약 조건은 &lt;a href=&quot;query&quot;&gt; &lt;code&gt;Query&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 구성됩니다 . 그런 다음 &lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt; 메소드 가 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="686212de06bf8398834d07ba97c35c4a1aa8d411" translate="yes" xml:space="preserve">
          <source>An MBean Server is an object implementing the interface &lt;a href=&quot;mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;. The most convenient MBean Server to use is the &lt;em&gt;Platform MBean Server&lt;/em&gt;. This is a single MBean Server that can be shared by different managed components running within the same Java Virtual Machine. The Platform MBean Server is accessed with the method &lt;a href=&quot;../../java/lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">MBean 서버는 &lt;a href=&quot;mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체 입니다. 가장 편리한 MBean 서버는 &lt;em&gt;Platform MBean Server&lt;/em&gt; 입니다. 이것은 동일한 Java Virtual Machine 내에서 실행되는 다른 관리 대상 구성 요소가 공유 할 수있는 단일 MBean 서버입니다. 플랫폼 MBean 서버는 &lt;a href=&quot;../../java/lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMBeanServer()&lt;/code&gt; &lt;/a&gt; 메소드로 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="6196712ecd6d41a40d55269bd3af371c1720992a" translate="yes" xml:space="preserve">
          <source>An MBean can be a listener for notifications emitted by other MBeans in the same MBean Server. In this case, it implements &lt;a href=&quot;notificationlistener&quot;&gt;&lt;code&gt;NotificationListener&lt;/code&gt;&lt;/a&gt; and the method &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.ObjectName-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;MBeanServer.addNotificationListener(ObjectName,
        ObjectName, NotificationFilter, Object)&lt;/code&gt;&lt;/a&gt; is used to listen.</source>
          <target state="translated">MBean은 같은 MBean 서버의 다른 MBean이 발행 한 알림의 리스너 일 수 있습니다. 이 경우 &lt;a href=&quot;notificationlistener&quot;&gt; &lt;code&gt;NotificationListener&lt;/code&gt; 를&lt;/a&gt; 구현 하고 &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.ObjectName-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;MBeanServer.addNotificationListener(ObjectName, ObjectName, NotificationFilter, Object)&lt;/code&gt; &lt;/a&gt; 를 사용하여 청취합니다.</target>
        </trans-unit>
        <trans-unit id="7a30bf77c8a83531fd79d0d4269b1cd85e0ea8db" translate="yes" xml:space="preserve">
          <source>An MBean can implement the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface in order to be told when it is registered and unregistered in the MBean Server. Additionally, the &lt;a href=&quot;mbeanregistration#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt;&lt;code&gt;preRegister&lt;/code&gt;&lt;/a&gt; method allows the MBean to get a reference to the &lt;code&gt;MBeanServer&lt;/code&gt; object and to get its &lt;code&gt;ObjectName&lt;/code&gt; within the MBean Server.</source>
          <target state="translated">MBean은 &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현 하여 MBean Server에 등록 및 등록 해제 될 때 알려줍니다. 또한 &lt;a href=&quot;mbeanregistration#preRegister-javax.management.MBeanServer-javax.management.ObjectName-&quot;&gt; &lt;code&gt;preRegister&lt;/code&gt; &lt;/a&gt; 메소드를 사용하면 MBean이 &lt;code&gt;MBeanServer&lt;/code&gt; 오브젝트에 대한 참조 를 얻고 MBean Server 내에서 &lt;code&gt;ObjectName&lt;/code&gt; 을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e251f67958e23d80ebda42f966d473cba5ea4c1" translate="yes" xml:space="preserve">
          <source>An MBean can perform actions when it is registered in or unregistered from an MBean Server if it implements the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">MBean이 &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우 MBean이 MBean 서버에 등록되거나 등록 해제 될 때 조치를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6e0a47e65f611ffbcc9eebd78bf36dec9777da3" translate="yes" xml:space="preserve">
          <source>An MBean that is of a subclass of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; can be used as a class loader to create other MBeans via the method &lt;a href=&quot;../mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;MBeanServer.createMBean(String, ObjectName,
	ObjectName, Object[], String[])&lt;/code&gt;&lt;/a&gt;, and to instantiate arbitrary objects via the method &lt;a href=&quot;../mbeanserver#instantiate-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt;&lt;code&gt;MBeanServer.instantiate(String, ObjectName,
	Object[], String[])&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;mlet&quot;&gt;&lt;code&gt;MLet&lt;/code&gt;&lt;/a&gt; class is an example of such an MBean. It is a &lt;a href=&quot;../../../java/net/urlclassloader&quot;&gt;&lt;code&gt;URLClassLoader&lt;/code&gt;&lt;/a&gt;, so the list of URLs to load classes from can be configured.</source>
          <target state="translated">&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 인 MBean을 클래스 로더로 사용하여 &lt;a href=&quot;../mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;MBeanServer.createMBean(String, ObjectName, ObjectName, Object[], String[])&lt;/code&gt; &lt;/a&gt; 메소드를 통해 다른 MBean을 작성하고 메소드 를 통해 임의의 오브젝트를 인스턴스화 할 수 있습니다. &lt;a href=&quot;../mbeanserver#instantiate-java.lang.String-javax.management.ObjectName-java.lang.Object:A-java.lang.String:A-&quot;&gt; &lt;code&gt;MBeanServer.instantiate(String, ObjectName, Object[], String[])&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;mlet&quot;&gt; &lt;code&gt;MLet&lt;/code&gt; &lt;/a&gt; 클래스는 MBean의 예이다. 그것은이다 &lt;a href=&quot;../../../java/net/urlclassloader&quot;&gt; &lt;code&gt;URLClassLoader&lt;/code&gt; 를&lt;/a&gt; 구성 할 수 있습니다에서 URL 목록이 클래스를로드 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="5ee8e60221fd233794c0a1cdcaf474e9f2e09cf3" translate="yes" xml:space="preserve">
          <source>An MBean that will emit notifications must implement the &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; interface. Usually, it does this by subclassing &lt;a href=&quot;notificationbroadcastersupport&quot;&gt;&lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt;&lt;/a&gt; or delegating to an instance of that class. Here is an example:</source>
          <target state="translated">통지를 발행 할 MBean은 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야합니다 . 일반적으로 &lt;a href=&quot;notificationbroadcastersupport&quot;&gt; &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱 하거나 해당 클래스의 인스턴스에 위임하여이를 수행합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d64b80f2eca1400e06525e015fb932555cdb8a8" translate="yes" xml:space="preserve">
          <source>An MBean which is not an &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt; may also emit MBeanServerNotifications. In particular, there is a convention for MBeans to emit an MBeanServerNotification for a group of MBeans.</source>
          <target state="translated">&lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; &lt;/a&gt; 가 아닌 MBean 도 MBeanServerNotifications를 생성 할 수 있습니다. 특히, MBean이 MBean 그룹에 대해 MBeanServerNotification을 생성하는 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95cea1a9029d95f515561a7a036eb04c03f3026b" translate="yes" xml:space="preserve">
          <source>An MBean whose management interface is determined by reflection on a Java interface, and that emits notifications.</source>
          <target state="translated">관리 인터페이스가 Java 인터페이스에 반영되어 결정되고 알림을 생성하는 MBean입니다.</target>
        </trans-unit>
        <trans-unit id="5a5b10fc82b6cd0e3aab40067c0af3302ae2944f" translate="yes" xml:space="preserve">
          <source>An MBean whose management interface is determined by reflection on a Java interface.</source>
          <target state="translated">관리 인터페이스가 Java 인터페이스에 반영되어 결정되는 MBean입니다.</target>
        </trans-unit>
        <trans-unit id="2a16665e14800a2674f071859c3ec94d73b109f2" translate="yes" xml:space="preserve">
          <source>An MBeanPermission contains four items of information:</source>
          <target state="translated">MBeanPermission에는 다음과 같은 네 가지 정보 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="39f9f8437c0998051c143f718f292156eeeaccfe" translate="yes" xml:space="preserve">
          <source>An MBeanServerNotification emitted to denote the registration or unregistration of a group of MBeans has the following characteristics:</source>
          <target state="translated">MBean 그룹의 등록 또는 등록 취소를 표시하기 위해 생성 된 MBeanServerNotification은 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba4ca74d70559ec8a55cf7fd17427e673f59ce61" translate="yes" xml:space="preserve">
          <source>An MLet that is not added to the &lt;a href=&quot;classloaderrepository&quot;&gt;&lt;code&gt;ClassLoaderRepository&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 추가되지 않습니다 MLet입니다 &lt;a href=&quot;classloaderrepository&quot;&gt; &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="684d2ceed16d31eafde9cf6a61f566a3a5e3a6ce" translate="yes" xml:space="preserve">
          <source>An MLet that is not added to the &lt;a href=&quot;classloaderrepository&quot;&gt;&lt;code&gt;ClassLoaderRepository&lt;/code&gt;&lt;/a&gt;. This class acts exactly like its parent class, &lt;a href=&quot;mlet&quot;&gt;&lt;code&gt;MLet&lt;/code&gt;&lt;/a&gt;, with one exception. When a PrivateMLet is registered in an MBean server, it is not added to that MBean server's &lt;a href=&quot;classloaderrepository&quot;&gt;&lt;code&gt;ClassLoaderRepository&lt;/code&gt;&lt;/a&gt;. This is true because this class implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 추가되지 않습니다 MLet입니다 &lt;a href=&quot;classloaderrepository&quot;&gt; &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에&lt;/a&gt; . 이 클래스는 하나의 예외를 제외하고 는 상위 클래스 &lt;a href=&quot;mlet&quot;&gt; &lt;code&gt;MLet&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동합니다 . PrivateMLet이 MBean 서버에 등록되면 해당 MBean 서버의 &lt;a href=&quot;classloaderrepository&quot;&gt; &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에&lt;/a&gt; 추가되지 않습니다 . 이것은이 클래스가 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하기 때문에 사실 입니다.</target>
        </trans-unit>
        <trans-unit id="fc13224541b9d8fc1c00fb4c8f5e8f87442494f2" translate="yes" xml:space="preserve">
          <source>An MXBean interface</source>
          <target state="translated">MXBean 인터페이스</target>
        </trans-unit>
        <trans-unit id="989b20991b0fe114ca7ab75b9bf606966fe30205" translate="yes" xml:space="preserve">
          <source>An MXBean interface, or a type referenced within an MXBean interface, can reference another MXBean interface, &lt;em&gt;J&lt;/em&gt;. Then &lt;em&gt;opentype(J)&lt;/em&gt; is &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt; and &lt;em&gt;opendata(J)&lt;/em&gt; is &lt;code&gt;ObjectName&lt;/code&gt;.</source>
          <target state="translated">MXBean 인터페이스 또는 MXBean 인터페이스 내에서 참조되는 유형은 다른 MXBean 인터페이스 &lt;em&gt;J를&lt;/em&gt; 참조 할 수 있습니다 . 그런 다음 &lt;em&gt;opentype (J)&lt;/em&gt; 은 &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt; 이고 &lt;em&gt;opendata (J)&lt;/em&gt; 는 &lt;code&gt;ObjectName&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59f414363b8c1ad567d9d9f3cf7a9c9bc32ebdf7" translate="yes" xml:space="preserve">
          <source>An MXBean is a kind of MBean. An MXBean object can be registered directly in the MBean Server, or it can be used as an argument to &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; and the resultant MBean registered in the MBean Server.</source>
          <target state="translated">MXBean은 일종의 MBean입니다. MXBean 객체는 MBean 서버에 직접 등록하거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; 에&lt;/a&gt; 대한 인수 및 MBean 서버에 등록 된 결과 MBean 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20af0d11e58d9b486064088eb6742a33feb2c915" translate="yes" xml:space="preserve">
          <source>An MXBean is a kind of Open MBean, as defined by the &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt; package. This means that the types of attributes, operation parameters, and operation return values must all be describable using &lt;em&gt;Open Types&lt;/em&gt;, that is the four standard subclasses of &lt;a href=&quot;openmbean/opentype&quot;&gt;&lt;code&gt;OpenType&lt;/code&gt;&lt;/a&gt;. MXBeans achieve this by mapping Java types into Open Types.</source>
          <target state="translated">MXBean은 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; &lt;/a&gt; 패키지에 의해 정의 된 일종의 Open MBean 입니다. 즉, 속성 유형, 작업 매개 변수 및 작업 반환 값은 모두 &lt;em&gt;Open Type을&lt;/em&gt; 사용하여 설명 할 수 있어야합니다 . 즉, &lt;a href=&quot;openmbean/opentype&quot;&gt; &lt;code&gt;OpenType&lt;/code&gt; &lt;/a&gt; 의 네 가지 표준 하위 클래스입니다 . MXBean은 Java 유형을 Open Type으로 맵핑하여이를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="dd34150eb05388627fba70e2eb54039cdac7862c" translate="yes" xml:space="preserve">
          <source>An MXBean is a type of Open MBean. However, for compatibility reasons, its &lt;a href=&quot;mbeaninfo&quot;&gt;&lt;code&gt;MBeanInfo&lt;/code&gt;&lt;/a&gt; is not an &lt;a href=&quot;openmbean/openmbeaninfo&quot;&gt;&lt;code&gt;OpenMBeanInfo&lt;/code&gt;&lt;/a&gt;. In particular, when the type of an attribute, parameter, or operation return value is a primitive type such as &lt;code&gt;int&lt;/code&gt;, or is &lt;code&gt;void&lt;/code&gt; (for a return type), then the attribute, parameter, or operation will be represented respectively by an &lt;a href=&quot;mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mbeanparameterinfo&quot;&gt;&lt;code&gt;MBeanParameterInfo&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;mbeanoperationinfo&quot;&gt;&lt;code&gt;MBeanOperationInfo&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;getType()&lt;/code&gt; or &lt;code&gt;getReturnType()&lt;/code&gt; returns the primitive name (&quot;&lt;code&gt;int&lt;/code&gt;&quot; etc). This is so even though the mapping rules above specify that the &lt;em&gt;opendata&lt;/em&gt; mapping is the wrapped type (&lt;code&gt;Integer&lt;/code&gt; etc).</source>
          <target state="translated">MXBean은 Open MBean 유형입니다. 그러나 호환성을 이유로 &lt;a href=&quot;mbeaninfo&quot;&gt; &lt;code&gt;MBeanInfo&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;openmbean/openmbeaninfo&quot;&gt; &lt;code&gt;OpenMBeanInfo&lt;/code&gt; &lt;/a&gt; 가 아닙니다 . 특히, 속성, 매개 변수 또는 오퍼레이션 리턴 값의 유형이 &lt;code&gt;int&lt;/code&gt; 와 같은 기본 유형 이거나 &lt;code&gt;void&lt;/code&gt; (리턴 유형의 경우) 인 경우 속성, 매개 변수 또는 오퍼레이션은 각각 &lt;a href=&quot;mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt; 로 표시됩니다 . &lt;a href=&quot;mbeanparameterinfo&quot;&gt; &lt;code&gt;MBeanParameterInfo&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;mbeanoperationinfo&quot;&gt; &lt;code&gt;MBeanOperationInfo&lt;/code&gt; 로&lt;/a&gt; &lt;code&gt;getType()&lt;/code&gt; 또는 &lt;code&gt;getReturnType()&lt;/code&gt; 원시 이름 ( &quot;반환 &lt;code&gt;int&lt;/code&gt; &quot;등). 위의 매핑 규칙에서 &lt;em&gt;opendata가&lt;/em&gt;맵핑은 랩핑 된 유형입니다 ( &lt;code&gt;Integer&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="542b942cbce0b3844c4f27707d82afa56cc4e312" translate="yes" xml:space="preserve">
          <source>An Object containing the new value of the attribute.</source>
          <target state="translated">속성의 새로운 값을 포함하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="8df6bdf0b272efecad0ee99b8a017f2209a256fa" translate="yes" xml:space="preserve">
          <source>An Object containing the old value of the attribute.</source>
          <target state="translated">속성의 이전 값을 포함하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="03fe8ea3b11dee9511e32c9a654b006fa03856b1" translate="yes" xml:space="preserve">
          <source>An Object may not implement this interface and the BeanContextChild interface (or any subinterfaces thereof) they are mutually exclusive.</source>
          <target state="translated">Object는이 인터페이스와 BeanContextChild 인터페이스 (또는 그 서브 인터페이스)를 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="18fab20a8981932e0cdfcb03629a21078cd776dc" translate="yes" xml:space="preserve">
          <source>An ObjectInputStream deserializes primitive data and objects previously written using an ObjectOutputStream.</source>
          <target state="translated">ObjectInputStream은 원시 데이터 및 이전에 ObjectOutputStream을 사용하여 작성된 오브젝트를 직렬화 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e69da085e00a0535ea9b9fd9090f35263c39c4b6" translate="yes" xml:space="preserve">
          <source>An ObjectName can be written as a String with the following elements in order:</source>
          <target state="translated">ObjectName은 다음 요소를 순서대로 사용하여 문자열로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db3eca8504c2a54b641d40de2aa92e2f7f19aa7b" translate="yes" xml:space="preserve">
          <source>An ObjectName is a &lt;em&gt;property pattern&lt;/em&gt; if it is either a &lt;em&gt;property list pattern&lt;/em&gt; or a &lt;em&gt;property value pattern&lt;/em&gt; or both.</source>
          <target state="translated">ObjectName은 &lt;em&gt;특성 목록 패턴&lt;/em&gt; 이거나 &lt;em&gt;특성 값 패턴&lt;/em&gt; 이거나 둘 다인 경우 &lt;em&gt;특성 패턴&lt;/em&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c510c9d7563f2a9b7c7d986e71babc6118f59c46" translate="yes" xml:space="preserve">
          <source>An ObjectName is a &lt;em&gt;property value pattern&lt;/em&gt; when at least one of its &lt;em&gt;quoted&lt;/em&gt; or &lt;em&gt;unquoted&lt;/em&gt; key property values contains the wildcard characters asterisk or question mark as described above. In this case it has one or more keys and associated values, with at least one of the values containing wildcard characters. It matches a nonpattern ObjectName whose domain matches and that contains the same keys whose values match; if the property value pattern is also a property list pattern then the nonpattern ObjectName can contain other keys and values.</source>
          <target state="translated">ObjectName은 &lt;em&gt;인용&lt;/em&gt; 되거나 &lt;em&gt;인용되지 않은&lt;/em&gt; 키 특성 값 중 하나 이상 에 와일드 카드 문자 별표 또는 물음표가 포함 된 경우 &lt;em&gt;특성 값 패턴&lt;/em&gt; 입니다. 이 경우 하나 이상의 키와 관련 값이 있으며 하나 이상의 값에 와일드 카드 문자가 포함되어 있습니다. 도메인이 일치하고 값이 일치하는 동일한 키를 포함하는 비 패턴 ObjectName과 일치합니다. 특성 값 패턴이 특성 목록 패턴 인 경우 비 패턴 ObjectName은 다른 키와 값을 포함 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a363b501b01e48c96e2931f7880a10d1ec8bbb15" translate="yes" xml:space="preserve">
          <source>An ObjectName is a pattern if its domain contains a wildcard or if the ObjectName is a property pattern.</source>
          <target state="translated">도메인에 와일드 카드가 포함되어 있거나 ObjectName이 특성 패턴 인 경우 ObjectName은 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="aab3b6bad2ccd1e7f7e80a174b134a6fde6602c1" translate="yes" xml:space="preserve">
          <source>An ObjectName may be a &lt;em&gt;property list pattern&lt;/em&gt;. In this case it may have zero or more keys and associated values. It matches a nonpattern ObjectName whose domain matches and that contains the same keys and associated values, as well as possibly other keys and values.</source>
          <target state="translated">ObjectName은 &lt;em&gt;프로퍼티리스트 패턴&lt;/em&gt; 일 수 있습니다 . 이 경우 0 개 이상의 키와 관련 값을 가질 수 있습니다. 도메인이 일치하고 동일한 키 및 관련 값뿐만 아니라 다른 키 및 값을 포함하는 비 패턴 ObjectName과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="efed495670010e9fb0fdfac0012ec76731cee814" translate="yes" xml:space="preserve">
          <source>An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream.</source>
          <target state="translated">ObjectOutputStream은 Java 데이터의 기본 데이터 유형 및 그래프를 OutputStream에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f0bb0438739d4af1d1f3db2d825ca51008a0af6a" translate="yes" xml:space="preserve">
          <source>An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream. The objects can be read (reconstituted) using an ObjectInputStream. Persistent storage of objects can be accomplished by using a file for the stream. If the stream is a network socket stream, the objects can be reconstituted on another host or in another process.</source>
          <target state="translated">ObjectOutputStream은 Java 데이터의 기본 데이터 유형 및 그래프를 OutputStream에 씁니다. ObjectInputStream을 사용하여 객체를 읽거나 재구성 할 수 있습니다. 스트림 용 파일을 사용하여 객체의 영구 저장을 수행 할 수 있습니다. 스트림이 네트워크 소켓 스트림 인 경우 다른 호스트 또는 다른 프로세스에서 오브젝트를 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e01e685e35391f4028a7c1dab2bc1a0c6b5d2a" translate="yes" xml:space="preserve">
          <source>An OpenDataException with a detail message.</source>
          <target state="translated">세부 메시지가있는 OpenDataException입니다.</target>
        </trans-unit>
        <trans-unit id="06cbacef60277873774d333417d2d8df86173993" translate="yes" xml:space="preserve">
          <source>An OpenDataException with no detail message.</source>
          <target state="translated">세부 메시지가없는 OpenDataException입니다.</target>
        </trans-unit>
        <trans-unit id="18f7952f191dd1ad4237483205ff1688bae7b694" translate="yes" xml:space="preserve">
          <source>An OutputStreamWriter is a bridge from character streams to byte streams: Characters written to it are encoded into bytes using a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OutputStreamWriter는 문자 스트림에서 바이트 스트림으로의 브릿지입니다. 이에 작성된 문자는 지정된 &lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 바이트로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b61197a7d747d33a5b03557fdb06bb541b50fdb" translate="yes" xml:space="preserve">
          <source>An OutputStreamWriter is a bridge from character streams to byte streams: Characters written to it are encoded into bytes using a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;. The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.</source>
          <target state="translated">OutputStreamWriter는 문자 스트림에서 바이트 스트림으로의 브릿지입니다. 이에 작성된 문자는 지정된 &lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 바이트로 인코딩됩니다 . 사용하는 문자 세트는 이름으로 지정되거나 명시 적으로 지정되거나 플랫폼의 기본 문자 세트가 승인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99808230987b6e9929e2105f4c3389aec4750422" translate="yes" xml:space="preserve">
          <source>An RMI connector client is usually constructed using &lt;a href=&quot;../jmxconnectorfactory&quot;&gt;&lt;code&gt;JMXConnectorFactory&lt;/code&gt;&lt;/a&gt;, with a &lt;code&gt;JMXServiceURL&lt;/code&gt; that has &lt;code&gt;rmi&lt;/code&gt; or &lt;code&gt;iiop&lt;/code&gt; as its protocol.</source>
          <target state="translated">RMI 커넥터 클라이언트는 일반적으로 프로토콜로 &lt;code&gt;rmi&lt;/code&gt; 또는 &lt;code&gt;iiop&lt;/code&gt; 가 있는 &lt;code&gt;JMXServiceURL&lt;/code&gt; 과 함께 &lt;a href=&quot;../jmxconnectorfactory&quot;&gt; &lt;code&gt;JMXConnectorFactory&lt;/code&gt; 를&lt;/a&gt; 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b910edd874b19213945efb1089e2da5eb5ae5c4" translate="yes" xml:space="preserve">
          <source>An RMI connector server can also be created by constructing an instance of &lt;a href=&quot;rmiconnectorserver&quot;&gt;&lt;code&gt;RMIConnectorServer&lt;/code&gt;&lt;/a&gt;, explicitly or through the MBean server's &lt;code&gt;createMBean&lt;/code&gt; method.</source>
          <target state="translated">RMI 커넥터 서버는 명시 적으로 또는 MBean 서버의 &lt;code&gt;createMBean&lt;/code&gt; 메소드를 통해 &lt;a href=&quot;rmiconnectorserver&quot;&gt; &lt;code&gt;RMIConnectorServer&lt;/code&gt; &lt;/a&gt; 인스턴스를 구성하여 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dc09f4208b4223c4f8a1f92d1b7d0592ec2bd1d" translate="yes" xml:space="preserve">
          <source>An RMI object representing a connector server.</source>
          <target state="translated">커넥터 서버를 나타내는 RMI 객체</target>
        </trans-unit>
        <trans-unit id="7a37fe4347b2bf73213943b7b26b24257710b125" translate="yes" xml:space="preserve">
          <source>An RMI object representing a connector server. Remote clients can make connections using the &lt;a href=&quot;rmiserverimpl#newClient-java.lang.Object-&quot;&gt;&lt;code&gt;newClient(Object)&lt;/code&gt;&lt;/a&gt; method. This method returns an RMI object representing the connection.</source>
          <target state="translated">커넥터 서버를 나타내는 RMI 객체 원격 클라이언트는 &lt;a href=&quot;rmiserverimpl#newClient-java.lang.Object-&quot;&gt; &lt;code&gt;newClient(Object)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 연결할 수 있습니다 . 이 메소드는 연결을 나타내는 RMI 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04b48e43382bc4313acaa11e4d8357ed179380cb" translate="yes" xml:space="preserve">
          <source>An URL for reading the resource, or null if the resource could not be found or the caller doesn't have adequate privileges to get the resource.</source>
          <target state="translated">리소스를 읽기위한 URL이거나, 리소스를 찾을 수 없거나 호출자에게 리소스를 얻을 수있는 권한이없는 경우 null입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
