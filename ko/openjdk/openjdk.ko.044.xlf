<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="d132531fc669e517a82a3d82919ac097d06f2259" translate="yes" xml:space="preserve">
          <source>If the other &lt;code&gt;StringJoiner&lt;/code&gt; is using a different delimiter, then elements from the other &lt;code&gt;StringJoiner&lt;/code&gt; are concatenated with that delimiter and the result is appended to this &lt;code&gt;StringJoiner&lt;/code&gt; as a single element.</source>
          <target state="translated">다른 경우 &lt;code&gt;StringJoiner&lt;/code&gt; 가 다른 구분자를 사용하고 다른 쪽의 요소 &lt;code&gt;StringJoiner&lt;/code&gt; 은 그 분리와 연결되며, 그 결과이 추가된다 &lt;code&gt;StringJoiner&lt;/code&gt; 단일 요소로.</target>
        </trans-unit>
        <trans-unit id="613b81a7888d7292adb45fa99af137ae84272f3b" translate="yes" xml:space="preserve">
          <source>If the output is an &lt;code&gt;ImageOutputStream&lt;/code&gt;, the existing contents of the output prior to the current seek position are flushed, and need not be readable or writable. If the format requires that &lt;code&gt;endWriteSequence&lt;/code&gt; be able to rewind to patch up the header information, such as for a sequence of images in a single TIFF file, then the metadata written by this method must remain in a writable portion of the stream. Other formats may flush the stream after this method and after each image.</source>
          <target state="translated">출력이 &lt;code&gt;ImageOutputStream&lt;/code&gt; 인 경우, 현재 탐색 위치 이전의 출력의 기존 내용이 플러시되므로 읽을 수 있거나 쓸 수 없습니다. 형식에서 &lt;code&gt;endWriteSequence&lt;/code&gt; 가 단일 TIFF 파일의 이미지 시퀀스와 같이 헤더 정보를 패치하기 위해 되감기를 필요로하는 경우이 방법으로 작성된 메타 데이터는 스트림의 쓰기 가능한 부분에 남아 있어야합니다. 이 방법 이후와 각 이미지 후에 다른 형식으로 스트림을 비울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54204b2e99d7d060bb6235389e37beb7f049e32" translate="yes" xml:space="preserve">
          <source>If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.</source>
          <target state="translated">텍스트의 전체 길이를 읽지 않고 구문 분석이 완료되거나 구문 분석 또는 병합 중에 문제가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ed75a33bb4145623122f20c780e9bac95e43865" translate="yes" xml:space="preserve">
          <source>If the path is relative, and if its first segment contains a colon character (&lt;code&gt;':'&lt;/code&gt;), then a &lt;code&gt;&quot;.&quot;&lt;/code&gt; segment is prepended. This prevents a relative URI with a path such as &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; from later being re-parsed as an opaque URI with a scheme of &lt;code&gt;&quot;a&quot;&lt;/code&gt; and a scheme-specific part of &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt;. &lt;b&gt;&lt;i&gt;(Deviation from RFC 2396)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">경로가 상대 경로이고 첫 번째 세그먼트에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; ) 가 포함 된 경우 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 세그먼트가 앞에 붙습니다. 이렇게하면 &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; 와 같은 경로가있는 상대 URI가 나중에 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 체계 및 &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt; 체계가있는 불투명 URI로 다시 구문 분석되지 않습니다. . &lt;b&gt;&lt;i&gt;(RFC 2396에서 벗어남)&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87a4c8fb790be59120806baf097d003e2948d992" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, (atomically) decrements it.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 (원자 적으로) 감소합니다.</target>
        </trans-unit>
        <trans-unit id="e572cb5e5dee791d5b39d6f57ac77915682e21a1" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 카운트를 감소시킵니다. 그렇지 않으면 &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; 호출 한 다음이 작업의 완료자를 작성하려고 시도합니다 (있는 경우). 그렇지 않으면 이 작업을 완료된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bc17ec5f581dec30fa586e110a04b1eaf5b5b327" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 4 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4223a7d1829a5930922236b794117f0ecfa3ef5" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 예약 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c7072c32b05b6fd0de10d7da5998d3dbfa5ec38" translate="yes" xml:space="preserve">
          <source>If the permits are acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cea382e9b6e94d448d8b5b7931ce98c85d158e1" translate="yes" xml:space="preserve">
          <source>If the persist field of the attribute's descriptor is not null then Persistence policy from the attribute descriptor is used to guide storing the attribute in a persistent store.</source>
          <target state="translated">속성 설명 자의 지속 필드가 널이 아닌 경우 속성 설명 자의 지속성 정책이 속성을 영구 저장소에 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4b331cf13e540556f5aca90f86b4e8ad5c60f9" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle image metadata, null should be returned.</source>
          <target state="translated">플러그인이 이미지 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aab4c0c381c1b7fcd5929e45b451378e4a93f9be" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle metadata, null should be returned.</source>
          <target state="translated">플러그인이 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5bf226ccbe41713d478e11aab7ab361a597353a7" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads. But method &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">풀에 현재 corePoolSize 스레드보다 많은 스레드가 있으면 keepAliveTime 이상 동안 유휴 상태 인 경우 초과 스레드가 종료됩니다 ( &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt; 참조 ). 이를 통해 풀을 적극적으로 사용하지 않을 때 리소스 소비를 줄일 수 있습니다. 풀이 나중에 더 활성화되면 새 스레드가 구성됩니다. 이 매개 변수는 &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 동적으로 변경할 수도 있습니다 . &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; 는&lt;/a&gt; 종료 전에 유휴 스레드가 종료되지 않도록 효과적으로 비활성화합니다. 기본적으로 연결 유지 정책은 corePoolSize 스레드보다 많은 경우에만 적용됩니다. 그러나 &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; 메소드 keepAliveTime 값이 0이 아닌 한이 시간 제한 정책을 코어 스레드에도 적용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3ff33f4d5e297ea7ec3916317d36251a2ccb95" translate="yes" xml:space="preserve">
          <source>If the prefix is &quot;GMT&quot;, &quot;UTC&quot;, or &quot;UT&quot; a &lt;code&gt;ZoneId&lt;/code&gt; with the prefix and the non-zero offset is returned. If the prefix is empty &lt;code&gt;&quot;&quot;&lt;/code&gt; the &lt;code&gt;ZoneOffset&lt;/code&gt; is returned.</source>
          <target state="translated">접두사가 &quot;GMT&quot;, &quot;UTC&quot;또는 &quot;UT&quot; 이면 접두사가 있고 0이 아닌 오프셋이 있는 &lt;code&gt;ZoneId&lt;/code&gt; 가 반환됩니다. 접두사가 비어 있으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2958ef27e71136debb4afdbdf265b117d00e567e" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is greater than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be truncated. In this case, if the file offset as returned by the &lt;code&gt;getFilePointer&lt;/code&gt; method is greater than &lt;code&gt;newLength&lt;/code&gt; then after this method returns the offset will be equal to &lt;code&gt;newLength&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드가 리턴 한 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 크면 파일이 잘립니다. 이 경우, &lt;code&gt;getFilePointer&lt;/code&gt; 메소드에 의해 리턴 된 파일 오프셋 이 &lt;code&gt;newLength&lt;/code&gt; 보다 큰 경우 , 이 메소드가 리턴 된 후 오프셋은 &lt;code&gt;newLength&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9cef2b80409c01c0c853b230c56f0ff2824529e5" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is smaller than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be extended. In this case, the contents of the extended portion of the file are not defined.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드에 의해 리턴 된 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 작 으면 파일이 확장됩니다. 이 경우 파일의 확장 부분 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dec7b0fc3a3fa3565bc2b4d09d4d15db4b1e4a93" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load from a system default package.</source>
          <target state="translated">이전 단계에서 프로토콜 핸들러를 찾지 못하면 생성자가 시스템 기본 패키지에서로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6585f9f7ecc69964ba3abd119ebdf439ff37f98d" translate="yes" xml:space="preserve">
          <source>If the previous step has found no resource bundle, proceed to Step 6. If a bundle has been found that is a base bundle (a bundle for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle has been found that is a base bundle, but the candidate locale list contained locales other than Locale(&quot;&quot;), put the bundle on hold and proceed to Step 6. If a bundle has been found that is not a base bundle, proceed to Step 7.</source>
          <target state="translated">이전 단계에서 자원 번들을 찾지 못한 경우 6 단계로 진행하십시오. 기본 번들 ( &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 의 번들) 인 번들이 발견 되고 후보 로케일 목록에 &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 만 포함 된 경우 , 번들을 호출자에게 리턴하십시오. 기본 번들 인 번들이 발견되었지만 후보 로케일 목록에 Locale ( &quot;&quot;) 이외의 다른 로케일이 포함 된 경우 번들을 보류하고 6 단계로 진행하십시오. 기본 번들이 아닌 번들이 발견 된 경우 7 단계로 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="6778bed4bae7f4aceabe96f43a91b258db12e0c7" translate="yes" xml:space="preserve">
          <source>If the print data is a stream, or a print job requests data as a stream, then &lt;code&gt;SimpleDoc&lt;/code&gt; does not monitor if the service properly closes the stream after data transfer completion or job termination. Clients may prefer to use provide their own implementation of doc that adds a listener to monitor job completion and to validate that resources such as streams are freed (ie closed).</source>
          <target state="translated">인쇄 데이터가 스트림이거나 인쇄 작업이 데이터를 스트림으로 요청하면 &lt;code&gt;SimpleDoc&lt;/code&gt; 은 데이터 전송 완료 또는 작업 종료 후 서비스가 스트림을 올바르게 닫는 지 여부를 모니터링하지 않습니다. 클라이언트는 작업 완료를 모니터하고 스트림과 같은 자원이 해제 (즉, 닫힘)되었는지 확인하기 위해 리스너를 추가하는 고유 한 doc 구현을 사용하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88bf35bed53cf1a7b9c25c4c647bfc4d663ad0d2" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09f9046e5ee10b9263ce6a07905ea1779eccbaa9" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7003e770420135c1df12e09d555ca6780cff43c6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation. If the class is not so annotated, &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt;&lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt; 으로 주석이 달린 경우 주석 에서 소스 버전을 리턴하십시오. 클래스에 주석이없는 경우 &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt; &lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b31e3a1fd2087ce273c8b857c1c713db2fbc7119" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate appropriate credentials.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationException을 명시 적으로 포착해야합니다. AuthenticationException을 발견 한 후, 프로그램은 분석 된 컨텍스트의 환경 특성을 적절한 적절한 신임 정보로 업데이트하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2dc297aa51d5849276a390a4e74ee5aecc6575" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationNotSupportedException explicitly before attempting to catch NamingException. After catching &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt;, the program could reattempt the authentication using a different authentication flavor by updating the resolved context's environment properties accordingly.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationNotSupportedException을 명시 적으로 포착해야합니다. &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt; 을 포착 한 후 프로그램은 이에 따라 해결 된 컨텍스트의 환경 특성을 업데이트하여 다른 인증 플레이버를 사용하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa89d5f48713a94a294fbe63d3a7465ee70153d" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch CannotProceedException explicitly before attempting to catch NamingException.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 CannotProceedException을 명시 적으로 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8620b756848fd740f3151a464311aed319d8483" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch ContextNotEmptyException explicitly before attempting to catch NamingException. For example, after catching ContextNotEmptyException, the program might try to remove the contents of the context before reattempting the destroy.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 ContextNotEmptyException을 명시 적으로 포착해야합니다. 예를 들어, ContextNotEmptyException을 발견 한 후 프로그램은 삭제를 재 시도하기 전에 컨텍스트의 컨텐츠를 제거하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895af51843785805eb993f6b245e3c37e050b292" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch NamingSecurityException explicitly before attempting to catch NamingException. A program might want to do this, for example, if it wants to treat security-related exceptions specially from other sorts of naming exception.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 발견하기 전에 NamingSecurityException을 명시 적으로 포착해야합니다. 예를 들어 다른 종류의 명명 예외에서 보안 관련 예외를 처리하려는 경우 프로그램이이를 수행하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f5f7560de8700736d8932ba9b65417b272c5ae" translate="yes" xml:space="preserve">
          <source>If the property editor class has a public constructor that takes an Object argument then it will be invoked using the bean parameter as the argument. Otherwise, the default constructor will be invoked.</source>
          <target state="translated">특성 편집기 클래스에 Object 인수를 사용하는 공용 생성자가 있으면 Bean 매개 변수를 인수로 사용하여 호출됩니다. 그렇지 않으면 기본 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f66e3274b70113dec5b6e974df0367593c3c3b" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d846b960ac8982dfe609a8cc87db59aceb1d4596" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c2a7d82245ca935ebfab36515f8332c15126b95" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">등록 정보 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가 없으면 나머지 값은 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="b9750c4a61406d17de53527d1fc84ece847954d5" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">특성 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가없는 경우 나머지 값은 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="6bfe54e945e0b7d817f4c40688004d1c3e18c1e7" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 값의 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef546a8769cb06ecdb14394d21b131483d0cbdbf" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value and the use of getAsText to identify the current value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하고 getAsText를 사용하여 현재 값을 식별하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4476facb38f8ef6d3eac0b77402edf9355a984" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8efe5ceae64e694176e05313f25266d8f3110e7f" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key. If the underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; must be encoded as an &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다. 기본 키 저장소 구현이 &lt;code&gt;jks&lt;/code&gt; 유형 인 경우 &lt;code&gt;key&lt;/code&gt; 는 PKCS # 8 표준에 정의 &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; 대로 EncryptedPrivateKeyInfo 로 인코딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e8fade5fe2a933f005d764f4f99cdb58a44ddd5" translate="yes" xml:space="preserve">
          <source>If the protocol is &quot;file&quot; and there is an authority component, then permission to connect to and accept connections from that authority may be granted. If the protocol is &quot;file&quot; and the path specifies a file, then permission to read that file is granted. If protocol is &quot;file&quot; and the path is a directory, permission is granted to read all files and (recursively) all files and subdirectories contained in that directory.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이고 권한 구성 요소가있는 경우 해당 권한에 대한 연결 및 연결 권한이 부여 될 수 있습니다. 프로토콜이 &quot;file&quot;이고 경로가 파일을 지정하면 해당 파일을 읽을 수있는 권한이 부여됩니다. 프로토콜이 &quot;file&quot;이고 경로가 디렉토리 인 경우 해당 디렉토리에 포함 된 모든 파일과 모든 파일 및 하위 디렉토리를 읽을 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5e9c9f7d7d328c23292e6a5e585815516946f8" translate="yes" xml:space="preserve">
          <source>If the protocol is not &quot;file&quot;, then permission to connect to and accept connections from the URL's host is granted.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이 아닌 경우 URL 호스트에 연결하고 연결을 수락 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="40b1f09001ad2f74e8788b23bbde2accb73745d9" translate="yes" xml:space="preserve">
          <source>If the protocol of this URL is &quot;jar&quot;, then the permission granted is based on the permission that is required by the URL of the Jar file.</source>
          <target state="translated">이 URL의 프로토콜이 &quot;jar&quot;인 경우 부여 된 권한은 Jar 파일의 URL에 필요한 권한을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f7aff0ef21850924145fd8d1eef710a0152583e2" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되고 설치된 공급자에서 성공적으로 검색 할 수 있으면 공급자에서 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 목록 이 검색됩니다. 그렇지 않으면 또는 이러한 장치가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 객체 를 포함하도록 &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="0e695a51fa3964ae1c7613ee0169a232ee920a9d" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되어 있고 설치된 공급자에서 성공적으로 검색 할 수있는 경우 Provider에서 &lt;code&gt;Mixer.Info&lt;/code&gt; 개체 목록 이 검색됩니다. 그렇지 않은 경우 또는 이러한 믹서가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;Mixer.Info&lt;/code&gt; 오브젝트 를 포함하기 위해 &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록이 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="60186988e7792b549f33f598eb6796ff82e377be" translate="yes" xml:space="preserve">
          <source>If the provider implementation is dynamic, then the flag gives the option of preventing the returned rules from being cached in &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. When the flag is true, the provider is permitted to return null, where null will prevent the rules from being cached in &lt;code&gt;ZoneId&lt;/code&gt;. When the flag is false, the provider must return non-null rules.</source>
          <target state="translated">제공자 구현이 동적 인 경우 플래그는 리턴 된 규칙이 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 에 캐시되지 않도록하는 옵션을 제공합니다 . 플래그가 true 인 경우 공급자는 null을 반환 할 수 있습니다. 여기서 null은 규칙이 &lt;code&gt;ZoneId&lt;/code&gt; 에 캐시되지 않도록합니다 . 플래그가 false이면 제공자는 널이 아닌 규칙을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="e445a3443a37b81ff119acc67b2ad73cb5fb6432" translate="yes" xml:space="preserve">
          <source>If the provider implementation is not dynamic, then the result of the method must be the non-null set of rules selected by the ID.</source>
          <target state="translated">제공자 구현이 동적이 아닌 경우 메소드의 결과는 ID에 의해 선택된 널이 아닌 규칙 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="17253c90de92aa58bc36b4a773f197b6ca04e1e5" translate="yes" xml:space="preserve">
          <source>If the provider package list exists and is not empty, then for each element &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; of the list, the factory will attempt to load the class</source>
          <target state="translated">공급자 패키지 목록이 존재하고 비어 있지 않은 경우 목록의 각 요소 &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; 에 대해 팩토리는 클래스로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d01e7ab79ccc797c94edb821e2001a4b21858cc0" translate="yes" xml:space="preserve">
          <source>If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">큐에 여유 공간이있는 지정된 배열에 큐가 들어가면 (즉, 배열에 큐보다 많은 요소가있는 경우) 컬렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="99b3e8d45f37070b6c7a53d21e9f356902e9580a" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">기수가 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 작은 지, &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 보다 큰 경우 , &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="a648ff4273d99de4e1bc95f12a1486f421ca4054" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the character is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 문자가 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d4a1e7fa070e5bd8bde88ce903f985156a6f1b0d" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the value of &lt;code&gt;ch&lt;/code&gt; is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 &lt;code&gt;ch&lt;/code&gt; 값이 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="671d0d109c8316ebaf1f99c9e9a6b5ad599bcdb9" translate="yes" xml:space="preserve">
          <source>If the radix is smaller than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or larger than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then the radix &lt;code&gt;10&lt;/code&gt; is used instead.</source>
          <target state="translated">기수 미만이면 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 이상 &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 후 기수 &lt;code&gt;10&lt;/code&gt; 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="88c548789120cc039a2be678f91a294c4a57446d" translate="yes" xml:space="preserve">
          <source>If the read lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">읽기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1de0197561ab1c42739d318716c6da06cb232ac" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown regardless of whether an input source has been set or whether the indices are in bounds.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) 입력 소스의 설정 여부 또는 인덱스의 범위에 관계없이 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb2451c0113cb8c1e0775121dff8874d947bd15f" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00cde4cc70dae1cb495d031cb9acb67bc8abef24" translate="yes" xml:space="preserve">
          <source>If the recognized year number is less than 100, it is interpreted as an abbreviated year relative to a century of which dates are within 80 years before and 19 years after the time when the Date class is initialized. After adjusting the year number, 1900 is subtracted from it. For example, if the current year is 1999 then years in the range 19 to 99 are assumed to mean 1919 to 1999, while years from 0 to 18 are assumed to mean 2000 to 2018. Note that this is slightly different from the interpretation of years less than 100 that is used in &lt;a href=&quot;../text/simpledateformat&quot;&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인식 된 연도 수가 100 미만인 경우 Date 클래스가 초기화 된 후 80 년 전과 19 년 이내에 날짜가있는 세기를 기준으로 약식 연도로 해석됩니다. 연도 번호를 조정 한 후 1900을 뺍니다. 예를 들어, 현재 연도가 1999 인 경우 19-99 범위의 연도는 1919-1999를 의미하고 0-18은 연도는 2000-2018을 의미한다고 가정합니다. 이는 연도 해석과 약간 다릅니다. 적은 100보다 그에서 사용 &lt;a href=&quot;../text/simpledateformat&quot;&gt; &lt;code&gt;SimpleDateFormat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57ad84aa4b7a2b33d920b4d445e6eaeb418fc1cc" translate="yes" xml:space="preserve">
          <source>If the region is such that this width is zero, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역이이 폭이 0이되면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c3b8b1f31e8b1eb0578d0596a852433e7405f3a" translate="yes" xml:space="preserve">
          <source>If the relation is represented by an MBean (created by the user and added as a relation in the Relation Service), returns the ObjectName of the MBean.</source>
          <target state="translated">관계가 MBean으로 표시되고 (사용자가 작성하고 관계 서비스에서 관계로 추가 된 경우) MBean의 ObjectName을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6c90ca0b52fc5c89008817da193bca78cfc36ed6" translate="yes" xml:space="preserve">
          <source>If the remote MBean Server is 1.2</source>
          <target state="translated">리모트 MBean 서버가 1.2 인 경우</target>
        </trans-unit>
        <trans-unit id="03cc18ab3cabbd8e48236da939259f3b987d3f83" translate="yes" xml:space="preserve">
          <source>If the remote destination to which the socket is connected does not exist, or is otherwise unreachable, and if an ICMP destination unreachable packet has been received for that address, then a subsequent call to send or receive may throw a PortUnreachableException. Note, there is no guarantee that the exception will be thrown.</source>
          <target state="translated">소켓이 연결된 원격 대상이 존재하지 않거나 도달 할 수없는 경우 해당 주소에 대해 ICMP 대상 도달 불가능 패킷이 수신 된 경우, 후속 송신 또는 수신 호출에서 PortUnreachableException이 발생할 수 있습니다. 예외가 발생한다고 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d89a1cc49adab461bf1f01dc66545d017f8bacb" translate="yes" xml:space="preserve">
          <source>If the requested option is binary, it can be set using this method by a java.lang.Boolean:</source>
          <target state="translated">요청 된 옵션이 2 진인 경우 java.lang.Boolean에서이 메소드를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ce1c03b79a7b89afd15d63c7ba902df5495593" translate="yes" xml:space="preserve">
          <source>If the requested permission is allowed, this method returns quietly. If denied, a SecurityException is raised.</source>
          <target state="translated">요청 된 권한이 허용되면이 메소드는 자동으로 리턴합니다. 거부되면 SecurityException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c37b9290b4ade460cdf802abd93f12770f8d7f0" translate="yes" xml:space="preserve">
          <source>If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized.</source>
          <target state="translated">필요한 액세스 및 인수 확인이 성공하고 인스턴스화가 진행되면 생성자의 선언 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="62e2c41caf4aaf142a44a8c6c165f53c1d68b4be" translate="yes" xml:space="preserve">
          <source>If the result of this method is used to access the event source, for example, to look up the object or get its attributes, then it needs to be locked because implementations of &lt;code&gt;Context&lt;/code&gt; are not guaranteed to be thread-safe (and &lt;code&gt;EventContext&lt;/code&gt; is a subinterface of &lt;code&gt;Context&lt;/code&gt;). See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">이 메소드의 결과가 예를 들어 오브젝트를 찾거나 속성을 얻는 등의 이벤트 소스에 액세스하는 데 사용되는 경우 &lt;code&gt;Context&lt;/code&gt; 구현은 스레드로부터 안전하지 않기 때문에 잠겨 야 합니다 (그리고 &lt;code&gt;EventContext&lt;/code&gt; 는 &lt;code&gt;Context&lt;/code&gt; 의 하위 인터페이스 ). 스레딩 문제에 대한 자세한 내용은 &lt;a href=&quot;package-summary#THREADING&quot;&gt;패키지 설명&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da3549687bea03167816a9b17ffaee344e82b496" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown. The time and offset do not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다. 시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8a3d11d3b73e216be8517618d151d35e100edd64" translate="yes" xml:space="preserve">
          <source>If the resulting date is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜가 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ca351660a2dc03d4cb71b7bc124559d23a4db29" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44ca6bebbc9287dfb9c1097c7e056b162daf7bcb" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown. The time does not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다. 시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4f6dc2bf2873abab7867f3b616c93e4b15b446fa" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a primitive, a zero value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 기본이면 0 값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="f822d109dcf5c55256ad0bbca3b4f4180ce12367" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a reference, a null value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 참조이면 널값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="22bfe5b1532d3b1937f6f097fa6b7e18ec35a472" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T1&lt;/em&gt; is marked as void, any returned value is discarded</source>
          <target state="translated">리턴 유형 &lt;em&gt;T1&lt;/em&gt; 이 void로 표시되면 리턴 된 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8a413e6168d2b6897adbb71ca65aa2bb806445d1" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">리턴 유형이 매개 변수화 된 유형 인 경우 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="c790d87847b61c0198be1f5880f62ee8cbf59f42" translate="yes" xml:space="preserve">
          <source>If the return type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">리턴 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="29af74f5a09429dcfd9193c144c392b2c8199600" translate="yes" xml:space="preserve">
          <source>If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type.</source>
          <target state="translated">메소드의 리턴 유형이 기본 유형이거나 void 인 경우 모든 메소드는 동일한 리턴 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="17d771c49fde9fd06df899fa732fea09b1398c4a" translate="yes" xml:space="preserve">
          <source>If the return value is non-null, all attributes in the returned set are unsupported with this DocFlavor. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">리턴 값이 널이 아닌 경우, 리턴 된 세트의 모든 속성이이 DocFlavor에서 지원되지 않습니다. 리턴 된 세트는 지원되지 않는 속성 값과 지원되지 않는 속성 카테고리를 구별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d67afcae574c0dadec33d0948d30e110523b788e" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 생성자의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="bba8a24f154f8c33c7318be4afad7cbac85009fd" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 필드의 클래스가 아직 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="51fb639a4d11801aea7b926f5d54285fffc4a0fb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 메소드의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="062c7a8a96f0cd16df82fd6a3d7ef90b21f0c525" translate="yes" xml:space="preserve">
          <source>If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the &lt;code&gt;flush&lt;/code&gt; method is called on the returned node (or one of its ancestors or descendants).</source>
          <target state="translated">이 호출 이전에 리턴 된 노드가 존재하지 않으면이 노드와이 호출로 작성된 상위 노드는 리턴 된 노드 (또는 상위 또는 하위 항목 중 하나) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 영구적으로 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31845fc89c4f6a02a974ef2eb4b2ee1fabe487a0" translate="yes" xml:space="preserve">
          <source>If the returned object represents a &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;class&lt;/a&gt; file, it must be an instance of &lt;a href=&quot;javafileobject&quot;&gt;&lt;code&gt;JavaFileObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오브젝트가 &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;소스&lt;/a&gt; 또는 &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;클래스&lt;/a&gt; 파일을 나타내는 경우 &lt;a href=&quot;javafileobject&quot;&gt; &lt;code&gt;JavaFileObject&lt;/code&gt; &lt;/a&gt; 의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e65e674c2c9738a67b46cbdff85eddf6bd7d6d6" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the cutover might occur, then this method returns the day-of-week that the month-day will be adjusted to. If the day is positive then the adjustment is later. If the day is negative then the adjustment is earlier.</source>
          <target state="translated">규칙이 컷 오버가 발생할 수있는 주를 정의하면이 방법은 월이 조정될 요일을 반환합니다. 일이 양수이면 나중에 조정됩니다. 일이 음수이면 조정이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ab9f1126ac23de664120eeb0433d59deaee2f7bd" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the day defines either the start of the end of the transition week.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하면 해당 요일은 전환 주 끝의 시작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="89f95b53b5119c06e7c28d0a4953b38d65679d33" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the month if the month of either the earliest or latest possible date of the cutover.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하는 경우 컷 오버가 가능한 가장 빠른 날짜 또는 가장 최근 달인 월입니다.</target>
        </trans-unit>
        <trans-unit id="c5876d137cd994c7ad4a664d7beaa1b898954c4d" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the day is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 해당 날짜가 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="7a405331c7ddef3021a3335c00454f67145186ff" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the month is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 해당 월이 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="5034d0b228d4988928265c1d8ac1f628685a4b7f" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then this returns null.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f0e91ac8cea622cd628a97cacbf583516eb1203" translate="yes" xml:space="preserve">
          <source>If the same MXBean were registered under two different &lt;code&gt;ObjectName&lt;/code&gt;s, a reference to that MXBean from another MXBean would be ambiguous. Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an &lt;a href=&quot;instancealreadyexistsexception&quot;&gt;&lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt;&lt;/a&gt;. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">동일한 MXBean이 두 개의 다른 &lt;code&gt;ObjectName&lt;/code&gt; 아래에 등록 된 경우 다른 MXBean에서 해당 MXBean에 대한 참조가 모호합니다. 따라서 MXBean 객체가 이미 MBean 서버에 등록되어 있고 다른 이름으로 동일한 MBean 서버에 등록하려고하면 결과는 &lt;a href=&quot;instancealreadyexistsexception&quot;&gt; &lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt; &lt;/a&gt; 입니다. 하나 이상의 이름으로 동일한 MBean 객체를 등록하는 것은 일반적으로 권장되지 않습니다. 특히 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 인&lt;/a&gt; MBean에서는 제대로 작동하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="50eb773388c08998af191260a43e85de5e2d0eab" translate="yes" xml:space="preserve">
          <source>If the same listener is added more than once, it is considered as many times as it was added. It is often useful to add the same listener with different filters or handback objects.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가되면 추가 된 횟수만큼 간주됩니다. 필터 나 핸드백 객체가 다른 동일한 리스너를 추가하는 것이 유용한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="a530990bfaa8ba340ab7814bcb938600df0674e3" translate="yes" xml:space="preserve">
          <source>If the same listener was added more than once, it will be notified one less time after being removed. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or was never added, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가 된 경우 제거 된 후 한 번 덜 알림을받습니다. 경우 &lt;code&gt;listener&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 또는 추가되지 않았다, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a2f1faa361a4f239eecfaa4480ce58bb66c8e63" translate="yes" xml:space="preserve">
          <source>If the scale is greater than or equal to zero and the adjusted exponent is greater than or equal to &lt;code&gt;-6&lt;/code&gt;, the number will be converted to a character form without using exponential notation. In this case, if the scale is zero then no decimal point is added and if the scale is positive a decimal point will be inserted with the scale specifying the number of characters to the right of the decimal point. &lt;code&gt;'0'&lt;/code&gt; characters are added to the left of the converted unscaled value as necessary. If no character precedes the decimal point after this insertion then a conventional &lt;code&gt;'0'&lt;/code&gt; character is prefixed.</source>
          <target state="translated">스케일이 0보다 크거나 조정 된 지수가 &lt;code&gt;-6&lt;/code&gt; 보다 크거나 같은 경우 , 지수 표기법을 사용하지 않고 숫자가 문자 형식으로 변환됩니다. 이 경우 스케일이 0이면 소수점이 추가되지 않고 스케일이 양수이면 소수점 오른쪽에 문자 수를 지정하는 스케일과 함께 소수점이 삽입됩니다. 필요에 따라 변환 된 스케일링되지 않은 값의 왼쪽에 &lt;code&gt;'0'&lt;/code&gt; 문자가 추가됩니다. 이 삽입 후 소수점 앞에 문자가 없으면 일반적인 &lt;code&gt;'0'&lt;/code&gt; 문자가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="b6699480c9af01ef59363f0886670fc80f9f3dd6" translate="yes" xml:space="preserve">
          <source>If the scheme component is defined in the given spec and does not match the scheme of the context, then the new URL is created as an absolute URL based on the spec alone. Otherwise the scheme component is inherited from the context URL.</source>
          <target state="translated">스킴 구성 요소가 지정된 스펙에 정의되어 있고 컨텍스트의 스킴과 일치하지 않으면 스펙 만 기반으로 새 URL이 절대 URL로 작성됩니다. 그렇지 않으면 스킴 구성 요소가 컨텍스트 URL에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="6ccd5d8778f5d88a5474e8c59978eccee5689a2e" translate="yes" xml:space="preserve">
          <source>If the second argument is 1.0, then the result is the same as the first argument.</source>
          <target state="translated">두 번째 인수가 1.0이면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8344687c76c61e184619d725d0545c562c31518" translate="yes" xml:space="preserve">
          <source>If the second argument is NaN, then the result is NaN.</source>
          <target state="translated">두 번째 인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="83af07e72de969c0ada685452a5155bf504024e7" translate="yes" xml:space="preserve">
          <source>If the second argument is positive or negative zero, then the result is 1.0.</source>
          <target state="translated">두 번째 인수가 양수 또는 음수 0이면 결과는 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="9b941ca67a1b9bc33a6bb0d7bf06f63dc95c2df8" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then jump to the next space.</source>
          <target state="translated">초를 사용할 수 없으면 다음 공간으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea372174aa5c23af0c1777c675872adacfad266" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then the format is complete.</source>
          <target state="translated">초를 사용할 수 없으면 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5653b3f59b63219b61535639dd8eec29f7dad782" translate="yes" xml:space="preserve">
          <source>If the security property is set to the fully qualified name of a &lt;code&gt;CallbackHandler&lt;/code&gt; implementation class, then a &lt;code&gt;LoginContext&lt;/code&gt; will load the specified &lt;code&gt;CallbackHandler&lt;/code&gt; and pass it to the underlying LoginModules. The &lt;code&gt;LoginContext&lt;/code&gt; only loads the default handler if it was not provided one.</source>
          <target state="translated">보안 특성이 &lt;code&gt;CallbackHandler&lt;/code&gt; 구현 클래스 의 완전한 이름으로 설정 되면 &lt;code&gt;LoginContext&lt;/code&gt; 는 지정된 &lt;code&gt;CallbackHandler&lt;/code&gt; 를로드 하여 기본 LoginModules에 전달합니다. &lt;code&gt;LoginContext&lt;/code&gt; 만 하나를 제공하지 않은 경우 기본 핸들러를로드합니다.</target>
        </trans-unit>
        <trans-unit id="08dd4228bba4510d42bc79e395b01540dece6a1f" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">선택기가 이미 닫혀 있으면이 메소드는 즉시 리턴합니다. 그렇지 않으면 선택기를 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ad935cdc55d4a107502fb1347aaf4da85ef291" translate="yes" xml:space="preserve">
          <source>If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</source>
          <target state="translated">선택기 자체가 닫히면 채널이 등록 취소되고 등록을 나타내는 키가 추가 지연없이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="527b7c6f507b87aa21ddf93053b13e95205bb2c8" translate="yes" xml:space="preserve">
          <source>If the sequence is mutated while the stream is being read, the result is undefined.</source>
          <target state="translated">스트림을 읽는 동안 시퀀스가 ​​변경되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96cc80cb5c49589843f4c152dbe187b0d7672c14" translate="yes" xml:space="preserve">
          <source>If the set contains &lt;code&gt;null&lt;/code&gt; or elements that are not of type &lt;code&gt;PosixFilePermission&lt;/code&gt; then these elements are ignored.</source>
          <target state="translated">집합에 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;PosixFilePermission&lt;/code&gt; 유형이 아닌 요소가 포함 된 경우 이러한 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a2fc5c10d29d945ad7e76e24ac30350f31297ef" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">반복자의 고유 한 &lt;a href=&quot;../../util/iterator#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것을 제외하고, 반복자가 작성된 후에 세트가 수정 되면 &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d6f544e9f4637d730c544f2df049efe3bc2241c9" translate="yes" xml:space="preserve">
          <source>If the signs of arguments are unknown and a positive modulus is needed it can be computed as &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt;.</source>
          <target state="translated">인수의 부호를 알 수없고 양의 계수가 필요한 경우 &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt; 로 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d63f4df1fec01d153e077a0cd492720daea9604" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the quotient is negative and &lt;code&gt;floorDiv&lt;/code&gt; returns the integer less than or equal to the quotient and the &lt;code&gt;/&lt;/code&gt; operator returns the integer closest to zero.</source>
          <target state="translated">인수의 부호가 다른 경우 몫은 음수이고 &lt;code&gt;floorDiv&lt;/code&gt; 는 몫 보다 작거나 같은 정수를 반환하고 &lt;code&gt;/&lt;/code&gt; 연산자는 0에 가장 가까운 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3eddbc3f191c883b4734fcd232862a579d8785" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the results differ from the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">인수의 부호가 다른 경우 결과는 &lt;code&gt;%&lt;/code&gt; 연산자 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8893f46ae7c980fbb6e68ff03e7cfa2f4485e10e" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorDiv&lt;/code&gt; and the &lt;code&gt;/&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorDiv&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e7d5446141374acaa0bf3d68df3adaaf0963a7c6" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorMod&lt;/code&gt; and the &lt;code&gt;%&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorMod&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7c0c3191c882ae94e067ec4dbb9ae1efa5c18a6b" translate="yes" xml:space="preserve">
          <source>If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage.</source>
          <target state="translated">맵 크기 (키-값 매핑 수)가 예상 최대 크기를 충분히 초과하면 버킷 수가 늘어납니다. 버킷 수를 늘리면 ( &quot;리 해싱&quot;) 비용이 상당히 많이들 수 있으므로 예상되는 최대 크기가 충분히 큰 ID 해시 맵을 만드는 데 비용이 듭니다. 반면 컬렉션 뷰에 대한 반복에는 해시 테이블의 버킷 수에 비례 한 시간이 필요하므로 반복 성능이나 메모리 사용과 관련하여 예상되는 최대 크기를 너무 높게 설정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca2d090f17022dd5e73b01197f1d6848c079ffd" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓을 닫은 후에도 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="59679157176f257978bbe9def3e0740bb5fb205a" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 엔드 포인트의 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e21984f9cc07335c38e61e8524fe85a27b1d410" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 로컬 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="763b9cd171c3cff366fd68dad3b49caafc1fe527" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 포트 번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd6141b5241054244025e22ff3d73a0248d5fc8c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 로컬 포트 ​​번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fc8e1670126679859d5c660bcdcb0e5c4dce29e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결된 경우 소켓이 닫힌 후에도이 메소드는 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="eded3cce47a4f9690c31a1eee5141c639e63658a" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3d182eb3854cd39ce3f790ae76cf8abf4ec7f3e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac6a556c1933db902b091802b19407a613fc41d9" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abfab3eeb26c13c0835e0da8c32c95bf0e46c4ed" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c74e08fa061f46bcfc74bd1ceb1c899db939f1d9" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">소스가 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 출력 스트림을 사용하여 서브 프로세스의 표준 입력을 쓸 수 있습니다 . 소스가 다른 값으로 설정되면 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="661f6402b0c9208e67543bc3982626f5f2502c0a" translate="yes" xml:space="preserve">
          <source>If the source of the notification is a reference to an MBean object, the MBean server will replace it by that MBean's ObjectName. Otherwise the source is unchanged.</source>
          <target state="translated">통지의 소스가 MBean 객체에의 참조 인 경우, MBean 서버는 그것을 MBean의 ObjectName로 교체합니다. 그렇지 않으면 소스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc0afb74deac5658d35d1df20daa373ddaf8091c" translate="yes" xml:space="preserve">
          <source>If the spec's path component begins with a slash character &quot;/&quot; then the path is treated as absolute and the spec path replaces the context path.</source>
          <target state="translated">스펙의 경로 구성 요소가 슬래시 문자 &quot;/&quot;로 시작하면 경로는 절대 경로로 취급되고 스펙 경로는 컨텍스트 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="97c03df7f79f779f19dbd94c565abdfcc104d7ca" translate="yes" xml:space="preserve">
          <source>If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned.</source>
          <target state="translated">지정된 IP 주소가 여러 네트워크 인터페이스에 바인딩 된 경우 어떤 네트워크 인터페이스가 반환되는지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c68f935629df479cecc1daf2323805432c7c1f" translate="yes" xml:space="preserve">
          <source>If the specified amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must have the same chronology as this period. Implementations may choose to accept or reject other &lt;code&gt;TemporalAmount&lt;/code&gt; implementations.</source>
          <target state="translated">지정된 금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우이 기간과 동일한 연대기를 가져야합니다. 구현시 다른 &lt;code&gt;TemporalAmount&lt;/code&gt; 구현 을 수락하거나 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aeb138890341e49f448dcdb19a0436d6eccb12fa" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;calendar.builder#build--&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 달력이 주 날짜를 지원하지 않는 경우, &lt;a href=&quot;calendar.builder#build--&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="21d5a2365b7e2ef9cdf719d377a83491e9b996d8" translate="yes" xml:space="preserve">
          <source>If the specified comment is &lt;code&gt;null&lt;/code&gt; then no comment will be stored in the document.</source>
          <target state="translated">지정된 주석이 &lt;code&gt;null&lt;/code&gt; 이면 주석이 문서에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c00aef2c14db555263f047e1c32a11c40196454" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aefe2d484ac87a9f75945af0a56cb6b62891cb32" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e90b9efbdd73e57fac8cf7dcbd6a9324c80a3a89" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a JobHoldUntil attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">지정된 날짜-시간이 이미 지난 경우 작업은 즉시 처리 할 수 ​​있어야합니다. 따라서 작업을 즉시 처리 후보로 만드는 한 가지 방법은 다음과 같이 구성된 JobHoldUntil 속성을 지정하는 것입니다 (1970 년 1 월 1 일 00:00:00 GMT 표시).</target>
        </trans-unit>
        <trans-unit id="2496623a004f15dd4819ee54aa8493f7e338eba3" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">지정된 호스트가 &lt;code&gt;null&lt;/code&gt; 의 경우, 주소를 &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 로 지정하는 것과 같습니다 . 즉, 루프백 인터페이스의 주소를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="900d04445ca5a80f48077470ed1101681577ef82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.</source>
          <target state="translated">지정된 키가 (널이 아닌) 값과 아직 연결되지 않은 경우 지정된 값과 연결합니다. 그렇지 않은 경우, 값을 지정된 리매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="327e72df9ef84db72836c87a15ef8d4fb475f995" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;) associates it with the given value and returns &lt;code&gt;null&lt;/code&gt;, else returns the current value.</source>
          <target state="translated">지정된 키가 값과 아직 연결되어 있지 않거나 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우 해당 키를 지정된 값과 연결하고 &lt;code&gt;null&lt;/code&gt; 을 반환하면 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b0beef1230b8f936ac0be883b146508d29a805b" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;), attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 키가 값에 아직 연결되어 있지 않은 경우 (또는 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우) 지정된 매핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="50fe8f5b029680a754d045deccf54d554f1ecb50" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is &lt;code&gt;null&lt;/code&gt;. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a &lt;code&gt;String msg&lt;/code&gt; to a value mapping:</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 제공된 널이 아닌 값과 연관시킵니다. 그렇지 않으면 관련 값을 제공된 다시 매핑 함수의 결과로 바꾸거나 결과가 &lt;code&gt;null&lt;/code&gt; 인 경우 제거합니다 . 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다. 예를 들어, &lt;code&gt;String msg&lt;/code&gt; 를 작성하거나 값 맵핑에 추가 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="07aab8862177972b392beb8f0bf5c9cd52e38ac3" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 주어진 값과 연관시킵니다. 그렇지 않으면 값을 지정된 다시 매핑 함수의 결과로 바꾸거나 결과가 null 인 경우 제거합니다. 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4925c79cda2f9aaf0050cbbfb1bd9cb1cde5984" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associate it with the given value. This is equivalent to</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 값과 연관 시키십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="df5a13cc298f2e36b4088599af2bf52a36c46112" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 지정된 값과 연관시킵니다. 그렇지 않은 경우, 값을 지정된 리매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 이 기능은 원자 적으로 한 번만 적용되는 것은 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="551c906c1bb44aa217c725bb3e6835b67419ea34" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 전체 메소드 호출은 원자 적으로 수행되므로 함수는 키당 최대 한 번 적용됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 조작은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 간단하고 단순해야하며이 맵의 다른 맵핑을 업데이트하려고하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="199aa69d5cf4c4d157c5d05ec7094035a1890fc8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only if the value is not present.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 함수가된다 &lt;em&gt;NOT&lt;/em&gt; 한번 원자 적 가치가 존재하지 않는 경우에만 적용 보장.</target>
        </trans-unit>
        <trans-unit id="74ec46a56735923288ea9182f5be9a7235b7c574" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">지정된 언어 태그에 잘못된 형식의 하위 태그가 포함 된 경우 첫 번째 하위 태그와 다음 하위 태그는 모두 무시됩니다. 이 경우 예외를 발생시키는 &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e16cfca3f81f7f2c484ea21572aa935aba3557" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">지정된리스트가 작거나 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우 ,이 구현은 첫 번째 요소를 이동해야하는 위치로 교환 한 다음, 대체 된 요소를 이동 된 요소가 첫 번째 요소로 교체 될 때까지 이동해야하는 위치로 반복적으로 교환합니다. 필요한 경우 회전이 완료 될 때까지 두 번째 및 연속 요소에서 프로세스가 반복됩니다. 지정된리스트가 크고 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하지 않는 경우 ,이 구현은리스트를 index- &lt;code&gt;-distance mod size&lt;/code&gt; 주위의 두 개의 서브 리스트보기로 나눕니다 . 그런 다음 &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;메소드는 각 서브리스트보기에서 호출되며 마지막으로 전체 목록에서 호출됩니다. 두 알고리즘에 대한 자세한 설명은 Jon Bentley 's 2.3 단원을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e207478f4c307f8daec04a1eb43edfa1b56c4337" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 주소를 AnyLocal 주소로 지정하는 것과 같습니다 ( &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3bb4277707fb1b363f377904ef8a00ae80162edc" translate="yes" xml:space="preserve">
          <source>If the specified name is already in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 이미 사용 가능한 속성 이름 목록에 있으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fdd0b3e89e1f58df16acb73daa9598c19a8c783" translate="yes" xml:space="preserve">
          <source>If the specified name is not in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 사용 가능한 속성 이름 목록에 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="92b923f20f66bacef4d2ff1b575298d2082a6d3b" translate="yes" xml:space="preserve">
          <source>If the specified object is an instance of &lt;code&gt;Throwable&lt;/code&gt;, it becomes the</source>
          <target state="translated">지정된 객체가 &lt;code&gt;Throwable&lt;/code&gt; 의 인스턴스 인 경우는</target>
        </trans-unit>
        <trans-unit id="f07c1a027ba244740b1e94181579aafe6b9799f7" translate="yes" xml:space="preserve">
          <source>If the specified prefix is already in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 이미 사용 가능한 알림 유형 목록에있는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35c19bfb0ddf95e53e5300c7d5d437ccd663d657" translate="yes" xml:space="preserve">
          <source>If the specified prefix is not in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 사용 가능한 알림 유형 목록에없는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f43c50810daae04d0ace6639274dabc1168944f9" translate="yes" xml:space="preserve">
          <source>If the specified property is not defined for a particular file format, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 속성이 특정 파일 형식에 대해 정의되어 있지 않으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1954d35e1a8126307e2b4392ca7004d2cfa54884" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then &lt;a href=&quot;timeoutexception&quot;&gt;&lt;code&gt;TimeoutException&lt;/code&gt;&lt;/a&gt; is thrown. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;a href=&quot;timeoutexception&quot;&gt; &lt;code&gt;TimeoutException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="310c63f9de70d34cca02c16171cb0b3c368911f0" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229ff9ac1c41d305f35a7c0608935889e0aaec6b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다. 이 스레드에 할당 된 모든 허가는 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출에 의해 허용 된 것처럼 허가를 획득하려는 다른 스레드에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dda73785392b01747ad72630377e93ff7ebd123" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 인수의 유효성을 검사하는 것 외에 다른 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f140d470f07fad292b66fc6ee306ae6d2a54ab2a" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="077ba9a63c85f3c79b6472adbd6bd273ed829948" translate="yes" xml:space="preserve">
          <source>If the standard error of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 하위 프로세스의 표준 오류를 리디렉션 한 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="86430b03fbc71403519b5c3b7220021c3f6618a7" translate="yes" xml:space="preserve">
          <source>If the standard input of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 입력 이 &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;널 출력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="7075f6432f67c8c99f417e3aed9f9abd4674447d" translate="yes" xml:space="preserve">
          <source>If the standard output of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 출력 이 &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;널 입력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="d366f3eb6bf9e4d636eed0b8ad01a318338322f7" translate="yes" xml:space="preserve">
          <source>If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it creates a datagram socket.</source>
          <target state="translated">stream 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 스트림 소켓이 작성됩니다. stream 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 데이터 그램 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="92109724254a6a952d63389232984fc4b39d101f" translate="yes" xml:space="preserve">
          <source>If the stream is parallel, and the &lt;code&gt;Collector&lt;/code&gt; is &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;concurrent&lt;/code&gt;&lt;/a&gt;, and either the stream is unordered or the collector is &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt;&lt;code&gt;unordered&lt;/code&gt;&lt;/a&gt;, then a concurrent reduction will be performed (see &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; for details on concurrent reduction.)</source>
          <target state="translated">스트림이 병렬이고 &lt;code&gt;Collector&lt;/code&gt; 가 &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;concurrent&lt;/code&gt; &lt;/a&gt; 이고 스트림이 정렬되지 않거나 수집기가 &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt; &lt;code&gt;unordered&lt;/code&gt; &lt;/a&gt; 경우 동시 축소가 수행됩니다 ( 동시 축소에 대한 자세한 내용 은 &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="649cf82f464f662aa965403c73cf99d556fea581" translate="yes" xml:space="preserve">
          <source>If the subprocess has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">서브 프로세스가 이미 종료 된 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 프로세스가 종료되지 않고 시간 종료 값이 0보다 작거나 같은 경우이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1b0a8ba1234c9978531ae814a7cbb1dae0a3c230" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">수퍼 클래스가 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 슈퍼 클래스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 . 이 &lt;code&gt;Class&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스, 프리미티브 유형 또는 void를 나타내는 경우 널이 리턴됩니다. 이 객체가 배열 클래스를 나타내는 경우, &lt;code&gt;Object&lt;/code&gt; 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="702061aae71a7b0bc29035519b62837f0bf9ee3d" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="a6062faf5608aab9b4601cbc2c84f0f96e088fa9" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not supported by this writer (</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 라이터에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="e0ec08c9bcf3ded436efba803a4101d1da6386d3" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not understood by this writer or transcoder, they will be ignored.</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 기록 기나 트랜스 코더가 이해할 수없는 선택적 설정 값이 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="11c8152472d911028fe75c0272d12bdc08e6d5e4" translate="yes" xml:space="preserve">
          <source>If the system does not support environment variables, an empty map is returned.</source>
          <target state="translated">시스템이 환경 변수를 지원하지 않으면 빈 맵이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="98fa5298bfbc9c3dc738e30b2cfbc794eda77505" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;java.system.class.loader&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스의 이름이됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 상위로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3a82eebeff03c982f8a2c8e7b92fff81f4e06e38" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52c1afd219c316bf40da492c932d1f909b2e0fe8" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f3d062ab7060d9b3ee095375a8de4d829bd4225b" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 가 정의 된 경우 URI 스킴 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 로 식별되는 구체적 제공자 클래스의 하나 이상의 완전한 이름 목록으로 간주 됩니다 . 특성이 둘 이상의 이름 목록 인 경우 이름은 쉼표로 구분됩니다. 각 클래스는 시스템 클래스 로더를 사용하여로드되며 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 하나의 인수 생성자를 호출하여 인스턴스화됩니다 . 제공자는 속성에 나열된 순서대로로드 및 인스턴스화됩니다. 이 프로세스가 실패하거나 제공자의 체계가 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 과 같지 않은 경우지정되지 않은 오류가 발생합니다. URI 스킴은 일반적으로 대소 문자와 상관없이 비교되지만 기본 제공자의 경우 스킴은 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이어야 합니다 . 첫 번째 제공자 클래스는 시스템 기본 제공자에 대한 참조로 호출하여 인스턴스화됩니다. 두 번째 공급자 클래스는 첫 번째 공급자 인스턴스에 대한 참조로 호출하여 인스턴스화됩니다. 세 번째 공급자 클래스는 두 번째 인스턴스 등에 대한 참조로 호출하여 인스턴스화됩니다. 인스턴스화 할 마지막 공급자가 기본 공급자가됩니다. 그 &lt;code&gt;getFileSystem&lt;/code&gt; 의 방법은 URI를 호출 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 기본 파일 시스템에 대한 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd24e048fc15e059868d56f4f568438df6b0caf5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer. This class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; 가 정의 된 경우 값은 구체적인 구현 클래스의 완전한 이름으로 간주되며 Packer를 구현해야합니다. 이 클래스는로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45a9607a9147c5f0b3360c97b95442bd171c997a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker. The class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; 가 정의 된 경우 값은 Unpacker를 구현해야하는 구체적 구현 클래스의 완전한 이름이됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e75189cd7136093b1d6f408091c23d0de22eb446" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; is defined, then it is taken to be the fully-qualified name of a class implementing the &lt;code&gt;PreferencesFactory&lt;/code&gt; interface. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 가 정의 된 경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 인터페이스를 구현하는 클래스의 완전한 이름으로 간주 됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7e27f744d6efd52e983b8075a0c2febcea34f65" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.management.builder.initial&lt;/code&gt; is set, the platform &lt;code&gt;MBeanServer&lt;/code&gt; creation will be done by the specified &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt;&lt;code&gt;MBeanServerBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.management.builder.initial&lt;/code&gt; 이 설정되면, 플랫폼 &lt;code&gt;MBeanServer&lt;/code&gt; 작성은 지정된 &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt; &lt;code&gt;MBeanServerBuilder&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cde7239c70f83bff85e4440c46d6384691316ad" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 수신자를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 적합한 MIDI 포트를 사용할 수 없으면 설치된 신시사이저에서 수신기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="91d3c314661dc26f163d797ffb58967de288f2ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default sequencer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 시퀀서를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00dcdd9d0bce1154db11492279afceeca3e08d7a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default synthesizer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 신시사이저를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30df19d74bec068b077f43c95c9174eacf908696" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default transmitter. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 송신기를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db720e9cdab4ebfc9f02a35fbd8f738bb2171b1" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default clip. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 클립을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="878cc5542428544d5bac13085b41e0430d054903" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default source data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 소스 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d607cde38af381ba0dfdab64a53303e271b212" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default target data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 대상 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af05deaf58fe154a4b75ce321753672bae18f99" translate="yes" xml:space="preserve">
          <source>If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.</source>
          <target state="translated">대상 파일이 존재하면 비어 있지 않은 디렉토리가 아닌 경우 대상 파일이 대체됩니다. 대상 파일이 존재하고 심볼릭 링크 인 경우 링크 대상이 아닌 심볼릭 링크 자체가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="3c180e88e82b133d4c219bf7bc995901410956a4" translate="yes" xml:space="preserve">
          <source>If the target method handle consumes no arguments besides than the result (if any) of the filter &lt;code&gt;coll&lt;/code&gt;, then &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt;. If the filter method handle &lt;code&gt;coll&lt;/code&gt; consumes one argument and produces a non-void result, then &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt;. Other equivalences are possible but would require argument permutation.</source>
          <target state="translated">대상있어서 핸들 필터들 (있는 경우) 또한 결과보다 인수를 소모하지 않으면 &lt;code&gt;coll&lt;/code&gt; 후, &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; 동등 &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt; . 필터 메소드 핸들 &lt;code&gt;coll&lt;/code&gt; 이 하나의 인수를 사용하고 무효가 아닌 결과를 생성하는 경우 &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; 는 &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt; . 다른 동등성도 가능하지만 인수 치환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9a6410dfb8cfd393874164170a840502005c25ad" translate="yes" xml:space="preserve">
          <source>If the target returns a value, the filter must accept that value as its only argument. If the target returns void, the filter must accept no arguments.</source>
          <target state="translated">대상이 값을 반환하면 필터는 해당 값을 유일한 인수로 허용해야합니다. 대상이 void를 반환하면 필터는 인수를 허용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="60ff5ddff7c5d899dfe402e4472a1b9b2a332d25" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain a date, but does contain one or more &lt;code&gt;ChronoField&lt;/code&gt; date fields, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time.</source>
          <target state="translated">시간 객체에 날짜가 포함되어 있지 않지만 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드 가 하나 이상 포함되어 있으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 날짜 / 시간을 변경하지 않고 재정의 연대기를 시간에 추가하여 이전 연대기를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="dd85e14ed75c47c84beea3f122d891fc9308e690" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time.</source>
          <target state="translated">임시 객체에 순간이 포함되어 있지 않지만 오프셋이 포함되어 있으면 추가 검사가 수행됩니다. 정규화 된 재정의 영역이 시간의 오프셋과 다른 오프셋 인 경우 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 재정의 영역이 시간에 추가되어 이전 영역을 대체하지만 날짜 / 시간을 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c09abaae8508d70028ba67cefa61277b54360a6" translate="yes" xml:space="preserve">
          <source>If the thread argument is a system thread (belongs to the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission. If the thread argument is</source>
          <target state="translated">스레드 인수가 시스템 스레드 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 스레드 그룹에 속함 )이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . 스레드 인수가</target>
        </trans-unit>
        <trans-unit id="956a4caf473783d2c99b96d529421cc001582508" translate="yes" xml:space="preserve">
          <source>If the thread group argument is the system thread group ( has a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission. If the thread group argument is</source>
          <target state="translated">스레드 그룹 인수가 시스템 스레드 그룹 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 경우)이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . 스레드 그룹 인수가</target>
        </trans-unit>
        <trans-unit id="2851f30724641ecca099288cb8621aaa00615fd6" translate="yes" xml:space="preserve">
          <source>If the thread is alive but suspended, it is resumed and is permitted to make progress in its execution.</source>
          <target state="translated">스레드가 활성 상태이지만 일시 중단 된 경우 스레드가 재개되고 실행 진행이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d129983d6e8dc28983c9eb2cd579ed898cf687" translate="yes" xml:space="preserve">
          <source>If the thread is alive, it is suspended and makes no further progress unless and until it is resumed.</source>
          <target state="translated">스레드가 활성 상태 인 경우 스레드가 일시 중단되고 다시 시작하지 않는 한 계속 진행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95f23b0ab1d9ecd54f0d7d1cfdcbc8a705f2c602" translate="yes" xml:space="preserve">
          <source>If the thread of the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If CPU time measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">지정된 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 . CPU 시간 측정이 비활성화 된 경우이 방법은 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="97aef73764a8b235d11df488cc792228726de005" translate="yes" xml:space="preserve">
          <source>If the time '23:59:60' is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return &lt;code&gt;true&lt;/code&gt; if it did adjust to remove the leap-second, and &lt;code&gt;false&lt;/code&gt; if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:</source>
          <target state="translated">'23 : 59 : 60 '시간이 수신되면 간단한 변환이 적용되어 분의 초를 60으로 59로 바꿉니다.이 쿼리는 구문 분석 결과에 사용하여 윤초 조정 여부를 판별 할 수 있습니다. 만든. 쿼리는 윤초를 제거하도록 조정 한 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. UTC-SLS와 같은 윤초 평활 메커니즘을 적용하는 것은 다음과 같이 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6ae6878cfd3b1d0ceb5a94fe0301dc8e364dcc4f" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 제한이 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 의 제한 시간이 변경 될 때마다 제한 시간을 초과하는 세션을 점검합니다 .</target>
        </trans-unit>
        <trans-unit id="ad1adddf8356c433278ef7cd10d12a5f2bd6c761" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout limit is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 한계가 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 에 대해 시간 종료 한계가 변경 될 때마다 시간 종료 한계를 초과하는 세션이 즉시 점검됩니다 .</target>
        </trans-unit>
        <trans-unit id="44775d676f01ccf28f57333e6fb89f1c12f0cfd6" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date and the notification is delivered immediately.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 동작하며 알림이 즉시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8056b6ccedf3aca7fb9d63268e271ee88e090cd9" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f7ed1fef67b3c31fe3734b8ae38aa892bb880b72" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date. The first notification is delivered immediately and the subsequent ones are spaced as specified by the period parameter.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다. 첫 번째 알림은 즉시 전달되고 후속 알림은 period 매개 변수에 지정된 간격으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="38b2e2e16267baf4e1e54405bd70137ca888e8ed" translate="yes" xml:space="preserve">
          <source>If the timer's task execution thread terminates unexpectedly, for example, because its &lt;code&gt;stop&lt;/code&gt; method is invoked, any further attempt to schedule a task on the timer will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;, as if the timer's &lt;code&gt;cancel&lt;/code&gt; method had been invoked.</source>
          <target state="translated">예를 들어, &lt;code&gt;stop&lt;/code&gt; 메소드가 호출 되어 타이머의 태스크 실행 스레드가 예기치 않게 종료되면 타이머에서 태스크 를 스케줄하려고 하면 타이머의 &lt;code&gt;cancel&lt;/code&gt; 메소드가 호출 된 것처럼 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3591693d15d3e4209a0731ba617c073e32bb40" translate="yes" xml:space="preserve">
          <source>If the transformer throws an exception (which it doesn't catch), subsequent transformers will still be called and the load, redefine or retransform will still be attempted. Thus, throwing an exception has the same effect as returning &lt;code&gt;null&lt;/code&gt;. To prevent unexpected behavior when unchecked exceptions are generated in transformer code, a transformer can catch &lt;code&gt;Throwable&lt;/code&gt;. If the transformer believes the &lt;code&gt;classFileBuffer&lt;/code&gt; does not represent a validly formatted class file, it should throw an &lt;code&gt;IllegalClassFormatException&lt;/code&gt;; while this has the same effect as returning null. it facilitates the logging or debugging of format corruptions.</source>
          <target state="translated">변압기에 예외가 발생하더라도 (포착되지 않는) 후속 변압기가 계속 호출되고로드, 재정의 또는 재 변환이 계속 시도됩니다. 따라서 예외를 throw하면 &lt;code&gt;null&lt;/code&gt; 을 반환하는 것과 같은 효과가 있습니다. 확인되지 않은 예외가 변환기 코드에서 생성 될 때 예기치 않은 동작을 방지하기 위해 변환기는 &lt;code&gt;Throwable&lt;/code&gt; 을 포착 할 수 있습니다 . 변환기가 &lt;code&gt;classFileBuffer&lt;/code&gt; 가 올바른 형식의 클래스 파일을 나타내지 않는다고 생각 하면 &lt;code&gt;IllegalClassFormatException&lt;/code&gt; 을 발생 시켜야합니다 . null을 반환하는 것과 같은 효과가 있습니다. 형식 손상의 로깅 또는 디버깅을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="cac1823b4d109a58d8c15953a4c53e9282211329" translate="yes" xml:space="preserve">
          <source>If the type is &lt;code&gt;null&lt;/code&gt;, a shared internal persistence delegate is returned that encodes &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">유형이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;null&lt;/code&gt; 값 을 인코딩하는 공유 내부 지속성 대리자가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="24624d93ce0bd52bd62b61c2d340c4e06907a0dd" translate="yes" xml:space="preserve">
          <source>If the type is a &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">형식이 &lt;code&gt;enum&lt;/code&gt; 선언 인 경우이 열거의 상수를 이름으로 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="17c7dfdd306d9dca345cd59fbb286fb56494c02b" translate="yes" xml:space="preserve">
          <source>If the type is a primitive type or the corresponding wrapper, a shared internal persistence delegate is returned that encodes values of the given type.</source>
          <target state="translated">유형이 기본 유형 또는 해당 랩퍼 인 경우, 주어진 유형의 값을 인코딩하는 공유 내부 지속성 대리자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7266e7d4fe52b4f4bd2947e2022cc33489854699" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유형이 프록시 인 경우 &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt; 를 사용하여 프록시 인스턴스를 인코딩하는 공유 내부 지속성 위임이 리턴됩니다. ) 방법.</target>
        </trans-unit>
        <trans-unit id="6d791c963ef8e6e2b0fde7ef89bca6d1754b00b4" translate="yes" xml:space="preserve">
          <source>If the type is an array, a shared internal persistence delegate is returned that encodes an array of the appropriate type and length, and each of its elements as if they are properties.</source>
          <target state="translated">유형이 배열 인 경우 적절한 유형 및 길이의 배열과 각 요소가 마치 속성 인 것처럼 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99f690abde7ac9507cafcabd4eb11b9f675436cc" translate="yes" xml:space="preserve">
          <source>If the type of the underlying field is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">기본 필드의 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="66b62dfc82fc14777b26e50687d5b79596a57206" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">기본 클래스가 배열 클래스 인 경우 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 수정자는 해당 구성 요소 유형과 동일합니다. 이 &lt;code&gt;Class&lt;/code&gt; 가 원시적 형 또는 void를 나타내는 경우, 그 &lt;code&gt;public&lt;/code&gt; 수식자는 항상 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 수식자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 이 객체가 배열 클래스, 프리미티브 유형 또는 void를 나타내는 경우, &lt;code&gt;final&lt;/code&gt; 수정자는 항상 &lt;code&gt;true&lt;/code&gt; 이고 인터페이스 수정자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 다른 수정 자의 값은이 사양에 의해 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6635d2c90407f220bf7ecba5d59930986096dac" translate="yes" xml:space="preserve">
          <source>If the underlying field is a static field, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본 필드가 정적 필드 인 경우 &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e60b6593bad05aa260e774035853633abadd33" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt; unless &lt;code&gt;setAccessible(true)&lt;/code&gt; has succeeded for this &lt;code&gt;Field&lt;/code&gt; object and the field is non-static. Setting a final field in this way is meaningful only during deserialization or reconstruction of instances of classes with blank final fields, before they are made available for access by other parts of a program. Use in any other context may have unpredictable effects, including cases in which other parts of a program continue to use the original value of this field.</source>
          <target state="translated">기본이되는 필드가 final의 경우, 이 &lt;code&gt;Field&lt;/code&gt; 오브젝트에 대해 &lt;code&gt;setAccessible(true)&lt;/code&gt; 가 성공 해 필드가 static이 아닌 경우 , 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw합니다 . 이 방법으로 최종 필드를 설정하는 것은 프로그램의 다른 부분에서 액세스 할 수있게되기 전에 빈 최종 필드가있는 클래스의 인스턴스를 역 직렬화 또는 재구성하는 동안에 만 의미가 있습니다. 다른 상황에서 사용하면 프로그램의 다른 부분이이 필드의 원래 값을 계속 사용하는 경우를 포함하여 예측할 수없는 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ffdb31707c7c6f0d8ea54510f297f85f678ae3" translate="yes" xml:space="preserve">
          <source>If the underlying field is of a primitive type, an unwrapping conversion is attempted to convert the new value to a value of a primitive type. If this attempt fails, the method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">기본 필드가 기본 유형 인 경우 랩핑 해제 변환은 새 값을 기본 유형의 값으로 변환하려고 시도합니다. 이 시도가 실패하면, 메소드는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="35c398b7568f2f6829527a1ee4e8ad05ab589757" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본이되는 필드가 정적 인 경우, &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79473e9ad073a8c2b30d02714d81cdc8e02b2e5d" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">기본 필드가 정적이면 필드를 선언 한 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c2e8ba35ddb7d491a4530be7e2d58c63b91b804" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">기본 메소드가 &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;호출자 구분&lt;/a&gt; 인 경우 직접 메소드 핸들은 특정 호출자 클래스, 이를 작성하는 데 사용되는 찾아보기 오브젝트 의 찾아 &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;보기 클래스&lt;/a&gt; 에 &quot;바인드&quot;됩니다 . 기본 메소드가 공용 인 경우에도 ( &lt;code&gt;Class.forName&lt;/code&gt; 과 같은 ) 다른 조회 클래스로이 메소드 핸들을 크래킹하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="315e1d5687f0be0717ab38a86bf5bdc38d92fd67" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, Second Edition, section 15.12.4.4; in particular, overriding based on the runtime type of the target object will occur.</source>
          <target state="translated">기본 메소드가 인스턴스 메소드 인 경우 The Java Language Specification, Second Edition, 섹션 15.12.4.4에 설명 된대로 동적 메소드 조회를 사용하여 호출됩니다. 특히 대상 객체의 런타임 유형에 따라 재정의가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1fdc5865953923b940ef228e2839e6291e6d1529" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, the class that declared the method is initialized if it has not already been initialized.</source>
          <target state="translated">기본 메소드가 정적 인 경우 메소드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5417f1946175b0c601b43e5b5d82e2dfa1a39a1f" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, then the specified &lt;code&gt;obj&lt;/code&gt; argument is ignored. It may be null.</source>
          <target state="translated">기본 메소드가 정적이면 지정된 &lt;code&gt;obj&lt;/code&gt; 인수가 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2221ca8e8e96c757d1acb4e9dea9f2b5398db497" translate="yes" xml:space="preserve">
          <source>If the unit is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported units are:</source>
          <target state="translated">단위가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. 지원되는 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd8d281301aa1d20e9a67171d9933765d4124562" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하는 것에 의해 획득된다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 전달하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="6f71bc9db5b6219e1ae283e954d88ba321dd8591" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument and the converted input temporal as the second argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; 호출함으로써 얻어지는,이 방법의 다음 결과 &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; 통과하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인수와 두 번째 인수로 변환 된 입력 시간있다.</target>
        </trans-unit>
        <trans-unit id="66bc82b1dd235049a5511719d85e81950af05fd7" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the unit is supported is determined by the unit.</source>
          <target state="translated">단위가 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 아닌 경우, &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 를 호출 하여 인수로 전달 &lt;code&gt;this&lt;/code&gt; 메소드의 결과를 얻습니다 . 장치가 지원되는지 여부는 장치에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="20661569ddc05848e0dfeb41e06e5676e4ccca6a" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;'1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ) 및 &lt;code&gt;'1'&lt;/code&gt; ( &lt;code&gt;'\u0031'&lt;/code&gt; )은 이진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c10c42689b734462a910f9cd90fb2d17103287f1" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as hexadecimal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 16 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f07ca050a4a81c4b683387f3c53d9089c379035d" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as octal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 8 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6714e942d1212dc9686ac25a627707c330ee39" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user. A typical basic usage of this method may be :</source>
          <target state="translated">사용자가 대화 상자를 취소하면 반환 된 속성에 사용자가 변경 한 내용이 반영되지 않습니다. 이 방법의 일반적인 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a3ff22bd71bfe0f9cb8dffa032e252c7a72a011" translate="yes" xml:space="preserve">
          <source>If the user provides an &lt;code&gt;RMIServerImpl&lt;/code&gt; rather than a &lt;code&gt;JMXServiceURL&lt;/code&gt;, then the generated &lt;code&gt;JMXServiceURL&lt;/code&gt; will have the local host name in its &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; part and no &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 가 &lt;code&gt;JMXServiceURL&lt;/code&gt; 대신 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 제공하면 생성 된 &lt;code&gt;JMXServiceURL&lt;/code&gt; 은 &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; 부분 에 로컬 호스트 이름을 가지며 &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 없습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="790177d5a2da0339061b07b0e2796a63d5c7bba4" translate="yes" xml:space="preserve">
          <source>If the user wants to represent more complex relations, involving properties and/or methods, he has to provide his own class implementing the Relation interface. This can be achieved either by inheriting from RelationSupport class, or by implementing the interface (fully or delegation to a RelationSupport object member).</source>
          <target state="translated">사용자가 속성 및 / 또는 메서드와 관련하여보다 복잡한 관계를 나타내려면 Relation 인터페이스를 구현하는 고유 한 클래스를 제공해야합니다. 이는 RelationSupport 클래스에서 상속하거나 인터페이스를 구현하거나 (RelationSupport 개체 멤버에 대한 전체 또는 위임) 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d22c3736384d8f57852c160122995e97ee6f65b" translate="yes" xml:space="preserve">
          <source>If the value cannot be obtained then an exception will be thrown. If the value is negative an exception will be thrown. If the field does not have a fixed set of valid values then an exception will be thrown. If the field value in the date-time to be printed is invalid it cannot be printed and an exception will be thrown.</source>
          <target state="translated">값을 얻을 수 없으면 예외가 발생합니다. 값이 음수이면 예외가 발생합니다. 필드에 고정 된 유효한 값 세트가 없으면 예외가 발생합니다. 인쇄 할 날짜-시간의 필드 값이 유효하지 않으면 인쇄 할 수 없으며 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ee0cd8b8e0f022dac140b1064202354f2993085" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">지정된 키의 값이 존재하고 널이 아닌 경우 키와 현재 맵핑 된 값이 주어지면 새 맵핑을 계산하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4b761882d9981acf5026d5923e5e847a58120eb7" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 간단하고 단순해야하며이 맵의 다른 매핑을 업데이트하려고하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f3db5a9e74f7891f194526ea0f347239e63fa2ef" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 이 기능은 원자 적으로 한 번만 적용되는 것은 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76a62dcfb0cff96625fd935bd1e2f63de3a120f6" translate="yes" xml:space="preserve">
          <source>If the value is 0, this means to wait indefinitely.</source>
          <target state="translated">값이 0이면 무기한 대기한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="301076cf0d84829c80ed3ada45bc0a362fb8a4d9" translate="yes" xml:space="preserve">
          <source>If the value is NaN or infinite, the literal strings &quot;NaN&quot; or &quot;Infinity&quot;, respectively, will be output.</source>
          <target state="translated">값이 NaN 또는 무한이면 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ab06ef8615a9271c661fe8e0122f8b8d95f1110e" translate="yes" xml:space="preserve">
          <source>If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or &quot;Infinity&quot; respectively, will be output. If the value is negative infinity, then the output will be &quot;(Infinity)&quot; if the &lt;code&gt;'('&lt;/code&gt; flag is given otherwise the output will be &quot;-Infinity&quot;. These values are not localized.</source>
          <target state="translated">값이 NaN 또는 양의 무한대 인 경우 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다. 값이 음의 무한대이면 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공 되면 출력은 &quot;(무한대)&quot;가되고 그렇지 않으면 출력은 &quot;-무한대&quot;가됩니다 .이 값은 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8386f5e063110a495ec4902ded50dbabab418fe" translate="yes" xml:space="preserve">
          <source>If the value is negative (or floating-point negative zero) and &lt;code&gt;'('&lt;/code&gt; flag is not given, then a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;) is prepended.</source>
          <target state="translated">값이 음수 (또는 부동 소수점 음수 0)이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되지 않은 경우 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="6f6d817a3f4c5b41b572c9b2e4daf5c4281d9fee" translate="yes" xml:space="preserve">
          <source>If the value is negative and the &lt;code&gt;'('&lt;/code&gt; flag is given, then a &lt;code&gt;'('&lt;/code&gt; (&lt;code&gt;'\u0028'&lt;/code&gt;) is prepended and a &lt;code&gt;')'&lt;/code&gt; (&lt;code&gt;'\u0029'&lt;/code&gt;) is appended.</source>
          <target state="translated">값이 음수이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되면 &lt;code&gt;'('&lt;/code&gt; ( &lt;code&gt;'\u0028'&lt;/code&gt; )이 앞에 붙고 &lt;code&gt;')'&lt;/code&gt; ( &lt;code&gt;'\u0029'&lt;/code&gt; )이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79c5db2353984efc6cb7e1c18940f5eb527e5ef9" translate="yes" xml:space="preserve">
          <source>If the value is negative, then it represents the number of days back from the end of the month where &lt;code&gt;-1&lt;/code&gt; is the last day of the month. In this case, the day identified is the latest possible date that the transition can be.</source>
          <target state="translated">값이 음수 인 경우, 월이 끝났을 때부터 일 수를 나타냅니다. 여기서 &lt;code&gt;-1&lt;/code&gt; 은 월 의 마지막 날입니다. 이 경우 식별 된 날짜는 전환이 가능한 최신 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="a89c880bd0c92196eb9e203f110acd320c2580c9" translate="yes" xml:space="preserve">
          <source>If the value is positive, then it represents a normal day-of-month, and is the earliest possible date that the transition can be. The date may refer to 29th February which should be treated as 1st March in non-leap years.</source>
          <target state="translated">값이 양수이면 정상 일을 나타내며 전환이 가능한 가장 빠른 날짜입니다. 날짜는 2 월 29 일을 의미 할 수 있으며 이는 윤년이 아닌 경우 3 월 1 일로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3334ef34b1cd3c138c012c02960e8363c7beb397" translate="yes" xml:space="preserve">
          <source>If the value is set to &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8a25b68c044cd0c1ec4edc8c60c29d6185e1c049" translate="yes" xml:space="preserve">
          <source>If the value of a field is not a String, then the toString() method will be called on it and the returned value, enclosed in parentheses, used as the value for the field in the returned array. If the value of a field is null, then the value of the field in the returned array will be empty. If the descriptor is empty, you will get an empty array.</source>
          <target state="translated">필드의 값이 문자열이 아닌 경우 toString () 메소드가 호출되고 괄호로 묶인 리턴 값이 리턴 된 배열의 필드 값으로 사용됩니다. 필드 값이 null이면 반환 된 배열의 필드 값이 비어 있습니다. 디스크립터가 비어 있으면 빈 배열을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="3c88da9b0c956884891afc187b29ac9d1d3914af" translate="yes" xml:space="preserve">
          <source>If the value of that system property is not &lt;code&gt;null&lt;/code&gt;, it is interpreted as a list of packages separated by a vertical slash character '&lt;code&gt;|&lt;/code&gt;'. The constructor tries to load the class named:</source>
          <target state="translated">이 시스템 프로퍼티의 값이없는 경우 &lt;code&gt;null&lt;/code&gt; 패키지 목록은 수직 슬래시 문자 '로 구분으로,이 해석 &lt;code&gt;|&lt;/code&gt; '. 생성자가 이름이 지정된 클래스를로드하려고합니다.</target>
        </trans-unit>
        <trans-unit id="189b2a483106b850cb5a3377c0425a501b7adcff" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;len&lt;/code&gt; parameter is negative then no characters are written. This is contrary to the specification of this method in the &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;superclass&lt;/a&gt;, which requires that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 매개 변수 의 값 이 음수이면 문자가 작성되지 않습니다. 이것은 &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;수퍼 클래스&lt;/a&gt; 에서이 메소드의 스펙과 상반 되므로 &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt; 이 발생 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3351a4cf5b5a7a09cdd906eb6fad0d706861c179" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the PENDING_HELD state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">이 속성 값이 미래의 날짜 시간을 지정하는 경우 프린터는 JOB_HOLD_UNTIL_SPECIFIED 의 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값을 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하고 작업을 PENDING_HELD 상태로 이동해야하며 인쇄 작업을 예약하지 않아야합니다. 지정된 날짜-시간이 도착합니다.</target>
        </trans-unit>
        <trans-unit id="fa55bedef91ce7d9c1fec0b52fe91e9615e15668" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it. The result of the method invocation is first copied into the value property of this expression and then returned as the result of &lt;code&gt;getValue&lt;/code&gt;. If the value property was already set, either by a call to &lt;code&gt;setValue&lt;/code&gt; or a previous call to &lt;code&gt;getValue&lt;/code&gt; then the value property is returned without either looking up or calling the method.</source>
          <target state="translated">이 인스턴스의 value 속성이 아직 설정되지 않은 경우이 메서드는이 인수를 사용하여이 대상에서 지정된 methodName이있는 메서드를 동적으로 찾아 호출합니다. 메소드 호출의 결과는 &lt;code&gt;getValue&lt;/code&gt; 표현식의 value 특성에 복사 된 후 getValue 의 결과로 리턴됩니다 . &lt;code&gt;setValue&lt;/code&gt; 에 대한 호출 또는 &lt;code&gt;getValue&lt;/code&gt; 에 대한 이전 호출에 의해 값 특성이 이미 설정된 경우 값 특성은 메소드를 찾거나 호출하지 않고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f8f305677180b918ee9ef198861d8afd741517" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in RFC 2253 or ASN.1 DER encoded form, respectively). Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우는 이름 의 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 (각각 RFC 2253 또는 ASN.1 DER로 인코딩 된 형식). 반환 된 &lt;code&gt;Collection&lt;/code&gt; 에 중복 된 이름이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d32dd70eeac4617e75643e7232c7906050d5b2bd" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 이는 pathToNames 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 에 중복 이름 (같은 이름 및 이름 유형)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26bd3763c8755d23c2f1916d343c204ac5aaffe" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, 주제 대체 이름 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 에 중복 이름 (같은 이름 및 이름 유형)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2adc8f493111a0124aaa2df328143a9d50bda6b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 문서에 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bfe0070c603a52728ff84ece5362c0b7ddae9b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce45de7cc21b8ac51cf0ba8fa224985e1d61a9e9" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a distinguished name, in RFC 2253 format.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우는 RFC 2253 형식의 식별 명입니다.</target>
        </trans-unit>
        <trans-unit id="5b8d5b4ce751bcbd27dc2db355066e723ecb44dc" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a unmodifiable &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 가 아닌 경우, 수정 불가능한 &lt;code&gt;X500Principal&lt;/code&gt; &lt;code&gt;Collection&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="bde030a57b155127406abe290ea916c308394ff9" translate="yes" xml:space="preserve">
          <source>If the voice is not currently processing a MIDI note, it is considered inactive. A voice is inactive when it has been given no note-on commands, or when every note-on command received has been terminated by a corresponding note-off (or by an &quot;all notes off&quot; message). For example, this happens when a synthesizer capable of playing 16 simultaneous notes is told to play a four-note chord; only four voices are active in this case (assuming no earlier notes are still playing). Usually, a voice whose status is reported as active is producing audible sound, but this is not always true; it depends on the details of the instrument (that is, the synthesis algorithm) and how long the note has been going on. For example, a voice may be synthesizing the sound of a single hand-clap. Because this sound dies away so quickly, it may become inaudible before a note-off message is received. In such a situation, the voice is still considered active even though no sound is currently being produced.</source>
          <target state="translated">음성이 현재 MIDI 음표를 처리하지 않으면 비활성 상태로 간주됩니다. 음성 명령에 메모 명령이 없거나 수신 된 모든 메모 명령이 해당 메모에 의해 (또는 &quot;모든 메모 꺼짐&quot;메시지에 의해 종료 된 경우) 음성이 비활성화됩니다. 예를 들어, 16 개의 동시 음표를 연주 할 수있는 신시사이저에 4 음표를 연주하도록 지시 할 때 발생합니다. 이 경우 4 개의 음색 만 활성화됩니다 (이전의 음표가 여전히 재생되지 않는다고 가정). 일반적으로 상태가 활성으로보고 된 음성은 소리를 내고 있지만 항상 그런 것은 아닙니다. 악기의 세부 사항 (즉, 합성 알고리즘)과 음이 얼마나 오래 진행되었는지에 따라 다릅니다. 예를 들어, 음성은 단일 핸드 박수 소리를 합성 할 수 있습니다. 이 소리는 너무 빨리 사라져서메모 메시지가 수신되기 전에 들리지 않을 수 있습니다. 이러한 상황에서 소리가 현재 생성되지 않더라도 음성은 여전히 ​​활성 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="653f1f40cfb615ca17661dd80259d388f697bee1" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드가 쓰기 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0805140ae31a0f4050f9a4cfea06b4f470819eca" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the write lock hold count is set to one.</source>
          <target state="translated">쓰기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a07048d034065274e4ede5c8a84bad27f47aabea" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="74ef7c44b070eb1cc369e6589e8a1122f0468708" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4fbef50e47f6976d0537a04edb35c78320ba5006" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the read lock has been acquired.</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 읽기 잠금이 획득 될 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="30ab94fb63654ae631cd1d744ae39fbebb43dde7" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">쓰기 스레드가 다른 스레드에 의해 유지되면이 메소드는 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7ef816b7e6153a6a58cc075b78ddfa153cbea13c" translate="yes" xml:space="preserve">
          <source>If the writer only offers a single, mandatory form of compression, it is not necessary to provide any named compression types. Named compression types should only be used where the user is able to make a meaningful choice between different schemes.</source>
          <target state="translated">기록기가 단일의 필수 압축 형식 만 제공하는 경우 명명 된 압축 유형을 제공 할 필요가 없습니다. 명명 된 압축 유형은 사용자가 다른 체계 중에서 의미있는 선택을 할 수있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7cb2436b74f4b1b03e972c41f1699a7b257b5b16" translate="yes" xml:space="preserve">
          <source>If the zone ID consists of a single letter, the zone ID is invalid and &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역 ID가 단일 문자로 구성된 경우 영역 ID가 유효하지 않고 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06d35c94a78d00be0bce80775b09f94dc2815e57" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a &lt;code&gt;ZoneId&lt;/code&gt; with the same ID and rules equivalent to &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'GMT', 'UTC'또는 'UT'인 경우 결과는 동일한 ID 및 규칙 이 &lt;code&gt;ZoneId&lt;/code&gt; 와 동일한 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7be309d5b31d6d9fd94ee00c0bd12eacb646dab8" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'Z', the result is &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'Z'인 경우 결과는 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87e6092693d13cc8dfc7ff32db6b3e49ec91630a" translate="yes" xml:space="preserve">
          <source>If the zone ID is a &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;, then the result always has a time of midnight.</source>
          <target state="translated">영역 ID가 &lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt; 이면 결과는 항상 자정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4b48da9c9e601217a4f5ae92f654428afda6e1aa" translate="yes" xml:space="preserve">
          <source>If the zone ID is not available or is a &lt;code&gt;ZoneOffset&lt;/code&gt; then the format is complete.</source>
          <target state="translated">영역 ID를 사용할 수 없거나 &lt;code&gt;ZoneOffset&lt;/code&gt; 인 경우 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="87677aa24c82d7da48f53ccb0c5b3d24a805cbe9" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">'-'영역 ID는 '+'또는 시작하는 경우,이 ID로서 해석된다 &lt;code&gt;ZoneOffset&lt;/code&gt; 하여 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1780773eff7ca92ecd4ba03a3e8ea655fd0b8589" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'UTC +', 'UTC-', 'GMT +', 'GMT-', 'UT +'또는 'UT-'로 시작하면 ID는 접두사 오프셋 기반 ID입니다. ID는 2 개 또는 3 개의 문자 접두사와 부호로 시작하는 접미사와 함께 2 개로 분할됩니다. 접미사는 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 으로&lt;/a&gt; 구문 분석됩니다 . 결과는 것이다 &lt;code&gt;ZoneId&lt;/code&gt; 따라 지정된 UTC / GMT / UT 프리픽스 및 정규화 옵셋 ID와 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt; . 반환 된 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙은 구문 분석 된 &lt;code&gt;ZoneOffset&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="41b8bc898e51c548630ae4313953f5a0179fbf8d" translate="yes" xml:space="preserve">
          <source>If the zone cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">영역을 구문 분석 할 수없는 경우 포맷터 섹션이 선택 사항이 아닌 한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="716de69875ef09bdf51d065ceec30a6b7a11919e" translate="yes" xml:space="preserve">
          <source>If the zone defines daylight savings into the future, then the list will normally be of size two and hold information about entering and exiting daylight savings. If the zone does not have daylight savings, or information about future changes is uncertain, then the list will be empty.</source>
          <target state="translated">영역이 일광 절약 시간을 미래로 정의하는 경우 일반적으로 목록의 크기는 2이며 일광 절약 입력 및 종료에 대한 정보를 보유합니다. 영역에 일광 절약 시간이 없거나 향후 변경에 대한 정보가 확실하지 않은 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a223a21923ebbbeb7ae1d7b22472f2e489ded7a7" translate="yes" xml:space="preserve">
          <source>If there are any calendar fields whose values haven't been set in the selected field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default value of each field may vary by concrete calendar systems. For example, in &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
 JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.</source>
          <target state="translated">그 선택한 필드의 편성으로 값이 설정되어 있지 않은 달력 필드가있는 경우, &lt;code&gt;Calendar&lt;/code&gt; 기본 값을 사용합니다. 각 필드의 기본값은 구체적인 달력 시스템에 따라 달라질 수 있습니다. 예를 들어, &lt;code&gt;GregorianCalendar&lt;/code&gt; 에서 필드의 기본값은 Epoch의 시작과 동일합니다 (예 : &lt;code&gt;YEAR = 1970&lt;/code&gt; , &lt;code&gt;MONTH = JANUARY&lt;/code&gt; , &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="e1f64fb5716e07724c0a7d48c0a02647c58da231" translate="yes" xml:space="preserve">
          <source>If there are conflicts or overlaps between the information provided by different &lt;code&gt;BeanInfo&lt;/code&gt; objects, the current &lt;code&gt;BeanInfo&lt;/code&gt; object takes priority over the additional &lt;code&gt;BeanInfo&lt;/code&gt; objects. Array elements with higher indices take priority over the elements with lower indices.</source>
          <target state="translated">다른 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 제공하는 정보간에 충돌이 있거나 겹치는 경우 현재 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 추가 &lt;code&gt;BeanInfo&lt;/code&gt; 객체 보다 우선 합니다. 지수가 높은 배열 요소는 지수가 낮은 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="530a00d062bd6f003dc671b04ddaa979158f274f" translate="yes" xml:space="preserve">
          <source>If there are different resources for different countries, you can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for the German language (de) in Switzerland (CH). If you want to only modify some of the resources in the specialization, you can do so.</source>
          <target state="translated">국가별로 다른 리소스가있는 경우 전문화를 수행 할 수 있습니다. 예를 들어 &quot;MyResources_de_CH&quot;에는 스위스 (CH)의 독일어 (de)에 대한 개체가 포함되어 있습니다. 전문화 과정에서 일부 리소스 만 수정하려는 경우 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a003779b8a649ef8cb40c3f51dd00ab52590b8c" translate="yes" xml:space="preserve">
          <source>If there are more arguments than format specifiers, the extra arguments are ignored.</source>
          <target state="translated">형식 지정자보다 많은 인수가 있으면 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="deb195b2b9fae2539cd1155fb241509f69b8a781" translate="yes" xml:space="preserve">
          <source>If there are multiple compression types but none has been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">여러 압축 유형이 있지만 설정되지 않은 경우 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="768dcb3e70295dbb108fd5dd725293766667ea22" translate="yes" xml:space="preserve">
          <source>If there are multiple runs of text, information about the runs can be accessed by indexing to get the start, limit, and level of a run. The level represents both the direction and the 'nesting level' of a directional run. Odd levels are right-to-left, while even levels are left-to-right. So for example level 0 represents left-to-right text, while level 1 represents right-to-left text, and level 2 represents left-to-right text embedded in a right-to-left run.</source>
          <target state="translated">여러 개의 텍스트 실행이있는 경우 인덱스를 통해 실행에 대한 정보에 액세스하여 실행의 시작, 제한 및 레벨을 얻을 수 있습니다. 레벨은 방향 달리기의 방향과 '중첩 레벨'을 모두 나타냅니다. 홀수 레벨은 오른쪽에서 왼쪽이며, 짝수 레벨은 왼쪽에서 오른쪽입니다. 예를 들어, 레벨 0은 왼쪽에서 오른쪽으로 텍스트를 나타내고, 레벨 1은 오른쪽에서 왼쪽으로 텍스트를 나타내고, 레벨 2는 오른쪽에서 왼쪽으로 실행되는 임베디드 왼쪽에서 오른쪽 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3fd8782c948e6644afcfe2c7b88c23640ca646b" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가없고 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; 를&lt;/a&gt; 사용하여 소켓을 닫지 않은 경우 &lt;a href=&quot;../io/inputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="70808ff13ea15a635fe9933aa430b40622465ff0" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가 없거나 모든 버퍼링 된 바이트가 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 에 의해 소비 된 경우 , 모든 후속 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d97fea5e3b07fef354727bb8ea01358071cedc12" translate="yes" xml:space="preserve">
          <source>If there are no fields in the descriptor, then an empty String is returned.</source>
          <target state="translated">디스크립터에 필드가 없으면 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="452463b6bb8122e8d19b3e5165c3baa6dd891166" translate="yes" xml:space="preserve">
          <source>If there are no originating elements, none need to be passed. This information may be used in an incremental environment to determine the need to rerun processors or remove generated files. Non-incremental environments may ignore the originating element information.</source>
          <target state="translated">원래 요소가 없으면 전달할 필요가 없습니다. 이 정보는 증분 환경에서 프로세서를 다시 실행하거나 생성 된 파일을 제거해야 할 필요성을 판별하는 데 사용될 수 있습니다. 비 증분 환경은 원래 요소 정보를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1b6e296a2b77ef070997fd74f624d1c0686a93" translate="yes" xml:space="preserve">
          <source>If there are no parameters, no formatter is used.</source>
          <target state="translated">매개 변수가 없으면 포맷터가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="256816c6b5677c8691bdb94b6765ccbc5f24a09f" translate="yes" xml:space="preserve">
          <source>If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions. In any case, every &lt;code&gt;invokedynamic&lt;/code&gt; instruction is either unlinked or linked to a unique &lt;code&gt;CallSite&lt;/code&gt; object.</source>
          <target state="translated">그러한 스레드가 여러 개인 경우 부트 스트랩 메소드가 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 전역 응용 프로그램 데이터에 액세스하는 부트 스트랩 방법은 경쟁 조건에 대해 일반적인 예방 조치를 취해야합니다. 어쨌든 모든 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어는 연결이 해제되거나 고유 한 &lt;code&gt;CallSite&lt;/code&gt; 객체에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="19df7c3245481a0b870f8b690f97116f667d21a7" translate="yes" xml:space="preserve">
          <source>If there are specialization prefixes for all arguments, the arity prefix may be left out (as in &lt;a href=&quot;objintconsumer&quot;&gt;&lt;code&gt;ObjIntConsumer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 인수에 특수 접두사가있는 경우, &lt;a href=&quot;objintconsumer&quot;&gt; &lt;code&gt;ObjIntConsumer&lt;/code&gt; &lt;/a&gt; 에서와 같이 arity 접 두부가 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5496a27b9238a94964b622c624cac4a711b3706d" translate="yes" xml:space="preserve">
          <source>If there are two sets of quotes, a specific begin-quote must be matched by its corresponding end-quote.</source>
          <target state="translated">인용 부호가 두 개인 경우 특정 시작 인용 부호를 해당 종료 인용 부호와 일치시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="60fe5e1f14261b51420b2f4800ed45295f2b7b43" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Filter&lt;/code&gt;, its &lt;code&gt;isLoggable&lt;/code&gt; method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record's level property is compared with the &lt;code&gt;pushLevel&lt;/code&gt;. If the given level is greater than or equal to the &lt;code&gt;pushLevel&lt;/code&gt; then &lt;code&gt;push&lt;/code&gt; is called to write all buffered records to the target output &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; 가있는 경우, 주어진 로그 레코드가 로그 가능한지 확인하기 위해 &lt;code&gt;isLoggable&lt;/code&gt; 메소드가 호출됩니다. 그렇지 않으면 우리는 돌아온다. 그렇지 않으면 주어진 레코드가 내부 순환 버퍼에 복사됩니다. 그런 다음 레코드의 레벨 특성이 &lt;code&gt;pushLevel&lt;/code&gt; 과 비교됩니다 . 주어진 레벨이 이상인 경우 &lt;code&gt;pushLevel&lt;/code&gt; 다음 &lt;code&gt;push&lt;/code&gt; 목표 출력 버퍼 된 모든 레코드를 작성라고 &lt;code&gt;Handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a6d33db9099e5da02b63b1c08b711314ed1070" translate="yes" xml:space="preserve">
          <source>If there is a current output stream then the &lt;code&gt;Formatter&lt;/code&gt;'s tail string is written and the stream is flushed and closed. Then the output stream is replaced with the new output stream.</source>
          <target state="translated">현재 출력 스트림이 있으면 &lt;code&gt;Formatter&lt;/code&gt; 의 꼬리 문자열이 기록되고 스트림이 플러시되고 닫힙니다. 그런 다음 출력 스트림이 새 출력 스트림으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="360eb0e694f70b9c0d8a6d2539b8b95168589f9b" translate="yes" xml:space="preserve">
          <source>If there is a language tag which matches completely to a language range above, the language tag is returned.</source>
          <target state="translated">위의 언어 범위와 완전히 일치하는 언어 태그가 있으면 언어 태그가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9d5f4f323a99adea908fdeaf0c559a2234dc4" translate="yes" xml:space="preserve">
          <source>If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied.</source>
          <target state="translated">주체에게 특정 권한을 부여하는 긍정적 인 항목과 주체에게 동일한 권한을 거부하는 부정적 항목이 있으면 결과는 권한이 부여되거나 거부되지 않은 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7d2642219ae6689a90935a889cec5cc47e6b73a4" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; permission to ensure it's ok to replace the existing security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어있는 경우이 메소드는 먼저 기존 보안 관리자를 대체 할 수 있도록 &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다 . 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34d939280196d74fc1d1d34c5817d26280f87f75" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; permission to ensure the calling thread has permission to create a new security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어 있으면이 메소드는 먼저 &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 호출 스레드에 새 보안 관리자를 작성할 수있는 권한이 있는지 확인합니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5672428ce2d0310db13a3f85f67e993338e8598a" translate="yes" xml:space="preserve">
          <source>If there is a security manager and &lt;code&gt;host&lt;/code&gt; is not null and &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가 있고 &lt;code&gt;host&lt;/code&gt; 가 널이 &lt;code&gt;host.length() &lt;/code&gt; 가 0이 아닌 경우, 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호스트 이름 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd5ff852f368770ab762748f1c19d1dda73aa1db" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, it can forbid the lookup on various grounds (&lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;see below&lt;/a&gt;). By contrast, the &lt;code&gt;ldc&lt;/code&gt; instruction on a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant is not subject to security manager checks.</source>
          <target state="translated">보안 관리자가 설치되어 있으면 다양한 이유로 조회를 금지 할 수 있습니다 ( &lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;아래 참조&lt;/a&gt; ). 반대로 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수 의 &lt;code&gt;ldc&lt;/code&gt; 명령어 는 보안 관리자 검사를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b156cc02a90506f8eb9b81ce87ad4e2f4f5e01f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with &lt;code&gt;this&lt;/code&gt; as its argument. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</source>
          <target state="translated">설치 보안 매니저가 존재하는 경우, 그 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출되어 &lt;code&gt;this&lt;/code&gt; 인수로. 이로 인해 현재 스레드에서 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5128105dcb411eeec7bd98eb31dc6c9f32f36396" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우,이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="31761f6c70fa775cd9eb51012f53c8d7db6b5b68" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우,이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="efeea28b8db5bdbdbe7665022456615ea9a2a02a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소와 채널 소켓의 로컬 포트를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4504e52760544f5802fe95b384c420e8994a88" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9d7c04bc4d0c36452207dc47930704ce6c96d6" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와이 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2186903b27dd0e412d3c41bc56df02edfa54b96" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 구현 주소로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e5eea39d0bafa27479de1740d6a3bd033e70cc0a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="501526fb9b9e2e222246e9cd9786ee96d321d66c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it.</source>
          <target state="translated">보안 관리자가있는 경우 보안 관리자의 &lt;code&gt;checkAccept&lt;/code&gt; 메소드가 허용하지 않으면 패킷을 수신 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="78bc0f4a72c52e6defa54f26456df6b6bfdcd359" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; as its argument. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">보안 관리자가 있고 소켓이 현재 원격 주소에 연결되어 있지 않으면이 방법은 먼저 일부 보안 검사를 수행합니다. 먼저 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 가 true 인 경우이 메소드는 &lt;code&gt;p.getAddress()&lt;/code&gt; 를 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 . 해당 표현식의 평가가 false 인 경우,이 메소드는 대신 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;p.getPort()&lt;/code&gt; 인수로 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출합니다 . 조작이 허용되지 않으면 보안 관리자 메소드를 호출 할 때마다 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2dc991bc054662c9aaf92a4f81920cc42b0299" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and this thread is not the current thread, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission to see if it's ok to get the stack trace.</source>
          <target state="translated">보안 관리자가 &lt;code&gt;checkPermission&lt;/code&gt; 스레드가 현재 스레드가 아닌 경우 보안 관리자의 checkPermission 메소드가 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 권한으로 호출되어 스택 추적을 가져 오기에 적합한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9414114a34df41ef68dcd065db4f4c005b486dbe" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">보안 관리자가있는 경우 , ThreadAccess를 인수로 사용하여 &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3533ff6ee33a3d65c462d1050b52aa5438f30879" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt;&lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt; &lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 보안 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a1e97c5d37987df52e3f2db8dd957eb6a2e0a1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가이 오브젝트 &lt;code&gt;command&lt;/code&gt; 배열 의 첫 번째 구성 요소를 인수로 사용하여 호출됩니다. 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c30beb89be73a967106d6bb017cc3341325b7e4" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드를 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="959b09fe0d2c452907b0520da6e28a90c4ae65f9" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread group as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드 그룹을 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c17150f3dc1fd1d9a170113f445867d696c2b24" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">보안 관리자가있는 경우 각 InetAddress에 대해 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 InetAddresses 만 Enumeration에 반환됩니다. 그러나 호출자에게 &lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt; ( &quot;getNetworkInformation&quot;) 권한 이 있으면 모든 InetAddresses가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16d27bea720609eee04166dfd76b88b456132798" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 &lt;code&gt;host.getHostAddress()&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c71e671e00781339f5ba759f2bcd61a8b7a34b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the List.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 각 InterfaceAddress에 대해 InetAddress와 함께 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 인터페이스 주소 만 목록에 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="78af07133b038dacb150089b40e78b0ca1d3d753" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host address and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 호스트 주소와 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2ddb66aff693ec81fe7a3cff9c33e416a967ed" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host name as its argument to check the permission to resolve it. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 호스트 이름을 인수로하여이를 해결하기위한 권한을 점검합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ae3cd02649f51bc3641c7c81a3016b88a1579b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local host name and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned.</source>
          <target state="translated">보안 관리자가있는 경우 로컬 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용 하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 루프백 주소를 나타내는 InetAddress가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d128c55ea8e46338a04c172173181318ab739b7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the proxy host address and port number as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 프록시 호스트 주소 및 포트 번호를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca28a5046aedb2445dad871f1870c7cd86fe222" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the host address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd69bfacd3a48bd3c84ffe11c3502373bc1b717d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 IP 주소의 텍스트 표현이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19b8451790374e638a897d576809e75ff26e4bdc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkExit&lt;/code&gt; method is first called with 0 as its argument to ensure the exit is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkExit&lt;/code&gt; 메소드는 먼저 엑시트가 허용되도록 인수로 0을 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad778e38f7a8fa1a04c66c84bec80348990751b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84eacac097d36c19fe75054afbaa3ba99bf8985e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7696a640bf74fb64021433fe004320c4e69fec7e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with 0 as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드는 조작이 허용되도록 인수로 0을 사용하여 먼저 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d8bb6cd4c61d496d648276b50f92f3feba88b5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2550b60768f930b8dee700df520c5f4176ce28d3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 조작이 허용되도록 인수로 SocketAddress 포트와 함께 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a229539b4a28c2f5ec8ded7c3825ecf64243199f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the port from the socket address as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 먼저 &lt;code&gt;checkListen&lt;/code&gt; 메소드가 소켓 주소의 포트를 인수로 호출하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1362fabcddab928d786a66dfafce71193c90bbd3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; permission before the default locale is changed.</source>
          <target state="translated">보안 관리자가있는 경우 기본 로케일이 변경되기 전에 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; 권한 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a19d07ab57d6d32ab3bfc3854e57cbabaa6348e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;checkPermission&lt;/code&gt; 메소드는 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b812e22f1f04741048de016813ab27b17900ad4d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가있는 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61ad58a3688694c18343d625b7add7843909f0fc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if write access to the file is allowed.</source>
          <target state="translated">보안 관리자가있는 경우, 파일에 대한 읽기 액세스가 허용되는지 확인하기 위해 &lt;code&gt;checkRead&lt;/code&gt; 메소드가 &lt;code&gt;name&lt;/code&gt; 인수 와 함께 인수로 호출됩니다 . 모드 가 쓰기를 허용하는 경우, 파일에 대한 쓰기 액세스가 허용되는지 확인하기 위해 보안 관리자의 &lt;code&gt;checkWrite&lt;/code&gt; 메소드가 &lt;code&gt;name&lt;/code&gt; 인수 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8440e06fb5641cd0bbb2e4e19fe4021dbf3d258" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to see if it's ok to read the file descriptor. If read access is denied to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">보안 관리자가있는 경우 파일 디스크립터 &lt;code&gt;fdObj&lt;/code&gt; 를 인수로 하여 &lt;code&gt;checkRead&lt;/code&gt; 메소드를 호출하여 파일 디스크립터 를 읽을 수 있는지 확인합니다. 파일 디스크립터에 대한 읽기 액세스가 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="07ece2acfb17b36150e2dd4f7e477c94e9f4a76d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the pathname of the &lt;code&gt;file&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the path argument to see if write access to the file is allowed.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;file&lt;/code&gt; 대한 읽기 액세스가 허용되는지 확인하기 위해 파일 인수 의 경로 이름을 인수로 사용하여 &lt;code&gt;checkRead&lt;/code&gt; 메소드가 호출됩니다 . 모드 가 쓰기를 허용하는 경우 파일에 대한 쓰기 액세스가 허용되는지 확인하기 위해 보안 관리자의 &lt;code&gt;checkWrite&lt;/code&gt; 메소드가 path 인수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31b66585dd5ded5b4cf8149540abcf6d797f5618" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its checkPermission method is called with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before the default locale is changed.</source>
          <target state="translated">보안 관리자가있는 경우 기본 로케일이 변경되기 전에 checkPermission 메소드가 PropertyPermission ( &quot;user.language&quot;, &quot;write&quot;) 권한으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bd97e3f8323cfe0de6530417bd6292cf0553996a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; 권한 대상 이름으로 &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 새 제공자를 추가 할 수 있는지 확인합니다. 이 권한 검사가 거부되면 &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; 권한 대상 이름으로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 가 다시 호출됩니다 . 두 검사가 모두 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9b31a15f0a361ace0e86d27297cb7544846a2131" translate="yes" xml:space="preserve">
          <source>If there is a security manager, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission as well as &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission to see if it is ok to get the stack trace of all threads.</source>
          <target state="translated">보안 관리자가있는 경우 모든 스레드의 스택 추적을 얻을 수 있는지 확인하기 위해 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한 뿐만 아니라 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3774f41cca13a332ee025b0313241e9bb0d0309d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method calls its &lt;code&gt;checkListen&lt;/code&gt; method with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드 는 &lt;code&gt;port&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkListen&lt;/code&gt; 메소드를 호출 하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c49df9821bd54b67f07151d3efea906c51666fdf" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkConnect&lt;/code&gt; method with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the calling code is allowed to know the hostname for this IP address, i.e., to connect to the host. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 호스트 이름과 인수로 &lt;code&gt;-1&lt;/code&gt; 을 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출하여 호출 코드가이 IP 주소의 호스트 이름을 알 수 있는지 (예 : 호스트에 연결) 여부를 확인합니다. 작업이 허용되지 않으면 IP 주소의 텍스트 표현이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="999933e43cb5d7cfb6601989d19930a2a9186ce5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkMulticast&lt;/code&gt; method with the &lt;code&gt;mcastaddr&lt;/code&gt; argument as its argument.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 &lt;code&gt;mcastaddr&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1e8e454b01623ff9ba56024fdcbb8a6e018247b0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method to ensure creation of a class loader is allowed.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkCreateClassLoader&lt;/code&gt; 메소드를 호출하여 클래스 로더 작성이 허용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="532913bfc0592ca00219b6f161a58e7676757794" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkSetFactory&lt;/code&gt; 메소드를 호출 하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0319ca077ddde1bcf2e693ddcb559868dc66ee3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; as its arguments. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">보안 관리자가있는 경우이 방법은 먼저 일부 보안 검사를 수행합니다. 먼저 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 가 true 인 경우이 메소드는 &lt;code&gt;p.getAddress()&lt;/code&gt; 및 &lt;code&gt;ttl&lt;/code&gt; 을 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 . 해당 표현식의 평가가 false 인 경우,이 메소드는 대신 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;p.getPort()&lt;/code&gt; 인수로 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출합니다 . 조작이 허용되지 않으면 보안 관리자 메소드를 호출 할 때마다 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f00389ed8595939dc871f12e3fcfe41a5531ae8a" translate="yes" xml:space="preserve">
          <source>If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</source>
          <target state="translated">&lt;em&gt;opendata (J)&lt;/em&gt; 를 &lt;em&gt;J&lt;/em&gt; 로 다시 변환하는 방법이 있다면 &lt;em&gt;J&lt;/em&gt; 는 &lt;em&gt;재구성 가능&lt;/em&gt; 하다고 말합니다 . MXBean 프레임 워크가 메소드를 호출 할 때 메소드를 &lt;em&gt;opendata (J)&lt;/em&gt; 에서 &lt;em&gt;J&lt;/em&gt; 로 변환해야하기 때문에 MXBean 인터페이스의 모든 메소드 매개 변수는 재구성 가능해야합니다 . &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 프록시에서 , 그것은 재구성 가능해야하는 MXBean 인터페이스에있는 메소드의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="9bde7f17c2deabb0575bd222ed2f85f576a5ede8" translate="yes" xml:space="preserve">
          <source>If there is any error (say, I/O error or format error) during the reading process of the KeyTab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</source>
          <target state="translated">KeyTab 파일 읽기 프로세스 중에 오류 (예 : I / O 오류 또는 형식 오류)가있는 경우 저장된 결과가 리턴되어야합니다. 저장된 결과가없는 경우 (즉,이 메소드가 처음 호출되거나 모든 이전 읽기 시도가 실패한 경우) 빈 배열이 리턴되어야합니다. 이를 통해 키탭 파일을 업데이트하는 동안 (아마도 느린) 결과가 크게 변경되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2521f70370beeb7a65247f5ecdb6409da533aa1" translate="yes" xml:space="preserve">
          <source>If there is any inherited context, then it has already been copied into the &lt;code&gt;URL&lt;/code&gt; argument.</source>
          <target state="translated">상속 된 컨텍스트가 있으면 이미 &lt;code&gt;URL&lt;/code&gt; 인수에 복사 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ce492db546ed8f744751a5952cc84069d57cdf28" translate="yes" xml:space="preserve">
          <source>If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt;CompositeType&lt;/code&gt; with one item for every getter. If the getter is</source>
          <target state="translated">적어도 하나의 getter가 있고 모든 getter에 컨버터블 유형이있는 경우 &lt;em&gt;opentype (J)&lt;/em&gt; 는 모든 getter에 대해 하나의 항목 이있는 &lt;code&gt;CompositeType&lt;/code&gt; 입니다. 게터가</target>
        </trans-unit>
        <trans-unit id="f0a5ce38d1565c12f161531f62c2ed657aa770d3" translate="yes" xml:space="preserve">
          <source>If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an MXBean. The interface in question is the &lt;em&gt;MXBean interface&lt;/em&gt;. In the example above, the MXBean interface is &lt;code&gt;MemoryPoolMXBean&lt;/code&gt;.</source>
          <target state="translated">그러한 인터페이스가 정확히 하나이거나 다른 인터페이스의 서브 인터페이스 인 인터페이스가 있으면 객체는 MXBean입니다. 문제의 인터페이스는 &lt;em&gt;MXBean 인터페이스&lt;/em&gt; 입니다. 위의 예에서 MXBean 인터페이스는 &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2719aa3eb5a7fffd1ca38e949931f67f1421af57" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;serviceURL&lt;/code&gt;, there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt;. If the &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt;&lt;code&gt;toStub&lt;/code&gt;&lt;/a&gt; method on this object returns an instance of &lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt;&lt;code&gt;Stub&lt;/code&gt;&lt;/a&gt;, then the connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;iiop&lt;/code&gt; form above. Otherwise, it will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</source>
          <target state="translated">&lt;code&gt;serviceURL&lt;/code&gt; 이 없으면 사용자 제공 &lt;code&gt;RMIServerImpl&lt;/code&gt; 이 있어야합니다 . 이 오브젝트 의 &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt; &lt;code&gt;toStub&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt; &lt;code&gt;Stub&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하면 , 커넥터 서버는 위 의 &lt;code&gt;iiop&lt;/code&gt; 양식을 사용하여 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 생성합니다 . 그렇지 않으면 &lt;code&gt;rmi&lt;/code&gt; 양식을 사용하여 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2cc3dec11f4378075a31721786189ded4db361d5" translate="yes" xml:space="preserve">
          <source>If there is no current set of system properties, a set of system properties is first created and initialized in the same manner as for the &lt;code&gt;getProperties&lt;/code&gt; method.</source>
          <target state="translated">현재 시스템 특성 세트가없는 경우 &lt;code&gt;getProperties&lt;/code&gt; 메소드 와 동일한 방식으로 시스템 특성 세트가 먼저 작성되고 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="62385658f9c9d30f2326007c7be1947af3806233" translate="yes" xml:space="preserve">
          <source>If there is no display name for the locale then a suitable default must be returned.</source>
          <target state="translated">로케일의 표시 이름이 없으면 적절한 기본값을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="14d757aed623c13896747a1cb10d2fafe0c24ef5" translate="yes" xml:space="preserve">
          <source>If there is no entry for a particular principal, then the principal is considered to have a null (empty) permission set.</source>
          <target state="translated">특정 프린시 펄에 대한 항목이 없으면 프린시 펄에는 널 (빈) 권한 세트가있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="83cc3943509d49fbbe54f8e7d0348cb9ef645fa2" translate="yes" xml:space="preserve">
          <source>If there is no entry in this Access Control List for the specified principal, an empty permission set is returned.</source>
          <target state="translated">이 액세스 제어 목록에 지정된 보안 주체에 대한 항목이 없으면 빈 권한 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="97ef1aceb0bd9ccbc5a3e085bc385c17a96da05c" translate="yes" xml:space="preserve">
          <source>If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case, &lt;code&gt;compareTo&lt;/code&gt; returns the difference of the lengths of the strings -- that is, the value:</source>
          <target state="translated">서로 다른 인덱스 위치가 없으면 짧은 문자열이 사전 식으로 긴 문자열보다 앞에옵니다. 이 경우 &lt;code&gt;compareTo&lt;/code&gt; 는 문자열 길이의 차이, 즉 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f38d945bc914e61ae40e4aad1f19fc041a605394" translate="yes" xml:space="preserve">
          <source>If there is no match, then either the first or last index is used, depending on whether the number (X) is too low or too high. If the limit array is not in ascending order, the results of formatting will be incorrect. ChoiceFormat also accepts &lt;code&gt;\u221E&lt;/code&gt; as equivalent to infinity(INF).</source>
          <target state="translated">일치하는 항목이 없으면 숫자 (X)가 너무 낮거나 높은지 여부에 따라 첫 번째 또는 마지막 색인이 사용됩니다. 한계 배열이 오름차순이 아닌 경우 서식 결과가 올바르지 않습니다. ChoiceFormat은 또한 무한대 (INF)와 동등한 &lt;code&gt;\u221E&lt;/code&gt; 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="f3d0e4d2da1282aaec455fc4732cff1c598c3d7c" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, if the specified name is empty or &lt;code&gt;null&lt;/code&gt;, or if the property does not have the correct numeric format, then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 이름의 속성이 없거나 지정된 이름이 비어 있거나 &lt;code&gt;null&lt;/code&gt; 이거나 속성에 올바른 숫자 형식이없는 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ebec043b114adf3a66c121103ae990378ebe9b9b" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, or if the specified name is empty or null, then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 이름의 속성이 없거나 지정된 이름이 비어 있거나 null 인 경우 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="62eecfe9a255148d750e0784a244f5d095566c9e" translate="yes" xml:space="preserve">
          <source>If there is one or more timer notifications before the time in the list of notifications, the notification is sent according to the &lt;code&gt;sendPastNotifications&lt;/code&gt; flag and then, updated according to its period and remaining number of occurrences. If the timer notification date remains earlier than the current date, this notification is just removed from the list of notifications.</source>
          <target state="translated">통지 목록에 시간 이전에 하나 이상의 타이머 통지가있는 경우, 통지는 &lt;code&gt;sendPastNotifications&lt;/code&gt; 플래그 에 따라 전송 된 후,주기 및 남은 발생 횟수에 따라 업데이트됩니다. 타이머 알림 날짜가 현재 날짜보다 빠른 경우이 알림은 알림 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bea1d12841642f06cd5c576dd8ad73a21f49fc5b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언에 주석이 붙은 슈퍼 인터페이스를 명시 적으로 나타내지 않는 클래스 또는 인터페이스를 나타내는 경우, 반환 값은 길이가 0의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="94f6da01be13858770dcd2fbeb1c8376bf8f27d5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared fields, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언 된 필드가없는 클래스 또는 인터페이스를 나타내는 경우이 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5e526ec67c2b068f6813c00e0742ddec3d6151e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared methods, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언 된 메서드가없는 클래스 또는 인터페이스를 나타내는 경우 반환 된 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d4ce471ae16ab801b2259a590ff7a0fee5c25fdb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no no accessible public fields, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 액세스 가능한 공개 필드가없는 클래스 또는 인터페이스를 나타내는 경우 ,이 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c9c0f2616e4b918558184c0ef2f121a34cc9b89a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 , 반환 값은 클래스에 의해 구현되는 인터페이스를 지정하기위한 인터페이스 타입의 사용을 나타내는 객체를 포함한 배열입니다. 배열 내의 객체의 순서는이 &lt;code&gt;Class&lt;/code&gt; 객체 의 선언의 'implementation'절에 사용되는 인터페이스 타입의 순서에 대응 합니다.</target>
        </trans-unit>
        <trans-unit id="8ea0225aadb3a9617c32673581f4007aea0f62a1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 ,이 메소드는 클래스와 모든 슈퍼 클래스의 공개 필드를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="42af070ad6a4d3648b309df9a277dd2d8e338352" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt;&lt;code&gt;Constructor&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing constructor of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 생성자 내에서 로컬 또는 익명 클래스를 나타내는 경우 기본 클래스의 즉시 둘러싸는 생성자를 나타내는 &lt;a href=&quot;reflect/constructor&quot;&gt; &lt;code&gt;Constructor&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 반환 값은 &lt;code&gt;null&lt;/code&gt; 이 없습니다. 특히, 기본이되는 클래스가 타입 선언, 인스턴스 이니셜 라이저 또는 정적 이니셜 라이저로 즉시 둘러싸인 로컬 또는 익명의 클래스 인 경우 ,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="4477ae736ceef4ce368b1839297468a2918b1155" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing method of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 메서드 내에서 로컬 또는 익명 클래스를 나타내는 경우 기본 클래스의 바로 묶는 메서드를 나타내는 &lt;a href=&quot;reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 반환 값은 &lt;code&gt;null&lt;/code&gt; 이 없습니다. 특히, 기본이되는 클래스가 타입 선언, 인스턴스 이니셜 라이저 또는 정적 이니셜 라이저로 즉시 둘러싸인 로컬 또는 익명의 클래스 인 경우 ,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="79bd7175460e43940d330fea2bc43e369e031bbb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 프리미티브 유형 또는 void를 나타내는 경우 반환 된 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="f02c0ed1f5bae30d0291b5a6aaf11110bd96f07d" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스 초기화 메소드 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 를 가지는 타입을 나타내는 경우 , 반환되는 배열에는 대응하는 &lt;code&gt;Method&lt;/code&gt; 객체 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b86687e1e312e67b7460fddd5aed10106e1e53" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple declared methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 같은 이름과 파라미터 타입을 가지지 만 리턴 타입이 다른 선언 된 메소드가 여러 개있는 타입을 나타내는 경우 , 반환 된 배열에는 그러한 각 &lt;code&gt;Method&lt;/code&gt; 대한 Method 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5139658d7d0116078759c8a142a520e5a7e171" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple public methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가, 이름과 파라미터 타입은 같지만 리턴 타입이 다른 복수의 퍼블릭 메소드를 가지는 타입을 나타내는 경우 , 반환 된 배열에는 그러한 각 &lt;code&gt;Method&lt;/code&gt; 대한 Method 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9710c2aebb0499fff54a4c1fab48952630f8353" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type whose declaration does not explicitly indicate an annotated superclass, then the return value is an &lt;code&gt;AnnotatedType&lt;/code&gt; object representing an element with no annotations.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언에 주석이 붙은 슈퍼 클래스를 명시 적으로 나타내지 않는 타입을 나타내는 경우 , 반환 값은 &lt;code&gt;AnnotatedType&lt;/code&gt; 이없는 요소를 나타내는 AnnotatedType 객체입니다.</target>
        </trans-unit>
        <trans-unit id="abacab4cf9b024f594f0b3f572123f051f06c2c5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type with a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스 초기화 메소드 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 를 가지는 타입을 나타내는 경우 , 반환되는 배열에는 대응하는 &lt;code&gt;Method&lt;/code&gt; 객체 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1bebb6eaefac5ae2ce6d923cc8da1eb725883029" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형, 원시적 형, 또는 void를 나타내는 경우, 반환되는 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="70b797601062908da356817410150aa204020fc1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형, 원시적 형, 또는 void를 나타내는 경우,이 메소드는 길이가 0 인 배열을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="20332c048f55b2154c66a445225edb4bdb3e274e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, the interfaces &lt;code&gt;Cloneable&lt;/code&gt; and &lt;code&gt;java.io.Serializable&lt;/code&gt; are returned in that order.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우는 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스 와 &lt;code&gt;java.io.Serializable&lt;/code&gt; 인터페이스 가 그 순서로 돌려 주어 집니다.</target>
        </trans-unit>
        <trans-unit id="348539037139d48e6387c9a62912e6564911c876" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each of the public methods inherited by the array type from &lt;code&gt;Object&lt;/code&gt;. It does not contain a &lt;code&gt;Method&lt;/code&gt; object for &lt;code&gt;clone()&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우, 돌려 주어진 배열은 &lt;code&gt;Object&lt;/code&gt; 로부터 배열 형에 의해 상속 된 각 공개 메소드에 대한 &lt;code&gt;Method&lt;/code&gt; 오브젝트를가집니다 . &lt;code&gt;clone()&lt;/code&gt; 의 &lt;code&gt;Method&lt;/code&gt; 객체를 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="29e81a940f259cfb7b07c0e245bb52be63c0dd30" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;clone()&lt;/code&gt; method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우,이 메소드는 &lt;code&gt;clone()&lt;/code&gt; 메소드를 찾지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb178a8f1871d07a34cdb3bb2de9a0c1fb20f2b9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;length&lt;/code&gt; field of the array type.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우,이 메소드는 배열 형 의 &lt;code&gt;length&lt;/code&gt; 필드를 찾지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4b35440106aa65e3bd6d1155d9e17869493181" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then the returned array does not contain any implicitly declared methods from &lt;code&gt;Object&lt;/code&gt;. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a &lt;code&gt;Class&lt;/code&gt; object which represents a class always has public methods, inherited from &lt;code&gt;Object&lt;/code&gt;.)</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우, 돌려 주어진 배열은 &lt;code&gt;Object&lt;/code&gt; 로부터 암묵적으로 선언 된 메소드를 포함하지 않습니다 . 따라서이 인터페이스 또는 해당 수퍼 인터페이스에 명시 적으로 선언 된 메소드가없는 경우 반환 된 배열의 길이는 0입니다. &lt;code&gt;Class&lt;/code&gt; 를 나타내는 Class 객체에는 항상 &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 public 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2d45c96fc82cd4f5045bb65c083bb3e36fa1de" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우, 반환 값은 인터페이스에 의해 직접 확장 된 인터페이스를 지정하기위한 인터페이스 타입의 사용을 나타내는 객체를 포함한 배열입니다. 배열의 객체 순서는이 &lt;code&gt;Class&lt;/code&gt; 객체 선언의 'extends'절에 사용 된 인터페이스 유형의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="0f7aab31089775b3540a55de72ec8246707dca71" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, then this method returns the fields of the interface and of all its superinterfaces.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우,이 메소드는 인터페이스 및 모든 슈퍼 인터페이스의 필드를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="24fcfbcd558d192b46d9d8daf24bd3361c63931e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents either the &lt;code&gt;Object&lt;/code&gt; class, an array type, a primitive type, or void, the return value is an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 &lt;code&gt;Object&lt;/code&gt; 클래스, 배열 유형, 기본 유형 또는 void를 나타내는 경우 반환 값은 길이가 0 인 배열입니다.</target>
        </trans-unit>
        <trans-unit id="74ef85a38a3ffe3f10aa47e5d033acb048da33fd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface type, an array type, a primitive type, or void, the return value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스 유형, 배열 유형, 기본 유형 또는 void를 나타내는 경우, 리턴 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c005c11b66aec51de31e87c510532c6a448273e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Field&lt;/code&gt; 객체가 Java 언어 액세스 제어를 실시하고있어, 기본이되는 필드에 액세스 할 수없는 경우, 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="bfff6651d72785da15b50a35bc44c7be29e967f4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;. If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">이 &lt;code&gt;Field&lt;/code&gt; 객체가 Java 언어 액세스 제어를 실시하고있어, 기본이되는 필드에 액세스 할 수없는 경우, 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw 합니다. 기본 필드가 정적 인 경우 필드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="8557e1e1be59bc05bf4e2df145cc3c316c6e80c0" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or variant that does not satisfy the IETF BCP 47 language tag syntax requirements, this method handles these fields as described below:</source>
          <target state="translated">이 &lt;code&gt;Locale&lt;/code&gt; 에 IETF BCP 47 언어 태그 구문 요구 사항을 충족하지 않는 언어, 국가 또는 변형이있는 경우이 메소드는 아래 설명 된대로 이러한 필드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ae1424f53f74471f85637ef0b51790d77bcaf639" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;SSLEngine&lt;/code&gt; has not yet started its initial handshake, this method will automatically start the handshake.</source>
          <target state="translated">이 &lt;code&gt;SSLEngine&lt;/code&gt; 가 초기 핸드 셰이크를 아직 시작하지 않은 경우이 메소드는 자동으로 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9f94176502144d53f9b47819a2742a061514b473" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;String&lt;/code&gt; object represents an empty character sequence, or the first and last characters of character sequence represented by this &lt;code&gt;String&lt;/code&gt; object both have codes greater than &lt;code&gt;'\u0020'&lt;/code&gt; (the space character), then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">이 경우 &lt;code&gt;String&lt;/code&gt; 객체가 빈 문자 순서, 또는 이것에 의해 표현되는 문자 순서의 첫 번째와 마지막 문자를 나타내는 &lt;code&gt;String&lt;/code&gt; 객체를 모두보다 큰 코드가 &lt;code&gt;'\u0020'&lt;/code&gt; (공백 문자),이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94372ce6dbad15dca713c930c5806a503901c516" translate="yes" xml:space="preserve">
          <source>If this CodeSource object was created using the &lt;a href=&quot;codesource#CodeSource-java.net.URL-java.security.CodeSigner:A-&quot;&gt;&lt;code&gt;CodeSource(URL url, CodeSigner[] signers)&lt;/code&gt;&lt;/a&gt; constructor then its certificate chains are extracted and used to create an array of Certificate objects. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain is ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).</source>
          <target state="translated">&lt;a href=&quot;codesource#CodeSource-java.net.URL-java.security.CodeSigner:A-&quot;&gt; &lt;code&gt;CodeSource(URL url, CodeSigner[] signers)&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여이 CodeSource 객체를 만든 경우 해당 인증서 체인이 추출되어 Certificate 객체 배열을 만드는 데 사용됩니다. 각 서명자 인증서 뒤에는 지원 인증서 체인 (비어있을 수 있음)이옵니다. 각 서명자 인증서 및 해당 지원 인증서 체인은 맨 아래에서 순서대로 주문됩니다 (즉, 서명자 인증서가 먼저 있고 (루트) 인증 기관이 마지막에 있음).</target>
        </trans-unit>
        <trans-unit id="ecab603cea1b392a04b99fd74cc5c16fc8600c78" translate="yes" xml:space="preserve">
          <source>If this CodeSource object was created using the &lt;a href=&quot;codesource#CodeSource-java.net.URL-java.security.cert.Certificate:A-&quot;&gt;&lt;code&gt;CodeSource(URL url, java.security.cert.Certificate[] certs)&lt;/code&gt;&lt;/a&gt; constructor then its certificate chains are extracted and used to create an array of CodeSigner objects. Note that only X.509 certificates are examined - all other certificate types are ignored.</source>
          <target state="translated">&lt;a href=&quot;codesource#CodeSource-java.net.URL-java.security.cert.Certificate:A-&quot;&gt; &lt;code&gt;CodeSource(URL url, java.security.cert.Certificate[] certs)&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여이 CodeSource 객체를 만든 경우 해당 인증서 체인이 추출되어 CodeSigner 객체의 배열을 만드는 데 사용됩니다. X.509 인증서 만 검사합니다. 다른 모든 인증서 유형은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87212e4e2a7f5242014dd7f84b673fda3009933f" translate="yes" xml:space="preserve">
          <source>If this InetAddress was created with a host name, this host name will be remembered and returned; otherwise, a reverse name lookup will be performed and the result will be returned based on the system configured name lookup service. If a lookup of the name service is required, call &lt;a href=&quot;inetaddress#getCanonicalHostName--&quot;&gt;&lt;code&gt;getCanonicalHostName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 InetAddress가 호스트 이름으로 생성 된 경우이 호스트 이름이 기억되고 반환됩니다. 그렇지 않으면 리버스 이름 검색이 수행되고 시스템 구성 이름 검색 서비스를 기반으로 결과가 반환됩니다. 이름 서비스를 찾아 &lt;a href=&quot;inetaddress#getCanonicalHostName--&quot;&gt; &lt;code&gt;getCanonicalHostName&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="8771b92415dc41144a3e4cc576f34f85f427b6e9" translate="yes" xml:space="preserve">
          <source>If this KeyPairGenerator has not been initialized explicitly, provider-specific defaults will be used for the size and other (algorithm-specific) values of the generated keys.</source>
          <target state="translated">이 KeyPairGenerator가 명시 적으로 초기화되지 않은 경우 생성 된 키의 크기 및 기타 (알고리즘 특정) 값에 공급자 별 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd80b9ee095b086c5f82414644de7ec8e7158a07" translate="yes" xml:space="preserve">
          <source>If this LDAP name is lexicographically lesser than obj, a negative number is returned. If this LDAP name is lexicographically greater than obj, a positive number is returned.</source>
          <target state="translated">이 LDAP 이름이 사전 순으로 obj보다 작은 경우 음수가 리턴됩니다. 이 LDAP 이름이 사전 순으로 obj보다 큰 경우 양수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f6337052f3e086791b9360f545e9101bb5279cf3" translate="yes" xml:space="preserve">
          <source>If this LoginModule's own authentication attempt succeeded (checked by retrieving the private state saved by the &lt;code&gt;login&lt;/code&gt; method), then this method associates relevant Principals and Credentials with the &lt;code&gt;Subject&lt;/code&gt; located in the &lt;code&gt;LoginModule&lt;/code&gt;. If this LoginModule's own authentication attempted failed, then this method removes/destroys any state that was originally saved.</source>
          <target state="translated">이 LoginModule 자신의 인증 시도가 성공한 경우 ( &lt;code&gt;login&lt;/code&gt; 방법으로 저장된 개인 상태를 검색하여 확인 ),이 방법은 관련 사용자 및 신임 정보를 &lt;code&gt;LoginModule&lt;/code&gt; 에 있는 &lt;code&gt;Subject&lt;/code&gt; 와 연관시킵니다 . 이 LoginModule 자체의 인증이 실패했을 경우,이 메소드는 원래 저장된 상태를 삭제 / 파기합니다.</target>
        </trans-unit>
        <trans-unit id="6b0c6b5c94882ad8131434b0393b17deee36d8cd" translate="yes" xml:space="preserve">
          <source>If this LoginModule's own authentication attempt succeeded (checked by retrieving the private state saved by the &lt;code&gt;login&lt;/code&gt; method), then this method cleans up any state that was originally saved.</source>
          <target state="translated">이 LoginModule 자체의 인증 시도가 성공한 경우 ( &lt;code&gt;login&lt;/code&gt; 방법으로 저장된 개인 상태를 검색하여 확인한 경우 ),이 방법은 원래 저장된 상태를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="c2e88106c6c744ebfa727aad7f15154d6461aeae" translate="yes" xml:space="preserve">
          <source>If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt;, the returned Spliterator must cover a strict prefix of the elements.</source>
          <target state="translated">이 Spliterator가 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 인 경우 리턴 된 Spliterator는 요소의 엄격한 접 두부를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb9e47f7f86d1768c1633e48cf94673a67f3b07f" translate="yes" xml:space="preserve">
          <source>If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, the returned Spliterator must cover a strict prefix of the elements.</source>
          <target state="translated">이 Spliterator가 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 인 경우 반환 된 Spliterator는 요소의 엄격한 접두사를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc3d02811da7cd52f8f2143d8108066a5174a2bd" translate="yes" xml:space="preserve">
          <source>If this Spliterator is &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;SIZED&lt;/code&gt;&lt;/a&gt; and has not yet been partially traversed or split, or this Spliterator is &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;SUBSIZED&lt;/code&gt;&lt;/a&gt; and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of &lt;a href=&quot;spliterator#trySplit--&quot;&gt;&lt;code&gt;trySplit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 Spliterator 인 경우 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;SIZED&lt;/code&gt; &lt;/a&gt; 아직 부분적으로 통과 또는 분할되지 않았거나이 Spliterator입니다 &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;SUBSIZED&lt;/code&gt; &lt;/a&gt; 아직 부분적으로 통과되지 않은,이 예상은 완전한 탐색에 의해 발생 될 요소의 정확한 계산해야합니다. 그렇지 않으면이 추정값이 임의로 부정확 할 수 있지만 &lt;a href=&quot;spliterator#trySplit--&quot;&gt; &lt;code&gt;trySplit()&lt;/code&gt; &lt;/a&gt; 호출에서 지정한대로 감소해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f10f115293acf7405775035800014677ebc0f036" translate="yes" xml:space="preserve">
          <source>If this Spliterator is &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt; and has not yet been partially traversed or split, or this Spliterator is &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt; and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of &lt;a href=&quot;spliterator#trySplit--&quot;&gt;&lt;code&gt;Spliterator.trySplit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스플리터가 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt; 이고 아직 부분적으로 순회 또는 분할 되지 않았 &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt; 스플리터가 Spliterator.SUBSIZED 이고 아직 부분적으로 순회되지 않은 경우,이 추정값은 전체 순회가 발생할 정확한 요소 수 여야합니다. 그렇지 않으면이 추정값이 임의로 부정확 할 수 있지만 &lt;a href=&quot;spliterator#trySplit--&quot;&gt; &lt;code&gt;Spliterator.trySplit()&lt;/code&gt; &lt;/a&gt; 호출에서 지정한대로 감소해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f60f6f6cceac6f24471b339df70a79fb087d77de" translate="yes" xml:space="preserve">
          <source>If this Spliterator's source is &lt;a href=&quot;spliterator#SORTED&quot;&gt;&lt;code&gt;SORTED&lt;/code&gt;&lt;/a&gt; by a &lt;a href=&quot;comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;, returns that &lt;code&gt;Comparator&lt;/code&gt;. If the source is &lt;code&gt;SORTED&lt;/code&gt; in &lt;a href=&quot;../lang/comparable&quot;&gt;natural order&lt;/a&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, if the source is not &lt;code&gt;SORTED&lt;/code&gt;, throws &lt;a href=&quot;../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 Spliterator의 소스가 &lt;a href=&quot;comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; 에&lt;/a&gt; 의해 &lt;a href=&quot;spliterator#SORTED&quot;&gt; &lt;code&gt;SORTED&lt;/code&gt; 인&lt;/a&gt; 경우 , 그 &lt;code&gt;Comparator&lt;/code&gt; 를 돌려줍니다 . 소스가 &lt;a href=&quot;../lang/comparable&quot;&gt;자연 순서대로 &lt;/a&gt; &lt;code&gt;SORTED&lt;/code&gt; 된 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 소스가되지 않는 경우 그렇지 않으면, &lt;code&gt;SORTED&lt;/code&gt; , 발생 &lt;a href=&quot;../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 이는&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d47d9dbaa7d1cd77d733d9036821dd30adccdd2" translate="yes" xml:space="preserve">
          <source>If this URI does not contain any characters in the</source>
          <target state="translated">이 URI에 문자가 포함되어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="953276a9eb7a662bc1d17295c7e9ca3ca9dc9fe3" translate="yes" xml:space="preserve">
          <source>If this URI is opaque, or if its path is already in normal form, then this URI is returned. Otherwise a new URI is constructed that is identical to this URI except that its path is computed by normalizing this URI's path in a manner consistent with &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt;, section 5.2, step 6, sub-steps c through f; that is:</source>
          <target state="translated">이 URI가 불투명하거나 해당 경로가 이미 일반 형식 인 경우이 URI가 반환됩니다. 그렇지 않으면 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt; , 섹션 5.2, 단계 6, 하위 단계 c-f 와 일치하는 방식으로이 URI 경로를 정규화하여 경로를 계산한다는 점을 제외하고는이 URI와 동일한 새 URI가 구성됩니다 . 그건:</target>
        </trans-unit>
        <trans-unit id="ef183e3c97a706cf2aab485f3b25ca02123979b8" translate="yes" xml:space="preserve">
          <source>If this URI was created by invoking one of the constructors in this class then a string equivalent to the original input string, or to the string computed from the originally-given components, as appropriate, is returned. Otherwise this URI was created by normalization, resolution, or relativization, and so a string is constructed from this URI's components according to the rules specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt;, section 5.2, step 7.</source>
          <target state="translated">이 클래스의 생성자 중 하나를 호출하여이 URI를 작성한 경우 원래 입력 문자열 또는 원래 제공된 컴포넌트에서 계산 된 문자열과 동등한 문자열이 리턴됩니다. 그렇지 않으면이 URI는 정규화, 분석 또는 재배치에 의해 작성되므로 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt; , 섹션 5.2, 7 단계에 지정된 규칙에 따라이 URI의 컴포넌트에서 문자열이 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="35a608d401f58e4ebbe22c45677516aed01211dc" translate="yes" xml:space="preserve">
          <source>If this URI's authority component has already been recognized as being server-based then it will already have been parsed into user-information, host, and port components. In this case, or if this URI has no authority component, this method simply returns this URI.</source>
          <target state="translated">이 URI의 권한 구성 요소가 이미 서버 기반으로 인식 된 경우 이미 사용자 정보, 호스트 및 포트 구성 요소로 구문 분석 된 것입니다. 이 경우 또는이 URI에 권한 컴포넌트가없는 경우이 메소드는 단순히이 URI를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f6747f06730f4f2cd3ccc7aa43e049d9e46fd3b4" translate="yes" xml:space="preserve">
          <source>If this abstract pathname does not denote a directory, then this method returns &lt;code&gt;null&lt;/code&gt;. Otherwise an array of &lt;code&gt;File&lt;/code&gt; objects is returned, one for each file or directory in the directory. Pathnames denoting the directory itself and the directory's parent directory are not included in the result. Each resulting abstract pathname is constructed from this abstract pathname using the &lt;a href=&quot;file#File-java.io.File-java.lang.String-&quot;&gt;&lt;code&gt;File(File,&amp;nbsp;String)&lt;/code&gt;&lt;/a&gt; constructor. Therefore if this pathname is absolute then each resulting pathname is absolute; if this pathname is relative then each resulting pathname will be relative to the same directory.</source>
          <target state="translated">이 추상 패스 명이 디렉토리를 나타내지 않는 경우,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 . 그렇지 않으면 디렉토리의 각 파일 또는 디렉토리마다 하나씩 &lt;code&gt;File&lt;/code&gt; 객체 배열 이 반환됩니다. 디렉토리 자체를 나타내는 경로 이름과 디렉토리의 상위 디렉토리는 결과에 포함되지 않습니다. 각각의 결과 추상 경로 이름은 &lt;a href=&quot;file#File-java.io.File-java.lang.String-&quot;&gt; &lt;code&gt;File(File,&amp;nbsp;String)&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여이 추상 경로 이름으로 구성됩니다. 따라서이 경로 이름이 절대이면 각 결과 경로 이름은 절대입니다. 이 경로 이름이 상대적이면 각 결과 경로 이름은 동일한 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="0a706980eb4f663347a3cb237daa9264b98ba23c" translate="yes" xml:space="preserve">
          <source>If this abstract pathname does not denote a directory, then this method returns &lt;code&gt;null&lt;/code&gt;. Otherwise an array of strings is returned, one for each file or directory in the directory. Names denoting the directory itself and the directory's parent directory are not included in the result. Each string is a file name rather than a complete path.</source>
          <target state="translated">이 추상 패스 명이 디렉토리를 나타내지 않는 경우,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 . 그렇지 않으면 디렉토리의 각 파일 또는 디렉토리마다 하나씩 문자열 배열이 리턴됩니다. 디렉토리 자체를 나타내는 이름과 디렉토리의 상위 디렉토리는 결과에 포함되지 않습니다. 각 문자열은 완전한 경로가 아닌 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7a3be84c548eed0823c8e3139a127143e82621eb" translate="yes" xml:space="preserve">
          <source>If this abstract pathname is already absolute, then the pathname string is simply returned as if by the &lt;code&gt;&lt;a href=&quot;file#getPath--&quot;&gt;&lt;code&gt;getPath()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method. If this abstract pathname is the empty abstract pathname then the pathname string of the current user directory, which is named by the system property &lt;code&gt;user.dir&lt;/code&gt;, is returned. Otherwise this pathname is resolved in a system-dependent way. On UNIX systems, a relative pathname is made absolute by resolving it against the current user directory. On Microsoft Windows systems, a relative pathname is made absolute by resolving it against the current directory of the drive named by the pathname, if any; if not, it is resolved against the current user directory.</source>
          <target state="translated">이 추상 경로명이 이미 절대이면, 경로명 문자열은 &lt;code&gt;&lt;a href=&quot;file#getPath--&quot;&gt;&lt;code&gt;getPath()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드에 의해 리턴되는 것처럼 간단 합니다. 이 추상 경로 이름이 빈 추상 경로 이름이면 시스템 속성 &lt;code&gt;user.dir&lt;/code&gt; 로 이름이 지정된 현재 사용자 디렉토리의 경로 이름 문자열 이 반환됩니다. 그렇지 않으면이 경로 이름은 시스템에 따라 결정됩니다. UNIX 시스템에서 상대 경로 이름은 현재 사용자 디렉토리와 비교하여 절대 경로 이름이됩니다. Microsoft Windows 시스템에서 상대 경로 이름은 경로 이름으로 지정된 드라이브의 현재 디렉토리 (있는 경우)와 비교하여 절대 경로로 만듭니다. 그렇지 않은 경우 현재 사용자 디렉토리에 대해 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="01c37402cc1becc5bfd07365fcd08b2dbdad0ad1" translate="yes" xml:space="preserve">
          <source>If this abstract pathname is the empty abstract pathname then this method returns a &lt;code&gt;Path&lt;/code&gt; that may be used to access the current user directory.</source>
          <target state="translated">이 추상 경로명이 빈 추상 경로명 인 경우,이 메소드는 현재 사용자 디렉토리에 액세스하는 데 사용될 수 있는 &lt;code&gt;Path&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9b7f67a5f088a680ac92408fde260047d736423c" translate="yes" xml:space="preserve">
          <source>If this buffer is backed by an array then buffer position</source>
          <target state="translated">이 버퍼가 배열에 의해 지원되는 경우 버퍼 위치</target>
        </trans-unit>
        <trans-unit id="f89b379a17fce051e1f16277ddcb14ccc4b66b84" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;bytebuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;bytebuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="156fa6ba3e659d60e072ffc378a13f068ae95a75" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;charbuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;charbuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="35a75ac82494b6599a9d8bae6f1e022d63bf504f" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;doublebuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;doublebuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="371c8e2f83e83deb4ece27649db80c4a89e64c63" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;floatbuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;floatbuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6d9ca59cfd7a9df15a63ddbc3c00fb352f1667b5" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;intbuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;intbuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="eedcd5391de7d0bd92118ac43e586d896f287226" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;longbuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;longbuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="36c05dd52389e980b2b475c5bf397dcbfe429999" translate="yes" xml:space="preserve">
          <source>If this buffer is itself read-only then this method behaves in exactly the same way as the &lt;a href=&quot;shortbuffer#duplicate--&quot;&gt;&lt;code&gt;duplicate&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 버퍼 자체가 읽기 전용 인 경우이 메소드는 &lt;a href=&quot;shortbuffer#duplicate--&quot;&gt; &lt;code&gt;duplicate&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5877df09139688bd1d4dd4caded2b54d8b6ef182" translate="yes" xml:space="preserve">
          <source>If this buffer was not mapped in read/write mode (&lt;a href=&quot;channels/filechannel.mapmode#READ_WRITE&quot;&gt;&lt;code&gt;FileChannel.MapMode.READ_WRITE&lt;/code&gt;&lt;/a&gt;) then invoking this method has no effect.</source>
          <target state="translated">이 버퍼가 읽기 / 쓰기 모드 ( &lt;a href=&quot;channels/filechannel.mapmode#READ_WRITE&quot;&gt; &lt;code&gt;FileChannel.MapMode.READ_WRITE&lt;/code&gt; &lt;/a&gt; )로 매핑되지 않은 경우이 메서드를 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a46445cea2b2d0e72d6b122d83869fbc86e4fec2" translate="yes" xml:space="preserve">
          <source>If this canonical name equals</source>
          <target state="translated">이 정식 이름이</target>
        </trans-unit>
        <trans-unit id="ca738f426c40cb3ea3806863cff08f7c8b90ba98" translate="yes" xml:space="preserve">
          <source>If this certificate does not contain a &lt;code&gt;SubjectAltName&lt;/code&gt; extension, &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, a &lt;code&gt;Collection&lt;/code&gt; is returned with an entry representing each &lt;code&gt;GeneralName&lt;/code&gt; included in the extension. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively).</source>
          <target state="translated">이 인증서에 &lt;code&gt;SubjectAltName&lt;/code&gt; 확장자 가 없으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 확장에 포함 된 각 &lt;code&gt;GeneralName&lt;/code&gt; 을 나타내는 항목과 함께 &lt;code&gt;Collection&lt;/code&gt; 이 반환됩니다 . 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태).</target>
        </trans-unit>
        <trans-unit id="21ef757fd34257aff40a963d9fc1a1d93bd09628" translate="yes" xml:space="preserve">
          <source>If this certificate does not contain an &lt;code&gt;IssuerAltName&lt;/code&gt; extension, &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, a &lt;code&gt;Collection&lt;/code&gt; is returned with an entry representing each &lt;code&gt;GeneralName&lt;/code&gt; included in the extension. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). For more details about the formats used for each name type, see the &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; method.</source>
          <target state="translated">이 인증서에 &lt;code&gt;IssuerAltName&lt;/code&gt; 확장이 포함되어 있지 않으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 확장에 포함 된 각 &lt;code&gt;GeneralName&lt;/code&gt; 을 나타내는 항목과 함께 &lt;code&gt;Collection&lt;/code&gt; 이 반환됩니다 . 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 각 이름 유형에 사용되는 형식에 대한 자세한 내용은 &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb57839b1a1ab664307c336a0abc091c0ec8147d" translate="yes" xml:space="preserve">
          <source>If this channel is already closed then invoking this method has no effect.</source>
          <target state="translated">이 채널이 이미 닫혀 있으면이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ab02f31b97ee071939ff874b950f37cd99195cf" translate="yes" xml:space="preserve">
          <source>If this channel is already connected then this method will not block and will immediately return &lt;code&gt;true&lt;/code&gt;. If this channel is in non-blocking mode then this method will return &lt;code&gt;false&lt;/code&gt; if the connection process is not yet complete. If this channel is in blocking mode then this method will block until the connection either completes or fails, and will always either return &lt;code&gt;true&lt;/code&gt; or throw a checked exception describing the failure.</source>
          <target state="translated">이 채널이 이미 연결되어 있으면이 메소드는 차단되지 않고 즉시 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 이 채널이 비 블로킹 모드 인 경우 연결 프로세스가 아직 완료되지 않은 경우이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다. 이 채널이 블로킹 모드 인 경우,이 메소드는 연결이 완료되거나 실패 할 때까지 차단되며 항상 &lt;code&gt;true&lt;/code&gt; 를 리턴 하거나 실패를 설명하는 점검 된 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3d7c302dbe2f695025b8640ac34f50a0de64f0c2" translate="yes" xml:space="preserve">
          <source>If this channel is already registered with the given selector then the selection key representing that registration is returned after setting its interest set to the given value.</source>
          <target state="translated">이 채널이 지정된 선택기로 이미 등록 된 경우 관심 설정을 지정된 값으로 설정 한 후 해당 등록을 나타내는 선택 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d87bd2f3adfdc3f28325dac54a700242beec8405" translate="yes" xml:space="preserve">
          <source>If this channel is closed by another thread during an invocation of this method then an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">이 메소드의 호출 중에 다른 thread에 의해이 채널이 닫히면 (자), &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbdb52e985c96146985878c92a9ee572c7a87bf" translate="yes" xml:space="preserve">
          <source>If this channel is closed then the value returned by this method is not specified.</source>
          <target state="translated">이 채널이 닫히면이 메소드가 리턴 한 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="163dba92f7b27612158435e616665962f5f46564" translate="yes" xml:space="preserve">
          <source>If this channel is closed while this operation is in progress then the key returned by this method will have been cancelled and will therefore be invalid.</source>
          <target state="translated">이 작업이 진행되는 동안이 채널이 닫히면이 방법으로 반환 된 키가 취소되어 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="570c45f56fd23551052dac6addc16e9085479d7c" translate="yes" xml:space="preserve">
          <source>If this channel is currently a member of the group on the given interface to receive all datagrams then the membership key, representing that membership, is returned. Otherwise this channel joins the group and the resulting new membership key is returned. The resulting membership key is not &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt;&lt;code&gt;source-specific&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 채널이 현재 지정된 인터페이스에서 모든 데이터 그램을 수신하기 위해 그룹의 멤버 인 경우 해당 멤버쉽을 나타내는 멤버쉽 키가 리턴됩니다. 그렇지 않으면이 채널이 그룹에 가입하고 결과로 생성 된 새 멤버쉽 키가 반환됩니다. 결과 멤버십 키는 &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt; &lt;code&gt;source-specific&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f801112322d04b871768e0c5d6c19666441d7d93" translate="yes" xml:space="preserve">
          <source>If this channel is currently a member of the group on the given interface to receive datagrams from the given source address then the membership key, representing that membership, is returned. Otherwise this channel joins the group and the resulting new membership key is returned. The resulting membership key is &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt;&lt;code&gt;source-specific&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 채널이 현재 지정된 소스 주소에서 데이터 그램을 수신하기 위해 지정된 인터페이스에서 그룹의 멤버 인 경우 해당 멤버쉽을 나타내는 멤버쉽 키가 리턴됩니다. 그렇지 않으면이 채널이 그룹에 가입하고 결과로 생성 된 새 멤버쉽 키가 반환됩니다. 결과 멤버십 키는 &lt;a href=&quot;membershipkey#sourceAddress--&quot;&gt; &lt;code&gt;source-specific&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10e0307a2763fb964960a3bb207d0318d28aa119" translate="yes" xml:space="preserve">
          <source>If this channel is currently registered with the given selector then the selection key representing that registration is returned. The key's interest set will have been changed to &lt;code&gt;ops&lt;/code&gt;, as if by invoking the &lt;a href=&quot;selectionkey#interestOps-int-&quot;&gt;&lt;code&gt;interestOps(int)&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;att&lt;/code&gt; argument is not &lt;code&gt;null&lt;/code&gt; then the key's attachment will have been set to that value. A &lt;a href=&quot;cancelledkeyexception&quot;&gt;&lt;code&gt;CancelledKeyException&lt;/code&gt;&lt;/a&gt; will be thrown if the key has already been cancelled.</source>
          <target state="translated">이 채널이 현재 지정된 선택기로 등록되어 있으면 해당 등록을 나타내는 선택 키가 반환됩니다. &lt;a href=&quot;selectionkey#interestOps-int-&quot;&gt; &lt;code&gt;interestOps(int)&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것처럼 키의 관심사 세트가 &lt;code&gt;ops&lt;/code&gt; 로 변경되었습니다 . 경우 &lt;code&gt;att&lt;/code&gt; 인수가 아닌 &lt;code&gt;null&lt;/code&gt; 다음 키의 첨부는 그 값으로 설정되어있는 것입니다. &lt;a href=&quot;cancelledkeyexception&quot;&gt; &lt;code&gt;CancelledKeyException&lt;/code&gt; 에러는&lt;/a&gt; 키가 이미 취소 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="731ff7e16ea304387baccdf40ccf8446f1ff82b2" translate="yes" xml:space="preserve">
          <source>If this channel is in blocking mode then an invocation of this method will block until the connection is established or an I/O error occurs.</source>
          <target state="translated">이 채널이 블로킹 모드에 있으면이 메소드의 호출은 연결이 설정되거나 I / O 오류가 발생할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c4af049551fd4be314d3714c933c67ea1e633195" translate="yes" xml:space="preserve">
          <source>If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single datagram to the given target address.</source>
          <target state="translated">이 채널이 비 차단 모드에 있고 기본 출력 버퍼에 충분한 공간이 있거나이 채널이 차단 모드에 있고 충분한 공간을 사용할 수있게되면 주어진 버퍼의 나머지 바이트가 단일 데이터 그램으로 전송됩니다. 주어진 목표 주소.</target>
        </trans-unit>
        <trans-unit id="a8abf8e95673d1e00311052153bdf85098ea24d2" translate="yes" xml:space="preserve">
          <source>If this channel is in non-blocking mode then an invocation of this method initiates a non-blocking connection operation. If the connection is established immediately, as can happen with a local connection, then this method returns &lt;code&gt;true&lt;/code&gt;. Otherwise this method returns &lt;code&gt;false&lt;/code&gt; and the connection operation must later be completed by invoking the &lt;a href=&quot;socketchannel#finishConnect--&quot;&gt;&lt;code&gt;finishConnect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 채널이 비 차단 모드 인 경우이 방법을 호출하면 비 차단 연결 작업이 시작됩니다. 로컬 연결에서 발생할 수있는 것처럼 연결이 즉시 설정되면이 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 리턴 하고 &lt;a href=&quot;socketchannel#finishConnect--&quot;&gt; &lt;code&gt;finishConnect&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 나중에 연결 조작을 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96a8b30b6de24a4c9b0a5b52fe7f2986ad339a52" translate="yes" xml:space="preserve">
          <source>If this channel is in non-blocking mode then this method will immediately return &lt;code&gt;null&lt;/code&gt; if there are no pending connections. Otherwise it will block indefinitely until a new connection is available or an I/O error occurs.</source>
          <target state="translated">이 채널이 비 차단 모드 인 경우 보류중인 연결이 없으면 이 메서드는 즉시 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다. 그렇지 않으면 새 연결을 사용할 수 있거나 I / O 오류가 발생할 때까지 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="90989044c141384d7c72d3db34ded45944982562" translate="yes" xml:space="preserve">
          <source>If this channel is registered with one or more selectors then an attempt to place it into blocking mode will cause an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">이 채널이 하나 이상의 선택기에 등록 된 경우 차단 모드로 설정하려고하면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69f3fb5016a511b899c6888623fee283b8c8ccae" translate="yes" xml:space="preserve">
          <source>If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash.</source>
          <target state="translated">이 채널의 파일이 로컬 저장 장치에 상주하는 경우이 메서드가 반환되면이 채널을 만든 후 또는이 메서드를 마지막으로 호출 한 이후에 파일에 대한 모든 변경 내용이 해당 장치에 기록 된 것입니다. 시스템 충돌시 중요한 정보가 손실되지 않도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0983d675f212d67b75b1d6a5a184d98509d7348d" translate="yes" xml:space="preserve">
          <source>If this channel's socket is not connected, or if the channel is closed, then invoking this method has no effect.</source>
          <target state="translated">이 채널의 소켓이 연결되어 있지 않거나 채널이 닫혀 있으면이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e22345f8e4dbdb6cf9ef6dd7404a94dfa19e4d17" translate="yes" xml:space="preserve">
          <source>If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from &lt;code&gt;random&lt;/code&gt;.</source>
          <target state="translated">이 암호 (기본 피드백 또는 패딩 체계 포함)에 임의의 바이트 (예 : 매개 변수 생성)가 필요한 경우 &lt;code&gt;random&lt;/code&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="df4c7583376380d891b8180fbc799056297727ce" translate="yes" xml:space="preserve">
          <source>If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the &lt;a href=&quot;../../java/security/securerandom&quot;&gt;&lt;code&gt;SecureRandom&lt;/code&gt;&lt;/a&gt; implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)</source>
          <target state="translated">이 암호 (기본 피드백 또는 패딩 체계 포함)에 임의의 바이트가 필요한 경우 (예를 들어, 매개 변수 생성), 우선 순위가 가장 높은 설치된 제공자 의 &lt;a href=&quot;../../java/security/securerandom&quot;&gt; &lt;code&gt;SecureRandom&lt;/code&gt; &lt;/a&gt; 구현을 임의성 소스로 사용하여 암호화 합니다. (설치된 공급자 중 어느 것도 SecureRandom의 구현을 제공하지 않으면 시스템에서 제공하는 무작위 소스가 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="1f014b120b82cdd937f7d72a75fe35be62115d12" translate="yes" xml:space="preserve">
          <source>If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the &lt;code&gt;SecureRandom&lt;/code&gt; implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)</source>
          <target state="translated">이 암호 (기본 피드백 또는 패딩 체계 포함)에 임의의 바이트가 필요한 경우 (예를 들어, 매개 변수 생성), 우선 순위가 가장 높은 설치된 제공자 의 &lt;code&gt;SecureRandom&lt;/code&gt; 구현을 임의성 소스로 사용하여 암호화 합니다. (설치된 공급자 중 어느 것도 SecureRandom의 구현을 제공하지 않으면 시스템에서 제공하는 무작위 소스가 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="ba0b3c8786993d9f760f587fe2264fbe88b5a094" translate="yes" xml:space="preserve">
          <source>If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail.</source>
          <target state="translated">이 암호에 입력 매개 변수에서 파생 될 수없는 알고리즘 매개 변수가 필요하고 적절한 공급자 별 기본값이 없으면 초기화가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c9607337bc0d2c4ac058d5f2be65c25112f2a16a" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters and &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipher#getParameters--&quot;&gt;&lt;code&gt;getParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipher#getIV--&quot;&gt;&lt;code&gt;getIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호 알고리즘 파라미터 및 필요한 경우 &lt;code&gt;params&lt;/code&gt; NULL, 기본 암호화 구현은 암호화 또는 열쇠 랩핑 용으로 초기화되고 있으면 (공급자 별 기본 또는 임의의 값을 사용하여) 필요한 파라미터 자체를 생성 및 상승하도록되어있다 &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; 가 있는 경우를 암호 해독 또는 키 언 래핑을 위해 초기화되고 있습니다. 생성 된 매개 변수는 &lt;a href=&quot;cipher#getParameters--&quot;&gt; &lt;code&gt;getParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipher#getIV--&quot;&gt; &lt;code&gt;getIV&lt;/code&gt; &lt;/a&gt; (매개 변수가 IV 인 경우)를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9885890d448faaca56b5580f516444c6cfac3586" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters and &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipherspi#engineGetParameters--&quot;&gt;&lt;code&gt;engineGetParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipherspi#engineGetIV--&quot;&gt;&lt;code&gt;engineGetIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호 알고리즘 파라미터 및 필요한 경우 &lt;code&gt;params&lt;/code&gt; NULL, 기본 암호화 구현은 암호화 또는 열쇠 랩핑 용으로 초기화되고 있으면 (공급자 별 기본 또는 임의의 값을 사용하여) 필요한 파라미터 자체를 생성 및 상승하도록되어있다 &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; 가 있는 경우를 암호 해독 또는 키 언 래핑을 위해 초기화되고 있습니다. 생성 된 매개 변수는 &lt;a href=&quot;cipherspi#engineGetParameters--&quot;&gt; &lt;code&gt;engineGetParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipherspi#engineGetIV--&quot;&gt; &lt;code&gt;engineGetIV&lt;/code&gt; 를&lt;/a&gt; 사용하여 검색 할 수 있습니다 (매개 변수가 IV 인 경우).</target>
        </trans-unit>
        <trans-unit id="1ee2bdd99eb0055747a5b587dd5410737fc50478" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters that cannot be derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipher#getParameters--&quot;&gt;&lt;code&gt;getParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipher#getIV--&quot;&gt;&lt;code&gt;getIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호에 지정된 &lt;code&gt;key&lt;/code&gt; 부터 파생 할 수없는 알고리즘 매개 변수가 필요한 경우, 암호화 또는 키 랩핑을 위해 초기화되는 경우 기본 암호 구현은 필요한 매개 변수 자체 (제공자 별 기본값 또는 임의 값 사용)를 생성해야합니다. 제기 &lt;code&gt;InvalidKeyException&lt;/code&gt; 복호화 또는 키 랩핑 해제 용으로 초기화되고 있으면. 생성 된 매개 변수는 &lt;a href=&quot;cipher#getParameters--&quot;&gt; &lt;code&gt;getParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipher#getIV--&quot;&gt; &lt;code&gt;getIV&lt;/code&gt; &lt;/a&gt; (매개 변수가 IV 인 경우)를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1a771ba743be01067043fa16cfae7decccc00fb" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters that cannot be derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipherspi#engineGetParameters--&quot;&gt;&lt;code&gt;engineGetParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipherspi#engineGetIV--&quot;&gt;&lt;code&gt;engineGetIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호에 지정된 &lt;code&gt;key&lt;/code&gt; 부터 파생 할 수없는 알고리즘 매개 변수가 필요한 경우, 암호화 또는 키 랩핑을 위해 초기화되는 경우 기본 암호 구현은 필요한 매개 변수 자체 (제공자 별 기본값 또는 임의 값 사용)를 생성해야합니다. 제기 &lt;code&gt;InvalidKeyException&lt;/code&gt; 복호화 또는 키 랩핑 해제 용으로 초기화되고 있으면. 생성 된 매개 변수는 &lt;a href=&quot;cipherspi#engineGetParameters--&quot;&gt; &lt;code&gt;engineGetParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipherspi#engineGetIV--&quot;&gt; &lt;code&gt;engineGetIV&lt;/code&gt; 를&lt;/a&gt; 사용하여 검색 할 수 있습니다 (매개 변수가 IV 인 경우).</target>
        </trans-unit>
        <trans-unit id="1ad3aae370c5f54c513619cd9029629a3de2dbf8" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters that cannot be derived from the public key in the given &lt;code&gt;certificate&lt;/code&gt;, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipher#getParameters--&quot;&gt;&lt;code&gt;getParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipher#getIV--&quot;&gt;&lt;code&gt;getIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호에 지정된 &lt;code&gt;certificate&lt;/code&gt; 내의 공개 키로부터 파생 할 수없는 알고리즘 파라미터가 필요한 경우, 암호화 또는 키 랩핑 을 해제하고, 복호화 또는 키 언 랩핑을 위해 초기화되는 경우 &lt;code&gt;InvalidKeyException&lt;/code&gt; 을 발생시킵니다. 생성 된 매개 변수는 &lt;a href=&quot;cipher#getParameters--&quot;&gt; &lt;code&gt;getParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipher#getIV--&quot;&gt; &lt;code&gt;getIV&lt;/code&gt; &lt;/a&gt; (매개 변수가 IV 인 경우)를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd810e0520a9cbad755c6af505916dd59eb466d1" translate="yes" xml:space="preserve">
          <source>If this cipher requires any algorithm parameters that cannot be derived from the public key in the given certificate, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an &lt;code&gt;
 InvalidKeyException&lt;/code&gt; if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using &lt;a href=&quot;cipher#getParameters--&quot;&gt;&lt;code&gt;getParameters&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cipher#getIV--&quot;&gt;&lt;code&gt;getIV&lt;/code&gt;&lt;/a&gt; (if the parameter is an IV).</source>
          <target state="translated">이 암호에 지정된 인증서의 공개 키에서 파생 할 수없는 알고리즘 매개 변수가 필요한 경우 기본 암호 구현은 암호화 또는 키 랩핑 을 해제하고, 복호화 또는 키 언 랩핑을 위해 초기화되는 경우 &lt;code&gt; InvalidKeyException&lt;/code&gt; 을 발생시킵니다. 생성 된 매개 변수는 &lt;a href=&quot;cipher#getParameters--&quot;&gt; &lt;code&gt;getParameters&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;cipher#getIV--&quot;&gt; &lt;code&gt;getIV&lt;/code&gt; &lt;/a&gt; (매개 변수가 IV 인 경우)를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="624f76b7bbcd95cfb5dce88f3ddce2f2d8116067" translate="yes" xml:space="preserve">
          <source>If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 클래스가 존재하지 않거나 클래스가 존재하지만 &lt;code&gt;URLStreamHandler&lt;/code&gt; 의 서브 클래스가 아닌 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="69d4f238f20070124b52ae9bc4ef867a68c61d0a" translate="yes" xml:space="preserve">
          <source>If this class object represents a class of arrays, then the internal form of the name consists of the name of the element type preceded by one or more '&lt;code&gt;[&lt;/code&gt;' characters representing the depth of the array nesting. The encoding of element type names is as follows:</source>
          <target state="translated">이 클래스 객체가 배열 클래스를 나타내는 경우, 이름의 내부 형식은 배열 중첩의 깊이를 나타내는 하나 이상의 ' &lt;code&gt;[&lt;/code&gt; '문자가 앞에 오는 요소 유형의 이름으로 구성됩니다 . 요소 유형 이름의 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="def3edfc8fbf2a15bf3c8b618faaee89903ad9aa" translate="yes" xml:space="preserve">
          <source>If this class object represents a primitive type or void, then the name returned is a &lt;code&gt;String&lt;/code&gt; equal to the Java language keyword corresponding to the primitive type or void.</source>
          <target state="translated">이 클래스 객체가 프리미티브 유형 또는 void를 나타내는 경우, 리턴 된 이름 은 프리미티브 유형 또는 void에 해당하는 Java 언어 키워드와 동일한 &lt;code&gt;String&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3d80b3d6f4447468d30f956a1a77f5832658ebf" translate="yes" xml:space="preserve">
          <source>If this class object represents a reference type that is not an array type then the binary name of the class is returned, as specified by</source>
          <target state="translated">이 클래스 객체가 배열 유형이 아닌 참조 유형을 나타내는 경우 클래스의 이진 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09a4dc4cb86e1e2f58f6aef9bb6951ac52447ad2" translate="yes" xml:space="preserve">
          <source>If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of this collection</source>
          <target state="translated">이 컬렉션이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에이 컬렉션보다 많은 요소가있는 경우) 컬렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이 모음의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="78d6d731c58007d098ae33f9cb0873fdf5217de6" translate="yes" xml:space="preserve">
          <source>If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.</source>
          <target state="translated">이 컬렉션이 요소가 iterator에 의해 리턴되는 순서를 보증하는 경우,이 메소드는 요소를 동일한 순서로 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c98bf87256cbfcf308d313fd2f95fc4c59ba56e" translate="yes" xml:space="preserve">
          <source>If this connector is not already associated with an &lt;code&gt;MBeanServer&lt;/code&gt; object, or if the &lt;code&gt;mbsf.setMBeanServer&lt;/code&gt; call just mentioned succeeds, then &lt;code&gt;mbsf&lt;/code&gt; becomes this connector server's &lt;code&gt;MBeanServer&lt;/code&gt;.</source>
          <target state="translated">이 커넥터가 아직 &lt;code&gt;MBeanServer&lt;/code&gt; 오브젝트 와 연관되어 있지 않거나 방금 언급 한 &lt;code&gt;mbsf.setMBeanServer&lt;/code&gt; 호출이 성공하면 &lt;code&gt;mbsf&lt;/code&gt; 가이 커넥터 서버의 &lt;code&gt;MBeanServer&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="58e96a5a6e2be6622a22adedba3560a6b7eb53b6" translate="yes" xml:space="preserve">
          <source>If this connector server is already associated with an &lt;code&gt;MBeanServer&lt;/code&gt; object, then that object is given to &lt;a href=&quot;../mbeanserverforwarder#setMBeanServer-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;mbsf.setMBeanServer&lt;/code&gt;&lt;/a&gt;. If doing so produces an exception, this method throws the same exception without any other effect.</source>
          <target state="translated">이 커넥터 서버가 이미 &lt;code&gt;MBeanServer&lt;/code&gt; 오브젝트 와 연관되어 있으면 해당 오브젝트가 &lt;a href=&quot;../mbeanserverforwarder#setMBeanServer-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;mbsf.setMBeanServer&lt;/code&gt; 에&lt;/a&gt; 제공됩니다 . 그렇게하면 예외가 발생하면이 방법은 다른 효과없이 동일한 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e199ab0891f8cfdd3a886ca4d5502a09e0396dc4" translate="yes" xml:space="preserve">
          <source>If this connector server is already associated with an &lt;code&gt;MBeanServer&lt;/code&gt; object, then that object is given to &lt;a href=&quot;mbeanserverforwarder#setMBeanServer-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;mbsf.setMBeanServer&lt;/code&gt;&lt;/a&gt;. If doing so produces an exception, this method throws the same exception without any other effect.</source>
          <target state="translated">이 커넥터 서버가 이미 &lt;code&gt;MBeanServer&lt;/code&gt; 오브젝트 와 연관되어 있으면 해당 오브젝트가 &lt;a href=&quot;mbeanserverforwarder#setMBeanServer-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;mbsf.setMBeanServer&lt;/code&gt; 에&lt;/a&gt; 제공됩니다 . 그렇게하면 예외가 발생하면이 방법은 다른 효과없이 동일한 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ae5f6cf31f822688ca1f884ee4068dbfa858e7ae" translate="yes" xml:space="preserve">
          <source>If this connector server is already attached to an MBean server, this method has no effect. The MBean server it is attached to is not necessarily the one it is being registered in.</source>
          <target state="translated">이 커넥터 서버가 이미 MBean 서버에 연결된 경우이 방법은 적용되지 않습니다. 접속 된 MBean 서버가 반드시 등록되어있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="591c70492849834b0b9910ca18bf79e4808ef615" translate="yes" xml:space="preserve">
          <source>If this decoder has already been flushed then invoking this method has no effect.</source>
          <target state="translated">이 디코더가 이미 플러시 된 경우이 메소드를 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="29e1093694eed107a88bf7c07bbd5945249dbbd2" translate="yes" xml:space="preserve">
          <source>If this decoder implements an auto-detecting charset then at a single point during a decoding operation this method may start returning &lt;code&gt;true&lt;/code&gt; to indicate that a specific charset has been detected in the input byte sequence. Once this occurs, the &lt;a href=&quot;charsetdecoder#detectedCharset--&quot;&gt;&lt;code&gt;detectedCharset&lt;/code&gt;&lt;/a&gt; method may be invoked to retrieve the detected charset.</source>
          <target state="translated">이 디코더가 자동 검출 문자셋을 구현하면, 디코딩 동작 동안 단일 지점에서이 방법은 특정 문자셋이 입력 바이트 시퀀스에서 검출되었음을 나타 내기 위해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하기 시작할 수있다 . 이 문제가 발생 하면 감지 된 문자 세트를 검색하기 위해 &lt;a href=&quot;charsetdecoder#detectedCharset--&quot;&gt; &lt;code&gt;detectedCharset&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94371ead6eeef262635714af7aa3dd537f5b17ff" translate="yes" xml:space="preserve">
          <source>If this decoder implements an auto-detecting charset then this method returns the actual charset once it has been detected. After that point, this method returns the same value for the duration of the current decoding operation. If not enough input bytes have yet been read to determine the actual charset then this method throws an &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 디코더가 자동 감지 문자 세트를 구현하면이 메소드는 감지 된 실제 문자 세트를 리턴합니다. 이 시점 이후에이 메서드는 현재 디코딩 작업 기간 동안 동일한 값을 반환합니다. 실제 문자 세트를 판별하기 위해 충분한 입력 바이트를 아직 읽지 않은 경우이 메소드는 &lt;a href=&quot;../../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="c64bf88c12ecf5625c8218a6500e6ed616cbae7d" translate="yes" xml:space="preserve">
          <source>If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 deque가 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에이 deque보다 많은 요소가있는 경우) deque 끝 바로 다음에있는 배열의 요소가 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="02f57345a6452f5e9026d62211962bbc940e055e" translate="yes" xml:space="preserve">
          <source>If this dictionary already contains an entry for the specified &lt;code&gt;key&lt;/code&gt;, the value already in this dictionary for that &lt;code&gt;key&lt;/code&gt; is returned, after modifying the entry to contain the new element.</source>
          <target state="translated">이 사전에 지정된 &lt;code&gt;key&lt;/code&gt; 에 대한 항목이 이미 포함되어 있으면 새 요소를 포함하도록 항목을 수정 한 후 해당 &lt;code&gt;key&lt;/code&gt; 대한이 사전에 이미있는 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="21cdc0ae4deca45735edd1a8c869ab07f87eadf6" translate="yes" xml:space="preserve">
          <source>If this dictionary does not already have an entry for the specified &lt;code&gt;key&lt;/code&gt;, an entry is created for the specified &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">이 사전에 지정된 &lt;code&gt;key&lt;/code&gt; 에 대한 항목이없는 경우 지정된 &lt;code&gt;key&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 에 대한 항목이 작성 되고 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba6239de0cab448d7826072832e3944f0eff1f3" translate="yes" xml:space="preserve">
          <source>If this duration has greater than millisecond precision, then the conversion will drop any excess precision information as though the amount in nanoseconds was subject to integer division by one million.</source>
          <target state="translated">이 지속 시간이 밀리 초보다 큰 정밀도를 갖는 경우, 변환은 나노초 단위의 양이 백만 분의 정수로 분할되는 것처럼 초과 정밀도 정보를 떨어 뜨린다.</target>
        </trans-unit>
        <trans-unit id="646430d8f0c3cf4b060406c066441d14b415faf2" translate="yes" xml:space="preserve">
          <source>If this duration is too large to fit in a &lt;code&gt;long&lt;/code&gt; milliseconds, then an exception is thrown.</source>
          <target state="translated">이 지속 시간이 너무 &lt;code&gt;long&lt;/code&gt; 밀리 초 에 맞지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5eb1910e8a8632050383d1502ff10c5891a131f7" translate="yes" xml:space="preserve">
          <source>If this duration is too large to fit in a &lt;code&gt;long&lt;/code&gt; nanoseconds, then an exception is thrown.</source>
          <target state="translated">이 지속 시간이 너무 &lt;code&gt;long&lt;/code&gt; 나노초 에 맞지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a91202676916cac7dee740e5b4030146c55eaee" translate="yes" xml:space="preserve">
          <source>If this element is one whose declaration is lexically enclosed immediately within the declaration of another element, that other element is returned.</source>
          <target state="translated">이 요소가 선언이 다른 요소의 선언 내에 즉시 어휘 적으로 묶인 요소 인 경우 해당 요소가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f792c4a3d4c584f788e17666a92b9623483ee223" translate="yes" xml:space="preserve">
          <source>If this encoder has already been flushed then invoking this method has no effect.</source>
          <target state="translated">이 엔코더가 이미 세척 된 경우이 방법을 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c074959dfda7a1b8ccc45069a9e2c3e535da645" translate="yes" xml:space="preserve">
          <source>If this exemption mechanism requires any algorithm parameters and &lt;code&gt;params&lt;/code&gt; is null, the underlying exemption mechanism implementation is supposed to generate the required parameters itself (using provider-specific default values); in the case that algorithm parameters must be specified by the caller, an &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; is raised.</source>
          <target state="translated">이 제외 메커니즘에 알고리즘 매개 변수가 필요하고 &lt;code&gt;params&lt;/code&gt; 가 널인 경우 기본 제외 메커니즘 구현은 필수 매개 변수 자체를 생성합니다 (제공자 별 기본값 사용). 호출자가 알고리즘 매개 변수를 지정해야하는 경우 &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f48b406dc55c7d93d9b734b8f828b98a0c6d2cb0" translate="yes" xml:space="preserve">
          <source>If this exemption mechanism requires any algorithm parameters that cannot be derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying exemption mechanism implementation is supposed to generate the required parameters itself (using provider-specific default values); in the case that algorithm parameters must be specified by the caller, an &lt;code&gt;InvalidKeyException&lt;/code&gt; is raised.</source>
          <target state="translated">이 제외 메커니즘에 지정된 &lt;code&gt;key&lt;/code&gt; 에서 파생 될 수없는 알고리즘 매개 변수가 필요한 경우 기본 제외 메커니즘 구현은 필요한 매개 변수 자체를 제공합니다 (제공자 별 기본값 사용). 호출자가 알고리즘 매개 변수를 지정해야하는 경우 &lt;code&gt;InvalidKeyException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50aecb57b570915b3125ed9e4b7405a7c9a0b5c2" translate="yes" xml:space="preserve">
          <source>If this factory cannot create a control using the argument supplied, it should return null. A factory should only throw an exception if it is sure that it is the only intended factory and that no other control factories should be tried. This might happen, for example, if the BER data in the control does not match what is expected of a control with the given OID. Since this method throws &lt;code&gt;NamingException&lt;/code&gt;, any other internally generated exception that should be propagated must be wrapped inside a &lt;code&gt;NamingException&lt;/code&gt;.</source>
          <target state="translated">이 팩토리가 제공된 인수를 사용하여 제어를 작성할 수 없으면 널을 리턴해야합니다. 팩토리가 유일한 팩토리이고 다른 제어 팩토리를 시도해서는 안되는 경우에만 팩토리에서 예외를 처리해야합니다. 예를 들어, 컨트롤의 BER 데이터가 주어진 OID를 가진 컨트롤에 예상되는 것과 일치하지 않는 경우에 발생할 수 있습니다. 이 메소드는 &lt;code&gt;NamingException&lt;/code&gt; 을 Throw하기 때문에 , 전파해야 할 내부적으로 생성 된 다른 예외는 &lt;code&gt;NamingException&lt;/code&gt; 에 랩됩니다 .</target>
        </trans-unit>
        <trans-unit id="45e27c4c938fbe66c22c4c86a3ed6d25c1cb9914" translate="yes" xml:space="preserve">
          <source>If this file has an associated channel then the channel is closed as well.</source>
          <target state="translated">이 파일에 연결된 채널이 있으면 채널도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="635e785cd12b388367b6da4d211b51f42af3dbeb" translate="yes" xml:space="preserve">
          <source>If this implementation supports</source>
          <target state="translated">이 구현이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="fe133eddff804df44bcaf058ea960eef008f4711" translate="yes" xml:space="preserve">
          <source>If this instance was created with the &lt;a href=&quot;inputstreamreader#InputStreamReader-java.io.InputStream-java.lang.String-&quot;&gt;&lt;code&gt;InputStreamReader(InputStream, String)&lt;/code&gt;&lt;/a&gt; constructor then the returned name, being unique for the encoding, may differ from the name passed to the constructor. This method will return &lt;code&gt;null&lt;/code&gt; if the stream has been closed.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;inputstreamreader#InputStreamReader-java.io.InputStream-java.lang.String-&quot;&gt; &lt;code&gt;InputStreamReader(InputStream, String)&lt;/code&gt; &lt;/a&gt; 생성자 로 작성된 경우 인코딩에 고유 한 리턴 된 이름이 생성자에 전달 된 이름과 다를 수 있습니다. 이 메소드는 스트림이 닫힌 경우 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="890b309648dad3759e14d379a74cbd471b520cc0" translate="yes" xml:space="preserve">
          <source>If this instance was created with the &lt;a href=&quot;outputstreamwriter#OutputStreamWriter-java.io.OutputStream-java.lang.String-&quot;&gt;&lt;code&gt;OutputStreamWriter(OutputStream, String)&lt;/code&gt;&lt;/a&gt; constructor then the returned name, being unique for the encoding, may differ from the name passed to the constructor. This method may return &lt;code&gt;null&lt;/code&gt; if the stream has been closed.</source>
          <target state="translated">이 인스턴스가 &lt;a href=&quot;outputstreamwriter#OutputStreamWriter-java.io.OutputStream-java.lang.String-&quot;&gt; &lt;code&gt;OutputStreamWriter(OutputStream, String)&lt;/code&gt; &lt;/a&gt; 생성자로 생성 된 경우 인코딩에 고유 한 반환 이름은 생성자에 전달 된 이름과 다를 수 있습니다. 스트림이 닫힌 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c0c7ed5296853c747df2e52d735327259e31d7a" translate="yes" xml:space="preserve">
          <source>If this instant has greater than millisecond precision, then the conversion will drop any excess precision information as though the amount in nanoseconds was subject to integer division by one million.</source>
          <target state="translated">이 순간이 밀리 초보다 큰 정밀도를 갖는 경우, 변환은 나노초 단위의 양이 백만 분의 정수로 분할되는 것처럼 초과 정밀도 정보를 떨어 뜨릴 것이다.</target>
        </trans-unit>
        <trans-unit id="af5f9e803caf892e414dbe5489eabcd25bc34fc5" translate="yes" xml:space="preserve">
          <source>If this instant represents a point on the time-line too far in the future or past to fit in a &lt;code&gt;long&lt;/code&gt; milliseconds, then an exception is thrown.</source>
          <target state="translated">이 순간이 미래 또는 과거의 타임 라인에서 너무 &lt;code&gt;long&lt;/code&gt; 시간 (밀리 초) 에 맞지 않는 지점을 나타내는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="51dd5d8c5d533ffbfd6b5e326c493179436819ba" translate="yes" xml:space="preserve">
          <source>If this is a &lt;a href=&quot;packageelement#getEnclosingElement--&quot;&gt;package&lt;/a&gt;, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">이것이 &lt;a href=&quot;packageelement#getEnclosingElement--&quot;&gt;package 인&lt;/a&gt; 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf598f6c1d24fa4deedb239a99d3523a7ece48da" translate="yes" xml:space="preserve">
          <source>If this is a &lt;a href=&quot;typeelement#getEnclosingElement--&quot;&gt;top-level type&lt;/a&gt;, its package is returned.</source>
          <target state="translated">이것이 &lt;a href=&quot;typeelement#getEnclosingElement--&quot;&gt;최상위 유형 인&lt;/a&gt; 경우 패키지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6e96bb4b14e3eba6404c2f781fb3a62e040d52fd" translate="yes" xml:space="preserve">
          <source>If this is a &lt;a href=&quot;typeparameterelement#getEnclosingElement--&quot;&gt;type parameter&lt;/a&gt;, &lt;a href=&quot;typeparameterelement#getGenericElement--&quot;&gt;the generic element&lt;/a&gt; of the type parameter is returned.</source>
          <target state="translated">이것이 &lt;a href=&quot;typeparameterelement#getEnclosingElement--&quot;&gt;type 매개 변수&lt;/a&gt; 인 &lt;a href=&quot;typeparameterelement#getGenericElement--&quot;&gt;경우 &lt;/a&gt;type 매개 변수 의 일반 요소 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="78cf6561ffb980740deb1888906856d467f5457b" translate="yes" xml:space="preserve">
          <source>If this is a &lt;a href=&quot;variableelement#getEnclosingElement--&quot;&gt;method or constructor parameter&lt;/a&gt;, &lt;a href=&quot;executableelement&quot;&gt;the executable element&lt;/a&gt; which declares the parameter is returned.</source>
          <target state="translated">이것이 &lt;a href=&quot;variableelement#getEnclosingElement--&quot;&gt;메소드 또는 생성자 매개 변수&lt;/a&gt; 인 &lt;a href=&quot;executableelement&quot;&gt;경우 &lt;/a&gt;매개 변수 를 선언하는 실행 가능 요소 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b763c6b818e8148b4556ea7a6bafd024a995a8e8" translate="yes" xml:space="preserve">
          <source>If this is the first &lt;code&gt;LogRecord&lt;/code&gt; to be written to a given &lt;code&gt;OutputStream&lt;/code&gt;, the &lt;code&gt;Formatter&lt;/code&gt;'s &quot;head&quot; string is written to the stream before the &lt;code&gt;LogRecord&lt;/code&gt; is written.</source>
          <target state="translated">이 첫 번째 경우 &lt;code&gt;LogRecord&lt;/code&gt; 의 주어진에 기록되는 &lt;code&gt;OutputStream&lt;/code&gt; 에가 의 &lt;code&gt;Formatter&lt;/code&gt; 전과의 &quot;머리&quot;문자열을 스트림에 기록됩니다 &lt;code&gt;LogRecord&lt;/code&gt; 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="9c8044ad26a6d20700b19f55ec42869a70d922ea" translate="yes" xml:space="preserve">
          <source>If this is the first URL object being created with the specified protocol, a</source>
          <target state="translated">지정된 프로토콜로 생성 된 첫 번째 URL 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="50aab0b1a9c70ab29fd7b9c662b5e7a0eca89f64" translate="yes" xml:space="preserve">
          <source>If this key agreement requires any random bytes, it will get them using the &lt;a href=&quot;../../java/security/securerandom&quot;&gt;&lt;code&gt;SecureRandom&lt;/code&gt;&lt;/a&gt; implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)</source>
          <target state="translated">이 키 계약에 임의의 바이트가 필요한 경우 우선 순위가 가장 높은 설치된 공급자 의 &lt;a href=&quot;../../java/security/securerandom&quot;&gt; &lt;code&gt;SecureRandom&lt;/code&gt; &lt;/a&gt; 구현을 임의 의 소스로 사용하여 가져옵니다 . (설치된 공급자 중 어느 것도 SecureRandom의 구현을 제공하지 않으면 시스템에서 제공하는 무작위 소스가 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="3d76c6a8bf2b303cf2221e92b4e42d6ba8afabe8" translate="yes" xml:space="preserve">
          <source>If this key generator requires any random bytes, it will get them using the &lt;a href=&quot;../../java/security/securerandom&quot;&gt;&lt;code&gt;SecureRandom&lt;/code&gt;&lt;/a&gt; implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)</source>
          <target state="translated">이 키 생성기에 임의의 바이트가 필요한 경우, 우선 순위가 가장 높은 설치된 제공자 의 &lt;a href=&quot;../../java/security/securerandom&quot;&gt; &lt;code&gt;SecureRandom&lt;/code&gt; &lt;/a&gt; 구현을 임의 의 소스로 사용하여 가져옵니다 . (설치된 공급자 중 어느 것도 SecureRandom의 구현을 제공하지 않으면 시스템에서 제공하는 무작위 소스가 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="9bddd254d42eea8986a11358178cffc024f93953" translate="yes" xml:space="preserve">
          <source>If this key has already been cancelled then invoking this method has no effect. Once cancelled, a key remains forever invalid.</source>
          <target state="translated">이 키가 이미 취소 된 경우이 방법을 호출해도 아무런 영향이 없습니다. 취소되면 키는 영원히 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83da59ce9539f95ec07aaec1f4842a15915ef06b" translate="yes" xml:space="preserve">
          <source>If this key has not yet been cancelled then it is added to its selector's cancelled-key set while synchronized on that set.</source>
          <target state="translated">이 키가 아직 취소되지 않은 경우 해당 세트에서 동기화되는 동안 선택기의 취소 된 키 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1efc582a6c2c71ff3e5aca522b4daaec159e53" translate="yes" xml:space="preserve">
          <source>If this key's channel does not support read operations then this method always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 키의 채널이 읽기 조작을 지원하지 않는 경우,이 메소드는 항상 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="890e145cfc4f3f9520f22ce4fa868c255e45c263" translate="yes" xml:space="preserve">
          <source>If this key's channel does not support socket-accept operations then this method always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 키의 채널이 소켓 수락 조작을 지원하지 않는 경우,이 메소드는 항상 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="7ebd7fa86869fc4b87322f9cf2053e6de7a63c99" translate="yes" xml:space="preserve">
          <source>If this key's channel does not support socket-connect operations then this method always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 키의 채널이 소켓 접속 조작을 지원하지 않는 경우,이 메소드는 항상 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e4beaec2b79e41b2d36924704bcbb11dc0727f4f" translate="yes" xml:space="preserve">
          <source>If this key's channel does not support write operations then this method always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 키의 채널이 쓰기 조작을 지원하지 않는 경우,이 메소드는 항상 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="008cdfca03fe48931c96cba5011bb7ee5c689831" translate="yes" xml:space="preserve">
          <source>If this keytab is bound to a specific principal, calling this method on another principal will return an empty array.</source>
          <target state="translated">이 키탭이 특정 주체에 바인딩 된 경우 다른 주체에서이 메서드를 호출하면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="000a1bab763399031238aaa35977217bf11683de" translate="yes" xml:space="preserve">
          <source>If this list fits in the specified array with room to spare (i.e., the array has more elements than this list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of this list</source>
          <target state="translated">이 목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에이 목록보다 많은 요소가있는 경우) 목록의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이 목록의 길이를 결정할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1db15b17eadbce7af9b771b8b76f56db6588ba62" translate="yes" xml:space="preserve">
          <source>If this list has not been explicitly modified, a system-provided default guarantees a minimum quality of service in all enabled cipher suites.</source>
          <target state="translated">이 목록이 명시 적으로 수정되지 않은 경우 시스템 제공 기본값은 사용 가능한 모든 암호 스위트에서 최소 서비스 품질을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="82085a0ded0a26a4ae9cce5749ded99e5178ffdd" translate="yes" xml:space="preserve">
          <source>If this lock is not held when any of the &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; or &lt;a href=&quot;condition#signal--&quot;&gt;signalling&lt;/a&gt; methods are called, then an &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;condition#await--&quot;&gt; 대기 중이&lt;/a&gt; 거나 &lt;a href=&quot;condition#signal--&quot;&gt;신호&lt;/a&gt; 방식이 호출 될 때이 잠금이 유지되지 않으면 &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5eee26829fd18b6973e06016bd08f5d58312d50f" translate="yes" xml:space="preserve">
          <source>If this lock object is valid then invoking this method releases the lock and renders the object invalid. If this lock object is invalid then invoking this method has no effect.</source>
          <target state="translated">이 잠금 오브젝트가 유효하면이 메소드를 호출하면 잠금이 해제되고 오브젝트가 유효하지 않게됩니다. 이 락 객체가 무효 인 경우,이 메소드의 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ced0aadf82c54cdaa29d509af41e23c06fee2d2b" translate="yes" xml:space="preserve">
          <source>If this map permits null values, then a return value of &lt;code&gt;null&lt;/code&gt; does not</source>
          <target state="translated">이 맵이 널값을 허용하는 경우, 리턴 값은 &lt;code&gt;null&lt;/code&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="38c84e3f3622968548e8ca88b47186596616c713" translate="yes" xml:space="preserve">
          <source>If this membership key is not source-specific, and the underlying operating system supports source filtering, then this method blocks multicast datagrams from the given source address. If the given source address is already blocked then this method has no effect. After a source address is blocked it may still be possible to receive datagrams from that source. This can arise when datagrams are waiting to be received in the socket's receive buffer.</source>
          <target state="translated">이 멤버쉽 키가 소스별로 다르고 기본 운영 체제가 소스 필터링을 지원하는 경우이 방법은 지정된 소스 주소에서 멀티 캐스트 데이터 그램을 차단합니다. 주어진 소스 주소가 이미 차단 된 경우이 방법은 효과가 없습니다. 소스 주소가 차단 된 후에도 해당 소스에서 데이터 그램을 수신 할 수 있습니다. 이것은 데이터 그램이 소켓의 수신 버퍼에서 수신 대기 중일 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa3370fa2c521cef5ca42d1f38eef3085fe4df23" translate="yes" xml:space="preserve">
          <source>If this method causes a node to be created, this node is not guaranteed to be persistent until the &lt;code&gt;flush&lt;/code&gt; method is invoked on this node or one of its ancestors (or descendants).</source>
          <target state="translated">이 메소드로 인해 노드가 작성되면 이 노드 또는 해당 노드 (조상 또는 후손) 중 하나 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지이 노드가 지속되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b7763898ffe1310d7a9cc8d3b7a661370fcf75bb" translate="yes" xml:space="preserve">
          <source>If this method completes successfully then it returns &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt;&lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt;&lt;/a&gt;. If there is insufficient room in the output buffer then it returns &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt;&lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt;&lt;/a&gt;. If this happens then this method must be invoked again, with an output buffer that has more room, in order to complete the current &lt;a href=&quot;#steps&quot;&gt;decoding operation&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 성공적으로 완료되면 &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt; &lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt; 를&lt;/a&gt; 리턴합니다 . 출력 버퍼에 공간이 부족하면 &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt; &lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 이 경우 현재 &lt;a href=&quot;#steps&quot;&gt;디코딩 작업&lt;/a&gt; 을 완료하려면 더 많은 공간이있는 출력 버퍼를 사용하여이 메소드를 다시 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="da3a441ed392e261c85ef52698fd864dc0d74f93" translate="yes" xml:space="preserve">
          <source>If this method completes successfully then it returns &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt;&lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt;&lt;/a&gt;. If there is insufficient room in the output buffer then it returns &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt;&lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt;&lt;/a&gt;. If this happens then this method must be invoked again, with an output buffer that has more room, in order to complete the current &lt;a href=&quot;#steps&quot;&gt;encoding operation&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 성공적으로 완료되면 &lt;a href=&quot;coderresult#UNDERFLOW&quot;&gt; &lt;code&gt;CoderResult.UNDERFLOW&lt;/code&gt; 를&lt;/a&gt; 리턴합니다 . 출력 버퍼에 공간이 부족하면 &lt;a href=&quot;coderresult#OVERFLOW&quot;&gt; &lt;code&gt;CoderResult.OVERFLOW&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 이 경우 현재 &lt;a href=&quot;#steps&quot;&gt;인코딩 작업&lt;/a&gt; 을 완료하려면 더 많은 공간이있는 출력 버퍼와 함께이 메소드를 다시 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f5838e3631d37a22c2762422064d85d5ff87054" translate="yes" xml:space="preserve">
          <source>If this method fails, then it may do so after creating some, but not all, of the parent directories.</source>
          <target state="translated">이 방법이 실패하면 부모 디렉토리의 전부는 아니지만 일부를 만든 후에 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c0928502e859e85a0de01a5473b5cf15abaacf" translate="yes" xml:space="preserve">
          <source>If this method has ever been called on a given &lt;code&gt;AttributeList&lt;/code&gt; instance, a subsequent attempt to add an object to that instance which is not an &lt;code&gt;Attribute&lt;/code&gt; will fail with a &lt;code&gt;IllegalArgumentException&lt;/code&gt;. For compatibility reasons, an &lt;code&gt;AttributeList&lt;/code&gt; on which this method has never been called does allow objects other than &lt;code&gt;Attribute&lt;/code&gt;s to be added.</source>
          <target state="translated">이 방법은 지금까지 주어진 호출 한 경우 &lt;code&gt;AttributeList&lt;/code&gt; 예를, 이후 시도는 인스턴스에 객체를 추가하는 &lt;code&gt;Attribute&lt;/code&gt; 실패합니다 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 . 호환성을 이유로 들어, &lt;code&gt;AttributeList&lt;/code&gt; 이 방법은 수 있습니까 불려 간 적이없는이 아닌 다른 객체 &lt;code&gt;Attribute&lt;/code&gt; 의 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359793ad6432cb9cd5fa8412782ecca71d3df2d7" translate="yes" xml:space="preserve">
          <source>If this method has ever been called on a given &lt;code&gt;RoleList&lt;/code&gt; instance, a subsequent attempt to add an object to that instance which is not a &lt;code&gt;Role&lt;/code&gt; will fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. For compatibility reasons, a &lt;code&gt;RoleList&lt;/code&gt; on which this method has never been called does allow objects other than &lt;code&gt;Role&lt;/code&gt;s to be added.</source>
          <target state="translated">지정된 &lt;code&gt;RoleList&lt;/code&gt; 인스턴스 에서이 메소드를 호출 한 경우, &lt;code&gt;Role&lt;/code&gt; 이 아닌 해당 인스턴스에 오브젝트를 추가하려는 후속 시도 는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 으로 실패합니다 . 호환성 때문에이 메소드를 호출 한 적이없는 &lt;code&gt;RoleList&lt;/code&gt; 에서는 &lt;code&gt;Role&lt;/code&gt; 이외의 오브젝트 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b83e7c1301d5a763b5d828fb7d5af0319b1267" translate="yes" xml:space="preserve">
          <source>If this method has ever been called on a given &lt;code&gt;RoleUnresolvedList&lt;/code&gt; instance, a subsequent attempt to add an object to that instance which is not a &lt;code&gt;RoleUnresolved&lt;/code&gt; will fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. For compatibility reasons, a &lt;code&gt;RoleUnresolvedList&lt;/code&gt; on which this method has never been called does allow objects other than &lt;code&gt;RoleUnresolved&lt;/code&gt;s to be added.</source>
          <target state="translated">이 방법은 지금까지 주어진 호출 한 경우 &lt;code&gt;RoleUnresolvedList&lt;/code&gt; 예, 이후 시도는 인스턴스에 객체를 추가하는 &lt;code&gt;RoleUnresolved&lt;/code&gt; 를가 실패합니다 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 . 호환성을 이유로 들어, &lt;code&gt;RoleUnresolvedList&lt;/code&gt; 이 방법은 수 있습니까 불려 간 적이없는이 아닌 다른 객체 &lt;code&gt;RoleUnresolved&lt;/code&gt; 를 의 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5e28ad1b99be76e057ec854fd96e8b1df9a3fda" translate="yes" xml:space="preserve">
          <source>If this method is called more than once with the same library name, the second and subsequent calls are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec3f1658c64077416de46608c8e7d21bb8a2d5d" translate="yes" xml:space="preserve">
          <source>If this method is called when it is not an overlap, &lt;code&gt;this&lt;/code&gt; is returned.</source>
          <target state="translated">이 오버랩하지 않는 경우,이 메소드가 호출되면, &lt;code&gt;this&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a895efab6b10c654536ae18029ccdc62da13ad3" translate="yes" xml:space="preserve">
          <source>If this method is invoked after the virtual machine has begun its shutdown sequence then if shutdown hooks are being run this method will block indefinitely. If shutdown hooks have already been run and on-exit finalization has been enabled then this method halts the virtual machine with the given status code if the status is nonzero; otherwise, it blocks indefinitely.</source>
          <target state="translated">가상 머신이 종료 시퀀스를 시작한 후이 메소드를 호출하면 종료 후크가 실행중인 경우이 메소드가 무기한 차단됩니다. 종료 후크가 이미 실행되고 종료시 종료가 활성화 된 경우이 방법은 상태가 0이 아닌 경우 지정된 상태 코드로 가상 머신을 중지합니다. 그렇지 않으면 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="41db96f0ae0cfb287399c72e6b99e0ffae187d24" translate="yes" xml:space="preserve">
          <source>If this method is invoked on a node that has been removed with the &lt;a href=&quot;abstractpreferences#removeNode--&quot;&gt;&lt;code&gt;removeNode()&lt;/code&gt;&lt;/a&gt; method, flushSpi() is invoked on this node, but not on others.</source>
          <target state="translated">&lt;a href=&quot;abstractpreferences#removeNode--&quot;&gt; &lt;code&gt;removeNode()&lt;/code&gt; &lt;/a&gt; 메소드 로 제거 된 노드에서이 메소드를 호출 하면 flushSpi ()가이 노드에서 호출되지만 다른 노드에서는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cb89a6eb185edcb78db3f7c05fc5b72ac8edd89" translate="yes" xml:space="preserve">
          <source>If this method is invoked on a node that has been removed with the &lt;a href=&quot;preferences#removeNode--&quot;&gt;&lt;code&gt;removeNode()&lt;/code&gt;&lt;/a&gt; method, flushSpi() is invoked on this node, but not on others.</source>
          <target state="translated">&lt;a href=&quot;preferences#removeNode--&quot;&gt; &lt;code&gt;removeNode()&lt;/code&gt; &lt;/a&gt; 메소드 로 제거 된 노드에서이 메소드를 호출 하면 flushSpi ()가이 노드에서 호출되지만 다른 노드에서는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="897ec622f1324a90c92ac76dcd58ecbd59846a3b" translate="yes" xml:space="preserve">
          <source>If this method is invoked while another invocation of this method or of the &lt;a href=&quot;selectablechannel#register-java.nio.channels.Selector-int-&quot;&gt;&lt;code&gt;register&lt;/code&gt;&lt;/a&gt; method is in progress then it will first block until the other operation is complete.</source>
          <target state="translated">이 메소드 또는 &lt;a href=&quot;selectablechannel#register-java.nio.channels.Selector-int-&quot;&gt; &lt;code&gt;register&lt;/code&gt; &lt;/a&gt; 메소드 의 다른 호출이 진행되는 동안이 메소드가 호출 되면 다른 조작이 완료 될 때까지 먼저 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="f9870c4dbe5964f938a44c3304f30bf52d5b60c0" translate="yes" xml:space="preserve">
          <source>If this method is invoked with equal minimum and maximum widths and a sign style of &lt;code&gt;NOT_NEGATIVE&lt;/code&gt; then it delegates to &lt;code&gt;appendValue(TemporalField,int)&lt;/code&gt;. In this scenario, the formatting and parsing behavior described there occur.</source>
          <target state="translated">이 메소드가, 같은 최소 폭과 최대폭과 부호 스타일 &lt;code&gt;NOT_NEGATIVE&lt;/code&gt; 로 &lt;code&gt;appendValue(TemporalField,int)&lt;/code&gt; 위임됩니다 . 이 시나리오에서는 설명 된 형식화 및 구문 분석 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad729037675a25baa03f0d24a4acba5ac35b089b" translate="yes" xml:space="preserve">
          <source>If this method is not called, the default &lt;code&gt;HostnameVerifier&lt;/code&gt; assumes the connection should not be permitted.</source>
          <target state="translated">이 메소드가 호출되지 않으면 기본 &lt;code&gt;HostnameVerifier&lt;/code&gt; 는 연결이 허용되지 않아야한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b0b6b511fb044eb39545567fe94d211a4d867129" translate="yes" xml:space="preserve">
          <source>If this method is overridden, then &lt;code&gt;super.checkAccess&lt;/code&gt; should be called by the first statement in the overridden method, or the equivalent security check should be placed in the overridden method.</source>
          <target state="translated">이 메소드를 대체 하는 경우 대체 된 메소드의 첫 번째 명령문에서 &lt;code&gt;super.checkAccess&lt;/code&gt; 를 호출하거나 대체 된 메소드에서 동등한 보안 검사를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bba6df9ffc21dac2bfe7a31f9c32e2fce7cb953f" translate="yes" xml:space="preserve">
          <source>If this method is overridden, then &lt;code&gt;super.checkPackageAccess&lt;/code&gt; should be called as the first line in the overridden method.</source>
          <target state="translated">이 메소드를 대체 하는 경우 대체 된 메소드에서 첫 번째 행으로 &lt;code&gt;super.checkPackageAccess&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="8717d447e57fbb7a357ddb19fca08779dbcd403d" translate="yes" xml:space="preserve">
          <source>If this method is overridden, then &lt;code&gt;super.checkPackageDefinition&lt;/code&gt; should be called as the first line in the overridden method.</source>
          <target state="translated">이 메소드를 대체 하는 경우 대체 된 메소드의 첫 번째 행으로 &lt;code&gt;super.checkPackageDefinition&lt;/code&gt; 을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2716b5886dbb3910a787a5d7351e3a6f9642796" translate="yes" xml:space="preserve">
          <source>If this method is overridden, then a call to &lt;code&gt;super.checkMemberAccess&lt;/code&gt; cannot be made, as the default implementation of &lt;code&gt;checkMemberAccess&lt;/code&gt; relies on the code being checked being at a stack depth of 4.</source>
          <target state="translated">이 메소드가 재정의되면 &lt;code&gt;checkMemberAccess&lt;/code&gt; 의 기본 구현은 스택 깊이 4 인 검사중인 코드에 의존 하므로 &lt;code&gt;super.checkMemberAccess&lt;/code&gt; 를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1f2fe15a0c80e5590ecfc272b969b250dc9971d7" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;a href=&quot;filevisitresult#CONTINUE&quot;&gt;&lt;code&gt;CONTINUE&lt;/code&gt;&lt;/a&gt;, then entries in the directory are visited. If this method returns &lt;a href=&quot;filevisitresult#SKIP_SUBTREE&quot;&gt;&lt;code&gt;SKIP_SUBTREE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;filevisitresult#SKIP_SIBLINGS&quot;&gt;&lt;code&gt;SKIP_SIBLINGS&lt;/code&gt;&lt;/a&gt; then entries in the directory (and any descendants) will not be visited.</source>
          <target state="translated">이 메소드가 &lt;a href=&quot;filevisitresult#CONTINUE&quot;&gt; &lt;code&gt;CONTINUE&lt;/code&gt; 를&lt;/a&gt; 리턴 하면 디렉토리의 항목이 방문됩니다. 이 메소드가 &lt;a href=&quot;filevisitresult#SKIP_SUBTREE&quot;&gt; &lt;code&gt;SKIP_SUBTREE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;filevisitresult#SKIP_SIBLINGS&quot;&gt; &lt;code&gt;SKIP_SIBLINGS&lt;/code&gt; &lt;/a&gt; 를 리턴 하면 디렉토리 (및 모든 하위 항목)의 항목을 방문하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e39185a4e0c8088f7aade4e05eb53553f43af678" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;UNSPECIFIED_OPTION&lt;/code&gt;, then this &lt;code&gt;ConfirmationCallback&lt;/code&gt; was instantiated with &lt;code&gt;options&lt;/code&gt; instead of an &lt;code&gt;optionType&lt;/code&gt;. In this case, invoke the &lt;code&gt;getOptions&lt;/code&gt; method to determine which confirmation options to display.</source>
          <target state="translated">이 방법은 반환하면 &lt;code&gt;UNSPECIFIED_OPTION&lt;/code&gt; 을 ,이 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 를가 인스턴스화 된 &lt;code&gt;options&lt;/code&gt; 대신의 &lt;code&gt;optionType&lt;/code&gt; . 이 경우 &lt;code&gt;getOptions&lt;/code&gt; 메소드를 호출하여 표시 할 확인 옵션을 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f8442da076503f391489329dc072c7aef9f736" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;false&lt;/code&gt; for a particular character sequence then more information about why the sequence cannot be encoded may be obtained by performing a full &lt;a href=&quot;#steps&quot;&gt;encoding operation&lt;/a&gt;.</source>
          <target state="translated">이 메서드가 특정 문자 시퀀스에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 전체 &lt;a href=&quot;#steps&quot;&gt;인코딩 작업&lt;/a&gt; 을 수행하여 시퀀스를 인코딩 할 수없는 이유에 대한 자세한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89741f03e2c12e3f9d0377de8cdbc5a8a096de70" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;hasThumbnails&lt;/code&gt; and &lt;code&gt;getNumThumbnails&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;, respectively, and &lt;code&gt;readThumbnail&lt;/code&gt; will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, regardless of their arguments.</source>
          <target state="translated">이 메소드가 &lt;code&gt;false&lt;/code&gt; 를 &lt;code&gt;hasThumbnails&lt;/code&gt; 주는 경우 , hasThumbnails 및 &lt;code&gt;getNumThumbnails&lt;/code&gt; 는 각각 &lt;code&gt;false&lt;/code&gt; 와 &lt;code&gt;0&lt;/code&gt; 를 돌려 &lt;code&gt;readThumbnail&lt;/code&gt; , readThumbnail 는 인수에 관계없이 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="583ee50e7f99c02fd6ebcf8333ad462d124187da" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;null&lt;/code&gt;, i.e. the libraries were not found in any of the JAR files loaded with this class loader, the VM searches the library along the path specified as the &lt;code&gt;java.library.path&lt;/code&gt; property.</source>
          <target state="translated">이 메소드가 &lt;code&gt;null&lt;/code&gt; 를 돌려주는 경우 , 즉이 클래스 로더에 의해로드 된 JAR 파일로 라이브러리가 발견되지 않은 경우, VM은 &lt;code&gt;java.library.path&lt;/code&gt; 프로퍼티 로서 지정된 경로를 따라 라이브러리를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="fd48509152a373edcec8f406d8b8e5710f1c1c27" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;buffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;buffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;buffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;buffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbdb6410341007d87b08daec6c7107ce0df914c6" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a857f7c1ccccfd0ee4edfcfe5dd250a8768e0861" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c55591e8102bdcf445fe25c70543f8c60cb25a" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa27e79e71eea321ee777191049d775b73b8810" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13dc213a3ee30b61fca492d489a4c0f9eb2f263" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17d0fce648cd581a214ad523211f985748ce4de4" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2694b014a8ca3bb488a35a3293aadfd6acca88e" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;true&lt;/code&gt; then the &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;arrayOffset&lt;/code&gt;&lt;/a&gt; methods may safely be invoked.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;arrayOffset&lt;/code&gt; &lt;/a&gt; 메소드가 안전하게 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f30f43a24fc957d3345e50bb02daec3098aff3e0" translate="yes" xml:space="preserve">
          <source>If this method returns successfully, the &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt; the &lt;code&gt;Receiver&lt;/code&gt; belongs to is opened implicitly, if it is not already open. It is possible to close an implicitly opened device by calling &lt;a href=&quot;receiver#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;Receiver&lt;/code&gt;. All open &lt;code&gt;Receiver&lt;/code&gt; instances have to be closed in order to release system resources hold by the &lt;code&gt;MidiDevice&lt;/code&gt;. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 성공적으로 리턴 되면 &lt;code&gt;Receiver&lt;/code&gt; 속한 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 가 아직 열려 있지 않은 경우 내재적으로 열립니다. 반환 된 &lt;code&gt;Receiver&lt;/code&gt; 에서 &lt;a href=&quot;receiver#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 를 호출하여 암시 적으로 열린 장치를 닫을 수 있습니다 . &lt;code&gt;MidiDevice&lt;/code&gt; 가 보유한 시스템 자원을 해제하려면 열려있는 모든 &lt;code&gt;Receiver&lt;/code&gt; 인스턴스를 닫아야 합니다 . 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11090b93bbbee91fc5f0393730ae36edec55ac29" translate="yes" xml:space="preserve">
          <source>If this method returns successfully, the &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt; the &lt;code&gt;Transmitter&lt;/code&gt; belongs to is opened implicitly, if it is not already open. It is possible to close an implicitly opened device by calling &lt;a href=&quot;transmitter#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;Transmitter&lt;/code&gt;. All open &lt;code&gt;Transmitter&lt;/code&gt; instances have to be closed in order to release system resources hold by the &lt;code&gt;MidiDevice&lt;/code&gt;. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 성공적으로 리턴되면 , &lt;code&gt;Transmitter&lt;/code&gt; 속한 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 가 아직 열려 있지 않은 경우 내재적으로 열립니다. 리턴 된 &lt;code&gt;Transmitter&lt;/code&gt; 에서 &lt;a href=&quot;transmitter#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 를 호출하여 내재적으로 열린 장치를 닫을 수 있습니다 . &lt;code&gt;MidiDevice&lt;/code&gt; 가 보유한 시스템 자원을 해제하려면 열려있는 모든 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스를 닫아야 합니다 . 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="014b30135306d4074b7578319732d53aa9c447fc" translate="yes" xml:space="preserve">
          <source>If this method returns true, and a match was found, then more input could cause the match to be lost. If this method returns false and a match was found, then more input might change the match but the match won't be lost. If a match was not found, then requireEnd has no meaning.</source>
          <target state="translated">이 메소드가 true를 리턴하고 일치하는 것이 발견되면, 더 많은 입력으로 일치가 유실 될 수 있습니다. 이 메소드가 false를 리턴하고 일치하는 것이 발견되면, 더 많은 입력이 일치를 변경할 수 있지만 일치는 유실되지 않습니다. 일치하는 것이 없으면 requireEnd는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a99f4d37b88e56a040cef00ac9b0e8bbdb966" translate="yes" xml:space="preserve">
          <source>If this method successfully creates an MBean, a notification is sent as described &lt;a href=&quot;#notif&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 MBean을 작성하면 &lt;a href=&quot;#notif&quot;&gt;위에&lt;/a&gt; 설명한대로 알림이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0872f63d827bd783c6afa520726b944970b97a1" translate="yes" xml:space="preserve">
          <source>If this method successfully registers an MBean, a notification is sent as described &lt;a href=&quot;#notif&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 MBean을 성공적으로 등록하면 &lt;a href=&quot;#notif&quot;&gt;위에&lt;/a&gt; 설명한대로 알림이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ae3a101c67d63daa605cb7ec0e8cbf30e62e517" translate="yes" xml:space="preserve">
          <source>If this method successfully unregisters an MBean, a notification is sent as described &lt;a href=&quot;#notif&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 MBean의 등록을 해제하면 &lt;a href=&quot;#notif&quot;&gt;위에&lt;/a&gt; 설명한대로 알림이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="19bb00699df718b977df1da7ce02cb1fa1580c55" translate="yes" xml:space="preserve">
          <source>If this method throws an exception, no classes have been redefined.</source>
          <target state="translated">이 메소드에서 예외가 발생하면 클래스가 다시 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="d645fdf0c0b5590fb0091579dadbcf7c2685180b" translate="yes" xml:space="preserve">
          <source>If this method throws an exception, no classes have been retransformed.</source>
          <target state="translated">이 메서드에서 예외가 발생하면 클래스가 다시 변환되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="80b175ddef3aedcef9f2574b1f0955c043f5beb5" translate="yes" xml:space="preserve">
          <source>If this method throws an exception, the corresponding call to &lt;code&gt;get&lt;/code&gt; will terminate abnormally with that exception, and no class value will be recorded.</source>
          <target state="translated">이 메소드에서 예외가 발생하면 해당 예외를 &lt;code&gt;get&lt;/code&gt; 해당 호출이 비정상적으로 종료되고 클래스 값이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31f24edbd9312a49f2c5d55339e1a0c7b714be08" translate="yes" xml:space="preserve">
          <source>If this node (or an ancestor) has already been removed with the &lt;a href=&quot;preferences#removeNode--&quot;&gt;&lt;code&gt;removeNode()&lt;/code&gt;&lt;/a&gt; method, it</source>
          <target state="translated">이 노드 (또는 상위 노드)가 &lt;a href=&quot;preferences#removeNode--&quot;&gt; &lt;code&gt;removeNode()&lt;/code&gt; &lt;/a&gt; 메소드로 이미 제거 된 경우</target>
        </trans-unit>
        <trans-unit id="5ee7f0b7048c262e543adfeeb22a030246d06650" translate="yes" xml:space="preserve">
          <source>If this node throws a &lt;code&gt;BackingStoreException&lt;/code&gt;, the exception will propagate out beyond the enclosing &lt;a href=&quot;abstractpreferences#childrenNames--&quot;&gt;&lt;code&gt;childrenNames()&lt;/code&gt;&lt;/a&gt; invocation.</source>
          <target state="translated">이 노드가 &lt;code&gt;BackingStoreException&lt;/code&gt; 을 발생 시키면 예외는 둘러싸는 &lt;a href=&quot;abstractpreferences#childrenNames--&quot;&gt; &lt;code&gt;childrenNames()&lt;/code&gt; &lt;/a&gt; 호출을 넘어 전파 됩니다.</target>
        </trans-unit>
        <trans-unit id="559431be004f78cfedf89622122e661e8465d896" translate="yes" xml:space="preserve">
          <source>If this node throws a &lt;code&gt;BackingStoreException&lt;/code&gt;, the exception will propagate out beyond the enclosing &lt;a href=&quot;abstractpreferences#flush--&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; invocation.</source>
          <target state="translated">이 노드가 &lt;code&gt;BackingStoreException&lt;/code&gt; 을 발생 시키면 예외는 둘러싸는 &lt;a href=&quot;abstractpreferences#flush--&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 호출을 넘어 전파 됩니다.</target>
        </trans-unit>
        <trans-unit id="92b05339fcd195b8f7ac0393a4c15f2aba767bd7" translate="yes" xml:space="preserve">
          <source>If this node throws a &lt;code&gt;BackingStoreException&lt;/code&gt;, the exception will propagate out beyond the enclosing &lt;a href=&quot;abstractpreferences#keys--&quot;&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/a&gt; invocation.</source>
          <target state="translated">이 노드가 &lt;code&gt;BackingStoreException&lt;/code&gt; 을 발생 시키면 예외는 둘러싸는 &lt;a href=&quot;abstractpreferences#keys--&quot;&gt; &lt;code&gt;keys()&lt;/code&gt; &lt;/a&gt; 호출을 넘어 전파 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd45290603e6a182e39c137fb954292209622352" translate="yes" xml:space="preserve">
          <source>If this node throws a &lt;code&gt;BackingStoreException&lt;/code&gt;, the exception will propagate out beyond the enclosing &lt;a href=&quot;abstractpreferences#removeNode--&quot;&gt;&lt;code&gt;removeNode()&lt;/code&gt;&lt;/a&gt; invocation.</source>
          <target state="translated">이 노드가 &lt;code&gt;BackingStoreException&lt;/code&gt; 을 발생 시키면 예외는 둘러싸는 &lt;a href=&quot;abstractpreferences#removeNode--&quot;&gt; &lt;code&gt;removeNode()&lt;/code&gt; &lt;/a&gt; 호출을 넘어 전파 됩니다.</target>
        </trans-unit>
        <trans-unit id="146b76b44e28b571c84f2ccde9b8eac9e2e10eb5" translate="yes" xml:space="preserve">
          <source>If this node throws a &lt;code&gt;BackingStoreException&lt;/code&gt;, the exception will propagate out beyond the enclosing &lt;a href=&quot;abstractpreferences#sync--&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt; invocation.</source>
          <target state="translated">이 노드가 &lt;code&gt;BackingStoreException&lt;/code&gt; 을 발생 시키면 예외는 둘러싸는 &lt;a href=&quot;abstractpreferences#sync--&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt; 호출을 넘어 전파 됩니다.</target>
        </trans-unit>
        <trans-unit id="9042e3a5360f606a37243806960e35e2291e5980" translate="yes" xml:space="preserve">
          <source>If this object has changed, as indicated by the &lt;code&gt;hasChanged&lt;/code&gt; method, then notify all of its observers and then call the &lt;code&gt;clearChanged&lt;/code&gt; method to indicate that this object has no longer changed.</source>
          <target state="translated">&lt;code&gt;hasChanged&lt;/code&gt; 메소드 로 표시된 대로이 오브젝트가 변경된 경우 모든 관찰자에게 알리고 &lt;code&gt;clearChanged&lt;/code&gt; 메소드를 호출 하여이 오브젝트가 더 이상 변경되지 않았 음을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9f163d00f83379280da474191b92bc7dee7c9f64" translate="yes" xml:space="preserve">
          <source>If this object is a wildcard domain (such as *.sun.com), and</source>
          <target state="translated">이 객체가 와일드 카드 도메인 인 경우 (예 : * .sun.com)</target>
        </trans-unit>
        <trans-unit id="3cea4ac3417339627d77e490ba6aa487e04415af" translate="yes" xml:space="preserve">
          <source>If this object represents a class or interface that implements no interfaces, the method returns an array of length 0.</source>
          <target state="translated">이 객체가 인터페이스를 구현하지 않는 클래스 또는 인터페이스를 나타내는 경우, 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6bbfde3dbccd1b93d90d863f22fea55a2270b449" translate="yes" xml:space="preserve">
          <source>If this object represents a class, the return value is an array containing objects representing all interfaces implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this object. For example, given the declaration:</source>
          <target state="translated">이 객체가 클래스를 나타내는 경우, 반환 값은 클래스가 구현 한 모든 인터페이스를 나타내는 객체를 포함하는 배열입니다. 배열에서 인터페이스 객체의 순서는 이 객체가 나타내는 클래스 선언의 &lt;code&gt;implements&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다. 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="68a0eb9644f50dfa3365237e48206912657dedee" translate="yes" xml:space="preserve">
          <source>If this object represents a class, the return value is an array containing objects representing all interfaces implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this object. In the case of an array class, the interfaces &lt;code&gt;Cloneable&lt;/code&gt; and &lt;code&gt;Serializable&lt;/code&gt; are returned in that order.</source>
          <target state="translated">이 객체가 클래스를 나타내는 경우, 반환 값은 클래스가 구현 한 모든 인터페이스를 나타내는 객체를 포함하는 배열입니다. 배열에서 인터페이스 객체의 순서는 이 객체가 나타내는 클래스 선언의 &lt;code&gt;implements&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다. 배열 클래스의 경우 &lt;code&gt;Cloneable&lt;/code&gt; 및 &lt;code&gt;Serializable&lt;/code&gt; 인터페이스 가 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e1fecec3e1842cf6d0a7c3c48522e500eb7718" translate="yes" xml:space="preserve">
          <source>If this object represents a primitive type or void, null is returned.</source>
          <target state="translated">이 객체가 프리미티브 유형을 나타내거나 void이면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="102d58b2bf49f93aca1515c64c4c34bb49821710" translate="yes" xml:space="preserve">
          <source>If this object represents a primitive type or void, the method returns an array of length 0.</source>
          <target state="translated">이 객체가 프리미티브 유형 또는 void를 나타내는 경우, 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="215f219962b0e236319b5b858d3118667b63b93f" translate="yes" xml:space="preserve">
          <source>If this object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;extends&lt;/code&gt; clause of the declaration of the interface represented by this object.</source>
          <target state="translated">이 객체가 인터페이스를 나타내는 경우, 배열은 인터페이스가 직접 확장 한 모든 인터페이스를 나타내는 객체를 포함합니다. 배열의 인터페이스 객체 순서는 이 객체가 나타내는 인터페이스 선언의 &lt;code&gt;extends&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="030be3302e9112b6d0ab9c62370805d7a4c2a90a" translate="yes" xml:space="preserve">
          <source>If this object represents an interface, the array contains objects representing all interfaces extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;extends&lt;/code&gt; clause of the declaration of the interface represented by this object.</source>
          <target state="translated">이 객체가 인터페이스를 나타내는 경우, 배열은 인터페이스가 확장 한 모든 인터페이스를 나타내는 객체를 포함합니다. 배열의 인터페이스 객체 순서는 이 객체가 나타내는 인터페이스 선언의 &lt;code&gt;extends&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="107c6791019a8d7adff1747d6751033e870c95bb" translate="yes" xml:space="preserve">
          <source>If this object was initialized with a single IP address and one of</source>
          <target state="translated">이 개체가 단일 IP 주소와 다음 중 하나를 사용하여 초기화 된 경우</target>
        </trans-unit>
        <trans-unit id="c94c2acd246f41a3340bde4e01678205c3f7fa20" translate="yes" xml:space="preserve">
          <source>If this object was not initialized with a single IP address, and one of this object's IP addresses equals one of</source>
          <target state="translated">이 객체가 단일 IP 주소로 초기화되지 않고이 객체의 IP 주소 중 하나가</target>
        </trans-unit>
        <trans-unit id="2c565fa50ed849b3fe574e7e2acaddd76ed6b27d" translate="yes" xml:space="preserve">
          <source>If this object's certificates are not null, then all of this object's certificates must be present in</source>
          <target state="translated">이 객체의 증명서가 null가 아닌 경우,이 객체의 증명서가 모두 존재해야한다</target>
        </trans-unit>
        <trans-unit id="a8a4f359cc185445100b803f449de95a93aa8f07" translate="yes" xml:space="preserve">
          <source>If this object's className is &quot;&lt;code&gt;*&lt;/code&gt;&quot;,</source>
          <target state="translated">이 객체의 className이 &quot; &lt;code&gt;*&lt;/code&gt; &quot;인 경우</target>
        </trans-unit>
        <trans-unit id="2a727f9940692bdd710512a875498d902fb56362" translate="yes" xml:space="preserve">
          <source>If this object's file (getLocation().getFile()) doesn't equal</source>
          <target state="translated">이 객체의 파일 (getLocation (). getFile ())이 다른 경우</target>
        </trans-unit>
        <trans-unit id="8d1575bbfa673d9c98ae1f0a6fbc3c9445cfd46a" translate="yes" xml:space="preserve">
          <source>If this object's host (getLocation().getHost()) is not null, then the SocketPermission constructed with this object's host must imply the SocketPermission constructed with</source>
          <target state="translated">이 객체의 호스트 (getLocation (). getHost ())가 null가 아닌 경우,이 객체의 호스트로 구축 된 SocketPermission는</target>
        </trans-unit>
        <trans-unit id="f93e8a81abaed7c6dfb8d9745b5294f8948ed92f" translate="yes" xml:space="preserve">
          <source>If this object's location (getLocation()) is not null, then the following checks are made against this object's location and</source>
          <target state="translated">이 객체의 위치 (getLocation ())가 null가 아닌 경우,이 객체의 위치에 대해서 다음의 확인이 행해집니다.</target>
        </trans-unit>
        <trans-unit id="1265a2276f6c2efb4e71acc80c2059bb1488b30c" translate="yes" xml:space="preserve">
          <source>If this object's location equals</source>
          <target state="translated">이 객체의 위치가 같은 경우</target>
        </trans-unit>
        <trans-unit id="accff77e178dc73cf6d4bfd526487c56cebf9d8d" translate="yes" xml:space="preserve">
          <source>If this object's member is &quot;&lt;code&gt;*&lt;/code&gt;&quot;,</source>
          <target state="translated">이 객체의 멤버가 &quot; &lt;code&gt;*&lt;/code&gt; &quot;인 경우</target>
        </trans-unit>
        <trans-unit id="72946dcef5d00302973d96c029cfad37ee53b4d4" translate="yes" xml:space="preserve">
          <source>If this object's objectName</source>
          <target state="translated">이 객체의 objectName</target>
        </trans-unit>
        <trans-unit id="bfdbd62eac79913358a6a925e81b8a1c4083d7be" translate="yes" xml:space="preserve">
          <source>If this object's port (getLocation().getPort()) is not equal to -1 (that is, if a port is specified), it must equal</source>
          <target state="translated">이 객체의 포트 (getLocation (). getPort ())가 -1이 아닌 경우 (즉, 포트가 지정된 경우) 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="e20be575a118272802cce2851bb247a6c997d8f9" translate="yes" xml:space="preserve">
          <source>If this object's reference (getLocation().getRef()) is not null, it must equal</source>
          <target state="translated">이 객체의 참조 (getLocation (). getRef ())가 null이 아닌 경우는</target>
        </trans-unit>
        <trans-unit id="29a4fac479570251a6b38b322c42aff61644037e" translate="yes" xml:space="preserve">
          <source>If this operation succeeds, the line is marked as open, and an &lt;code&gt;&lt;a href=&quot;lineevent.type#OPEN&quot;&gt;&lt;code&gt;OPEN&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; event is dispatched to the line's listeners.</source>
          <target state="translated">이 작업이 성공하면 회선이 열린 것으로 표시되고 &lt;code&gt;&lt;a href=&quot;lineevent.type#OPEN&quot;&gt;&lt;code&gt;OPEN&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 이벤트가 회선의 리스너로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e693e570c2d3a4cf22cb3f646db70276ee3f3cfe" translate="yes" xml:space="preserve">
          <source>If this option is present then a new file is created, failing if the file already exists or is a symbolic link. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">이 옵션이 있으면 파일이 이미 존재하거나 심볼릭 링크 인 경우 새 파일이 생성됩니다. 파일을 작성할 때 파일 존재 여부를 점검하고 파일이 존재하지 않는 경우 파일 작성은 다른 파일 시스템 조작과 관련하여 원 자성입니다. 읽기 전용으로 파일을 열면이 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdcb9ea5fd489f84524729f8084b77cb2a731fb" translate="yes" xml:space="preserve">
          <source>If this option is present then a new file is created, failing if the file already exists. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">이 옵션이 있으면 새 파일이 작성되고 파일이 이미 있으면 실패합니다. 파일을 작성할 때 파일 존재 여부를 점검하고 파일이 존재하지 않는 경우 파일 작성은 다른 파일 시스템 조작과 관련하여 원 자성입니다. 읽기 전용으로 파일을 열면이 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cfedbbbeb7c34fd91e56623eb3a72c083a4274f9" translate="yes" xml:space="preserve">
          <source>If this option is present then an existing file is opened if it exists, otherwise a new file is created. This option is ignored if the &lt;code&gt;CREATE_NEW&lt;/code&gt; option is also present or the file is opened only for reading.</source>
          <target state="translated">이 옵션이 있으면 기존 파일이 존재하면 열려고, 그렇지 않으면 새 파일이 작성됩니다. &lt;code&gt;CREATE_NEW&lt;/code&gt; 옵션이 있거나 파일을 읽기 전용으로 열면 이 옵션이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="65f047e4530eeb8e098678a36747b78cda483f61" translate="yes" xml:space="preserve">
          <source>If this option is present then an existing file is opened if it exists, otherwise a new file is created. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored if the &lt;code&gt;CREATE_NEW&lt;/code&gt; option is also present or the file is opened only for reading.</source>
          <target state="translated">이 옵션이 있으면 기존 파일이 존재하면 열려고, 그렇지 않으면 새 파일이 작성됩니다. 파일을 작성할 때 파일 존재 여부를 점검하고 파일이 존재하지 않는 경우 파일 작성은 다른 파일 시스템 조작과 관련하여 원 자성입니다. &lt;code&gt;CREATE_NEW&lt;/code&gt; 옵션이 있거나 파일을 읽기 전용으로 열면 이 옵션이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="58acc2fa4fe310e68564a49365b12f42e0810bf3" translate="yes" xml:space="preserve">
          <source>If this option is present then the existing file is truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">이 옵션이 있으면 기존 파일이 0 바이트 크기로 잘립니다. 읽기 전용으로 파일을 열면이 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7db5f0753fc18eb30790c031e675e1a8c799a37" translate="yes" xml:space="preserve">
          <source>If this option is present then the file is opened for writing and each invocation of the channel's &lt;code&gt;write&lt;/code&gt; method first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. This option may not be used in conjunction with the &lt;code&gt;READ&lt;/code&gt; or &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; options.</source>
          <target state="translated">이 옵션이 존재하면 파일을 쓰기 위해 열고 채널의 &lt;code&gt;write&lt;/code&gt; 메소드를 호출 할 때마다 위치가 파일의 끝으로 이동 한 다음 요청 된 데이터를 씁니다. 위치의 발전과 데이터 쓰기가 단일 원자 작업으로 수행되는지 여부는 시스템에 따라 다르므로 지정되지 않습니다. 이 옵션은 &lt;code&gt;READ&lt;/code&gt; 또는 &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; 옵션 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd3aa8f58cf9f02bfcdc80cec86a501a8a7247c" translate="yes" xml:space="preserve">
          <source>If this path has one or more elements, and no root component, then this method is equivalent to evaluating the expression:</source>
          <target state="translated">이 경로에 하나 이상의 요소가 있고 루트 구성 요소가없는 경우이 메소드는 표현식을 평가하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30aeff65d6a5437b4b182c4f62c0198083fc0c78" translate="yes" xml:space="preserve">
          <source>If this path is already &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; then this method simply returns this path. Otherwise, this method resolves the path in an implementation dependent manner, typically by resolving the path against a file system default directory. Depending on the implementation, this method may throw an I/O error if the file system is not accessible.</source>
          <target state="translated">이 경로가 이미 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 이면이 메소드는 단순히이 경로를 반환합니다. 그렇지 않은 경우,이 메소드는 일반적으로 파일 시스템 기본 디렉토리에 대한 경로를 분석하여 구현에 의존하는 방식으로 경로를 분석합니다. 구현에 따라이 방법은 파일 시스템에 액세스 할 수없는 경우 I / O 오류를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c90a56c401bf7a00c5a062ce8dc90f5fbdad860" translate="yes" xml:space="preserve">
          <source>If this path is relative then its absolute path is first obtained, as if by invoking the &lt;a href=&quot;path#toAbsolutePath--&quot;&gt;&lt;code&gt;toAbsolutePath&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 경로가 상대 경로 인 경우 &lt;a href=&quot;path#toAbsolutePath--&quot;&gt; &lt;code&gt;toAbsolutePath&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것처럼 절대 경로가 먼저 확보됩니다 .</target>
        </trans-unit>
        <trans-unit id="cee4ecf521bbf7c48468eb74ea9ed7b0eef09055" translate="yes" xml:space="preserve">
          <source>If this path was created by converting a path string using the &lt;a href=&quot;filesystem#getPath-java.lang.String-java.lang.String...-&quot;&gt;&lt;code&gt;getPath&lt;/code&gt;&lt;/a&gt; method then the path string returned by this method may differ from the original String used to create the path.</source>
          <target state="translated">&lt;a href=&quot;filesystem#getPath-java.lang.String-java.lang.String...-&quot;&gt; &lt;code&gt;getPath&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 경로 문자열을 변환하여이 경로를 작성한 경우이 메소드가 리턴 한 경로 문자열은 경로를 작성하는 데 사용 된 원래 문자열과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f3f316869769c8f30bbf29b48d50988b855cb9" translate="yes" xml:space="preserve">
          <source>If this path was created by invoking the &lt;code&gt;File&lt;/code&gt;&lt;a href=&quot;../../io/file#toPath--&quot;&gt;&lt;code&gt;toPath&lt;/code&gt;&lt;/a&gt; method then there is no guarantee that the &lt;code&gt;File&lt;/code&gt; object returned by this method is &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; to the original &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; &lt;a href=&quot;../../io/file#toPath--&quot;&gt; &lt;code&gt;toPath&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여이 경로를 작성한 경우이 메소드가 리턴 한 &lt;code&gt;File&lt;/code&gt; 오브젝트 가 원래 &lt;code&gt;File&lt;/code&gt; &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2380c1feeac1df8b717ffb6d8b0f464f5c1469c4" translate="yes" xml:space="preserve">
          <source>If this pattern does not match any subsequence of the input then the resulting stream has just one element, namely the input sequence in string form.</source>
          <target state="translated">이 패턴이 입력의 서브 시퀀스와 일치하지 않으면 결과 스트림은 하나의 요소, 즉 문자열 형식의 입력 시퀀스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6c129875659d42e8617f0f6fe9f8eeaed922599a" translate="yes" xml:space="preserve">
          <source>If this phaser is a member of a tiered set of phasers, then &lt;code&gt;onAdvance&lt;/code&gt; is invoked only for its root phaser on each advance.</source>
          <target state="translated">이 페이저가 계층화 된 페이저 세트 세트의 구성원 인 경우, 각 사전에 루트 페이저에 대해서만 &lt;code&gt;onAdvance&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="25e351e3788079c7fe12a6a6df200389fde78fe7" translate="yes" xml:space="preserve">
          <source>If this plug-in does not allow the rendering size to be set, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">이 플러그인으로 렌더링 크기를 설정할 수 없으면 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59ba1fa4accaead615f724e3c7c028034f29cc41" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, then any error output generated by subprocesses subsequently started by this object's &lt;a href=&quot;processbuilder#start--&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method will be merged with the standard output, so that both can be read using the &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; method. This makes it easier to correlate error messages with the corresponding output. The initial value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 프로퍼티이 &lt;code&gt;true&lt;/code&gt; 의 경우 ,이 객체의 &lt;a href=&quot;processbuilder#start--&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 이후에 시작된 서브 프로세스에 의해 생성 된 에러 출력 은 표준 출력과 병합되므로, &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 메소드를 사용해 양쪽 모두를 읽을 수 있습니다 . 따라서 오류 메시지를 해당 출력과 쉽게 연관시킬 수 있습니다. 초기 값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed9500168343cb56332d4fc88ac168ed027dc4ed" translate="yes" xml:space="preserve">
          <source>If this property is absent, the default size is defined by the mechanism.</source>
          <target state="translated">이 속성이 없으면 기본 크기는 메커니즘에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="06e5e28626bd6eda0b86511efffb808fc70159b4" translate="yes" xml:space="preserve">
          <source>If this property is absent, the default strength is &lt;code&gt;&quot;high,medium,low&quot;&lt;/code&gt;. The value of this constant is &lt;code&gt;&quot;javax.security.sasl.strength&quot;&lt;/code&gt;.</source>
          <target state="translated">이 속성이 없으면 기본 강도는 &lt;code&gt;&quot;high,medium,low&quot;&lt;/code&gt; 입니다. 이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.strength&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8cc3eda816a77b81a2af6ebc25e493966bcf228c" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the default is determined by the provider.</source>
          <target state="translated">이 속성을 지정하지 않으면 공급자가 기본값을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc49fbf015d08e3eea6e2ecba88f5740773ba2e8" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;pack200.packer#TRUE&quot;&gt;&lt;code&gt;TRUE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer will set the deflation hint accordingly in the output archive, and will not transmit the individual deflation hints of archive elements.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;pack200.packer#TRUE&quot;&gt; &lt;code&gt;TRUE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; 로&lt;/a&gt; 설정되면 패커는 출력 아카이브에서 이에 따라 수축 힌트를 설정하고 아카이브 요소의 개별 수축 힌트를 전송하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d03d5dc13a687142c5929c662ca49d36074a7ded" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;pack200.packer#TRUE&quot;&gt;&lt;code&gt;TRUE&lt;/code&gt;&lt;/a&gt;, the packer will transmit all elements in their original order within the source archive.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;pack200.packer#TRUE&quot;&gt; &lt;code&gt;TRUE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 소스 아카이브 내에서 모든 요소를 ​​원래 순서대로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="75f525ec3fc65cfee3f8f241c0b2d719029df8df" translate="yes" xml:space="preserve">
          <source>If this property is set to a single decimal digit, the packer will use the indicated amount of effort in compressing the archive. Level 1 may produce somewhat larger size and faster compression speed, while level 9 will take much longer but may produce better compression.</source>
          <target state="translated">이 특성이 10 진수 한 자릿수로 설정되면 패커는 표시된 압축 노력을 아카이브 압축에 사용합니다. 수준 1은 다소 큰 크기와 빠른 압축 속도를 생성 할 수 있지만 수준 9는 훨씬 오래 걸리지 만 더 나은 압축을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26004343d49f4de62b441eeb8bc5f6df79863d9" translate="yes" xml:space="preserve">
          <source>If this property is set to the special string &lt;a href=&quot;pack200.packer#KEEP&quot;&gt;&lt;code&gt;KEEP&lt;/code&gt;&lt;/a&gt;, the packer transmits a separate modification time for each input element.</source>
          <target state="translated">이 속성이 특수 문자열 &lt;a href=&quot;pack200.packer#KEEP&quot;&gt; &lt;code&gt;KEEP&lt;/code&gt; &lt;/a&gt; 로 설정되면 패커는 각 입력 요소에 대해 별도의 수정 시간을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="7183fc1cd09c99a8f2ef588139d7494408411a2c" translate="yes" xml:space="preserve">
          <source>If this property is set to the special string &lt;a href=&quot;pack200.packer#KEEP&quot;&gt;&lt;code&gt;KEEP&lt;/code&gt;&lt;/a&gt;, the packer will attempt to determine an independent deflation hint for each available element of the input archive, and transmit this hint separately.</source>
          <target state="translated">이 속성이 특수 문자열 &lt;a href=&quot;pack200.packer#KEEP&quot;&gt; &lt;code&gt;KEEP&lt;/code&gt; &lt;/a&gt; 로 설정되면 패커는 입력 아카이브의 사용 가능한 각 요소에 대해 독립적 인 디플레이션 힌트를 결정하고이 힌트를 별도로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="6707f281e27f03d84f3a7a3c629cdd4096bad1c7" translate="yes" xml:space="preserve">
          <source>If this property is set to the special string &lt;a href=&quot;pack200.packer#LATEST&quot;&gt;&lt;code&gt;LATEST&lt;/code&gt;&lt;/a&gt;, the packer will attempt to determine the latest modification time, among all the available entries in the original archive or the latest modification time of all the available entries in each segment. This single value will be transmitted as part of the segment and applied to all the entries in each segment, &lt;a href=&quot;pack200.packer#SEGMENT_LIMIT&quot;&gt;&lt;code&gt;SEGMENT_LIMIT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성이 특수 문자열 &lt;a href=&quot;pack200.packer#LATEST&quot;&gt; &lt;code&gt;LATEST&lt;/code&gt; &lt;/a&gt; 로 설정되면 패커는 원래 아카이브에서 사용 가능한 모든 항목 중에서 최신 수정 시간 또는 각 세그먼트에서 사용 가능한 모든 항목의 최신 수정 시간을 판별하려고 시도합니다. 이 단일 값은 세그먼트의 일부로 전송되어 각 세그먼트 &lt;a href=&quot;pack200.packer#SEGMENT_LIMIT&quot;&gt; &lt;code&gt;SEGMENT_LIMIT&lt;/code&gt; 의&lt;/a&gt; 모든 항목에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="223580f4429eb5c6ae28663e207c1e32ba4d790d" translate="yes" xml:space="preserve">
          <source>If this provider does not support the creation of such file systems or if the provider does not recognize the file type of the given file then it throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;. The default implementation of this method throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 프로 바이더가 그러한 파일 시스템의 작성을 지원하지 않는 경우, 또는 프로 바이더가 지정된 파일의 파일 형식을 인식하지 않는 경우 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가 Throw 됩니다. 이 메소드의 기본 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="adebdb1d5e5973bafb9cf6145ce5e6e780e19399" translate="yes" xml:space="preserve">
          <source>If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 대기열이 여유 공간이있는 지정된 배열에 들어가면 (즉, 배열에이 대기열보다 많은 요소가있는 경우) 대기열 끝 바로 다음에있는 배열의 요소가 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cc39709616b45493aeca7f5e8ac69e5cb52f845" translate="yes" xml:space="preserve">
          <source>If this scanner has not yet been closed then if its underlying &lt;a href=&quot;../lang/readable&quot;&gt;readable&lt;/a&gt; also implements the &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt; interface then the readable's &lt;code&gt;close&lt;/code&gt; method will be invoked. If this scanner is already closed then invoking this method will have no effect.</source>
          <target state="translated">이 스캐너가 아직 닫히지 않은 경우, 기본 &lt;a href=&quot;../lang/readable&quot;&gt;판독 가능 항목&lt;/a&gt; 도 &lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현 하면 판독 가능함 의 &lt;code&gt;close&lt;/code&gt; 메소드가 호출됩니다. 이 스캐너가 이미 닫혀 있으면이 방법을 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a15e47874a4460c8788d8fab1f7c5d6bc3952dd3" translate="yes" xml:space="preserve">
          <source>If this selector is already closed then invoking this method has no effect.</source>
          <target state="translated">이 셀렉터가 이미 닫혀 있으면이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6405daa2c069d6b40d10358e7bb77371faa4a3a2" translate="yes" xml:space="preserve">
          <source>If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of this set</source>
          <target state="translated">이 세트가 여유 공간이있는 지정된 배열에 맞으면 (즉, 배열에이 세트보다 많은 요소가있는 경우) 세트의 끝 바로 다음에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이 세트의 길이를 결정할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c80184b3688b04badc083e61b15fdf0059d3f2c1" translate="yes" xml:space="preserve">
          <source>If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.</source>
          <target state="translated">이 세트가, 반복자에 의해 요소가 돌려 주어지는 순서를 보증하는 경우,이 메소드는 요소를 같은 순서로 돌려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="94d1259b873602b3b91dfea6d2c8e9566dd609a2" translate="yes" xml:space="preserve">
          <source>If this socket has an associated channel then the channel is closed as well.</source>
          <target state="translated">이 소켓에 연결된 채널이 있으면 채널도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="e0939c800f0a2312fef33d7c5d500964dbec69f2" translate="yes" xml:space="preserve">
          <source>If this socket has an associated channel then the resulting input stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the input stream's &lt;code&gt;read&lt;/code&gt; operations will throw an &lt;a href=&quot;../nio/channels/illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 소켓에 연결된 채널이 있으면 결과 입력 스트림이 모든 작업을 채널에 위임합니다. 채널이 비 블로킹 모드 인 경우 입력 스트림의 &lt;code&gt;read&lt;/code&gt; 작업에서 &lt;a href=&quot;../nio/channels/illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d7ee7bd8c081806387ada503ad7b8c514e5dfac1" translate="yes" xml:space="preserve">
          <source>If this socket has an associated channel then the resulting output stream delegates all of its operations to the channel. If the channel is in non-blocking mode then the output stream's &lt;code&gt;write&lt;/code&gt; operations will throw an &lt;a href=&quot;../nio/channels/illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 소켓에 연결된 채널이 있으면 결과 출력 스트림은 모든 작업을 채널에 위임합니다. 채널이 비 블로킹 모드 인 경우 출력 스트림의 &lt;code&gt;write&lt;/code&gt; 작업에서 &lt;a href=&quot;../nio/channels/illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="693a1800e76c5ac59beead537e01064ff0c4be28" translate="yes" xml:space="preserve">
          <source>If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.</source>
          <target state="translated">이 스플리터를 분할 할 수있는 경우 요소를 포함하는 스플리터를 반환합니다.이 메서드는이 메서드에서 돌아 왔을 때이 스플리터에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c735b11df0039877353011e334fc443d166561ca" translate="yes" xml:space="preserve">
          <source>If this stream has an associated channel then the channel is closed as well.</source>
          <target state="translated">이 스트림에 연결된 채널이 있으면 채널도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="92d68b98e0019a083095ba0519f2ddd9fb22048a" translate="yes" xml:space="preserve">
          <source>If this stream was created from an enumeration, all remaining elements are requested from the enumeration and closed before the &lt;code&gt;close&lt;/code&gt; method returns.</source>
          <target state="translated">이 스트림이 열거에서 작성된 경우, 나머지 모든 요소는 열거에서 요청되고 &lt;code&gt;close&lt;/code&gt; 메소드가 리턴 되기 전에 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="4d83610308e8ed4feab83660c34b5cc784dbd534" translate="yes" xml:space="preserve">
          <source>If this task does not have a completer, invokes &lt;a href=&quot;forkjointask#quietlyComplete--&quot;&gt;&lt;code&gt;ForkJoinTask.quietlyComplete()&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;null&lt;/code&gt;. Or, if the completer's pending count is non-zero, decrements that pending count and returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns the completer. This method can be used as part of a completion traversal loop for homogeneous task hierarchies:</source>
          <target state="translated">이 작업에 완료자가 없으면 &lt;a href=&quot;forkjointask#quietlyComplete--&quot;&gt; &lt;code&gt;ForkJoinTask.quietlyComplete()&lt;/code&gt; &lt;/a&gt; 호출 하고 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 또는 완료 자의 보류 카운트가 0이 아닌 경우 해당 카운트를 감소시키고 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 완료자를 반환합니다. 이 방법은 동종 작업 계층에 대한 완료 순회 루프의 일부로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd12cf42083780739c6a825c0d630d6b5ba9cfcf" translate="yes" xml:space="preserve">
          <source>If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.</source>
          <target state="translated">이 태스크가 완료되지 않은 경우, 존재하는 것으로 알려진 경우이 태스크가 완료 경로에있는 지정된 수의 다른 처리되지 않은 태스크를 처리하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="062c4f45b9bcf8888c66111d88b0a6efdd255e64" translate="yes" xml:space="preserve">
          <source>If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns &lt;code&gt;null&lt;/code&gt;. This method is designed to be used with &lt;a href=&quot;countedcompleter#nextComplete--&quot;&gt;&lt;code&gt;nextComplete()&lt;/code&gt;&lt;/a&gt; in completion traversal loops.</source>
          <target state="translated">이 작업의 보류 카운트가 0이면이 작업을 반환합니다. 그렇지 않으면 보류중인 카운트를 줄이고 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 이 메소드는 완료 순회 루프에서 &lt;a href=&quot;countedcompleter#nextComplete--&quot;&gt; &lt;code&gt;nextComplete()&lt;/code&gt; &lt;/a&gt; 과 함께 사용하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="37210489834346fdfa0ada349e6c4f85f2e096b6" translate="yes" xml:space="preserve">
          <source>If this thread group has a parent thread group, the &lt;code&gt;uncaughtException&lt;/code&gt; method of that parent is called with the same two arguments.</source>
          <target state="translated">이 스레드 그룹에 상위 스레드 그룹이 있으면 해당 상위 의 &lt;code&gt;uncaughtException&lt;/code&gt; 메소드가 동일한 두 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="136205f825397c64ddc73f65dffe39be30ff4a5a" translate="yes" xml:space="preserve">
          <source>If this thread is blocked in a &lt;a href=&quot;../nio/channels/selector&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt; then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's &lt;a href=&quot;../nio/channels/selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method were invoked.</source>
          <target state="translated">이 스레드가 &lt;a href=&quot;../nio/channels/selector&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; 에서 차단 되면 스레드의 인터럽트 상태가 설정되고 선택기의 &lt;a href=&quot;../nio/channels/selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 것처럼 0이 아닌 값으로 선택 조작에서 즉시 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="de3aec7f5e3ea72da2979ae96ca609512aa7e1ac" translate="yes" xml:space="preserve">
          <source>If this thread is blocked in an I/O operation upon an &lt;a href=&quot;../nio/channels/interruptiblechannel&quot;&gt;&lt;code&gt;InterruptibleChannel&lt;/code&gt;&lt;/a&gt; then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a &lt;a href=&quot;../nio/channels/closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스레드가 &lt;a href=&quot;../nio/channels/interruptiblechannel&quot;&gt; &lt;code&gt;InterruptibleChannel&lt;/code&gt; &lt;/a&gt; 에 대한 I / O 조작에서 차단 되면 채널이 닫히고 스레드의 인터럽트 상태가 설정되며 스레드는 &lt;a href=&quot;../nio/channels/closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="4f7e022d7d703785a470b724182da4d83682bbf3" translate="yes" xml:space="preserve">
          <source>If this thread is blocked in an invocation of the &lt;a href=&quot;object#wait--&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;object#wait-long-&quot;&gt;&lt;code&gt;wait(long)&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;object#wait-long-int-&quot;&gt;&lt;code&gt;wait(long, int)&lt;/code&gt;&lt;/a&gt; methods of the &lt;a href=&quot;object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt; class, or of the &lt;a href=&quot;thread#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;thread#join-long-&quot;&gt;&lt;code&gt;join(long)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;thread#join-long-int-&quot;&gt;&lt;code&gt;join(long, int)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;thread#sleep-long-&quot;&gt;&lt;code&gt;sleep(long)&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;thread#sleep-long-int-&quot;&gt;&lt;code&gt;sleep(long, int)&lt;/code&gt;&lt;/a&gt;, methods of this class, then its interrupt status will be cleared and it will receive an &lt;a href=&quot;interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스레드가 &lt;a href=&quot;object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 클래스 또는 &lt;a href=&quot;thread#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;thread#join-long-&quot;&gt; &lt;code&gt;join(long)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;thread#join-long-int-&quot;&gt; &lt;code&gt;join(long, int)&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;object#wait--&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;object#wait-long-&quot;&gt; &lt;code&gt;wait(long)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;object#wait-long-int-&quot;&gt; &lt;code&gt;wait(long, int)&lt;/code&gt; &lt;/a&gt; 메소드 호출에서 차단 된 경우 이 클래스의 , &lt;a href=&quot;thread#sleep-long-&quot;&gt; &lt;code&gt;sleep(long)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;thread#sleep-long-int-&quot;&gt; &lt;code&gt;sleep(long, int)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하면 인터럽트 상태가 지워지고 &lt;a href=&quot;interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dee04fe29a564110a8edc14c833afd51b71a8fd" translate="yes" xml:space="preserve">
          <source>If this thread is different from the current thread (that is, the current thread is trying to stop a thread other than itself), the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method (with a &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; argument) is called in addition. Again, this may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).</source>
          <target state="translated">이 스레드가 현재 스레드와 다른 경우 (즉, 현재 스레드가 자신 이외의 스레드를 중지하려고 시도하는 경우) Security Manager의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드 ( &lt;code&gt;RuntimePermission(&quot;stopThread&quot;)&lt;/code&gt; 인수 사용)가 추가로 호출됩니다. 다시 말하지만, 현재 스레드에서 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6eb1caff0d211bf12bda29597feac8eecc8df201" translate="yes" xml:space="preserve">
          <source>If this thread was constructed using a separate &lt;code&gt;Runnable&lt;/code&gt; run object, then that &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called; otherwise, this method does nothing and returns.</source>
          <target state="translated">이 스레드가 별도의 &lt;code&gt;Runnable&lt;/code&gt; 실행 객체를 사용하여 구성된 경우 해당 &lt;code&gt;Runnable&lt;/code&gt; 객체의 &lt;code&gt;run&lt;/code&gt; 메소드가 호출됩니다. 그렇지 않으면이 메소드는 아무 것도 수행하지 않고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1036a7dd624514ec464cb770020aa6e61ea13a75" translate="yes" xml:space="preserve">
          <source>If this type is a top-level type, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">이 유형이 최상위 유형 인 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e08bb6c116e1da83b9d529a037838f86be336252" translate="yes" xml:space="preserve">
          <source>If this type variable was declared with no explicit upper bounds, the result is &lt;code&gt;java.lang.Object&lt;/code&gt;. If it was declared with multiple upper bounds, the result is an &lt;a href=&quot;intersectiontype&quot;&gt;intersection type&lt;/a&gt;; individual bounds can be found by examining the result's &lt;a href=&quot;intersectiontype#getBounds--&quot;&gt;bounds&lt;/a&gt;.</source>
          <target state="translated">이 타입 변수가 명시적인 상한없이 선언 된 경우 결과는 &lt;code&gt;java.lang.Object&lt;/code&gt; 입니다. 여러 개의 상한으로 선언 된 경우 결과는 &lt;a href=&quot;intersectiontype&quot;&gt;교차 유형입니다&lt;/a&gt; . 결과의 &lt;a href=&quot;intersectiontype#getBounds--&quot;&gt;범위를&lt;/a&gt; 검사하여 개별 범위를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acbf944d3989fe8aba9f6f6ea4080273b18cb6ee" translate="yes" xml:space="preserve">
          <source>If this virtual machine has a console then it is represented by a unique instance of this class which can be obtained by invoking the &lt;a href=&quot;../lang/system#console--&quot;&gt;&lt;code&gt;System.console()&lt;/code&gt;&lt;/a&gt; method. If no console device is available then an invocation of that method will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 가상 머신에 콘솔이있는 경우, &lt;a href=&quot;../lang/system#console--&quot;&gt; &lt;code&gt;System.console()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻을 수있는이 클래스의 고유 인스턴스로 표시됩니다 . 사용 가능한 콘솔 장치가없는 경우 해당 메소드를 호출하면 &lt;code&gt;null&lt;/code&gt; 이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb30c4d00faeeb962ddb4c865ecf63132c1c820" translate="yes" xml:space="preserve">
          <source>If this watch key has already been cancelled then invoking this method has no effect. Once cancelled, a watch key remains forever invalid.</source>
          <target state="translated">이 감시 키가 이미 취소 된 경우이 방법을 호출해도 효과가 없습니다. 일단 취소되면 감시 키는 영원히 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67ae0cc16c031b634fcbfcefd9879a42a332defc" translate="yes" xml:space="preserve">
          <source>If this watch key has been cancelled or this watch key is already in the ready state then invoking this method has no effect. Otherwise if there are pending events for the object then this watch key is immediately re-queued to the watch service. If there are no pending events then the watch key is put into the ready state and will remain in that state until an event is detected or the watch key is cancelled.</source>
          <target state="translated">이 감시 키가 취소되었거나이 감시 키가 이미 준비 상태에 있으면이 방법을 호출해도 아무런 영향이 없습니다. 그렇지 않으면 객체에 대해 보류중인 이벤트가있는 경우이 감시 키는 즉시 감시 서비스에 다시 큐에 대기됩니다. 보류중인 이벤트가 없으면 감시 키는 준비 상태가되며 이벤트가 감지되거나 감시 키가 취소 될 때까지 해당 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="fc96c97802231f3c6be6068b9e85703f581d32c1" translate="yes" xml:space="preserve">
          <source>If this write lock is not held when any &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; method is called then an &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown. (Read locks are held independently of write locks, so are not checked or affected. However it is essentially always an error to invoke a condition waiting method when the current thread has also acquired read locks, since other threads that could unblock it will not be able to acquire the write lock.)</source>
          <target state="translated">&lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 메서드가 호출 될 때이 쓰기 잠금이 유지되지 않으면 &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. (읽기 잠금은 쓰기 잠금과 독립적으로 유지되므로 검사되거나 영향을받지 않습니다. 그러나 현재 스레드가 읽기 잠금을 획득했을 때 조건 대기 메소드를 호출하는 것은 본질적으로 항상 오류입니다. 차단을 해제 할 수있는 다른 스레드는 그렇지 않습니다. 쓰기 잠금을 획득 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5f79e63814e29ed4746eb250848d65b14d8ed57d" translate="yes" xml:space="preserve">
          <source>If timed out while blocked in step 4, return false, else true.</source>
          <target state="translated">4 단계에서 차단되는 동안 시간이 초과되면 false를, 그렇지 않으면 true를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1483298083f3abb8afa0f1aa85d3e5075f14df" translate="yes" xml:space="preserve">
          <source>If true, the proxy is for an MXBean, and appropriate mappings are applied to method parameters and return values.</source>
          <target state="translated">true 인 경우 프록시는 MXBean 용이며 메소드 매개 변수 및 리턴 값에 적절한 맵핑이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b514e3ca049e844626b929e4397fb69536176a9" translate="yes" xml:space="preserve">
          <source>If two MBeanInfo objects return the same values in one of their arrays but in a different order then they are not equal.</source>
          <target state="translated">두 MBeanInfo 오브젝트가 배열 중 하나에서 동일한 값을 리턴하지만 다른 순서로 리턴하면 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3de416a161d2a7eece4b7d623902e09f45d1ac1a" translate="yes" xml:space="preserve">
          <source>If two Permission objects are equal according to the &lt;code&gt;equals&lt;/code&gt; method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of the two Permission objects must produce the same integer result.</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; 메소드 에 따라 두 개의 Permission 오브젝트가 동일한 경우, 두 개의 Permission 오브젝트 각각 에서 &lt;code&gt;hashCode&lt;/code&gt; 메소드 를 호출 하면 동일한 정수 결과가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0a883ac4c9f090a20d5a7c637148cd5c404124c" translate="yes" xml:space="preserve">
          <source>If two instances of &lt;code&gt;Random&lt;/code&gt; are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class &lt;code&gt;Random&lt;/code&gt;. Java implementations must use all the algorithms shown here for the class &lt;code&gt;Random&lt;/code&gt;, for the sake of absolute portability of Java code. However, subclasses of class &lt;code&gt;Random&lt;/code&gt; are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.</source>
          <target state="translated">동일한 시드로 두 개의 &lt;code&gt;Random&lt;/code&gt; 인스턴스 가 작성되고 각각에 대해 동일한 시퀀스의 메소드 호출이 수행되면 동일한 시퀀스의 숫자를 생성하고 리턴합니다. 이 속성을 보장하기 위해 &lt;code&gt;Random&lt;/code&gt; 클래스에 특정 알고리즘이 지정됩니다 . Java 구현 은 Java 코드의 절대 이식성을 위해 &lt;code&gt;Random&lt;/code&gt; 클래스에 대해 여기에 표시된 모든 알고리즘을 사용해야합니다 . 그러나 &lt;code&gt;Random&lt;/code&gt; 클래스의 서브 클래스는 모든 메소드에 대한 일반 계약을 준수하는 한 다른 알고리즘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0375c976322546dce1a4576dbb74510f34a3ade" translate="yes" xml:space="preserve">
          <source>If two methods produce the same item name (for example, &lt;code&gt;getOwner&lt;/code&gt; and &lt;code&gt;isOwner&lt;/code&gt;, or &lt;code&gt;getOwner&lt;/code&gt; and &lt;code&gt;getowner&lt;/code&gt;) then the type is not convertible.</source>
          <target state="translated">두 메소드가 동일한 항목 이름을 생성하면 (예 : &lt;code&gt;getOwner&lt;/code&gt; 및 &lt;code&gt;isOwner&lt;/code&gt; 또는 &lt;code&gt;getOwner&lt;/code&gt; 및 &lt;code&gt;getowner&lt;/code&gt; ) 유형을 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cea1bcc2545da2681608af0aef2a71633ab2ff67" translate="yes" xml:space="preserve">
          <source>If two objects are equal according to the &lt;code&gt;equals(Object)&lt;/code&gt; method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of the two objects must produce the same integer result.</source>
          <target state="translated">&lt;code&gt;equals(Object)&lt;/code&gt; 메소드 에 따라 두 오브젝트가 동일한 경우 두 오브젝트 각각 에서 &lt;code&gt;hashCode&lt;/code&gt; 메소드 를 호출 하면 동일한 정수 결과가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="70c98c2264176024b5b44e24255d881ddec4b3f0" translate="yes" xml:space="preserve">
          <source>If user information is given then it is appended, followed by a commercial-at character (&lt;code&gt;'@'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">사용자 정보가 제공되면 추가되고 상업 문자 ( &lt;code&gt;'@'&lt;/code&gt; )가 옵니다 . 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="39dd44621dc4e48c6ce7a185460bfc4a326f4e14" translate="yes" xml:space="preserve">
          <source>If user information, a host, or a port are given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended.</source>
          <target state="translated">사용자 정보, 호스트 또는 포트가 제공되면 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 문자열 이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4992c99e0e1791dc3d662a55a95e751e859f3fe7" translate="yes" xml:space="preserve">
          <source>If we don't find explicit BeanInfo on a class, we use low-level reflection to study the methods of the class and apply standard design patterns to identify property accessors, event sources, or public methods. We then proceed to analyze the class's superclass and add in the information from it (and possibly on up the superclass chain).</source>
          <target state="translated">클래스에서 명시 적 BeanInfo를 찾지 못하면 저수준 반영을 사용하여 클래스의 메소드를 연구하고 표준 디자인 패턴을 적용하여 특성 접근 자, 이벤트 소스 또는 공용 메소드를 식별합니다. 그런 다음 클래스의 수퍼 클래스를 분석하고 그 정보를 추가합니다 (가능하면 수퍼 클래스 체인에 추가).</target>
        </trans-unit>
        <trans-unit id="249f1ecd847d4ff837d620f68c34ba098b73ce31" translate="yes" xml:space="preserve">
          <source>If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the &quot;sum of salaries&quot; logic using &lt;a href=&quot;collectors#groupingBy-java.util.function.Function-java.util.stream.Collector-&quot;&gt;&lt;code&gt;Collectors.groupingBy(Function, Collector)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">부서별로 급여의 합계를 표시하는 수집기를 만들려면 &lt;a href=&quot;collectors#groupingBy-java.util.function.Function-java.util.stream.Collector-&quot;&gt; &lt;code&gt;Collectors.groupingBy(Function, Collector)&lt;/code&gt; &lt;/a&gt; 사용하여 &quot;봉급 합계&quot;논리를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26d7e844a9f8459934217a70e48f27af2b1b69c5" translate="yes" xml:space="preserve">
          <source>If we wanted to take a stream of strings and concatenate them into a single long string, we &lt;em&gt;could&lt;/em&gt; achieve this with ordinary reduction:</source>
          <target state="translated">문자열 스트림을 가져 와서 하나의 긴 문자열로 연결하려면 일반적인 축소로이를 달성 할 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="75d993d59371bab20ce135584545b17525307c4a" translate="yes" xml:space="preserve">
          <source>If week year &lt;code&gt;'Y'&lt;/code&gt; is specified and the &lt;a href=&quot;dateformat#getCalendar--&quot;&gt;calendar&lt;/a&gt; doesn't support any &lt;a href=&quot;../util/gregoriancalendar#week_year&quot;&gt; week years&lt;/a&gt;, the calendar year (&lt;code&gt;'y'&lt;/code&gt;) is used instead. The support of week years can be tested with a call to &lt;a href=&quot;dateformat#getCalendar--&quot;&gt;&lt;code&gt;getCalendar()&lt;/code&gt;&lt;/a&gt;.&lt;a href=&quot;../util/calendar#isWeekDateSupported--&quot;&gt;&lt;code&gt;isWeekDateSupported()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주년 &lt;code&gt;'Y'&lt;/code&gt; 가 지정되고 &lt;a href=&quot;dateformat#getCalendar--&quot;&gt;달력&lt;/a&gt; 이 &lt;a href=&quot;../util/gregoriancalendar#week_year&quot;&gt;주년을&lt;/a&gt; 지원하지 않으면 달력 연도 ( &lt;code&gt;'y'&lt;/code&gt; )가 대신 사용됩니다. 주별 지원은 &lt;a href=&quot;dateformat#getCalendar--&quot;&gt; &lt;code&gt;getCalendar()&lt;/code&gt; &lt;/a&gt; 호출로 테스트 할 수 있습니다 . &lt;a href=&quot;../util/calendar#isWeekDateSupported--&quot;&gt; &lt;code&gt;isWeekDateSupported()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e787fae525d53f984b40c242326308dcc608cfbc" translate="yes" xml:space="preserve">
          <source>If writeObject is used to write an object that has been previously written with writeUnshared, the previous writeUnshared operation is treated as if it were a write of a separate object. In other words, ObjectOutputStream will never generate back-references to object data written by calls to writeUnshared.</source>
          <target state="translated">writeObject를 사용하여 이전에 writeUnshared로 작성된 오브젝트를 작성하는 경우 이전 writeUnshared 조작은 별도의 오브젝트의 쓰기 인 것처럼 처리됩니다. 다시 말해 ObjectOutputStream은 writeUnshared 호출로 작성된 객체 데이터에 대한 역 참조를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33329ee24831b4b830806a0df21b74b91fbe2bdb" translate="yes" xml:space="preserve">
          <source>If you are formatting multiple dates, it is more efficient to get the format and use it multiple times so that the system doesn't have to fetch the information about the local language and country conventions multiple times.</source>
          <target state="translated">여러 날짜의 형식을 지정하는 경우 시스템에서 현지 언어 및 국가 규칙에 대한 정보를 여러 번 가져올 필요가 없도록 형식을 가져와 여러 번 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dd1b56a949a2d40e2ef6096bec1333c2fcd9c70c" translate="yes" xml:space="preserve">
          <source>If you are formatting multiple numbers, it is more efficient to get the format and use it multiple times so that the system doesn't have to fetch the information about the local language and country conventions multiple times.</source>
          <target state="translated">여러 숫자를 형식화하는 경우 시스템에서 현지 언어 및 국가 규칙에 대한 정보를 여러 번 가져올 필요가 없도록 형식을 가져와 여러 번 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cbc79913bd626004719fe8514d3567201aed1ed4" translate="yes" xml:space="preserve">
          <source>If you are interested in the positions of all attributes in the formatted string use the &lt;code&gt;Format&lt;/code&gt; method &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.</source>
          <target state="translated">형식화 된 문자열에서 모든 속성의 위치에 관심이있는 경우 &lt;code&gt;Format&lt;/code&gt; 메소드 &lt;code&gt;formatToCharacterIterator&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4facb91de8b32639ccf8a84b652bd430e83444a" translate="yes" xml:space="preserve">
          <source>If you are using a monospaced font with spacing for alignment, you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output, &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the last character of the integer and the decimal. Add (desiredSpaceCount - getEndIndex) spaces at the front of the string.</source>
          <target state="translated">간격을두고 공백이있는 고정 폭 글꼴을 사용하는 경우 &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt; 와 함께 형식 호출에서 &lt;code&gt;FieldPosition&lt;/code&gt; 을 전달할 수 있습니다 . 출력시, &lt;code&gt;getEndIndex&lt;/code&gt; 는 정수의 마지막 문자와 10 진수 사이의 오프셋으로 설정됩니다. 문자열 앞에 (desiredSpaceCount-getEndIndex) 공백을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9406e93ec5832fb57d51414b10aab81a761c42ae" translate="yes" xml:space="preserve">
          <source>If you are using proportional fonts, instead of padding with spaces, measure the width of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;. Then move the pen by (desiredPixelWidth - widthToAlignmentPoint) before drawing the text. It also works where there is no decimal, but possibly additional characters at the end, e.g., with parentheses in negative numbers: &quot;(12)&quot; for -12.</source>
          <target state="translated">공백으로 채우는 대신 비례 글꼴을 사용하는 경우 시작에서 &lt;code&gt;getEndIndex&lt;/code&gt; 까지 문자열 너비를 픽셀 단위로 측정하십시오 . 그런 다음 텍스트를 그리기 전에 (desiredPixelWidth-widthToAlignmentPoint)만큼 펜을 이동하십시오. 소수점이없는 경우에도 작동하지만 끝에 추가 문자가있을 수 있습니다 (예 : 음수로 괄호를 사용하는 경우 : -12의 경우 &quot;(12)&quot;).</target>
        </trans-unit>
        <trans-unit id="0f106737aef6a81a4054543d7f78f0e7b7a5e9c4" translate="yes" xml:space="preserve">
          <source>If you decide to create a date-time formatter with a specific format pattern for a specific locale, you can do so with:</source>
          <target state="translated">특정 로케일에 대해 특정 형식 패턴으로 날짜-시간 포맷터를 작성하기로 결정한 경우 다음을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a64ac8c1421bcee0c93f8d4f878d8ecbf3d1a551" translate="yes" xml:space="preserve">
          <source>If you have an MBean Server &lt;code&gt;mbs&lt;/code&gt; containing an MBean with &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;name&lt;/code&gt;, and if the MBean's management interface is described by the Java interface &lt;code&gt;MyMBean&lt;/code&gt;, you can construct a proxy for the MBean like this:</source>
          <target state="translated">당신의 MBean 서버가있는 경우 &lt;code&gt;mbs&lt;/code&gt; 와 MBean에 포함 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;name&lt;/code&gt; 가 MBean의 관리 인터페이스는 인터페이스 자바에 의해 기술되는 경우, 그리고 &lt;code&gt;MyMBean&lt;/code&gt; ,이 같은 MBean의 프록시를 구성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="88dcf89fa7f0531902cdd760892b5fd0c5d30465" translate="yes" xml:space="preserve">
          <source>If you have an MBean Server &lt;code&gt;mbs&lt;/code&gt; containing an MXBean with &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;name&lt;/code&gt;, and if the MXBean's management interface is described by the Java interface &lt;code&gt;MyMXBean&lt;/code&gt;, you can construct a proxy for the MXBean like this:</source>
          <target state="translated">당신의 MBean 서버가있는 경우 &lt;code&gt;mbs&lt;/code&gt; 와 함께 MXBean의를 포함하는 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;name&lt;/code&gt; , 그리고의 MXBean의 관리 인터페이스는 자바 인터페이스에 의해 설명되는 경우 &lt;code&gt;MyMXBean&lt;/code&gt; ,이 같은 MXBean의 프록시를 구성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="aeeadc6bd76712b1cf5b57f384a18bfbf8ff9346" translate="yes" xml:space="preserve">
          <source>If you have an MBeanPermission, it allows operations only if all four of the items match.</source>
          <target state="translated">MBeanPermission이 있으면 네 항목 모두가 일치하는 경우에만 조작을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="dcf357f105ce4230844a06dba35ba909423f4aa5" translate="yes" xml:space="preserve">
          <source>If you have an RMI stub of type &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt;, you can construct an RMI connection directly by using the appropriate constructor of &lt;a href=&quot;rmiconnector&quot;&gt;&lt;code&gt;RMIConnector&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt; 유형의 RMI 스텁이있는 경우 적절한 &lt;a href=&quot;rmiconnector&quot;&gt; &lt;code&gt;RMIConnector&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 RMI 연결을 직접 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42e51cf36b22f71cae737ff0a604aab0e89fa946" translate="yes" xml:space="preserve">
          <source>If you make an MXBean proxy for a &lt;code&gt;ModuleMXBean&lt;/code&gt; and call its &lt;code&gt;getProduct()&lt;/code&gt; method, the proxy will map the &lt;code&gt;ObjectName&lt;/code&gt; back into a &lt;code&gt;ProductMXBean&lt;/code&gt; by making another MXBean proxy. More formally, when a proxy made with &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy(mbeanServerConnection, objectNameX,
      interfaceX)&lt;/code&gt;&lt;/a&gt; needs to map &lt;code&gt;objectNameY&lt;/code&gt; back into &lt;code&gt;interfaceY&lt;/code&gt;, another MXBean interface, it does so with &lt;code&gt;JMX.newMXBeanProxy(mbeanServerConnection, objectNameY,
      interfaceY)&lt;/code&gt;. The implementation may return a proxy that was previously created by a call to &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; with the same parameters, or it may create a new proxy.</source>
          <target state="translated">&lt;code&gt;ModuleMXBean&lt;/code&gt; 에 대해 MXBean 프록시를 작성 하고 &lt;code&gt;getProduct()&lt;/code&gt; 메소드를 호출 하면 프록시는 다른 MXBean 프록시를 작성 하여 &lt;code&gt;ObjectName&lt;/code&gt; 을 &lt;code&gt;ProductMXBean&lt;/code&gt; 에 다시 맵핑합니다 . 더 공식적으로 만든 프록시 때 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)&lt;/code&gt; &lt;/a&gt; 매핑해야 &lt;code&gt;objectNameY&lt;/code&gt; 에 다시 &lt;code&gt;interfaceY&lt;/code&gt; , 다른 MXBean의 인터페이스를, 그것과 그렇게 &lt;code&gt;JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)&lt;/code&gt; . 구현시 동일한 매개 변수를 사용하여 &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; 를 호출하여 이전에 작성된 프록시를 리턴 하거나 새 프록시를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36de616fe3a9de0652b022e0f4521a1bc90414b1" translate="yes" xml:space="preserve">
          <source>If you make an MXBean proxy for a &lt;code&gt;ModuleMXBean&lt;/code&gt; and call its &lt;code&gt;setProduct&lt;/code&gt; method, the proxy will map its &lt;code&gt;ProductMXBean&lt;/code&gt; argument back into an &lt;code&gt;ObjectName&lt;/code&gt;. This will only work if the argument is in fact another proxy, for a &lt;code&gt;ProductMXBean&lt;/code&gt; in the same &lt;code&gt;MBeanServerConnection&lt;/code&gt;. The proxy can have been returned from another proxy (like &lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; which returns a proxy for a &lt;code&gt;ProductMXBean&lt;/code&gt;); or it can have been created by &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;; or it can have been created using &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; with an invocation handler that is &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt; or a subclass.</source>
          <target state="translated">&lt;code&gt;ModuleMXBean&lt;/code&gt; 에 대해 MXBean 프록시를 작성 하고 &lt;code&gt;setProduct&lt;/code&gt; 메소드를 호출 하면 프록시는 &lt;code&gt;ProductMXBean&lt;/code&gt; 인수를 &lt;code&gt;ObjectName&lt;/code&gt; 에 다시 맵핑합니다 . 이것은 같은 &lt;code&gt;MBeanServerConnection&lt;/code&gt; 의 &lt;code&gt;ProductMXBean&lt;/code&gt; 에 대한 인수가 실제로 다른 프록시 인 경우에만 작동합니다 . 프록시는 다른 프록시 ( &lt;code&gt;ProductMXBean&lt;/code&gt; 에 대한 프록시를 리턴하는 &lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; 와 같은)에서 리턴 될 수 있습니다 . 또는 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; 에&lt;/a&gt; 의해 작성되었을 수 있습니다 . 또는 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; 인&lt;/a&gt; 호출 핸들러와 함께 &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 를 사용하여 작성할 수 있습니다. 또는 서브 클래스.</target>
        </trans-unit>
        <trans-unit id="3e2b53ae02293acead2a531e5c995698a3d635fc" translate="yes" xml:space="preserve">
          <source>If you need (or choose) to provide a persistence delegate for a bean, you can do so either by using a &lt;a href=&quot;defaultpersistencedelegate&quot;&gt;&lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;&lt;/a&gt; instance or by creating your own subclass of &lt;code&gt;PersistenceDelegate&lt;/code&gt;. If the only reason a bean needs a persistence delegate is because you want to invoke the bean's constructor with property values as arguments, you can create the bean's persistence delegate with the one-argument &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; constructor. Otherwise, you need to implement your own persistence delegate, for which you're likely to need the following classes:</source>
          <target state="translated">Bean에 대한 지속성 위임을 제공해야하는 경우 (또는 선택) &lt;a href=&quot;defaultpersistencedelegate&quot;&gt; &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하거나 고유 한 &lt;code&gt;PersistenceDelegate&lt;/code&gt; 서브 클래스를 작성 하여 수행 할 수 있습니다 . Bean에 지속성 위임이 필요한 유일한 이유는 특성 값을 인수로 사용하여 Bean의 생성자를 호출하려는 경우 한 인수 &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; 생성자를 사용하여 Bean의 지속성 위임을 작성할 수 있습니다 . 그렇지 않으면 다음과 같은 클래스가 필요할 수있는 자체 지속성 위임을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f489d4a0e8c62f4faa7fab289ad65258b11c6f2" translate="yes" xml:space="preserve">
          <source>If you need to return a value, you can do something like the following:</source>
          <target state="translated">값을 반환해야하는 경우 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8c2b1b32a99074d0ed797e0b2d27a5393d1b97c" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkAccept&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkAccept&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="32a163e4193ac982fc24cb8d0e24b6ff2e92df6b" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkAwtEventQueueAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 시점에서 &lt;code&gt;super.checkAwtEventQueueAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b0bf23ffdb875cb462ac3762bf0b0f61436b578" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkConnect&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkConnect&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b25c342fd63139aa40f0f94857b7bcc782f9565" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkCreateClassLoader&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkCreateClassLoader&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c89616b32751c00600ebd3ccc8535ec049f9fdfa" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkDelete&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkDelete&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d275b056a9090e158c634d81a08838570939532f" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkExec&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 재정의하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 시점에서 &lt;code&gt;super.checkExec&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8fad4004790324c59ba0ed5dd06d44da82aaedda" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkExit&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkExit&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efcc6f30743e16455930171e5a781be9f204238f" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkLink&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkLink&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6877a896c1d32e57ba90da2c55b2663b1b78ec" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkListen&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkListen&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4d26672886acca0d759af04d237b7c1efbe698e" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkMulticast&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkMulticast&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="251fab6eb9acffef8859edc74b706798e78e6e8b" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkPrintJobAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkPrintJobAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e10ad25cab0f05b0222d29bd5e36927db4eeb6b2" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkPropertiesAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 시점에서 &lt;code&gt;super.checkPropertiesAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a86588c85e4d6399731a04d49863896ed2dc3e28" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkPropertyAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 시점에서 &lt;code&gt;super.checkPropertyAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa5bed7cbc4197994e6709d36a446566db9ba266" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkRead&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkRead&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d57848509497be814c85001e6b95b9646bffc2a" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkSecurityAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 시점에서 &lt;code&gt;super.checkSecurityAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eebab1fb31a31734e30e41e1327c09607085023c" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkSetFactory&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkSetFactory&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2401855174b74221644d242d6cb2acd443f9052" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkSystemClipboardAccess&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkSystemClipboardAccess&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d59d3d943d86eedf5cde305b53f409a81429ea16" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt; at the point the overridden method would normally return &lt;code&gt;false&lt;/code&gt;, and the value of &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt; should be returned.</source>
          <target state="translated">이 메소드를 대체하는 경우 대체 된 메소드가 일반적으로 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 지점에서 &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt; 를 호출 해야하며 &lt;code&gt;super.checkTopLevelWindow&lt;/code&gt; 의 값 이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8cecc78a2cd42444c250869d1b1fffc199c4eb79" translate="yes" xml:space="preserve">
          <source>If you override this method, then you should make a call to &lt;code&gt;super.checkWrite&lt;/code&gt; at the point the overridden method would normally throw an exception.</source>
          <target state="translated">이 메소드를 재정의하는 경우 대체 된 메소드가 일반적으로 예외를 발생시키는 지점에서 &lt;code&gt;super.checkWrite&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b77207df3b1139f3ea68a88d7c6de19a281d70e" translate="yes" xml:space="preserve">
          <source>If you produce one of these errors, a &lt;code&gt;RuleBasedCollator&lt;/code&gt; throws a &lt;code&gt;ParseException&lt;/code&gt;.</source>
          <target state="translated">이러한 오류 중 하나를 생성하면 &lt;code&gt;RuleBasedCollator&lt;/code&gt; 가 &lt;code&gt;ParseException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e6f41edec5bd75c329a95672b206803463bfa5e8" translate="yes" xml:space="preserve">
          <source>If you read from a socket input stream after invoking this method on the socket, the stream's &lt;code&gt;available&lt;/code&gt; method will return 0, and its &lt;code&gt;read&lt;/code&gt; methods will return &lt;code&gt;-1&lt;/code&gt; (end of stream).</source>
          <target state="translated">소켓에서이 메소드를 호출 한 후 소켓 입력 스트림에서 읽을 경우 스트림의 &lt;code&gt;available&lt;/code&gt; 메소드는 0을 리턴하고 해당 &lt;code&gt;read&lt;/code&gt; 메소드는 &lt;code&gt;-1&lt;/code&gt; (스트림 끝)을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9adc7053a82a501abb4cad7dc21865d522ec6e09" translate="yes" xml:space="preserve">
          <source>If you simply need to pass a known MIDI byte value as a method parameter, it can be expressed directly as an integer, using (for example) decimal or hexadecimal notation. For instance, to pass the &quot;active sensing&quot; status byte as the first argument to ShortMessage's &lt;a href=&quot;shortmessage#setMessage-int-&quot;&gt;&lt;code&gt;setMessage(int)&lt;/code&gt;&lt;/a&gt; method, you can express it as 254 or 0xFE.</source>
          <target state="translated">알려진 MIDI 바이트 값을 메소드 매개 변수로 전달해야하는 경우 10 진수 또는 16 진 표기법을 사용하여 정수로 직접 표현할 수 있습니다. 예를 들어, &quot;활성 감지&quot;상태 바이트를 ShortMessage의 &lt;a href=&quot;shortmessage#setMessage-int-&quot;&gt; &lt;code&gt;setMessage(int)&lt;/code&gt; &lt;/a&gt; 메소드 의 첫 번째 인수로 전달하려면 254 또는 0xFE로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1b642d6abf000e5a6aebbe484690cdcc9c2881" translate="yes" xml:space="preserve">
          <source>If you would like to immediately block waiting for a task, you can use constructions of the form &lt;code&gt;result = exec.submit(aCallable).get();&lt;/code&gt;</source>
          <target state="translated">작업 대기를 즉시 차단하려면 &lt;code&gt;result = exec.submit(aCallable).get();&lt;/code&gt; 형식의 구성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0817bc0b871977b1a8c9e94b1ef78e8841f5ed3c" translate="yes" xml:space="preserve">
          <source>If, after possible unwrapping, the new value cannot be converted to the type of the underlying field by an identity or widening conversion, the method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">가능한 랩핑 해제 후 ID 또는 확장 변환으로 새 값을 기본 필드의 유형으로 변환 할 수없는 경우, 메소드는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="24cfa618cbc5961c88abb6321f352d54db94f655" translate="yes" xml:space="preserve">
          <source>If, after processing, the locale would exactly match either ja_JP_JP or th_TH_TH with no extensions, the appropriate extensions are added as though the constructor had been called:</source>
          <target state="translated">처리 후 로케일이 확장자가없는 ja_JP_JP 또는 th_TH_TH와 정확히 일치하면 생성자가 호출 된 것처럼 적절한 확장자가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6c08f223dd80703077dada0f83d9b60721b452cd" translate="yes" xml:space="preserve">
          <source>If, if the address is &lt;code&gt;null&lt;/code&gt;, creates an unbound socket.</source>
          <target state="translated">주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 언 바운드 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b7a3944583d471c07a700e6fff18fb04ba3825df" translate="yes" xml:space="preserve">
          <source>If, when the adapter is called, the supplied array argument does not have the correct number of elements, the adapter will throw an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; instead of invoking the target.</source>
          <target state="translated">어댑터가 호출 될 때 제공된 배열 인수에 올바른 수의 요소가없는 경우 어댑터는 대상을 호출하는 대신 &lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="21847df5c5cb4e7672a041f56f6d078037fceb03" translate="yes" xml:space="preserve">
          <source>IllegalAccessError</source>
          <target state="translated">IllegalAccessError</target>
        </trans-unit>
        <trans-unit id="dd91bcefa6284f552972a0be97fee45225f084db" translate="yes" xml:space="preserve">
          <source>IllegalAccessException</source>
          <target state="translated">IllegalAccessException</target>
        </trans-unit>
        <trans-unit id="07762b664ab5db9b2429f8c1a03a6fdc3ea71fdc" translate="yes" xml:space="preserve">
          <source>IllegalAccessException &amp;mdash; if the member exists but an access check fails</source>
          <target state="translated">IllegalAccessException &amp;mdash; 멤버가 존재하지만 액세스 검사에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="5cba9941f37a9bb4e09bf14b74224997efa1538b" translate="yes" xml:space="preserve">
          <source>IllegalBlockSizeException</source>
          <target state="translated">IllegalBlockSizeException</target>
        </trans-unit>
        <trans-unit id="72bee4f060e1046316b9d9208f43a1e30f093b56" translate="yes" xml:space="preserve">
          <source>IllegalBlockingModeException</source>
          <target state="translated">IllegalBlockingModeException</target>
        </trans-unit>
        <trans-unit id="728ba9e6dd595a3196c4ac4b622b54d1c837df50" translate="yes" xml:space="preserve">
          <source>IllegalChannelGroupException</source>
          <target state="translated">IllegalChannelGroupException</target>
        </trans-unit>
        <trans-unit id="08856e863e3820d0924f3ef1be4b809519443035" translate="yes" xml:space="preserve">
          <source>IllegalCharsetNameException</source>
          <target state="translated">IllegalCharsetNameException</target>
        </trans-unit>
        <trans-unit id="1ee77982e6e3d907bbc5b59a832da5d3e0e28e63" translate="yes" xml:space="preserve">
          <source>IllegalCharsetNameException.getCharsetName()</source>
          <target state="translated">IllegalCharsetNameException.getCharsetName()</target>
        </trans-unit>
        <trans-unit id="3f2717d0b8f564968056d35a3e99daf87783976b" translate="yes" xml:space="preserve">
          <source>IllegalClassFormatException</source>
          <target state="translated">IllegalClassFormatException</target>
        </trans-unit>
        <trans-unit id="2e88f78ae51e3f9d1be0762af4b7ca8e8f11f783" translate="yes" xml:space="preserve">
          <source>IllegalFormatCodePointException</source>
          <target state="translated">IllegalFormatCodePointException</target>
        </trans-unit>
        <trans-unit id="01e9b728feda93c0804cfc60551e0a73ac67cb23" translate="yes" xml:space="preserve">
          <source>IllegalFormatCodePointException.getCodePoint()</source>
          <target state="translated">IllegalFormatCodePointException.getCodePoint()</target>
        </trans-unit>
        <trans-unit id="b58e3a3bb89019a4239ddcc347dd9da221bd439c" translate="yes" xml:space="preserve">
          <source>IllegalFormatCodePointException.getMessage()</source>
          <target state="translated">IllegalFormatCodePointException.getMessage()</target>
        </trans-unit>
        <trans-unit id="cf694920d369177ecd98f05c63ceccfd014dfb3a" translate="yes" xml:space="preserve">
          <source>IllegalFormatConversionException</source>
          <target state="translated">IllegalFormatConversionException</target>
        </trans-unit>
        <trans-unit id="c2af42e8201376b34c77bc1352974c64f68a5c82" translate="yes" xml:space="preserve">
          <source>IllegalFormatConversionException.getArgumentClass()</source>
          <target state="translated">IllegalFormatConversionException.getArgumentClass()</target>
        </trans-unit>
        <trans-unit id="93cfe6fd63a97ee0cb039d0f535c1bec0f8381bb" translate="yes" xml:space="preserve">
          <source>IllegalFormatConversionException.getConversion()</source>
          <target state="translated">IllegalFormatConversionException.getConversion()</target>
        </trans-unit>
        <trans-unit id="32267ab7467ebe1517e9a90793fb60edfa337c8f" translate="yes" xml:space="preserve">
          <source>IllegalFormatConversionException.getMessage()</source>
          <target state="translated">IllegalFormatConversionException.getMessage()</target>
        </trans-unit>
        <trans-unit id="6fc8f0163cbca539149d1e776e01d43e638d91f1" translate="yes" xml:space="preserve">
          <source>IllegalFormatException</source>
          <target state="translated">IllegalFormatException</target>
        </trans-unit>
        <trans-unit id="c860a8ffb590545dad947d6d0a32f4306f0b6669" translate="yes" xml:space="preserve">
          <source>IllegalFormatFlagsException</source>
          <target state="translated">IllegalFormatFlagsException</target>
        </trans-unit>
        <trans-unit id="5d2373c99c0c78d388f5d343129d99c232ecdb83" translate="yes" xml:space="preserve">
          <source>IllegalFormatFlagsException.getFlags()</source>
          <target state="translated">IllegalFormatFlagsException.getFlags()</target>
        </trans-unit>
        <trans-unit id="64c3da34100c4721209bf9cd2b15ee2ec4a71d99" translate="yes" xml:space="preserve">
          <source>IllegalFormatFlagsException.getMessage()</source>
          <target state="translated">IllegalFormatFlagsException.getMessage()</target>
        </trans-unit>
        <trans-unit id="5b3fb4fc418e6c049903e5b64d9f8e8768116ade" translate="yes" xml:space="preserve">
          <source>IllegalFormatPrecisionException</source>
          <target state="translated">IllegalFormatPrecisionException</target>
        </trans-unit>
        <trans-unit id="4906b7cf69fa0eca0016b6d9e6fa7ee8fa52cb68" translate="yes" xml:space="preserve">
          <source>IllegalFormatPrecisionException.getMessage()</source>
          <target state="translated">IllegalFormatPrecisionException.getMessage()</target>
        </trans-unit>
        <trans-unit id="f8b90130a9087589e9ccb2175b557399069a72e1" translate="yes" xml:space="preserve">
          <source>IllegalFormatPrecisionException.getPrecision()</source>
          <target state="translated">IllegalFormatPrecisionException.getPrecision()</target>
        </trans-unit>
        <trans-unit id="150579129307b1603edaa8afafecdfc747707a0c" translate="yes" xml:space="preserve">
          <source>IllegalFormatWidthException</source>
          <target state="translated">IllegalFormatWidthException</target>
        </trans-unit>
        <trans-unit id="c1a5b579faf7cca9bf3f94878c79fb0f475cf233" translate="yes" xml:space="preserve">
          <source>IllegalFormatWidthException.getMessage()</source>
          <target state="translated">IllegalFormatWidthException.getMessage()</target>
        </trans-unit>
        <trans-unit id="8f52f453c1c984aec8936f3217284e6377d96c69" translate="yes" xml:space="preserve">
          <source>IllegalFormatWidthException.getWidth()</source>
          <target state="translated">IllegalFormatWidthException.getWidth()</target>
        </trans-unit>
        <trans-unit id="32d0389d11053deed8d75849534640e819bb4527" translate="yes" xml:space="preserve">
          <source>IllegalMonitorStateException</source>
          <target state="translated">IllegalMonitorStateException</target>
        </trans-unit>
        <trans-unit id="e9bfc30e12d08117404111c4265dd4ec5ebc94c4" translate="yes" xml:space="preserve">
          <source>IllegalSelectorException</source>
          <target state="translated">IllegalSelectorException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="ac921dc0ca27355ce8a5b55265b8b7ba05f069f0" translate="yes" xml:space="preserve">
          <source>IllegalThreadStateException</source>
          <target state="translated">IllegalThreadStateException</target>
        </trans-unit>
        <trans-unit id="e967f0136e45172f483f99e3bfebb380a3980435" translate="yes" xml:space="preserve">
          <source>IllformedLocaleException</source>
          <target state="translated">IllformedLocaleException</target>
        </trans-unit>
        <trans-unit id="3d9fd3af220073c500b086cc9fbdcb26786c4326" translate="yes" xml:space="preserve">
          <source>IllformedLocaleException.getErrorIndex()</source>
          <target state="translated">IllformedLocaleException.getErrorIndex()</target>
        </trans-unit>
        <trans-unit id="e221fe5a3e6f4ff124e28b73d70e7afa9ab3f313" translate="yes" xml:space="preserve">
          <source>Image Types</source>
          <target state="translated">이미지 타입</target>
        </trans-unit>
        <trans-unit id="9cfa0ee34d7252ba885e40e3d0bae9b6168fffbc" translate="yes" xml:space="preserve">
          <source>ImageIO</source>
          <target state="translated">ImageIO</target>
        </trans-unit>
        <trans-unit id="fb08904deaf392352762e63593d408f30ad7592f" translate="yes" xml:space="preserve">
          <source>ImageIO provides &lt;code&gt;ImageReader&lt;/code&gt; and &lt;code&gt;ImageWriter&lt;/code&gt; plug-ins for the &lt;a href=&quot;http://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt; Graphics Interchange Format (GIF)&lt;/a&gt; image format. These are the &quot;standard&quot; GIF plug-ins, meaning those that are included in the JRE, as distinct from those included in standard extensions, or 3rd party plug-ins. The following notes and metadata specification apply to the standard plug-ins.</source>
          <target state="translated">ImageIO는 &lt;a href=&quot;http://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;GIF (Graphics Interchange Format)&lt;/a&gt; 이미지 형식 을위한 &lt;code&gt;ImageReader&lt;/code&gt; 및 &lt;code&gt;ImageWriter&lt;/code&gt; 플러그인을 제공 합니다. &quot;표준&quot;GIF 플러그인은 표준 확장 또는 타사 플러그인에 포함 된 것과 달리 JRE에 포함 된 것을 의미합니다. 다음 참고 및 메타 데이터 사양은 표준 플러그인에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da7c9851db149fedc74fd958b51bbff7e3c3e4cb" translate="yes" xml:space="preserve">
          <source>ImageIO.createImageInputStream()</source>
          <target state="translated">ImageIO.createImageInputStream()</target>
        </trans-unit>
        <trans-unit id="c95c8213476c7bf7c6e8cd2a4156f6aad06b2ede" translate="yes" xml:space="preserve">
          <source>ImageIO.createImageOutputStream()</source>
          <target state="translated">ImageIO.createImageOutputStream()</target>
        </trans-unit>
        <trans-unit id="09fd3c3ef36b3e3b4e27a58c340ac1498c852811" translate="yes" xml:space="preserve">
          <source>ImageIO.getCacheDirectory()</source>
          <target state="translated">ImageIO.getCacheDirectory()</target>
        </trans-unit>
        <trans-unit id="b8d56c96a5e032b322a7dfc9e9dfd4f7d3163210" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageReader()</source>
          <target state="translated">ImageIO.getImageReader()</target>
        </trans-unit>
        <trans-unit id="7e76eb241ccb26f43c390618bae46f5d10b95238" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageReaders()</source>
          <target state="translated">ImageIO.getImageReaders()</target>
        </trans-unit>
        <trans-unit id="44ef81251a0359e10da539ea0c926738bc079d80" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageReadersByFormatName()</source>
          <target state="translated">ImageIO.getImageReadersByFormatName()</target>
        </trans-unit>
        <trans-unit id="64a0bc918bed1738502afad4783faccab9c2186b" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageReadersByMIMEType()</source>
          <target state="translated">ImageIO.getImageReadersByMIMEType()</target>
        </trans-unit>
        <trans-unit id="afa949cd049242f118953cd39b6f5c21cd74bfbe" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageReadersBySuffix()</source>
          <target state="translated">ImageIO.getImageReadersBySuffix()</target>
        </trans-unit>
        <trans-unit id="de6da74d518b0c2784171323506bb5b1ee6d852b" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageTranscoders()</source>
          <target state="translated">ImageIO.getImageTranscoders()</target>
        </trans-unit>
        <trans-unit id="5e29940fba4bc557445fc983f308938e46bd224f" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageWriter()</source>
          <target state="translated">ImageIO.getImageWriter()</target>
        </trans-unit>
        <trans-unit id="56bc830a97378de25ad150d4e503fc48f66dc3ec" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageWriters()</source>
          <target state="translated">ImageIO.getImageWriters()</target>
        </trans-unit>
        <trans-unit id="89db07061cc0732e6ab14d4c068e2d7eceb3e2a9" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageWritersByFormatName()</source>
          <target state="translated">ImageIO.getImageWritersByFormatName()</target>
        </trans-unit>
        <trans-unit id="e750e9b780c2367dccb6426f7d619b865597416c" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageWritersByMIMEType()</source>
          <target state="translated">ImageIO.getImageWritersByMIMEType()</target>
        </trans-unit>
        <trans-unit id="ce7337d2c90e5649fdf14512d0e005a7d112c6cb" translate="yes" xml:space="preserve">
          <source>ImageIO.getImageWritersBySuffix()</source>
          <target state="translated">ImageIO.getImageWritersBySuffix()</target>
        </trans-unit>
        <trans-unit id="fe5c85a5282508405c3f1206d09bed976dd42965" translate="yes" xml:space="preserve">
          <source>ImageIO.getReaderFileSuffixes()</source>
          <target state="translated">ImageIO.getReaderFileSuffixes()</target>
        </trans-unit>
        <trans-unit id="06d8f415a89de32cffca703fc29bbb91572fbc9f" translate="yes" xml:space="preserve">
          <source>ImageIO.getReaderFormatNames()</source>
          <target state="translated">ImageIO.getReaderFormatNames()</target>
        </trans-unit>
        <trans-unit id="0645e1589c3071d7502c318da4c3c2b061194cb7" translate="yes" xml:space="preserve">
          <source>ImageIO.getReaderMIMETypes()</source>
          <target state="translated">ImageIO.getReaderMIMETypes()</target>
        </trans-unit>
        <trans-unit id="07ad9f1d97f6d3e904844a56851b3bcda99b2c43" translate="yes" xml:space="preserve">
          <source>ImageIO.getUseCache()</source>
          <target state="translated">ImageIO.getUseCache()</target>
        </trans-unit>
        <trans-unit id="5169caa39bfd700d76397736d7e285aa33f9c7a7" translate="yes" xml:space="preserve">
          <source>ImageIO.getWriterFileSuffixes()</source>
          <target state="translated">ImageIO.getWriterFileSuffixes()</target>
        </trans-unit>
        <trans-unit id="7e7a97a50c9d05a7a40adf51dd33a857053c65da" translate="yes" xml:space="preserve">
          <source>ImageIO.getWriterFormatNames()</source>
          <target state="translated">ImageIO.getWriterFormatNames()</target>
        </trans-unit>
        <trans-unit id="01db539be762fbfd821ea09f01177e71fd96fc8c" translate="yes" xml:space="preserve">
          <source>ImageIO.getWriterMIMETypes()</source>
          <target state="translated">ImageIO.getWriterMIMETypes()</target>
        </trans-unit>
        <trans-unit id="463d1f56e81833ff31c3d295de1bb6fcfda5275d" translate="yes" xml:space="preserve">
          <source>ImageIO.read()</source>
          <target state="translated">ImageIO.read()</target>
        </trans-unit>
        <trans-unit id="c7d104e02651636725b9f8fe56a25a4d2c570bf1" translate="yes" xml:space="preserve">
          <source>ImageIO.scanForPlugins()</source>
          <target state="translated">ImageIO.scanForPlugins()</target>
        </trans-unit>
        <trans-unit id="d62714299e20b57d1592d993d43407e41aa2164e" translate="yes" xml:space="preserve">
          <source>ImageIO.setCacheDirectory()</source>
          <target state="translated">ImageIO.setCacheDirectory()</target>
        </trans-unit>
        <trans-unit id="792babf03cb2c5b21cc1ccff7d0276833b152238" translate="yes" xml:space="preserve">
          <source>ImageIO.setUseCache()</source>
          <target state="translated">ImageIO.setUseCache()</target>
        </trans-unit>
        <trans-unit id="740030501c0f7240b3fef74e1112008cba5f6479" translate="yes" xml:space="preserve">
          <source>ImageIO.write()</source>
          <target state="translated">ImageIO.write()</target>
        </trans-unit>
        <trans-unit id="0245e9e67a54a472fc25581d5c9f9f41c5862fe9" translate="yes" xml:space="preserve">
          <source>ImageInputStream</source>
          <target state="translated">ImageInputStream</target>
        </trans-unit>
        <trans-unit id="fdb0db46a0549545118bcfab191f5a01bb7b7856" translate="yes" xml:space="preserve">
          <source>ImageInputStream.close()</source>
          <target state="translated">ImageInputStream.close()</target>
        </trans-unit>
        <trans-unit id="74e92bb6efaabdb3e1364e44d9201955d9a97ecd" translate="yes" xml:space="preserve">
          <source>ImageInputStream.flush()</source>
          <target state="translated">ImageInputStream.flush()</target>
        </trans-unit>
        <trans-unit id="f2c19a159035aa426a1b4fa9ff8fef450cf20186" translate="yes" xml:space="preserve">
          <source>ImageInputStream.flushBefore()</source>
          <target state="translated">ImageInputStream.flushBefore()</target>
        </trans-unit>
        <trans-unit id="3e3dcc8b7874fe66b112c67eb0131282cf5be45d" translate="yes" xml:space="preserve">
          <source>ImageInputStream.getBitOffset()</source>
          <target state="translated">ImageInputStream.getBitOffset()</target>
        </trans-unit>
        <trans-unit id="ed0c413a5cdd9ba2f88e8004941a2b40d5be3aca" translate="yes" xml:space="preserve">
          <source>ImageInputStream.getByteOrder()</source>
          <target state="translated">ImageInputStream.getByteOrder()</target>
        </trans-unit>
        <trans-unit id="a9f86dc54492d048236b77adbd714aeca40c9e51" translate="yes" xml:space="preserve">
          <source>ImageInputStream.getFlushedPosition()</source>
          <target state="translated">ImageInputStream.getFlushedPosition()</target>
        </trans-unit>
        <trans-unit id="7fac3b49b57032a0641c75807a3c18076b5da2b5" translate="yes" xml:space="preserve">
          <source>ImageInputStream.getStreamPosition()</source>
          <target state="translated">ImageInputStream.getStreamPosition()</target>
        </trans-unit>
        <trans-unit id="1acb72377037719672c98f780c77e950ff820492" translate="yes" xml:space="preserve">
          <source>ImageInputStream.isCached()</source>
          <target state="translated">ImageInputStream.isCached()</target>
        </trans-unit>
        <trans-unit id="5f69754bd4d96138a7c22bbedd6aefaabde231a8" translate="yes" xml:space="preserve">
          <source>ImageInputStream.isCachedFile()</source>
          <target state="translated">ImageInputStream.isCachedFile()</target>
        </trans-unit>
        <trans-unit id="5c548a7b471d7672ecb6792e54d5bdc21e4d2387" translate="yes" xml:space="preserve">
          <source>ImageInputStream.isCachedMemory()</source>
          <target state="translated">ImageInputStream.isCachedMemory()</target>
        </trans-unit>
        <trans-unit id="5261bd544299c757e4b1f336fdefee6de42c7b4c" translate="yes" xml:space="preserve">
          <source>ImageInputStream.length()</source>
          <target state="translated">ImageInputStream.length()</target>
        </trans-unit>
        <trans-unit id="cfabbc33a2b60af25762be95a557f5de9c1ba8ea" translate="yes" xml:space="preserve">
          <source>ImageInputStream.mark()</source>
          <target state="translated">ImageInputStream.mark()</target>
        </trans-unit>
        <trans-unit id="07764b9f240c07205fc1c6d6c63a27c1372ff701" translate="yes" xml:space="preserve">
          <source>ImageInputStream.read()</source>
          <target state="translated">ImageInputStream.read()</target>
        </trans-unit>
        <trans-unit id="fb57b6a837e11c39f6562a7a887b53c7dc1c09f5" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readBit()</source>
          <target state="translated">ImageInputStream.readBit()</target>
        </trans-unit>
        <trans-unit id="0917c6385b2ac3e649e5b9a229ff8852a7e03f14" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readBits()</source>
          <target state="translated">ImageInputStream.readBits()</target>
        </trans-unit>
        <trans-unit id="0c8ff8f950621dce17dda1c964b80be167dd2cee" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readBoolean()</source>
          <target state="translated">ImageInputStream.readBoolean()</target>
        </trans-unit>
        <trans-unit id="7a252976aef85f172deca195d4e9d13d7ffeca7b" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readByte()</source>
          <target state="translated">ImageInputStream.readByte()</target>
        </trans-unit>
        <trans-unit id="76a124f0baeafb323fcdeb4600b759c65f8d0176" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readBytes()</source>
          <target state="translated">ImageInputStream.readBytes()</target>
        </trans-unit>
        <trans-unit id="b2e9a3b48f6aeb1974e857f3d1dc37592e8a6ddc" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readChar()</source>
          <target state="translated">ImageInputStream.readChar()</target>
        </trans-unit>
        <trans-unit id="e06adfc4448348b3acddca93f268a2153ab1a3ee" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readDouble()</source>
          <target state="translated">ImageInputStream.readDouble()</target>
        </trans-unit>
        <trans-unit id="257f1ac56d5e6e98ef9a7c125604a204d17b5d18" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readFloat()</source>
          <target state="translated">ImageInputStream.readFloat()</target>
        </trans-unit>
        <trans-unit id="cf9313280471b393d59238085e0efa067c010043" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readFully()</source>
          <target state="translated">ImageInputStream.readFully()</target>
        </trans-unit>
        <trans-unit id="2cf680fda4d5eb74c626d594fd5817dad1ebb713" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readInt()</source>
          <target state="translated">ImageInputStream.readInt()</target>
        </trans-unit>
        <trans-unit id="af33fd30f73a756d5dabfadf948021b8a508cc2c" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readLine()</source>
          <target state="translated">ImageInputStream.readLine()</target>
        </trans-unit>
        <trans-unit id="c502e57ec334956d872b572bcb59a8d15e976afc" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readLong()</source>
          <target state="translated">ImageInputStream.readLong()</target>
        </trans-unit>
        <trans-unit id="560d5375c889ea524187a3cf8aca901ebf457cb1" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readShort()</source>
          <target state="translated">ImageInputStream.readShort()</target>
        </trans-unit>
        <trans-unit id="7c6880473353874f02e9c2ae4fcba87e85333517" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readUTF()</source>
          <target state="translated">ImageInputStream.readUTF()</target>
        </trans-unit>
        <trans-unit id="dab86d8b4038eb19b0b3a15dd627a0d8b836e2c3" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readUnsignedByte()</source>
          <target state="translated">ImageInputStream.readUnsignedByte()</target>
        </trans-unit>
        <trans-unit id="87eb9f587b973471d74845a3ddc84409ec8adf3b" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readUnsignedInt()</source>
          <target state="translated">ImageInputStream.readUnsignedInt()</target>
        </trans-unit>
        <trans-unit id="f35074f6242fa76bc133147208ccc387bac999de" translate="yes" xml:space="preserve">
          <source>ImageInputStream.readUnsignedShort()</source>
          <target state="translated">ImageInputStream.readUnsignedShort()</target>
        </trans-unit>
        <trans-unit id="00a12c946b17c606257256e3e6378b114e2e9c05" translate="yes" xml:space="preserve">
          <source>ImageInputStream.reset()</source>
          <target state="translated">ImageInputStream.reset()</target>
        </trans-unit>
        <trans-unit id="90be6fbdd0622d26d611dfbaa9e05e7fd752415f" translate="yes" xml:space="preserve">
          <source>ImageInputStream.seek()</source>
          <target state="translated">ImageInputStream.seek()</target>
        </trans-unit>
        <trans-unit id="85a0afa0fb736f9a6a3be490b62269fb855570a6" translate="yes" xml:space="preserve">
          <source>ImageInputStream.setBitOffset()</source>
          <target state="translated">ImageInputStream.setBitOffset()</target>
        </trans-unit>
        <trans-unit id="e72841dd92c4486f8ecb47461c0ae520978c01fc" translate="yes" xml:space="preserve">
          <source>ImageInputStream.setByteOrder()</source>
          <target state="translated">ImageInputStream.setByteOrder()</target>
        </trans-unit>
        <trans-unit id="cdbbc1faf80c7c46e3e14c86efeb22e4d29bd35c" translate="yes" xml:space="preserve">
          <source>ImageInputStream.skipBytes()</source>
          <target state="translated">ImageInputStream.skipBytes()</target>
        </trans-unit>
        <trans-unit id="8656b12ebd4577f365f30700a4965ac15bc88eb3" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl</source>
          <target state="translated">ImageInputStreamImpl</target>
        </trans-unit>
        <trans-unit id="e0c3696efb1099cc8eed113cd35fe056c319999b" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.checkClosed()</source>
          <target state="translated">ImageInputStreamImpl.checkClosed()</target>
        </trans-unit>
        <trans-unit id="782595d006aa0abb71963fe9baf1cc70df4da48b" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.close()</source>
          <target state="translated">ImageInputStreamImpl.close()</target>
        </trans-unit>
        <trans-unit id="a27706961795dad7d8923c0071f3c550dbffe802" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.finalize()</source>
          <target state="translated">ImageInputStreamImpl.finalize()</target>
        </trans-unit>
        <trans-unit id="9431ae756c0353adf60204204171a32b3973cc72" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.flush()</source>
          <target state="translated">ImageInputStreamImpl.flush()</target>
        </trans-unit>
        <trans-unit id="168614a85c503d2d4cc8ce626e217d7f77f8faed" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.flushBefore()</source>
          <target state="translated">ImageInputStreamImpl.flushBefore()</target>
        </trans-unit>
        <trans-unit id="981a58447ac21e8c657544ed69ffb81fa14d1e22" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.getBitOffset()</source>
          <target state="translated">ImageInputStreamImpl.getBitOffset()</target>
        </trans-unit>
        <trans-unit id="ba306fe0c0ab7cc5d661d7a915cb0e8fb1a3614e" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.getByteOrder()</source>
          <target state="translated">ImageInputStreamImpl.getByteOrder()</target>
        </trans-unit>
        <trans-unit id="e471eeed2837714dd874a503b9a005465e7d9378" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.getFlushedPosition()</source>
          <target state="translated">ImageInputStreamImpl.getFlushedPosition()</target>
        </trans-unit>
        <trans-unit id="31c54856fb3d87a3c4f706059d932317bdb5fd70" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.getStreamPosition()</source>
          <target state="translated">ImageInputStreamImpl.getStreamPosition()</target>
        </trans-unit>
        <trans-unit id="594592c73635611de1bb90869376a480b3d175fd" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.isCached()</source>
          <target state="translated">ImageInputStreamImpl.isCached()</target>
        </trans-unit>
        <trans-unit id="3e815c25865006ecb81b108a964827b1d0f3cece" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.isCachedFile()</source>
          <target state="translated">ImageInputStreamImpl.isCachedFile()</target>
        </trans-unit>
        <trans-unit id="3243c5d2ecc0d3399d30bc93ff50a264f67ba333" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.isCachedMemory()</source>
          <target state="translated">ImageInputStreamImpl.isCachedMemory()</target>
        </trans-unit>
        <trans-unit id="e5ac4ec2e26729b99cd28a078d488c8935aba2be" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.length()</source>
          <target state="translated">ImageInputStreamImpl.length()</target>
        </trans-unit>
        <trans-unit id="7bbd52b0fbf58b6798e63d8b0c87497a56df66f6" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.mark()</source>
          <target state="translated">ImageInputStreamImpl.mark()</target>
        </trans-unit>
        <trans-unit id="1f55b2cfe2b750f10111c7035e587f1ceb7d09ed" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.read()</source>
          <target state="translated">ImageInputStreamImpl.read()</target>
        </trans-unit>
        <trans-unit id="aabb5f23baeb84e5f6f3ac1ff541b929760ceb92" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readBit()</source>
          <target state="translated">ImageInputStreamImpl.readBit()</target>
        </trans-unit>
        <trans-unit id="f8e0d5cb350a27e01a0e88fcbc5dc0060ae78474" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readBits()</source>
          <target state="translated">ImageInputStreamImpl.readBits()</target>
        </trans-unit>
        <trans-unit id="e68b253d54db897da7d251ca7724e7c3894b0592" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readBoolean()</source>
          <target state="translated">ImageInputStreamImpl.readBoolean()</target>
        </trans-unit>
        <trans-unit id="79329a0abc951e56dcca4a1789034a361ae747f5" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readByte()</source>
          <target state="translated">ImageInputStreamImpl.readByte()</target>
        </trans-unit>
        <trans-unit id="71cdd7657c8e38c8c63465cad9d8fcb058772a3d" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readBytes()</source>
          <target state="translated">ImageInputStreamImpl.readBytes()</target>
        </trans-unit>
        <trans-unit id="96b166e904694f192ebd27a9749b7fab7e1eae91" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readChar()</source>
          <target state="translated">ImageInputStreamImpl.readChar()</target>
        </trans-unit>
        <trans-unit id="42ee4e564f1504e893ac6b1b35e7055913601286" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readDouble()</source>
          <target state="translated">ImageInputStreamImpl.readDouble()</target>
        </trans-unit>
        <trans-unit id="2f8d752842016666b1aedf8121b8348521d31b30" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readFloat()</source>
          <target state="translated">ImageInputStreamImpl.readFloat()</target>
        </trans-unit>
        <trans-unit id="f92136c9a37ae3d989b1909b62111e2e310a8378" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readFully()</source>
          <target state="translated">ImageInputStreamImpl.readFully()</target>
        </trans-unit>
        <trans-unit id="eb6805ccf006d0398ca358e9619d5f5eebda940b" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readInt()</source>
          <target state="translated">ImageInputStreamImpl.readInt()</target>
        </trans-unit>
        <trans-unit id="8642b232a3108c5773bc9627c92583405125e05f" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readLine()</source>
          <target state="translated">ImageInputStreamImpl.readLine()</target>
        </trans-unit>
        <trans-unit id="6f6f63ca415b0e89f8ae5c30c1a3018e595b6068" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readLong()</source>
          <target state="translated">ImageInputStreamImpl.readLong()</target>
        </trans-unit>
        <trans-unit id="b617d67507eca06216066c571114be11c0751e31" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readShort()</source>
          <target state="translated">ImageInputStreamImpl.readShort()</target>
        </trans-unit>
        <trans-unit id="698dc14620f50ae23a50d28ab1fe8525bc7b6c9d" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readUTF()</source>
          <target state="translated">ImageInputStreamImpl.readUTF()</target>
        </trans-unit>
        <trans-unit id="b5f1586569947e262ec3518385bc537415c0e03e" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readUnsignedByte()</source>
          <target state="translated">ImageInputStreamImpl.readUnsignedByte()</target>
        </trans-unit>
        <trans-unit id="d8947b30c253b0c61bc67637afb8d343cc16f7e0" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readUnsignedInt()</source>
          <target state="translated">ImageInputStreamImpl.readUnsignedInt()</target>
        </trans-unit>
        <trans-unit id="8ea1539b573be4ee8f231d4ad18a0d5f1fd114ae" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.readUnsignedShort()</source>
          <target state="translated">ImageInputStreamImpl.readUnsignedShort()</target>
        </trans-unit>
        <trans-unit id="e567969379ca63dc0a8d56046863f56c6269e1b5" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.reset()</source>
          <target state="translated">ImageInputStreamImpl.reset()</target>
        </trans-unit>
        <trans-unit id="bb704f2bb8a0ae856f08dff751400fd6014d8230" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.seek()</source>
          <target state="translated">ImageInputStreamImpl.seek()</target>
        </trans-unit>
        <trans-unit id="58977f5c2fcf07fe4e22f6971622098bbb2cf156" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.setBitOffset()</source>
          <target state="translated">ImageInputStreamImpl.setBitOffset()</target>
        </trans-unit>
        <trans-unit id="b2d11387197b1eb752c26b411519321f23b1e961" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.setByteOrder()</source>
          <target state="translated">ImageInputStreamImpl.setByteOrder()</target>
        </trans-unit>
        <trans-unit id="81cbaf9dfa780bf07efce1dbde0370337472ec57" translate="yes" xml:space="preserve">
          <source>ImageInputStreamImpl.skipBytes()</source>
          <target state="translated">ImageInputStreamImpl.skipBytes()</target>
        </trans-unit>
        <trans-unit id="6c016edb7393ee78be323cdee64306abc5c33a76" translate="yes" xml:space="preserve">
          <source>ImageInputStreamSpi</source>
          <target state="translated">ImageInputStreamSpi</target>
        </trans-unit>
        <trans-unit id="98f3c89642183c2de7b74025c9a94892a10c8290" translate="yes" xml:space="preserve">
          <source>ImageInputStreamSpi.canUseCacheFile()</source>
          <target state="translated">ImageInputStreamSpi.canUseCacheFile()</target>
        </trans-unit>
        <trans-unit id="cfc724f334540654cf7bd9bb0273b3b20fb1cab9" translate="yes" xml:space="preserve">
          <source>ImageInputStreamSpi.createInputStreamInstance()</source>
          <target state="translated">ImageInputStreamSpi.createInputStreamInstance()</target>
        </trans-unit>
        <trans-unit id="e28bb6fdf2a6fe5a11d08bbd9dabfed557c79dde" translate="yes" xml:space="preserve">
          <source>ImageInputStreamSpi.getInputClass()</source>
          <target state="translated">ImageInputStreamSpi.getInputClass()</target>
        </trans-unit>
        <trans-unit id="bab49208b3442ad088d417fd6882ece7eb22c453" translate="yes" xml:space="preserve">
          <source>ImageInputStreamSpi.needsCacheFile()</source>
          <target state="translated">ImageInputStreamSpi.needsCacheFile()</target>
        </trans-unit>
        <trans-unit id="83452b3370966adeb8529169778744f6e09ff6af" translate="yes" xml:space="preserve">
          <source>ImageOutputStream</source>
          <target state="translated">ImageOutputStream</target>
        </trans-unit>
        <trans-unit id="9a7340fd79bf4a3bd17e4efc378a302841865164" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.flushBefore()</source>
          <target state="translated">ImageOutputStream.flushBefore()</target>
        </trans-unit>
        <trans-unit id="96d9f9f0c87a58778def7cb4472f9e30f72c9ed1" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.write()</source>
          <target state="translated">ImageOutputStream.write()</target>
        </trans-unit>
        <trans-unit id="2a749a2ab1d342fdbe254964c94d9dc6e10d6335" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeBit()</source>
          <target state="translated">ImageOutputStream.writeBit()</target>
        </trans-unit>
        <trans-unit id="a6bd0332e894f3faebb742ce886bef1b0ca3072b" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeBits()</source>
          <target state="translated">ImageOutputStream.writeBits()</target>
        </trans-unit>
        <trans-unit id="8eea4d74a7715f2548485de45d4641de28d84d29" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeBoolean()</source>
          <target state="translated">ImageOutputStream.writeBoolean()</target>
        </trans-unit>
        <trans-unit id="340a472f842b04b86af885671257d5256986b53d" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeByte()</source>
          <target state="translated">ImageOutputStream.writeByte()</target>
        </trans-unit>
        <trans-unit id="22db935c085af8d2c472ea2849517b813ad1f3ed" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeBytes()</source>
          <target state="translated">ImageOutputStream.writeBytes()</target>
        </trans-unit>
        <trans-unit id="6d08d9de75de11b5d66b87c7b7d2d68abb4df88c" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeChar()</source>
          <target state="translated">ImageOutputStream.writeChar()</target>
        </trans-unit>
        <trans-unit id="75afc2031ad65ed5b89bec90a825f5be8fa0d014" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeChars()</source>
          <target state="translated">ImageOutputStream.writeChars()</target>
        </trans-unit>
        <trans-unit id="fb2b58ece7b590e768f813dc298c99bf314a3232" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeDouble()</source>
          <target state="translated">ImageOutputStream.writeDouble()</target>
        </trans-unit>
        <trans-unit id="b482f3b68f7be8d4a57bdd6647d17e30c247283d" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeDoubles()</source>
          <target state="translated">ImageOutputStream.writeDoubles()</target>
        </trans-unit>
        <trans-unit id="43acf80f83723f299ebf51426b7fef88628108c7" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeFloat()</source>
          <target state="translated">ImageOutputStream.writeFloat()</target>
        </trans-unit>
        <trans-unit id="42313ffd030977d4a3eadc27f5b1a50e373481aa" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeFloats()</source>
          <target state="translated">ImageOutputStream.writeFloats()</target>
        </trans-unit>
        <trans-unit id="d86afeab1a6a45ac1f3cede360cec9c35ddfa0e2" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeInt()</source>
          <target state="translated">ImageOutputStream.writeInt()</target>
        </trans-unit>
        <trans-unit id="b75d0d72ffb9a076f3698444a5c3d154adcd2744" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeInts()</source>
          <target state="translated">ImageOutputStream.writeInts()</target>
        </trans-unit>
        <trans-unit id="f4292b5040fa930bcf8f0f53bf7f055a1ac9c78a" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeLong()</source>
          <target state="translated">ImageOutputStream.writeLong()</target>
        </trans-unit>
        <trans-unit id="0246e3aa4a07aed1c640740521fc0870e0ff5c0f" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeLongs()</source>
          <target state="translated">ImageOutputStream.writeLongs()</target>
        </trans-unit>
        <trans-unit id="1f3727fa7152d18143df7ebe1ebb2c9947230c62" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeShort()</source>
          <target state="translated">ImageOutputStream.writeShort()</target>
        </trans-unit>
        <trans-unit id="491e72b4dcac099107b1db722933b0052128b231" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeShorts()</source>
          <target state="translated">ImageOutputStream.writeShorts()</target>
        </trans-unit>
        <trans-unit id="e08fcb28ace3d3e84578214b9b4d4d83bcc71a48" translate="yes" xml:space="preserve">
          <source>ImageOutputStream.writeUTF()</source>
          <target state="translated">ImageOutputStream.writeUTF()</target>
        </trans-unit>
        <trans-unit id="72b99a9a0945d72b23e4c7cd15e0ca4370caa83d" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl</source>
          <target state="translated">ImageOutputStreamImpl</target>
        </trans-unit>
        <trans-unit id="b94df9c7619840c20a9af8bb6d7976dc537c692d" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.flushBits()</source>
          <target state="translated">ImageOutputStreamImpl.flushBits()</target>
        </trans-unit>
        <trans-unit id="730f1cdbd189048de523719e5b0ff1f89fa69f1a" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.write()</source>
          <target state="translated">ImageOutputStreamImpl.write()</target>
        </trans-unit>
        <trans-unit id="f1b3f1b6c632622f8e619e2ac5fbfd01ca7c1ee5" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeBit()</source>
          <target state="translated">ImageOutputStreamImpl.writeBit()</target>
        </trans-unit>
        <trans-unit id="9393ba275c9ea1f015e3d4ab25fdde23e0ac1067" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeBits()</source>
          <target state="translated">ImageOutputStreamImpl.writeBits()</target>
        </trans-unit>
        <trans-unit id="d3c067d1d56c1470e93a5bf33fa3280efe069058" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeBoolean()</source>
          <target state="translated">ImageOutputStreamImpl.writeBoolean()</target>
        </trans-unit>
        <trans-unit id="f15ad350c4b938293d993a25eba797c8db998a3e" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeByte()</source>
          <target state="translated">ImageOutputStreamImpl.writeByte()</target>
        </trans-unit>
        <trans-unit id="095bb6cefb5354d2f7c4f0a22c12443ef62ac1dc" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeBytes()</source>
          <target state="translated">ImageOutputStreamImpl.writeBytes()</target>
        </trans-unit>
        <trans-unit id="521e6614a439aa71cfcbbacfc51409ff6ad51c36" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeChar()</source>
          <target state="translated">ImageOutputStreamImpl.writeChar()</target>
        </trans-unit>
        <trans-unit id="334dd26e9aa2141489f61cebfce3d91fd9810de8" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeChars()</source>
          <target state="translated">ImageOutputStreamImpl.writeChars()</target>
        </trans-unit>
        <trans-unit id="2c9a5b7a1ec440545f7662de460fbeadfd3d7ece" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeDouble()</source>
          <target state="translated">ImageOutputStreamImpl.writeDouble()</target>
        </trans-unit>
        <trans-unit id="e1333d7825287cc0f22a19657c00a1a290595890" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeDoubles()</source>
          <target state="translated">ImageOutputStreamImpl.writeDoubles()</target>
        </trans-unit>
        <trans-unit id="197e47ac604fffd79dd1b7217f6c18e8d617db02" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeFloat()</source>
          <target state="translated">ImageOutputStreamImpl.writeFloat()</target>
        </trans-unit>
        <trans-unit id="94642ce32c1a3ed90a2320a50906426c9bef3109" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeFloats()</source>
          <target state="translated">ImageOutputStreamImpl.writeFloats()</target>
        </trans-unit>
        <trans-unit id="cf0acbd914d5ff262a81300aa0318afe64266461" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeInt()</source>
          <target state="translated">ImageOutputStreamImpl.writeInt()</target>
        </trans-unit>
        <trans-unit id="a3cfd025a02e305b2a2830ae1b5194f4b274eed9" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeInts()</source>
          <target state="translated">ImageOutputStreamImpl.writeInts()</target>
        </trans-unit>
        <trans-unit id="dba6391684abecf926b01dfb902078ced0cfb8ca" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeLong()</source>
          <target state="translated">ImageOutputStreamImpl.writeLong()</target>
        </trans-unit>
        <trans-unit id="9e426a86c094e0adb14df7ac3b38f0e9d52c28c2" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeLongs()</source>
          <target state="translated">ImageOutputStreamImpl.writeLongs()</target>
        </trans-unit>
        <trans-unit id="0cf54f61217e13cdd0f2c560981703c79d6e0231" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeShort()</source>
          <target state="translated">ImageOutputStreamImpl.writeShort()</target>
        </trans-unit>
        <trans-unit id="c025774860a58ffe651c29b29ac3ef8721bbc953" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeShorts()</source>
          <target state="translated">ImageOutputStreamImpl.writeShorts()</target>
        </trans-unit>
        <trans-unit id="147c12a0a914540fbe428bd115e9f1f47a62611f" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamImpl.writeUTF()</source>
          <target state="translated">ImageOutputStreamImpl.writeUTF()</target>
        </trans-unit>
        <trans-unit id="5b31c596804eae9fe47d2e389a77a1a15db3fcac" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamSpi</source>
          <target state="translated">ImageOutputStreamSpi</target>
        </trans-unit>
        <trans-unit id="c41355ca3fef446e456f7414fb6307475fd139b1" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamSpi.canUseCacheFile()</source>
          <target state="translated">ImageOutputStreamSpi.canUseCacheFile()</target>
        </trans-unit>
        <trans-unit id="a6c7fcb65468a4ded2040925c5b97fb20b574f69" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamSpi.createOutputStreamInstance()</source>
          <target state="translated">ImageOutputStreamSpi.createOutputStreamInstance()</target>
        </trans-unit>
        <trans-unit id="67d7de5675588e83404da953f0e8085b1083f41d" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamSpi.getOutputClass()</source>
          <target state="translated">ImageOutputStreamSpi.getOutputClass()</target>
        </trans-unit>
        <trans-unit id="2058ca306ee8f78dfbd63327e0de312210c1b1c1" translate="yes" xml:space="preserve">
          <source>ImageOutputStreamSpi.needsCacheFile()</source>
          <target state="translated">ImageOutputStreamSpi.needsCacheFile()</target>
        </trans-unit>
        <trans-unit id="cd2cd26b1dd4bf4d9188ff3707eaaa081bf1035f" translate="yes" xml:space="preserve">
          <source>ImageReadParam</source>
          <target state="translated">ImageReadParam</target>
        </trans-unit>
        <trans-unit id="1201d8d62bd34eabb029c751e075ad9c3a694230" translate="yes" xml:space="preserve">
          <source>ImageReadParam.canSetSourceRenderSize()</source>
          <target state="translated">ImageReadParam.canSetSourceRenderSize()</target>
        </trans-unit>
        <trans-unit id="7d70a5327a4b03f33e450ac9974dd7150da0cb22" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getDestination()</source>
          <target state="translated">ImageReadParam.getDestination()</target>
        </trans-unit>
        <trans-unit id="56b8b8fa4c49d4b3d42080bf6e079d7e7c47736d" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getDestinationBands()</source>
          <target state="translated">ImageReadParam.getDestinationBands()</target>
        </trans-unit>
        <trans-unit id="10b87be325ee80f458950abf026570aa1721b8e0" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getSourceMaxProgressivePass()</source>
          <target state="translated">ImageReadParam.getSourceMaxProgressivePass()</target>
        </trans-unit>
        <trans-unit id="64baebae8df2c30bdcaa009fa90a8fafaf8374a0" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getSourceMinProgressivePass()</source>
          <target state="translated">ImageReadParam.getSourceMinProgressivePass()</target>
        </trans-unit>
        <trans-unit id="2a9e30e7ab09c34d21976c697343b0ddb7fdf4c2" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getSourceNumProgressivePasses()</source>
          <target state="translated">ImageReadParam.getSourceNumProgressivePasses()</target>
        </trans-unit>
        <trans-unit id="979e6351f23c4d15b32fcfc2dd1e2e42c39caf1a" translate="yes" xml:space="preserve">
          <source>ImageReadParam.getSourceRenderSize()</source>
          <target state="translated">ImageReadParam.getSourceRenderSize()</target>
        </trans-unit>
        <trans-unit id="8fa94c9268843bf28b601aec3e833b199101d137" translate="yes" xml:space="preserve">
          <source>ImageReadParam.setDestination()</source>
          <target state="translated">ImageReadParam.setDestination()</target>
        </trans-unit>
        <trans-unit id="d26f0854d8589f1ab523c1d34c410a49623f03a2" translate="yes" xml:space="preserve">
          <source>ImageReadParam.setDestinationBands()</source>
          <target state="translated">ImageReadParam.setDestinationBands()</target>
        </trans-unit>
        <trans-unit id="4a5c79c15a0e6dd8aa1340f4967dd5b96b0ea9ce" translate="yes" xml:space="preserve">
          <source>ImageReadParam.setDestinationType()</source>
          <target state="translated">ImageReadParam.setDestinationType()</target>
        </trans-unit>
        <trans-unit id="f3b2bae255bfd5a49cdea25971232f60ab5f428b" translate="yes" xml:space="preserve">
          <source>ImageReadParam.setSourceProgressivePasses()</source>
          <target state="translated">ImageReadParam.setSourceProgressivePasses()</target>
        </trans-unit>
        <trans-unit id="f81a8a635bd5c447a283fcda74554a5cf0e1a36d" translate="yes" xml:space="preserve">
          <source>ImageReadParam.setSourceRenderSize()</source>
          <target state="translated">ImageReadParam.setSourceRenderSize()</target>
        </trans-unit>
        <trans-unit id="f906495681b83a7a65361e49916ce979a0426c83" translate="yes" xml:space="preserve">
          <source>ImageReader</source>
          <target state="translated">ImageReader</target>
        </trans-unit>
        <trans-unit id="dc96d2a37589b461a1a2f4153e1a69d22416ed5b" translate="yes" xml:space="preserve">
          <source>ImageReader.abort()</source>
          <target state="translated">ImageReader.abort()</target>
        </trans-unit>
        <trans-unit id="83f2ec08c69f7b5fc978c20bd79a32f0b4f2197c" translate="yes" xml:space="preserve">
          <source>ImageReader.abortRequested()</source>
          <target state="translated">ImageReader.abortRequested()</target>
        </trans-unit>
        <trans-unit id="5ffcbeadfa0c662e8519d7f22e35f802a4161aeb" translate="yes" xml:space="preserve">
          <source>ImageReader.addIIOReadProgressListener()</source>
          <target state="translated">ImageReader.addIIOReadProgressListener()</target>
        </trans-unit>
        <trans-unit id="55ab4d1ac22f560753cab40ba690b36dc7b0e87d" translate="yes" xml:space="preserve">
          <source>ImageReader.addIIOReadUpdateListener()</source>
          <target state="translated">ImageReader.addIIOReadUpdateListener()</target>
        </trans-unit>
        <trans-unit id="00f5ad390becce52c29dd2e5c4c6ffea976f7d75" translate="yes" xml:space="preserve">
          <source>ImageReader.addIIOReadWarningListener()</source>
          <target state="translated">ImageReader.addIIOReadWarningListener()</target>
        </trans-unit>
        <trans-unit id="04557cc6b974931172aa306cd0120d6bdfcb7944" translate="yes" xml:space="preserve">
          <source>ImageReader.canReadRaster()</source>
          <target state="translated">ImageReader.canReadRaster()</target>
        </trans-unit>
        <trans-unit id="bb47920d771bacef735a7542995c7120f95f227c" translate="yes" xml:space="preserve">
          <source>ImageReader.checkReadParamBandSettings()</source>
          <target state="translated">ImageReader.checkReadParamBandSettings()</target>
        </trans-unit>
        <trans-unit id="1c6ce2ff37299628966cfe31bee7c6648fa58294" translate="yes" xml:space="preserve">
          <source>ImageReader.clearAbortRequest()</source>
          <target state="translated">ImageReader.clearAbortRequest()</target>
        </trans-unit>
        <trans-unit id="60e428b87efa48f5947edb064d44a48fefd6dc8c" translate="yes" xml:space="preserve">
          <source>ImageReader.computeRegions()</source>
          <target state="translated">ImageReader.computeRegions()</target>
        </trans-unit>
        <trans-unit id="0b02305cba48707110942e47479fd4de96aaba83" translate="yes" xml:space="preserve">
          <source>ImageReader.dispose()</source>
          <target state="translated">ImageReader.dispose()</target>
        </trans-unit>
        <trans-unit id="862f19c5fec013bdca9d3acaa7d1d02fe6e60221" translate="yes" xml:space="preserve">
          <source>ImageReader.getAspectRatio()</source>
          <target state="translated">ImageReader.getAspectRatio()</target>
        </trans-unit>
        <trans-unit id="9f7937f38c6919792f25c0c297d3c2d9560c302a" translate="yes" xml:space="preserve">
          <source>ImageReader.getAvailableLocales()</source>
          <target state="translated">ImageReader.getAvailableLocales()</target>
        </trans-unit>
        <trans-unit id="6ef2cfc3e9cee276d76912054d603565ad80e897" translate="yes" xml:space="preserve">
          <source>ImageReader.getDefaultReadParam()</source>
          <target state="translated">ImageReader.getDefaultReadParam()</target>
        </trans-unit>
        <trans-unit id="a6f7e6bef5ae2e033bf2d0309e37885b20a2a7a4" translate="yes" xml:space="preserve">
          <source>ImageReader.getDestination()</source>
          <target state="translated">ImageReader.getDestination()</target>
        </trans-unit>
        <trans-unit id="ed6f46842d3eb44cf80250063a801e8ee871b0f5" translate="yes" xml:space="preserve">
          <source>ImageReader.getFormatName()</source>
          <target state="translated">ImageReader.getFormatName()</target>
        </trans-unit>
        <trans-unit id="af5e6ef5861bb73f88c830f220e29d57f93ef484" translate="yes" xml:space="preserve">
          <source>ImageReader.getHeight()</source>
          <target state="translated">ImageReader.getHeight()</target>
        </trans-unit>
        <trans-unit id="67fc0c0f685a171c6be1b5b4630458248a66bb51" translate="yes" xml:space="preserve">
          <source>ImageReader.getImageMetadata()</source>
          <target state="translated">ImageReader.getImageMetadata()</target>
        </trans-unit>
        <trans-unit id="0cd9e56e497f979ded19cd949256048ec05a8908" translate="yes" xml:space="preserve">
          <source>ImageReader.getImageTypes()</source>
          <target state="translated">ImageReader.getImageTypes()</target>
        </trans-unit>
        <trans-unit id="89ab2b0df8dec8b194c46f9eed32ea752dcd253a" translate="yes" xml:space="preserve">
          <source>ImageReader.getInput()</source>
          <target state="translated">ImageReader.getInput()</target>
        </trans-unit>
        <trans-unit id="7645c286f114ef27413cc9252235a04024cffeba" translate="yes" xml:space="preserve">
          <source>ImageReader.getLocale()</source>
          <target state="translated">ImageReader.getLocale()</target>
        </trans-unit>
        <trans-unit id="05881ac0d7c50df1fedce4c2265168876a1dd69f" translate="yes" xml:space="preserve">
          <source>ImageReader.getMinIndex()</source>
          <target state="translated">ImageReader.getMinIndex()</target>
        </trans-unit>
        <trans-unit id="f5fb554919b40b5bf590e52fdf32545a178965ec" translate="yes" xml:space="preserve">
          <source>ImageReader.getNumImages()</source>
          <target state="translated">ImageReader.getNumImages()</target>
        </trans-unit>
        <trans-unit id="4dc313e7e6c80c0f80ea20afcf72779aad62f48d" translate="yes" xml:space="preserve">
          <source>ImageReader.getNumThumbnails()</source>
          <target state="translated">ImageReader.getNumThumbnails()</target>
        </trans-unit>
        <trans-unit id="fa51cfecd8d98b8edc0ef85e12c99e34375f3980" translate="yes" xml:space="preserve">
          <source>ImageReader.getOriginatingProvider()</source>
          <target state="translated">ImageReader.getOriginatingProvider()</target>
        </trans-unit>
        <trans-unit id="2dd35ae30620fad4265584b22f6dd0d301b80a31" translate="yes" xml:space="preserve">
          <source>ImageReader.getRawImageType()</source>
          <target state="translated">ImageReader.getRawImageType()</target>
        </trans-unit>
        <trans-unit id="772c3749de9149545c202f7bf846a91eae70bd01" translate="yes" xml:space="preserve">
          <source>ImageReader.getSourceRegion()</source>
          <target state="translated">ImageReader.getSourceRegion()</target>
        </trans-unit>
        <trans-unit id="21a53fd1b290330b6ee9001e7897cc9124608203" translate="yes" xml:space="preserve">
          <source>ImageReader.getStreamMetadata()</source>
          <target state="translated">ImageReader.getStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="422bdb64a898763b81ebd4c6c0a49ffa50614262" translate="yes" xml:space="preserve">
          <source>ImageReader.getThumbnailHeight()</source>
          <target state="translated">ImageReader.getThumbnailHeight()</target>
        </trans-unit>
        <trans-unit id="2409b2e10d1ca6bc1887e2473a01d6b5ddd88d3a" translate="yes" xml:space="preserve">
          <source>ImageReader.getThumbnailWidth()</source>
          <target state="translated">ImageReader.getThumbnailWidth()</target>
        </trans-unit>
        <trans-unit id="f6079ff16724edea440c9aef05092dd180ca03e9" translate="yes" xml:space="preserve">
          <source>ImageReader.getTileGridXOffset()</source>
          <target state="translated">ImageReader.getTileGridXOffset()</target>
        </trans-unit>
        <trans-unit id="b7bed61e0f6b2e832750f5320539d86bcd8f1d73" translate="yes" xml:space="preserve">
          <source>ImageReader.getTileGridYOffset()</source>
          <target state="translated">ImageReader.getTileGridYOffset()</target>
        </trans-unit>
        <trans-unit id="a9ffe8eebbb18c47f7ab7d45c2860aeba23fe03c" translate="yes" xml:space="preserve">
          <source>ImageReader.getTileHeight()</source>
          <target state="translated">ImageReader.getTileHeight()</target>
        </trans-unit>
        <trans-unit id="c598984eea032bfe6a67df6db445eb3c61a9cec7" translate="yes" xml:space="preserve">
          <source>ImageReader.getTileWidth()</source>
          <target state="translated">ImageReader.getTileWidth()</target>
        </trans-unit>
        <trans-unit id="239b57f4d284c9ed81be32877db7ca829d6aad8c" translate="yes" xml:space="preserve">
          <source>ImageReader.getWidth()</source>
          <target state="translated">ImageReader.getWidth()</target>
        </trans-unit>
        <trans-unit id="95fb5a83ad4728cf0d19d28beb840d0ab015cfc3" translate="yes" xml:space="preserve">
          <source>ImageReader.hasThumbnails()</source>
          <target state="translated">ImageReader.hasThumbnails()</target>
        </trans-unit>
        <trans-unit id="6a535c8397fa10b6b5c78d496c964f2c8684453b" translate="yes" xml:space="preserve">
          <source>ImageReader.isIgnoringMetadata()</source>
          <target state="translated">ImageReader.isIgnoringMetadata()</target>
        </trans-unit>
        <trans-unit id="fd46f791b3df8fda404201934f2e552fdc7786d2" translate="yes" xml:space="preserve">
          <source>ImageReader.isImageTiled()</source>
          <target state="translated">ImageReader.isImageTiled()</target>
        </trans-unit>
        <trans-unit id="e3b888b29f4f77e432159cab9ac83c2bdeee6f78" translate="yes" xml:space="preserve">
          <source>ImageReader.isRandomAccessEasy()</source>
          <target state="translated">ImageReader.isRandomAccessEasy()</target>
        </trans-unit>
        <trans-unit id="21cb4aa283e4998ab3cc4eba6b03f638b2206274" translate="yes" xml:space="preserve">
          <source>ImageReader.isSeekForwardOnly()</source>
          <target state="translated">ImageReader.isSeekForwardOnly()</target>
        </trans-unit>
        <trans-unit id="83405980505714fab061b5e73072682831fd1099" translate="yes" xml:space="preserve">
          <source>ImageReader.processImageComplete()</source>
          <target state="translated">ImageReader.processImageComplete()</target>
        </trans-unit>
        <trans-unit id="a825cd399a303adaba67bb2d44903c1156834b5d" translate="yes" xml:space="preserve">
          <source>ImageReader.processImageProgress()</source>
          <target state="translated">ImageReader.processImageProgress()</target>
        </trans-unit>
        <trans-unit id="2f5606c190b01674cb99b14e8bfbcbb7c7a4962b" translate="yes" xml:space="preserve">
          <source>ImageReader.processImageStarted()</source>
          <target state="translated">ImageReader.processImageStarted()</target>
        </trans-unit>
        <trans-unit id="12d63aab61b5bc5958d9dfef431913f87fe28d16" translate="yes" xml:space="preserve">
          <source>ImageReader.processImageUpdate()</source>
          <target state="translated">ImageReader.processImageUpdate()</target>
        </trans-unit>
        <trans-unit id="dfe1c122805842bfe5b3f20a7db22b48cd761796" translate="yes" xml:space="preserve">
          <source>ImageReader.processPassComplete()</source>
          <target state="translated">ImageReader.processPassComplete()</target>
        </trans-unit>
        <trans-unit id="f4a909463f9e14f96174182c1794c53f7d83a2e4" translate="yes" xml:space="preserve">
          <source>ImageReader.processPassStarted()</source>
          <target state="translated">ImageReader.processPassStarted()</target>
        </trans-unit>
        <trans-unit id="1ccff571a4dfc2b5085f661fb338eb1acc3e5c92" translate="yes" xml:space="preserve">
          <source>ImageReader.processReadAborted()</source>
          <target state="translated">ImageReader.processReadAborted()</target>
        </trans-unit>
        <trans-unit id="e5dd31c7a713893ea8ac32e5e37bb4404d8083a7" translate="yes" xml:space="preserve">
          <source>ImageReader.processSequenceComplete()</source>
          <target state="translated">ImageReader.processSequenceComplete()</target>
        </trans-unit>
        <trans-unit id="ef653be7cb0793be5d89120339dab603586d9f46" translate="yes" xml:space="preserve">
          <source>ImageReader.processSequenceStarted()</source>
          <target state="translated">ImageReader.processSequenceStarted()</target>
        </trans-unit>
        <trans-unit id="e0ec2514327f115f940fac18bbab7e79c4467cb5" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailComplete()</source>
          <target state="translated">ImageReader.processThumbnailComplete()</target>
        </trans-unit>
        <trans-unit id="c034d8d050941821b2eeb39dcf96c2097bc552d1" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailPassComplete()</source>
          <target state="translated">ImageReader.processThumbnailPassComplete()</target>
        </trans-unit>
        <trans-unit id="27bd8f1a631567b196e414ce17394485cb3b4a05" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailPassStarted()</source>
          <target state="translated">ImageReader.processThumbnailPassStarted()</target>
        </trans-unit>
        <trans-unit id="47060488d6f55ce0e446c835d52343cebce515e9" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailProgress()</source>
          <target state="translated">ImageReader.processThumbnailProgress()</target>
        </trans-unit>
        <trans-unit id="5b89cffe604158032bd2f4456be04fcfd1fc7091" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailStarted()</source>
          <target state="translated">ImageReader.processThumbnailStarted()</target>
        </trans-unit>
        <trans-unit id="f9c9ad260fb38f12182956612b850bbcf23c0ed4" translate="yes" xml:space="preserve">
          <source>ImageReader.processThumbnailUpdate()</source>
          <target state="translated">ImageReader.processThumbnailUpdate()</target>
        </trans-unit>
        <trans-unit id="5b2f86a5e49e056589fa20c70b320b343f82a972" translate="yes" xml:space="preserve">
          <source>ImageReader.processWarningOccurred()</source>
          <target state="translated">ImageReader.processWarningOccurred()</target>
        </trans-unit>
        <trans-unit id="402b088f594fb72f39498c4a355c4ffed0b74070" translate="yes" xml:space="preserve">
          <source>ImageReader.read()</source>
          <target state="translated">ImageReader.read()</target>
        </trans-unit>
        <trans-unit id="ee5a1f319268437ff8387bb0981f3fe47eb57f8a" translate="yes" xml:space="preserve">
          <source>ImageReader.readAll()</source>
          <target state="translated">ImageReader.readAll()</target>
        </trans-unit>
        <trans-unit id="22a5fda3d9b4d4ee2fa0bf74803c2f5115d9ff2d" translate="yes" xml:space="preserve">
          <source>ImageReader.readAsRenderedImage()</source>
          <target state="translated">ImageReader.readAsRenderedImage()</target>
        </trans-unit>
        <trans-unit id="ae9330919034f80a8c2d87c450e681a2a8053aa3" translate="yes" xml:space="preserve">
          <source>ImageReader.readRaster()</source>
          <target state="translated">ImageReader.readRaster()</target>
        </trans-unit>
        <trans-unit id="a09688ff6526526ab7a6038bdd4141c6afe8f1f6" translate="yes" xml:space="preserve">
          <source>ImageReader.readThumbnail()</source>
          <target state="translated">ImageReader.readThumbnail()</target>
        </trans-unit>
        <trans-unit id="3c89f7d36bd8010987131b228345a25d066b76e9" translate="yes" xml:space="preserve">
          <source>ImageReader.readTile()</source>
          <target state="translated">ImageReader.readTile()</target>
        </trans-unit>
        <trans-unit id="8c813dd87cf577e7d6234c47a677676477d95a8a" translate="yes" xml:space="preserve">
          <source>ImageReader.readTileRaster()</source>
          <target state="translated">ImageReader.readTileRaster()</target>
        </trans-unit>
        <trans-unit id="64d3eb2a5d9017a4f0b5f5bbbfdf1c8261f95dbf" translate="yes" xml:space="preserve">
          <source>ImageReader.readerSupportsThumbnails()</source>
          <target state="translated">ImageReader.readerSupportsThumbnails()</target>
        </trans-unit>
        <trans-unit id="099fd73475427f29d3f49fc033fbe68b5e0622e2" translate="yes" xml:space="preserve">
          <source>ImageReader.removeAllIIOReadProgressListeners()</source>
          <target state="translated">ImageReader.removeAllIIOReadProgressListeners()</target>
        </trans-unit>
        <trans-unit id="7df56151d938be64315fcccd83f9d37acf0e82a4" translate="yes" xml:space="preserve">
          <source>ImageReader.removeAllIIOReadUpdateListeners()</source>
          <target state="translated">ImageReader.removeAllIIOReadUpdateListeners()</target>
        </trans-unit>
        <trans-unit id="8b915f705163455fb8a9a23532fec9a43b3d29d5" translate="yes" xml:space="preserve">
          <source>ImageReader.removeAllIIOReadWarningListeners()</source>
          <target state="translated">ImageReader.removeAllIIOReadWarningListeners()</target>
        </trans-unit>
        <trans-unit id="07c92fd388eedbf20e32ad9dc36615cd6bbae20f" translate="yes" xml:space="preserve">
          <source>ImageReader.removeIIOReadProgressListener()</source>
          <target state="translated">ImageReader.removeIIOReadProgressListener()</target>
        </trans-unit>
        <trans-unit id="e9722b3a2f5391a950193f30cd3d54628879aaa6" translate="yes" xml:space="preserve">
          <source>ImageReader.removeIIOReadUpdateListener()</source>
          <target state="translated">ImageReader.removeIIOReadUpdateListener()</target>
        </trans-unit>
        <trans-unit id="023ab851da16bf3a07c58ef101014a670cd932b0" translate="yes" xml:space="preserve">
          <source>ImageReader.removeIIOReadWarningListener()</source>
          <target state="translated">ImageReader.removeIIOReadWarningListener()</target>
        </trans-unit>
        <trans-unit id="e4e83add06a2b48e9526683b506060ae5ed77130" translate="yes" xml:space="preserve">
          <source>ImageReader.reset()</source>
          <target state="translated">ImageReader.reset()</target>
        </trans-unit>
        <trans-unit id="dbdc25a3690bbe4534e5dc416172e1d0ea1288a8" translate="yes" xml:space="preserve">
          <source>ImageReader.setInput()</source>
          <target state="translated">ImageReader.setInput()</target>
        </trans-unit>
        <trans-unit id="23ceac5a96e27350a57962919a976aeb9bfb567a" translate="yes" xml:space="preserve">
          <source>ImageReader.setLocale()</source>
          <target state="translated">ImageReader.setLocale()</target>
        </trans-unit>
        <trans-unit id="376e41ebaa573602896e8d479c0176731174559e" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi</source>
          <target state="translated">ImageReaderSpi</target>
        </trans-unit>
        <trans-unit id="ac7dbd0a753e7ac2ff7335fba8639219adcd8713" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi.canDecodeInput()</source>
          <target state="translated">ImageReaderSpi.canDecodeInput()</target>
        </trans-unit>
        <trans-unit id="3c7dcc0f3b62f34c44289be9aad680842dc8c4ed" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi.createReaderInstance()</source>
          <target state="translated">ImageReaderSpi.createReaderInstance()</target>
        </trans-unit>
        <trans-unit id="50806e3d08c420c4abfcbe7facfd3dc09ec03dce" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi.getImageWriterSpiNames()</source>
          <target state="translated">ImageReaderSpi.getImageWriterSpiNames()</target>
        </trans-unit>
        <trans-unit id="cefb63caddb366bd1eb1c31f48a0ab71564a4c84" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi.getInputTypes()</source>
          <target state="translated">ImageReaderSpi.getInputTypes()</target>
        </trans-unit>
        <trans-unit id="d3136c51d01b4b0b3b305ef950d1ad5a92943e5a" translate="yes" xml:space="preserve">
          <source>ImageReaderSpi.isOwnReader()</source>
          <target state="translated">ImageReaderSpi.isOwnReader()</target>
        </trans-unit>
        <trans-unit id="3443fa6fc0a7963d5ead490360966c6f8774c754" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi</source>
          <target state="translated">ImageReaderWriterSpi</target>
        </trans-unit>
        <trans-unit id="393233988cc33bb6fba0cc35469857ee9f1a8d7f" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getExtraImageMetadataFormatNames()</source>
          <target state="translated">ImageReaderWriterSpi.getExtraImageMetadataFormatNames()</target>
        </trans-unit>
        <trans-unit id="c4fb202455044529cf3c4e4612f21afe062e4963" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getExtraStreamMetadataFormatNames()</source>
          <target state="translated">ImageReaderWriterSpi.getExtraStreamMetadataFormatNames()</target>
        </trans-unit>
        <trans-unit id="48b2bf826dd931098ac161cd8ab73455652f7bb1" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getFileSuffixes()</source>
          <target state="translated">ImageReaderWriterSpi.getFileSuffixes()</target>
        </trans-unit>
        <trans-unit id="345e065fd098396a0dd7c5ef0358fada7b3afa62" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getFormatNames()</source>
          <target state="translated">ImageReaderWriterSpi.getFormatNames()</target>
        </trans-unit>
        <trans-unit id="df48f7d071dd4a2d7c1049cb61f609462a3abaa4" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getImageMetadataFormat()</source>
          <target state="translated">ImageReaderWriterSpi.getImageMetadataFormat()</target>
        </trans-unit>
        <trans-unit id="7b85260052834d518879df691ee7bd10990c050c" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getMIMETypes()</source>
          <target state="translated">ImageReaderWriterSpi.getMIMETypes()</target>
        </trans-unit>
        <trans-unit id="a7c7658657946362cacb3a50d22d77b43b3100bd" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getNativeImageMetadataFormatName()</source>
          <target state="translated">ImageReaderWriterSpi.getNativeImageMetadataFormatName()</target>
        </trans-unit>
        <trans-unit id="a2e2fc9fffc6df64409092179b1f4bad5625f480" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getNativeStreamMetadataFormatName()</source>
          <target state="translated">ImageReaderWriterSpi.getNativeStreamMetadataFormatName()</target>
        </trans-unit>
        <trans-unit id="0b328ac0a7c07da6d3ad5bc66a4afd80f7610bd1" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getPluginClassName()</source>
          <target state="translated">ImageReaderWriterSpi.getPluginClassName()</target>
        </trans-unit>
        <trans-unit id="a3cfa123b91136daa887bb526626487cfaaa1409" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.getStreamMetadataFormat()</source>
          <target state="translated">ImageReaderWriterSpi.getStreamMetadataFormat()</target>
        </trans-unit>
        <trans-unit id="7ac0b3089b0a649caccc4374df94fb3e823364b6" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.isStandardImageMetadataFormatSupported()</source>
          <target state="translated">ImageReaderWriterSpi.isStandardImageMetadataFormatSupported()</target>
        </trans-unit>
        <trans-unit id="7454ccb9648639eac2c96414321e87ec66e98786" translate="yes" xml:space="preserve">
          <source>ImageReaderWriterSpi.isStandardStreamMetadataFormatSupported()</source>
          <target state="translated">ImageReaderWriterSpi.isStandardStreamMetadataFormatSupported()</target>
        </trans-unit>
        <trans-unit id="7074989e970140ccbe5497322f7c8cef8fe1663a" translate="yes" xml:space="preserve">
          <source>ImageTranscoder</source>
          <target state="translated">ImageTranscoder</target>
        </trans-unit>
        <trans-unit id="b65c3add20132f879aa036db292c79a29d3ca488" translate="yes" xml:space="preserve">
          <source>ImageTranscoder.convertImageMetadata()</source>
          <target state="translated">ImageTranscoder.convertImageMetadata()</target>
        </trans-unit>
        <trans-unit id="877dcd3940ee4c1f24efb96f1bd64897c4963bce" translate="yes" xml:space="preserve">
          <source>ImageTranscoder.convertStreamMetadata()</source>
          <target state="translated">ImageTranscoder.convertStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="34cb2653707bc3d390fb96709f633289b6833ab3" translate="yes" xml:space="preserve">
          <source>ImageTranscoderSpi</source>
          <target state="translated">ImageTranscoderSpi</target>
        </trans-unit>
        <trans-unit id="7dcf7fb9441e9be7a2d69c7af23e41cb047e93e2" translate="yes" xml:space="preserve">
          <source>ImageTranscoderSpi.createTranscoderInstance()</source>
          <target state="translated">ImageTranscoderSpi.createTranscoderInstance()</target>
        </trans-unit>
        <trans-unit id="397cb3241db131e36b52f8ecc780c8867166595e" translate="yes" xml:space="preserve">
          <source>ImageTranscoderSpi.getReaderServiceProviderName()</source>
          <target state="translated">ImageTranscoderSpi.getReaderServiceProviderName()</target>
        </trans-unit>
        <trans-unit id="34b0abd472106b1013e774590a3046f282e9a71b" translate="yes" xml:space="preserve">
          <source>ImageTranscoderSpi.getWriterServiceProviderName()</source>
          <target state="translated">ImageTranscoderSpi.getWriterServiceProviderName()</target>
        </trans-unit>
        <trans-unit id="bf50296a873ae59a7d7778a3ed242c052be43098" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier</source>
          <target state="translated">ImageTypeSpecifier</target>
        </trans-unit>
        <trans-unit id="8567bfd1b3de238aea08d0617373266b768a64cd" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createBanded()</source>
          <target state="translated">ImageTypeSpecifier.createBanded()</target>
        </trans-unit>
        <trans-unit id="6a0fae9470c6e2ba3648f004192b22c9a6f30ea6" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createBufferedImage()</source>
          <target state="translated">ImageTypeSpecifier.createBufferedImage()</target>
        </trans-unit>
        <trans-unit id="c9eea4554eb312780cc7b1c2ae286a32c7fa59e2" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createFromBufferedImageType()</source>
          <target state="translated">ImageTypeSpecifier.createFromBufferedImageType()</target>
        </trans-unit>
        <trans-unit id="d711b829e0890002b2a91a880e4e25e63fda3730" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createFromRenderedImage()</source>
          <target state="translated">ImageTypeSpecifier.createFromRenderedImage()</target>
        </trans-unit>
        <trans-unit id="a0ea04c2125a810758a9582b6f48810c6c8b8089" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createGrayscale()</source>
          <target state="translated">ImageTypeSpecifier.createGrayscale()</target>
        </trans-unit>
        <trans-unit id="fc83b2d72b5153f93778d0864dad26c5e7097c5b" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createIndexed()</source>
          <target state="translated">ImageTypeSpecifier.createIndexed()</target>
        </trans-unit>
        <trans-unit id="97badba223b73a028a6dd43f25ca5d9071a9fe30" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createInterleaved()</source>
          <target state="translated">ImageTypeSpecifier.createInterleaved()</target>
        </trans-unit>
        <trans-unit id="ae499dfc3b95f67fe6d966d7c9687c98ade3face" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.createPacked()</source>
          <target state="translated">ImageTypeSpecifier.createPacked()</target>
        </trans-unit>
        <trans-unit id="e8360d73a22bf926157c8f48eba9af4d29fedac4" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.equals()</source>
          <target state="translated">ImageTypeSpecifier.equals()</target>
        </trans-unit>
        <trans-unit id="d7b571daa3f9bb6c2031b7ef1d881e74fdd1d4ff" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getBitsPerBand()</source>
          <target state="translated">ImageTypeSpecifier.getBitsPerBand()</target>
        </trans-unit>
        <trans-unit id="b8c286b8d4bde28e992024df5b5a8ed7f3edefca" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getBufferedImageType()</source>
          <target state="translated">ImageTypeSpecifier.getBufferedImageType()</target>
        </trans-unit>
        <trans-unit id="1a6bf2a63f0739c1077b3e3098e53fcef1ae1ced" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getColorModel()</source>
          <target state="translated">ImageTypeSpecifier.getColorModel()</target>
        </trans-unit>
        <trans-unit id="e66273a7d655626df06f98d5dd65e6ecdb55ed63" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getNumBands()</source>
          <target state="translated">ImageTypeSpecifier.getNumBands()</target>
        </trans-unit>
        <trans-unit id="f829597101acf9d5743e4311e6294f51d12d3c46" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getNumComponents()</source>
          <target state="translated">ImageTypeSpecifier.getNumComponents()</target>
        </trans-unit>
        <trans-unit id="40217a206fe4c99da358dbb01869b89d042d7f68" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.getSampleModel()</source>
          <target state="translated">ImageTypeSpecifier.getSampleModel()</target>
        </trans-unit>
        <trans-unit id="9476b6b5282eef57fb6d8642e44cd44dc849fdb2" translate="yes" xml:space="preserve">
          <source>ImageTypeSpecifier.hashCode()</source>
          <target state="translated">ImageTypeSpecifier.hashCode()</target>
        </trans-unit>
        <trans-unit id="07683084bc9eafadf7bb5ab59817c271f28e7ca5" translate="yes" xml:space="preserve">
          <source>ImageWriteParam</source>
          <target state="translated">ImageWriteParam</target>
        </trans-unit>
        <trans-unit id="6dc3171d7ef8bffe69ca5d3a9f3dab7f36980640" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.canOffsetTiles()</source>
          <target state="translated">ImageWriteParam.canOffsetTiles()</target>
        </trans-unit>
        <trans-unit id="475e8299763b3f808fea8a780162d768a366114a" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.canWriteCompressed()</source>
          <target state="translated">ImageWriteParam.canWriteCompressed()</target>
        </trans-unit>
        <trans-unit id="bd57676b35d6d2d71f22ae6fa059ab875cb75579" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.canWriteProgressive()</source>
          <target state="translated">ImageWriteParam.canWriteProgressive()</target>
        </trans-unit>
        <trans-unit id="99be13b9ee21eb767ed6c1f05abca26887b0d158" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.canWriteTiles()</source>
          <target state="translated">ImageWriteParam.canWriteTiles()</target>
        </trans-unit>
        <trans-unit id="2e9f75633cc6ca3dc8df3258ec1106f8a88042a5" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getBitRate()</source>
          <target state="translated">ImageWriteParam.getBitRate()</target>
        </trans-unit>
        <trans-unit id="b3885e99ad3bdca8a00ac5ba3bb8a9943d565224" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionMode()</source>
          <target state="translated">ImageWriteParam.getCompressionMode()</target>
        </trans-unit>
        <trans-unit id="61121fff18c829b95668813fe016c042a1cc4255" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionQuality()</source>
          <target state="translated">ImageWriteParam.getCompressionQuality()</target>
        </trans-unit>
        <trans-unit id="6babb304bcc35a37b4fa5ae725e4416c07d39b8c" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionQualityDescriptions()</source>
          <target state="translated">ImageWriteParam.getCompressionQualityDescriptions()</target>
        </trans-unit>
        <trans-unit id="1bc463905c78e183d00029b667c84948a25dcf46" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionQualityValues()</source>
          <target state="translated">ImageWriteParam.getCompressionQualityValues()</target>
        </trans-unit>
        <trans-unit id="7bce38049e7b015c9210d033a761c00397269971" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionType()</source>
          <target state="translated">ImageWriteParam.getCompressionType()</target>
        </trans-unit>
        <trans-unit id="120fd5386b558bae7b698d70df640560e01387a5" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getCompressionTypes()</source>
          <target state="translated">ImageWriteParam.getCompressionTypes()</target>
        </trans-unit>
        <trans-unit id="ca298a4496ff7f080b2ceb35fef7ebd4f453e6a1" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getLocale()</source>
          <target state="translated">ImageWriteParam.getLocale()</target>
        </trans-unit>
        <trans-unit id="7c44903cef90cb8b271db6fe029b03bcacde7152" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getLocalizedCompressionTypeName()</source>
          <target state="translated">ImageWriteParam.getLocalizedCompressionTypeName()</target>
        </trans-unit>
        <trans-unit id="f323ca52d15633b8524d32324c152c53fb27584b" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getPreferredTileSizes()</source>
          <target state="translated">ImageWriteParam.getPreferredTileSizes()</target>
        </trans-unit>
        <trans-unit id="912209f5a4b1d009431bef6c30e73e483a5ea36d" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getProgressiveMode()</source>
          <target state="translated">ImageWriteParam.getProgressiveMode()</target>
        </trans-unit>
        <trans-unit id="f02a967bd40a471af171d11100a9bf989e6b753b" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getTileGridXOffset()</source>
          <target state="translated">ImageWriteParam.getTileGridXOffset()</target>
        </trans-unit>
        <trans-unit id="b688c968cc015c550840729aef049e208a474759" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getTileGridYOffset()</source>
          <target state="translated">ImageWriteParam.getTileGridYOffset()</target>
        </trans-unit>
        <trans-unit id="223ba30a3d8d30ac19b4c024ed256ee13f3b5a0b" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getTileHeight()</source>
          <target state="translated">ImageWriteParam.getTileHeight()</target>
        </trans-unit>
        <trans-unit id="c8536380edb0accf3360e06ba7d3b95289337625" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getTileWidth()</source>
          <target state="translated">ImageWriteParam.getTileWidth()</target>
        </trans-unit>
        <trans-unit id="300d303fcb42fea0bab918d263d0cb51f641b271" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.getTilingMode()</source>
          <target state="translated">ImageWriteParam.getTilingMode()</target>
        </trans-unit>
        <trans-unit id="4df72fb263a5522f7a874ac051fd5eaff93c839b" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.isCompressionLossless()</source>
          <target state="translated">ImageWriteParam.isCompressionLossless()</target>
        </trans-unit>
        <trans-unit id="8fff1e955237d51ee22d2e2afa3e834707d92156" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.setCompressionMode()</source>
          <target state="translated">ImageWriteParam.setCompressionMode()</target>
        </trans-unit>
        <trans-unit id="8450501a9c81e824c9b19f0ace510839d247289b" translate="yes" xml:space="preserve">
          <source>ImageWriteParam.setCompressionQuality()</source>
          <target state="translated">ImageWriteParam.setCompressionQuality()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
