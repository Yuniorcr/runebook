<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="28393cbfd67002d6ad36a08762b2e38653599b68" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the &lt;code&gt;==&lt;/code&gt; operator)</source>
          <target state="translated">두 문자는 동일합니다 ( &lt;code&gt;==&lt;/code&gt; 연산자 와 비교하여 )</target>
        </trans-unit>
        <trans-unit id="4a8e8cdc02eb816448907e6ad7e73c37517a03bf" translate="yes" xml:space="preserve">
          <source>The two possible authentication types for a resource.</source>
          <target state="translated">자원에 대한 두 가지 가능한 인증 유형.</target>
        </trans-unit>
        <trans-unit id="8562722983b5297a255d72d065fc4efeeada15b3" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1e9cc57517a9438e11a17414782fcda2ca6c93d7" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 이중 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f74bb945ec6a22ab7838a324a183e657cee9de65" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 float 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ea19c65ec77bbed855a0ec57d24fe61a6f3cfc" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the last parameter type of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">어댑터의 유형 및 작동은 대상의 유형 및 작동과 동일하지만 특정 &lt;code&gt;invoke&lt;/code&gt; 및 &lt;code&gt;asType&lt;/code&gt; 요청으로 인해 후행 위치 인수가 대상의 후행 매개 변수로 수집 될 수 있습니다. 또한 대상의 마지막 매개 변수 유형이 다른 경우에도 어댑터의 마지막 매개 변수 유형은 &lt;code&gt;arrayType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff6bb0cadf07db39ec6be40e5dae1eed885b4134" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형 및 인코딩은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 문서를 참조하여 다른 유형 또는 인코딩이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8a0aad1afcd781464b76996d424e8348249f28ac" translate="yes" xml:space="preserve">
          <source>The type fingerprint that is set to indicate serialization compatibility with a previous version of the type.</source>
          <target state="translated">이전 버전의 유형과의 직렬화 호환성을 나타내도록 설정된 유형 지문입니다.</target>
        </trans-unit>
        <trans-unit id="47aacc9e53df6990e6cd21e34ac8f46081f60e02" translate="yes" xml:space="preserve">
          <source>The type is a &lt;code&gt;String&lt;/code&gt; that identifies the type of &lt;code&gt;Certificate&lt;/code&gt;s in the certification path. For each certificate &lt;code&gt;cert&lt;/code&gt; in a certification path &lt;code&gt;certPath&lt;/code&gt;, &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">유형은 인증 경로에서 &lt;code&gt;Certificate&lt;/code&gt; 유형을 식별 하는 &lt;code&gt;String&lt;/code&gt; 입니다 . 각 인증서의 경우 &lt;code&gt;cert&lt;/code&gt; 인증 경로에서 &lt;code&gt;certPath&lt;/code&gt; , &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; 해야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3992f3a6c4f1b89ac824af3b12e6534482315701" translate="yes" xml:space="preserve">
          <source>The type is an interface type and not an annotation type, enum, or class.</source>
          <target state="translated">형식은 인터페이스 형식이며 주석 형식, 열거 형 또는 클래스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dbbee8087c3ba28222fa95426623818374828807" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt;&lt;code&gt;Redirect.INHERIT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt; &lt;code&gt;Redirect.INHERIT&lt;/code&gt; &lt;/a&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c0ad9640a3999591dd1d2029f7ecfcb72b0d98b2" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="f56f95d6997ec10a60d61b49368aad5c85b0c93d" translate="yes" xml:space="preserve">
          <source>The type of MIDI file.</source>
          <target state="translated">MIDI 파일의 타입입니다.</target>
        </trans-unit>
        <trans-unit id="127e2dcfa435659f04a5c90d26c476f9ace2f0e1" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;processbuilder.redirect&quot;&gt;&lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect&quot;&gt; &lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt; &lt;/a&gt; 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="19a111fbf1a4085482090a96e6a31a6562e4dbf5" translate="yes" xml:space="preserve">
          <source>The type of a metric, one of the strings &quot;counter&quot; or &quot;gauge&quot;. A metric is a measurement exported by an MBean, usually an attribute but sometimes the result of an operation. A metric that is a &lt;em&gt;counter&lt;/em&gt; has a value that never decreases except by being reset to a starting value. Counter metrics are almost always non-negative integers. An example might be the number of requests received. A metric that is a &lt;em&gt;gauge&lt;/em&gt; has a numeric value that can increase or decrease. Examples might be the number of open connections or a cache hit rate or a temperature reading.</source>
          <target state="translated">문자열 &quot;counter&quot;또는 &quot;gauge&quot;중 하나의 메트릭 유형입니다. 메트릭은 일반적으로 속성이지만 때로는 작업 결과 인 MBean에서 내 보낸 측정 값입니다. &lt;em&gt;카운터 인&lt;/em&gt; 메트릭 은 시작 값으로 재설정하지 않는 한 절대 감소하지 않는 값을 갖습니다. 카운터 메트릭은 거의 항상 음이 아닌 정수입니다. 수신 된 요청 수를 예로들 수 있습니다. &lt;em&gt;게이지 인&lt;/em&gt; 메트릭 에는 증가 또는 감소 할 수있는 숫자 값이 있습니다. 열린 연결 수 또는 캐시 적중률 또는 온도 판독 값이 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="aa5066ac5677ba94a729db439698f3123b5e4800" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b6c13fdf29d3471638747b7836301b890025ac8d" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1b7eaaee0ed7fe469cb15b4032d95ee3779bbd61" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="62d360876f66c4619f7a66dbb6e3f42e2c3d1fb3" translate="yes" xml:space="preserve">
          <source>The type of the call site is permanently set to the given type.</source>
          <target state="translated">호출 사이트의 유형은 지정된 유형으로 영구적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0f38c67fdfb625338235f720fe145ed3f504d4e9" translate="yes" xml:space="preserve">
          <source>The type of the entity requesting authentication.</source>
          <target state="translated">인증을 요청하는 엔티티의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="05a0aedd8679b410dfd61aa7d127e3dcd930c83d" translate="yes" xml:space="preserve">
          <source>The type of the new method handle will drop the types for the bound parameters from the original target type, since the new method handle will no longer require those arguments to be supplied by its callers.</source>
          <target state="translated">새 메소드 핸들의 유형은 더 이상 호출자가 호출 한 인수를 제공하지 않아도되므로 원래 대상 유형에서 바운드 매개 변수의 유형을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="689485c1e5985a3231bd5ec529f55e5aa04a546f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">새 대상 의 유형은 이전 대상의 유형 &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;과 같아야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a890ec2d11b23f48d0302a6f1ff678bb8116b7db" translate="yes" xml:space="preserve">
          <source>The type of the observed attribute is not correct.</source>
          <target state="translated">관찰 된 속성의 유형이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37d7b8236ac8a0ff81b6ebd996e68b65203530e" translate="yes" xml:space="preserve">
          <source>The type of the returned invoker will not be the given &lt;code&gt;type&lt;/code&gt;, but rather will have all parameters except the first &lt;code&gt;leadingArgCount&lt;/code&gt; replaced by a single array of type &lt;code&gt;Object[]&lt;/code&gt;, which will be the final parameter.</source>
          <target state="translated">반환 된 호출자의 유형은 지정된 &lt;code&gt;type&lt;/code&gt; 이 아니라 첫 번째 &lt;code&gt;leadingArgCount&lt;/code&gt; 제외한 모든 매개 변수를 &lt;code&gt;Object[]&lt;/code&gt; 유형의 단일 배열로 대체 하여 최종 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="3713b00b65f5a644a274c8162bd2331606919143" translate="yes" xml:space="preserve">
          <source>The type of this event.</source>
          <target state="translated">이 이벤트의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="efb86a4d23b927b4d7779a5f3229d3b046c17f0c" translate="yes" xml:space="preserve">
          <source>The types are compared for equality with their case ignored.</source>
          <target state="translated">유형은 대소 문자를 무시하고 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="59391c7d69614504e0086f4dff6684db3e9ee2b5" translate="yes" xml:space="preserve">
          <source>The types of notifications emitted by &lt;code&gt;MemoryMXBean&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 에서 생성 된 알림 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444baca227e7a21fbc93ead1d887a79a164df63b" translate="yes" xml:space="preserve">
          <source>The typical language value is a two or three-letter language code as defined in ISO639.</source>
          <target state="translated">일반적인 언어 값은 ISO639에 정의 된 2 자리 또는 3 자리 언어 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5c660145e6f646b3735ac4f7205ca9ace38822eb" translate="yes" xml:space="preserve">
          <source>The typical region value is a two-letter ISO 3166 code or a three-digit UN M.49 area code.</source>
          <target state="translated">일반적인 지역 값은 2 자리 ISO 3166 코드 또는 3 자리 UN M.49 지역 코드입니다.</target>
        </trans-unit>
        <trans-unit id="17cdcc250877b85946cb955da511369645e967cc" translate="yes" xml:space="preserve">
          <source>The typical script value is a four-letter script code as defined by ISO 15924.</source>
          <target state="translated">일반적인 스크립트 값은 ISO 15924에 의해 정의 된 4 자리 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="121414ae83882d6978c3061ae2ccaf0b4cd3a7f5" translate="yes" xml:space="preserve">
          <source>The underlying character-input stream.</source>
          <target state="translated">기본 문자 입력 스트림</target>
        </trans-unit>
        <trans-unit id="66e9f85ce07195fbd2dc5d2f06d3273076e5b33d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream of this &lt;code&gt;PrintWriter&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;PrintWriter&lt;/code&gt; 기본이되는 문자 출력 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="997090c1014b7704de737ddf5326441d3f6eab7d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream.</source>
          <target state="translated">기본 문자 출력 스트림</target>
        </trans-unit>
        <trans-unit id="48e3e0bfbed1be484de7c256629bbfc344226e62" translate="yes" xml:space="preserve">
          <source>The underlying field's value is obtained as follows:</source>
          <target state="translated">기본 필드의 값은 다음과 같이 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6b7dedd2916acda5e4ddd9bf5218b5756a52e4ca" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dsts ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 및 &lt;code&gt;dsts ByteBuffer&lt;/code&gt; 가 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="028d275e77138b148a731ed31ec7168887398dc7" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;srcs&lt;/code&gt; and &lt;code&gt;dst ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;srcs&lt;/code&gt; 및 &lt;code&gt;dst ByteBuffer&lt;/code&gt; 가 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8bcc6a3ebcd69bf1c22f30e41fee2405130dbb8f" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began. For a channel that is ready for at least one such operation, one of the following two actions is performed:</source>
          <target state="translated">기본 오퍼레이팅 시스템은 선택 조작이 시작된 순간 키의 관심 세트로 식별 된 오퍼레이션을 수행하기 위해 나머지 각 채널의 준비 상태에 대한 업데이트를 쿼리합니다. 이러한 작업을 하나 이상 준비한 채널의 경우 다음 두 작업 중 하나가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fac40f1f061f6b657772e9f893915f23de48bf5" translate="yes" xml:space="preserve">
          <source>The underlying output stream to be filtered.</source>
          <target state="translated">필터링 할 기본 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="1a5764b11a39a7b859946ca022bc7546c2758d6c" translate="yes" xml:space="preserve">
          <source>The underlying signing algorithm is designated by the Signature object passed to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. A typical usage for signing is the following:</source>
          <target state="translated">기본 서명 알고리즘은 생성자 및 &lt;code&gt;verify&lt;/code&gt; 메서드에 전달 된 Signature 객체로 지정됩니다 . 서명의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a0c62e15b608a731329638c7175e259e5b752ff" translate="yes" xml:space="preserve">
          <source>The underscore character &lt;code&gt;'_'&lt;/code&gt; (&lt;code&gt;'\u005f'&lt;/code&gt;, &lt;small&gt;LOW LINE&lt;/small&gt;).</source>
          <target state="translated">밑줄 문자 &lt;code&gt;'_'&lt;/code&gt; ( &lt;code&gt;'\u005f'&lt;/code&gt; , &lt;small&gt;LOW LINE&lt;/small&gt; ).</target>
        </trans-unit>
        <trans-unit id="cae92f9fce61041c312223fede1e34d5be987d37" translate="yes" xml:space="preserve">
          <source>The uniquely named method is allowed to be multiply declared, with distinct type descriptors. (E.g., it can be overloaded, or can possess bridge methods.) All such declarations are connected directly to the target method handle. Argument and return types are adjusted by &lt;code&gt;asType&lt;/code&gt; for each individual declaration.</source>
          <target state="translated">고유 한 이름의 메소드는 고유 한 유형 설명 자로 여러 번 선언 될 수 있습니다. (예를 들어, 오버로드되거나 브릿지 메소드를 소유 할 수 있습니다.) 이러한 모든 선언은 대상 메소드 핸들에 직접 연결됩니다. 인수 및 반환 유형은 각 개별 선언에 대해 &lt;code&gt;asType&lt;/code&gt; 으로 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5191f12612fb84b7bbf9829ac12d3dce772f7d2d" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">단위는 남은 시간없이 표준 날짜의 길이로 나눌 수있는 &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;기간&lt;/a&gt; 이 있어야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 에 제공된 모든 시간 단위가 포함됩니다 . 다른 부대는 예외를 던진다.</target>
        </trans-unit>
        <trans-unit id="5122174d5f83d404ea9a42f52e7c1c4179e0a65a" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ac0d6412e7c41ea9d12640bb3ba8932b0b5834" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f111a51a42acb493693efa131e93c6ce9b6b10b" translate="yes" xml:space="preserve">
          <source>The unit that represents week-based-years for the purpose of addition and subtraction.</source>
          <target state="translated">덧셈과 뺄셈의 목적으로 주별 연도를 나타내는 단위입니다.</target>
        </trans-unit>
        <trans-unit id="27ed7bbeff7184c6ce008c19d55f08c8ed276069" translate="yes" xml:space="preserve">
          <source>The unit works using double dispatch. Client code calls methods on a date-time like &lt;code&gt;LocalDateTime&lt;/code&gt; which check if the unit is a &lt;code&gt;ChronoUnit&lt;/code&gt;. If it is, then the date-time must handle it. Otherwise, the method call is re-dispatched to the matching method in this interface.</source>
          <target state="translated">이 장치는 이중 디스패치를 ​​사용하여 작동합니다. 클라이언트 코드 는 단위가 &lt;code&gt;ChronoUnit&lt;/code&gt; 인지 확인하는 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 같은 날짜-시간에 메소드를 호출합니다 . 그렇다면 날짜-시간이 처리해야합니다. 그렇지 않은 경우, 메소드 호출은이 인터페이스에서 일치하는 메소드로 다시 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="337c6ca2e533607b16bd03301e040526d12b467c" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">속성은, 파라미터 또는 동작 리턴 값은, 예를 들어, 측정 된 단위 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d174c8b0683065fbf044b493c3ef8ed79dc428" translate="yes" xml:space="preserve">
          <source>The unknown conversion.</source>
          <target state="translated">알 수없는 변환입니다.</target>
        </trans-unit>
        <trans-unit id="c132eeb914111eef836f7b17954aa6d06ab7144e" translate="yes" xml:space="preserve">
          <source>The unmatched format specifier</source>
          <target state="translated">일치하지 않는 형식 지정자</target>
        </trans-unit>
        <trans-unit id="89d7d1f2a0c6d2d00918acd6dc9254422a7dc31f" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c2a58d4aa16389063e1d4593b8080b538ec67075" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker--&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newUnpacker--&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="101f5ee99703bb9848ebdb64b9a981d2574364ad" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">언 팩커가 주기적으로 업데이트 한 언 팩커 진행률 (백분율)입니다. 0-100의 값은 정상이며 -1은 중단을 나타냅니다. 이 특성의 값을 폴링하여 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b61a518de7509b59d212e291756906cb8ecb6f4" translate="yes" xml:space="preserve">
          <source>The unqualified name of a proxy class is unspecified. The space of class names that begin with the string &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; should be, however, reserved for proxy classes.</source>
          <target state="translated">프록시 클래스의 규정되지 않은 이름이 지정되지 않았습니다. 그러나 문자열 &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; 시작하는 클래스 이름 공간은 프록시 클래스 용으로 예약되어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb7964c4b4dc617463023ff4866e3bcc872cfffc" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="90b3bb257b666565307d76750b50c74e6f924841" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="43fc0c46437e63e9c1bc27fd8276c60615fc1eec" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ef8dc1e7e596de25447c72effc2b78e2e9eda78" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;32를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="054a6f2331c22a50fc40ea825d5bbe23a0c2752a" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;32를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4adf2f37edf13f4b7e5a873d42af291756d4bd27" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값은 인수에 인수가 음수 인 경우 2 &lt;sup&gt;32를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6060d22783b5de73678a070487c0c6a5f000dbdf" translate="yes" xml:space="preserve">
          <source>The unusual compilation and linkage behavior of &lt;code&gt;invokeExact&lt;/code&gt; and plain &lt;code&gt;invoke&lt;/code&gt; is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 및 일반 &lt;code&gt;invoke&lt;/code&gt; 의 비정상적인 컴파일 및 연결 동작은 &lt;em&gt;시그니처 다형성&lt;/em&gt; 이라는 용어로 참조됩니다 . Java 언어 사양에 정의 된대로 서명 다형성 방법은 광범위한 호출 서명 및 반환 유형과 함께 작동 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d313d97487f3c7f3cbc749779eb54e77639e2d72" translate="yes" xml:space="preserve">
          <source>The updated CompositeName, not a new one. Cannot be null.</source>
          <target state="translated">새 이름이 아닌 업데이트 된 CompositeName입니다. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a42c811bccd6dd7e2f5a6b9d96175190ed03196" translate="yes" xml:space="preserve">
          <source>The updated CompoundName, not a new one. Cannot be null.</source>
          <target state="translated">새로운 CompoundName이 아닌 업데이트 된 CompoundName. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0a53b9e80856c6692659d4301653ca2c511f3f2" translate="yes" xml:space="preserve">
          <source>The updated LdapName, not a new instance. Cannot be null.</source>
          <target state="translated">새 인스턴스가 아닌 업데이트 된 LdapName null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff1724ae2775960bc3b129d71cefa43e6c05193" translate="yes" xml:space="preserve">
          <source>The updated name (not a new instance).</source>
          <target state="translated">업데이트 된 이름 (새 인스턴스가 아님).</target>
        </trans-unit>
        <trans-unit id="9e5507eac7b1c8f8528ce3b0b75192849c664597" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'a'&lt;/code&gt;. The entire string representing the number will be converted to upper case including the &lt;code&gt;'x'&lt;/code&gt; (&lt;code&gt;'\u0078'&lt;/code&gt;) and &lt;code&gt;'p'&lt;/code&gt; (&lt;code&gt;'\u0070'&lt;/code&gt; and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'a'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 캐릭터 라인 전체가 대문자로 변환 될 &lt;code&gt;'x'&lt;/code&gt; ( &lt;code&gt;'\u0078'&lt;/code&gt; )와 &lt;code&gt;'p'&lt;/code&gt; ( &lt;code&gt;'\u0070'&lt;/code&gt; 모두 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c5bb73738331e23e3b8d0a094ce01abeb63f19" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'b'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="322e75fb849065f4ca52a6addf60e0ac9b017449" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'c'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'c'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="a34a284aaae73cba16fd4c94692a85c43d38c457" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'e'&lt;/code&gt;. The exponent symbol will be &lt;code&gt;'E'&lt;/code&gt; (&lt;code&gt;'\u0045'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'e'&lt;/code&gt; 의 대문자 변형입니다 . 지수 기호는 &lt;code&gt;'E'&lt;/code&gt; ( &lt;code&gt;'\u0045'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="8e4023159140f742a67dc9be0c2aef26ca29decf" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'g'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'g'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0a797a98a3e9c41bf7072b33c0c5562f599482a3" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'h'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'h'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="07e68ff070c96b0a5cf38a9497cd5a90681077a0" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="6d089cd4117c5c549f52accd43d02871b2e37215" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'t'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'t'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="a786ff8547a2a8f3e96b122c7d43bbbbe0cec7bd" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 전체 문자열로 변환한다 &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;상부 케이스&lt;/a&gt; 포함 &lt;code&gt;'x'&lt;/code&gt; (있는 경우) 모든 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="654f2289487545b8f3928941dfdc0d162440284e" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; (&lt;code&gt;'\u0041'&lt;/code&gt; through &lt;code&gt;'\u005a'&lt;/code&gt;),</source>
          <target state="translated">대문자 &lt;code&gt;'A'&lt;/code&gt; ~ &lt;code&gt;'Z'&lt;/code&gt; ( &lt;code&gt;'\u0041'&lt;/code&gt; ~ &lt;code&gt;'\u005a'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4330d8d1977e43b23dd07bee2099b3f4b622bfa6" translate="yes" xml:space="preserve">
          <source>The url string has the following expected structure.</source>
          <target state="translated">URL 문자열의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4af9a221919250af2a20e619455ccc9a51cf8601" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;synchronized&lt;/code&gt; methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.</source>
          <target state="translated">의 사용 &lt;code&gt;synchronized&lt;/code&gt; 방법이나 문은 모든 객체와 관련된 암묵의 감시 락에의 액세스를 제공하지만, 힘 모든 잠금 획득 및 해제는 블록 구조의 방법으로 발생 : 여러 잠금 취득 할 때 반대 순서로 발표되어야 모든 잠금은 잠금을 획득 한 동일한 어휘 범위에서 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="63a7e152cb80dbfba69bf4ce931d07a2966b3c06" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;Supplier&lt;/code&gt; in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">이 형식 으로 &lt;code&gt;Supplier&lt;/code&gt; 를 사용 하면 소스와의 잠재적 인 간섭 범위를 줄이는 간접적 인 수준을 제공 할 수 있습니다. 공급 업체는 터미널 작업이 시작된 후에 만 ​​호출되므로 터미널 작업이 시작될 때까지 소스에 대한 모든 수정 사항이 스트림 결과에 반영됩니다. 자세한 내용은 &lt;a href=&quot;package-summary#NonInterference&quot;&gt;비 간섭&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="454af7b03b7693d82fd0e4233351ee60b0851423" translate="yes" xml:space="preserve">
          <source>The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).</source>
          <target state="translated">사용자는 자신의 MBean 관계 클래스를 작성할 때 RelationSupport를 확장하여 필요한 인터페이스의 구현을 검색 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="df61ad83755512938c568feb25a069781cb800fc" translate="yes" xml:space="preserve">
          <source>The user data object. It is used for whatever data the notification source wishes to communicate to its consumers.</source>
          <target state="translated">사용자 데이터 객체. 알림 소스가 소비자와 통신하고자하는 모든 데이터에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a90065a65c9a5ea16238f84c083e26d1b911ff17" translate="yes" xml:space="preserve">
          <source>The user-defined authenticator instance is passed to the connector server in the environment map as the value of the attribute &lt;a href=&quot;jmxconnectorserver#AUTHENTICATOR&quot;&gt;&lt;code&gt;JMXConnectorServer.AUTHENTICATOR&lt;/code&gt;&lt;/a&gt;. For connector servers that use only this authentication system, if this attribute is not present or its value is &lt;code&gt;null&lt;/code&gt; then no user authentication will be performed and full access to the methods exported by the &lt;code&gt;MBeanServerConnection&lt;/code&gt; object will be allowed.</source>
          <target state="translated">사용자 정의 인증 자 인스턴스는 &lt;a href=&quot;jmxconnectorserver#AUTHENTICATOR&quot;&gt; &lt;code&gt;JMXConnectorServer.AUTHENTICATOR&lt;/code&gt; &lt;/a&gt; 속성 값으로 환경 맵의 커넥터 서버에 전달됩니다 . 이 인증 시스템만을 사용하는 커넥터 서버의 경우,이 속성이 없거나 값이 &lt;code&gt;null&lt;/code&gt; 이면 사용자 인증이 수행되지 않고 &lt;code&gt;MBeanServerConnection&lt;/code&gt; 오브젝트가 내 보낸 메소드에 대한 전체 액세스 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c914f1ee26eb2ebcd79dbec38073d9056bf25e3d" translate="yes" xml:space="preserve">
          <source>The user-information component of a URI, if defined, only contains characters in the</source>
          <target state="translated">URI의 사용자 정보 구성 요소 (정의 된 경우)에는</target>
        </trans-unit>
        <trans-unit id="03440d126078d0084be21d674c68227ce0cda463" translate="yes" xml:space="preserve">
          <source>The username/password, or null if one can't be gotten.</source>
          <target state="translated">사용자 이름 / 비밀번호. 또는 아이디를 얻을 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="ffbb7618ff4fd4460738f69cf1f76b5b5baf3e9a" translate="yes" xml:space="preserve">
          <source>The usual way to create an RMI connector server is to supply an RMI connector address to the method &lt;a href=&quot;../jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt;&lt;/a&gt;. The MBean server to which the connector server is attached can be specified as a parameter to that method. Alternatively, the connector server can be registered as an MBean in that MBean server.</source>
          <target state="translated">RMI 커넥터 서버를 작성하는 일반적인 방법은 &lt;a href=&quot;../jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;JMXConnectorServerFactory.newJMXConnectorServer&lt;/code&gt; &lt;/a&gt; 메소드에 RMI 커넥터 주소를 제공하는 것 입니다. 커넥터 서버가 연결된 MBean 서버는 해당 메소드의 매개 변수로 지정할 수 있습니다. 또는 커넥터 서버를 해당 MBean 서버에서 MBean으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8fbb7c2ff253065f61fe611df6643442f33374" translate="yes" xml:space="preserve">
          <source>The utility method to check whether a host name is in a domain or not.</source>
          <target state="translated">호스트 이름이 도메인에 있는지 여부를 확인하는 유틸리티 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ec277891051115eca19f87e67b309f58b25f882b" translate="yes" xml:space="preserve">
          <source>The valid-operation set</source>
          <target state="translated">유효한 작업 세트</target>
        </trans-unit>
        <trans-unit id="6da16c658a7a0e79e77c0c1ee20586931f71b8d4" translate="yes" xml:space="preserve">
          <source>The validity period consists of two date/time values: the first and last dates (and times) on which the certificate is valid. It is defined in ASN.1 as:</source>
          <target state="translated">유효 기간은 두 가지 날짜 / 시간 값으로 구성됩니다. 인증서가 유효한 첫 번째 날짜와 마지막 날짜 (및 시간). ASN.1에서 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9c29678c035dc87e004d700016db31124565f565" translate="yes" xml:space="preserve">
          <source>The value 0, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 0</target>
        </trans-unit>
        <trans-unit id="7ba5543468adcdfdcdc64230eac64e84fb598f9f" translate="yes" xml:space="preserve">
          <source>The value 1, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 1</target>
        </trans-unit>
        <trans-unit id="88131b97bd60cff8f031f2c61496c018172d0043" translate="yes" xml:space="preserve">
          <source>The value 10, with a scale of 0.</source>
          <target state="translated">스케일이 0 인 값 10</target>
        </trans-unit>
        <trans-unit id="2493c3149038a8c099fab7e9e4311ce1d4deb4f4" translate="yes" xml:space="preserve">
          <source>The value associated with the key must be a non-empty string. A provider satisfies this selection criterion iff the provider implements the specified algorithm or type for the specified cryptographic service and its implementation meets the constraint expressed by the specified attribute name/value pair.</source>
          <target state="translated">키와 연관된 값은 비어 있지 않은 문자열이어야합니다. 제공자는 지정된 암호화 서비스에 대해 지정된 알고리즘 또는 유형을 구현하고 해당 구현이 지정된 속성 이름 / 값 쌍으로 표시되는 제한 조건을 충족하는 경우이 선택 기준을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="391e2180db915adfa1b2cf6e71bfe20db996f02f" translate="yes" xml:space="preserve">
          <source>The value associated with the key must be an empty string.</source>
          <target state="translated">키와 연관된 값은 빈 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6a82fa77874feef436d7637c68a730afd2083" translate="yes" xml:space="preserve">
          <source>The value being monitored can be a simple value contained within a complex type. For example, the &lt;a href=&quot;../../../java/lang/management/memorymxbean&quot;&gt;&lt;code&gt;MemoryMXBean&lt;/code&gt;&lt;/a&gt; defined in &lt;code&gt;java.lang.management&lt;/code&gt; has an attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; of type &lt;a href=&quot;../../../java/lang/management/memoryusage&quot;&gt;&lt;code&gt;MemoryUsage&lt;/code&gt;&lt;/a&gt;. To monitor the amount of</source>
          <target state="translated">모니터링되는 값은 복합 유형에 포함 된 간단한 값일 수 있습니다. 예를 들어, &lt;code&gt;java.lang.management&lt;/code&gt; 에 정의 된 &lt;a href=&quot;../../../java/lang/management/memorymxbean&quot;&gt; &lt;code&gt;MemoryMXBean&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;../../../java/lang/management/memoryusage&quot;&gt; &lt;code&gt;MemoryUsage&lt;/code&gt; &lt;/a&gt; 유형의 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 속성이 있습니다. 의 양을 모니터링하려면</target>
        </trans-unit>
        <trans-unit id="79fbee1710c4e5fba3cf79c5bfcda285dfaed740" translate="yes" xml:space="preserve">
          <source>The value can be anything the server chooses to send. Its value is probably of interest only to the server. The cookie's value can be changed after creation with the &lt;code&gt;setValue&lt;/code&gt; method.</source>
          <target state="translated">값은 서버가 전송하도록 선택한 모든 것이 될 수 있습니다. 그 값은 아마도 서버에만 관심이 있습니다. 쿠키 값은 &lt;code&gt;setValue&lt;/code&gt; 메소드로 작성 후 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="translated">원래 키와 동일한 키로 &lt;code&gt;get&lt;/code&gt; 메소드를 호출하여 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b849d5ab1b9e466df1b5b353714d586423cc336" translate="yes" xml:space="preserve">
          <source>The value element MUST have the name of the code generator. The recommended convention is to use the fully qualified name of the code generator. For example: com.acme.generator.CodeGen.</source>
          <target state="translated">value 요소는 반드시 코드 생성기의 이름을 가져야합니다. 권장되는 규칙은 완전한 코드 생성기 이름을 사용하는 것입니다. 예를 들면 다음과 같습니다. com.acme.generator.CodeGen.</target>
        </trans-unit>
        <trans-unit id="92457a36cc7103fbd6b5d7894167b1422c935465" translate="yes" xml:space="preserve">
          <source>The value for the Domain attribute contains no embedded dots, and the value is not .local.</source>
          <target state="translated">Domain 속성 값에 포함 된 점이없고 값이 .local이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d5997f3b8a866c24134b984ca931d64c1fadf66" translate="yes" xml:space="preserve">
          <source>The value for the given parameter. Returns &lt;code&gt;null&lt;/code&gt; if no value is assigned to the key.</source>
          <target state="translated">주어진 매개 변수의 값입니다. 키에 값이 할당되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="42d264b983e7f353bc8ad5829d7a8cba44eb4f1c" translate="yes" xml:space="preserve">
          <source>The value for the specified key.</source>
          <target state="translated">지정된 키의 값</target>
        </trans-unit>
        <trans-unit id="16eb1ebbc57d65829c8ea71ba8f13bcf76d6b4be" translate="yes" xml:space="preserve">
          <source>The value is a sequence of 12 month lengths, for example: &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;</source>
          <target state="translated">값은 12 개월 길이의 시퀀스입니다 (예 : &quot;29 30 29 30 29 30 30 30 29 30 29 29&quot;).</target>
        </trans-unit>
        <trans-unit id="d4656bc7f215cf6f15fb76158e42016f85338cb8" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt;&lt;code&gt;SO_RCVBUF&lt;/code&gt;&lt;/a&gt; is also used to set the TCP receive window that is advertized to the remote peer. Generally, the window size can be modified at any time when a socket is connected. However, if a receive window larger than 64K is required then this must be requested &lt;b&gt;before&lt;/b&gt; the socket is connected to the remote peer. There are two cases to be aware of:</source>
          <target state="translated">&lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt; &lt;code&gt;SO_RCVBUF&lt;/code&gt; &lt;/a&gt; 의 값 은 또한 원격 피어에 알리는 TCP 수신 창을 설정하는 데 사용됩니다. 일반적으로 창 크기는 소켓이 연결될 때 언제든지 수정할 수 있습니다. 그러나 64K보다 큰 수신 창이 필요한 경우 소켓을 원격 피어에 연결 &lt;b&gt;하기 전에&lt;/b&gt; 요청해야합니다 . 알아야 할 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85d520eb7eadb3694e23d56197be67f17133e54" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt;&lt;code&gt;SO_RCVBUF&lt;/code&gt;&lt;/a&gt; is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer.</source>
          <target state="translated">&lt;a href=&quot;socketoptions#SO_RCVBUF&quot;&gt; &lt;code&gt;SO_RCVBUF&lt;/code&gt; &lt;/a&gt; 의 값은 내부 소켓 수신 버퍼의 크기를 설정하고 원격 피어에 알리는 TCP 수신 창의 크기를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47901eb75b98cda41165efa4708755552728c44a" translate="yes" xml:space="preserve">
          <source>The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">부동 소수점 합의 값은 입력 값과 덧셈 연산 순서 모두의 함수입니다. 이 방법의 추가 연산 순서는 계산 결과의 속도와 정확성을 향상시키기 위해 구현 유연성을 허용하도록 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현되어, &lt;code&gt;double&lt;/code&gt; 값 의 단순한 합산과 비교하여 수치 합의 오차 한계를 감소시킬 수있다 .</target>
        </trans-unit>
        <trans-unit id="257716e5f7261a724275793b4cede7634e4a94a2" translate="yes" xml:space="preserve">
          <source>The value of either the &lt;code&gt;engineScope&lt;/code&gt; or &lt;code&gt;globalScope&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;engineScope&lt;/code&gt; 또는 &lt;code&gt;globalScope&lt;/code&gt; 필드 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="cc44f2ec78c81b386a8c310e62b47b764873b9be" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;CODE&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;CODE&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="8ed71c2de4c7b018d8c2009db367a1d0adf781b3" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;NAME&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;NAME&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="33a0213d4d41d39ffcaba8745b73f4b11a491bc0" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;OBJECT&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;OBJECT&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="959bfb062f0baa61d452078c0860aff55768dad8" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;VERSION&lt;/code&gt; attribute of the &lt;code&gt;MLET&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;MLET&lt;/code&gt; 태그 의 &lt;code&gt;VERSION&lt;/code&gt; 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="f7db15370f7c34a2470defe5752a0b701343b9aa" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;initialSize&lt;/code&gt; parameter for the default group (see &lt;a href=&quot;asynchronouschannelgroup#withCachedThreadPool-java.util.concurrent.ExecutorService-int-&quot;&gt;&lt;code&gt;withCachedThreadPool&lt;/code&gt;&lt;/a&gt;). The value of the property is taken to be the &lt;code&gt;String&lt;/code&gt; representation of an &lt;code&gt;Integer&lt;/code&gt; that is the initial size parameter. If the value cannot be parsed as an &lt;code&gt;Integer&lt;/code&gt; it causes an unspecified error to be thrown during the construction of the default group.</source>
          <target state="translated">기본 그룹 의 &lt;code&gt;initialSize&lt;/code&gt; 매개 변수 값입니다 ( &lt;a href=&quot;asynchronouschannelgroup#withCachedThreadPool-java.util.concurrent.ExecutorService-int-&quot;&gt; &lt;code&gt;withCachedThreadPool&lt;/code&gt; &lt;/a&gt; 참조 ). 속성 값은 초기 크기 매개 변수 인 &lt;code&gt;Integer&lt;/code&gt; 의 &lt;code&gt;String&lt;/code&gt; 표현 으로 간주 됩니다. 값을 &lt;code&gt;Integer&lt;/code&gt; 로 구문 분석 할 수 없으면 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6dc8151f529dc33a68ca2fcf1cb579a5177476f4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;pos&lt;/code&gt; field at the time the last &lt;code&gt;mark&lt;/code&gt; method was called.</source>
          <target state="translated">마지막 &lt;code&gt;mark&lt;/code&gt; 메소드가 호출 된 시점 의 &lt;code&gt;pos&lt;/code&gt; 필드 값</target>
        </trans-unit>
        <trans-unit id="83b12208c67365cc9a87568927cbc140c553a51c" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값이 반환 된 문자열로부터 회수 될 수 &lt;code&gt;s&lt;/code&gt; 호출 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 16)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7c96fb72306b59eb6e27bbb68b4960125a44ad5" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea713c8dbe3bbb434d598cf92fbf26c0ccad22fb" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;integer#parseUnsignedInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseUnsignedInt(s, 8)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="002109f6f0e34deda860d2f8c13101257bd26010" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 16)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값이 반환 된 문자열로부터 회수 될 수 &lt;code&gt;s&lt;/code&gt; 호출 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 16)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8bd9a5106b83006a5daa1344bcf9fab6f821e2" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85fe9464ad74c5e36e8aac8096c9a27cbff3e7e2" translate="yes" xml:space="preserve">
          <source>The value of the argument can be recovered from the returned string &lt;code&gt;s&lt;/code&gt; by calling &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseUnsignedLong(s,
 8)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 값은 반환 된 문자열에서 복구 할 수 &lt;code&gt;s&lt;/code&gt; 호출에 의해 &lt;a href=&quot;long#parseUnsignedLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseUnsignedLong(s, 8)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92420401b1a66eb9d260a1d33bbda978b19012bf" translate="yes" xml:space="preserve">
          <source>The value of the attribute in the lowest scope for which an attribute with the given name is defined. Returns null if no attribute with the name exists in any scope.</source>
          <target state="translated">지정된 이름의 속성이 정의 된 가장 낮은 범위의 속성 값입니다. 이름을 가진 속성이 범위에 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3da50d92e176dc63b5da07ccab80504daf8a1e18" translate="yes" xml:space="preserve">
          <source>The value of the attribute retrieved.</source>
          <target state="translated">검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="92991f2b467a9dd9be161ffe7219ec382620ce83" translate="yes" xml:space="preserve">
          <source>The value of the attribute. May be null if the attribute is unknown.</source>
          <target state="translated">속성의 값 속성을 알 수없는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466e384c29b6463845ff35c548a12774880047a9" translate="yes" xml:space="preserve">
          <source>The value of the attribute. Returns &lt;code&gt;null&lt;/code&gt; is the name does not exist in the given scope.</source>
          <target state="translated">속성의 값 주어진 범위에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e49deabc177c53d0801c439c0df42c2b5ea401a4" translate="yes" xml:space="preserve">
          <source>The value of the field will be output during a format. If the value cannot be obtained then an exception will be thrown.</source>
          <target state="translated">필드 값은 포맷 중에 출력됩니다. 값을 얻을 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48e435e7bad97cf8759c8bed3884e0e05a6ca6c6" translate="yes" xml:space="preserve">
          <source>The value of the job's &lt;a href=&quot;jobholduntil&quot;&gt;&lt;code&gt;JobHoldUntil&lt;/code&gt;&lt;/a&gt; attribute was specified with a date-time that is still in the future. The job must not be a candidate for processing until this reason is removed and there are no other reasons to hold the job. This value should be supported if the &lt;a href=&quot;jobholduntil&quot;&gt;&lt;code&gt;JobHoldUntil&lt;/code&gt;&lt;/a&gt; job template attribute is supported.</source>
          <target state="translated">작업의 &lt;a href=&quot;jobholduntil&quot;&gt; &lt;code&gt;JobHoldUntil&lt;/code&gt; &lt;/a&gt; 속성 값 이 여전히 미래의 날짜-시간으로 지정되었습니다. 이 이유가 제거되고 작업을 보유 할 다른 이유가 없을 때까지 작업이 처리 후보가되어서는 안됩니다. &lt;a href=&quot;jobholduntil&quot;&gt; &lt;code&gt;JobHoldUntil&lt;/code&gt; &lt;/a&gt; 작업 템플리트 속성이 지원 되는 경우이 값이 지원되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9603d0dd485012e1f4fbb07ab95058c5884e0871" translate="yes" xml:space="preserve">
          <source>The value of the negotiated property. If null, the property was not negotiated or is not applicable to this mechanism.</source>
          <target state="translated">협상 된 속성의 값입니다. null 인 경우, 속성이 협상되지 않았거나이 메커니즘에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1375a6bafbe98e90e4d0729db426a82bac246c11" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; attribute ia STOPPED.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 속성 값은 STOPPED입니다.</target>
        </trans-unit>
        <trans-unit id="db78b0d3523e7732321ffc791c71a38c96846c14" translate="yes" xml:space="preserve">
          <source>The value of the printer's &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attribute contains a &lt;a href=&quot;printerstatereason&quot;&gt;&lt;code&gt;PrinterStateReason&lt;/code&gt;&lt;/a&gt; value of STOPPED_PARTLY.</source>
          <target state="translated">프린터의 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성 값 에는 &lt;a href=&quot;printerstatereason&quot;&gt; &lt;code&gt;PrinterStateReason&lt;/code&gt; &lt;/a&gt; 값 STOPPED_PARTLY가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e7acadd9356fd0eed465f05edbb22ae5050736f1" translate="yes" xml:space="preserve">
          <source>The value of the property, or null if there is no such property in this ObjectName.</source>
          <target state="translated">프로퍼티의 값.이 ObjectName에 그러한 프로퍼티이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="8e6b1a6d6df9caa879e4a52b4aef13f1d4aeeca5" translate="yes" xml:space="preserve">
          <source>The value of the property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c68b6061bfa99862e097c1bb571847be45f5a36" translate="yes" xml:space="preserve">
          <source>The value of the property. Primitive types such as &quot;int&quot; will be wrapped as the corresponding object type such as &quot;java.lang.Integer&quot;.</source>
          <target state="translated">속성 값 &quot;int&quot;와 같은 기본 유형은 &quot;java.lang.Integer&quot;와 같은 해당 오브젝트 유형으로 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ce8c1b4a0539cb032514fafac80fbdabadd594" translate="yes" xml:space="preserve">
          <source>The value of the protected &lt;code&gt;context&lt;/code&gt; field.</source>
          <target state="translated">보호 된 &lt;code&gt;context&lt;/code&gt; 필드 의 값</target>
        </trans-unit>
        <trans-unit id="a5c45270efc048e5f1b9cd9f6afbcaa1274b9a65" translate="yes" xml:space="preserve">
          <source>The value of the retrieved attribute from the descriptor 'value' field or from the invocation of the operation in the 'getMethod' field of the descriptor.</source>
          <target state="translated">디스크립터 'value'필드 또는 디스크립터의 'getMethod'필드에서 오퍼레이션 호출에서 검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="b348eeda39c4d1e3238a0258085bfeb71a22ed5d" translate="yes" xml:space="preserve">
          <source>The value of the retrieved attribute.</source>
          <target state="translated">검색된 속성의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2285df145b3c9ae26df5020d927db2f64460ec3" translate="yes" xml:space="preserve">
          <source>The value of the returned &lt;code&gt;BigDecimal&lt;/code&gt; is equal to</source>
          <target state="translated">리턴 값 &lt;code&gt;BigDecimal&lt;/code&gt; 와 같다</target>
        </trans-unit>
        <trans-unit id="535d078962378e613737dbb726452780163b4074" translate="yes" xml:space="preserve">
          <source>The value of the socket option. A value of &lt;code&gt;null&lt;/code&gt; may be a valid value for some socket options.</source>
          <target state="translated">소켓 옵션의 값입니다. 값 &lt;code&gt;null&lt;/code&gt; 는, 일부 소켓 옵션에 대한 유효한 값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d50cdb99a13d27827b534e10ac604af9967b5a1" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;cert.provider.x509v1&lt;/code&gt; property has to be changed to instantiate another implementation. If this security property is not set, a default implementation will be used. Currently, due to possible security restrictions on access to Security properties, this value is looked up and cached at class initialization time and will fallback on a default implementation if the Security property is not accessible.</source>
          <target state="translated">이 &lt;code&gt;cert.provider.x509v1&lt;/code&gt; 특성 의 값은 다른 구현을 인스턴스화하도록 변경되어야합니다. 이 보안 속성을 설정하지 않으면 기본 구현이 사용됩니다. 현재 보안 특성에 대한 액세스에 대한 보안 제한 사항으로 인해이 값은 클래스 초기화 시간에 조회 및 캐시되며 보안 특성에 액세스 할 수없는 경우 기본 구현에서 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="b60a5da34c192f58211cc46053f1f572c4bcdf56" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.applet&quot;.</source>
          <target state="translated">이 상수의 값은 &quot;java.naming.applet&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="70be25b63d854a9373d506112dfd3d18c4830bec" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.authoritative&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.authoritative&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b330540296e7168a688d0fb69bbfb34bf899dd2a" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.batchsize&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.batchsize&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f985e2167f0d965a15bc9d49973d2222a40eafb6" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.dns.url&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.dns.url&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="505f54502cd8d68ab0da6463ca38a0fec91385e7" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.control&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.control&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7151f0bb014c7a5ab1e3e977660775d91a8bd76c" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.initial&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.initial&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="db62ad09fcd4f30699d9b514e5ba9db02ab135dd" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.object&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.object&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e9295a43ecaf172542c1bc89cc562dadd505eb4e" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.state&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.state&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="72e77db2979cf3c5d5df8c1f312fdcb7e3cf0dd8" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.factory.url.pkgs&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.factory.url.pkgs&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c23367e5ddc754ace44be4965849c443f3d3cf88" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.language&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.language&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="debafaf87500101460cf58fe25d46bd025885114" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.provider.url&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.provider.url&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="89c2070cd88436218f7f16bf66cb4edf6ba490b2" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.referral&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.referral&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9cc48d1c5ca0afebb5ebfd310dd2dbd8487ff419" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.authentication&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.authentication&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4c0573f6efaba0c512fbcff0c36d7e5b791eae7f" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.credentials&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.credentials&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d87cc085dd14ae23c4bfcf35065e84615877a976" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.principal&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.principal&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="faea59681e2f4d68a14cc8e707a0f644a7fab244" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.security.protocol&quot;.</source>
          <target state="translated">이 정수의 값은 &quot;java.naming.security.protocol&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1eea6e7406196f98194d7dc4149b557304e5b765" translate="yes" xml:space="preserve">
          <source>The value of this constant is &quot;java.naming.spi.CannotProceedException&quot;.</source>
          <target state="translated">이 상수의 값은 &quot;java.naming.spi.CannotProceedException&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ca2029255b18ef7fc07dffc1f1d98d2c4a798dec" translate="yes" xml:space="preserve">
          <source>The value of this constant is 0.</source>
          <target state="translated">이 상수의 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9e4a7844333ec948b380e774556e82eb6fe0c6a9" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.bound.server.name&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.bound.server.name&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9f28810068395a3fbd50259cbc462fa2359430a" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.credentials&quot;&lt;/code&gt;.</source>
          <target state="translated">이 정수의 값은 &lt;code&gt;&quot;javax.security.sasl.credentials&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="470d84324d3f7fbd7bbb9ea4bcbc9b6b988c1568" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.maxbuffer&quot;&lt;/code&gt;.</source>
          <target state="translated">이 정수의 값은 &lt;code&gt;&quot;javax.security.sasl.maxbuffer&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31211a3383721cd0f9f3b326fde5e252995d83ce" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.credentials&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.credentials&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="959a445f01f7aad3ebc64b3b1f531a15a4e437ce" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.forward&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.forward&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e431aa384161ffc86b3e1453b5fb9e26219c7419" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noactive&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noactive&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a51b4b91f4b66398378907c088b0e7d664796c9" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noanonymous&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noanonymous&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0452024b914f4b0596371c42d90bfa7fba3f64b0" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.nodictionary&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.nodictionary&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa422d1fabd0c76c81a41c9fb85f540e36c02f2b" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.policy.noplaintext&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.policy.noplaintext&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ecd04d0142b9d176d5021d06e7368dededa7b0b" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.rawsendsize&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.rawsendsize&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ac4a332444a4793633faa0cd515cf9f64bef452" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;&quot;javax.security.sasl.server.authentication&quot;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.server.authentication&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03055235b2244f2e81fee5ab8a46b3ccf4c6c844" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5451c528917161e845b65a9600deb14a63245379" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1f15de420d3f3cb04487857617eafedff4b7f93" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ddb9709927414a9036f3f779734e11c829be7e35" translate="yes" xml:space="preserve">
          <source>The value of this constant is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbdd77c61d7d11ab57c8e33e4d6f179994662c3b" translate="yes" xml:space="preserve">
          <source>The value of this field can be accessed by the &lt;code&gt;getURL&lt;/code&gt; method.</source>
          <target state="translated">이 필드의 값은 &lt;code&gt;getURL&lt;/code&gt; 메소드 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fddbead7df76c109d78f7a8ca445c61cc40955f1" translate="yes" xml:space="preserve">
          <source>The value of this field can be set by the &lt;code&gt;setAllowUserInteraction&lt;/code&gt; method. Its value is returned by the &lt;code&gt;getAllowUserInteraction&lt;/code&gt; method. Its default value is the value of the argument in the last invocation of the &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; method.</source>
          <target state="translated">이 필드의 값은 &lt;code&gt;setAllowUserInteraction&lt;/code&gt; 메소드 로 설정할 수 있습니다 . 그 값은 &lt;code&gt;getAllowUserInteraction&lt;/code&gt; 메소드에 의해 리턴됩니다 . 기본값은 &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; 메소드 의 마지막 호출에서 인수의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4e9b5b9176900e2f7e73fa51e5d189eb641207bb" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.counter.threshold&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.counter.threshold&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="805bc0f84fb9bc3c7c29e277899cba9c75088a9e" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.attribute&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.attribute&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="8aae8963b9d0d4c118706ad729d8d7101e29ded5" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.mbean&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.mbean&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="96f76369ba45bc9c5be134158fd29b7c372302c9" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.runtime&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.error.runtime&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="aff36f8311add070b34ea295a25633a58a58c2a0" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.threshold&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.error.threshold&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ed9ee71b1f970d4866364bbcf548b29ac9080a87" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.error.type&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.error.type&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3d5fc439fac56d5a0fb765bacfd4d488c995be13" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.gauge.high&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.gauge.high&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="16b9f89192e3138677e5519341c20486c7c08f31" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.gauge.low&lt;/code&gt;.</source>
          <target state="translated">이 알림 유형의 값은 &lt;code&gt;jmx.monitor.gauge.low&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="07d0c2e7618db99121021ce2e78af95512f4d70e" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.string.differs&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.string.differs&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="99445c3c77b537173304b9ebd614ce3cc4025612" translate="yes" xml:space="preserve">
          <source>The value of this notification type is &lt;code&gt;jmx.monitor.string.matches&lt;/code&gt;.</source>
          <target state="translated">이 통지 유형의 값은 &lt;code&gt;jmx.monitor.string.matches&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ac0faf0ee35ba6f9fe8a29efe20b4f587e920230" translate="yes" xml:space="preserve">
          <source>The value of this property is taken to be the fully-qualified name of a concrete &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; class. The class is loaded using the system class loader and instantiated. The factory's &lt;a href=&quot;../../util/concurrent/threadfactory#newThread-java.lang.Runnable-&quot;&gt;&lt;code&gt;newThread&lt;/code&gt;&lt;/a&gt; method is invoked to create each thread for the default group's thread pool. If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.</source>
          <target state="translated">이 프로퍼티의 값은, 구체적인 &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt; 클래스 의 완전한 이름이 됩니다. 클래스는 시스템 클래스 로더를 사용하여로드되고 인스턴스화됩니다. 팩토리의 &lt;a href=&quot;../../util/concurrent/threadfactory#newThread-java.lang.Runnable-&quot;&gt; &lt;code&gt;newThread&lt;/code&gt; &lt;/a&gt; 메소드는 기본 그룹의 스레드 풀에 대한 각 스레드를 작성하기 위해 호출됩니다. 속성 값을로드하고 인스턴스화하는 프로세스가 실패하면 기본 그룹을 구성하는 동안 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="faedb6e636b2c0bf3f25486ce02c8a4b90b5e19e" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;a href=&quot;networkinterface&quot;&gt;&lt;code&gt;NetworkInterface&lt;/code&gt;&lt;/a&gt; that represents the outgoing interface for multicast datagrams sent by the datagram-oriented socket. For &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; sockets then it is system dependent whether setting this option also sets the outgoing interface for multicast datagrams sent to IPv4 addresses.</source>
          <target state="translated">이 소켓 옵션의 값은 데이터 그램 지향 소켓이 전송 한 멀티 캐스트 데이터 그램의 발신 인터페이스를 나타내는 &lt;a href=&quot;networkinterface&quot;&gt; &lt;code&gt;NetworkInterface&lt;/code&gt; &lt;/a&gt; 입니다. 대한 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓 다음이 옵션을 설정하면 또한 IPv4 주소로 전송 멀티 캐스트 데이터 그램에 대한 나가는 인터페이스를 설정할지 여부를 의존하는 시스템이다.</target>
        </trans-unit>
        <trans-unit id="52d41017b39ecaa0454385d328f3b6bd932b4bc4" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that controls the &lt;em&gt;loopback&lt;/em&gt; of multicast datagrams. The value of the socket option represents if the option is enabled or disabled.</source>
          <target state="translated">이 소켓 옵션의 값은 멀티 캐스트 데이터 그램 의 &lt;em&gt;루프백&lt;/em&gt; 을 제어 하는 &lt;code&gt;Boolean&lt;/code&gt; 입니다 . 소켓 옵션의 값은 옵션의 활성화 여부를 나타냅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0782095e27c4f63c26addb4f4b586af5276685e2" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The exact semantics of this socket option are socket type and system dependent.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 활성화 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 이 소켓 옵션의 정확한 의미는 소켓 유형 및 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c799a28ae4a75daf519e682a26de2c11c010df2a" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The option is specific to datagram-oriented sockets sending to &lt;a href=&quot;inet4address&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; broadcast addresses. When the socket option is enabled then the socket can be used to send &lt;em&gt;broadcast datagrams&lt;/em&gt;.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 활성화 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 이 옵션은 &lt;a href=&quot;inet4address&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 브로드 캐스트 주소로 보내는 데이터 그램 지향 소켓에만 해당됩니다 . 소켓 옵션이 활성화되면 소켓을 사용하여 &lt;em&gt;브로드 캐스트 데이터 그램&lt;/em&gt; 을 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="378a8b74d2abd11578002c1e83ca787b93b99699" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. The socket option is specific to stream-oriented sockets using the TCP/IP protocol. TCP/IP uses an algorithm known as &lt;em&gt;The Nagle Algorithm&lt;/em&gt; to coalesce short segments and improve network efficiency.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 활성화 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 소켓 옵션은 TCP / IP 프로토콜을 사용하는 스트림 지향 소켓에 따라 다릅니다. TCP / IP는 &lt;em&gt;Nagle 알고리즘&lt;/em&gt; 이라는 알고리즘을 사용하여 짧은 세그먼트를 통합하고 네트워크 효율성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="f111eca53be5c4a77e641dab1abf0b374fefe83a" translate="yes" xml:space="preserve">
          <source>The value of this socket option is a &lt;code&gt;Boolean&lt;/code&gt; that represents whether the option is enabled or disabled. When the &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; option is enabled the operating system may use a &lt;em&gt;keep-alive&lt;/em&gt; mechanism to periodically probe the other end of a connection when the connection is otherwise idle. The exact semantics of the keep alive mechanism is system dependent and therefore unspecified.</source>
          <target state="translated">이 소켓 옵션의 값은 옵션의 활성화 여부를 나타내는 &lt;code&gt;Boolean&lt;/code&gt; 입니다. 때 &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; 옵션은 운영 체제가 사용할 수 있습니다 사용할 수 있습니다 &lt;em&gt;연결 유지&lt;/em&gt; 주기적으로 연결의 다른 쪽 끝을 조사하는기구를 연결이 유휴 상태 일 때. 연결 유지 메커니즘의 정확한 의미는 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ff8b71c0be896401e7f25bf544169440736d7ac" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; in the range &lt;code&gt;0 &amp;lt;= value &amp;lt;= 255&lt;/code&gt;. It is used to control the scope of multicast datagrams sent by the datagram-oriented socket. In the case of an &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket the option is the time-to-live (TTL) on multicast datagrams sent by the socket. Datagrams with a TTL of zero are not transmitted on the network but may be delivered locally. In the case of an &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket the option is the &lt;em&gt;hop limit&lt;/em&gt; which is number of &lt;em&gt;hops&lt;/em&gt; that the datagram can pass through before expiring on the network. For IPv6 sockets it is system dependent whether the option also sets the &lt;em&gt;time-to-live&lt;/em&gt; on multicast datagrams sent to IPv4 addresses.</source>
          <target state="translated">이 소켓 옵션의 값은 &lt;code&gt;0 &amp;lt;= value &amp;lt;= 255&lt;/code&gt; 범위 의 &lt;code&gt;Integer&lt;/code&gt; 입니다 . 데이터 그램 지향 소켓에 의해 전송 된 멀티 캐스트 데이터 그램의 범위를 제어하는 ​​데 사용됩니다. 의 경우 &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; 의&lt;/a&gt; 옵션이 소켓에서 보낸 멀티 캐스트 데이터 그램의 시간 (TTL)이다 소켓. TTL이 0 인 데이터 그램은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다. 의 경우 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; 의&lt;/a&gt; 옵션이있다 소켓 &lt;em&gt;홉 제한&lt;/em&gt; 의 수입니다 &lt;em&gt;홉&lt;/em&gt; 데이터 그램이 네트워크에 만료되기 전에 통과 할 수있는가. IPv6 소켓의 경우, 옵션 이 IPv4 주소로 전송 된 멀티 캐스트 데이터 그램에서 &lt;em&gt;수명&lt;/em&gt; 을 설정하는지 여부는 시스템에 따라 다릅니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0aaeb374d470c89144bd7d473179b01228a3931" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; representing the value of the ToS octet in IP packets sent by sockets to an &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket. The interpretation of the ToS octet is network specific and is not defined by this class. Further information on the ToS octet can be found in &lt;a href=&quot;http://www.ietf.org/rfc/rfc1349.txt&quot;&gt;RFC 1349&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2474.txt&quot;&gt;RFC 2474&lt;/a&gt;. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt;. An implementation may ignore the value, or ignore specific values.</source>
          <target state="translated">이 소켓 옵션 의 값은 소켓에서 &lt;a href=&quot;standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 소켓으로 보낸 IP 패킷의 ToS 옥텟 값을 나타내는 &lt;code&gt;Integer&lt;/code&gt; 입니다. ToS 옥텟의 해석은 네트워크에 따라 다르며이 클래스에 의해 정의되지 않습니다. ToS 옥텟에 대한 추가 정보는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1349.txt&quot;&gt;RFC 1349&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2474.txt&quot;&gt;RFC 2474&lt;/a&gt; 에서 찾을 수 있습니다 . 소켓 옵션의 값은 &lt;em&gt;힌트&lt;/em&gt; 입니다. 구현시 값을 무시하거나 특정 값을 무시할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9f336d96465d1b5cce00d70fe23ba02abe6c752" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that controls the action taken when unsent data is queued on the socket and a method to close the socket is invoked. If the value of the socket option is zero or greater, then it represents a timeout value, in seconds, known as the &lt;em&gt;linger interval&lt;/em&gt;. The linger interval is the timeout for the &lt;code&gt;close&lt;/code&gt; method to block while the operating system attempts to transmit the unsent data or it decides that it is unable to transmit the data. If the value of the socket option is less than zero then the option is disabled. In that case the &lt;code&gt;close&lt;/code&gt; method does not wait until unsent data is transmitted; if possible the operating system will transmit any unsent data before the connection is closed.</source>
          <target state="translated">이 소켓 옵션의 값은 보내지 않은 데이터가 소켓에 대기하고 소켓을 닫는 메소드가 호출 될 때 수행되는 조치를 제어 하는 &lt;code&gt;Integer&lt;/code&gt; 입니다. socket 옵션의 값이 0 이상인 경우, 시간 초과 값을 초 단위로 표시합니다 ( &lt;em&gt;링거 간격)&lt;/em&gt; . 느린 간격은 운영 체제가 보내지 않은 데이터를 전송하려고 시도하거나 데이터를 전송할 수없는 것으로 결정하는 동안 &lt;code&gt;close&lt;/code&gt; 메서드가 차단되는 시간 초과입니다 . socket 옵션의 값이 0보다 작 으면 옵션이 비활성화됩니다. 이 경우 &lt;code&gt;close&lt;/code&gt; 메소드는 전송되지 않은 데이터가 전송 될 때까지 기다리지 않습니다. 가능하면 운영 체제는 연결을 닫기 전에 보내지 않은 데이터를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="aa78f370acd97919109586e7fab1f967828d0cb4" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that is the size of the socket receive buffer in bytes. The socket receive buffer is an input buffer used by the networking implementation. It may need to be increased for high-volume connections or decreased to limit the possible backlog of incoming data. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual size may differ.</source>
          <target state="translated">이 소켓 옵션의 값은 소켓 수신 버퍼의 크기 (바이트 ) 인 &lt;code&gt;Integer&lt;/code&gt; 입니다. 소켓 수신 버퍼는 네트워킹 구현에서 사용되는 입력 버퍼입니다. 대량 연결의 경우 증가하거나 들어오는 데이터의 백 로그를 제한하기 위해 감소해야 할 수도 있습니다. 소켓 옵션의 값은 버퍼 크기를 조정하는 구현에 대한 &lt;em&gt;힌트&lt;/em&gt; 이며 실제 크기는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3964a21153626d6dca5ee91d3e140a157ee18420" translate="yes" xml:space="preserve">
          <source>The value of this socket option is an &lt;code&gt;Integer&lt;/code&gt; that is the size of the socket send buffer in bytes. The socket send buffer is an output buffer used by the networking implementation. It may need to be increased for high-volume connections. The value of the socket option is a &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual size may differ. The socket option can be queried to retrieve the actual size.</source>
          <target state="translated">이 소켓 옵션의 값은 소켓 송신 버퍼의 크기 (바이트 ) 인 &lt;code&gt;Integer&lt;/code&gt; 입니다. 소켓 송신 버퍼는 네트워킹 구현에서 사용되는 출력 버퍼입니다. 대용량 연결의 경우이 값을 늘려야 할 수 있습니다. 소켓 옵션의 값은 버퍼 크기를 조정하는 구현에 대한 &lt;em&gt;힌트&lt;/em&gt; 이며 실제 크기는 다를 수 있습니다. 실제 크기를 검색하기 위해 소켓 옵션을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e29e94ffa50d1811c8c377fed262ac17b18615" translate="yes" xml:space="preserve">
          <source>The value of this type string is &lt;code&gt;jmx.attribute.change&lt;/code&gt;.</source>
          <target state="translated">이 유형 문자열의 값은 &lt;code&gt;jmx.attribute.change&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eae86827f3a1e6e6b1a2cc87015f797db0fbc402" translate="yes" xml:space="preserve">
          <source>The value passed in is converted to a byte, which may lose information.</source>
          <target state="translated">전달 된 값은 바이트로 변환되어 정보가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b9d68f8861a0f3a1d298ab379faa4e96b2ee1c" translate="yes" xml:space="preserve">
          <source>The value previously associated with the given name. Returns null if no value was previously associated with the name.</source>
          <target state="translated">주어진 이름과 이전에 연결된 값입니다. 이전에 이름과 연결된 값이 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="193e10e740caf76fa19a1f3cbe75690884cfc899" translate="yes" xml:space="preserve">
          <source>The value property of an &lt;code&gt;Expression&lt;/code&gt; is set to a unique private (non-&lt;code&gt;null&lt;/code&gt;) value by default and this value is used as an internal indication that the method has not yet been called. A return value of &lt;code&gt;null&lt;/code&gt; replaces this default value in the same way that any other value would, ensuring that expressions are never evaluated more than once.</source>
          <target state="translated">&lt;code&gt;Expression&lt;/code&gt; 의 value 속성은 기본적으로 고유 한 private ( &lt;code&gt;null&lt;/code&gt; 이 아닌 ) 값으로 설정 되며이 값은 메서드가 아직 호출되지 않았 음을 나타내는 내부 표시로 사용됩니다. &lt;code&gt;null&lt;/code&gt; 값을 반환 하면 다른 모든 값과 동일한 방식으로이 기본값이 바뀌므로식이 두 번 이상 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31f5093977dcc1cdd4697dab36dd10971db541b7" translate="yes" xml:space="preserve">
          <source>The value represented by the string is larger than the largest unsigned &lt;code&gt;int&lt;/code&gt;, 2&lt;sup&gt;32&lt;/sup&gt;-1.</source>
          <target state="translated">문자열로 표시되는 값이 가장 큰 부호없는 &lt;code&gt;int&lt;/code&gt; 2 &lt;sup&gt;32&lt;/sup&gt; -1 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="d6f78b1ec9763b41e7fb9ba7f86d098e20d6f9a2" translate="yes" xml:space="preserve">
          <source>The value represented by the string is larger than the largest unsigned &lt;code&gt;long&lt;/code&gt;, 2&lt;sup&gt;64&lt;/sup&gt;-1.</source>
          <target state="translated">문자열로 표시되는 값이 가장 큰 부호없는 &lt;code&gt;long&lt;/code&gt; , 2 &lt;sup&gt;64&lt;/sup&gt; -1 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="7ec8c505fdb637aca2b4b00c43e241fdc3c70c56" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;byte&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2dd516c49699030c6a86876fa65104bf2bacc9c3" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;int&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="080e00aed4fe6d75b4b9f01ff131e35f0a26ccd4" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값은 &lt;code&gt;long&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="dd537294351459ff10862aaa7bdcdb05b16e77a1" translate="yes" xml:space="preserve">
          <source>The value represented by the string is not a value of type &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">문자열로 표시되는 값이 &lt;code&gt;short&lt;/code&gt; 유형의 값이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5e116924436bf7c8d4007129887075eebdca3586" translate="yes" xml:space="preserve">
          <source>The value returned by the procedure or function</source>
          <target state="translated">프로 시저 또는 함수가 리턴 한 값</target>
        </trans-unit>
        <trans-unit id="a4624000eb901432b19900a8426561fff4b2b375" translate="yes" xml:space="preserve">
          <source>The value returned by the procedure. The rules for converting the scripting variable returned by the script method to a Java Object are implementation-specific.</source>
          <target state="translated">프로 시저가 리턴 한 값. 스크립트 메소드가 리턴 한 스크립팅 변수를 Java 오브젝트로 변환하는 규칙은 구현마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67e56c1928fd73288739bc1a971b0ef8da9c3a99" translate="yes" xml:space="preserve">
          <source>The value returned by the script execution, if any. Should return &lt;code&gt;null&lt;/code&gt; if no value is returned by the script execution.</source>
          <target state="translated">스크립트 실행에 의해 반환되는 값입니다 (있는 경우). 스크립트 실행에서 값이 반환되지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="110307d8995a99466a52bbbf0e1fd931923962c2" translate="yes" xml:space="preserve">
          <source>The value returned by the script.</source>
          <target state="translated">스크립트가 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="232a4c3688c018a1f715de261ad24f1b8ccdde7a" translate="yes" xml:space="preserve">
          <source>The value returned by this method is equal to the value that would be returned by &lt;code&gt;Arrays.asList(a).hashCode()&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, in which case &lt;code&gt;0&lt;/code&gt; is returned.</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 값은 , &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 가 아닌 한 , &lt;code&gt;0&lt;/code&gt; 이 돌려 &lt;code&gt;Arrays.asList(a).hashCode()&lt;/code&gt; 지지 않는 한 , Arrays.asList (a) .hashCode ()에 의해 돌려 주어지는 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4830ed24165ee75d854121d512ff4c6287d16823" translate="yes" xml:space="preserve">
          <source>The value returned by this method is equal to the value that would be returned by &lt;code&gt;Arrays.asList(a).toString()&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, in which case &lt;code&gt;&quot;null&quot;&lt;/code&gt; is returned.</source>
          <target state="translated">이 방법에 의해 리턴되는 값에 의해 반환되는 값과 동일 &lt;code&gt;Arrays.asList(a).toString()&lt;/code&gt; 않으면, &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 되는 경우, &lt;code&gt;&quot;null&quot;&lt;/code&gt; 복귀된다.</target>
        </trans-unit>
        <trans-unit id="497f48c5d27b5d369d6b9d0a0e986992c79396f5" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 값 은 같은 순서 로 &lt;code&gt;a&lt;/code&gt; 의 요소를 나타내는 일련의 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 인스턴스를 포함한 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; 로&lt;/a&gt;&lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출했을 때와 같은 값입니다 . 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d9dbfc6d6211692de527549b2fcd5858a66bb72" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/byte&quot;&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/byte&quot;&gt; &lt;code&gt;Byte&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61e555fbf6ad7db5b6071c0b6b9e1c1677c17310" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="202f92c2c1f2690fa3631974cac693f1c7bc62a6" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c915104330624d5c65626efa3aeedf957b1ba02" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; 의 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6086d722cb980f02f1d9be10f9049cb0b95e719" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c957e2b334ef39fa0169c9d7f5a824127ab492" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="630057fa5af0e23dd224c2a30f87a15dcf29fe3f" translate="yes" xml:space="preserve">
          <source>The value returned by this method is the same value that would be obtained by invoking the &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; containing a sequence of &lt;a href=&quot;../lang/short&quot;&gt;&lt;code&gt;Short&lt;/code&gt;&lt;/a&gt; instances representing the elements of &lt;code&gt;a&lt;/code&gt; in the same order. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 값이 호출에 의해 얻어진 것 같은 값 &lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;&lt;code&gt;hashCode&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; A의 방법을 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 서열 함유 &lt;a href=&quot;../lang/short&quot;&gt; &lt;code&gt;Short&lt;/code&gt; &lt;/a&gt; 요소를 나타내는 경우 동일한 순서로한다. 경우 &lt;code&gt;a&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 메소드는 0을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3446146db6ab390bdd9c3f968d4d845281bdb3a" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script.</source>
          <target state="translated">스크립트 실행에서 반환 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="55349d45b1798417fa58a2e4c3952f10780b9ff0" translate="yes" xml:space="preserve">
          <source>The value returned is &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;, which is the number of bytes remaining to be read from the input buffer.</source>
          <target state="translated">리턴 된 값은 &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt; . 이는 입력 버퍼에서 읽을 나머지 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2036e23bfa2dc5e8d0a1aee47cc9e89872df1136" translate="yes" xml:space="preserve">
          <source>The value returned is a two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;, where &lt;em&gt;m&lt;/em&gt; is at least 5. Each of the &lt;em&gt;n&lt;/em&gt; rows is an entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;. Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from 0..&lt;em&gt;n&lt;/em&gt;-1):</source>
          <target state="translated">반환 된 값은 크기가 &lt;em&gt;n&lt;/em&gt; x &lt;em&gt;m&lt;/em&gt; 인 2 차원 문자열 배열이며 , 여기서 &lt;em&gt;m&lt;/em&gt; 은 5 이상입니다. 각 &lt;em&gt;n&lt;/em&gt; 행은 단일 &lt;code&gt;TimeZone&lt;/code&gt; 의 현지화 된 이름을 포함하는 항목 입니다. 이러한 각 행에는 다음이 포함됩니다 ( &lt;code&gt;i&lt;/code&gt; 범위는 0 .. &lt;em&gt;n&lt;/em&gt; -1 임).</target>
        </trans-unit>
        <trans-unit id="03c9efb8c5db2500c4c240fcd8666dee938e1da7" translate="yes" xml:space="preserve">
          <source>The value returned is only an estimate because the number of thread groups may change dynamically while this method traverses internal data structures. This method is intended primarily for debugging and monitoring purposes.</source>
          <target state="translated">이 메소드가 내부 데이터 구조를 통과하는 동안 스레드 그룹의 수가 동적으로 변경 될 수 있으므로 리턴 된 값은 추정치입니다. 이 방법은 주로 디버깅 및 모니터링 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="852cc356c26f432ab42fcc161a95ca76132880ee" translate="yes" xml:space="preserve">
          <source>The value returned is only an estimate because the number of threads may change dynamically while this method traverses internal data structures, and might be affected by the presence of certain system threads. This method is intended primarily for debugging and monitoring purposes.</source>
          <target state="translated">리턴 된 값은이 메소드가 내부 데이터 구조를 순회하는 동안 스레드 수가 동적으로 변경 될 수 있고 특정 시스템 스레드의 존재에 영향을받을 수 있으므로 추정치 일뿐입니다. 이 방법은 주로 디버깅 및 모니터링 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b84a0253c5b3c6f11eea15293b58032f1c52ac87" translate="yes" xml:space="preserve">
          <source>The value specified is not valid for the attribute.</source>
          <target state="translated">지정된 값이 속성에 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="500cac38ba0a7780ed53053b9886791f008d3156" translate="yes" xml:space="preserve">
          <source>The value will be printed as per the normal format of an integer value. Only negative numbers will be signed. No padding will be added.</source>
          <target state="translated">정수 값의 일반 형식에 따라 값이 인쇄됩니다. 음수 만 서명됩니다. 패딩이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6acd3ee9804ea2240ae60fd89170c2a1ca81d0" translate="yes" xml:space="preserve">
          <source>The value will be zero-padded on the left. If the size of the value means that it cannot be printed within the width then an exception is thrown. If the value of the field is negative then an exception is thrown during formatting.</source>
          <target state="translated">왼쪽에 값이 0으로 채워집니다. 값의 크기가 너비 내에서 인쇄 할 수 없음을 의미하면 예외가 발생합니다. 필드 값이 음수이면 서식 지정 중에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="031c945b382d2bfa8a375b39b12c9b937e2dbd2c" translate="yes" xml:space="preserve">
          <source>The values are equal.</source>
          <target state="translated">값이 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c207ea95e8a56f3038b875f5e458580dce26ff8" translate="yes" xml:space="preserve">
          <source>The values are key/value pairs of two types. The first type of pairs consists of those whose keys are reserved and defined in this specification or by individual implementations. The values in the pairs with reserved keys have specified meanings.</source>
          <target state="translated">값은 두 가지 유형의 키 / 값 쌍입니다. 첫 번째 유형의 쌍은 키가이 사양에서 예약되고 정의 된 개별 구성 또는 개별 구현으로 구성됩니다. 예약 된 키가있는 쌍의 값에는 지정된 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36e9ac0d41a47dcc5adf02d33d70256195d6bc3" translate="yes" xml:space="preserve">
          <source>The values are numbered following the ISO-8601 standard, from 1 (January) to 12 (December).</source>
          <target state="translated">값은 ISO-8601 표준에 따라 1 (1 월)에서 12 (12 월)까지 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="2f7227c6c87280051d32783be85f72f98db78fec" translate="yes" xml:space="preserve">
          <source>The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday). See &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week-numbering.</source>
          <target state="translated">값은 ISO-8601 표준에 따라 1 (월요일)에서 7 (일요일)까지 번호가 매겨집니다. 현지화 된 주 번호 매기기에 대해서는 &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="103d4a4344917ad71ffdead36a1faff6de82ef17" translate="yes" xml:space="preserve">
          <source>The values for an attribute are immutable, or must not be mutated by clients or storage. They are always passed by reference, and not cloned.</source>
          <target state="translated">속성 값은 변경 불가능하거나 클라이언트 나 스토리지에서 변경해서는 안됩니다. 그것들은 항상 참조로 전달되며 복제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e249ae9bc2f78685ef11b72e309449abc9a2d7e" translate="yes" xml:space="preserve">
          <source>The values for these keys are the Strings returned by &lt;code&gt;getEngineName&lt;/code&gt;, &lt;code&gt;getEngineVersion&lt;/code&gt;, &lt;code&gt;getLanguageName&lt;/code&gt;, &lt;code&gt;getLanguageVersion&lt;/code&gt; for the first four keys respectively. For NAME, one of the Strings returned by &lt;code&gt;getNames&lt;/code&gt; is returned.</source>
          <target state="translated">이 키의 값은 각각 처음 네 개의 키에 대해 &lt;code&gt;getEngineName&lt;/code&gt; , &lt;code&gt;getEngineVersion&lt;/code&gt; , &lt;code&gt;getLanguageName&lt;/code&gt; , &lt;code&gt;getLanguageVersion&lt;/code&gt; 에 의해 리턴되는 문자열 입니다. NAME의 경우 &lt;code&gt;getNames&lt;/code&gt; 에서 리턴 한 문자열 중 하나 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ed1518f76cd5c7850d1ed62e39ed9fbf6f653dda" translate="yes" xml:space="preserve">
          <source>The values of cipherSuites, protocols, cryptographic algorithm constraints, endpoint identification algorithm, server names and server name matchers are set to &lt;code&gt;null&lt;/code&gt;, useCipherSuitesOrder, wantClientAuth and needClientAuth are set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">cipherSuites, 프로토콜, 암호화 알고리즘 제한 조건, 엔드 포인트 식별 알고리즘, 서버 이름 및 서버 이름 매처의 값이 &lt;code&gt;null&lt;/code&gt; 설정되고 useCipherSuitesOrder, wantClientAuth 및 needClientAuth가 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="01f68b856f41bbdd549e5ce9ce35a7c9be9bec94" translate="yes" xml:space="preserve">
          <source>The values of other calendar fields may be taken into account to determine a set of display names. For example, if this &lt;code&gt;Calendar&lt;/code&gt; is a lunisolar calendar system and the year value given by the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; field has a leap month, this method would return month names containing the leap month name, and month names are mapped to their values specific for the year.</source>
          <target state="translated">다른 캘린더 필드의 값을 고려하여 일련의 표시 이름을 결정할 수 있습니다. 예를 들어,이 &lt;code&gt;Calendar&lt;/code&gt; 이 음력 달력 시스템이고 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 필드에서 제공 한 연도 값 에 윤월이있는 경우이 방법은 윤월 이름을 포함하는 월 이름을 반환하고 월 이름은 해당 연도에 해당하는 값에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="465f58c72b3a6f0d702e1f81a258c44981222924" translate="yes" xml:space="preserve">
          <source>The values returned by this method become meaningful only when the difference between two such values, obtained within the same instance of a Java virtual machine, is computed.</source>
          <target state="translated">이 메소드에 의해 리턴 된 값은 Java 가상 머신의 동일한 인스턴스 내에서 얻은 두 값 간의 차이가 계산 될 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd18fd2ae18c7b303b9ff07577197ac1e8f395b" translate="yes" xml:space="preserve">
          <source>The variable arity parameter has a reifiable element type, which includes primitive types, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;String&lt;/code&gt;. (The unchecked warnings this annotation type suppresses already do not occur for a reifiable element type.)</source>
          <target state="translated">변수 arity 매개 변수에는 기본 유형, &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 을 포함하는 수정 가능한 요소 유형이 있습니다 . (이 주석 유형이 억제하는 확인되지 않은 경고는 수정 가능한 요소 유형에 대해 이미 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="3d3705f4b80513e86c1fef983b33a0e581672d50" translate="yes" xml:space="preserve">
          <source>The variant code, or the empty string if none is defined.</source>
          <target state="translated">변형 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="e1f53b3a3ade84d5fdc041ae16475767cdbbf2af" translate="yes" xml:space="preserve">
          <source>The variant field contains a value which identifies the layout of the &lt;code&gt;UUID&lt;/code&gt;. The bit layout described above is valid only for a &lt;code&gt;UUID&lt;/code&gt; with a variant value of 2, which indicates the Leach-Salz variant.</source>
          <target state="translated">variant 필드에는 &lt;code&gt;UUID&lt;/code&gt; 의 레이아웃을 식별하는 값이 포함 됩니다 . 위에서 설명한 비트 레이아웃 은 변형 값이 2 인 &lt;code&gt;UUID&lt;/code&gt; 에만 유효하며 이는 Leach-Salz 변형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ff76ceb354bc3cf76d2cc94fa0c1aadbaba32d0" translate="yes" xml:space="preserve">
          <source>The variant number associated with this &lt;code&gt;UUID&lt;/code&gt;. The variant number describes the layout of the &lt;code&gt;UUID&lt;/code&gt;. The variant number has the following meaning:</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 변형 번호 입니다. 변형 번호는 &lt;code&gt;UUID&lt;/code&gt; 의 레이아웃을 설명합니다 . 변형 번호는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0759d3d03dbf7321713ed34def228b0638c5dab2" translate="yes" xml:space="preserve">
          <source>The variant number of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 변형 번호</target>
        </trans-unit>
        <trans-unit id="4f651a70a37a4814efdb6f28d7a64f3a1d099f21" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;next&lt;/code&gt;methods of &lt;code&gt;Scanner&lt;/code&gt; make a match result available if they complete without throwing an exception. For instance, after an invocation of the &lt;a href=&quot;scanner#nextInt--&quot;&gt;&lt;code&gt;nextInt()&lt;/code&gt;&lt;/a&gt; method that returned an int, this method returns a &lt;code&gt;MatchResult&lt;/code&gt; for the search of the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above. Similarly the &lt;a href=&quot;scanner#findInLine-java.lang.String-&quot;&gt;&lt;code&gt;findInLine(java.lang.String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;scanner#findWithinHorizon-java.lang.String-int-&quot;&gt;&lt;code&gt;findWithinHorizon(java.lang.String, int)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;scanner#skip-java.util.regex.Pattern-&quot;&gt;&lt;code&gt;skip(java.util.regex.Pattern)&lt;/code&gt;&lt;/a&gt; methods will make a match available if they succeed.</source>
          <target state="translated">&lt;code&gt;Scanner&lt;/code&gt; 의 다양한 &lt;code&gt;next&lt;/code&gt; 방법은 예외를 발생시키지 않고 완료되면 일치 결과를 사용할 수있게합니다. 예를 들어, int를 반환 한 &lt;a href=&quot;scanner#nextInt--&quot;&gt; &lt;code&gt;nextInt()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 &lt;code&gt;MatchResult&lt;/code&gt; 메서드는 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식을 검색하기 위해 MatchResult 를 반환합니다 . 마찬가지로 &lt;a href=&quot;scanner#findInLine-java.lang.String-&quot;&gt; &lt;code&gt;findInLine(java.lang.String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;scanner#findWithinHorizon-java.lang.String-int-&quot;&gt; &lt;code&gt;findWithinHorizon(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;scanner#skip-java.util.regex.Pattern-&quot;&gt; &lt;code&gt;skip(java.util.regex.Pattern)&lt;/code&gt; &lt;/a&gt; 메소드는 성공하면 일치하는 항목을 작성합니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1180351e5247e4780b4dc25a40f38943b4896262" translate="yes" xml:space="preserve">
          <source>The vector is empty if there is no timer notification registered for this timer MBean.</source>
          <target state="translated">이 타이머 MBean에 등록 된 타이머 통지가없는 경우는 벡터는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e2d6864ec2b83e2c1a64a7dd7faed626bbda83" translate="yes" xml:space="preserve">
          <source>The vector is empty if there is no timer notifications registered for this timer MBean with the specified &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;type&lt;/code&gt; 으로이 타이머 MBean에 등록 된 타이머 통지가없는 경우는 벡터는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="58462e7fd48bf8ac3b31199fbf9a449a7280a048" translate="yes" xml:space="preserve">
          <source>The vendor might supply the following &lt;code&gt;ChangeIDControl&lt;/code&gt; and &lt;code&gt;VendorXControlFactory&lt;/code&gt; classes. The &lt;code&gt;VendorXControlFactory&lt;/code&gt; will be used by the service provider when the provider receives response controls from the LDAP server.</source>
          <target state="translated">공급 업체는 다음 &lt;code&gt;ChangeIDControl&lt;/code&gt; 및 &lt;code&gt;VendorXControlFactory&lt;/code&gt; 클래스를 제공 할 수 있습니다. &lt;code&gt;VendorXControlFactory&lt;/code&gt; 를이 공급자가 LDAP 서버로부터 응답 컨트롤을 수신 서비스 제공자에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92b9d2715811e51e997d7d4ca0742429f1579adf" translate="yes" xml:space="preserve">
          <source>The version field holds a value that describes the type of this &lt;code&gt;UUID&lt;/code&gt;. There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively.</source>
          <target state="translated">버전 필드에는이 &lt;code&gt;UUID&lt;/code&gt; 유형을 설명하는 값이 있습니다. UUID에는 시간 기반, DCE 보안, 이름 기반 및 무작위로 생성 된 UUID의 네 가지 기본 유형이 있습니다. 이러한 유형의 버전 값은 각각 1, 2, 3 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="05fd679ec54a555aaf6a087d093ec8e9634ec69d" translate="yes" xml:space="preserve">
          <source>The version number associated with this &lt;code&gt;UUID&lt;/code&gt;. The version number describes how this &lt;code&gt;UUID&lt;/code&gt; was generated. The version number has the following meaning:</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 와 관련된 버전 번호 입니다. 버전 번호는이 &lt;code&gt;UUID&lt;/code&gt; 생성 방법을 설명합니다 . 버전 번호는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6cff03f566dfbcc1da388f423a088498b0bfb75e" translate="yes" xml:space="preserve">
          <source>The version number of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 버전 번호</target>
        </trans-unit>
        <trans-unit id="f960447e30249f093071e1177d67cf04bcbfa430" translate="yes" xml:space="preserve">
          <source>The version of the Hijrah variant data</source>
          <target state="translated">Hijrah 변형 데이터의 버전</target>
        </trans-unit>
        <trans-unit id="cf8368aa8f5f9b58b1196c5b1361941f6ebe95f2" translate="yes" xml:space="preserve">
          <source>The version of the RMI Connector Protocol understood by this connector server. This is a string with the following format:</source>
          <target state="translated">이 커넥터 서버가 이해하는 RMI 커넥터 프로토콜의 버전. 다음 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="67c46c943cb161ebaf61561a24251c325c38dcc4" translate="yes" xml:space="preserve">
          <source>The version of the information model in which this element was introduced. A set of MBeans defined by an application is collectively called an &lt;em&gt;information model&lt;/em&gt;. The application may also define versions of this model, and use the &lt;code&gt;&quot;since&quot;&lt;/code&gt; field to record the version in which an element first appeared.</source>
          <target state="translated">이 요소가 소개 된 정보 모델의 버전. 어플리케이션에 의해 정의 된 MBean 세트를 통칭하여 &lt;em&gt;정보 모델&lt;/em&gt; 이라고합니다 . 응용 프로그램은이 모델의 버전을 정의하고 &lt;code&gt;&quot;since&quot;&lt;/code&gt; 필드를 사용하여 요소가 처음 나타난 버전을 기록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3685bfd8924e2e12ab202fe7572e0fc113f3c96f" translate="yes" xml:space="preserve">
          <source>The version of the supported language.</source>
          <target state="translated">지원되는 언어의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="493ae14aa8bda8f4cbb42c55258a1945f011ee02" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition 5.0. The language described in</source>
          <target state="translated">Java 2 플랫폼, Standard Edition 5.0에서 인식되는 버전입니다. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="6c8ee4fc6c4ec0e899d656f5815ce54f62279899" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.2. The language described in</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.2에서 인식되는 버전입니다. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="60485dd1cd7fcf936094d3c03d7336c18a555a23" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.3. No major changes from &lt;code&gt;RELEASE_2&lt;/code&gt;.</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.3에서 인식되는 버전입니다. &lt;code&gt;RELEASE_2&lt;/code&gt; 에서 큰 변화가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="33e65cacac89fcf14c1fb1ffd5441c1fd46da791" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java 2 Platform, Standard Edition, v 1.4. Added a simple assertion facility.</source>
          <target state="translated">Java 2 플랫폼, Standard Edition, v 1.4에서 인식되는 버전입니다. 간단한 어설 션 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="2af496d830b8e85fb7bdac6006a960dc011931da" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform 1.1. The language is &lt;code&gt;RELEASE_0&lt;/code&gt; augmented with nested classes as described in the 1.1 update to</source>
          <target state="translated">Java 플랫폼 1.1에서 인식하는 버전입니다. 이 언어는 1.1 업데이트에 설명 된대로 중첩 클래스로 보강 된 &lt;code&gt;RELEASE_0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a1c95c42d35f8469c63a9001750d4f9ec2552bd" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 6. No major changes from &lt;code&gt;RELEASE_5&lt;/code&gt;.</source>
          <target state="translated">Java 플랫폼, Standard Edition 6에 의해 인식되는 버전 &lt;code&gt;RELEASE_5&lt;/code&gt; . RELEASE_5 에서 큰 변화가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dc1600019466bdbd05352dcab9d2cc9fbdf36863" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 7. Additions in this release include, diamond syntax for constructors, &lt;code&gt;try&lt;/code&gt;-with-resources, strings in switch, binary literals, and multi-catch.</source>
          <target state="translated">Java 플랫폼, Standard Edition 7에서 인식하는 버전입니다.이 릴리스의 추가 기능에는 생성자를위한 다이아몬드 구문, &lt;code&gt;try&lt;/code&gt; -with-resources, 스위치의 문자열, 이진 리터럴 및 멀티 캐치가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5437ac950badfe9820695aa51943c8ac51fd94" translate="yes" xml:space="preserve">
          <source>The version recognized by the Java Platform, Standard Edition 8. Additions in this release include lambda expressions and default methods.</source>
          <target state="translated">Java 플랫폼, Standard Edition 8에서 인식하는 버전입니다.이 릴리스의 추가 기능에는 람다 식 및 기본 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c631dab429ccbd9fa24264a600e66db40fdd0678" translate="yes" xml:space="preserve">
          <source>The view of a file provided by an instance of this class is guaranteed to be consistent with other views of the same file provided by other instances in the same program. The view provided by an instance of this class may or may not, however, be consistent with the views seen by other concurrently-running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols. This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine. The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.</source>
          <target state="translated">이 클래스의 인스턴스에서 제공 한 파일보기는 동일한 프로그램의 다른 인스턴스에서 제공 한 동일한 파일의 다른보기와 일치하도록 보장됩니다. 그러나이 클래스의 인스턴스가 제공하는보기는 기본 운영 체제에서 수행하는 캐싱 및 네트워크 파일 시스템 프로토콜에 의해 유발 된 지연으로 인해 동시에 실행중인 다른 프로그램에서 보는보기와 일치 할 수도 있고 일치하지 않을 수도 있습니다. 이는 다른 프로그램이 작성되는 언어 및 동일한 시스템에서 실행되는지 또는 다른 시스템에서 실행되는지에 관계없이 적용됩니다. 이러한 불일치의 정확한 특성은 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e69e4b05faf63e778871c0d3850aefc9998b9588" translate="yes" xml:space="preserve">
          <source>The view of the files and file system provided by classes in this package are guaranteed to be consistent with other views provided by other instances in the same Java virtual machine. The view may or may not, however, be consistent with the view of the file system as seen by other concurrently running programs due to caching performed by the underlying operating system and delays induced by network-filesystem protocols. This is true regardless of the language in which these other programs are written, and whether they are running on the same machine or on some other machine. The exact nature of any such inconsistencies are system-dependent and are therefore unspecified.</source>
          <target state="translated">이 패키지의 클래스가 제공하는 파일 및 파일 시스템의보기는 동일한 Java 가상 머신의 다른 인스턴스가 제공하는 다른보기와 일치하도록 보장됩니다. 그러나보기는 기본 운영 체제에서 수행하는 캐싱 및 네트워크 파일 시스템 프로토콜에 의해 유발 된 지연으로 인해 동시에 실행중인 다른 프로그램에서 볼 수있는 파일 시스템의보기와 일치 할 수도 있고 일치하지 않을 수도 있습니다. 이는 다른 프로그램이 작성되는 언어 및 동일한 시스템에서 실행되는지 또는 다른 시스템에서 실행되는지에 관계없이 적용됩니다. 이러한 불일치의 정확한 특성은 시스템에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcf26d7eb7f2b3b9db64cfa5669c95b2c00b65af" translate="yes" xml:space="preserve">
          <source>The view's &lt;code&gt;spliterator&lt;/code&gt; reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 &lt;code&gt;spliterator&lt;/code&gt; 는 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; 을&lt;/a&gt; 보고합니다 .</target>
        </trans-unit>
        <trans-unit id="7f5166b266b10230b8c5577f5d6f553331cc4405" translate="yes" xml:space="preserve">
          <source>The view's &lt;code&gt;spliterator&lt;/code&gt; reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#DISTINCT&quot;&gt;&lt;code&gt;Spliterator.DISTINCT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 &lt;code&gt;spliterator&lt;/code&gt; 가 &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../spliterator#DISTINCT&quot;&gt; &lt;code&gt;Spliterator.DISTINCT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; 을보고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e180456519029a61110027d18c36a686018713ed" translate="yes" xml:space="preserve">
          <source>The view's iterators and spliterators are &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰의 이터레이터와 스플리터는 &lt;a href=&quot;package-summary#Weakly&quot;&gt;&lt;i&gt;일관성&lt;/i&gt;&lt;/a&gt; 이 &lt;i&gt;약&lt;/i&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c1f582e06f3b6e62c7c1e3d34a0b9a3c408789c8" translate="yes" xml:space="preserve">
          <source>The virtual machine is</source>
          <target state="translated">가상 머신은</target>
        </trans-unit>
        <trans-unit id="e9f9a3839ed2055f08a26dbd35178cd5a027df29" translate="yes" xml:space="preserve">
          <source>The virtual machine is free to treat the &lt;code&gt;stackSize&lt;/code&gt; parameter as a suggestion. If the specified value is unreasonably low for the platform, the virtual machine may instead use some platform-specific minimum value; if the specified value is unreasonably high, the virtual machine may instead use some platform-specific maximum. Likewise, the virtual machine is free to round the specified value up or down as it sees fit (or to ignore it completely).</source>
          <target state="translated">가상 머신은 &lt;code&gt;stackSize&lt;/code&gt; 매개 변수를 제안으로 자유롭게 처리 할 수 있습니다. 플랫폼에 대해 지정된 값이 부당하게 낮은 경우 가상 시스템은 일부 플랫폼 별 최소값을 대신 사용할 수 있습니다. 지정된 값이 부당하게 높은 경우 가상 시스템은 일부 플랫폼 별 최대 값을 대신 사용할 수 있습니다. 마찬가지로, 가상 머신은 지정된대로 적절하게 지정된 값을 올림 또는 내림하거나 자유롭게 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c721c30f38fc2edaadd8b6106e60056792e573" translate="yes" xml:space="preserve">
          <source>The virtual machine performs the finalization process automatically as needed, in a separate thread, if the &lt;code&gt;runFinalization&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;runFinalization&lt;/code&gt; 메소드가 명시 적으로 호출되지 않은 경우 가상 머신은 필요에 따라 별도의 스레드에서 종료 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="8642fbcebaba07b4669d35a2e26b8bad16051e94" translate="yes" xml:space="preserve">
          <source>The virtual machine's shutdown sequence consists of two phases. In the first phase all registered &lt;a href=&quot;runtime#addShutdownHook-java.lang.Thread-&quot;&gt;&lt;code&gt;shutdown hooks&lt;/code&gt;&lt;/a&gt;, if any, are started in some unspecified order and allowed to run concurrently until they finish. In the second phase all uninvoked finalizers are run if &lt;a href=&quot;runtime#runFinalizersOnExit-boolean-&quot;&gt;&lt;code&gt;finalization-on-exit&lt;/code&gt;&lt;/a&gt; has been enabled. Once this is done the virtual machine &lt;a href=&quot;runtime#halt-int-&quot;&gt;&lt;code&gt;halts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가상 머신의 종료 순서는 두 단계로 구성됩니다. 첫 번째 단계에서는 등록 된 모든 &lt;a href=&quot;runtime#addShutdownHook-java.lang.Thread-&quot;&gt; &lt;code&gt;shutdown hooks&lt;/code&gt; &lt;/a&gt; (있는 경우)가 지정되지 않은 순서로 시작되어 완료 될 때까지 동시에 실행될 수 있습니다. 두 번째 단계에서는 종료시 &lt;a href=&quot;runtime#runFinalizersOnExit-boolean-&quot;&gt; &lt;code&gt;finalization-on-exit&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 모든 호출되지 않은 종료 자가 실행됩니다 . 이 작업이 완료되면 가상 머신이 &lt;a href=&quot;runtime#halt-int-&quot;&gt; &lt;code&gt;halts&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae8e7cd4a0bb7e3290fc509b4004aec986be05c" translate="yes" xml:space="preserve">
          <source>The volatile write to &lt;code&gt;V&lt;/code&gt; is placed (in an implementation specific manner) in the global synchronization order.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 에 대한 휘발성 쓰기 는 (구체적 특정 방식으로) 글로벌 동기화 순서로 배치된다.</target>
        </trans-unit>
        <trans-unit id="c21a8aed036bbcc185b5b957c5388bff363a670b" translate="yes" xml:space="preserve">
          <source>The week-based-year itself is defined relative to the standard ISO proleptic year. It differs from the standard year in that it always starts on a Monday.</source>
          <target state="translated">주별 연도 자체는 표준 ISO proleptic 연도를 기준으로 정의됩니다. 항상 월요일에 시작한다는 점에서 표준 연도와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d336c8b0105b02d9ce73f7d6cc89eeb2f4a9e56e" translate="yes" xml:space="preserve">
          <source>The width</source>
          <target state="translated">넓이</target>
        </trans-unit>
        <trans-unit id="7fe9b320764e1c259d500225d7d4be176cd3d638" translate="yes" xml:space="preserve">
          <source>The width is defined as for &lt;a href=&quot;#genWidth&quot;&gt;General conversions&lt;/a&gt;.</source>
          <target state="translated">너비는 &lt;a href=&quot;#genWidth&quot;&gt;일반 변환&lt;/a&gt; 과 같이 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9b89fd07215f56373dd23dc6888317dc590ecf4" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output including the &lt;code&gt;'%'&lt;/code&gt;. If the length of the converted value is less than the &lt;code&gt;width&lt;/code&gt; then the output will be padded by spaces (&lt;code&gt;'\u0020'&lt;/code&gt;) until the total number of characters equals width. The padding is on the left. If width is not specified then just the &lt;code&gt;'%'&lt;/code&gt; is output.</source>
          <target state="translated">너비는 &lt;code&gt;'%'&lt;/code&gt; 를 포함하여 출력에 쓸 최소 문자 수입니다 . 변환 된 값의 길이가 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 총 문자 수가 너비와 같아 질 때까지 공백 ( &lt;code&gt;'\u0020'&lt;/code&gt; )으로 출력이 채워집니다 . 패딩은 왼쪽에 있습니다. 너비를 지정하지 않으면 &lt;code&gt;'%'&lt;/code&gt; 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="08497cb4ffc4de43dc36a3a7a1421b6649c24786" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output. For the line separator conversion, width is not applicable; if it is provided, an exception will be thrown.</source>
          <target state="translated">너비는 출력에 쓸 최소 문자 수입니다. 행 구분 기호 변환의 경우 너비를 적용 할 수 없습니다. 제공되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93c895f38cd814a0586673133f90d150b89f6aeb" translate="yes" xml:space="preserve">
          <source>The width is the minimum number of characters to be written to the output. If the length of the converted value is less than the &lt;code&gt;width&lt;/code&gt; then the output will be padded by spaces (&lt;code&gt;'\u0020'&lt;/code&gt;) until the total number of characters equals width. The padding is on the left by default. If the &lt;code&gt;'-'&lt;/code&gt; flag is given then the padding will be on the right. If width is not specified then there is no minimum.</source>
          <target state="translated">너비는 출력에 쓸 최소 문자 수입니다. 변환 된 값의 길이가 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 총 문자 수가 너비와 같아 질 때까지 공백 ( &lt;code&gt;'\u0020'&lt;/code&gt; )으로 출력이 채워집니다 . 패딩은 기본적으로 왼쪽에 있습니다. 경우 &lt;code&gt;'-'&lt;/code&gt; 플래그가 지정되었을 경우, 우측으로 패딩됩니다. 너비를 지정하지 않으면 최소값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="11573fd74f145064e80c81a509d0d28ecf0a475c" translate="yes" xml:space="preserve">
          <source>The width of each tile if tiling has been set, or 0 otherwise.</source>
          <target state="translated">바둑판 식 배열이 설정된 경우 각 타일의 너비이거나 그렇지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="ec49c197d43c64b4897761f6df266e5358ba460b" translate="yes" xml:space="preserve">
          <source>The width of the printed fraction can be controlled. Setting the minimum width to zero will cause no output to be generated. The printed fraction will have the minimum width necessary between the minimum and maximum widths - trailing zeroes are omitted. No rounding occurs due to the maximum width - digits are simply dropped.</source>
          <target state="translated">인쇄 된 부분의 너비를 제어 할 수 있습니다. 최소 너비를 0으로 설정하면 출력이 생성되지 않습니다. 인쇄 된 분수는 최소 너비와 최대 너비 사이에 필요한 최소 너비를 갖습니다. 후행 0은 생략됩니다. 최대 너비로 인해 반올림이 발생하지 않습니다. 숫자는 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="87463d379aacb015b2b5b4467fead7e3636e854d" translate="yes" xml:space="preserve">
          <source>The working directory does not exist.</source>
          <target state="translated">작업 디렉토리가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="149ba28788d40521e03aae86481799a4aad8958e" translate="yes" xml:space="preserve">
          <source>The working directory of the new subprocess is specified by &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the subprocess inherits the current working directory of the current process.</source>
          <target state="translated">새 하위 프로세스의 작업 디렉토리는 &lt;code&gt;dir&lt;/code&gt; 로 지정됩니다 . 경우 &lt;code&gt;dir&lt;/code&gt; 있습니다 &lt;code&gt;null&lt;/code&gt; , 서브 프로세스는 현재의 프로세스의 현재 작업 디렉토리를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="9d7e42ba8563b4861562d9fedd9c297c3c802ae3" translate="yes" xml:space="preserve">
          <source>The wrapper instance will implement the requested interface and its super-types, but no other single-method interfaces. This means that the instance will not unexpectedly pass an &lt;code&gt;instanceof&lt;/code&gt; test for any unrequested type.</source>
          <target state="translated">랩퍼 인스턴스는 요청 된 인터페이스 및 해당 수퍼 유형을 구현하지만 다른 단일 메소드 인터페이스는 구현하지 않습니다. 이는 요청되지 않은 유형에 대해 인스턴스가 예기치 않게 테스트 &lt;code&gt;instanceof&lt;/code&gt; 통과하지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3c15fc629a9a44eeca7f4fece2da5b14c32ef837" translate="yes" xml:space="preserve">
          <source>The wrapper will allow data to be collected on the native method call, but now the problem becomes linking up the wrapped method with the native implementation. That is, the method &lt;code&gt;wrapped_foo&lt;/code&gt; needs to be resolved to the native implementation of &lt;code&gt;foo&lt;/code&gt;, which might be:</source>
          <target state="translated">랩퍼는 원시 메소드 호출에서 데이터를 수집 할 수 있지만 이제 문제점은 랩핑 된 메소드를 원시 구현과 링크합니다. 즉, &lt;code&gt;wrapped_foo&lt;/code&gt; 메소드는 다음과 같은 &lt;code&gt;foo&lt;/code&gt; 기본 구현으로 분석 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="16ec3748a6bad8d0fc41d7ba859a56b2513c46d9" translate="yes" xml:space="preserve">
          <source>The write end of a pipe</source>
          <target state="translated">파이프의 쓰기 끝</target>
        </trans-unit>
        <trans-unit id="8f8bfaf5e08009c50abac22b29c0466e9561af91" translate="yes" xml:space="preserve">
          <source>The write lock is acquired by the current thread; or</source>
          <target state="translated">쓰기 잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="4479644870cc0b6de23ac32560cf11f5241f6aec" translate="yes" xml:space="preserve">
          <source>The write lock provides a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation that behaves in the same way, with respect to the write lock, as the &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation provided by &lt;a href=&quot;reentrantlock#newCondition--&quot;&gt;&lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt;&lt;/a&gt; does for &lt;a href=&quot;reentrantlock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; can, of course, only be used with the write lock.</source>
          <target state="translated">기입 로크는 제공 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 은 AS 쓰기 잠금에 대하여 동일한 방식으로 동작, 구현한다는 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 에 의해 제공 구현 &lt;a href=&quot;reentrantlock#newCondition--&quot;&gt; &lt;code&gt;ReentrantLock.newCondition()&lt;/code&gt; &lt;/a&gt; 에 대해 수행 &lt;a href=&quot;reentrantlock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; 와이&lt;/a&gt; . 물론 이 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 은 쓰기 잠금에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02bad978674eb6748c2b65fbeda2a59a87a1171a" translate="yes" xml:space="preserve">
          <source>The write operation may write up to</source>
          <target state="translated">쓰기 작업은 최대</target>
        </trans-unit>
        <trans-unit id="848f53cc5fb27d051b03412fae86949bd08f9ecd" translate="yes" xml:space="preserve">
          <source>The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The default mechanism for saving the Object's fields can be invoked by calling out.defaultWriteObject. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">writeObject 메소드는 해당 readObject 메소드가이를 복원 할 수 있도록 특정 클래스에 대한 오브젝트 상태를 작성합니다. out.defaultWriteObject를 호출하여 객체 필드를 저장하는 기본 메커니즘을 호출 할 수 있습니다. 이 메소드는 수퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput에서 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfd2d3d4a572740437c98d7a9b174fefaf95ccd" translate="yes" xml:space="preserve">
          <source>The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The method does not need to concern itself with the state belonging to the object's superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput.</source>
          <target state="translated">writeObject 메소드는 해당 readObject 메소드가이를 복원 할 수 있도록 특정 클래스에 대한 오브젝트 상태를 작성합니다. 이 메소드는 객체의 슈퍼 클래스 또는 서브 클래스에 속하는 상태와 관련 될 필요가 없습니다. writeObject 메소드를 사용하거나 DataOutput에서 지원하는 기본 데이터 유형의 메소드를 사용하여 개별 필드를 ObjectOutputStream에 기록하여 상태가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="12162856e28a75771ac79f11fb7626d43e724abb" translate="yes" xml:space="preserve">
          <source>The writeStreamHeader method is provided so subclasses can append or prepend their own header to the stream. It writes the magic number and version to the stream.</source>
          <target state="translated">writeStreamHeader 메소드가 제공되어 서브 클래스가 자체 헤더를 스트림에 추가하거나 추가 할 수 있습니다. 매직 넘버와 버전을 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="62a34851e79619261706f169067b1e8ae983bacb" translate="yes" xml:space="preserve">
          <source>The writing is not complete until a call to &lt;code&gt;endWriteEmpty&lt;/code&gt; occurs. Calls to &lt;code&gt;prepareReplacePixels&lt;/code&gt;, &lt;code&gt;replacePixels&lt;/code&gt;, and &lt;code&gt;endReplacePixels&lt;/code&gt; may occur between calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; and &lt;code&gt;endWriteEmpty&lt;/code&gt;. However, calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; cannot be nested, and calls to &lt;code&gt;prepareWriteEmpty&lt;/code&gt; and &lt;code&gt;prepareInsertEmpty&lt;/code&gt; may not be interspersed.</source>
          <target state="translated">&lt;code&gt;endWriteEmpty&lt;/code&gt; 에 대한 호출이 발생할 때까지 쓰기가 완료되지 않습니다 . 를 호출 &lt;code&gt;prepareReplacePixels&lt;/code&gt; , &lt;code&gt;replacePixels&lt;/code&gt; 및 &lt;code&gt;endReplacePixels&lt;/code&gt; 는 호출 사이에 발생할 수 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 와 &lt;code&gt;endWriteEmpty&lt;/code&gt; . 그러나 호출 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 중첩 될 수 없으며, 호출 &lt;code&gt;prepareWriteEmpty&lt;/code&gt; 와 &lt;code&gt;prepareInsertEmpty&lt;/code&gt; 산재되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f340ab186950cff3443ac085c8bde6bcffa4a47" translate="yes" xml:space="preserve">
          <source>The writing of interlaced images can be controlled by the progressive mode of the provided &lt;code&gt;ImageWriteParam&lt;/code&gt; instance. If progressive mode is &lt;code&gt;MODE_DISABLED&lt;/code&gt; then a non-interlaced image will be written. If progressive mode is &lt;code&gt;MODE_DEFAULT&lt;/code&gt; then an interlaced image will be written. If progressive mode is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, then the metadata setting is used (if it is provided, otherwise an interlaced image will be written).</source>
          <target state="translated">인터레이스 이미지 쓰기는 제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 인스턴스 의 프로그레시브 모드로 제어 할 수 있습니다 . 프로그레시브 모드가 &lt;code&gt;MODE_DISABLED&lt;/code&gt; 이면 비 인터레이스 이미지가 기록됩니다. 프로그레시브 모드가 &lt;code&gt;MODE_DEFAULT&lt;/code&gt; 이면 인터레이스 이미지가 기록됩니다. 프로그레시브 모드가 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 이면 메타 데이터 설정이 사용됩니다 (제공된 경우 인터레이스 이미지가 기록됨).</target>
        </trans-unit>
        <trans-unit id="470f5ef5b9bb159907b73cd224384f1fb1f65e99" translate="yes" xml:space="preserve">
          <source>The year 1AD/CE is represented by 1.</source>
          <target state="translated">1AD / CE 연도는 1로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94efbba691fdae1a9f89ed9e390e5077e5ec1212" translate="yes" xml:space="preserve">
          <source>The year 1BC/BCE is represented by 0.</source>
          <target state="translated">1BC / BCE 연도는 0으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a4166e71717478dfbab468797a5aaf46cfd05d82" translate="yes" xml:space="preserve">
          <source>The year 2AD/CE is represented by 2.</source>
          <target state="translated">2AD / CE 연도는 2로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="109099de288ae4e09256b7ba426e8999e6a15a2f" translate="yes" xml:space="preserve">
          <source>The year 2BC/BCE is represented by -1.</source>
          <target state="translated">2BC / BCE 연도는 -1로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07ec242f131c9a27b1dbfd15fa2dc1ccc37871eb" translate="yes" xml:space="preserve">
          <source>The year can be divided into four quarters. This method returns the first month of the quarter for the base month. January, February and March return January. April, May and June return April. July, August and September return July. October, November and December return October.</source>
          <target state="translated">연도는 4 분기로 나눌 수 있습니다. 이 방법은 기준 월에 대한 분기의 첫 번째 달을 반환합니다. 1 월, 2 월 및 3 월은 1 월에 돌아옵니다. 4 월, 5 월 및 6 월은 4 월에 돌아옵니다. 7 월, 8 월, 9 월은 7 월에 돌아옵니다. 10 월, 11 월 및 12 월은 10 월에 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="63b23bd5415b33a1dd713df991700a20700f76a3" translate="yes" xml:space="preserve">
          <source>The year returned by this method is proleptic as per &lt;code&gt;get(YEAR)&lt;/code&gt;.</source>
          <target state="translated">이 메소드에 의해 반환 된 &lt;code&gt;get(YEAR)&lt;/code&gt; 는 get (YEAR)에 따라 다산 입니다.</target>
        </trans-unit>
        <trans-unit id="b6358c1cf0f427abe2556c16331c59f4b8d32da2" translate="yes" xml:space="preserve">
          <source>The year returned by this method is proleptic as per &lt;code&gt;get(YEAR)&lt;/code&gt;. To obtain the year-of-era, use &lt;code&gt;get(YEAR_OF_ERA)&lt;/code&gt;.</source>
          <target state="translated">이 메소드에 의해 반환 된 &lt;code&gt;get(YEAR)&lt;/code&gt; 는 get (YEAR)에 따라 다산 입니다. 연도를 얻으려면 &lt;code&gt;get(YEAR_OF_ERA)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbff7fe10e8b9cf90167f0d75f706532355546dc" translate="yes" xml:space="preserve">
          <source>The year within the era.</source>
          <target state="translated">시대의 해.</target>
        </trans-unit>
        <trans-unit id="41d3f4e85bc99f5353fb949c0b4b1e34eb530da9" translate="yes" xml:space="preserve">
          <source>The year, month, and day are checked against the new requested HijrahChronology. If the chronology has a shorter month length for the month, the day is reduced to be the last day of the month.</source>
          <target state="translated">새로운 요청 된 HijrahChronology에 대해 년, 월 및 일이 점검됩니다. 연대기의 월 길이가 더 짧으면 해당 월의 마지막 날로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="95823fc22286c4941f6416c1b3d8f9df75024a4b" translate="yes" xml:space="preserve">
          <source>The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of the &lt;a href=&quot;../util/timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt; class that are not &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;custom IDs&lt;/a&gt;. All other entries are localized names.</source>
          <target state="translated">영역 ID가 현지화 &lt;em&gt;되지 않았습니다&lt;/em&gt; . &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;사용자 지정 ID&lt;/a&gt; 가 아닌 &lt;a href=&quot;../util/timezone&quot;&gt; &lt;code&gt;TimeZone&lt;/code&gt; &lt;/a&gt; 클래스 의 유효한 ID 중 하나입니다 . 다른 모든 항목은 현지화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="12a91a95938b30a6f68ad5300194d7afd44011e4" translate="yes" xml:space="preserve">
          <source>The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of the &lt;a href=&quot;../util/timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt; class that are not &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;custom IDs&lt;/a&gt;. All other entries are localized names. If a zone does not implement daylight saving time, the daylight saving time names should not be used.</source>
          <target state="translated">영역 ID가 현지화 &lt;em&gt;되지 않았습니다&lt;/em&gt; . &lt;a href=&quot;../util/timezone#CustomID&quot;&gt;사용자 지정 ID&lt;/a&gt; 가 아닌 &lt;a href=&quot;../util/timezone&quot;&gt; &lt;code&gt;TimeZone&lt;/code&gt; &lt;/a&gt; 클래스 의 유효한 ID 중 하나입니다 . 다른 모든 항목은 현지화 된 이름입니다. 영역이 일광 절약 시간제를 구현하지 않으면 일광 절약 시간제 이름을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ef072be235e128f4417bff8f2ecc9a9fd327d55d" translate="yes" xml:space="preserve">
          <source>The zone ID may be same as the &lt;a href=&quot;zoneddatetime#getOffset--&quot;&gt;offset&lt;/a&gt;. If this is true, then any future calculations, such as addition or subtraction, have no complex edge cases due to time-zone rules. See also &lt;a href=&quot;zoneddatetime#withFixedOffsetZone--&quot;&gt;&lt;code&gt;withFixedOffsetZone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">영역 ID는 &lt;a href=&quot;zoneddatetime#getOffset--&quot;&gt;오프셋&lt;/a&gt; 과 동일 할 수 있습니다 . 이것이 사실이라면, 시간대 규칙으로 인해 더하기 나 빼기와 같은 미래 계산에는 복잡한 경우가 없습니다. &lt;a href=&quot;zoneddatetime#withFixedOffsetZone--&quot;&gt; &lt;code&gt;withFixedOffsetZone()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e5541312fac30d6776b7c47cc8181f1f41befb2" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;implies&lt;/code&gt; checks each of the following, in order, and for each returns true if the stated condition is true:</source>
          <target state="translated">그런 &lt;code&gt;implies&lt;/code&gt; 위해 검사 다음의 각을, 각각의 반환을 위해 명시된 조건이 참에 해당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="9548fcc35b330bbac33c7968b3c68d3a8baf60b6" translate="yes" xml:space="preserve">
          <source>Then every entry in this &lt;code&gt;Properties&lt;/code&gt; table is written out, one per line. For each entry the key string is written, then an ASCII &lt;code&gt;=&lt;/code&gt;, then the associated element string. For the key, all space characters are written with a preceding &lt;code&gt;\&lt;/code&gt; character. For the element, leading space characters, but not embedded or trailing space characters, are written with a preceding &lt;code&gt;\&lt;/code&gt; character. The key and element characters &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; are written with a preceding backslash to ensure that they are properly loaded.</source>
          <target state="translated">그런 다음이 &lt;code&gt;Properties&lt;/code&gt; 테이블의 모든 항목이 한 줄에 하나씩 작성됩니다. 각 항목에 대해 키 문자열이 작성된 다음 ASCII &lt;code&gt;=&lt;/code&gt; , 관련 요소 문자열이 작성됩니다. 키의 경우 모든 공백 문자는 앞에 &lt;code&gt;\&lt;/code&gt; 문자 로 기록됩니다 . 요소의 경우 선행 또는 공백 문자가 아닌 선행 공백 문자는 앞에 &lt;code&gt;\&lt;/code&gt; 문자 로 기록됩니다 . 키와 요소의 문자 &lt;code&gt;#&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; 은 백 슬래시로 작성되어 올바르게로드되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f2515634c238092ca6ab3e114e72af7420724d4f" translate="yes" xml:space="preserve">
          <source>Then it calls &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; passing the &lt;var&gt;delegate&lt;/var&gt; that should be used by the MBeanServer implementation.</source>
          <target state="translated">그런 다음 MBeanServer 구현에서 사용해야 하는 &lt;var&gt;delegate&lt;/var&gt; 를 전달하여 &lt;code&gt;newMBeanServer(defaultDomain,outer,delegate)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5c9c219ad93a3973cb2bece1cad4c707c4e984e8" translate="yes" xml:space="preserve">
          <source>Then the floating-point result equals the value of the mathematical expression</source>
          <target state="translated">그런 다음 부동 소수점 결과는 수학 표현식의 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2305112f3cfd47ec6189ee9ae9aff82a3050640c" translate="yes" xml:space="preserve">
          <source>Then the following linkage invariants must hold:</source>
          <target state="translated">그런 다음 다음 연결 불변 값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed9c8aedb6a288d80aca27bb2abdd611ccdaa129" translate="yes" xml:space="preserve">
          <source>Then the method &lt;code&gt;doIt&lt;/code&gt; is overloaded. EventHandler will invoke the method that is appropriate based on the source. If the source is null, then either method is appropriate and the one that is invoked is undefined. For that reason we recommend against targeting overloaded methods.</source>
          <target state="translated">그런 다음 &lt;code&gt;doIt&lt;/code&gt; 메소드 가 오버로드됩니다. EventHandler는 소스를 기반으로 적절한 메소드를 호출합니다. 소스가 널인 경우, 두 메소드 중 하나가 적합하고 호출 된 메소드가 정의되지 않습니다. 따라서 오버로드 된 메소드를 타겟팅하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf6134715d80b46ffde96271931c92751bbdaf3f" translate="yes" xml:space="preserve">
          <source>Then you can execute:</source>
          <target state="translated">그런 다음 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63c81bede51f6179d36f078fe8cba0feafc1e55" translate="yes" xml:space="preserve">
          <source>Then, before sending a notification to a listener registered with a filter, the notification broadcaster compares this notification type with all notification types enabled by the filter. The notification will be sent to the listener only if its filter enables this notification type.</source>
          <target state="translated">그런 다음 필터로 등록 된 리스너에 알림을 보내기 전에 알림 브로드 캐스터는이 알림 유형을 필터에서 사용 가능한 모든 알림 유형과 비교합니다. 필터에서이 알림 유형을 활성화 한 경우에만 알림이 리스너에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="d356dd80aaac6fd043102b988a584a6fc2fbf218" translate="yes" xml:space="preserve">
          <source>There are 3 HTTP cookie specifications:</source>
          <target state="translated">3 가지 HTTP 쿠키 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da791d8e9fec115ce104b9f6b089536088c3804" translate="yes" xml:space="preserve">
          <source>There are 52 weeks in most week-based years, however on occasion there are 53 weeks.</source>
          <target state="translated">대부분의 주 단위로 52 주가 있지만 때로는 53 주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea75d499786717edf2fd9174e48f8b5e056e64a9" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;SSLSessionContext&lt;/code&gt; parameters that affect how sessions are stored:</source>
          <target state="translated">세션 저장 방법에 영향을주는 &lt;code&gt;SSLSessionContext&lt;/code&gt; 매개 변수 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="368828561f4d9578233a778592c44861ba54cf6a" translate="yes" xml:space="preserve">
          <source>There are a number of classes and interfaces in this package which are designed to ease the implementation of the SPI to customize the behavior of a compiler:</source>
          <target state="translated">이 패키지에는 컴파일러의 동작을 사용자 정의하기 위해 SPI를 쉽게 구현할 수 있도록 설계된 여러 클래스와 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef8f158deb14b7be2cf0d4efa8baefda6a71922f" translate="yes" xml:space="preserve">
          <source>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using &lt;a href=&quot;../spliterators#spliteratorUnknownSize-java.util.Iterator-int-&quot;&gt;&lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt;&lt;/a&gt;. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</source>
          <target state="translated">스플리터를 구현할 때 여러 가지 구현 선택 사항이 있으며, 그 대부분은 구현의 단순성과 해당 스플리터를 사용하는 스트림의 런타임 성능 간의 절충점입니다. 스플리터를 작성하는 가장 단순하지만 성능이 가장 낮은 방법은 &lt;a href=&quot;../spliterators#spliteratorUnknownSize-java.util.Iterator-int-&quot;&gt; &lt;code&gt;Spliterators.spliteratorUnknownSize(java.util.Iterator, int)&lt;/code&gt; &lt;/a&gt; 사용하여 이터레이터에서 하나를 작성하는 것입니다 . 이러한 스플리터는 작동하지만 사이징 정보 (기본 데이터 세트의 크기)가 손실되고 단순한 스 플리 팅 알고리즘으로 제한되어 있기 때문에 병렬 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d878f03d7f9c2dbc33d5fa733c11fe1634d11ad" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;log&quot; methods that take a log level, a message string, and optionally some parameters to the message string.</source>
          <target state="translated">로그 레벨, 메시지 문자열 및 선택적으로 메시지 문자열에 대한 일부 매개 변수를 취하는 &quot;log&quot;메소드 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f67ebc693e84bdf0873eac0e73efeaa82c19a53" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;logp&quot; methods (for &quot;log precise&quot;) that are like the &quot;log&quot; methods, but also take an explicit source class name and method name.</source>
          <target state="translated">&quot;log&quot;메소드와 유사한 &quot;logp&quot;메소드 세트 ( &quot;정확한 로그&quot;)가 있지만 명시적인 소스 클래스 이름 및 메소드 이름도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15b0598156ef25c63a8ccf779a6fbebb01022f73" translate="yes" xml:space="preserve">
          <source>There are a set of &quot;logrb&quot; method (for &quot;log with resource bundle&quot;) that are like the &quot;logp&quot; method, but also take an explicit resource bundle object for use in localizing the log message.</source>
          <target state="translated">&quot;logp&quot;메소드와 유사한 &quot;logrb&quot;메소드 세트 ( &quot;자원 번들이있는 로그&quot;)가 있지만 로그 메시지를 지역화하는 데 사용할 명시 적 자원 번들 오브젝트도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="198896f4bb32a48314969671e1a0bed9b57f85c9" translate="yes" xml:space="preserve">
          <source>There are additional derived function shapes which extend the basic function shapes, including &lt;a href=&quot;unaryoperator&quot;&gt;&lt;code&gt;UnaryOperator&lt;/code&gt;&lt;/a&gt; (extends &lt;code&gt;Function&lt;/code&gt;) and &lt;a href=&quot;binaryoperator&quot;&gt;&lt;code&gt;BinaryOperator&lt;/code&gt;&lt;/a&gt; (extends &lt;code&gt;BiFunction&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;unaryoperator&quot;&gt; &lt;code&gt;UnaryOperator&lt;/code&gt; &lt;/a&gt; (extends &lt;code&gt;Function&lt;/code&gt; ) 및 &lt;a href=&quot;binaryoperator&quot;&gt; &lt;code&gt;BinaryOperator&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;BiFunction&lt;/code&gt; 확장 )를 포함하여 기본 함수 모양을 확장하는 추가 파생 함수 모양이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da12f2c258a3714932bec19ffbde602032cd7a0d" translate="yes" xml:space="preserve">
          <source>There are also times where you don't know a priori which permissions to check the context against. In these cases you can use the doPrivileged method that takes a context. You can also limit the scope of the privileged code by passing additional &lt;code&gt;Permission&lt;/code&gt; parameters.</source>
          <target state="translated">컨텍스트를 확인할 권한을 사전에 모르는 경우도 있습니다. 이 경우 컨텍스트를 취하는 doPrivileged 메소드를 사용할 수 있습니다. 추가 &lt;code&gt;Permission&lt;/code&gt; 매개 변수 를 전달하여 권한있는 코드의 범위를 제한 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3fe717a4310bd251c07830ac0f0685c5d479c19" translate="yes" xml:space="preserve">
          <source>There are certain methods in which the name must resolve to a context (for example, when searching a single level context). The documentation of such methods use the term &lt;em&gt;named context&lt;/em&gt; to describe their name parameter. For these methods, if the named object is not a DirContext, &lt;code&gt;NotContextException&lt;/code&gt; is thrown. Aside from these methods, there is no requirement that the &lt;em&gt;named object&lt;/em&gt; be a DirContext.</source>
          <target state="translated">이름이 컨텍스트로 해석되어야하는 특정 방법이 있습니다 (예 : 단일 레벨 컨텍스트를 검색 할 때). 이러한 메소드의 문서에서는 &lt;em&gt;이름이 지정된 context라는&lt;/em&gt; 용어를 사용하여 이름 매개 변수를 설명합니다. 이러한 메소드의 경우, 이름 지정된 오브젝트가 DirContext가 아닌 경우 &lt;code&gt;NotContextException&lt;/code&gt; 이 발생합니다. 이러한 메소드 외에, &lt;em&gt;명명 된 객체&lt;/em&gt; 가 DirContext 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="94b019709222f6854929818bf02c4b3e4fa68677" translate="yes" xml:space="preserve">
          <source>There are convenience methods for tracing method entries (the &quot;entering&quot; methods), method returns (the &quot;exiting&quot; methods) and throwing exceptions (the &quot;throwing&quot; methods).</source>
          <target state="translated">메소드 항목 추적 ( &quot;enter&quot;메소드), 메소드 리턴 ( &quot;exiting&quot;메소드) 및 예외 발생 ( &quot;throwing&quot;메소드)에 대한 편리한 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="618db28d57aed6ef38b8a1dbeb663ce327ce97c2" translate="yes" xml:space="preserve">
          <source>There are currently, as of 2013, two segments in the Java time-scale.</source>
          <target state="translated">현재 2013 년 현재 Java 시간 규모에는 두 개의 세그먼트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc705dd39680a046181dbb1861c4932a0e3881d7" translate="yes" xml:space="preserve">
          <source>There are five distinct phases to an &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SSLEngine&lt;/code&gt; 에는 5 가지 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0a4f63088373d76505ee3e5710b2bb4d1a2d15" translate="yes" xml:space="preserve">
          <source>There are five kinds of printing attributes: doc attributes, print request attributes, print job attributes, print service attributes, and supported-values attributes.</source>
          <target state="translated">인쇄 속성에는 문서 속성, 인쇄 요청 속성, 인쇄 작업 속성, 인쇄 서비스 속성 및 지원되는 값 속성의 5 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad932612288aaada09723e6430aa6935c07b669" translate="yes" xml:space="preserve">
          <source>There are four main target uses of the logs:</source>
          <target state="translated">로그에는 다음과 같은 네 가지 주요 대상 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3229708e8f565466bb07ef07847c54b18ae5a8fb" translate="yes" xml:space="preserve">
          <source>There are four possible types of icons: 16 x 16 color, 32 x 32 color, 16 x 16 mono, and 32 x 32 mono. If you implement a bean so that it supports a single icon, it is recommended to use 16 x 16 color. Another recommendation is to set a transparent background for the icons.</source>
          <target state="translated">16 x 16 컬러, 32 x 32 컬러, 16 x 16 모노 및 32 x 32 모노의 네 가지 아이콘 유형이 있습니다. 단일 아이콘을 지원하도록 Bean을 구현하는 경우 16 x 16 색상을 사용하는 것이 좋습니다. 다른 권장 사항은 아이콘의 투명한 배경을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98c7cab3315e49a24f27fa42a75adda139b73fd1" translate="yes" xml:space="preserve">
          <source>There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to &lt;code&gt;collect()&lt;/code&gt;. For example, the following will accumulate strings into an &lt;code&gt;ArrayList&lt;/code&gt;:</source>
          <target state="translated">JDK에는 서명이 &lt;code&gt;collect()&lt;/code&gt; 인수로 메소드 참조와 함께 사용하기에 적합한 기존 클래스가 많이 있습니다 . 예를 들어, 다음은 문자열을 &lt;code&gt;ArrayList&lt;/code&gt; 에 누적합니다 .</target>
        </trans-unit>
        <trans-unit id="50c2a67a49e9e5ccc44a9144a8b2fa11e175cf65" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toConcurrentMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a &lt;code&gt;Map&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑 된 여러 요소 간의 충돌을 처리하는 여러 가지 방법이 있습니다. &lt;code&gt;toConcurrentMap&lt;/code&gt; 의 다른 형식은 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어 &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소로 &quot;전화 번호부&quot;매핑 이름을 생성하려고하지만 두 사람이 같은 이름을 가질 수있는 경우 이러한 충돌을 정상적으로 처리하기 위해 다음과 같이 할 수 있습니다. 연결된 주소 목록에 대한 &lt;code&gt;Map&lt;/code&gt; 매핑 이름을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d570df6b0a511d807488f697e8fff67205fb8ca7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of &lt;code&gt;toMap&lt;/code&gt; simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of &lt;code&gt;Person&lt;/code&gt;, and you want to produce a &quot;phone book&quot; mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a &lt;code&gt;Map&lt;/code&gt; mapping names to a concatenated list of addresses:</source>
          <target state="translated">동일한 키에 매핑 된 여러 요소 간의 충돌을 처리하는 여러 가지 방법이 있습니다. 다른 형태의 &lt;code&gt;toMap&lt;/code&gt; 은 무조건 던지는 병합 함수를 사용하지만보다 유연한 병합 정책을 쉽게 작성할 수 있습니다. 예를 들어 &lt;code&gt;Person&lt;/code&gt; 스트림이 있고 주소로 &quot;전화 번호부&quot;매핑 이름을 생성하려고하지만 두 사람이 같은 이름을 가질 수있는 경우 이러한 충돌을 정상적으로 처리하기 위해 다음과 같이 할 수 있습니다. 연결된 주소 목록에 대한 &lt;code&gt;Map&lt;/code&gt; 매핑 이름을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="49355ea4a7f0de6774fce9fba4ed5392d62aa873" translate="yes" xml:space="preserve">
          <source>There are nine predefined &lt;code&gt;Class&lt;/code&gt; objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as the primitive types that they represent, namely &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">8 개의 기본 유형과 void를 나타내는 9 개의 사전 정의 된 &lt;code&gt;Class&lt;/code&gt; 객체가 있습니다. 이것들은 Java Virtual Machine에 의해 만들어지며, 그것들이 나타내는 기본 타입과 같은 이름, 즉 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5073f2e7c4323e6ba19e16f32d668e2082db861a" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. For example, typical implementations will cancel via &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;, so any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업 처리를 중지하려는 최선의 노력 외에는 보장 할 수 없습니다. 예를 들어 일반적인 구현은 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 취소 되므로 인터럽트에 응답하지 않는 모든 작업은 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f38732315c805219d239e42cbc8fc17be7b03f5" translate="yes" xml:space="preserve">
          <source>There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation cancels tasks via &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;Thread.interrupt()&lt;/code&gt;&lt;/a&gt;, so any task that fails to respond to interrupts may never terminate.</source>
          <target state="translated">적극적으로 실행중인 작업 처리를 중지하려는 최선의 노력 외에는 보장 할 수 없습니다. 이 구현은 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;Thread.interrupt()&lt;/code&gt; &lt;/a&gt; 를 통해 작업을 취소 하므로 인터럽트에 응답하지 않는 작업은 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c152317dbceb46ecf06e80209421468af5e327b5" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, or serializability of the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt; objects returned, or of the thread-safety of the &lt;code&gt;List&lt;/code&gt; objects returned.</source>
          <target state="translated">거기의 종류, 가변성, 또는 직렬화에 대한 보장없는 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 반환되는 객체는, 또는의 스레드 안전성의 &lt;code&gt;List&lt;/code&gt; 반환 객체.</target>
        </trans-unit>
        <trans-unit id="bb964f47cb21418a605ea5141958b9590922fa27" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt; objects returned.</source>
          <target state="translated">반환 된 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 객체 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9cea59dafa3fd974f0fd6fa4fbe89e4cbe017d69" translate="yes" xml:space="preserve">
          <source>There are no guarantees on the type, mutability, serializability, or thread-safety of the &lt;code&gt;Map&lt;/code&gt; returned.</source>
          <target state="translated">리턴 된 &lt;code&gt;Map&lt;/code&gt; 의 유형, 변경 가능성, 직렬화 가능성 또는 스레드 안전성에 대한 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb1f2720f5e4869f1d5aa33e3942c41021d10b1b" translate="yes" xml:space="preserve">
          <source>There are several basic function shapes, including &lt;a href=&quot;function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;), &lt;a href=&quot;consumer&quot;&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;predicate&quot;&gt;&lt;code&gt;Predicate&lt;/code&gt;&lt;/a&gt; (unary function from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;), and &lt;a href=&quot;supplier&quot;&gt;&lt;code&gt;Supplier&lt;/code&gt;&lt;/a&gt; (nilary function to &lt;code&gt;R&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;consumer&quot;&gt; &lt;code&gt;Consumer&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;void&lt;/code&gt; 로의 단항 함수 ), &lt;a href=&quot;predicate&quot;&gt; &lt;code&gt;Predicate&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;boolean&lt;/code&gt; 까지의 단항 함수 ) 및 &lt;a href=&quot;supplier&quot;&gt; &lt;code&gt;Supplier&lt;/code&gt; &lt;/a&gt; (nilary 함수에서 &lt;code&gt;R&lt;/code&gt; ) 를 포함하여 몇 가지 기본 함수 모양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2da96ddea93cc96c7a3493bc185e3b88403db18" translate="yes" xml:space="preserve">
          <source>There are several compatibility concerns to keep in mind if an annotation type</source>
          <target state="translated">주석 유형 인 경우 명심해야 할 호환성 문제가 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6b76f15b787736c9401a42c8c4bb8a7e713611" translate="yes" xml:space="preserve">
          <source>There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Locale&lt;/code&gt; 오브젝트 를 작성하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad010658753417b64166337fccfa2064b4e7316" translate="yes" xml:space="preserve">
          <source>There are several reasons why an enabled cipher suite might not actually be used. For example: the server socket might not have appropriate private keys available to it or the cipher suite might be anonymous, precluding the use of client authentication, while the server socket has been told to require that sort of authentication.</source>
          <target state="translated">활성화 된 암호 제품군이 실제로 사용되지 않는 데는 몇 가지 이유가 있습니다. 예를 들어, 서버 소켓에 사용 가능한 적절한 개인 키가 없거나 암호 제품군이 익명 일 수 있으며 클라이언트 인증 사용을 제외하고 서버 소켓에 이러한 종류의 인증이 필요하다는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="06a988002378eef1c65c03ab8ae35ac92c999ee3" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the parameters that may be passed to &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 에 전달 될 수있는 매개 변수에는 몇 가지 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bd6f67a832bd215f4e92e1b7ec5044236848741" translate="yes" xml:space="preserve">
          <source>There are three general strategies for queuing:</source>
          <target state="translated">큐잉을위한 세 가지 일반적인 전략이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75f24f0c160cfac7adb08056cdce581127cc3e7" translate="yes" xml:space="preserve">
          <source>There are three kinds of Monitors:</source>
          <target state="translated">세 가지 종류의 모니터가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c25e15fc967b546c584ccdefa3b60e5531758f54" translate="yes" xml:space="preserve">
          <source>There are three main models for triggering a push of the buffer:</source>
          <target state="translated">버퍼 푸시를 트리거하기위한 세 가지 주요 모델이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b997529c7c84200f70fc10cb9c45ebe777ca580" translate="yes" xml:space="preserve">
          <source>There are three phases to the use of a Signature object for either signing data or verifying a signature:</source>
          <target state="translated">데이터 서명 또는 서명 확인을 위해 Signature 객체를 사용하는 데는 3 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a114e0c5ecd87e992d3fcc0bb2519744081844d" translate="yes" xml:space="preserve">
          <source>There are three predefined modes that specify possible masters for a sequencer: &lt;code&gt;INTERNAL_CLOCK&lt;/code&gt;, &lt;code&gt;MIDI_SYNC&lt;/code&gt;, and &lt;code&gt;MIDI_TIME_CODE&lt;/code&gt;. The latter two work if the sequencer receives MIDI messages from another device. In these two modes, the sequencer's time gets reset based on system real-time timing clock messages or MIDI time code (MTC) messages, respectively. These two modes can also be used as slave modes, in which case the sequencer sends the corresponding types of MIDI messages to its receiver (whether or not the sequencer is also receiving them from a master). A fourth mode, &lt;code&gt;NO_SYNC&lt;/code&gt;, is used to indicate that the sequencer should not control its receiver's timing.</source>
          <target state="translated">시퀀서의 가능한 마스터를 지정하는 사전 정의 된 세 가지 모드가 있습니다 : &lt;code&gt;INTERNAL_CLOCK&lt;/code&gt; , &lt;code&gt;MIDI_SYNC&lt;/code&gt; 및 &lt;code&gt;MIDI_TIME_CODE&lt;/code&gt; . 후자는 시퀀서가 다른 장치에서 MIDI 메시지를 수신하면 작동합니다. 이 두 가지 모드에서 시퀀서의 시간은 각각 시스템 실시간 타이밍 클럭 메시지 또는 MIDI 타임 코드 (MTC) 메시지에 따라 재설정됩니다. 이 두 가지 모드는 슬레이브 모드로도 사용할 수 있습니다.이 경우 시퀀서는 해당 유형의 MIDI 메시지를 리시버로 보냅니다 (시퀀서도 마스터에서 수신하는지 여부). 네 번째 모드 인 &lt;code&gt;NO_SYNC&lt;/code&gt; 는 시퀀서가 수신기의 타이밍을 제어해서는 안됨을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9f4282a0141a82a2de17fffc9351d57e318a288" translate="yes" xml:space="preserve">
          <source>There are three ways in which connection request controls are set:</source>
          <target state="translated">연결 요청 제어는 세 가지 방법으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b25b98bbf1bed6a0ab1c73f9a3229fba6803ca" translate="yes" xml:space="preserve">
          <source>There are two basic models of what attributes should be associated with. First, attributes may be directly associated with a DirContext object. In this model, an attribute operation on the named object is roughly equivalent to a lookup on the name (which returns the DirContext object), followed by the attribute operation invoked on the DirContext object in which the caller supplies an empty name. The attributes can be viewed as being stored along with the object (note that this does not imply that the implementation must do so).</source>
          <target state="translated">어떤 속성을 연관시켜야하는지에 대한 두 가지 기본 모델이 있습니다. 먼저, 속성은 DirContext 객체와 직접 연관 될 수 있습니다. 이 모델에서, 명명 된 객체에 대한 속성 연산은 이름에 대한 조회 (DirContext 객체를 반환 함)와 거의 동일하며 호출자가 빈 이름을 제공하는 DirContext 객체에 대해 호출 된 속성 연산이 뒤 따릅니다. 속성은 객체와 함께 저장된 것으로 볼 수 있습니다 (이것은 구현이 그렇게해야 함을 의미하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="6277a3c91d311327a3eead7b7d8b16a596430d2c" translate="yes" xml:space="preserve">
          <source>There are two broad categories of print data, client formatted print data and service formatted print data.</source>
          <target state="translated">클라이언트 형식 인쇄 데이터와 서비스 형식 인쇄 데이터의 두 가지 범주의 인쇄 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e053f696696474cc554e2ee656c6df0dd65d2bd6" translate="yes" xml:space="preserve">
          <source>There are two common implementations. &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; is a date-based implementation, storing years, months and days. &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is a time-based implementation, storing seconds and nanoseconds, but providing some access using other duration based units such as minutes, hours and fixed 24-hour days.</source>
          <target state="translated">일반적인 두 가지 구현이 있습니다. &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 은 년, 월 및 일을 저장하는 날짜 기반 구현입니다. &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 은 초와 나노초를 저장하는 시간 기반 구현이지만 분, 시간 및 고정 24 시간과 같은 다른 지속 시간 기반 단위를 사용하여 일부 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ebfd465408d113172e53262f7239645338b176ec" translate="yes" xml:space="preserve">
          <source>There are two distinguished supported locations (subtrees within the logical file system) where newly created files are placed: one for &lt;a href=&quot;../../tools/standardlocation#SOURCE_OUTPUT&quot;&gt;new source files&lt;/a&gt;, and one for &lt;a href=&quot;../../tools/standardlocation#CLASS_OUTPUT&quot;&gt;new class files&lt;/a&gt;. (These might be specified on a tool's command line, for example, using flags such as &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt;.) The actual locations for new source files and new class files may or may not be distinct on a particular run of the tool. Resource files may be created in either location. The methods for reading and writing resources take a relative name argument. A relative name is a non-null, non-empty sequence of path segments separated by &lt;code&gt;'/'&lt;/code&gt;; &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are invalid path segments. A valid relative name must match the &quot;path-rootless&quot; rule of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;, section 3.3.</source>
          <target state="translated">새로 작성된 파일이 배치되는 두 가지 구별되는 지원 위치 (논리 파일 시스템 내의 서브 트리)가 있습니다. 하나는 &lt;a href=&quot;../../tools/standardlocation#SOURCE_OUTPUT&quot;&gt;새 소스 파일&lt;/a&gt; 용이고 다른 하나는 &lt;a href=&quot;../../tools/standardlocation#CLASS_OUTPUT&quot;&gt;새 클래스 파일 용&lt;/a&gt; 입니다. (예를 들어, &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 와 같은 플래그를 사용하여 도구의 명령 행에 지정할 수 있습니다 .) 새 소스 파일 및 새 클래스 파일의 실제 위치는 특정 도구 실행에서 구별되거나 구분되지 않을 수 있습니다. 리소스 파일은 어느 위치 에나 생성 될 수 있습니다. 리소스를 읽고 쓰는 방법에는 상대적인 이름 인수가 사용됩니다. 상대 이름은 &lt;code&gt;'/'&lt;/code&gt; 로 구분 된 null이 아닌 비어 있지 않은 경로 세그먼트 시퀀스입니다 . &lt;code&gt;'.'&lt;/code&gt; 그리고 &lt;code&gt;'..'&lt;/code&gt; 유효하지 않은 경로 세그먼트입니다. 유효한 상대 이름은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; 의 &quot;path-rootless&quot;규칙 , 섹션 3.3 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72119fc16750a087fcef97d6993f73e9c9d8b934" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on the interface directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 동등한 방법이 두 가지 있습니다. 첫 번째는 인터페이스에서 직접 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="122c9761aea7bb48c6b202253cc10ffaf3858a78" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalAdjuster&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 사용하는 동등한 방법이 두 가지 있습니다. 첫 번째는이 인터페이스에서 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="221c7636be87b0733017baa83864b434059c108b" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using a &lt;code&gt;TemporalQuery&lt;/code&gt;. The first is to invoke the method on this interface directly. The second is to use &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;TemporalQuery&lt;/code&gt; 를 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 인터페이스에서 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4f6ddab868b4d8af37cbc5e13d59377eb7bc1e1b" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9a9f36371a08c9e03929b3d371a732fe25c15a1a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="19622de3e1de5aa717583d3f58905f5525534b2a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;Temporal.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7049dde645017bc74c4cfbcd545b88a0f9312c" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;Temporal.until(Temporal, TemporalUnit)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14641be0ebbb10666cf02dfef66e60e2e24f19de" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="23c7abacd277c7c67a02cfdac67f8ec2ddb1e2a7" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d131f4265fdeb909d228a96a8cfb3506d44f7ffe" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#getLong-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#getLong-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.getLong(TemporalField)&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.get(TemporalField)&lt;/code&gt; &lt;/a&gt; )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="69e761971c5e4cae8513f296453b2fac6111a7fc" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.isSupported(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7a30794131e2de9a5dbaf4c9a1f6157f885e685a" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt;&lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#query-java.time.temporal.TemporalQuery-&quot;&gt; &lt;code&gt;TemporalAccessor.query(TemporalQuery)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b82d66ee70b01eb4f8a3cda3c1d15d8275ac3e27" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;TemporalAccessor.range(TemporalField)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f81056ea2c2becde1c2107f4139e24e0e6b5fd30" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use &lt;a href=&quot;temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 직접 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01700b17f3c068ac68e900641c6f6a6834b85ea7" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;../temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;../temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c69dd529f917ee2a2e64e1fed358cbede056afdf" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;period#between-java.time.LocalDate-java.time.LocalDate-&quot;&gt;&lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;period#between-java.time.LocalDate-java.time.LocalDate-&quot;&gt; &lt;code&gt;Period.between(LocalDate, LocalDate)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31b6839d92a1d7cc91a6f3682b7584519c917ea6" translate="yes" xml:space="preserve">
          <source>There are two equivalent ways of using this method. The first is to invoke this method. The second is to use &lt;a href=&quot;temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법을 사용하는 두 가지 동등한 방법이 있습니다. 첫 번째는이 메소드를 호출하는 것입니다. 두 번째는 &lt;a href=&quot;temporal/temporalunit#between-java.time.temporal.Temporal-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7019f051004e11b6b00277ad3a368c81695ab5e" translate="yes" xml:space="preserve">
          <source>There are two forms for RMI connector addresses:</source>
          <target state="translated">RMI 커넥터 주소에는 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53aaf7a78abd414d9fb78d865d3dc8bfb49f2f5" translate="yes" xml:space="preserve">
          <source>There are two general types of decoding errors. If the input byte sequence is not legal for this charset then the input is considered</source>
          <target state="translated">디코딩 오류에는 두 가지 일반적인 유형이 있습니다. 입력 바이트 순서가이 캐릭터 세트에 적합하지 않은 경우, 입력이 고려됩니다</target>
        </trans-unit>
        <trans-unit id="8736c93a7b7bb502b162e668f9dc8978cdb0b6fc" translate="yes" xml:space="preserve">
          <source>There are two general types of encoding errors. If the input character sequence is not a legal sixteen-bit Unicode sequence then the input is considered</source>
          <target state="translated">인코딩 오류에는 두 가지 일반적인 유형이 있습니다. 입력 문자 시퀀스가 ​​올바른 16 비트 유니 코드 시퀀스가 ​​아닌 경우 입력이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="bd7ebb4ee3bd1aaafa978527a6396c0b5c9c4cf7" translate="yes" xml:space="preserve">
          <source>There are two groups of cipher suites which you will need to know about when managing cipher suites:</source>
          <target state="translated">암호화 제품군을 관리 할 때 알아야 할 두 가지 암호화 제품군 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e94429dce8a0432578760912963aff83ad3eb1" translate="yes" xml:space="preserve">
          <source>There are two kinds of JNDI resource files: &lt;em&gt;provider&lt;/em&gt; and &lt;em&gt;application&lt;/em&gt;.</source>
          <target state="translated">JNDI 자원 파일에는 &lt;em&gt;provider&lt;/em&gt; 및 &lt;em&gt;application&lt;/em&gt; 의 두 가지 종류가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1f12fecd42a80e7f754001eddff6ff78d61515c" translate="yes" xml:space="preserve">
          <source>There are two kinds of transformers, determined by the &lt;code&gt;canRetransform&lt;/code&gt; parameter of &lt;a href=&quot;instrumentation#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-&quot;&gt;&lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;instrumentation#addTransformer-java.lang.instrument.ClassFileTransformer-boolean-&quot;&gt; &lt;code&gt;Instrumentation.addTransformer(ClassFileTransformer,boolean)&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;canRetransform&lt;/code&gt; 매개 변수에 의해 결정되는 두 종류의 변환기가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80be071c6ecd97b5c0ebef1df8ee841bd2ad1fb8" translate="yes" xml:space="preserve">
          <source>There are two other possible locale sensitive service providers, i.e., &quot;CLDR&quot; which is a provider based on Unicode Consortium's &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;CLDR Project&lt;/a&gt;, and &quot;HOST&quot; which is a provider that reflects the user's custom settings in the underlying operating system. These two providers may not be available, depending on the Java Runtime Environment implementation. Specifying &quot;JRE,SPI&quot; is identical to the default behavior, which is compatibile with the prior releases.</source>
          <target state="translated">로케일에 민감한 두 가지 다른 서비스 공급자, 즉 유니 코드 컨소시엄의 &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;CLDR 프로젝트를&lt;/a&gt; 기반으로하는 공급자 인 &quot;CLDR&quot; 과 기본 운영 체제에서 사용자의 사용자 지정 설정을 반영하는 공급자 인 &quot;HOST&quot;가 있습니다. Java Runtime Environment 구현에 따라이 두 제공자를 사용하지 못할 수 있습니다. &quot;JRE, SPI&quot;를 지정하는 것은 이전 릴리스와 호환되는 기본 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ff12985c6611d7ceaf5b220dd6a1ef040dc0377c" translate="yes" xml:space="preserve">
          <source>There are two possible ways in which this decoder could deal with illegal strings. It could either leave illegal characters alone or it could throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;. Which approach the decoder takes is left to the implementation.</source>
          <target state="translated">이 디코더가 잘못된 문자열을 처리 할 수있는 두 가지 방법이 있습니다. 잘못된 문자를 그대로 두거나 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킬 수 있습니다. 디코더가 취하는 접근법은 구현에 맡겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91ceedcd52bc4240b139aedacb18606cb46b462" translate="yes" xml:space="preserve">
          <source>There are two separate trees of preference nodes, one for user preferences and one for system preferences. Each user has a separate user preference tree, and all users in a given system share the same system preference tree. The precise description of &quot;user&quot; and &quot;system&quot; will vary from implementation to implementation. Typical information stored in the user preference tree might include font choice, color choice, or preferred window location and size for a particular application. Typical information stored in the system preference tree might include installation configuration data for an application.</source>
          <target state="translated">환경 설정 노드에는 사용자 환경 설정과 시스템 환경 설정을위한 두 개의 별도 트리가 있습니다. 각 사용자에게는 별도의 사용자 기본 설정 트리가 있으며 지정된 시스템의 모든 사용자는 동일한 시스템 기본 설정 트리를 공유합니다. &quot;사용자&quot;및 &quot;시스템&quot;에 대한 정확한 설명은 구현마다 다릅니다. 사용자 기본 설정 트리에 저장된 일반적인 정보에는 글꼴 선택, 색상 선택 또는 특정 응용 프로그램의 기본 창 위치 및 크기가 포함될 수 있습니다. 시스템 환경 설정 트리에 저장된 일반 정보에는 응용 프로그램의 설치 구성 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6202432717df2ac02cb63931bf58fa0f63cab202" translate="yes" xml:space="preserve">
          <source>There are two situations where this query may return a non-zero period.</source>
          <target state="translated">이 쿼리가 0이 아닌 기간을 반환 할 수있는 두 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e75919a8d6dc8a964f582e10611fcfefe5d1d7" translate="yes" xml:space="preserve">
          <source>There are two types of filtering: filtering for basic language ranges (called &quot;basic filtering&quot;) and filtering for extended language ranges (called &quot;extended filtering&quot;). They may return different results by what kind of language ranges are included in the given Language Priority List. &lt;a href=&quot;locale.filteringmode&quot;&gt;&lt;code&gt;Locale.FilteringMode&lt;/code&gt;&lt;/a&gt; is a parameter to specify how filtering should be done.</source>
          <target state="translated">기본 언어 범위 필터링 ( &quot;기본 필터링&quot;)과 확장 언어 범위 필터링 ( &quot;확장 필터링&quot;)의 두 가지 필터링 유형이 있습니다. 주어진 언어 우선 순위 목록에 포함 된 언어 범위에 따라 다른 결과를 반환 할 수 있습니다. &lt;a href=&quot;locale.filteringmode&quot;&gt; &lt;code&gt;Locale.FilteringMode&lt;/code&gt; &lt;/a&gt; 는 필터링 방법을 지정하는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="863bb4e82b05433afe02f4bff6c94f9fcbaf46be" translate="yes" xml:space="preserve">
          <source>There are two types of language ranges: basic and extended. In RFC 4647, the syntax of language ranges is expressed in &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; as follows:</source>
          <target state="translated">언어 범위에는 기본과 확장의 두 가지 유형이 있습니다. RFC 4647에서 언어 범위의 구문은 다음과 같이 &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="03767c30c8b687a49d6fbdbfbb2ec538574b74af" translate="yes" xml:space="preserve">
          <source>There are two types of request controls:</source>
          <target state="translated">요청 제어에는 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2fda0a5c05f0d77dfca57e037365613258cde0a" translate="yes" xml:space="preserve">
          <source>There are two ways in which a context instance gets its request controls:</source>
          <target state="translated">컨텍스트 인스턴스가 요청 제어를 얻는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="975a7b038db4eb6bf41059eceb7313d6dd42998b" translate="yes" xml:space="preserve">
          <source>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This subclass should override the &lt;code&gt;run&lt;/code&gt; method of class &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be allocated and started. For example, a thread that computes primes larger than a stated value could be written as follows:</source>
          <target state="translated">새로운 실행 스레드를 작성하는 두 가지 방법이 있습니다. 하나는 클래스를 &lt;code&gt;Thread&lt;/code&gt; 의 서브 클래스로 선언하는 것 입니다. 이 서브 클래스는 &lt;code&gt;Thread&lt;/code&gt; 클래스 의 &lt;code&gt;run&lt;/code&gt; 메소드를 대체해야합니다 . 그런 다음 서브 클래스의 인스턴스를 할당하고 시작할 수 있습니다. 예를 들어, 명시된 값보다 큰 소수를 계산하는 스레드는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1130822317a86f6e57038bd5122e8e2e69d189a3" translate="yes" xml:space="preserve">
          <source>There are two ways to create an MBean. One is to construct a Java object that will be the MBean, then use the &lt;a href=&quot;mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt;&lt;code&gt;registerMBean&lt;/code&gt;&lt;/a&gt; method to register it in the MBean Server. The other is to create and register the MBean in a single operation using one of the &lt;a href=&quot;mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-&quot;&gt;&lt;code&gt;createMBean&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">MBean을 작성하는 방법에는 두 가지가 있습니다. 하나는 MBean이 될 Java 객체를 구성한 다음 &lt;a href=&quot;mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt; &lt;code&gt;registerMBean&lt;/code&gt; &lt;/a&gt; 메소드를 사용 하여 MBean 서버에 등록하는 것입니다. 다른 하나는 &lt;a href=&quot;mbeanserver#createMBean-java.lang.String-javax.management.ObjectName-&quot;&gt; &lt;code&gt;createMBean&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 사용하여 단일 조작으로 MBean을 작성하고 등록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f02bb82aa08947d1c4db6345575e9a9a9391eb79" translate="yes" xml:space="preserve">
          <source>There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</source>
          <target state="translated">키 쌍을 생성하는 방법에는 알고리즘 독립적 방식과 알고리즘 특정 방식의 두 가지가 있습니다. 이 둘의 유일한 차이점은 객체의 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="fc8284f153af11fa26dc2b9e2c9486fe94b0031e" translate="yes" xml:space="preserve">
          <source>There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</source>
          <target state="translated">키를 생성하는 방법에는 알고리즘 독립적 방식과 알고리즘 특정 방식의 두 가지가 있습니다. 이 둘의 유일한 차이점은 객체의 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="159241de6eb6c0aad925571d76835e03dc536a22" translate="yes" xml:space="preserve">
          <source>There are two ways to make a Java object that is an MBean with this management interface. One is for the object to be of a class that has exactly the same name as the Java interface but without the &lt;code&gt;MBean&lt;/code&gt; suffix. So in the example the object would be of the class &lt;code&gt;Configuration&lt;/code&gt;, in the same Java package as &lt;code&gt;ConfigurationMBean&lt;/code&gt;. The second way is to use the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 관리 인터페이스를 사용하여 MBean 인 Java 오브젝트를 작성하는 방법에는 두 가지가 있습니다. 하나는 객체가 Java 인터페이스와 이름은 동일하지만 &lt;code&gt;MBean&lt;/code&gt; 접미어가 없는 클래스가되는 것입니다 . 그래서 예에서 객체는 클래스의 것 &lt;code&gt;Configuration&lt;/code&gt; 과 같은 Java 패키지에, &lt;code&gt;ConfigurationMBean&lt;/code&gt; . 두 번째 방법은 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90012bb7cf1245412cbc193a80e9ac8ba45df7dd" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain an instance of the &lt;code&gt;Instrumentation&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;Instrumentation&lt;/code&gt; 인터페이스 의 인스턴스를 얻는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="771a213e98d7cf68dc3b44a652ef624310ae5943" translate="yes" xml:space="preserve">
          <source>There are two ways to set a &lt;code&gt;Calendar&lt;/code&gt; to a date-time value. One is to set the instant parameter to a millisecond offset from the &lt;a href=&quot;calendar#Epoch&quot;&gt;Epoch&lt;/a&gt;. The other is to set individual field parameters, such as &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt;, to their desired values. These two ways can't be mixed. Trying to set both the instant and individual fields will cause an &lt;a href=&quot;../lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; to be thrown. However, it is permitted to override previous values of the instant or field parameters.</source>
          <target state="translated">&lt;code&gt;Calendar&lt;/code&gt; 을 날짜-시간 값 으로 설정하는 방법에는 두 가지가 있습니다 . 하나는 instant 매개 변수를 &lt;a href=&quot;calendar#Epoch&quot;&gt;Epoch&lt;/a&gt; 에서 밀리 초 오프셋으로 설정하는 것 입니다. 다른 하나는 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 와 같은 개별 필드 매개 변수 를 원하는 값으로 설정하는 것입니다. 이 두 가지 방법은 섞을 수 없습니다. 인스턴트 필드와 개별 ​​필드를 모두 설정하려고하면 &lt;a href=&quot;../lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 그러나 인스턴트 또는 필드 매개 변수의 이전 값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c4aa4c3dad5442ad3148498e9b2b89e070dc8d" translate="yes" xml:space="preserve">
          <source>There are various ways to handle the conversion from a &lt;code&gt;LocalDateTime&lt;/code&gt;. One technique, using this method, would be:</source>
          <target state="translated">&lt;code&gt;LocalDateTime&lt;/code&gt; 에서 변환을 처리하는 방법에는 여러 가지가 있습니다 . 이 방법을 사용하는 한 가지 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3918cb605e7d0c3c6f2663575261375e1b19245" translate="yes" xml:space="preserve">
          <source>There are, however, some limited use cases where users believe they need to store and use dates in arbitrary calendar systems throughout the application. This is supported by &lt;a href=&quot;chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt;, however it is vital to read all the associated warnings in the Javadoc of that interface before using it. In summary, applications that require general interoperation between multiple calendar systems typically need to be written in a very different way to those only using the ISO calendar, thus most applications should just use ISO and avoid &lt;code&gt;ChronoLocalDate&lt;/code&gt;.</source>
          <target state="translated">그러나 사용자가 응용 프로그램 전체에서 임의의 달력 시스템에 날짜를 저장하고 사용해야한다고 생각하는 일부 사용 사례가 있습니다. 이것은 &lt;a href=&quot;chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 에서 지원 되지만 사용하기 전에 해당 인터페이스의 Javadoc에서 모든 관련 경고를 읽어야합니다. 요약하면, 여러 달력 시스템간에 일반적인 상호 운용이 필요한 응용 프로그램은 일반적으로 ISO 달력을 사용하는 응용 프로그램과는 매우 다른 방식으로 작성해야하므로 대부분의 응용 프로그램은 ISO 만 사용하고 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 를 피해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="ad68c71cd005733d3d27a578116ef8c19e4d7ff1" translate="yes" xml:space="preserve">
          <source>There can be different implementations of &lt;code&gt;Name&lt;/code&gt;; for example, composite names, URLs, or namespace-specific compound names.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 의 다른 구현이있을 수 있습니다 . 예를 들어 복합 이름, URL 또는 네임 스페이스 별 복합 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ce433d14a2eedfbb470ac526e7184d30f9308adf" translate="yes" xml:space="preserve">
          <source>There exist different variants of these global identifiers. The methods of this class are for manipulating the Leach-Salz variant, although the constructors allow the creation of any variant of UUID (described below).</source>
          <target state="translated">이러한 전역 식별자에는 다양한 변형이 있습니다. 이 클래스의 메소드는 Leach-Salz 변형을 조작하기위한 것이지만 생성자는 UUID의 변형 (아래 설명 참조)을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbdeb2575b41cbcf1a0c50743f59d79e06e928f0" translate="yes" xml:space="preserve">
          <source>There is a buffer class for each non-boolean primitive type. Each class defines a family of</source>
          <target state="translated">부울이 아닌 기본 유형마다 버퍼 클래스가 있습니다. 각 클래스는</target>
        </trans-unit>
        <trans-unit id="e611c9ca26ee759c4b00b3f9330825ec933eabb1" translate="yes" xml:space="preserve">
          <source>There is a couple of System Properties affecting how IPv4 and IPv6 addresses are used.</source>
          <target state="translated">IPv4 및 IPv6 주소 사용 방법에 영향을주는 몇 가지 시스템 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e457efe2a17a4c04ee89e9b13d9382d5d98aca7c" translate="yes" xml:space="preserve">
          <source>There is a distinction between an attribute's Java language type, as returned by &lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt;&lt;code&gt;getType()&lt;/code&gt;&lt;/a&gt;, and its &lt;code&gt;OpenType&lt;/code&gt;, as returned by &lt;a href=&quot;openmbeanparameterinfo#getOpenType--&quot;&gt;&lt;code&gt;getOpenType()&lt;/code&gt;&lt;/a&gt;. For example, if the Java language type is &lt;code&gt;java.lang.String&lt;/code&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be &lt;a href=&quot;simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.String&lt;/code&gt;&lt;/a&gt;. If the Java language type is &lt;a href=&quot;compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;OpenType&lt;/code&gt; will be a &lt;a href=&quot;compositetype&quot;&gt;&lt;code&gt;CompositeType&lt;/code&gt;&lt;/a&gt; that describes the items in the &lt;code&gt;CompositeData&lt;/code&gt; instances for the attribute.</source>
          <target state="translated">&lt;a href=&quot;../mbeanattributeinfo#getType--&quot;&gt; &lt;code&gt;getType()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 속성의 Java 언어 유형 과 &lt;a href=&quot;openmbeanparameterinfo#getOpenType--&quot;&gt; &lt;code&gt;getOpenType()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 &lt;code&gt;OpenType&lt;/code&gt; 사이에는 차이가 있습니다 . 예를 들어, Java 언어 유형이 &lt;code&gt;java.lang.String&lt;/code&gt; 인 경우 &lt;code&gt;OpenType&lt;/code&gt; 은 &lt;a href=&quot;simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.String&lt;/code&gt; &lt;/a&gt; 입니다. Java 언어 유형이 &lt;a href=&quot;compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;OpenType&lt;/code&gt; 은 속성 에 대한 &lt;code&gt;CompositeData&lt;/code&gt; 인스턴스 의 항목을 설명 하는 &lt;a href=&quot;compositetype&quot;&gt; &lt;code&gt;CompositeType&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="47ec9ff2dff4067d12469aae62647665afd970c0" translate="yes" xml:space="preserve">
          <source>There is a one-to-one mapping between keys and identities, and there can only be one copy of one key per scope. For example, suppose &lt;b&gt;Acme Software, Inc&lt;/b&gt; is a software publisher known to a user. Suppose it is an Identity, that is, it has a public key, and a set of associated certificates. It is named in the scope using the name &quot;Acme Software&quot;. No other named Identity in the scope has the same public key. Of course, none has the same name as well.</source>
          <target state="translated">키와 ID간에 ​​일대일 매핑이 있으며 범위 당 하나의 키 사본 만있을 수 있습니다. 예를 들어 &lt;b&gt;Acme Software, Inc&lt;/b&gt; 는 사용자에게 알려진 소프트웨어 게시자라고 가정 합니다. 아이덴티티, 즉 공개 키와 관련 인증서 세트가 있다고 가정하십시오. &quot;Acme Software&quot;라는 이름을 사용하여 범위에서 명명됩니다. 범위 내에서 이름이 지정된 다른 Identity는 동일한 공개 키를 갖지 않습니다. 물론 같은 이름을 가진 사람은 없습니다.</target>
        </trans-unit>
        <trans-unit id="54e8a1cf0a979c6bead49e4451cc625e0cb7132c" translate="yes" xml:space="preserve">
          <source>There is a one-to-one mapping between the distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; values and the result of this conversion. That is, every distinguishable &lt;code&gt;BigDecimal&lt;/code&gt; value (unscaled value and scale) has a unique string representation as a result of using &lt;code&gt;toString&lt;/code&gt;. If that string representation is converted back to a &lt;code&gt;BigDecimal&lt;/code&gt; using the &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor, then the original value will be recovered.</source>
          <target state="translated">식별 가능한 &lt;code&gt;BigDecimal&lt;/code&gt; 값과이 변환 결과 사이에는 일대일 맵핑 이 있습니다. 즉, 식별 가능한 모든 &lt;code&gt;BigDecimal&lt;/code&gt; 값 (스케일링되지 않은 값 및 스케일)은 &lt;code&gt;toString&lt;/code&gt; 사용의 결과로 고유 한 문자열 표현을 갖습니다 . 해당 문자열 표현은로 변환 다시 경우 &lt;code&gt;BigDecimal&lt;/code&gt; 은 Using &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 생성자는, 원의 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="07a170e47ba1b28632f7de6a7126103d894a204e" translate="yes" xml:space="preserve">
          <source>There is a single global LogManager object that is used to maintain a set of shared state about Loggers and log services.</source>
          <target state="translated">로거 및 로그 서비스에 대한 공유 상태 세트를 유지하는 데 사용되는 단일 글로벌 LogManager 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f6696f8357f83f1e4bc66cdc5dac5cd0bb4624" translate="yes" xml:space="preserve">
          <source>There is a single global instance of the &lt;code&gt;LoggingMXBean&lt;/code&gt;. This instance is an &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; that can be obtained by calling the &lt;a href=&quot;logmanager#getLoggingMXBean--&quot;&gt;&lt;code&gt;LogManager.getLoggingMXBean()&lt;/code&gt;&lt;/a&gt; method or from the &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt;platform &lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LoggingMXBean&lt;/code&gt; 의 단일 글로벌 인스턴스가 있습니다. 이 인스턴스는 &lt;a href=&quot;logmanager#getLoggingMXBean--&quot;&gt; &lt;code&gt;LogManager.getLoggingMXBean()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하거나 &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMBeanServer--&quot;&gt;플랫폼 &lt;/a&gt; &lt;code&gt;MBeanServer&lt;/code&gt; 에서 확보 할 수 있는 &lt;a href=&quot;../../../javax/management/mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1db9183d0fe9302b767e7cc23a636f50f0a9febc" translate="yes" xml:space="preserve">
          <source>There is a single global instance of the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;. The &lt;a href=&quot;managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt;&lt;/a&gt; method can be used to obtain the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; object as follows:</source>
          <target state="translated">&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 의 단일 글로벌 인스턴스가 있습니다. &lt;a href=&quot;managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt; &lt;/a&gt; 방법은 취득 할 수 &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 다음 개체 :</target>
        </trans-unit>
        <trans-unit id="ef852b41e85d5b8d7d0516574ed1e5208aad1805" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetDestinationOffset&lt;/code&gt; method; simply call &lt;code&gt;setDestinationOffset(new Point(0, 0))&lt;/code&gt; to restore default values.</source>
          <target state="translated">&lt;code&gt;unsetDestinationOffset&lt;/code&gt; 메소드 는 없습니다 . 단순히 &lt;code&gt;setDestinationOffset(new Point(0, 0))&lt;/code&gt; 을 호출 하여 기본값을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="75fe41e0afde47fd04c96028c6e0c36054c90aa2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetSourceProgressivePasses&lt;/code&gt; method; the same effect may be obtained by calling &lt;code&gt;setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsetSourceProgressivePasses&lt;/code&gt; 메소드 가 없습니다 . &lt;code&gt;setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code&gt; 호출하여 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3c1caf12670f746761a1a308b04f8a646c8f65" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;unsetSourceSubsampling&lt;/code&gt; method; simply call &lt;code&gt;setSourceSubsampling(1, 1, 0, 0)&lt;/code&gt; to restore default values.</source>
          <target state="translated">&lt;code&gt;unsetSourceSubsampling&lt;/code&gt; 메소드 는 없습니다 . 간단히 &lt;code&gt;setSourceSubsampling(1, 1, 0, 0)&lt;/code&gt; 을 호출 하여 기본값을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4f6a6600ccefd5bc95c8181388c200994df259" translate="yes" xml:space="preserve">
          <source>There is no embedded flag character for enabling canonical equivalence.</source>
          <target state="translated">정식 등가를 가능하게하는 내장 플래그 문자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c437702dae33f4479582f804dd1b9271378f690" translate="yes" xml:space="preserve">
          <source>There is no embedded flag character for enabling literal parsing.</source>
          <target state="translated">리터럴 파싱을 활성화하기위한 내장 된 플래그 문자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2476cd0e3a3386674e0ed89def19edc4b13b242e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about when the &lt;code&gt;MemoryMXBean&lt;/code&gt; will emit a threshold notification and when the notification will be delivered. When a notification listener is invoked, the memory usage of the memory pool may have crossed the usage threshold more than once. The &lt;a href=&quot;memorynotificationinfo#getCount--&quot;&gt;&lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt;&lt;/a&gt; method returns the number of times that the memory usage has crossed the usage threshold at the point in time when the notification was constructed. It can be compared with the current usage threshold count returned by the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method to determine if such situation has occurred.</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 이 임계 값 알림을 발행 하는 시기 와 알림이 전달 될 시기 에 대한 보장은 없습니다 . 알림 리스너가 호출되면 메모리 풀의 메모리 사용량이 사용량 임계 값을 두 번 이상 초과했을 수 있습니다. &lt;a href=&quot;memorynotificationinfo#getCount--&quot;&gt; &lt;code&gt;MemoryNotificationInfo.getCount()&lt;/code&gt; &lt;/a&gt; 메소드는, 통지가 구축되었을 때의 메모리 사용량이 시점에서 사용량 임계치를 넘은 회수를 돌려줍니다. &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 현재 사용 임계 값 계수와 비교하여 이러한 상황이 발생했는지 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d60f97f9703f42d93a54253e7d22123ed3faa9b8" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the &lt;code&gt;asType&lt;/code&gt; call is actually made. If the JVM can predict the results of making the call, it may perform adaptations directly on the caller's arguments, and call the target method handle according to its own exact type.</source>
          <target state="translated">&lt;code&gt;asType&lt;/code&gt; 호출이 실제로 이루어 졌다는 보장은 없습니다 . JVM이 호출 결과를 예측할 수 있으면 호출자의 인수에 대해 직접 적응을 수행하고 고유 한 정확한 유형에 따라 대상 메소드 핸들을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563bedb54b5f2fda07232672d28d980b59e9cdfa" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not, in particular, guaranteed to appear in alphabetical order.</source>
          <target state="translated">결과 배열의 이름 문자열이 특정 순서로 나타날 것이라는 보장은 없습니다. 특히 알파벳 순서로 표시되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4b5307904581616c49620a8afa65d4a7ad0b81a2" translate="yes" xml:space="preserve">
          <source>There is no limit on the amount of data that may be written, so use this with care.</source>
          <target state="translated">기록 될 수있는 데이터의 양에는 제한이 없으므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="caa61a6745a38d47cfa3d5d57583320bc8d9204d" translate="yes" xml:space="preserve">
          <source>There is no limit to integer digits set by this routine, since that is the typical end-user desire; use setMaximumInteger if you want to set a real value. For negative numbers, use a second pattern, separated by a semicolon</source>
          <target state="translated">이 루틴에 의해 설정된 정수 자릿수에는 제한이 없습니다. 이것이 일반적인 최종 사용자 요구이기 때문입니다. 실제 값을 설정하려면 setMaximumInteger를 사용하십시오. 음수의 경우 세미콜론으로 구분 된 두 번째 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="998f9151c1110aaa94300df3294ecd2bb59d3edc" translate="yes" xml:space="preserve">
          <source>There is no pathname transformation, except that the system file separator is replaced by the JAR file separator '/'.</source>
          <target state="translated">시스템 파일 구분 기호가 JAR 파일 구분 기호 '/'로 대체되는 것을 제외하고는 경로 이름 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="40cfd7dfadd3391c252abf3662f2ca699044a90b" translate="yes" xml:space="preserve">
          <source>There is no requirement for a compiler at runtime. However, if a default compiler is provided, it can be located using the &lt;a href=&quot;toolprovider&quot;&gt;ToolProvider&lt;/a&gt;, for example:</source>
          <target state="translated">런타임에는 컴파일러가 필요하지 않습니다. 그러나 기본 컴파일러가 제공되는 경우 &lt;a href=&quot;toolprovider&quot;&gt;ToolProvider를&lt;/a&gt; 사용하여 찾을 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="e86520d525eca5d9dc11030c4679128fdfa1c011" translate="yes" xml:space="preserve">
          <source>There is no requirement that a distinct result be returned each time the supplier is invoked.</source>
          <target state="translated">공급 업체가 호출 될 때마다 고유 한 결과가 반환 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="198941742d95f771d09454ad8b8b1eb431801562" translate="yes" xml:space="preserve">
          <source>There is no requirement that a new or distinct result be returned each time the supplier is invoked.</source>
          <target state="translated">공급 업체가 호출 될 때마다 새롭거나 고유 한 결과가 반환 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ac505bd21b647e3b0d66513534387f91f440e63" translate="yes" xml:space="preserve">
          <source>There is no requirement that a process represented by a &lt;code&gt;Process&lt;/code&gt; object execute asynchronously or concurrently with respect to the Java process that owns the &lt;code&gt;Process&lt;/code&gt; object.</source>
          <target state="translated">a로 표현하는 과정한다는 요구 사항이 없습니다 &lt;code&gt;Process&lt;/code&gt; 개체가 소유하는 Java 프로세스와 비동기 적으로 또는 동시에 실행 &lt;code&gt;Process&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="6bb1589cbaa1bcec5ff870e1e9b12d1f77370ebe" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">허가를 해제하는 스레드가 &lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 허가를 획득해야 할 필요는 없습니다 . 세마포어의 올바른 사용법은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d19982f377f29e5caf430a892cc8364a3737d224" translate="yes" xml:space="preserve">
          <source>There is no requirement that a thread that releases a permit must have acquired that permit by calling &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire&lt;/code&gt;&lt;/a&gt;. Correct usage of a semaphore is established by programming convention in the application.</source>
          <target state="translated">허가를 해제하는 스레드가 &lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 허가를 획득해야 할 필요는 없습니다 . 세마포어의 올바른 사용법은 응용 프로그램의 프로그래밍 규칙에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1210cbd94c899524cbebe37d1b7a14d3758c7b6" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same doc. Therefore, all implementations of interface Doc must be designed to be multiple thread safe.</source>
          <target state="translated">동일한 문서에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 모든 Doc 인터페이스 구현은 다중 스레드 안전하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="54d1bdd3c5393ebf87fe28c474c4187eeec91d09" translate="yes" xml:space="preserve">
          <source>There is no restriction on the number of client threads that may be simultaneously accessing the same multidoc. Therefore, all implementations of interface MultiDoc must be designed to be multiple thread safe. In fact, a client thread could be adding docs to the end of the (conceptual) list while a Print Job thread is simultaneously obtaining docs from the beginning of the list; provided the multidoc object synchronizes the threads properly, the two threads will not interfere with each other</source>
          <target state="translated">동일한 멀티 도크에 동시에 액세스 할 수있는 클라이언트 스레드 수에는 제한이 없습니다. 따라서 MultiDoc 인터페이스의 모든 구현은 다중 스레드 안전을 갖도록 설계되어야합니다. 실제로, 클라이언트 스레드는 (개념적) 목록의 끝에 문서를 추가하는 반면 인쇄 작업 스레드는 목록의 처음부터 문서를 동시에 가져옵니다. multidoc 객체가 스레드를 올바르게 동기화하면 두 스레드가 서로 간섭하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b4a3972e1a2f7f3338a732047fe875411d8907" translate="yes" xml:space="preserve">
          <source>There is no restriction on the value of &lt;code&gt;fromIndex&lt;/code&gt;. If it is negative, it has the same effect as if it were zero: this entire string may be searched. If it is greater than the length of this string, it has the same effect as if it were equal to the length of this string: &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;fromIndex&lt;/code&gt; 값에는 제한이 없습니다 . 음수이면 0 인 것과 같은 효과를 갖습니다.이 전체 문자열을 검색 할 수 있습니다. 이 문자열의 길이보다 큰 경우이 문자열의 길이와 같은 효과를 갖습니다. &lt;code&gt;-1&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="41d4b46878c902aebcab2313c7f766261a893b1b" translate="yes" xml:space="preserve">
          <source>There is one circumstance under which &lt;code&gt;putSpi, removeSpi and childSpi&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;putSpi, removeSpi and childSpi&lt;/code&gt; 에는 한 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="514e11614a5cff7c22ae4d822f5dd9cd11012a75" translate="yes" xml:space="preserve">
          <source>There is one subclass of this class for each non-boolean primitive type.</source>
          <target state="translated">부울이 아닌 기본 유형마다이 클래스의 서브 클래스가 하나씩 있습니다.</target>
        </trans-unit>
        <trans-unit id="633f37c2f9ed69daba67e576cc65222c3b761eee" translate="yes" xml:space="preserve">
          <source>There is only one Configuration object installed in the runtime at any given time. A Configuration object can be installed by calling the &lt;code&gt;setConfiguration&lt;/code&gt; method. The installed Configuration object can be obtained by calling the &lt;code&gt;getConfiguration&lt;/code&gt; method.</source>
          <target state="translated">주어진 시간에 런타임에 하나의 구성 오브젝트 만 설치됩니다. &lt;code&gt;setConfiguration&lt;/code&gt; 메소드 를 호출하여 구성 오브젝트를 설치할 수 있습니다 . &lt;code&gt;getConfiguration&lt;/code&gt; 메소드 를 호출하여 설치된 구성 오브젝트를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70c5e4ecda10caf422eac93731e929117c0b2433" translate="yes" xml:space="preserve">
          <source>There is only one Policy object installed in the runtime at any given time. A Policy object can be installed by calling the &lt;code&gt;setPolicy&lt;/code&gt; method. The installed Policy object can be obtained by calling the &lt;code&gt;getPolicy&lt;/code&gt; method.</source>
          <target state="translated">주어진 시간에 런타임에 하나의 Policy 오브젝트 만 설치됩니다. &lt;code&gt;setPolicy&lt;/code&gt; 메소드 를 호출하여 Policy 오브젝트를 설치할 수 있습니다 . 설치된 Policy 오브젝트는 &lt;code&gt;getPolicy&lt;/code&gt; 메소드 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e8219f9fa1e5ad5fd8b7ff9a0008b52bda96130" translate="yes" xml:space="preserve">
          <source>There is some nonnegative integer</source>
          <target state="translated">음이 아닌 정수가 있습니다</target>
        </trans-unit>
        <trans-unit id="2567bf148c60cd0704ecaf928436c03eebe56e55" translate="yes" xml:space="preserve">
          <source>There're various ways user can hook up his own HTTP cookie management behavior, e.g.</source>
          <target state="translated">사용자가 자신의 HTTP 쿠키 관리 동작을 연결하는 다양한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8405dc8d6e96295949c0c54f86ccd888ec7eea86" translate="yes" xml:space="preserve">
          <source>These IDs are the string form of a &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 ID는 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 의 문자열 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="2ac6d107158b337a6c06b66cc752f623087b39c6" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameterGenerator&quot;&gt; AlgorithmParameterGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameterGenerator&quot;&gt;AlgorithmParameterGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2840e4cdcf1ea5e28eecc02068cd6e631114c12e" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameters&quot;&gt; AlgorithmParameters section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#AlgorithmParameters&quot;&gt;AlgorithmParameters 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7810b58cc40d92a27956a4ca52be2a76493d1bab" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt; KeyFactory section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;KeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a50f9efd915eeed3ad86d74499ef1250eabefdda" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyGenerator&quot;&gt; KeyGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyGenerator&quot;&gt;KeyGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="24c1f8a9dcc7a5506f057dba5d8bfbe7a8fd8ab2" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt; KeyPairGenerator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;KeyPairGenerator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="67fa782ff8eb29fae6354c59022ac3e4584f2bd2" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Mac&quot;&gt; Mac section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Mac&quot;&gt;Mac 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="df11e8427aa46377243a3bc2fdea20b313fc069f" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt; MessageDigest section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;MessageDigest 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d0b5ae813100c512f39daa5af7097e9f5e4bc52" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory&quot;&gt; SecretKeyFactory section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이러한 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory&quot;&gt;SecretKeyFactory 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fc5cf5ef0ceb706cddfb7a9b2c6fe158ff062a97" translate="yes" xml:space="preserve">
          <source>These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Signature&quot;&gt; Signature section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">These algorithms are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Signature&quot;&gt; Signature section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</target>
        </trans-unit>
        <trans-unit id="e0bd70779c56b886df3b68e00d621608fc2cd850" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007A'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007A'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진 (기수 16)의 자릿수는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce73c7a8bcb9b77ceb02b691c9f5e1120078896" translate="yes" xml:space="preserve">
          <source>These are &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007a'&lt;/code&gt;. If &lt;code&gt;radix&lt;/code&gt; is &lt;var&gt;N&lt;/var&gt;, then the first &lt;var&gt;N&lt;/var&gt; of these characters are used as radix-&lt;var&gt;N&lt;/var&gt; digits in the order shown. Thus, the digits for hexadecimal (radix 16) are &lt;code&gt;0123456789abcdef&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">이들은 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007a'&lt;/code&gt; 입니다. 경우 &lt;code&gt;radix&lt;/code&gt; 인 &lt;var&gt;N&lt;/var&gt; 을 한 후 제 &lt;var&gt;N&lt;/var&gt; 이 문자는 기수 -로서 사용되는 &lt;var&gt;N&lt;/var&gt; 에 도시 된 순서로 자리. 따라서 16 진 (기수 16)의 자릿수는 &lt;code&gt;0123456789abcdef&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1959b44b606d1297e43332ac44b1adaf84cdd4db" translate="yes" xml:space="preserve">
          <source>These are some of the Unicode characters for which this method returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">다음은이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 일부 유니 코드 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="fa0898612837a31f540bec1dccf10ba5ee8752d0" translate="yes" xml:space="preserve">
          <source>These are some of the points that must be considered before using this interface throughout an application.</source>
          <target state="translated">응용 프로그램 전체에서이 인터페이스를 사용하기 전에 고려해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b003314e199b67286aa0a74af0f5fe08230f55" translate="yes" xml:space="preserve">
          <source>These are the characters &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0037'&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0037'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08694341e216489e339c217c51678557a14dc442" translate="yes" xml:space="preserve">
          <source>These are the characters &lt;code&gt;'\u0030'&lt;/code&gt; through &lt;code&gt;'\u0039'&lt;/code&gt; and &lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u0066'&lt;/code&gt;. If uppercase letters are desired, the &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; method may be called on the result:</source>
          <target state="translated">문자 &lt;code&gt;'\u0030'&lt;/code&gt; ~ &lt;code&gt;'\u0039'&lt;/code&gt; 및 &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u0066'&lt;/code&gt; 입니다. 대문자가 필요한 경우 결과에서 &lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b100126a9566a5dfd6a5042da372581f55c4cf" translate="yes" xml:space="preserve">
          <source>These are used to set the initial settings for the initially displayed print service. Values which are not supported by the print service are ignored. As the user browses print services, attributes and values are copied to the new display. If a user browses a print service which does not support a particular attribute-value, the default for that service is used as the new value to be copied.</source>
          <target state="translated">초기에 표시되는 인쇄 서비스의 초기 설정을 설정하는 데 사용됩니다. 인쇄 서비스에서 지원하지 않는 값은 무시됩니다. 사용자가 인쇄 서비스를 탐색하면 속성과 값이 새 디스플레이에 복사됩니다. 사용자가 특정 속성 값을 지원하지 않는 인쇄 서비스를 탐색하면 해당 서비스의 기본값이 복사 할 새 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e8017b0b68c1f6f870bc8aa6a50aadf98ce71b6" translate="yes" xml:space="preserve">
          <source>These bulk operations accept a &lt;code&gt;parallelismThreshold&lt;/code&gt; argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; suppresses all parallelism. Using a value of &lt;code&gt;1&lt;/code&gt; results in maximal parallelism by partitioning into enough subtasks to fully utilize the &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;&lt;/a&gt; that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput.</source>
          <target state="translated">이러한 대량 작업은 &lt;code&gt;parallelismThreshold&lt;/code&gt; 인수를 허용합니다 . 현재 맵 크기가 주어진 임계 값보다 작은 것으로 추정되면 방법이 순차적으로 진행됩니다. &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 모든 병렬 처리가 억제됩니다. 값 &lt;code&gt;1&lt;/code&gt; 을 사용하면 모든 병렬 계산에 사용되는 &lt;a href=&quot;forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; &lt;/a&gt; 을 완전히 활용할 수 있도록 충분한 하위 작업으로 분할하여 최대 병렬 처리가 가능합니다 . 일반적으로 처음에는 이러한 극단적 인 값 중 하나를 선택한 다음 오버 헤드와 처리량을 모두 상쇄하는 중간 값을 사용하여 성능을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="61e99440ec085de26d7fa6b38952f9639f22cdf5" translate="yes" xml:space="preserve">
          <source>These callbacks are used when the default rules for URL hostname verification fail.</source>
          <target state="translated">이러한 콜백은 URL 호스트 이름 확인에 대한 기본 규칙이 실패 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd87981d1c383695eeedcb97149451439e2b8d64" translate="yes" xml:space="preserve">
          <source>These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session's client and server.</source>
          <target state="translated">이들은 오래 지속될 수 있으며 일부 사용자의 전체 로그인 세션에 해당합니다. 세션은 세션의 클라이언트와 서버의 ID뿐만 아니라 해당 세션의 모든 연결에 의해 활발하게 사용되는 특정 암호 스위트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="30905a97f0d453c12f6b8ea895f71cbb656d45d8" translate="yes" xml:space="preserve">
          <source>These certificates are managed and vouched for by &lt;em&gt;Certificate Authorities&lt;/em&gt; (CAs). CAs are services which create certificates by placing data in the X.509 standard format and then digitally signing that data. CAs act as trusted third parties, making introductions between principals who have no direct knowledge of each other. CA certificates are either signed by themselves, or by some other CA such as a &quot;root&quot; CA.</source>
          <target state="translated">이 인증서는 &lt;em&gt;인증 기관&lt;/em&gt; (CA)에서 관리하고 보증합니다 . CA는 X.509 표준 형식으로 데이터를 배치 한 다음 해당 데이터에 디지털 서명하여 인증서를 작성하는 서비스입니다. CA는 신뢰할 수있는 제 3 자 역할을하여 서로에 대한 직접적인 지식이없는 보안 주체를 소개합니다. CA 인증서는 자체적으로 또는 &quot;루트&quot;CA와 같은 다른 CA에 의해 서명됩니다.</target>
        </trans-unit>
        <trans-unit id="e7654f792c1fa0442a29a75f4478a4533c2aa670" translate="yes" xml:space="preserve">
          <source>These certificates are widely used to support authentication and other functionality in Internet security systems. Common applications include Privacy Enhanced Mail (PEM), Transport Layer Security (SSL), code signing for trusted software distribution, and Secure Electronic Transactions (SET).</source>
          <target state="translated">이 인증서는 인터넷 보안 시스템에서 인증 및 기타 기능을 지원하는 데 널리 사용됩니다. 일반적인 응용 프로그램으로는 PEM (Privacy Enhanced Mail), SSL (Transport Layer Security), 신뢰할 수있는 소프트웨어 배포를위한 코드 서명 및 SET (Secure Electronic Transactions)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e42e0ff806cf170a11e36b37a054c3229ccff88" translate="yes" xml:space="preserve">
          <source>These classes are capable of formatting dates, numbers, and messages, parsing; searching and sorting strings; and iterating over characters, words, sentences, and line breaks. This package contains three main groups of classes and interfaces:</source>
          <target state="translated">이 클래스는 날짜, 숫자 및 메시지를 형식화하고 구문 분석 할 수 있습니다. 문자열 검색 및 정렬; 문자, 단어, 문장 및 줄 바꿈을 반복합니다. 이 패키지에는 세 가지 주요 클래스 및 인터페이스 그룹이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="536ba11d6da2845bb0c80905149fb7531b460122" translate="yes" xml:space="preserve">
          <source>These comments apply to gain controls in general, not just master gain controls. A line can have more than one gain control. For example, a mixer (which is itself a line) might have a master gain control, an auxiliary return control, a reverb return control, and, on each of its source lines, an individual aux send and reverb send.</source>
          <target state="translated">이 의견은 마스터 게인 컨트롤뿐만 아니라 일반적인 게인 컨트롤에도 적용됩니다. 라인은 하나 이상의 게인 컨트롤을 가질 수 있습니다. 예를 들어, 믹서 (그 자체가 라인 인)는 마스터 게인 컨트롤, 보조 리턴 컨트롤, 리버브 리턴 컨트롤 및 각 소스 라인에서 개별 보조 전송 및 리버브 전송을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6863080fd292838b064091acab8ec4a7e59422e3" translate="yes" xml:space="preserve">
          <source>These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object with language, country and variant, but you cannot specify script or extensions.</source>
          <target state="translated">이러한 생성자를 사용하면 언어, 국가 및 변형이 있는 &lt;code&gt;Locale&lt;/code&gt; 객체 를 만들 수 있지만 스크립트 또는 확장명을 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f834728921b0f3ab0a540e3f3bf6b14d71c7bcf" translate="yes" xml:space="preserve">
          <source>These different rule types can be expressed and queried.</source>
          <target state="translated">이러한 다른 규칙 유형을 표현하고 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f08e754a38dde7958ef1c6f1638768b615f3f1ca" translate="yes" xml:space="preserve">
          <source>These encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other encodings are supported.</source>
          <target state="translated">이러한 인코딩은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 인코딩이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b32f25bab2a6f9d22d42132cf2929dcee766e8c6" translate="yes" xml:space="preserve">
          <source>These fields are intended to be applicable in multiple calendar systems. For example, most non-ISO calendar systems define dates as a year, month and day, just with slightly different rules. The documentation of each field explains how it operates.</source>
          <target state="translated">이 필드는 여러 캘린더 시스템에 적용 할 수 있도록 고안되었습니다. 예를 들어, 대부분의 비 ISO 캘린더 시스템은 약간 다른 규칙을 사용하여 날짜를 년, 월 및 일로 정의합니다. 각 필드의 설명서에는 작동 방식이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71a58fc2f85a34846eba4205dc69caa813474de" translate="yes" xml:space="preserve">
          <source>These flags can be logically OR'ed together.</source>
          <target state="translated">이 플래그들은 논리적으로 함께 OR 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a00b200b8092958ccb95d52e492735fb5a88b33" translate="yes" xml:space="preserve">
          <source>These general methods allow polymorphic parsing and formatting of objects and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;. Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt; when no text in the required format is at the beginning of the input text.</source>
          <target state="translated">이러한 일반적인 방법은 객체의 다형성 구문 분석 및 서식 지정을 허용하며 예를 들어 &lt;code&gt;MessageFormat&lt;/code&gt; 에 의해 사용됩니다 . 서브 클래스는 종종 특정 입력 유형에 대한 추가 &lt;code&gt;format&lt;/code&gt; 메소드와 특정 결과 유형에 대한 &lt;code&gt;parse&lt;/code&gt; 메소드를 제공합니다. 모든 &lt;code&gt;parse&lt;/code&gt; 테이크하지 않는 방법 &lt;code&gt;ParsePosition&lt;/code&gt; 의의 인수는 던져해야 &lt;code&gt;ParseException&lt;/code&gt; 가를 요구 된 포맷의 텍스트가 입력 텍스트의 선두에없는 경우.</target>
        </trans-unit>
        <trans-unit id="eab7b0e51c3bfdf0586a547fefddc0d8e955988f" translate="yes" xml:space="preserve">
          <source>These interfaces and classes are required as part of the Java&amp;trade; Platform, Standard Edition (Java SE), but there is no requirement to provide any tools implementing them.</source>
          <target state="translated">이러한 인터페이스 및 클래스는 Java SE (Java &amp;trade; Platform, Standard Edition)의 일부로 필요하지만이를 구현하는 도구를 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="69a3f32f3321c8dd0341d385f7705d3bdbb396b6" translate="yes" xml:space="preserve">
          <source>These kinds of protection are specified by a &quot;cipher suite&quot;, which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a cipher suite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.</source>
          <target state="translated">이러한 종류의 보호는 지정된 SSL 연결에서 사용되는 암호화 알고리즘의 조합 인 &quot;암호 제품군&quot;에 의해 지정됩니다. 협상 프로세스 동안 두 엔드 포인트는 두 환경에서 모두 사용 가능한 암호 스위트에 동의해야합니다. 공통적 인 제품군이 없으면 SSL 연결을 설정할 수 없으며 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff41a76c06a874e4c78ae8f4beb0185f7f249d3" translate="yes" xml:space="preserve">
          <source>These kinds of protection are specified by a &quot;cipher suite&quot;, which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a ciphersuite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged.</source>
          <target state="translated">이러한 종류의 보호는 지정된 SSL 연결에서 사용되는 암호화 알고리즘의 조합 인 &quot;암호 제품군&quot;에 의해 지정됩니다. 협상 프로세스 동안 두 엔드 포인트는 두 환경 모두에서 사용 가능한 암호 스위트에 동의해야합니다. 공통적 인 제품군이 없으면 SSL 연결을 설정할 수 없으며 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b9c276e86b40b1083fdf2a0734e76f5ff35e720" translate="yes" xml:space="preserve">
          <source>These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments. For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it. Attempts to create method handles with impossible method types lead to an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;. In particular, a method handle&amp;rsquo;s type must not have an arity of the exact maximum 255.</source>
          <target state="translated">이러한 한계는 스택 된 인수에 대한 JVM 한계로 인해 특정 메소드 핸들을 작성할 수 없음을 의미합니다. 예를 들어, 정적 JVM 메소드가 정확히 255 개의 인수를 허용하면 메소드 핸들을 작성할 수 없습니다. 불가능한 메소드 유형으로 메소드 핸들을 작성하려고하면 &lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 특히, 메소드 핸들의 유형은 정확히 최대 255의 arity를 ​​가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2aef62f1a686aa612f7dadf32611ec60612d24e1" translate="yes" xml:space="preserve">
          <source>These linkage methods are designed to support the evaluation of &lt;em&gt;lambda expressions&lt;/em&gt; and &lt;em&gt;method references&lt;/em&gt; in the Java Language. For every lambda expressions or method reference in the source code, there is a target type which is a functional interface. Evaluating a lambda expression produces an object of its target type. The recommended mechanism for evaluating lambda expressions is to desugar the lambda body to a method, invoke an invokedynamic call site whose static argument list describes the sole method of the functional interface and the desugared implementation method, and returns an object (the lambda object) that implements the target type. (For method references, the implementation method is simply the referenced method; no desugaring is needed.)</source>
          <target state="translated">이러한 연결 방법은 Java 언어에서 &lt;em&gt;람다 식&lt;/em&gt; 및 &lt;em&gt;방법 참조&lt;/em&gt; 의 평가를 지원하도록 설계되었습니다 . 소스 코드의 모든 람다 표현식 또는 메소드 참조에 대해 기능 인터페이스 인 대상 유형이 있습니다. 람다 식을 평가하면 대상 유형의 객체가 생성됩니다. 람다 식을 평가하는 데 권장되는 메커니즘은 람다 본문을 메서드로 desugar하고 정적 인수 목록이 함수 인터페이스의 유일한 메서드와 desugared 구현 방법을 설명하는 invokedynamic 호출 ​​사이트를 호출하고 다음과 같은 객체 (람다 객체)를 반환하는 것입니다. 대상 유형을 구현합니다. (방법 참조의 경우 구현 방법은 단순히 참조 된 방법이며, 설탕 제거가 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="f76b936989514145bd202de1643f4d241fbb018e" translate="yes" xml:space="preserve">
          <source>These mechanisms are described in the &lt;a href=&quot;package-summary&quot;&gt;package specification&lt;/a&gt;.</source>
          <target state="translated">이러한 메커니즘은 &lt;a href=&quot;package-summary&quot;&gt;패키지 사양에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ac5b741a325296e9f1f056304a110b8a722ad5" translate="yes" xml:space="preserve">
          <source>These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications. The &lt;code&gt;park&lt;/code&gt; method is designed for use only in constructions of the form:</source>
          <target state="translated">이러한 방법은 높은 수준의 동기화 유틸리티를 만들기위한 도구로 사용되도록 고안되었으며 대부분의 동시성 제어 응용 프로그램에는 유용하지 않습니다. &lt;code&gt;park&lt;/code&gt; 메소드는 형태의 구조물에 사용하도록 설계되었습니다 :</target>
        </trans-unit>
        <trans-unit id="80b2b542cff995913a77f4654f407bd25dd4c1a4" translate="yes" xml:space="preserve">
          <source>These methods provide basic scripting functionality. Applications written to this simple interface are expected to work with minimal modifications in every implementation. It includes methods that execute scripts, and ones that set and get values.</source>
          <target state="translated">이러한 방법은 기본 스크립팅 기능을 제공합니다. 이 간단한 인터페이스로 작성된 응용 프로그램은 모든 구현에서 최소한의 수정으로 작동 할 것으로 예상됩니다. 스크립트를 실행하는 메소드와 값을 설정하고 얻는 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="297752b6a18f573e9c56aa0c6689ca4f4e9ec102" translate="yes" xml:space="preserve">
          <source>These objects may only be accessed via the following public static final variables, and are the only &lt;code&gt;Class&lt;/code&gt; objects for which this method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이러한 객체는 다음의 공개 정적 최종 변수를 통해서만 액세스 할 수 있으며이 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 유일한 &lt;code&gt;Class&lt;/code&gt; 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="a96ccc8f3e2fd8fe4c1dbd6fc649068f34d0702f" translate="yes" xml:space="preserve">
          <source>These operations are exposed in the constructors and methods of this class as follows:</source>
          <target state="translated">이러한 작업은이 클래스의 생성자와 메서드에 다음과 같이 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="47cbaf1cf3b15e600a882f2b865f9a1538cc73da" translate="yes" xml:space="preserve">
          <source>These parameter rules are also applicable to the set rule methods, such as &lt;code&gt;setStartRule&lt;/code&gt;.</source>
          <target state="translated">이러한 매개 변수 규칙은 &lt;code&gt;setStartRule&lt;/code&gt; 과 같은 설정된 규칙 메소드에도 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647770bcf1eb1a38d71a54bfe8c3e7ad6de8bd78" translate="yes" xml:space="preserve">
          <source>These properties are interpreted according to the following rules:</source>
          <target state="translated">이러한 속성은 다음 규칙에 따라 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d206af1d2dc412e81e7644b4cec4700275f97ba3" translate="yes" xml:space="preserve">
          <source>These purposes are served in this class by three related operations:</source>
          <target state="translated">이러한 목적은이 수업에서 세 가지 관련 작업으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e42b277937f8a596084eb371e31744be7cbbfdeb" translate="yes" xml:space="preserve">
          <source>These reduction operations can run safely in parallel with almost no modification:</source>
          <target state="translated">이러한 축소 작업은 거의 수정없이 안전하게 병렬로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5fe1b43768fd591f3bcb574e2cd4e802bb59264" translate="yes" xml:space="preserve">
          <source>These requirements ensure that streams produced by the &lt;a href=&quot;collection#stream--&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collection#parallelStream--&quot;&gt;&lt;code&gt;parallelStream()&lt;/code&gt;&lt;/a&gt; methods will reflect the contents of the collection as of initiation of the terminal stream operation.</source>
          <target state="translated">이러한 요구 사항은 &lt;a href=&quot;collection#stream--&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;collection#parallelStream--&quot;&gt; &lt;code&gt;parallelStream()&lt;/code&gt; &lt;/a&gt; 메서드로 생성 된 스트림 이 터미널 스트림 작업을 시작할 때 컬렉션의 내용을 반영하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9ce6632fdcabd56179ddf7edadcea4b6aaa39c33" translate="yes" xml:space="preserve">
          <source>These requirements significantly reduce the scope of potential interference between mutations of the stream source and execution of stream pipelines. Streams based on spliterators with the desired characteristics, or those using the Supplier-based factory forms, are immune to modifications of the data source prior to commencement of the terminal operation (provided the behavioral parameters to the stream operations meet the required criteria for non-interference and statelessness). See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 요구 사항은 스트림 소스의 돌연변이와 스트림 파이프 라인 실행 간의 잠재적 인 간섭 범위를 크게 줄입니다. 원하는 특성을 가진 스플리터를 기반으로하는 스트림 또는 공급 업체 기반 팩토리 형식을 사용하는 스트림은 터미널 작업을 시작하기 전에 데이터 소스 수정에 영향을받지 않습니다 (스트림 매개 변수에 대한 동작 매개 변수가 비 작업에 필요한 기준을 충족하는 경우) 간섭 및 무국적). 자세한 내용은 &lt;a href=&quot;package-summary#NonInterference&quot;&gt;비 간섭&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f76fe1fde2a58cf1420c28ae186dba0fd8cdb513" translate="yes" xml:space="preserve">
          <source>These response controls might have been generated by a successful or failed operation.</source>
          <target state="translated">이러한 응답 제어는 성공 또는 실패한 조작으로 생성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3133b61143c4a97991f32b65e594ea52115dd6e5" translate="yes" xml:space="preserve">
          <source>These rules imply that there is a one-to-one mapping between quoted and unquoted forms.</source>
          <target state="translated">이러한 규칙은 인용 양식과 인용되지 않은 양식간에 일대일 매핑이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fef3e7eb79137df43be121f2de5aa7417409ab48" translate="yes" xml:space="preserve">
          <source>These rules mean that extra items can be added to a &lt;code&gt;CompositeData&lt;/code&gt; without making it invalid for a &lt;code&gt;CompositeType&lt;/code&gt; that does not have those items.</source>
          <target state="translated">이러한 규칙은 해당 항목 이없는 &lt;code&gt;CompositeType&lt;/code&gt; 에 대해 유효하지 않은 추가 항목을 &lt;code&gt;CompositeData&lt;/code&gt; 에 추가 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="93285ed9687ceae878834b3cc5f3c85f4529ac14" translate="yes" xml:space="preserve">
          <source>These scales are the ones used by the methods which return exact arithmetic results; except that an exact divide may have to use a larger scale since the exact result may have more digits. For example, &lt;code&gt;1/32&lt;/code&gt; is &lt;code&gt;0.03125&lt;/code&gt;.</source>
          <target state="translated">이 스케일은 정확한 산술 결과를 반환하는 메소드에서 사용되는 스케일입니다. 정확한 결과는 더 많은 자릿수를 가질 수 있으므로 정확한 나누기는 더 큰 스케일을 사용해야 할 수 있습니다. 예를 들어 &lt;code&gt;1/32&lt;/code&gt; 는 &lt;code&gt;0.03125&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e810c9cd3c3d10bac6318c77d76a5f66cc69714" translate="yes" xml:space="preserve">
          <source>These styles are used when obtaining a date-time style from configuration. See &lt;a href=&quot;datetimeformatter&quot;&gt;&lt;code&gt;DateTimeFormatter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetimeformatterbuilder&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt;&lt;/a&gt; for usage.</source>
          <target state="translated">이 스타일은 구성에서 날짜-시간 스타일을 가져올 때 사용됩니다. 사용법 은 &lt;a href=&quot;datetimeformatter&quot;&gt; &lt;code&gt;DateTimeFormatter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetimeformatterbuilder&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e707b74f1bd6747e77b6eba32772900f7b93a32" translate="yes" xml:space="preserve">
          <source>These transformations are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher&quot;&gt; Cipher section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other transformations are supported.</source>
          <target state="translated">이러한 변환은 Java Cryptography Architecture 표준 알고리즘 이름 설명서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher&quot;&gt;암호 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 문서를 참조하여 다른 변환이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="998abafd744dbc64c5eb0e4aa97e8d53ca3729ba" translate="yes" xml:space="preserve">
          <source>These two APIs provide callers the means to query the Policy for Principal-based Permission entries.</source>
          <target state="translated">이 두 API는 호출자에게 주체 기반 권한 항목에 대한 정책을 쿼리 할 수있는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a115f527807f7ad38aadc1251aabbfdf3dc66f31" translate="yes" xml:space="preserve">
          <source>These two properties may be specified on the command line to the &quot;java&quot; command, or as system property definitions passed to JNI_CreateJavaVM.</source>
          <target state="translated">이 두 특성은 명령 행에서 &quot;java&quot;명령에 지정되거나 JNI_CreateJavaVM에 전달 된 시스템 특성 정의로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996bd5dd03cf13a899ae43ea59349cc73d3d4dc4" translate="yes" xml:space="preserve">
          <source>These units are intended to be applicable in multiple calendar systems. For example, most non-ISO calendar systems define units of years, months and days, just with slightly different rules. The documentation of each unit explains how it operates.</source>
          <target state="translated">이 단위는 여러 달력 시스템에 적용 할 수 있도록 고안되었습니다. 예를 들어, 대부분의 비 ISO 캘린더 시스템은 약간 다른 규칙으로 년, 월 및 일 단위를 정의합니다. 각 장치의 설명서에는 장치 작동 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5472c0639969a263b9f755acdf389e0d8c3da22" translate="yes" xml:space="preserve">
          <source>They have the same element type,</source>
          <target state="translated">그들은 같은 요소 유형을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfeeb8a91a65cd73f75c6e587083ef66ea635a5" translate="yes" xml:space="preserve">
          <source>They have the same number of remaining elements, and</source>
          <target state="translated">그들은 같은 수의 나머지 요소를 가지고 있으며</target>
        </trans-unit>
        <trans-unit id="1b2edcdb089ab60cba21f42efe299c3451e3c185" translate="yes" xml:space="preserve">
          <source>They may be used to monitor both print services (such as printers going on-line &amp;amp; off-line), and the progress of a specific print job.</source>
          <target state="translated">인쇄 서비스 (예 : 온라인 및 오프라인 프린터) 및 특정 인쇄 작업의 진행 상황을 모니터링하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9817dde9253443f7c2405ea71c3564c292de17d" translate="yes" xml:space="preserve">
          <source>Third parties may wish to provide value-add wrappers around the facility objects from this interface, for example a &lt;code&gt;Filer&lt;/code&gt; extension that allows multiple processors to coordinate writing out a single source file. To enable this, for processors running in a context where their side effects via the API could be visible to each other, the tool infrastructure must provide corresponding facility objects that are &lt;code&gt;.equals&lt;/code&gt;, &lt;code&gt;Filer&lt;/code&gt;s that are &lt;code&gt;.equals&lt;/code&gt;, and so on. In addition, the tool invocation must be able to be configured such that from the perspective of the running annotation processors, at least the chosen subset of helper classes are viewed as being loaded by the same class loader. (Since the facility objects manage shared state, the implementation of a wrapper class must know whether or not the same base facility object has been wrapped before.)</source>
          <target state="translated">타사는이 인터페이스에서 시설 개체 주위에 부가 가치 래퍼 (예 : 여러 프로세서가 단일 소스 파일 작성을 조정 하는 &lt;code&gt;Filer&lt;/code&gt; 확장)를 제공 할 수 있습니다. API를 통해 부작용이 서로 볼 수 수있는 곳 컨텍스트에서 실행중인 프로세서,이를 사용하려면,있는 시설 개체에 해당 제공해야하는 도구 인프라 &lt;code&gt;.equals&lt;/code&gt; , &lt;code&gt;Filer&lt;/code&gt; 이다의 &lt;code&gt;.equals&lt;/code&gt; 을, 등등. 또한 실행중인 주석 프로세서의 관점에서 최소한 선택된 헬퍼 클래스 서브 세트가 동일한 클래스 로더에 의해로드 된 것으로 간주되도록 도구 호출을 구성 할 수 있어야합니다. 기능 오브젝트가 공유 상태를 관리하므로 랩퍼 클래스의 구현은 동일한 기본 기능 오브젝트가 이전에 랩핑되었는지 여부를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="7af406c3aaa271300eedbb974c7a54d928cca6a4" translate="yes" xml:space="preserve">
          <source>This &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry specifies that code from &quot;foo.com&quot;, signed by &quot;foo', and running as a &lt;code&gt;SolarisPrincipal&lt;/code&gt; with the name, duke, has one &lt;code&gt;Permission&lt;/code&gt;. This &lt;code&gt;Permission&lt;/code&gt; permits the executing code to read and write files in the directory, &quot;/home/duke&quot;.</source>
          <target state="translated">이 &lt;b&gt;&lt;i&gt;권한 부여&lt;/i&gt;&lt;/b&gt; 항목은 &quot;foo&quot;로 서명되고 duke라는 이름 으로 &lt;code&gt;SolarisPrincipal&lt;/code&gt; 로 실행되는 &quot;foo.com&quot;의 코드 가 하나의 &lt;code&gt;Permission&lt;/code&gt; 을갖도록 지정 합니다.이 &lt;code&gt;Permission&lt;/code&gt; 은 실행 코드가 디렉토리에서 파일을 읽고 쓸 수 있도록합니다 . &quot; / home / duke &quot;.</target>
        </trans-unit>
        <trans-unit id="a0574eaa19de0e15db5fdb797729f29466170c1f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;@Target&lt;/code&gt; meta-annotation indicates that the declared type is intended solely for use as a member type in complex annotation type declarations. It cannot be used to annotate anything directly:</source>
          <target state="translated">이 &lt;code&gt;@Target&lt;/code&gt; 메타 주석은 선언 된 유형이 복잡한 주석 유형 선언에서 멤버 유형으로 만 사용됨을 나타냅니다. 직접 주석을 달 수는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="98f93f642c8589caf925501755e90c3a3667c633" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Configuration&lt;/code&gt; specifies that an application named, &quot;Login&quot;, requires users to first authenticate to the</source>
          <target state="translated">이 &lt;code&gt;Configuration&lt;/code&gt; 은 &quot;로그인&quot;이라는 응용 프로그램이 사용자에게 먼저 인증을 요구하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e7dca1afa768c61eb8246089859bd808f78d59fc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;FileAttributeView&lt;/code&gt; provides a view of a file's user-defined attributes as a set of name/value pairs, where the attribute name is represented by a &lt;code&gt;String&lt;/code&gt;. An implementation may require to encode and decode from the platform or file system representation when accessing the attribute. The value has opaque content. This attribute view defines the &lt;a href=&quot;userdefinedfileattributeview#read-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; methods to read the value into or write from a &lt;a href=&quot;../../bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;FileAttributeView&lt;/code&gt; is not intended for use where the size of an attribute value is larger than &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 파일의 사용자 정의 속성보기를 이름 / 값 쌍 세트로 제공합니다. 여기서 속성 이름은 &lt;code&gt;String&lt;/code&gt; 으로 표시됩니다 . 구현시 속성에 액세스 할 때 플랫폼 또는 파일 시스템 표현에서 인코딩 및 디코딩해야 할 수 있습니다. 값에 불투명 한 내용이 있습니다. 이 속성보기는 &lt;a href=&quot;../../bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; &lt;/a&gt; 에서 값을 읽거나 쓸 수 있는 &lt;a href=&quot;userdefinedfileattributeview#read-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 메소드를 정의합니다 . 이 &lt;code&gt;FileAttributeView&lt;/code&gt; 는 속성 값의 크기가 &lt;a href=&quot;../../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; &lt;/a&gt; 보다 큰 경우 사용하기위한 것이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="bee0760fe5e783edd2bde04ce6514f1bd4ac2344" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Handler&lt;/code&gt; publishes log records to &lt;code&gt;System.err&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Handler&lt;/code&gt; 는 로그 레코드를 &lt;code&gt;System.err&lt;/code&gt; 에 공개 합니다.</target>
        </trans-unit>
        <trans-unit id="518dc12e789b63d9602f3b36b0af20a614700005" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Handler&lt;/code&gt; publishes log records to &lt;code&gt;System.err&lt;/code&gt;. By default the &lt;code&gt;SimpleFormatter&lt;/code&gt; is used to generate brief summaries.</source>
          <target state="translated">이 &lt;code&gt;Handler&lt;/code&gt; 는 로그 레코드를 &lt;code&gt;System.err&lt;/code&gt; 에 공개 합니다. 기본적으로 &lt;code&gt;SimpleFormatter&lt;/code&gt; 는 간단한 요약을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36046ccb9dcb8ece08562c1ab81b5a9c5364f7f4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;MemoryMXBean&lt;/code&gt; is a &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt; that emits two types of memory &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;notifications&lt;/code&gt;&lt;/a&gt; if any one of the memory pools supports a &lt;a href=&quot;memorypoolmxbean#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt; or a &lt;a href=&quot;memorypoolmxbean#CollectionThreshold&quot;&gt;collection usage threshold&lt;/a&gt; which can be determined by calling the &lt;a href=&quot;memorypoolmxbean#isUsageThresholdSupported--&quot;&gt;&lt;code&gt;MemoryPoolMXBean.isUsageThresholdSupported()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;memorypoolmxbean#isCollectionUsageThresholdSupported--&quot;&gt;&lt;code&gt;MemoryPoolMXBean.isCollectionUsageThresholdSupported()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 &lt;code&gt;MemoryMXBean&lt;/code&gt; 은 메모리 풀 중 하나가 &lt;a href=&quot;memorypoolmxbean#isUsageThresholdSupported--&quot;&gt; &lt;code&gt;MemoryPoolMXBean.isUsageThresholdSupported()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;memorypoolmxbean#isCollectionUsageThresholdSupported--&quot;&gt; &lt;code&gt;MemoryPoolMXBean.isCollectionUsageThresholdSupported()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수있는 &lt;a href=&quot;memorypoolmxbean#CollectionThreshold&quot;&gt;사용 임계 &lt;/a&gt;&lt;a href=&quot;memorypoolmxbean#UsageThreshold&quot;&gt;값&lt;/a&gt; 또는 콜렉션 사용 임계 값 을 지원하는 경우 두 가지 유형의 메모리 &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;notifications&lt;/code&gt; &lt;/a&gt; 발행 하는 &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b2df064c410fd27f0e63fabab24d4a2bd0b9a0c2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;StringJoiner&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;StringJoiner&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9e558e7263cf30635484236c95f403ac1121e48" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Subject&lt;/code&gt; class implements &lt;code&gt;Serializable&lt;/code&gt;. While the Principals associated with the &lt;code&gt;Subject&lt;/code&gt; are serialized, the credentials associated with the &lt;code&gt;Subject&lt;/code&gt; are not. Note that the &lt;code&gt;java.security.Principal&lt;/code&gt; class does not implement &lt;code&gt;Serializable&lt;/code&gt;. Therefore all concrete &lt;code&gt;Principal&lt;/code&gt; implementations associated with Subjects must implement &lt;code&gt;Serializable&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Subject&lt;/code&gt; 클래스는 &lt;code&gt;Serializable&lt;/code&gt; 을 구현 합니다. &lt;code&gt;Subject&lt;/code&gt; 와 연관된 프린시 펄 은 직렬화되지만 &lt;code&gt;Subject&lt;/code&gt; 와 연관된 신임 정보는 직렬화 되지 않습니다. 참고는 것을 &lt;code&gt;java.security.Principal&lt;/code&gt; 클래스는 구현하지 않습니다 &lt;code&gt;Serializable&lt;/code&gt; . 따라서 주제와 관련된 모든 구체적인 &lt;code&gt;Principal&lt;/code&gt; 구현은 &lt;code&gt;Serializable&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="62db0d8a65e44d082a42520a299db77e5cc95323" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is intended to replace the integer-based enumeration of rounding mode constants in &lt;a href=&quot;bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;bigdecimal#ROUND_UP&quot;&gt;&lt;code&gt;BigDecimal.ROUND_UP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bigdecimal#ROUND_DOWN&quot;&gt;&lt;code&gt;BigDecimal.ROUND_DOWN&lt;/code&gt;&lt;/a&gt;, etc. ).</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;bigdecimal#ROUND_UP&quot;&gt; &lt;code&gt;BigDecimal.ROUND_UP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bigdecimal#ROUND_DOWN&quot;&gt; &lt;code&gt;BigDecimal.ROUND_DOWN&lt;/code&gt; &lt;/a&gt; 등) 에서 반올림 모드 상수의 정수 기반 열거를 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1f2d20f5d20e9aafea63ff46a3fe3aa6165a7d79" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;read&lt;/code&gt; method cannot block.</source>
          <target state="translated">이 &lt;code&gt;read&lt;/code&gt; 방법은 차단할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb06f97a093b16c944a96b6ca17a8d22c3e28b44" translate="yes" xml:space="preserve">
          <source>This Configuration instance will only have a Provider if it was obtained via a call to &lt;code&gt;Configuration.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 메소드를 사용해 취득되었을 경우에이 구성 인스턴스 만 제공이됩니다 &lt;code&gt;Configuration.getInstance&lt;/code&gt; . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c22e50bd9aa1f0422f432a320935dd0d1f877f98" translate="yes" xml:space="preserve">
          <source>This Configuration instance will only have a type if it was obtained via a call to &lt;code&gt;Configuration.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 메소드를 사용해 취득되었을 경우에이 구성 인스턴스는 유형이있을 것이다 &lt;code&gt;Configuration.getInstance&lt;/code&gt; . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8bc6889ca1b0f8f3565d8930a4e873adaa859028" translate="yes" xml:space="preserve">
          <source>This Configuration instance will only have parameters if it was obtained via a call to &lt;code&gt;Configuration.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 메소드를 사용해 취득되었을 경우에이 구성 인스턴스는 매개 변수가됩니다 &lt;code&gt;Configuration.getInstance&lt;/code&gt; . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="12a42e83700f895cae61540b6259e88c2b2aa2d7" translate="yes" xml:space="preserve">
          <source>This DOM Level 3 method is not supported for &lt;code&gt;IIOMetadataNode&lt;/code&gt; and will throw a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">이 DOM 레벨 3 방법은 지원되지 않습니다 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 를 하고 발생합니다 &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88cddc5e47c86d31fa8b49379a932b299b096755" translate="yes" xml:space="preserve">
          <source>This ID uniquely defines this object. The format of an offset based ID is defined by &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 ID는이 객체를 고유하게 정의합니다. 오프셋 기반 ID의 형식은 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="d11b672098a927855c0e4006aad3e98c4704db5f" translate="yes" xml:space="preserve">
          <source>This LogManager object:</source>
          <target state="translated">이 LogManager 객체 :</target>
        </trans-unit>
        <trans-unit id="9a4b9245f566d6174f8af40ceb307bc6ac85ee54" translate="yes" xml:space="preserve">
          <source>This MessageDigest class provides applications the functionality of a message digest algorithm, such as SHA-1 or SHA-256.</source>
          <target state="translated">이 MessageDigest 클래스는 SHA-1 또는 SHA-256과 같은 메시지 요약 알고리즘의 기능을 응용 프로그램에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dfc2d27c227ae660aca7a9180063fa625e6efb62" translate="yes" xml:space="preserve">
          <source>This MessageDigest class provides applications the functionality of a message digest algorithm, such as SHA-1 or SHA-256. Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value.</source>
          <target state="translated">이 MessageDigest 클래스는 SHA-1 또는 SHA-256과 같은 메시지 요약 알고리즘의 기능을 응용 프로그램에 제공합니다. 메시지 요약은 임의의 크기의 데이터를 가져와 고정 길이 해시 값을 출력하는 안전한 단방향 해시 함수입니다.</target>
        </trans-unit>
        <trans-unit id="87bd004e92d6136db7b100806731ffb0e4a8ae69" translate="yes" xml:space="preserve">
          <source>This Policy instance will only have a Provider if it was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 Policy 인스턴스는 &lt;code&gt;Policy.getInstance&lt;/code&gt; 호출을 통해 얻은 경우에만 제공자를 갖습니다 . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bac1288a600ecf0e061da22889c8ff35d4287de5" translate="yes" xml:space="preserve">
          <source>This Policy instance will only have a type if it was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 Policy 인스턴스는 &lt;code&gt;Policy.getInstance&lt;/code&gt; 호출을 통해 얻은 경우에만 유형을 갖습니다 . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="73075a777314e91e010444cf463c609e4a101022" translate="yes" xml:space="preserve">
          <source>This Policy instance will only have parameters if it was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;. Otherwise this method returns null.</source>
          <target state="translated">이 Policy 인스턴스는 &lt;code&gt;Policy.getInstance&lt;/code&gt; 호출을 통해 얻은 경우에만 매개 변수를 갖습니다 . 그렇지 않으면이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3f1c7e734c6ce43bfd074f3059f9cc9f53d9b23e" translate="yes" xml:space="preserve">
          <source>This PrinterURI attribute's underlying URI and &lt;code&gt;object&lt;/code&gt;'s underlying URI are equal.</source>
          <target state="translated">이 PrinterURI 속성의 기본 URI와 &lt;code&gt;object&lt;/code&gt; 의 기본 URI가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a23acb3515bb3ced0191a146de6afa2ce3788fa7" translate="yes" xml:space="preserve">
          <source>This ProtectionDomain class encapsulates the characteristics of a domain, which encloses a set of classes whose instances are granted a set of permissions when being executed on behalf of a given set of Principals.</source>
          <target state="translated">이 ProtectionDomain 클래스는 도메인의 특성을 캡슐화합니다. 도메인의 특성은, 지정된 Principal 세트를 대신해 실행되는 경우 인스턴스에 일련의 액세스권이 부여되는 클래스 세트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c3aa809b1bad0e1ae553bc8ccc658fd593e6cbaf" translate="yes" xml:space="preserve">
          <source>This URI attribute's underlying URI and &lt;code&gt;object&lt;/code&gt;'s underlying URI are equal.</source>
          <target state="translated">이 URI 속성의 기본 URI와 &lt;code&gt;object&lt;/code&gt; 의 기본 URI가 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d0d02c3d86c6b9788a5b1840dfd1af05ed9b865" translate="yes" xml:space="preserve">
          <source>This abstract class has two implementations, both of which are immutable and thread-safe. One implementation models region-based IDs, the other is &lt;code&gt;ZoneOffset&lt;/code&gt; modelling offset-based IDs. This difference is visible in serialization.</source>
          <target state="translated">이 추상 클래스에는 두 가지 구현이 있으며 둘 다 변경할 수 없으며 스레드로부터 안전합니다. 한 구현은 지역 기반 ID를 모델링 하고 다른 구현은 &lt;code&gt;ZoneOffset&lt;/code&gt; 모델링 오프셋 기반 ID입니다. 이 차이는 직렬화에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af89798815d8766dba755b7064bdbaa6e44d16b9" translate="yes" xml:space="preserve">
          <source>This abstract class is the superclass of all classes representing an input stream of bytes.</source>
          <target state="translated">이 추상 클래스는 바이트 입력 스트림을 나타내는 모든 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="542c000ead5f94e153511c3149a9ac30f0978f97" translate="yes" xml:space="preserve">
          <source>This abstract class is the superclass of all classes representing an output stream of bytes.</source>
          <target state="translated">이 추상 클래스는 바이트 출력 스트림을 나타내는 모든 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="859a86cb70a29ade18be64d6164eef01f3fb0053" translate="yes" xml:space="preserve">
          <source>This abstract class is the superclass of all classes representing an output stream of bytes. An output stream accepts output bytes and sends them to some sink.</source>
          <target state="translated">이 추상 클래스는 바이트 출력 스트림을 나타내는 모든 클래스의 수퍼 클래스입니다. 출력 스트림은 출력 바이트를 받아서 싱크로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0da0a4f596a531d53598898b278744dacde2837d" translate="yes" xml:space="preserve">
          <source>This abstract class is used to represent a referral exception, which is generated in response to a &lt;em&gt;referral&lt;/em&gt; such as that returned by LDAP v3 servers.</source>
          <target state="translated">이 추상 클래스는 LDAP v3 서버에서 리턴 된 것과 같은 &lt;em&gt;참조&lt;/em&gt; 에 대한 응답으로 생성되는 참조 예외를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5533d7c594ae4e8f67be32756fbf1c36a0369f4a" translate="yes" xml:space="preserve">
          <source>This abstract class is used to represent an LDAP referral exception.</source>
          <target state="translated">이 추상 클래스는 LDAP 조회 예외를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="211be5043fa4842399ea6e1192a72d3190feae8d" translate="yes" xml:space="preserve">
          <source>This abstract class is used to represent an LDAP referral exception. It extends the base &lt;code&gt;ReferralException&lt;/code&gt; by providing a &lt;code&gt;getReferralContext()&lt;/code&gt; method that accepts request controls. LdapReferralException is an abstract class. Concrete implementations of it determine its synchronization and serialization properties.</source>
          <target state="translated">이 추상 클래스는 LDAP 조회 예외를 나타내는 데 사용됩니다. 요청 제어를 승인 하는 &lt;code&gt;getReferralContext()&lt;/code&gt; 메소드를 제공 하여 기본 &lt;code&gt;ReferralException&lt;/code&gt; 을 확장 합니다. LdapReferralException은 추상 클래스입니다. 그것의 구체적인 구현은 동기화 및 직렬화 속성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5870422cc3cf304540dbf014abbe765753c4a28a" translate="yes" xml:space="preserve">
          <source>This abstract class must be implemented with care to ensure other classes operate correctly. All implementations that can be instantiated must be final, immutable and thread-safe.</source>
          <target state="translated">이 추상 클래스는 다른 클래스가 올바르게 작동하도록주의해서 구현해야합니다. 인스턴스화 할 수있는 모든 구현은 최종적이고 변경 불가능하며 스레드로부터 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="a882cc8603d5c8dd42b9dccf2e9ac4a17199444b" translate="yes" xml:space="preserve">
          <source>This abstract class represents a factory for creating LDAPv3 controls.</source>
          <target state="translated">이 추상 클래스는 LDAPv3 컨트롤을 만들기위한 팩토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="15ef5eb148d426a9a74e89d09b6c1d6c762bd269" translate="yes" xml:space="preserve">
          <source>This abstract class represents a factory for creating LDAPv3 controls. LDAPv3 controls are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251&lt;/a&gt;.</source>
          <target state="translated">이 추상 클래스는 LDAPv3 컨트롤을 만들기위한 팩토리를 나타냅니다. LDAPv3 컨트롤은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acebe30fbd007e4c2204c729b868e57910970846" translate="yes" xml:space="preserve">
          <source>This activity is normal, although it may cause puzzling entries to be created in web-server logs. If a web server is not configured correctly, however, then this activity may cause the provider-loading algorithm to fail spuriously.</source>
          <target state="translated">웹 서버 로그에 수수께끼 항목이 생성 될 수 있지만이 활동은 정상입니다. 그러나 웹 서버가 올바르게 구성되지 않은 경우이 활동으로 인해 제공자로드 알고리즘이 허위로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa8c5c0a107b31c4a95d0edb91b439cd84c11c5" translate="yes" xml:space="preserve">
          <source>This adds a new provider to those currently available. A provider supplies rules for one or more zone IDs. A provider cannot be registered if it supplies a zone ID that has already been registered. See the notes on time-zone IDs in &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;, especially the section on using the concept of a &quot;group&quot; to make IDs unique.</source>
          <target state="translated">현재 사용 가능한 공급자에 새 공급자가 추가됩니다. 공급자는 하나 이상의 영역 ID에 대한 규칙을 제공합니다. 공급자가 이미 등록 된 영역 ID를 제공하면 공급자를 등록 할 수 없습니다. &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; 의&lt;/a&gt; 시간대 ID에 대한 참고 사항 , 특히 &quot;그룹&quot;개념을 사용하여 ID를 고유하게 만드는 방법에 대한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b1b2290b18bee4fc34922df6ada6db168a30c6" translate="yes" xml:space="preserve">
          <source>This adds the amount to the days unit in a copy of this period. The years and months units are unaffected. For example, &quot;1 year, 6 months and 3 days&quot; plus 2 days returns &quot;1 year, 6 months and 5 days&quot;.</source>
          <target state="translated">이 기간의 사본에서 일 단위에 금액을 추가합니다. 연도 및 월 단위는 영향을받지 않습니다. 예를 들어 &quot;1 년, 6 개월 및 3 일&quot;에 2 일을 더하면 &quot;1 년, 6 개월 및 5 일&quot;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="577c40b8bdf2319aa6e28f29dbc1c99faaccf0de" translate="yes" xml:space="preserve">
          <source>This adds the amount to the months unit in a copy of this period. The years and days units are unaffected. For example, &quot;1 year, 6 months and 3 days&quot; plus 2 months returns &quot;1 year, 8 months and 3 days&quot;.</source>
          <target state="translated">그러면이 기간의 사본에서 월 단위에 금액이 추가됩니다. 년과 일 단위는 영향을받지 않습니다. 예를 들어 &quot;1 년, 6 개월 및 3 일&quot;에 2 개월을 더한 경우 &quot;1 년, 8 개월 및 3 일&quot;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42ae399a959d94527692104db6f0b6addcd3e7c1" translate="yes" xml:space="preserve">
          <source>This adds the amount to the years unit in a copy of this period. The months and days units are unaffected. For example, &quot;1 year, 6 months and 3 days&quot; plus 2 years returns &quot;3 years, 6 months and 3 days&quot;.</source>
          <target state="translated">이것은이 기간의 사본에서 년 단위에 금액을 추가합니다. 월 및 일 단위는 영향을받지 않습니다. 예를 들어 &quot;1 년, 6 개월 및 3 일&quot;에 2 년을 더한 경우 &quot;3 년, 6 개월 및 3 일&quot;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="312630dd3e559aa3e850635064b18ba893feb979" translate="yes" xml:space="preserve">
          <source>This adds the specified number of hours to this time, returning a new time. The calculation wraps around midnight.</source>
          <target state="translated">이 시간에 지정된 시간이 추가되어 새 시간이 반환됩니다. 계산은 자정을 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="5f9421d077bfb82504acd23d2b3d17ad4833739e" translate="yes" xml:space="preserve">
          <source>This adds the specified number of minutes to this time, returning a new time. The calculation wraps around midnight.</source>
          <target state="translated">이렇게하면 지정된 시간 (분)이 추가되고 새 시간이 반환됩니다. 계산은 자정을 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="56664909d328f8aa38e9bb862961993421d5ea4a" translate="yes" xml:space="preserve">
          <source>This adds the specified number of nanoseconds to this time, returning a new time. The calculation wraps around midnight.</source>
          <target state="translated">이 시간에 지정된 수의 나노초가 추가되어 새로운 시간이 반환됩니다. 계산은 자정을 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="272f310507ce85af55cf8e2ef919441f6f1bce72" translate="yes" xml:space="preserve">
          <source>This adds the specified number of seconds to this time, returning a new time. The calculation wraps around midnight.</source>
          <target state="translated">이렇게하면 지정된 시간 (초)이 추가되고 새 시간이 반환됩니다. 계산은 자정을 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="adbe662ba01bd9221e2364f3a2749e6f09b92016" translate="yes" xml:space="preserve">
          <source>This adjusts the specified temporal object using the logic encapsulated in the implementing class. Examples might be an adjuster that sets the date avoiding weekends, or one that sets the date to the last day of the month.</source>
          <target state="translated">구현 클래스에 캡슐화 된 로직을 사용하여 지정된 임시 객체를 조정합니다. 주말을 피하는 날짜를 설정하는 조정자 또는 날짜를 해당 월의 마지막 날로 설정하는 조정자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64bbe4507c0b775f8dd0431c3109d0f3b5437715" translate="yes" xml:space="preserve">
          <source>This adjusts this date-time according to the rules of the specified adjuster. A simple adjuster might simply set the one of the fields, such as the year field. A more complex adjuster might set the date to the last day of the month. A selection of common adjustments is provided in &lt;a href=&quot;../temporal/temporaladjusters&quot;&gt;&lt;code&gt;TemporalAdjusters&lt;/code&gt;&lt;/a&gt;. These include finding the &quot;last day of the month&quot; and &quot;next Wednesday&quot;. The adjuster is responsible for handling special cases, such as the varying lengths of month and leap years.</source>
          <target state="translated">지정된 조정자의 규칙에 따라이 날짜-시간을 조정합니다. 간단한 조정자가 연도 필드와 같은 필드 중 하나를 간단하게 설정할 수 있습니다. 더 복잡한 조정자는 날짜를 해당 월의 마지막 날로 설정할 수 있습니다. &lt;a href=&quot;../temporal/temporaladjusters&quot;&gt; &lt;code&gt;TemporalAdjusters&lt;/code&gt; &lt;/a&gt; 에서 공통 조정을 선택할 수 있습니다. 여기에는 &quot;매월 마지막 날&quot;과 &quot;다음 수요일&quot;찾기가 포함됩니다. 조정자는 다양한 월 및 윤년과 같은 특수 사례를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="10ae2372be7be68098127766d8108eeb65da90e5" translate="yes" xml:space="preserve">
          <source>This adjusts this date-time according to the rules of the specified adjuster. A simple adjuster might simply set the one of the fields, such as the year field. A more complex adjuster might set the date to the last day of the month. A selection of common adjustments is provided in &lt;a href=&quot;temporaladjusters&quot;&gt;&lt;code&gt;TemporalAdjusters&lt;/code&gt;&lt;/a&gt;. These include finding the &quot;last day of the month&quot; and &quot;next Wednesday&quot;. The adjuster is responsible for handling special cases, such as the varying lengths of month and leap years.</source>
          <target state="translated">지정된 조정자의 규칙에 따라이 날짜-시간을 조정합니다. 간단한 조정자가 연도 필드와 같은 필드 중 하나를 간단하게 설정할 수 있습니다. 더 복잡한 조정자는 날짜를 해당 월의 마지막 날로 설정할 수 있습니다. &lt;a href=&quot;temporaladjusters&quot;&gt; &lt;code&gt;TemporalAdjusters&lt;/code&gt; &lt;/a&gt; 에서 공통 조정을 선택할 수 있습니다. 여기에는 &quot;매월 마지막 날&quot;과 &quot;다음 수요일&quot;찾기가 포함됩니다. 조정자는 다양한 월 및 윤년과 같은 특수 사례를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e88d4e6ef393c6ea0a8be4561f97e8f887d8f6e7" translate="yes" xml:space="preserve">
          <source>This adjusts this temporal, adding according to the rules of the specified amount. The amount is typically a &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; but may be any other type implementing the &lt;a href=&quot;../temporal/temporalamount&quot;&gt;&lt;code&gt;TemporalAmount&lt;/code&gt;&lt;/a&gt; interface, such as &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 양의 규칙에 따라이 시간을 조정합니다. 금액은 일반적으로 &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;../temporal/temporalamount&quot;&gt; &lt;code&gt;TemporalAmount&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 다른 유형 ( 예 : &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; )일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf16c51e141a12f609caa086e84589698dded626" translate="yes" xml:space="preserve">
          <source>This adjusts this temporal, adding according to the rules of the specified amount. The amount is typically a &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; but may be any other type implementing the &lt;a href=&quot;temporalamount&quot;&gt;&lt;code&gt;TemporalAmount&lt;/code&gt;&lt;/a&gt; interface, such as &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 양의 규칙에 따라이 시간을 조정합니다. 금액은 일반적으로 &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;temporalamount&quot;&gt; &lt;code&gt;TemporalAmount&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 다른 유형 ( 예 : &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; )일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fbebc06513f3a97a95d03c4fcae8ef0464f29e9" translate="yes" xml:space="preserve">
          <source>This adjusts this temporal, subtracting according to the rules of the specified amount. The amount is typically a &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; but may be any other type implementing the &lt;a href=&quot;../temporal/temporalamount&quot;&gt;&lt;code&gt;TemporalAmount&lt;/code&gt;&lt;/a&gt; interface, such as &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간의 규칙에 따라 차감하여이 시간을 조정합니다. 금액은 일반적으로 &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;../temporal/temporalamount&quot;&gt; &lt;code&gt;TemporalAmount&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 다른 유형 ( 예 : &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; )일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1df2d75424dfecb1e8650c0bb937b97b7353dc6e" translate="yes" xml:space="preserve">
          <source>This adjusts this temporal, subtracting according to the rules of the specified amount. The amount is typically a &lt;a href=&quot;../period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; but may be any other type implementing the &lt;a href=&quot;temporalamount&quot;&gt;&lt;code&gt;TemporalAmount&lt;/code&gt;&lt;/a&gt; interface, such as &lt;a href=&quot;../duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간의 규칙에 따라 차감하여이 시간을 조정합니다. 금액은 일반적으로 &lt;a href=&quot;../period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;temporalamount&quot;&gt; &lt;code&gt;TemporalAmount&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 다른 유형 ( 예 : &lt;a href=&quot;../duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; )일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aed973346c68a83b9e5a6d690975188f9f90522" translate="yes" xml:space="preserve">
          <source>This algorithm is described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathBuilder&quot;&gt; CertPathBuilder section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathBuilder&quot;&gt;CertPathBuilder 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5a7ddfdadb11cb4435a90789db39d514610524" translate="yes" xml:space="preserve">
          <source>This algorithm is described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathValidator&quot;&gt; CertPathValidator section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathValidator&quot;&gt;CertPathValidator 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="08156557404a503d4b57bb0035d148a7251005fb" translate="yes" xml:space="preserve">
          <source>This algorithm is described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyAgreement&quot;&gt; KeyAgreement section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.</source>
          <target state="translated">이 알고리즘은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#KeyAgreement&quot;&gt;KeyAgreement 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 설명서를 참조하여 다른 알고리즘이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8420ee4992ac12c0e9c3a3d695f8378f8178a34d" translate="yes" xml:space="preserve">
          <source>This algorithm is implemented by this method. If it is overridden, the behavior specified here must be maintained.</source>
          <target state="translated">이 알고리즘은이 방법으로 구현됩니다. 재정의 된 경우 여기에 지정된 동작을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="7012ce743c621477f3e955bfcc887cfe246859dd" translate="yes" xml:space="preserve">
          <source>This allows a &lt;code&gt;DateTimeFormatter&lt;/code&gt; to be created. All date-time formatters are created ultimately using this builder.</source>
          <target state="translated">이를 통해 &lt;code&gt;DateTimeFormatter&lt;/code&gt; 를 만들 수 있습니다. 모든 날짜-시간 포맷터는 궁극적으로이 빌더를 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa9e683c930d9182a069fdd650fc200aa8b8d84" translate="yes" xml:space="preserve">
          <source>This allows a number of week-based-years to be added to, or subtracted from, a date. The unit is equal to either 52 or 53 weeks. The estimated duration of a week-based-year is the same as that of a standard ISO year at &lt;code&gt;365.2425 Days&lt;/code&gt;.</source>
          <target state="translated">이를 통해 날짜에 여러 주 단위 연도를 더하거나 뺄 수 있습니다. 단위는 52 주 또는 53 주입니다. 주 단위로 예상되는 기간은 표준 ISO 년의 &lt;code&gt;365.2425 Days&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="392df325756a65e9c5a8af04366376db864af4a4" translate="yes" xml:space="preserve">
          <source>This allows an attacker to control the runtime characteristics of the Java virtual machine and cause the system to misbehave. An attacker can also access some information related to the running application.</source>
          <target state="translated">이를 통해 공격자는 Java 가상 머신의 런타임 특성을 제어하고 시스템의 오작동을 유발할 수 있습니다. 공격자는 실행중인 응용 프로그램과 관련된 일부 정보에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="47834696b9fa695c266a5e8270bb613c5f6a908f" translate="yes" xml:space="preserve">
          <source>This allows an attacker to create thread groups and set their run priority.</source>
          <target state="translated">이를 통해 공격자는 스레드 그룹을 만들고 실행 우선 순위를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8b990f0a0bfc85454485276436f4879f340d42" translate="yes" xml:space="preserve">
          <source>This allows an attacker to modify the behaviour of any thread in the system.</source>
          <target state="translated">이를 통해 공격자는 시스템의 모든 스레드 동작을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e99a9ee933bdb89ca061322a9c2ca82d618e076" translate="yes" xml:space="preserve">
          <source>This allows an attacker to mount a denial-of-service attack by automatically forcing the virtual machine to halt. Note: The &quot;exitVM.*&quot; permission is automatically granted to all code loaded from the application class path, thus enabling applications to terminate themselves. Also, the &quot;exitVM&quot; permission is equivalent to &quot;exitVM.*&quot;.</source>
          <target state="translated">이를 통해 공격자는 가상 시스템이 자동으로 중지되도록하여 서비스 거부 공격을 수행 할 수 있습니다. 참고 : &quot;exitVM. *&quot;권한은 응용 프로그램 클래스 경로에서로드 된 모든 코드에 자동으로 부여되므로 응용 프로그램이 스스로 종료 될 수 있습니다. 또한 &quot;exitVM&quot;권한은 &quot;exitVM. *&quot;와 같습니다.</target>
        </trans-unit>
        <trans-unit id="26b8bd3c8f3c70a93f4288696898edada575f0d3" translate="yes" xml:space="preserve">
          <source>This allows an attacker to register a malicious shutdown hook that interferes with the clean shutdown of the virtual machine.</source>
          <target state="translated">이를 통해 공격자는 가상 시스템의 완전 종료를 방해하는 악의적 인 종료 후크를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="035ba076dd3c77252c39610d9f759a5d2e632455" translate="yes" xml:space="preserve">
          <source>This allows an attacker to register a malicious uncaught exception handler that could interfere with termination of a thread</source>
          <target state="translated">이를 통해 침입자는 스레드 종료를 방해 할 수있는 악의적 인 catch되지 않은 예외 처리기를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="828216fa1ac0c86e1f04efa978214156f3ec6eff" translate="yes" xml:space="preserve">
          <source>This allows attackers to remove a certificate for an identity's public key. This is dangerous because it affects the trust relationship across the system. This public key suddenly becomes considered less trustworthy than it otherwise would be.</source>
          <target state="translated">이를 통해 공격자는 ID의 공개 키에 대한 인증서를 제거 할 수 있습니다. 시스템 전체의 트러스트 관계에 영향을주기 때문에 위험합니다. 이 공개 키는 갑자기 다른 것보다 신뢰도가 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="95e86b5eb05f9b417cd456bf7e00be54c6071bde" translate="yes" xml:space="preserve">
          <source>This allows attackers to set a certificate for an identity's public key. This is dangerous because it affects the trust relationship across the system. This public key suddenly becomes trusted to a wider audience than it otherwise would be.</source>
          <target state="translated">이를 통해 공격자는 ID의 공개 키에 대한 인증서를 설정할 수 있습니다. 시스템 전체의 트러스트 관계에 영향을주기 때문에 위험합니다. 이 공개 키는 갑자기 다른 사람보다 더 많은 사람들에게 신뢰됩니다.</target>
        </trans-unit>
        <trans-unit id="05220737081c9aa7d095629bd62f1f3428e344b2" translate="yes" xml:space="preserve">
          <source>This allows attackers to set the general description for an identity. This may trick applications into using a different identity than intended or may prevent applications from finding a particular identity.</source>
          <target state="translated">이를 통해 공격자는 ID에 대한 일반적인 설명을 설정할 수 있습니다. 이로 인해 응용 프로그램이 의도 한 것과 다른 ID를 사용하도록 속이거나 응용 프로그램이 특정 ID를 찾지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc18153c69ee893634a4d2b84d8e76265eac6e6" translate="yes" xml:space="preserve">
          <source>This allows changing the value of the standard system streams. An attacker may change System.in to monitor and steal user input, or may set System.err to a &quot;null&quot; OutputStream, which would hide any error messages sent to System.err.</source>
          <target state="translated">이를 통해 표준 시스템 스트림의 값을 변경할 수 있습니다. 공격자는 System.in을 변경하여 사용자 입력을 모니터링하고 훔치거나 System.err을 &quot;null&quot;OutputStream으로 설정하여 System.err에 전송 된 오류 메시지를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baff8f2a3bff8a54097a516a8f38343fd059efb5" translate="yes" xml:space="preserve">
          <source>This allows code to obtain file system information such as disk usage or disk space available to the caller. This is potentially dangerous because it discloses information about the system hardware configuration and some information about the caller's privilege to write files.</source>
          <target state="translated">이를 통해 코드는 디스크 사용 또는 호출자가 사용할 수있는 디스크 공간과 같은 파일 시스템 정보를 얻을 수 있습니다. 시스템 하드웨어 구성에 대한 정보와 파일을 쓸 수있는 호출자의 권한에 대한 정보를 공개하기 때문에 잠재적으로 위험합니다.</target>
        </trans-unit>
        <trans-unit id="291eb9e418733f5873f220381f195838e9a1605b" translate="yes" xml:space="preserve">
          <source>This allows code to obtain policy information for a particular code source. While obtaining policy information does not compromise the security of the system, it does give attackers additional information, such as local file names for example, to better aim an attack.</source>
          <target state="translated">이를 통해 코드는 특정 코드 소스에 대한 정책 정보를 얻을 수 있습니다. 정책 정보를 얻는 것이 시스템의 보안을 손상 시키지는 않지만, 공격자에게보다 효과적인 공격을 위해 로컬 파일 이름과 같은 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42356fd570cef37cca56d1270fec316ba29c2374" translate="yes" xml:space="preserve">
          <source>This allows code to set the actual implementation for the socket, server socket, stream handler, or RMI socket factory. An attacker may set a faulty implementation which mangles the data stream.</source>
          <target state="translated">이를 통해 코드는 소켓, 서버 소켓, 스트림 핸들러 또는 RMI 소켓 팩토리에 대한 실제 구현을 설정할 수 있습니다. 공격자는 데이터 스트림을 엉망으로 만드는 잘못된 구현을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1894fdf0105d5006404e150ed427a01fc06e03a" translate="yes" xml:space="preserve">
          <source>This allows code to stop any thread in the system provided that it is already granted permission to access that thread. This poses as a threat, because that code may corrupt the system by killing existing threads.</source>
          <target state="translated">이렇게하면 해당 스레드에 대한 액세스 권한이 이미 부여 된 경우 코드가 시스템의 모든 스레드를 중지 할 수 있습니다. 이 코드는 기존 스레드를 강제 종료하여 시스템을 손상시킬 수 있기 때문에 위협이됩니다.</target>
        </trans-unit>
        <trans-unit id="fc5495ce28f148b193f78839eeb3539a66ed4a47" translate="yes" xml:space="preserve">
          <source>This allows code to write to a particular file associated with the descriptor. This is dangerous because it may allow malicious code to plant viruses or at the very least, fill up your entire disk.</source>
          <target state="translated">이를 통해 코드는 설명자와 관련된 특정 파일에 쓸 수 있습니다. 악성 코드가 바이러스를 생성하거나 최소한 전체 디스크를 채울 수 있기 때문에 위험합니다.</target>
        </trans-unit>
        <trans-unit id="31273fa567bcce8ad03110c0ebfe4cbadf40f08d" translate="yes" xml:space="preserve">
          <source>This allows malicious code to monitor runtime information and uncover vulnerabilities.</source>
          <target state="translated">이를 통해 악성 코드가 런타임 정보를 모니터링하고 취약점을 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7f242b0fbd58fd2048bc791aab8771f721dcad" translate="yes" xml:space="preserve">
          <source>This allows retrieval of the stack trace information of another thread. This might allow malicious code to monitor the execution of threads and discover vulnerabilities in applications.</source>
          <target state="translated">이를 통해 다른 스레드의 스택 추적 정보를 검색 할 수 있습니다. 이로 인해 악성 코드가 스레드 실행을 모니터링하고 응용 프로그램의 취약점을 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce37454c4a1eb923451c2cb48986b69c3da820d" translate="yes" xml:space="preserve">
          <source>This allows someone to instantiate an AccessControlContext with a &lt;code&gt;DomainCombiner&lt;/code&gt;. Extreme care must be taken when granting this permission. Malicious code could create a DomainCombiner that augments the set of permissions granted to code, and even grant the code &lt;a href=&quot;allpermission&quot;&gt;&lt;code&gt;AllPermission&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이를 통해 누군가가 &lt;code&gt;DomainCombiner&lt;/code&gt; 로 AccessControlContext를 인스턴스화 할 수 있습니다 . 이 권한을 부여 할 때는 각별히주의해야합니다. 악성 코드는 코드에 부여 된 권한 집합을 보강하고 &lt;a href=&quot;allpermission&quot;&gt; &lt;code&gt;AllPermission&lt;/code&gt; &lt;/a&gt; 코드를 부여하는 DomainCombiner를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="230473330163ca9ce75d0df8dd3d22c243a7bf1b" translate="yes" xml:space="preserve">
          <source>This allows someone to query the policy via the &lt;code&gt;getPermissions&lt;/code&gt; call, which discloses which permissions would be granted to a given CodeSource. While revealing the policy does not compromise the security of the system, it does provide malicious code with additional information which it may use to better aim an attack. It is wise not to divulge more information than necessary.</source>
          <target state="translated">이를 통해 누군가 &lt;code&gt;getPermissions&lt;/code&gt; 호출을 통해 정책을 쿼리 할 수 있습니다.이 권한은 주어진 CodeSource에 부여 된 권한을 공개합니다. 정책을 공개한다고해서 시스템의 보안이 손상되는 것은 아니지만, 공격을보다 효과적으로 조준하는 데 사용할 수있는 추가 정보를 악성 코드에 제공합니다. 필요 이상으로 많은 정보를 공개하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c2d1c6dd45d7f9f0a64f8e96aed1ed432ca6aa34" translate="yes" xml:space="preserve">
          <source>This allows someone to retrieve an AccessControlContext's &lt;code&gt;DomainCombiner&lt;/code&gt;. Since DomainCombiners may contain sensitive information, this could potentially lead to a privacy leak.</source>
          <target state="translated">이를 통해 누군가 AccessControlContext의 &lt;code&gt;DomainCombiner&lt;/code&gt; 를 검색 할 수 있습니다 . DomainCombiners는 민감한 정보를 포함 할 수 있으므로 개인 정보가 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc55baaf5ae8bcaed6ce4277c97a2358b139f90" translate="yes" xml:space="preserve">
          <source>This allows the &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;epoch-second&lt;/code&gt;&lt;/a&gt; field to be converted to a local date-time. This is primarily intended for low-level conversions rather than general application usage.</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;epoch-second&lt;/code&gt; &lt;/a&gt; 필드를 현지 날짜-시간으로 변환 할 수 있습니다. 이것은 주로 일반적인 응용 프로그램 사용이 아닌 저수준 변환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2afa8fa74586094ef2899a3f32763c6befa79c46" translate="yes" xml:space="preserve">
          <source>This allows this date-time to be converted to a value of the &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;epoch-seconds&lt;/code&gt;&lt;/a&gt; field. This is primarily intended for low-level conversions rather than general application usage.</source>
          <target state="translated">이를 통해이 날짜-시간을 &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;epoch-seconds&lt;/code&gt; &lt;/a&gt; 필드 값으로 변환 할 수 있습니다 . 이것은 주로 일반적인 응용 프로그램 사용이 아닌 저수준 변환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd85c07b257361553b187272035252c2297f4bf6" translate="yes" xml:space="preserve">
          <source>This allows you to use a RuleBasedCollator to compare accented strings even when the collator is set to NO_DECOMPOSITION. There are two caveats, however. First, if the strings to be collated contain combining sequences that may not be in canonical order, you should set the collator to CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of combining sequences. Second, if the strings contain characters with compatibility decompositions (such as full-width and half-width forms), you must use FULL_DECOMPOSITION, since the rule tables only include canonical mappings.</source>
          <target state="translated">이렇게하면 콜 레이터가 NO_DECOMPOSITION으로 설정되어 있어도 RuleBasedCollator를 사용하여 강조된 문자열을 비교할 수 있습니다. 그러나 두 가지 경고가 있습니다. 먼저, 조합 할 문자열에 정식 순서가 아닐 수있는 조합 시퀀스가 ​​포함 된 경우 조합 시퀀스를 정렬 할 수 있도록 조합기를 CANONICAL_DECOMPOSITION 또는 FULL_DECOMPOSITION으로 설정해야합니다. 둘째, 문자열에 호환성 분해 (예 : 전각 및 반각 형식)가 포함 된 문자가 포함 된 경우 규칙 테이블에는 정규 매핑 만 포함되므로 FULL_DECOMPOSITION을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b093d9555c5e0b41a82468bed3e0200f01d727a9" translate="yes" xml:space="preserve">
          <source>This allows you to write programs that can:</source>
          <target state="translated">이를 통해 다음을 수행 할 수있는 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c38ffc1f1970683fea610833ab9fd738cacf72" translate="yes" xml:space="preserve">
          <source>This amount of memory is not guaranteed to be available for memory management if it is greater than the amount of committed memory. The Java virtual machine may fail to allocate memory even if the amount of used memory does not exceed this maximum size.</source>
          <target state="translated">커밋 된 메모리의 양보다 큰 경우이 메모리 양을 메모리 관리에 사용할 수있는 것은 아닙니다. 사용 된 메모리의 양이이 최대 크기를 초과하지 않아도 Java 가상 머신이 메모리를 할당하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5a0d10b353af8113e99e87322144b9932c085d3" translate="yes" xml:space="preserve">
          <source>This appends a localized section to the builder, suitable for outputting a date, time or date-time combination. The format of the localized section is lazily looked up based on four items:</source>
          <target state="translated">이는 날짜, 시간 또는 날짜-시간 조합을 출력하는 데 적합한 현지화 된 섹션을 빌더에 추가합니다. 현지화 된 섹션의 형식은 네 가지 항목을 기준으로 느리게 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="d700fecf40f724eba44dbf4e379113997e1398d6" translate="yes" xml:space="preserve">
          <source>This appends a localized zone offset to the builder, the format of the localized offset is controlled by the specified &lt;a href=&quot;formatstyle&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; to this method:</source>
          <target state="translated">이렇게하면 지역화 된 영역 오프셋이 빌더에 추가되고 지역화 된 오프셋의 형식은 이 &lt;a href=&quot;formatstyle&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; 에 지정된 스타일 로 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="6487cb530ad122df71ffcb6338354a5ae097b70f" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the best available zone or offset ID to the builder. The zone ID is obtained in a lenient manner that first attempts to find a true zone ID, such as that on &lt;code&gt;ZonedDateTime&lt;/code&gt;, and then attempts to find an offset, such as that on &lt;code&gt;OffsetDateTime&lt;/code&gt;.</source>
          <target state="translated">여기에 사용 가능한 최상의 영역 또는 오프셋 ID를 형식화 / 파싱하는 지침이 빌더에 추가됩니다. 영역 ID는 &lt;code&gt;ZonedDateTime&lt;/code&gt; 과 같은 실제 영역 ID를 먼저 찾은 다음 OffsetDateTime 과 같은 오프셋을 찾으려고 관대 한 방식으로 &lt;code&gt;OffsetDateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e76363dee66256a2f3c0714515c9703601b9ff27" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the chronology ID to the builder.</source>
          <target state="translated">연대기 ID를 형식화 / 구 문화하는 지시 사항이 빌더에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0c353c51ea950bb45e9fa1e8f8f16aec8bee4c30" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the offset ID to the builder.</source>
          <target state="translated">이것은 오프셋 ID를 형식화 / 구 문화하는 명령을 빌더에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b4e600a2f00589a49ea004161fae69d7158dc603" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the offset ID to the builder. This is equivalent to calling &lt;code&gt;appendOffset(&quot;+HH:MM:ss&quot;, &quot;Z&quot;)&lt;/code&gt;.</source>
          <target state="translated">이것은 오프셋 ID를 형식화 / 구 문화하는 명령을 빌더에 추가합니다. &lt;code&gt;appendOffset(&quot;+HH:MM:ss&quot;, &quot;Z&quot;)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d86f8e93f39c33affe30be38ab664d8c8b94075f" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the textual name of the zone to the builder.</source>
          <target state="translated">이는 영역의 텍스트 이름을 빌더로 형식화 / 구 문화하는 지시 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e41e08ec1df822e63d53a305a848c2af6417734" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the zone ID to the builder only if it is a region-based ID.</source>
          <target state="translated">이것은 영역 기반 ID 인 경우에만 영역 ID를 빌더로 형식화 / 구문하기위한 지시 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3b37b4a643f5f53713c1af8800a2f80dd2a35a58" translate="yes" xml:space="preserve">
          <source>This appends an instruction to format/parse the zone ID to the builder. The zone ID is obtained in a strict manner suitable for &lt;code&gt;ZonedDateTime&lt;/code&gt;. By contrast, &lt;code&gt;OffsetDateTime&lt;/code&gt; does not have a zone ID suitable for use with this method, see &lt;a href=&quot;datetimeformatterbuilder#appendZoneOrOffsetId--&quot;&gt;&lt;code&gt;appendZoneOrOffsetId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 영역 ID를 빌더로 형식화 / 구 문화하는 지시 사항을 추가합니다. 영역 ID는 &lt;code&gt;ZonedDateTime&lt;/code&gt; 에 적합한 엄격한 방식으로 얻습니다 . 반대로 &lt;code&gt;OffsetDateTime&lt;/code&gt; 에는이 메소드에 사용하기에 적합한 영역 ID가 없습니다 &lt;a href=&quot;datetimeformatterbuilder#appendZoneOrOffsetId--&quot;&gt; &lt;code&gt;appendZoneOrOffsetId()&lt;/code&gt; &lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="116c49b6626c7acf49bd437a0b56faa051168c80" translate="yes" xml:space="preserve">
          <source>This appends an instruction to the builder to inject a default value into the parsed result. This is especially useful in conjunction with optional parts of the formatter.</source>
          <target state="translated">그러면 구문 분석 된 결과에 기본값을 삽입하라는 지시 사항이 빌더에 추가됩니다. 포맷터의 선택적 부분과 함께 사용하면 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9be0c13550155e8e59a2fd2d102063b4601f14ed" translate="yes" xml:space="preserve">
          <source>This applies the conversions listed in &lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;Locale.forLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; when constructing a Locale. (Grandfathered tags are handled in &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">로케일을 구성 할 때 &lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;Locale.forLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 나열된 변환이 적용됩니다 . (Grandfathered 태그는 &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 에서 처리됩니다 .)</target>
        </trans-unit>
        <trans-unit id="a9d14656058135f7b74fa6f19ce86566b836ae09" translate="yes" xml:space="preserve">
          <source>This approach allows an alternate clock, such as &lt;a href=&quot;clock#fixed-java.time.Instant-java.time.ZoneId-&quot;&gt;&lt;code&gt;fixed&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;clock#offset-java.time.Clock-java.time.Duration-&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; to be used during testing.</source>
          <target state="translated">이 방법을 사용하면 테스트 중에 &lt;a href=&quot;clock#fixed-java.time.Instant-java.time.ZoneId-&quot;&gt; &lt;code&gt;fixed&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;clock#offset-java.time.Clock-java.time.Duration-&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 과 같은 대체 클록 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45c8c988a424a289fab84dd5545b7a69d4eea5d" translate="yes" xml:space="preserve">
          <source>This approach ensures that a partial period can be added to a partial date. For example, a period of years and/or months can be added to a &lt;code&gt;YearMonth&lt;/code&gt;, but a period including days cannot. The approach also adds years and months together when necessary, which ensures correct behaviour at the end of the month.</source>
          <target state="translated">이 방법을 사용하면 부분 날짜를 부분 날짜에 추가 할 수 있습니다. 예를 들어, 년 및 / 또는 월을 &lt;code&gt;YearMonth&lt;/code&gt; 에 추가 할 수 있지만 일을 포함한 기간은 추가 할 수 없습니다. 이 방법은 필요할 때 몇 년과 몇 달을 더하여 월말에 올바른 동작을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="90ee599e8b118f32de5c4e9cd0140e9dbc90fd8a" translate="yes" xml:space="preserve">
          <source>This approach ensures that a partial period can be subtracted from a partial date. For example, a period of years and/or months can be subtracted from a &lt;code&gt;YearMonth&lt;/code&gt;, but a period including days cannot. The approach also subtracts years and months together when necessary, which ensures correct behaviour at the end of the month.</source>
          <target state="translated">이 방법을 사용하면 부분 날짜에서 부분 기간을 뺄 수 있습니다. 예를 들어 &lt;code&gt;YearMonth&lt;/code&gt; 에서 년 및 / 또는 월을 뺄 수 있지만 일을 포함하는 기간은 할 수 없습니다. 이 방법은 필요한 경우 몇 년과 몇 달을 빼서 월말에 올바른 동작을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="9a34f705974537252f812b090b7633f5333d4528" translate="yes" xml:space="preserve">
          <source>This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., an IV) that were used to seal the object.</source>
          <target state="translated">이러한 접근법은 물체를 씰 해제하는 당사자가 물체를 밀봉하는데 사용 된 파라미터 (예를 들어, IV)를 추적 할 필요가 없다는 이점을 갖는다.</target>
        </trans-unit>
        <trans-unit id="6b27b76b29cfa32a58ebb4f790b16569099bdf3f" translate="yes" xml:space="preserve">
          <source>This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key. For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object.</source>
          <target state="translated">이 접근 방식은 봉인 된 객체를 봉인 해제하는 당사자가 암호 해독 키에 대한 지식이 필요하지 않다는 이점이 있습니다. 예를 들어, 한 당사자가 필요한 암호 해독 키를 사용하여 암호 오브젝트를 초기화 한 후 암호 오브젝트를 다른 당사자에게 넘겨서 봉인 된 오브젝트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="63c09dec8a7d446df4a7af11bf80860cea142ccd" translate="yes" xml:space="preserve">
          <source>This approach treats the problem of globalized calendar systems as a localization issue and confines it to the UI layer. This approach is in keeping with other localization issues in the java platform.</source>
          <target state="translated">이 방법은 세계화 된 캘린더 시스템의 문제를 현지화 문제로 취급하고이를 UI 계층으로 제한합니다. 이 접근법은 Java 플랫폼의 다른 현지화 문제와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2e4acb3eebe760200b57ee09d39e8e33a473219a" translate="yes" xml:space="preserve">
          <source>This attribute can be used instead of specifying MediaName or MediaTray.</source>
          <target state="translated">이 속성은 MediaName 또는 MediaTray를 지정하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ce450d52d4aa8c1c76637f12936f4c702a2de7" translate="yes" xml:space="preserve">
          <source>This attribute can be used instead of specifying MediaSize or MediaTray.</source>
          <target state="translated">이 속성은 MediaSize 또는 MediaTray를 지정하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58c03b8321b50d6ffb90742e0fdffcc3b889085" translate="yes" xml:space="preserve">
          <source>This attribute is often used as a simple access control mechanism to prevent files from being deleted or updated. Whether the file system or platform does any enforcement to prevent &lt;em&gt;read-only&lt;/em&gt; files from being updated is implementation specific.</source>
          <target state="translated">이 속성은 종종 파일의 삭제 또는 업데이트를 막기 위해 간단한 액세스 제어 메커니즘으로 사용됩니다. 파일 시스템 또는 플랫폼이 &lt;em&gt;읽기 전용&lt;/em&gt; 파일의 업데이트 를 막기 위해 시행 할 것인지는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3eeb1d55245778cba97de33ea39c544ab59df5c7" translate="yes" xml:space="preserve">
          <source>This attribute is often used to indicate if the file is visible to users.</source>
          <target state="translated">이 속성은 파일이 사용자에게 표시되는지 여부를 나타내는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0596a0228dd81612a4d3fd62530c3e80647f1746" translate="yes" xml:space="preserve">
          <source>This attribute is often used to indicate that the file is a component of the operating system.</source>
          <target state="translated">이 속성은 파일이 운영 체제의 구성 요소임을 나타내는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6b3d268faabc1bc1a3c7d7722914a4fe8827d8" translate="yes" xml:space="preserve">
          <source>This attribute is typically used by backup programs.</source>
          <target state="translated">이 속성은 일반적으로 백업 프로그램에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0af09403714e88dfda7b330926ca836af61e562f" translate="yes" xml:space="preserve">
          <source>This attribute specifies the &lt;code&gt;.ser&lt;/code&gt; file that contains a serialized representation of the MBean to be obtained. This file must be contained in one of the &lt;code&gt;.jar&lt;/code&gt; files specified by the &lt;code&gt;ARCHIVE&lt;/code&gt; attribute. If the &lt;code&gt;.jar&lt;/code&gt; file contains a directory hierarchy, specify the path of the file within this hierarchy. Otherwise a match will not be found. Either &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;OBJECT&lt;/code&gt; must be present.</source>
          <target state="translated">이 속성은 획득 할 MBean의 직렬화 된 표현을 포함하는 &lt;code&gt;.ser&lt;/code&gt; 파일을 지정합니다 . 이 파일은 &lt;code&gt;ARCHIVE&lt;/code&gt; 속성으로 지정된 &lt;code&gt;.jar&lt;/code&gt; 파일 중 하나에 포함되어야 합니다. 는 IF &lt;code&gt;.jar&lt;/code&gt; 파일이 디렉토리 계층 구조를 포함하고,이 계층 구조 내에서 파일의 경로를 지정합니다. 그렇지 않으면 일치하는 것이 없습니다. 어느 &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;OBJECT&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d147fedbae7325c324e7d77fc07d77deceb84bb9" translate="yes" xml:space="preserve">
          <source>This attribute specifies the full Java class name, including package name, of the MBean to be obtained. The compiled &lt;code&gt;.class&lt;/code&gt; file of the MBean must be contained in one of the &lt;code&gt;.jar&lt;/code&gt; files specified by the &lt;code&gt;ARCHIVE&lt;/code&gt; attribute. Either &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;OBJECT&lt;/code&gt; must be present.</source>
          <target state="translated">이 속성은 얻을 MBean의 패키지 이름을 포함한 전체 Java 클래스 이름을 지정합니다. MBean 의 컴파일 된 &lt;code&gt;.class&lt;/code&gt; 파일은 &lt;code&gt;ARCHIVE&lt;/code&gt; 속성으로 지정된 &lt;code&gt;.jar&lt;/code&gt; 파일 중 하나에 포함되어야 합니다. 어느 &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;OBJECT&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a0c53530aad014804af0b4de10d041606ae7c636" translate="yes" xml:space="preserve">
          <source>This attribute's X dimension is equal to &lt;code&gt;object&lt;/code&gt;'s X dimension.</source>
          <target state="translated">이 속성의 X 치수는 &lt;code&gt;object&lt;/code&gt; 의 X 치수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="86198e24becbec5b86fec6178a8c1283a8fc118b" translate="yes" xml:space="preserve">
          <source>This attribute's Y dimension is equal to &lt;code&gt;object&lt;/code&gt;'s Y dimension.</source>
          <target state="translated">이 속성의 Y 치수는 &lt;code&gt;object&lt;/code&gt; 의 Y 치수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fdc945bfb1edc9c7533be74c4de3229628d02df5" translate="yes" xml:space="preserve">
          <source>This attribute's cross feed direction resolution is equal to &lt;code&gt;object&lt;/code&gt;'s cross feed direction resolution.</source>
          <target state="translated">이 속성의 교차 피드 방향 해상도는 &lt;code&gt;object&lt;/code&gt; 의 교차 피드 방향 해상도와 같습니다.</target>
        </trans-unit>
        <trans-unit id="42a722408b194823e78df986d87812f231231ff3" translate="yes" xml:space="preserve">
          <source>This attribute's cross feed direction resolution is less than or equal to the &lt;code&gt;other&lt;/code&gt; attribute's cross feed direction resolution.</source>
          <target state="translated">이 속성의 교차 피드 방향 해상도가 &lt;code&gt;other&lt;/code&gt; 속성의 교차 피드 방향 해상도 보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bf49e9bd87ea63e550f5aa731a9e96e45c21ebf8" translate="yes" xml:space="preserve">
          <source>This attribute's feed direction resolution is equal to &lt;code&gt;object&lt;/code&gt;'s feed direction resolution.</source>
          <target state="translated">이 속성의 피드 방향 해상도는 &lt;code&gt;object&lt;/code&gt; 의 피드 방향 해상도와 같습니다.</target>
        </trans-unit>
        <trans-unit id="136df71936942acc7cc0e61189291431a74f5eaf" translate="yes" xml:space="preserve">
          <source>This attribute's feed direction resolution is less than or equal to the &lt;code&gt;other&lt;/code&gt; attribute's feed direction resolution.</source>
          <target state="translated">이 속성의 피드 방향 해상도가 &lt;code&gt;other&lt;/code&gt; 속성의 피드 방향 해상도 보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4880d6984e9ccd72b50c0ebb6ac9d4f39f2e1283" translate="yes" xml:space="preserve">
          <source>This attribute's schema definition. Null if the implementation supports schemas but this particular attribute does not have any schema information.</source>
          <target state="translated">이 속성의 스키마 정의. 구현이 스키마를 지원하지만이 특정 속성에 스키마 정보가없는 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="95ec5f83f16371801ae3b13ea00e9349940346a1" translate="yes" xml:space="preserve">
          <source>This base class returns an empty string, but this may be overridden by subclasses.</source>
          <target state="translated">이 기본 클래스는 빈 문자열을 리턴하지만 서브 클래스로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d38d0ba474eda1b8a360fd28b3e5ea975b2310" translate="yes" xml:space="preserve">
          <source>This becomes clearer if we compare what the clients of the two models might look like:</source>
          <target state="translated">두 모델의 클라이언트가 어떻게 보이는지 비교하면 더 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="b8112861628bf3cb4cdbc975fb94a82903ce6439" translate="yes" xml:space="preserve">
          <source>This behavior is designed to support debugging and to be compatible with previous uses of &lt;code&gt;toString&lt;/code&gt; that expected language, country, and variant fields only. To represent a Locale as a String for interchange purposes, use &lt;a href=&quot;locale#toLanguageTag--&quot;&gt;&lt;code&gt;toLanguageTag()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 디버깅을 지원하고 언어, 국가 및 변형 필드 만 예상되는 &lt;code&gt;toString&lt;/code&gt; 의 이전 사용과 호환되도록 설계되었습니다 . 교환 목적으로 로케일을 문자열로 표시하려면 &lt;a href=&quot;locale#toLanguageTag--&quot;&gt; &lt;code&gt;toLanguageTag()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c2d139f6620ff45c0de7612b11482344771e9ab" translate="yes" xml:space="preserve">
          <source>This block was previously known as &quot;Combining Marks for Symbols&quot;.</source>
          <target state="translated">이 블록은 이전에는 &quot;기호에 대한 마크 결합&quot;으로 알려져있었습니다.</target>
        </trans-unit>
        <trans-unit id="14876ac73afcb34469404e2320461183f7735ef5" translate="yes" xml:space="preserve">
          <source>This block was previously known as the &quot;Greek&quot; block.</source>
          <target state="translated">이 블록은 이전에는 &quot;Greek&quot;블록으로 알려져있었습니다.</target>
        </trans-unit>
        <trans-unit id="f3f5626990b494e388e57ff761627940cac15cd5" translate="yes" xml:space="preserve">
          <source>This buffer</source>
          <target state="translated">이 버퍼</target>
        </trans-unit>
        <trans-unit id="c27e5c7676de43b1074567048424ea5097800b42" translate="yes" xml:space="preserve">
          <source>This buffer's byte order</source>
          <target state="translated">이 버퍼의 바이트 순서</target>
        </trans-unit>
        <trans-unit id="d084b06bb48e26d99a49679f9badb91b0961f1a1" translate="yes" xml:space="preserve">
          <source>This builder can still be used after creating the formatter if desired, although the state may have been changed by calls to &lt;code&gt;optionalEnd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;optionalEnd&lt;/code&gt; 에 대한 호출로 상태가 변경되었을 수 있지만 원하는 경우 포맷터를 작성한 후에도이 빌더를 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0a367dcd24e85f4849a51096bb8414304e05ebd" translate="yes" xml:space="preserve">
          <source>This builder.</source>
          <target state="translated">이 빌더.</target>
        </trans-unit>
        <trans-unit id="fcc1a0e36b13027b1cd2e8e182a87b2a50741a65" translate="yes" xml:space="preserve">
          <source>This calculates the amount in terms of this unit. The start and end points are supplied as temporal objects and must be of compatible types. The implementation will convert the second type to be an instance of the first type before the calculating the amount. The result will be negative if the end is before the start. For example, the amount in hours between two temporal objects can be calculated using &lt;code&gt;HOURS.between(startTime, endTime)&lt;/code&gt;.</source>
          <target state="translated">이 단위로 금액을 계산합니다. 시작점과 끝점은 임시 객체로 제공되며 호환 가능한 유형이어야합니다. 구현은 금액을 계산하기 전에 두 번째 유형을 첫 번째 유형의 인스턴스로 변환합니다. 끝이 시작하기 전에 결과는 음수입니다. 예를 들어, 두 시간 객체 사이의 시간 (시간)은 &lt;code&gt;HOURS.between(startTime, endTime)&lt;/code&gt; 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f28ba1aed263ee4a7a43885af68db05c8ba2820a" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;ChronoLocalDate&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;ChronoLocalDate&lt;/code&gt; using &lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.date(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. The calculation returns a whole number, representing the number of complete units between the two dates. For example, the amount in days between two dates can be calculated using &lt;code&gt;startDate.until(endDate, DAYS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 개체 사이의 시간을 계산합니다 . 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메서드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 은 &lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.date(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 로 변환됩니다 . 계산은 두 날짜 사이의 완전한 단위 수를 나타내는 정수를 반환합니다. 예를 들어, 두 날짜 사이의 일 수는 &lt;code&gt;startDate.until(endDate, DAYS)&lt;/code&gt; 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="042600c3bd3d8fa895b02a793742724c69aa74b1" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;Instant&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified instant. The result will be negative if the end is before the start. The calculation returns a whole number, representing the number of complete units between the two instants. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;Instant&lt;/code&gt; using &lt;a href=&quot;instant#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in days between two dates can be calculated using &lt;code&gt;startInstant.until(endInstant, SECONDS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 의 관점에서 두 &lt;code&gt;Instant&lt;/code&gt; 객체 간의 시간을 계산합니다 . 시작 지점과 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 순간입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 계산은 두 인스턴트 사이의 완전한 단위 수를 나타내는 정수를 반환합니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 은 &lt;a href=&quot;instant#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;Instant&lt;/code&gt; 로 변환됩니다 . 예를 들어 &lt;code&gt;startInstant.until(endInstant, SECONDS)&lt;/code&gt; 사용하여 두 날짜 사이의 일 수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09fb64acead91b0835e975fd6d1baf20e5fb366a" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;LocalDate&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;LocalDate&lt;/code&gt; using &lt;a href=&quot;localdate#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in days between two dates can be calculated using &lt;code&gt;startDate.until(endDate, DAYS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;LocalDate&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 은 &lt;a href=&quot;localdate#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;LocalDate&lt;/code&gt; 로 변환됩니다 . 예를 들어, 두 날짜 사이의 일 수는 &lt;code&gt;startDate.until(endDate, DAYS)&lt;/code&gt; 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1adb51a4aa4348285f06861583659a5dfc5d8fac" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;LocalDateTime&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date-time. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;LocalDateTime&lt;/code&gt; using &lt;a href=&quot;localdatetime#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in days between two date-times can be calculated using &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;LocalDateTime&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 지점과 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 날짜-시간입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 은 &lt;a href=&quot;localdatetime#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;LocalDateTime&lt;/code&gt; 으로 변환됩니다 . 예를 들어 &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt; 사용하여 두 날짜-시간 사이의 일 수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dd9d251ec489c054692d2712ae14ef0e0b3cac4" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;LocalTime&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified time. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;LocalTime&lt;/code&gt; using &lt;a href=&quot;localtime#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in hours between two times can be calculated using &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;LocalTime&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 시간과 지정된 시간입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 은 &lt;a href=&quot;localtime#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;LocalTime&lt;/code&gt; 으로 변환됩니다 . 예를 들어, &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt; 사용하여 두 시간 사이의 시간을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb0f2b197558a031fa50848ba7feca7bd7dc0ed1" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;OffsetDateTime&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date-time. The result will be negative if the end is before the start. For example, the amount in days between two date-times can be calculated using &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 의 관점에서 두 &lt;code&gt;OffsetDateTime&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 지점과 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 날짜-시간입니다. 끝이 시작하기 전에 결과는 음수입니다. 예를 들어 &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt; 사용하여 두 날짜-시간 사이의 일 수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c17761fd36cd4af0600aca6b972c1d14d1b7c96" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;OffsetTime&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified time. The result will be negative if the end is before the start. For example, the amount in hours between two times can be calculated using &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 의 관점에서 두 &lt;code&gt;OffsetTime&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 시간과 지정된 시간입니다. 끝이 시작하기 전에 결과는 음수입니다. 예를 들어, &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt; 사용하여 두 시간 사이의 시간을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c90681be0c15bfab4f976bf42b28fe16d0484839" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;Year&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified year. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;Year&lt;/code&gt; using &lt;a href=&quot;year#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in decades between two year can be calculated using &lt;code&gt;startYear.until(endYear, DECADES)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 을 기준으로 두 &lt;code&gt;Year&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작과 끝 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 연도입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 는 &lt;a href=&quot;year#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;Year&lt;/code&gt; 변환됩니다 . 예를 들어, 2 년 사이의 10 년 단위 금액은 &lt;code&gt;startYear.until(endYear, DECADES)&lt;/code&gt; 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05ab7db1f28ab1369011ae6c8419666f5da8a465" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;YearMonth&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified year-month. The result will be negative if the end is before the start. The &lt;code&gt;Temporal&lt;/code&gt; passed to this method is converted to a &lt;code&gt;YearMonth&lt;/code&gt; using &lt;a href=&quot;yearmonth#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt;. For example, the amount in years between two year-months can be calculated using &lt;code&gt;startYearMonth.until(endYearMonth, YEARS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;YearMonth&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 연도입니다. 끝이 시작하기 전에 결과는 음수입니다. 이 메소드에 전달 된 &lt;code&gt;Temporal&lt;/code&gt; 는 &lt;a href=&quot;yearmonth#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;YearMonth&lt;/code&gt; 로 변환됩니다 . 예를 들어 &lt;code&gt;startYearMonth.until(endYearMonth, YEARS)&lt;/code&gt; 사용하여 2 년에서 2 년 사이의 연도 금액을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83debf9fbfd6d180e052b061238b01be11cefc24" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two &lt;code&gt;ZonedDateTime&lt;/code&gt; objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date-time. The result will be negative if the end is before the start. For example, the amount in days between two date-times can be calculated using &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 &lt;code&gt;ZonedDateTime&lt;/code&gt; 객체 사이의 시간을 계산합니다 . 시작 지점과 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 날짜-시간입니다. 끝이 시작하기 전에 결과는 음수입니다. 예를 들어 &lt;code&gt;startDateTime.until(endDateTime, DAYS)&lt;/code&gt; 사용하여 두 날짜-시간 사이의 일 수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d3524284225e48615609b767b2885c90cbc4075" translate="yes" xml:space="preserve">
          <source>This calculates the amount of time between two temporal objects in terms of a single &lt;code&gt;TemporalUnit&lt;/code&gt;. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified temporal. The end point is converted to be of the same type as the start point if different. The result will be negative if the end is before the start. For example, the amount in hours between two temporal objects can be calculated using &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;TemporalUnit&lt;/code&gt; 로 두 임시 오브젝트 사이의 시간을 계산합니다 . 시작 지점과 종료 지점은 &lt;code&gt;this&lt;/code&gt; 과 지정된 시간입니다. 다른 경우 종료점은 시작점과 동일한 유형으로 변환됩니다. 끝이 시작하기 전에 결과는 음수입니다. 예를 들어 &lt;code&gt;startTime.until(endTime, HOURS)&lt;/code&gt; 사용하여 두 시간 객체 사이의 시간을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cc33fec53173d135a50ffbf92ecd960b4b26e20" translate="yes" xml:space="preserve">
          <source>This calculates the duration between two temporal objects. If the objects are of different types, then the duration is calculated based on the type of the first object. For example, if the first argument is a &lt;code&gt;LocalTime&lt;/code&gt; then the second argument is converted to a &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">이것은 두 시간 객체 사이의 지속 시간을 계산합니다. 객체의 유형이 다른 경우 지속 시간은 첫 번째 객체의 유형을 기준으로 계산됩니다. 예를 들어, 첫 번째 인수가 &lt;code&gt;LocalTime&lt;/code&gt; 이면 두 번째 인수는 &lt;code&gt;LocalTime&lt;/code&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="594e2f6af833c2542f6f050bdfea8088a78206f2" translate="yes" xml:space="preserve">
          <source>This calculates the period between two dates in terms of years, months and days. The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">이것은 두 날짜 사이의 기간을 년, 월 및 일로 계산합니다. 시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c0d5ebde5fbaa16b5f0a5ab228ff4a362b44867a" translate="yes" xml:space="preserve">
          <source>This calculates the period between two dates. All supplied chronologies calculate the period using years, months and days, however the &lt;code&gt;ChronoPeriod&lt;/code&gt; API allows the period to be represented using other units.</source>
          <target state="translated">두 날짜 사이의 기간을 계산합니다. 제공된 모든 연대기는 년, 월, 일을 사용하여 기간을 계산하지만 &lt;code&gt;ChronoPeriod&lt;/code&gt; API를 사용하면 다른 단위를 사용하여 기간을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3eb34b880dc06e18251e836328c9cf95247a612" translate="yes" xml:space="preserve">
          <source>This call is equivalent to the following code:</source>
          <target state="translated">이 호출은 다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0eda11cca3152f1293f0403ac2586884749c10f" translate="yes" xml:space="preserve">
          <source>This call is typically used to increase the scale, in which case it is guaranteed that there exists a &lt;code&gt;BigDecimal&lt;/code&gt; of the specified scale and the correct value. The call can also be used to reduce the scale if the caller knows that the &lt;code&gt;BigDecimal&lt;/code&gt; has sufficiently many zeros at the end of its fractional part (i.e., factors of ten in its integer value) to allow for the rescaling without changing its value.</source>
          <target state="translated">이 호출은 일반적으로 스케일을 늘리는 데 사용되며,이 경우 지정된 스케일 의 &lt;code&gt;BigDecimal&lt;/code&gt; 과 올바른 값 이 있음을 보장 합니다. 호출자가 &lt;code&gt;BigDecimal&lt;/code&gt; 이 소수 부분 (즉, 정수 값에서 10의 요소) 끝에 값이 변경되지 않고 크기를 조정할 수 있도록 충분히 많은 0을 가지고 있다는 것을 알고있는 경우 호출을 사용하여 스케일을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f47905a3cc645defe6a8d0f839946fd13048c6" translate="yes" xml:space="preserve">
          <source>This call takes into account any unprocessed (buffered) data from a previous &lt;code&gt;update&lt;/code&gt; call, padding, and AEAD tagging.</source>
          <target state="translated">이 호출은 이전 &lt;code&gt;update&lt;/code&gt; 호출, 패딩 및 AEAD 태깅 에서 처리되지 않은 (버퍼링 된) 데이터를 고려합니다 .</target>
        </trans-unit>
        <trans-unit id="296aa42b38e903ff1e454a8bcb6b056684be96f5" translate="yes" xml:space="preserve">
          <source>This callback is used by &lt;code&gt;SaslClient&lt;/code&gt; and &lt;code&gt;SaslServer&lt;/code&gt; to obtain a realm given a list of realm choices.</source>
          <target state="translated">이 콜백은 &lt;code&gt;SaslClient&lt;/code&gt; 및 &lt;code&gt;SaslServer&lt;/code&gt; 에서 영역 선택 목록이 제공된 영역을 얻기 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4649c6d05711daba7a8c470abe7c83a7037dc5d" translate="yes" xml:space="preserve">
          <source>This callback is used by &lt;code&gt;SaslClient&lt;/code&gt; and &lt;code&gt;SaslServer&lt;/code&gt; to retrieve realm information.</source>
          <target state="translated">이 콜백은 &lt;code&gt;SaslClient&lt;/code&gt; 및 &lt;code&gt;SaslServer&lt;/code&gt; 에서 영역 정보를 검색 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="da001e5eb0147319eb39f5e82d0f0125f6be1350" translate="yes" xml:space="preserve">
          <source>This callback is used by &lt;code&gt;SaslServer&lt;/code&gt; to determine whether one entity (identified by an authenticated authentication id) can act on behalf of another entity (identified by an authorization id).</source>
          <target state="translated">이 콜백은 &lt;code&gt;SaslServer&lt;/code&gt; 에서 사용되어 한 엔티티 (인증 된 인증 ID로 식별)가 다른 엔티티 (권한 부여 ID로 식별)를 대신하여 작동 할 수 있는지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="d9d531ae8fc123db629f09c058badc6dec936eab" translate="yes" xml:space="preserve">
          <source>This can be used to select between two or more ways that a date or time might be resolved. For example, if the formatter consists of year, month, day-of-month and day-of-year, then there are two ways to resolve a date. Calling this method with the arguments &lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#DAY_OF_YEAR&quot;&gt;&lt;code&gt;DAY_OF_YEAR&lt;/code&gt;&lt;/a&gt; will ensure that the date is resolved using the year and day-of-year, effectively meaning that the month and day-of-month are ignored during the resolving phase.</source>
          <target state="translated">날짜 또는 시간을 해결할 수있는 둘 이상의 방법 중에서 선택하는 데 사용할 수 있습니다. 예를 들어, 포맷터가 연도, 월, 일 및 월로 구성되어 있으면 날짜를 확인하는 두 가지 방법이 있습니다. 인수 &lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronofield#DAY_OF_YEAR&quot;&gt; &lt;code&gt;DAY_OF_YEAR&lt;/code&gt; &lt;/a&gt; 를 사용 하여이 메소드를 호출 하면 날짜와 연도를 사용하여 날짜가 해결되므로 사실상 해결 단계에서 월과 월이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e45280dbd70395d086faced1f60d08bd155ffe5" translate="yes" xml:space="preserve">
          <source>This can marginally decrease the transmitted size of the archive, at the expense of setting all installed files to a single date.</source>
          <target state="translated">이렇게하면 설치된 모든 파일을 단일 날짜로 설정하는 대신 파일의 전송 크기가 약간 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="578c6ceb1b651448d4047469d59db99838e5d5c3" translate="yes" xml:space="preserve">
          <source>This channel</source>
          <target state="translated">이 채널</target>
        </trans-unit>
        <trans-unit id="e9c69663f21441297e1f18b7c46f7d691e4a6034" translate="yes" xml:space="preserve">
          <source>This channel's file position, a non-negative integer counting the number of bytes from the beginning of the file to the current position</source>
          <target state="translated">이 채널의 파일 위치. 파일의 시작부터 현재 위치까지의 바이트 수를 계산하는 음이 아닌 정수</target>
        </trans-unit>
        <trans-unit id="affd2ee65dd82094eda8c4a2466f8bbdce3a032e" translate="yes" xml:space="preserve">
          <source>This channel's position, a non-negative integer counting the number of bytes from the beginning of the entity to the current position</source>
          <target state="translated">이 채널의 위치. 엔티티의 시작부터 현재 위치까지의 바이트 수를 계산하는 음이 아닌 정수</target>
        </trans-unit>
        <trans-unit id="062195b3fb91dca89b184564527c313265b74955" translate="yes" xml:space="preserve">
          <source>This character will be output during a format.</source>
          <target state="translated">이 문자는 형식 중에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="790384daa2c909e9dfeb5c3379af61db3570fae2" translate="yes" xml:space="preserve">
          <source>This check is made on a per lookup service basis to allow flexibility in the policy to reflect the needs of different lookup services.</source>
          <target state="translated">이 검사는 정책마다 융통성있게 다른 조회 서비스의 요구를 반영 할 수 있도록 조회 서비스별로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="a1caed47b8f1a4432c44cad1bdfdde7f88509c85" translate="yes" xml:space="preserve">
          <source>This checked exception is thrown when an</source>
          <target state="translated">이 확인 된 예외는</target>
        </trans-unit>
        <trans-unit id="28b63a9fef5f48dbf7c3a988ace8631c1510865f" translate="yes" xml:space="preserve">
          <source>This checks if the date-time can be queried for the specified field. If false, then calling the &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 필드에 대해 날짜-시간을 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e001386cca850781e9f7d8273bb9e3ed645a810" translate="yes" xml:space="preserve">
          <source>This checks if the specified field can be queried on this date-time. If false, then calling the &lt;a href=&quot;../temporal/temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronolocaldatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 필드를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;../temporal/temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;chronolocaldatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89949121330bc9ba6aed0e0bee18cb7f1eedc979" translate="yes" xml:space="preserve">
          <source>This checks if the specified field can be queried on this date-time. If false, then calling the &lt;a href=&quot;chronozoneddatetime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;chronozoneddatetime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronozoneddatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 필드를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;chronozoneddatetime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;chronozoneddatetime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;chronozoneddatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe7f34c857fcd2794bedd1a0b3d3849d857d1f" translate="yes" xml:space="preserve">
          <source>This checks if the specified field can be queried on this date. If false, then calling the &lt;a href=&quot;../temporal/temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronolocaldate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜에 지정된 필드를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;../temporal/temporalaccessor#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;chronolocaldate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="896450607daf28966676b17d89f57052b7a7a187" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to or subtracted from this date-time. If false, then calling the &lt;a href=&quot;chronolocaldatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronolocaldatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜를이 날짜-시간에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;chronolocaldatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;chronolocaldatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a16cdf6906b47ed394148421fdc66adcd20b8932" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to or subtracted from this date-time. If false, then calling the &lt;a href=&quot;chronozoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronozoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜를이 날짜-시간에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;chronozoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;chronozoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="499323b815ed97dfcc3d04aa828dc07969af7aa0" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to or subtracted from this date. If false, then calling the &lt;a href=&quot;chronolocaldate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;chronolocaldate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜를이 날짜에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;chronolocaldate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;chronolocaldate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbb4b9f8b1fb858c6ffabe9a99939c0deefd54d8" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the &lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;instant#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;instant#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8991a388ed5d1b8af35dc89e0fd0cd7d0cd2ec71" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;localdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5abaaac74440a4a0e20222e221c0976ae3d40277" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the &lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsetdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;offsetdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a32d76a7b3acabd4c5d884835fd8954deaee4df" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;temporal#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14e1fc6d16337742ca01416ba749c0d479def26f" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the &lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이 날짜-시간에 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a099085caa8337ae69ad5caf4c81c4a272c67340" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this date. If false, then calling the &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localdate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜를이 날짜에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;localdate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97524706a5e63c0e08b5f70958d56e0a4ec0818d" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this offset-time. If false, then calling the &lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsettime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 시간을이 오프셋 시간에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;offsettime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16986bde30ad8869a0ca62f1baa929296eef15df" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this time. If false, then calling the &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이번에는 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;localtime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b914ff1dc9985d7b396c05aa7450315a0c951e27" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this year-month. If false, then calling the &lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;yearmonth#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">이것은 올해 단위로 지정된 단위를 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;yearmonth#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf401dd8c41a53574fb734555172bd339bb8f26e" translate="yes" xml:space="preserve">
          <source>This checks if the specified unit can be added to, or subtracted from, this year. If false, then calling the &lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;year#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 단위를 올해에 더하거나 뺄 수 있는지 확인합니다. false 인 경우 &lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;year#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af21ec1477506ba05c4f5e6ba0156e95cf2f26ab" translate="yes" xml:space="preserve">
          <source>This checks if the standard offset and the actual offset are the same for the specified instant. If they are not, it is assumed that daylight savings is in operation.</source>
          <target state="translated">지정된 오프셋에 대해 표준 오프셋과 실제 오프셋이 동일한 지 확인합니다. 그렇지 않은 경우 일광 절약이 작동중인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="98ef38b56e840ab25453127b66d71cc1f136fdfc" translate="yes" xml:space="preserve">
          <source>This checks if this date can be queried for the specified field. If false, then calling the &lt;a href=&quot;japanesedate#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜에 대해이 날짜를 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;japanesedate#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/temporalaccessor#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9f1fc2b03dc91e397685c4017488e4266f24b7f" translate="yes" xml:space="preserve">
          <source>This checks if this date can be queried for the specified field. If false, then calling the &lt;a href=&quot;localdate#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;localdate#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜에 대해이 날짜를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;localdate#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;localdate#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39aa64124947cbb9407c2c86c4c30de5974fe7b8" translate="yes" xml:space="preserve">
          <source>This checks if this date-time can be queried for the specified field. If false, then calling the &lt;a href=&quot;localdatetime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;localdatetime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜에 대해이 날짜-시간을 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;localdatetime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;localdatetime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92920f3938ea8cbefe111f0da77e8729f0620df8" translate="yes" xml:space="preserve">
          <source>This checks if this date-time can be queried for the specified field. If false, then calling the &lt;a href=&quot;offsetdatetime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;offsetdatetime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsetdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜에 대해이 날짜-시간을 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;offsetdatetime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;offsetdatetime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;offsetdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b25971e07fe6643a5f6f05396b4f92b6e0af2e96" translate="yes" xml:space="preserve">
          <source>This checks if this date-time can be queried for the specified field. If false, then calling the &lt;a href=&quot;zoneddatetime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zoneddatetime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneddatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 날짜에 대해이 날짜-시간을 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;zoneddatetime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zoneddatetime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;zoneddatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e75f4b593a135657699b83696af0b83841468f2" translate="yes" xml:space="preserve">
          <source>This checks if this day-of-week can be queried for the specified field. If false, then calling the &lt;a href=&quot;dayofweek#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;dayofweek#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 요일에이 요일을 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;dayofweek#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;dayofweek#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf2af797d86f942cd2da9033ca56360472670c45" translate="yes" xml:space="preserve">
          <source>This checks if this era can be queried for the specified field. If false, then calling the &lt;a href=&quot;era#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;era#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 필드에 대해이 시대를 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;era#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;era#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="245129fc70a5436326dda9f234b222d0a93044ed" translate="yes" xml:space="preserve">
          <source>This checks if this instant can be queried for the specified field. If false, then calling the &lt;a href=&quot;instant#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;instant#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;instant#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 필드에 대해이 인스턴트를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;instant#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;instant#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;instant#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b211971db1795bc5585acaa903273b06269d2c5d" translate="yes" xml:space="preserve">
          <source>This checks if this month-day can be queried for the specified field. If false, then calling the &lt;a href=&quot;monthday#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;monthday#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 월에 대해이 월을 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;monthday#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;monthday#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="224a0a96dca5693e7f01300014d70926672a421d" translate="yes" xml:space="preserve">
          <source>This checks if this month-of-year can be queried for the specified field. If false, then calling the &lt;a href=&quot;month#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;month#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 달에 대해이 달을 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;month#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;month#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8343b04cd719d66f80c79958a49089d25cb754b8" translate="yes" xml:space="preserve">
          <source>This checks if this offset can be queried for the specified field. If false, then calling the &lt;a href=&quot;zoneoffset#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 필드에 대해이 오프셋을 쿼리 할 수 ​​있는지 확인합니다. false 인 경우 &lt;a href=&quot;zoneoffset#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffset#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e97f23736773ca5d20f1d9c0d96760a8e6252df" translate="yes" xml:space="preserve">
          <source>This checks if this time can be queried for the specified field. If false, then calling the &lt;a href=&quot;localtime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;localtime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 시간 동안이 시간을 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;localtime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;localtime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ca315efad6b7500b2ec870d5521340b5ca22434" translate="yes" xml:space="preserve">
          <source>This checks if this time can be queried for the specified field. If false, then calling the &lt;a href=&quot;offsettime#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;offsettime#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;offsettime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 시간 동안이 시간을 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;offsettime#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;offsettime#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;offsettime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0bd642d89c147b4df9975a43763e71737dd19b3" translate="yes" xml:space="preserve">
          <source>This checks if this year can be queried for the specified field. If false, then calling the &lt;a href=&quot;year#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;year#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;year#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 필드에 대해 올해를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;year#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;year#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;year#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="962a5b7bdfb5ae41751b10c91017e6097b971dd2" translate="yes" xml:space="preserve">
          <source>This checks if this year-month can be queried for the specified field. If false, then calling the &lt;a href=&quot;yearmonth#range-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;yearmonth#get-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;yearmonth#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; methods will throw an exception.</source>
          <target state="translated">지정된 연도에 대해 이번 연도를 쿼리 할 수 ​​있는지 확인합니다. 다음 호출 false의 경우 &lt;a href=&quot;yearmonth#range-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;yearmonth#get-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;yearmonth#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 방법은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e43092d27505a008a9bf4137b2d9b53dee85b7d6" translate="yes" xml:space="preserve">
          <source>This checks that all valid values are within the bounds of an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">모든 유효한 값이 &lt;code&gt;int&lt;/code&gt; 범위 내에 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="0650e9af54b80c91c876b4f8f70fa9c63e34d721" translate="yes" xml:space="preserve">
          <source>This checks that the implementing date-time can add/subtract this unit. This can be used to avoid throwing an exception.</source>
          <target state="translated">이를 통해 구현 날짜-시간이이 단위를 추가 / 감소 할 수 있는지 확인합니다. 예외가 발생하지 않도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4b9f69e60cf5452eb12206977163925e6b8007" translate="yes" xml:space="preserve">
          <source>This checks that the value is within the stored range of values.</source>
          <target state="translated">값이 저장된 값 범위 내에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f04f4cea51d94a0009200fc39cd5bbe3d4afe8e4" translate="yes" xml:space="preserve">
          <source>This checks to see if the given offset will be valid at some point in the transition. A gap will always return false. An overlap will return true if the offset is either the before or after offset.</source>
          <target state="translated">이것은 주어진 오프셋이 전환의 어느 시점에서 유효한지 확인합니다. 간격은 항상 거짓을 반환합니다. 오프셋이 이전 또는 이후 오프셋 인 경우 오버랩은 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="265c01caaca3f3e5bf023b6d2c23765fed66fd0a" translate="yes" xml:space="preserve">
          <source>This checks to see if this date represents a point on the local time-line after the other date.</source>
          <target state="translated">이 날짜가 다른 날짜 이후의 현지 타임 라인의 한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a926e8f5a354ef5894035bb6914fa9312300051e" translate="yes" xml:space="preserve">
          <source>This checks to see if this date represents a point on the local time-line before the other date.</source>
          <target state="translated">이 날짜가 다른 날짜 이전의 현지 타임 라인의 한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1e00037dbb39ec0a9c9ac1bcb2daa7ee63e3c8d6" translate="yes" xml:space="preserve">
          <source>This checks to see if this date represents the same point on the local time-line as the other date.</source>
          <target state="translated">이 날짜가 다른 날짜와 같은 현지 시간 표시 줄의 동일한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7d3fde6570177af9d05099a481bfb884a1b02705" translate="yes" xml:space="preserve">
          <source>This checks to see if this date-time represents a point on the local time-line after the other date-time.</source>
          <target state="translated">이 날짜-시간이 다른 날짜-시간 이후의 로컬 타임 라인의 한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5ca88dbc6e85ad56cfac4f5a132ad59a8a0c65de" translate="yes" xml:space="preserve">
          <source>This checks to see if this date-time represents a point on the local time-line before the other date-time.</source>
          <target state="translated">이 날짜-시간이 다른 날짜-시간 이전의 로컬 타임 라인의 한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="46b058621489d3ca1904f5844641d2db4cfd1f15" translate="yes" xml:space="preserve">
          <source>This checks to see if this date-time represents the same point on the local time-line as the other date-time.</source>
          <target state="translated">이 날짜-시간이 다른 날짜-시간과 로컬 시간 표시 줄의 동일한 지점을 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f3da7c16000c65374ad23d5ee50855e929a6af85" translate="yes" xml:space="preserve">
          <source>This checks whether the years, months or days units are less than zero.</source>
          <target state="translated">년, 월 또는 일 단위가 0보다 작은 지 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7e65501fe8b51cdc6a79e5fd57da96a8104d6ec8" translate="yes" xml:space="preserve">
          <source>This chronology defines the rules of the ISO calendar system. This calendar system is based on the ISO-8601 standard, which is the</source>
          <target state="translated">이 연대기는 ISO 캘린더 시스템의 규칙을 정의합니다. 이 캘린더 시스템은 ISO-8601 표준을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f2672ddfe9764a0398589d00c507a97713a9b680" translate="yes" xml:space="preserve">
          <source>This chronology defines the rules of the Japanese Imperial calendar system. This calendar system is primarily used in Japan. The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering.</source>
          <target state="translated">이 연대기는 일본 제국 달력 시스템의 규칙을 정의합니다. 이 달력 시스템은 주로 일본에서 사용됩니다. 일본 제국 달력 시스템은 시대 별 연도 번호를 제외하고 ISO 달력 시스템과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f287d87771abb8efb52de119872d348265a82a59" translate="yes" xml:space="preserve">
          <source>This chronology defines the rules of the Minguo calendar system. This calendar system is primarily used in the Republic of China, often known as Taiwan. Dates are aligned such that &lt;code&gt;0001-01-01 (Minguo)&lt;/code&gt; is &lt;code&gt;1912-01-01 (ISO)&lt;/code&gt;.</source>
          <target state="translated">이 연대기는 Minguo 캘린더 시스템의 규칙을 정의합니다. 이 캘린더 시스템은 주로 대만으로 알려진 중국에서 주로 사용됩니다. &lt;code&gt;0001-01-01 (Minguo)&lt;/code&gt; 이 &lt;code&gt;1912-01-01 (ISO)&lt;/code&gt; 가되도록 날짜가 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="e67fb8bd1997ec68d2aad9ffaec53c7b1557fefe" translate="yes" xml:space="preserve">
          <source>This chronology defines the rules of the Thai Buddhist calendar system. This calendar system is primarily used in Thailand. Dates are aligned such that &lt;code&gt;2484-01-01 (Buddhist)&lt;/code&gt; is &lt;code&gt;1941-01-01 (ISO)&lt;/code&gt;.</source>
          <target state="translated">이 연대기는 태국 불교 달력 시스템의 규칙을 정의합니다. 이 달력 시스템은 주로 태국에서 사용됩니다. &lt;code&gt;2484-01-01 (Buddhist)&lt;/code&gt; 이 &lt;code&gt;1941-01-01 (ISO)&lt;/code&gt; 이되도록 날짜가 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="fc07d7dd0027616976f4483849a8d9d04205cb46" translate="yes" xml:space="preserve">
          <source>This class acts as a factory for key managers based on a source of key material.</source>
          <target state="translated">이 클래스는 키 자료 소스를 기반으로하는 키 관리자의 팩토리 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="2a0a7454493f3db4c77f185a02b23b164174be56" translate="yes" xml:space="preserve">
          <source>This class acts as a factory for key managers based on a source of key material. Each key manager manages a specific type of key material for use by secure sockets. The key material is based on a KeyStore and/or provider specific sources.</source>
          <target state="translated">이 클래스는 키 자료 소스를 기반으로하는 키 관리자의 팩토리 역할을합니다. 각 키 관리자는 보안 소켓에서 사용할 특정 유형의 키 자료를 관리합니다. 키 자료는 KeyStore 및 / 또는 제공자 특정 소스를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="8a16a01436e97318ea3255ad09e29584197177c0" translate="yes" xml:space="preserve">
          <source>This class acts as a factory for trust managers based on a source of trust material.</source>
          <target state="translated">이 클래스는 신뢰 자료 소스를 기반으로하는 신뢰 관리자의 팩토리 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="d9c0ab1da3b6d2aa2b4ade72f525fa8860f50e7a" translate="yes" xml:space="preserve">
          <source>This class acts as a factory for trust managers based on a source of trust material. Each trust manager manages a specific type of trust material for use by secure sockets. The trust material is based on a KeyStore and/or provider specific sources.</source>
          <target state="translated">이 클래스는 신뢰 자료 소스를 기반으로하는 신뢰 관리자의 팩토리 역할을합니다. 각 신뢰 관리자는 보안 소켓에서 사용할 특정 유형의 신뢰 자료를 관리합니다. 신뢰 자료는 KeyStore 및 / 또는 제공자 특정 소스를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="c911b08ea419f003753c346ff87b6440e99d5888" translate="yes" xml:space="preserve">
          <source>This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG reader plug-in.</source>
          <target state="translated">이 클래스는 내장 JPEG 리더 플러그인을 사용할 때 JPEG 양자화 및 허프만 테이블을 설정하는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e2691ba9db3001e7d91ebcdc6955b689a032cf1c" translate="yes" xml:space="preserve">
          <source>This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG reader plug-in. An instance of this class will be returned from the &lt;code&gt;getDefaultImageReadParam&lt;/code&gt; methods of the built-in JPEG &lt;code&gt;ImageReader&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 내장 JPEG 리더 플러그인을 사용할 때 JPEG 양자화 및 허프만 테이블을 설정하는 기능을 추가합니다. 이 클래스의 인스턴스는 내장 JPEG &lt;code&gt;ImageReader&lt;/code&gt; 의 &lt;code&gt;getDefaultImageReadParam&lt;/code&gt; 메소드 로부터 돌려 주어 집니다.</target>
        </trans-unit>
        <trans-unit id="77c5aed8d2bdde726d3a02900753ab0db680cdc5" translate="yes" xml:space="preserve">
          <source>This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG writer plug-in, and to request that optimized Huffman tables be computed for an image.</source>
          <target state="translated">이 클래스는 내장 JPEG 라이터 플러그인을 사용할 때 JPEG 양자화 및 허프만 테이블을 설정하고 이미지에 대해 최적화 된 허프만 테이블을 계산하도록 요청하는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4dfa7cbf1bfbfe2a4f1633752f9e49f0aad38f7b" translate="yes" xml:space="preserve">
          <source>This class adds the ability to set JPEG quantization and Huffman tables when using the built-in JPEG writer plug-in, and to request that optimized Huffman tables be computed for an image. An instance of this class will be returned from the &lt;code&gt;getDefaultImageWriteParam&lt;/code&gt; methods of the built-in JPEG &lt;code&gt;ImageWriter&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 내장 JPEG 라이터 플러그인을 사용할 때 JPEG 양자화 및 허프만 테이블을 설정하고 이미지에 대해 최적화 된 허프만 테이블을 계산하도록 요청하는 기능을 추가합니다. 이 클래스의 인스턴스는 내장 JPEG &lt;code&gt;ImageWriter&lt;/code&gt; 의 &lt;code&gt;getDefaultImageWriteParam&lt;/code&gt; 메소드 로부터 돌려 주어 집니다.</target>
        </trans-unit>
        <trans-unit id="d6ac544140297f561bd1c7ede858f5e6a7f2cc35" translate="yes" xml:space="preserve">
          <source>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.FilterInputStream and java.io.InputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all. Moreover, this class catches all exceptions that are not thrown by its ancestor classes. In particular, the &lt;code&gt;skip&lt;/code&gt; method skips, and the &lt;code&gt;available&lt;/code&gt; method counts only data that have been processed by the encapsulated Cipher.</source>
          <target state="translated">이 클래스는 상위 클래스 java.io.FilterInputStream 및 java.io.InputStream의 시맨틱, 특히 실패 시맨틱을 엄격하게 준수합니다. 이 클래스는 상위 클래스에 지정된 메소드를 정확하게 가지고 있으며 모든 메소드를 대체합니다. 또한이 클래스는 조상 클래스에서 발생하지 않는 모든 예외를 포착합니다. 특히, &lt;code&gt;skip&lt;/code&gt; 메소드는 건너 뛰고 &lt;code&gt;available&lt;/code&gt; 메소드는 캡슐화 된 Cipher에 의해 처리 된 데이터 만 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c66433003e78fb298309a0cb99c19c9629392e11" translate="yes" xml:space="preserve">
          <source>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes java.io.OutputStream and java.io.FilterOutputStream. This class has exactly those methods specified in its ancestor classes, and overrides them all. Moreover, this class catches all exceptions that are not thrown by its ancestor classes.</source>
          <target state="translated">이 클래스는 상위 클래스 java.io.OutputStream 및 java.io.FilterOutputStream의 시맨틱, 특히 실패 시맨틱을 엄격하게 준수합니다. 이 클래스는 상위 클래스에 지정된 메소드를 정확하게 가지고 있으며 모든 메소드를 대체합니다. 또한이 클래스는 조상 클래스에서 발생하지 않는 모든 예외를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="13ee0c499ccacc109c50c74284032b81d0afb937" translate="yes" xml:space="preserve">
          <source>This class allows an application to create an input stream in which the bytes read are supplied by the contents of a string. Applications can also read bytes from a byte array by using a &lt;code&gt;ByteArrayInputStream&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 어플리케이션이 읽은 바이트가 문자열의 내용에 의해 제공되는 입력 스트림을 작성할 수있게합니다. 응용 프로그램은 &lt;code&gt;ByteArrayInputStream&lt;/code&gt; 을 사용하여 바이트 배열에서 바이트를 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="345efd47d898aa1e229a2bf9d4103e663820ff7d" translate="yes" xml:space="preserve">
          <source>This class allows for the specification of various parameters while writing a BMP format image file. By default, the data layout is bottom-up, such that the pixels are stored in bottom-up order, the first scanline being stored last.</source>
          <target state="translated">이 클래스는 BMP 형식 이미지 파일을 작성하는 동안 다양한 매개 변수를 지정할 수 있습니다. 기본적으로 데이터 레이아웃은 상향식이므로 픽셀은 상향식 순서로 저장되며 첫 번째 스캔 라인은 마지막에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="140e3e5d12e36ac06b631eacafcc8c3345838175" translate="yes" xml:space="preserve">
          <source>This class allows rules for identifying future transitions to be expressed. A rule might be written in many forms:</source>
          <target state="translated">이 클래스를 사용하면 향후 전환을 식별하기위한 규칙을 표현할 수 있습니다. 규칙은 여러 형태로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="883a340235c5e37d5d31802323e643a49c062394" translate="yes" xml:space="preserve">
          <source>This class also defines factory methods that allow a &lt;a href=&quot;../../lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; to be specified when locating a provider. As with installed providers, the provider classes are identified by placing the provider configuration file in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 공급자를 찾을 때 &lt;a href=&quot;../../lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 를 지정할 수있는 팩토리 메소드도 정의합니다 . 설치된 제공자와 마찬가지로 제공자 구성 파일을 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 배치하여 제공자 클래스를 식별 합니다 .</target>
        </trans-unit>
        <trans-unit id="8544b2160ddbef279d46a118efdbdae999cd88f3" translate="yes" xml:space="preserve">
          <source>This class also defines methods for maintaining a selector's cancelled-key set and for removing a key from its channel's key set, and declares the abstract &lt;a href=&quot;abstractselector#register-java.nio.channels.spi.AbstractSelectableChannel-int-java.lang.Object-&quot;&gt;&lt;code&gt;register&lt;/code&gt;&lt;/a&gt; method that is invoked by a selectable channel's &lt;a href=&quot;abstractselectablechannel#register-java.nio.channels.Selector-int-java.lang.Object-&quot;&gt;&lt;code&gt;register&lt;/code&gt;&lt;/a&gt; method in order to perform the actual work of registering a channel.</source>
          <target state="translated">이 클래스는 또한 셀렉터의 취소 된 키 세트를 유지 관리하고 채널의 키 세트에서 키를 제거하는 메소드를 정의하고, 채널 을 등록하는 실제 작업을 수행하기 위해 선택 가능한 채널의 &lt;a href=&quot;abstractselectablechannel#register-java.nio.channels.Selector-int-java.lang.Object-&quot;&gt; &lt;code&gt;register&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출되는 추상 &lt;a href=&quot;abstractselector#register-java.nio.channels.spi.AbstractSelectableChannel-int-java.lang.Object-&quot;&gt; &lt;code&gt;register&lt;/code&gt; &lt;/a&gt; 메소드를 선언합니다. .</target>
        </trans-unit>
        <trans-unit id="800bb7cdbb26403b8253b92ac40e8720a35d0118" translate="yes" xml:space="preserve">
          <source>This class also defines methods for replacing matched subsequences with new strings whose contents can, if desired, be computed from the match result. The &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt;&lt;code&gt;appendReplacement&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;matcher#appendTail-java.lang.StringBuffer-&quot;&gt;&lt;code&gt;appendTail&lt;/code&gt;&lt;/a&gt; methods can be used in tandem in order to collect the result into an existing string buffer, or the more convenient &lt;a href=&quot;matcher#replaceAll-java.lang.String-&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; method can be used to create a string in which every matching subsequence in the input sequence is replaced.</source>
          <target state="translated">이 클래스는 또한 일치하는 서브 시퀀스를 원하는 경우 일치 결과에서 컨텐츠를 계산할 수있는 새 문자열로 대체하기위한 메소드를 정의합니다. &lt;a href=&quot;matcher#appendReplacement-java.lang.StringBuffer-java.lang.String-&quot;&gt; &lt;code&gt;appendReplacement&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;matcher#appendTail-java.lang.StringBuffer-&quot;&gt; &lt;code&gt;appendTail&lt;/code&gt; &lt;/a&gt; 방법은 기존 문자열 버퍼에 결과를 수집하기 위해 직렬로 사용될 수 있으며, 또는보다 편리 &lt;a href=&quot;matcher#replaceAll-java.lang.String-&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 방법은, 입력 시퀀스의 모든 매칭 시퀀스가 치환 된 문자열을 생성하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="eb5b370e1171b96ffc5a2d05a76690caa47226f8" translate="yes" xml:space="preserve">
          <source>This class also defines static methods for testing whether a particular charset is supported, for locating charset instances by name, and for constructing a map that contains every charset for which support is available in the current Java virtual machine. Support for new charsets can be added via the service-provider interface defined in the &lt;a href=&quot;spi/charsetprovider&quot;&gt;&lt;code&gt;CharsetProvider&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 클래스는 또한 특정 문자 세트가 지원되는지 테스트하고 이름으로 문자 세트 인스턴스를 찾고 현재 Java 가상 머신에서 지원되는 모든 문자 세트를 포함하는 맵을 구성하기위한 정적 메소드를 정의합니다. &lt;a href=&quot;spi/charsetprovider&quot;&gt; &lt;code&gt;CharsetProvider&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 서비스 공급자 인터페이스를 통해 새 문자 세트에 대한 지원을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6107bcbf688c4a8e406ba31ee1bc08a7a500f8fe" translate="yes" xml:space="preserve">
          <source>This class also extends &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; so as to define methods to get and set the file owner.</source>
          <target state="translated">또한이 클래스는 &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; 를 확장 하여 파일 소유자를 가져오고 설정하는 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="759e9c8edfea028125ddb4633f8e5b4e40b88175" translate="yes" xml:space="preserve">
          <source>This class also provides additional commonly used bounded random generation methods.</source>
          <target state="translated">이 클래스는 또한 일반적으로 사용되는 추가 된 무작위 생성 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f9db46f37b6f37829cea24460ae2fcad6fbd1820" translate="yes" xml:space="preserve">
          <source>This class also provides convenience methods to &lt;a href=&quot;semaphore#acquire-int-&quot;&gt;&lt;code&gt;acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;semaphore#release-int-&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; multiple permits at a time. Beware of the increased risk of indefinite postponement when these methods are used without fairness set true.</source>
          <target state="translated">이 클래스는 또한 한 번에 여러 허가 를 &lt;a href=&quot;semaphore#acquire-int-&quot;&gt; &lt;code&gt;acquire&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;semaphore#release-int-&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 하는 편리한 방법을 제공합니다 . 이러한 방법을 공정하게 사용하지 않고 사용할 경우 무기한 연기의 위험이 증가한다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="388897f95e2ff6372628c92b420d7766250b3049" translate="yes" xml:space="preserve">
          <source>This class also provides hooks that make it possible to supply custom descriptions and names for the &lt;a href=&quot;mbeaninfo&quot;&gt;&lt;code&gt;MBeanInfo&lt;/code&gt;&lt;/a&gt; returned by the DynamicMBean interface.</source>
          <target state="translated">이 클래스는 또한 DynamicMBean 인터페이스에서 리턴 한 &lt;a href=&quot;mbeaninfo&quot;&gt; &lt;code&gt;MBeanInfo&lt;/code&gt; 에&lt;/a&gt; 대한 사용자 정의 설명 및 이름을 제공 할 수있는 후크를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3e214e2e116cbd8d9d4053eaab2404092347b186" translate="yes" xml:space="preserve">
          <source>This class also supports methods that conditionally provide conversions across the three modes. For example, method &lt;a href=&quot;stampedlock#tryConvertToWriteLock-long-&quot;&gt;&lt;code&gt;tryConvertToWriteLock(long)&lt;/code&gt;&lt;/a&gt; attempts to &quot;upgrade&quot; a mode, returning a valid write stamp if (1) already in writing mode (2) in reading mode and there are no other readers or (3) in optimistic mode and the lock is available. The forms of these methods are designed to help reduce some of the code bloat that otherwise occurs in retry-based designs.</source>
          <target state="translated">이 클래스는 또한 세 가지 모드에서 조건부로 변환을 제공하는 메소드를 지원합니다. 예를 들어, &lt;a href=&quot;stampedlock#tryConvertToWriteLock-long-&quot;&gt; &lt;code&gt;tryConvertToWriteLock(long)&lt;/code&gt; &lt;/a&gt; 메소드는 (1) 이미 쓰기 모드에 있고 (2) 읽기 모드에 있고 다른 판독기가 없거나 (3) 낙관적 모드에있는 경우 유효한 쓰기 스탬프를 반환하여 모드를 &quot;업그레이드&quot;하려고 시도합니다. 잠금이 가능합니다. 이러한 방법의 형태는 재시도 기반 설계에서 발생하는 일부 코드 팽창을 줄이는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a00765dbf6fd5bee7c0cb57ffcf0fb5907d6bb4" translate="yes" xml:space="preserve">
          <source>This class always replaces malformed surrogate elements and unmappable character sequences with the charset's default</source>
          <target state="translated">이 클래스는 항상 잘못된 대리 요소와 매핑 할 수없는 문자 시퀀스를 문자 집합의 기본값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2c924ddcfb11ff34458b625cfb5bc3a8a092689c" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;../collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="caedfeebaf4719dc6fcd730450a6cc6bdb4c5939" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces. The Iterator provided in method &lt;a href=&quot;delayqueue#iterator--&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of the DelayQueue in any particular order.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;../collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 . &lt;a href=&quot;delayqueue#iterator--&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 메소드에 제공된 Iterator 는 특정 순서로 DelayQueue의 요소를 순회한다고 보장 &lt;em&gt;하지 않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40f8fce0544f16774f1621d14ca4d225948f2bdf" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces. The Iterator provided in method &lt;a href=&quot;priorityblockingqueue#iterator--&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of the PriorityBlockingQueue in any particular order. If you need ordered traversal, consider using &lt;code&gt;Arrays.sort(pq.toArray())&lt;/code&gt;. Also, method &lt;code&gt;drainTo&lt;/code&gt; can be used to &lt;em&gt;remove&lt;/em&gt; some or all elements in priority order and place them in another collection.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;../collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 . 반복자 방식으로 제공 &lt;a href=&quot;priorityblockingqueue#iterator--&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 특정 순서 인 PriorityBlockingQueue의 요소를 통과 보장. 순서 순회가 필요한 경우 &lt;code&gt;Arrays.sort(pq.toArray())&lt;/code&gt; 사용을 고려하십시오 . 또한 &lt;code&gt;drainTo&lt;/code&gt; 메서드를 사용하여 일부 또는 모든 요소를 ​​우선 순위대로 &lt;em&gt;제거&lt;/em&gt; 하고 다른 컬렉션에 배치 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d9f6bf748b95eac88b62dd7afacd5a8aa1e40da" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../deque&quot;&gt;&lt;code&gt;Deque&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 해당 반복기 는 &lt;a href=&quot;../deque&quot;&gt; &lt;code&gt;Deque&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad988531a4324358d99a6ecc31419085cfbbef7" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 해당 반복기 는 &lt;a href=&quot;../queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="35873d3267139d8d755ababcaa078e4145b88017" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e244e2d44c033168919981aa9877da35b94bdea6" translate="yes" xml:space="preserve">
          <source>This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces. The Iterator provided in method &lt;a href=&quot;priorityqueue#iterator--&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using &lt;code&gt;Arrays.sort(pq.toArray())&lt;/code&gt;.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 . 방법에 제공된 반복자 &lt;a href=&quot;priorityqueue#iterator--&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 특정 순서로 우선 순위 큐의 요소를 통과 보장. 순서 순회가 필요한 경우 &lt;code&gt;Arrays.sort(pq.toArray())&lt;/code&gt; 사용을 고려하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5e15d54db024790d58205f4d994a57d20890421" translate="yes" xml:space="preserve">
          <source>This class and its iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces. Like most other concurrent collection implementations, this class does not permit the use of &lt;code&gt;null&lt;/code&gt; elements, because &lt;code&gt;null&lt;/code&gt; arguments and return values cannot be reliably distinguished from the absence of elements.</source>
          <target state="translated">이 클래스와 반복자 는 &lt;a href=&quot;../set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 . 대부분의 다른 동시 콜렉션 구현과 마찬가지로이 클래스는 &lt;code&gt;null&lt;/code&gt; 인수 및 리턴 값을 요소가없는 것과 확실하게 구별 할 수 없으므로 &lt;code&gt;null&lt;/code&gt; 요소 의 사용을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0660b496da92e14815a4d2a72b5668f5dc39ac" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 뷰 및 반복자 는 &lt;a href=&quot;../map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd49627c9771a5ac8b18c8f6e51a5ed51ae7566" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;../map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; interfaces. Like most other concurrent collections, this class does &lt;em&gt;not&lt;/em&gt; permit the use of &lt;code&gt;null&lt;/code&gt; keys or values because some null return values cannot be reliably distinguished from the absence of elements.</source>
          <target state="translated">이 클래스와 뷰 및 반복자 는 &lt;a href=&quot;../map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메소드를 구현합니다 . 대부분의 다른 동시 컬렉션과 마찬가지로,이 클래스는 않습니다 &lt;em&gt;하지&lt;/em&gt; 의 사용을 허용 &lt;code&gt;null&lt;/code&gt; 일부는 null 반환 값이 안정적으로 요소의 부재 구별 할 수 없기 때문에 키 또는 값을.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e421f4acf9e80902e544cac7ff5823ab2877594" translate="yes" xml:space="preserve">
          <source>This class associates, with each thread that uses it, a permit (in the sense of the &lt;a href=&quot;../semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; class). A call to &lt;code&gt;park&lt;/code&gt; will return immediately if the permit is available, consuming it in the process; otherwise it &lt;em&gt;may&lt;/em&gt; block. A call to &lt;code&gt;unpark&lt;/code&gt; makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.)</source>
          <target state="translated">이 클래스는이를 사용하는 각 스레드와 허가 ( &lt;a href=&quot;../semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 클래스 의 의미에서)를 연관시킵니다 . 를 호출 &lt;code&gt;park&lt;/code&gt; 허가 과정에서 그것을 소모를 사용할 수있는 경우 즉시 반환합니다; 그렇지 않으면 차단 &lt;em&gt;될 수&lt;/em&gt; 있습니다. 를 호출 &lt;code&gt;unpark&lt;/code&gt; 이미 사용할 수없는 경우, 허가 (permit)가 사용할 수 있습니다. (세마포어와 달리 허가는 누적되지 않습니다. 최대 1 개가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="dd0f9876e6138197a3b7c504077f0adca6ca21e4" translate="yes" xml:space="preserve">
          <source>This class brings more flexibility to the notion of Management Interface in the use of Standard MBeans. Straightforward use of the patterns for Standard MBeans described in the JMX Specification means that there is a fixed relationship between the implementation class of an MBean and its management interface (i.e., if the implementation class is Thing, the management interface must be ThingMBean). This class makes it possible to keep the convenience of specifying the management interface with a Java interface, without requiring that there be any naming relationship between the implementation and interface classes.</source>
          <target state="translated">이 클래스는 표준 MBean 사용시 관리 인터페이스 개념에 더 많은 유연성을 제공합니다. JMX 스펙에 기술 된 표준 MBean에 대한 패턴의 간단한 사용은 MBean의 구현 클래스와 관리 인터페이스 사이에 고정 된 관계가 있음을 의미합니다 (즉, 구현 클래스가 Thing 인 경우 관리 인터페이스는 ThingMBean이어야 함). 이 클래스를 사용하면 구현과 인터페이스 클래스간에 이름 지정 관계가 없어도 Java 인터페이스로 관리 인터페이스를 편리하게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f5e7e6debadb6bc7d15130372b1009e07cd59e" translate="yes" xml:space="preserve">
          <source>This class can be instantiated by a string representation of the RDN defined in RFC 2253 as shown in the following code example:</source>
          <target state="translated">이 클래스는 다음 코드 예제와 같이 RFC 2253에 정의 된 RDN의 문자열 표현으로 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="408aa59b50ee1cd17fc707c3d6d1ca84920d2eac" translate="yes" xml:space="preserve">
          <source>This class can be instantiated by using a string representation of the distinguished name, or by using the ASN.1 DER encoded byte representation of the distinguished name. The current specification for the string representation of a distinguished name is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253: Lightweight Directory Access Protocol (v3): UTF-8 String Representation of Distinguished Names&lt;/a&gt;. This class, however, accepts string formats from both RFC 2253 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1779.txt&quot;&gt;RFC 1779: A String Representation of Distinguished Names&lt;/a&gt;, and also recognizes attribute type keywords whose OIDs (Object Identifiers) are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 식별 이름의 문자열 표현을 사용하거나 식별 이름의 ASN.1 DER 인코딩 된 바이트 표현을 사용하여 인스턴스화 할 수 있습니다. 식별 이름의 문자열 표시에 대한 현재 스펙은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253 : 경량 디렉토리 액세스 프로토콜 (v3) : 구별 이름의 UTF-8&lt;/a&gt; 문자열 표시에 정의되어 있습니다. 그러나이 클래스는 RFC 2253 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1779.txt&quot;&gt;RFC 1779 : 식별 이름의 문자열 표현&lt;/a&gt; 에서 문자열 형식을 허용 하며 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280 : Internet X.509 공개 키 인프라 인증서 및&lt;/a&gt; OID (개체 식별자)가 OID (개체 식별자)로 정의 된 속성 유형 키워드도 인식합니다 . CRL 프로필 .</target>
        </trans-unit>
        <trans-unit id="22cda7839ea871c5574403a26f0611bfb6183d06" translate="yes" xml:space="preserve">
          <source>This class can be serialized and stores the string zone ID in the external form. The &lt;code&gt;ZoneOffset&lt;/code&gt; subclass uses a dedicated format that only stores the offset from UTC/Greenwich.</source>
          <target state="translated">이 클래스는 직렬화 할 수 있으며 외부 영역에 문자열 영역 ID를 저장합니다. &lt;code&gt;ZoneOffset&lt;/code&gt; 서브 클래스 용도에만 저장이 UTC / 그리니치에서 오프셋 전용 형식입니다.</target>
        </trans-unit>
        <trans-unit id="08caf67472a9c4270c71d609d696e3667269ecae" translate="yes" xml:space="preserve">
          <source>This class can be used to initialize a &lt;code&gt;Cipher&lt;/code&gt; object that implements the</source>
          <target state="translated">이 클래스는 다음 을 구현 하는 &lt;code&gt;Cipher&lt;/code&gt; 객체 를 초기화하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a7be8980f88523567e69634ed88eb43eb7a20a7" translate="yes" xml:space="preserve">
          <source>This class cannot be instantiated. It has only static methods.</source>
          <target state="translated">이 클래스는 인스턴스화 할 수 없습니다. 정적 메소드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f3489be448c81f6059af9b604eab721ae2b783" translate="yes" xml:space="preserve">
          <source>This class centralizes all security properties and common security methods.</source>
          <target state="translated">이 클래스는 모든 보안 속성과 일반적인 보안 방법을 중앙 집중화합니다.</target>
        </trans-unit>
        <trans-unit id="dc8b950092cbcc01690c61de27fb3ae19d4e974f" translate="yes" xml:space="preserve">
          <source>This class centralizes all security properties and common security methods. One of its primary uses is to manage providers.</source>
          <target state="translated">이 클래스는 모든 보안 속성과 일반적인 보안 방법을 중앙 집중화합니다. 주요 용도 중 하나는 공급자를 관리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6cb96a6673c912eb785c3687c59092c3790b519" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods for obtaining encoders and decoders for the Base64 encoding scheme.</source>
          <target state="translated">이 클래스는 Base64 인코딩 체계에 대한 인코더 및 디코더를 얻기위한 정적 메소드로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c26324f4ebfc25aeaffc4122553f9b3b6f2a74b0" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods for obtaining encoders and decoders for the Base64 encoding scheme. The implementation of this class supports the following types of Base64 as specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 Base64 인코딩 체계에 대한 인코더 및 디코더를 얻기위한 정적 메소드로만 구성됩니다. 이 클래스의 구현은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045에&lt;/a&gt; 지정된대로 다음 유형의 Base64를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="70f8b85b793509ea8934dc209fad03b9b5008a13" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that help adapt method handles to other JVM types, such as interfaces.</source>
          <target state="translated">이 클래스는 인터페이스와 같은 다른 JVM 유형에 대한 메소드 핸들을 조정하는 데 도움이되는 정적 메소드로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="43d1381f06f84f756c39b887a569b407d32db808" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on files, directories, or other types of files.</source>
          <target state="translated">이 클래스는 파일, 디렉토리 또는 다른 유형의 파일에서 작동하는 정적 메소드로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f1c00fd4abcf08932e8295ad0ab5d4edf45278f8" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on or return collections.</source>
          <target state="translated">이 클래스는 컬렉션에서 작동하거나 컬렉션을 반환하는 정적 메서드로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2c343c6383fb79e44f84addffdad6704e48b70c6" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, &quot;wrappers&quot;, which return a new collection backed by a specified collection, and a few other odds and ends.</source>
          <target state="translated">이 클래스는 컬렉션에서 작동하거나 컬렉션을 반환하는 정적 메서드로만 구성됩니다. 여기에는 컬렉션에서 작동하는 다형성 알고리즘, &quot;래퍼&quot;가 포함되어 있는데,이 컬렉션은 지정된 컬렉션으로 뒷받침되는 새 컬렉션을 반환하며 다른 확률과 끝도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8606d91ec86719639d5cef7ea45e744cdd1a3c30" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on or return method handles.</source>
          <target state="translated">이 클래스는 독점적으로 작동하거나 메소드 핸들을 리턴하는 정적 메소드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="66cb9dc1c07813623f3d59a48ce5a193b59e02f4" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on or return method handles. They fall into several categories:</source>
          <target state="translated">이 클래스는 독점적으로 작동하거나 메소드 핸들을 리턴하는 정적 메소드로 구성됩니다. 그들은 여러 범주로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="9387ec154802c2f1f1f0551417b10625786c8612" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that operate on sets of &lt;a href=&quot;posixfilepermission&quot;&gt;&lt;code&gt;PosixFilePermission&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;posixfilepermission&quot;&gt; &lt;code&gt;PosixFilePermission&lt;/code&gt; &lt;/a&gt; 객체 세트에서 작동하는 정적 메소드로만 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="24b9a888f811ee23b32a4d03f075039b51070f5b" translate="yes" xml:space="preserve">
          <source>This class consists exclusively of static methods that return a &lt;a href=&quot;path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; by converting a path string or &lt;a href=&quot;../../net/uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 반환 정적 메소드의 독점적 구성 &lt;a href=&quot;path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 경로 문자열이나 변환하여 &lt;a href=&quot;../../net/uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f16fba3ccf8da91eb7017800adf15ecbe4516dc8" translate="yes" xml:space="preserve">
          <source>This class consists of &lt;code&gt;static&lt;/code&gt; utility methods for operating on objects.</source>
          <target state="translated">이 클래스는 객체를 조작하기위한 &lt;code&gt;static&lt;/code&gt; 유틸리티 메소드 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0fae45e0057b0736f390509c1be56b00c02fcc0" translate="yes" xml:space="preserve">
          <source>This class consists of &lt;code&gt;static&lt;/code&gt; utility methods for operating on objects. These utilities include &lt;code&gt;null&lt;/code&gt;-safe or &lt;code&gt;null&lt;/code&gt;-tolerant methods for computing the hash code of an object, returning a string for an object, and comparing two objects.</source>
          <target state="translated">이 클래스는 객체를 조작하기위한 &lt;code&gt;static&lt;/code&gt; 유틸리티 메소드 로 구성됩니다 . 이러한 유틸리티에는 객체의 해시 코드를 계산하고 객체의 문자열을 반환하며 두 객체를 비교하는 &lt;code&gt;null&lt;/code&gt; 안전 또는 &lt;code&gt;null&lt;/code&gt; 허용 방법 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="4ecb8a6e31e66f95dd9b703a1b211405da9780f9" translate="yes" xml:space="preserve">
          <source>This class contains a standard set of adjusters, available as static methods. These include:</source>
          <target state="translated">이 클래스에는 정적 메소드로 사용 가능한 표준 조정자 세트가 포함되어 있습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cf71e09253395b2196af54fee31b21544178fe" translate="yes" xml:space="preserve">
          <source>This class contains an export/import facility, allowing preferences to be &quot;exported&quot; to an XML document, and XML documents representing preferences to be &quot;imported&quot; back into the system. This facility may be used to back up all or part of a preference tree, and subsequently restore from the backup.</source>
          <target state="translated">이 클래스에는 내보내기 / 가져 오기 기능이 포함되어있어 환경 설정을 XML 문서로 &quot;내보낼 수&quot;있으며 환경 설정을 나타내는 XML 문서를 시스템으로 다시 &quot;가져올&quot;수 있습니다. 이 기능을 사용하여 기본 설정 트리의 전체 또는 일부를 백업 한 다음 백업에서 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="769baf2f62fd3bfa627c82579b4b3f0fa768d95c" translate="yes" xml:space="preserve">
          <source>This class contains methods for creating context objects and objects referred to by location information in the naming or directory service.</source>
          <target state="translated">이 클래스에는 이름 지정 또는 디렉토리 서비스에서 위치 정보로 참조되는 컨텍스트 오브젝트 및 오브젝트를 작성하는 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b352bb3ae62015ae3e6fccafbc2587e07fa56bad" translate="yes" xml:space="preserve">
          <source>This class contains methods for supporting &lt;code&gt;DirContext&lt;/code&gt; implementations.</source>
          <target state="translated">이 클래스에는 &lt;code&gt;DirContext&lt;/code&gt; 구현 을 지원하기위한 메소드가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be427fd0c5a72ac1ce15c650309bd1733d1fadd" translate="yes" xml:space="preserve">
          <source>This class contains various methods for manipulating arrays (such as sorting and searching).</source>
          <target state="translated">이 클래스에는 배열 조작 (예 : 정렬 및 검색)을위한 다양한 메소드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2faeb8efc1bbc7ccfbd6fa84fa1afb79a3e332" translate="yes" xml:space="preserve">
          <source>This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.</source>
          <target state="translated">이 클래스에는 배열 조작 (예 : 정렬 및 검색)을위한 다양한 메소드가 포함되어 있습니다. 이 클래스에는 배열을 목록으로 볼 수있는 정적 팩토리도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62572ec8afcb6754bbc9f0bb11387de8c016c9a" translate="yes" xml:space="preserve">
          <source>This class creates server sockets.</source>
          <target state="translated">이 클래스는 서버 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c207b61ace7e1da2567b107efe9d43a912448216" translate="yes" xml:space="preserve">
          <source>This class creates server sockets. It may be subclassed by other factories, which create particular types of server sockets. This provides a general framework for the addition of public socket-level functionality. It is the server side analogue of a socket factory, and similarly provides a way to capture a variety of policies related to the sockets being constructed.</source>
          <target state="translated">이 클래스는 서버 소켓을 만듭니다. 특정 유형의 서버 소켓을 생성하는 다른 팩토리에 의해 서브 클래 싱 될 수 있습니다. 이것은 공개 소켓 레벨 기능을 추가하기위한 일반적인 프레임 워크를 제공합니다. 소켓 팩토리의 서버 측 아날로그이며, 유사하게 구성되는 소켓과 관련된 다양한 정책을 캡처하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74dca92c6d0671abb7c75a39cc208057d8610072" translate="yes" xml:space="preserve">
          <source>This class creates sockets.</source>
          <target state="translated">이 클래스는 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8494a4be035b231016becf7c5a349116ea210a23" translate="yes" xml:space="preserve">
          <source>This class creates sockets. It may be subclassed by other factories, which create particular subclasses of sockets and thus provide a general framework for the addition of public socket-level functionality.</source>
          <target state="translated">이 클래스는 소켓을 만듭니다. 다른 팩토리에 의해 서브 클래 싱 될 수 있으며, 이는 특정 소켓의 서브 클래스를 생성하므로 공용 소켓 레벨 기능을 추가하기위한 일반적인 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="61356c7940468f66c8f7585670ec18ba9bbb0bae" translate="yes" xml:space="preserve">
          <source>This class defines a nested &lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt;&lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt;&lt;/a&gt; class that can be used as a &lt;a href=&quot;condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; implementation by subclasses supporting exclusive mode for which method &lt;a href=&quot;abstractqueuedsynchronizer#isHeldExclusively--&quot;&gt;&lt;code&gt;isHeldExclusively()&lt;/code&gt;&lt;/a&gt; reports whether synchronization is exclusively held with respect to the current thread, method &lt;a href=&quot;abstractqueuedsynchronizer#release-int-&quot;&gt;&lt;code&gt;release(int)&lt;/code&gt;&lt;/a&gt; invoked with the current &lt;a href=&quot;abstractqueuedsynchronizer#getState--&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; value fully releases this object, and &lt;a href=&quot;abstractqueuedsynchronizer#acquire-int-&quot;&gt;&lt;code&gt;acquire(int)&lt;/code&gt;&lt;/a&gt;, given this saved state value, eventually restores this object to its previous acquired state. No &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of &lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt;&lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt;&lt;/a&gt; depends of course on the semantics of its synchronizer implementation.</source>
          <target state="translated">이 클래스는 중첩 정의 &lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt; &lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt; &lt;/a&gt; A와 사용될 수있는 클래스 &lt;a href=&quot;condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 하는 방법 전용 모드를 지원하는 서브 클래스 구현 &lt;a href=&quot;abstractqueuedsynchronizer#isHeldExclusively--&quot;&gt; &lt;code&gt;isHeldExclusively()&lt;/code&gt; &lt;/a&gt; 동기화 단독 현재 스레드 방법에 대하여 유지되는지, &lt;a href=&quot;abstractqueuedsynchronizer#release-int-&quot;&gt; &lt;code&gt;release(int)&lt;/code&gt; &lt;/a&gt; 현재 호출을 &lt;a href=&quot;abstractqueuedsynchronizer#getState--&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 값은이 객체를 완전히 해제하고 ,이 저장된 상태 값이 주어지면 &lt;a href=&quot;abstractqueuedsynchronizer#acquire-int-&quot;&gt; &lt;code&gt;acquire(int)&lt;/code&gt; &lt;/a&gt; 는 결국이 객체를 이전에 획득 한 상태로 복원합니다. 그렇지 않으면 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 메소드가 해당 조건을 작성하지 않으므로이 제한 조건을 충족 할 수 없으면 사용하지 마십시오. 의 행동&lt;a href=&quot;abstractqueuedsynchronizer.conditionobject&quot;&gt; &lt;code&gt;AbstractQueuedSynchronizer.ConditionObject&lt;/code&gt; &lt;/a&gt; 는 물론 동기화 구현의 시맨틱에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="1d161644e58a91950e721e3df258d6272fe8f8a2" translate="yes" xml:space="preserve">
          <source>This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel. Each subclass of &lt;a href=&quot;selectablechannel&quot;&gt;&lt;code&gt;SelectableChannel&lt;/code&gt;&lt;/a&gt; defines an &lt;a href=&quot;selectablechannel#validOps--&quot;&gt;&lt;code&gt;validOps()&lt;/code&gt;&lt;/a&gt; method which returns a set identifying just those operations that are supported by the channel. An attempt to set or test an operation-set bit that is not supported by a key's channel will result in an appropriate run-time exception.</source>
          <target state="translated">이 클래스는 알려진 모든 연산 세트 비트를 정의하지만 주어진 채널에서 지원하는 비트는 채널 유형에 따라 정확하게 결정됩니다. &lt;a href=&quot;selectablechannel&quot;&gt; &lt;code&gt;SelectableChannel&lt;/code&gt; 의&lt;/a&gt; 각 서브 클래스 는 채널에서 지원하는 작업 만 식별하는 집합을 반환 하는 &lt;a href=&quot;selectablechannel#validOps--&quot;&gt; &lt;code&gt;validOps()&lt;/code&gt; &lt;/a&gt; 메서드를 정의합니다 . 키 채널에서 지원하지 않는 작업 세트 비트를 설정하거나 테스트하면 적절한 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e2b90f2996121462dde9c2bea370e40d1ef9615" translate="yes" xml:space="preserve">
          <source>This class defines fields and units that are specific to the ISO calendar system.</source>
          <target state="translated">이 클래스는 ISO 캘린더 시스템에 특정한 필드와 단위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4ef202ff1aebdeb0625aa6ebefdd0cc56e7f02b2" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon char buffers:</source>
          <target state="translated">이 클래스는 char 버퍼에 대한 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f98ba77c2c9981bdfeb41dfaf75537c33937770f" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon double buffers:</source>
          <target state="translated">이 클래스는 이중 버퍼에 대한 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6c37d099cf36e3f88a52048c7ea732645a2daaa9" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon float buffers:</source>
          <target state="translated">이 클래스는 float 버퍼에 대한 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="88eb21b6bb4ad00179423581ffdebb353e51fc3d" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon int buffers:</source>
          <target state="translated">이 클래스는 int 버퍼에 대한 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="126a1062471d99cc02075569ba00b39109425458" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon long buffers:</source>
          <target state="translated">이 클래스는 긴 버퍼에 대한 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5923e2513cc2452ca2ee5e213879f6f707f4b96b" translate="yes" xml:space="preserve">
          <source>This class defines four categories of operations upon short buffers:</source>
          <target state="translated">이 클래스는 짧은 버퍼에 대해 네 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f2f17913f06f71e1e24cbd648059cc5684375ff8" translate="yes" xml:space="preserve">
          <source>This class defines login and logout methods for a provider.</source>
          <target state="translated">이 클래스는 제공자의 로그인 및 로그 아웃 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="029acb623286c2f3ebb08fab792ab3fadbf98ce6" translate="yes" xml:space="preserve">
          <source>This class defines methods for reading and writing values of all other primitive types, except &lt;code&gt;boolean&lt;/code&gt;. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order, which may be retrieved and modified via the &lt;a href=&quot;bytebuffer#order--&quot;&gt;&lt;code&gt;order&lt;/code&gt;&lt;/a&gt; methods. Specific byte orders are represented by instances of the &lt;a href=&quot;byteorder&quot;&gt;&lt;code&gt;ByteOrder&lt;/code&gt;&lt;/a&gt; class. The initial order of a byte buffer is always &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;boolean&lt;/code&gt; 을 제외한 다른 모든 기본 유형의 값을 읽고 쓰는 메소드를 정의합니다 . 프리미티브 값은 버퍼의 현재 바이트 순서에 따라 바이트 시퀀스로 변환되거나 바이트 순서에서 변환되며, 이는 &lt;a href=&quot;bytebuffer#order--&quot;&gt; &lt;code&gt;order&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 및 수정 될 수 있습니다 . 특정 바이트 순서는 &lt;a href=&quot;byteorder&quot;&gt; &lt;code&gt;ByteOrder&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스로 표시됩니다 . 바이트 버퍼의 초기 순서는 항상 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="833f4acdf0db623c46516faed8a12b57ce205a05" translate="yes" xml:space="preserve">
          <source>This class defines methods that handle the mechanics of channel registration, deregistration, and closing. It maintains the current blocking mode of this channel as well as its current set of selection keys. It performs all of the synchronization required to implement the &lt;a href=&quot;../selectablechannel&quot;&gt;&lt;code&gt;SelectableChannel&lt;/code&gt;&lt;/a&gt; specification. Implementations of the abstract protected methods defined in this class need not synchronize against other threads that might be engaged in the same operations.</source>
          <target state="translated">이 클래스는 채널 등록, 등록 해제 및 닫기 메커니즘을 처리하는 메소드를 정의합니다. 이 채널의 현재 차단 모드와 현재 선택 키 세트를 유지합니다. &lt;a href=&quot;../selectablechannel&quot;&gt; &lt;code&gt;SelectableChannel&lt;/code&gt; &lt;/a&gt; 사양 을 구현하는 데 필요한 모든 동기화를 수행합니다 . 이 클래스에 정의 된 추상 보호 메소드의 구현은 동일한 조작에 참여할 수있는 다른 스레드와 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="102117ab56796ca0ef2e4471bf89d8d921b3664d" translate="yes" xml:space="preserve">
          <source>This class defines six categories of operations upon byte buffers:</source>
          <target state="translated">이 클래스는 바이트 버퍼에 대한 6 가지 범주의 작업을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f9146ca2b8add7c0ef293bafe59b338da56f98ab" translate="yes" xml:space="preserve">
          <source>This class defines static methods that support the interoperation of the stream classes of the &lt;code&gt;&lt;a href=&quot;../../io/package-summary&quot;&gt;&lt;code&gt;java.io&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; package with the channel classes of this package.</source>
          <target state="translated">이 클래스는 &lt;code&gt;&lt;a href=&quot;../../io/package-summary&quot;&gt;&lt;code&gt;java.io&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 패키지 의 스트림 클래스 와이 패키지의 채널 클래스의 상호 운용을 지원하는 정적 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d84c379001913e342accd986ca649b3e0f329887" translate="yes" xml:space="preserve">
          <source>This class defines the</source>
          <target state="translated">이 클래스는</target>
        </trans-unit>
        <trans-unit id="b3d5084504afb30c838fb8bf8db215c665f80109" translate="yes" xml:space="preserve">
          <source>This class defines the functionality of a certificate factory, which is used to generate certificate, certification path (&lt;code&gt;CertPath&lt;/code&gt;) and certificate revocation list (CRL) objects from their encodings.</source>
          <target state="translated">이 클래스는 인코딩에서 인증서, 인증 경로 ( &lt;code&gt;CertPath&lt;/code&gt; ) 및 인증서 해지 목록 (CRL) 객체 를 생성하는 데 사용되는 인증서 팩토리의 기능을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3eb1e8a146d86c95ae0ee3663bd63a4d9555d8" translate="yes" xml:space="preserve">
          <source>This class defines the methods &lt;a href=&quot;provider.service#supportsParameter-java.lang.Object-&quot;&gt;&lt;code&gt;supportsParameter()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;provider.service#newInstance-java.lang.Object-&quot;&gt;&lt;code&gt;newInstance()&lt;/code&gt;&lt;/a&gt; which are used by the Java security framework when it searches for suitable services and instantiates them. The valid arguments to those methods depend on the type of service. For the service types defined within Java SE, see the  Java Cryptography Architecture API Specification &amp;amp; Reference  for the valid values. Note that components outside of Java SE can define additional types of services and their behavior.</source>
          <target state="translated">이 클래스는 적절한 서비스를 검색하고 인스턴스화 할 때 Java 보안 프레임 워크에서 사용하는 &lt;a href=&quot;provider.service#supportsParameter-java.lang.Object-&quot;&gt; &lt;code&gt;supportsParameter()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;provider.service#newInstance-java.lang.Object-&quot;&gt; &lt;code&gt;newInstance()&lt;/code&gt; &lt;/a&gt; 메소드를 정의 합니다. 이러한 메소드에 유효한 인수는 서비스 유형에 따라 다릅니다. Java SE 내에 정의 된 서비스 유형은 유효한 값에 대한 Java Cryptography Architecture API 사양 및 참조를 참조하십시오. Java SE 외부의 구성 요소는 추가 유형의 서비스 및 해당 동작을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a15d8301b5051b9c65fd5754702615d1eb11a360" translate="yes" xml:space="preserve">
          <source>This class defines the policy of how to locate, load, and instantiate SASL clients and servers.</source>
          <target state="translated">이 클래스는 SASL 클라이언트 및 서버를 찾고로드하고 인스턴스화하는 방법에 대한 정책을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4e3aebe453fbbcde578bedce9ea55b53e835992e" translate="yes" xml:space="preserve">
          <source>This class defines the valid eras for the Japanese chronology. Japan introduced the Gregorian calendar starting with Meiji 6. Only Meiji and later eras are supported; dates before Meiji 6, January 1 are not supported.</source>
          <target state="translated">이 클래스는 일본어 연대기에 대한 유효한 시대를 정의합니다. 일본은 Meiji 6부터 그레고리오 달력을 도입했습니다. Meiji 이상 만 지원됩니다. 1 월 1 일 메이지 6 이전의 날짜는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbe65b3854b04fee6983070dd4203eca5cf27c1a" translate="yes" xml:space="preserve">
          <source>This class describes the various problems which can be encountered when accessing a role.</source>
          <target state="translated">이 클래스는 역할에 액세스 할 때 발생할 수있는 다양한 문제를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d56ac70faee3ada578571fe8a2c0709cb67d01f6" translate="yes" xml:space="preserve">
          <source>This class does</source>
          <target state="translated">이 수업은</target>
        </trans-unit>
        <trans-unit id="51ed6edad8ec894a41b2906553da3514e2f0f580" translate="yes" xml:space="preserve">
          <source>This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional &lt;em&gt;fairness&lt;/em&gt; policy.</source>
          <target state="translated">이 클래스는 잠금 액세스를 위해 리더 또는 라이터 기본 설정 순서를 강요하지 않습니다. 그러나 선택적인 &lt;em&gt;공정성&lt;/em&gt; 정책을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b55850117de60502f1359995ec43d1c79d50fb78" translate="yes" xml:space="preserve">
          <source>This class does not properly convert characters into bytes.</source>
          <target state="translated">이 클래스는 문자를 바이트로 올바르게 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="162e46887cb13f1ba011995c900f39cc02a52d40" translate="yes" xml:space="preserve">
          <source>This class does not properly convert characters into bytes. As of JDK 1.1, the preferred way to create a stream from a string is via the &lt;code&gt;StringReader&lt;/code&gt; class.</source>
          <target state="translated">이 클래스는 문자를 바이트로 올바르게 변환하지 않습니다. JDK 1.1 현재, 캐릭터 라인으로부터 스트림을 작성하는 바람직한 방법은 &lt;code&gt;StringReader&lt;/code&gt; 클래스 를 이용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="94b1b0fa3bcb888b725ed330a4d97dab66d2166b" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a date or time-zone. Instead, it is a description of the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.</source>
          <target state="translated">이 클래스는 날짜 또는 시간대를 저장하거나 나타내지 않습니다. 대신 벽시계에서 볼 수있는 현지 시간에 대한 설명입니다. 오프셋 또는 시간대와 같은 추가 정보가 없으면 타임 라인에서 순간을 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af6b2b16c68aa3ebe3feaed5905165e4006f92ac" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a day, time or time-zone. For example, the value &quot;October 2007&quot; can be stored in a &lt;code&gt;YearMonth&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 요일, 시간 또는 시간대를 저장하거나 나타내지 않습니다. 예를 들어, &quot;October 2007&quot;값은 &lt;code&gt;YearMonth&lt;/code&gt; 에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="623be08061125589af241bd7ce5a308081256174" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a month, day, time or time-zone. For example, the value &quot;2007&quot; can be stored in a &lt;code&gt;Year&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 월, 일, 시간 또는 시간대를 저장하거나 나타내지 않습니다. 예를 들어, &quot;2007&quot;값은 &lt;code&gt;Year&lt;/code&gt; 에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d1e1ffdef80b6fdd0adba10ba28ec25df5388d7" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.</source>
          <target state="translated">이 클래스는 시간 또는 시간대를 저장하거나 나타내지 않습니다. 대신 생일에 사용되는 날짜에 대한 설명입니다. 오프셋 또는 시간대와 같은 추가 정보가 없으면 타임 라인에서 순간을 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe90c824d1431213b461922cf8b2690aa184e146" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a time-zone. Instead, it is a description of the date, as used for birthdays, combined with the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.</source>
          <target state="translated">이 클래스는 시간대를 저장하거나 나타내지 않습니다. 대신, 생일에 사용되는 벽시계에서 볼 수있는 현지 시간과 함께 날짜에 대한 설명입니다. 오프셋 또는 시간대와 같은 추가 정보가 없으면 타임 라인에서 순간을 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dab391bb2089c461440ad234087ecc47782d3e5" translate="yes" xml:space="preserve">
          <source>This class does not store or represent a year, time or time-zone. For example, the value &quot;December 3rd&quot; can be stored in a &lt;code&gt;MonthDay&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 연도, 시간 또는 시간대를 저장하거나 나타내지 않습니다. 예를 들어, &quot;December 3rd&quot;값은 &lt;code&gt;MonthDay&lt;/code&gt; 에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87d2f9566a12e39af2b715032fd8d4df9db03ff0" translate="yes" xml:space="preserve">
          <source>This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.</source>
          <target state="translated">이 클래스는 프로그래머가 암호화 알고리즘으로 객체를 생성하고 기밀성을 보호 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2b1ba15e57078832f452a767958acfa0d9ed2504" translate="yes" xml:space="preserve">
          <source>This class encapsulates a Kerberos principal.</source>
          <target state="translated">이 클래스는 Kerberos 프린시 펄을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="02b0f1f4d4efdeca04a3d0ff51abd4ec98caaa56" translate="yes" xml:space="preserve">
          <source>This class encapsulates a Kerberos ticket and associated information as viewed from the client's point of view.</source>
          <target state="translated">이 클래스는 클라이언트 입장에서 볼 때 Kerberos 티켓과 관련 정보를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="b4fb1ff28a74175616cf3a7221f597e406482891" translate="yes" xml:space="preserve">
          <source>This class encapsulates a Kerberos ticket and associated information as viewed from the client's point of view. It captures all information that the Key Distribution Center (KDC) sends to the client in the reply message KDC-REP defined in the Kerberos Protocol Specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;).</source>
          <target state="translated">이 클래스는 클라이언트 입장에서 볼 때 Kerberos 티켓과 관련 정보를 캡슐화합니다. KDC (Key Distribution Center)가 Kerberos 프로토콜 스펙 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt; )에 정의 된 응답 메시지 KDC-REP에서 클라이언트로 전송하는 모든 정보를 캡처합니다 .</target>
        </trans-unit>
        <trans-unit id="4080b2d7eb034d05308a58a456615b37be74e61f" translate="yes" xml:space="preserve">
          <source>This class encapsulates a keytab file.</source>
          <target state="translated">이 클래스는 키탭 파일을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="f5c98dc941892e57d92bcbd1cbf58a4c65c0d6b6" translate="yes" xml:space="preserve">
          <source>This class encapsulates a long term secret key for a Kerberos principal.</source>
          <target state="translated">이 클래스는 Kerberos 프린시 펄에 대한 장기 비밀 키를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="6bdcd8de4f4b409e0e87e2dff0350424da2fded3" translate="yes" xml:space="preserve">
          <source>This class encapsulates factors that determine scope of search and what gets returned as a result of the search.</source>
          <target state="translated">이 클래스는 검색 범위와 검색 결과로 반환되는 요소를 결정하는 요소를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="84e18e89ad99473964a876c3740334cd37702ebc" translate="yes" xml:space="preserve">
          <source>This class encapsulates information about a code signer.</source>
          <target state="translated">이 클래스는 코드 서명자에 대한 정보를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="191e3fbfb6316c52dbc601eea6fa3c7922bc82dd" translate="yes" xml:space="preserve">
          <source>This class encapsulates information about a code signer. It is immutable.</source>
          <target state="translated">이 클래스는 코드 서명자에 대한 정보를 캡슐화합니다. 불변입니다.</target>
        </trans-unit>
        <trans-unit id="2cf5950049a0b20a346f67af5aa2efae5c5ad449" translate="yes" xml:space="preserve">
          <source>This class encapsulates information about a signed timestamp.</source>
          <target state="translated">이 클래스는 서명 된 타임 스탬프에 대한 정보를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="d011ab8fa75b957c131d5f7832d7a99f0f0c7204" translate="yes" xml:space="preserve">
          <source>This class encapsulates information about a signed timestamp. It is immutable. It includes the timestamp's date and time as well as information about the Timestamping Authority (TSA) which generated and signed the timestamp.</source>
          <target state="translated">이 클래스는 서명 된 타임 스탬프에 대한 정보를 캡슐화합니다. 불변입니다. 타임 스탬프의 날짜 및 시간과 타임 스탬프를 생성하고 서명 한 TSA (Timestamping Authority)에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe8ca2895d516ddb4bb2dbb2d265b8a9b3c6d85" translate="yes" xml:space="preserve">
          <source>This class encapsulates the low-level machinery required to implement the asynchronous closing and interruption of channels. A concrete channel class must invoke the &lt;a href=&quot;abstractinterruptiblechannel#begin--&quot;&gt;&lt;code&gt;begin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; methods before and after, respectively, invoking an I/O operation that might block indefinitely. In order to ensure that the &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method is always invoked, these methods should be used within a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block:</source>
          <target state="translated">이 클래스는 채널의 비동기 폐쇄 및 중단을 구현하는 데 필요한 저수준 기계를 캡슐화합니다. 구체적 채널 클래스는 무기한으로 차단 될 수있는 I / O 조작을 호출하기 전후에 각각 &lt;a href=&quot;abstractinterruptiblechannel#begin--&quot;&gt; &lt;code&gt;begin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야 합니다. &lt;a href=&quot;abstractinterruptiblechannel#end-boolean-&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드가 항상 호출 되도록하려면 이러한 메소드를 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록 내에서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8b178d5ab1d471af84cc8f749b651d6a8a10c4f" translate="yes" xml:space="preserve">
          <source>This class encapsulates the low-level machinery required to implement the interruption of selection operations. A concrete selector class must invoke the &lt;a href=&quot;abstractselector#begin--&quot;&gt;&lt;code&gt;begin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractselector#end--&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; methods before and after, respectively, invoking an I/O operation that might block indefinitely. In order to ensure that the &lt;a href=&quot;abstractselector#end--&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt; method is always invoked, these methods should be used within a &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; block:</source>
          <target state="translated">이 클래스는 선택 작업 중단을 구현하는 데 필요한 저수준 기계를 캡슐화합니다. 구체적 선택기 클래스는 무기한으로 차단 될 수있는 I / O 조작을 호출하기 전후에 &lt;a href=&quot;abstractselector#begin--&quot;&gt; &lt;code&gt;begin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractselector#end--&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드를 각각 호출해야합니다. &lt;a href=&quot;abstractselector#end--&quot;&gt; &lt;code&gt;end&lt;/code&gt; &lt;/a&gt; 메소드가 항상 호출 되도록하려면 이러한 메소드를 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;finally&lt;/code&gt; 블록 내에서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcfd0ca9cfe63da2c2c8be76ce7997f64531ca7" translate="yes" xml:space="preserve">
          <source>This class expresses a &lt;em&gt;Language Range&lt;/em&gt; defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of Language Tags&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 언어 태그 일치에&lt;/a&gt; 정의 된 &lt;em&gt;언어 범위를&lt;/em&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="39eac8e5feabe8dfd6efce5552c2b7e2f5cf68a2" translate="yes" xml:space="preserve">
          <source>This class expresses a &lt;em&gt;Language Range&lt;/em&gt; defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of Language Tags&lt;/a&gt;. A language range is an identifier which is used to select language tag(s) meeting specific requirements by using the mechanisms described in &lt;a href=&quot;locale#LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;. A list which represents a user's preferences and consists of language ranges is called a &lt;em&gt;Language Priority List&lt;/em&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 언어 태그 일치에&lt;/a&gt; 정의 된 &lt;em&gt;언어 범위를&lt;/em&gt; 나타냅니다 . 언어 범위는 &lt;a href=&quot;locale#LocaleMatching&quot;&gt;로캘 일치에&lt;/a&gt; 설명 된 메커니즘을 사용하여 특정 요구 사항을 충족하는 언어 태그를 선택하는 데 사용되는 식별자입니다 . 사용자의 기본 설정을 나타내며 언어 범위로 구성된 &lt;em&gt;목록을 언어 우선 순위 목록&lt;/em&gt; 이라고합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12c4b1b942381193fe784dc1d0b755920b078b78" translate="yes" xml:space="preserve">
          <source>This class extends &lt;a href=&quot;../../../lang/number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, but does &lt;em&gt;not&lt;/em&gt; define methods such as &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; because instances are expected to be mutated, and so are not useful as collection keys.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../../../lang/number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; 를&lt;/a&gt; 확장 하지만 인스턴스가 변경 될 것으로 예상되므로 콜렉션 키로 유용 하지 &lt;em&gt;않으므로 &lt;/em&gt; &lt;code&gt;equals&lt;/code&gt; , &lt;code&gt;hashCode&lt;/code&gt; 및 &lt;code&gt;compareTo&lt;/code&gt; 와 같은 메소드를 정의 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ab4a5394494318646046abcbdc4101f61febbe0d" translate="yes" xml:space="preserve">
          <source>This class extends &lt;a href=&quot;printservice&quot;&gt;&lt;code&gt;PrintService&lt;/code&gt;&lt;/a&gt; and represents a print service that prints data in different formats to a client-provided output stream.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;printservice&quot;&gt; &lt;code&gt;PrintService&lt;/code&gt; 를&lt;/a&gt; 확장 하고 다양한 형식의 데이터를 클라이언트 제공 출력 스트림에 인쇄하는 인쇄 서비스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3a2bfc4316a8193b07c7576eedeac793be63ffc9" translate="yes" xml:space="preserve">
          <source>This class extends &lt;a href=&quot;printservice&quot;&gt;&lt;code&gt;PrintService&lt;/code&gt;&lt;/a&gt; and represents a print service that prints data in different formats to a client-provided output stream. This is principally intended for services where the output format is a document type suitable for viewing or archiving. The output format must be declared as a mime type. This is equivalent to an output document flavor where the representation class is always &quot;java.io.OutputStream&quot; An instance of the &lt;code&gt;StreamPrintService&lt;/code&gt; class is obtained from a &lt;a href=&quot;streamprintservicefactory&quot;&gt;&lt;code&gt;StreamPrintServiceFactory&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;printservice&quot;&gt; &lt;code&gt;PrintService&lt;/code&gt; 를&lt;/a&gt; 확장 하고 다양한 형식의 데이터를 클라이언트 제공 출력 스트림에 인쇄하는 인쇄 서비스를 나타냅니다. 주로 출력 형식이 보거나 보관하기에 적합한 문서 유형 인 서비스를위한 것입니다. 출력 형식은 MIME 유형으로 선언해야합니다. 이는 표현 클래스가 항상 &quot;java.io.OutputStream&quot;인 출력 문서 플레이버와 같습니다. &lt;code&gt;StreamPrintService&lt;/code&gt; 클래스 의 인스턴스 는 &lt;a href=&quot;streamprintservicefactory&quot;&gt; &lt;code&gt;StreamPrintServiceFactory&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8b2cee8723f0682d562cbfd968a38cc915af5e1a" translate="yes" xml:space="preserve">
          <source>This class extends &lt;code&gt;ServerSocket&lt;/code&gt;s and provides secure server sockets using protocols such as the Secure Sockets Layer (SSL) or Transport Layer Security (TLS) protocols.</source>
          <target state="translated">이 클래스는 &lt;code&gt;ServerSocket&lt;/code&gt; 을 확장 하고 SSL (Secure Sockets Layer) 또는 TLS (Transport Layer Security) 프로토콜과 같은 프로토콜을 사용하여 보안 서버 소켓을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d8efeac981cc313c07ad5b341e7a806e991c63d7" translate="yes" xml:space="preserve">
          <source>This class extends &lt;code&gt;Socket&lt;/code&gt;s and provides secure socket using protocols such as the &quot;Secure Sockets Layer&quot; (SSL) or IETF &quot;Transport Layer Security&quot; (TLS) protocols.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Socket&lt;/code&gt; 을 확장 하고 &quot;Secure Sockets Layer&quot;(SSL) 또는 IETF &quot;Transport Layer Security&quot;(TLS) 프로토콜과 같은 프로토콜을 사용하여 보안 소켓을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6d5bad603f01a52f40d16a5d42fa59411d47f088" translate="yes" xml:space="preserve">
          <source>This class extends &lt;code&gt;ThreadLocal&lt;/code&gt; to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values.</source>
          <target state="translated">이 클래스는 &lt;code&gt;ThreadLocal&lt;/code&gt; 을 확장 하여 부모 스레드에서 자식 스레드로의 값 상속을 제공합니다. 자식 스레드가 생성되면 자식은 부모가 값을 갖는 상속 가능한 모든 스레드 로컬 변수의 초기 값을받습니다.</target>
        </trans-unit>
        <trans-unit id="61cf9e599bd69e17a1f21ad16e7f04aebe6304d0" translate="yes" xml:space="preserve">
          <source>This class extends &lt;code&gt;ThreadLocal&lt;/code&gt; to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. Normally the child's values will be identical to the parent's; however, the child's value can be made an arbitrary function of the parent's by overriding the &lt;code&gt;childValue&lt;/code&gt; method in this class.</source>
          <target state="translated">이 클래스는 &lt;code&gt;ThreadLocal&lt;/code&gt; 을 확장 하여 부모 스레드에서 자식 스레드로의 값 상속을 제공합니다. 자식 스레드가 생성되면 자식은 부모가 값을 갖는 상속 가능한 모든 스레드 로컬 변수의 초기 값을받습니다. 일반적으로 자녀의 가치는 부모의 가치와 동일합니다. 그러나이 클래스에서 &lt;code&gt;childValue&lt;/code&gt; 메서드를 재정 의하여 자식 값을 부모의 임의 함수로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0780edb1d92a454e50a61e6a3acb5cdc9197c84e" translate="yes" xml:space="preserve">
          <source>This class extends &lt;code&gt;javax.management.MBeanFeatureInfo&lt;/code&gt; and thus provides &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt; fields. The &lt;code&gt;name&lt;/code&gt; field should be the fully qualified Java class name of the notification objects described by this class.</source>
          <target state="translated">이 클래스는 &lt;code&gt;javax.management.MBeanFeatureInfo&lt;/code&gt; 를 확장 하므로 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;description&lt;/code&gt; 필드 를 제공 합니다. &lt;code&gt;name&lt;/code&gt; 필드는이 클래스에 의해 기술 된 알림 객체의 완전한 Java 클래스 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="79411ae38bda3676bbd057e31ea7c77af07c30b0" translate="yes" xml:space="preserve">
          <source>This class extends ClassLoader with additional support for defining classes with an associated code source and permissions which are retrieved by the system policy by default.</source>
          <target state="translated">이 클래스는 기본적으로 시스템 정책에 의해 검색되는 관련 코드 소스 및 권한으로 클래스를 정의하기위한 추가 지원을 통해 ClassLoader를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="80fd8d0442ed8d6ca7099a0928889c31d6da43cc" translate="yes" xml:space="preserve">
          <source>This class extends the concept of a codebase to encapsulate not only the location (URL) but also the certificate chains that were used to verify signed code originating from that location.</source>
          <target state="translated">이 클래스는 위치 (URL)뿐만 아니라 해당 위치에서 시작된 서명 된 코드를 확인하는 데 사용 된 인증서 체인을 캡슐화하도록 코드베이스의 개념을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="20cbb526b48b2f6f9e0788d4a54943b1653177c6" translate="yes" xml:space="preserve">
          <source>This class handles conversion from the local time-line of &lt;code&gt;LocalDateTime&lt;/code&gt; to the instant time-line of &lt;code&gt;Instant&lt;/code&gt;. The difference between the two time-lines is the offset from UTC/Greenwich, represented by a &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 로컬 타임 라인에서 &lt;code&gt;Instant&lt;/code&gt; 의 인스턴트 타임 라인으로의 변환을 처리합니다 . 두 타임 라인의 차이는 UTC / 그리니치와의 오프셋이며 &lt;code&gt;ZoneOffset&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4b932d45ae5c58a5d969eda80df032fc50a1bbc" translate="yes" xml:space="preserve">
          <source>This class has one tuning parameter (which affects performance but not semantics):</source>
          <target state="translated">이 클래스에는 하나의 튜닝 매개 변수가 있습니다 (성능에는 영향을 주지만 의미론에는 영향을 미치지 않음).</target>
        </trans-unit>
        <trans-unit id="70113f3193141e1f041370d6ac6ba662a48c28f3" translate="yes" xml:space="preserve">
          <source>This class has the following properties:</source>
          <target state="translated">이 클래스에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d13ba8d22873fec38f5fdb9655962f8d07b5525" translate="yes" xml:space="preserve">
          <source>This class implements &lt;a href=&quot;temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;temporal/temporal&quot;&gt;&lt;code&gt;Temporal&lt;/code&gt;&lt;/a&gt;. This is because it is not possible to define whether February 29th is valid or not without external information, preventing the implementation of plus/minus. Related to this, &lt;code&gt;MonthDay&lt;/code&gt; only provides access to query and set the fields &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;temporal/temporal&quot;&gt; &lt;code&gt;Temporal&lt;/code&gt; Accessor를&lt;/a&gt; 구현 합니다. 외부 정보없이 2 월 29 일이 유효한지 여부를 정의 할 수 없기 때문에 플러스 / 마이너스 구현을 방해 할 수 있습니다. 이와 관련하여 &lt;code&gt;MonthDay&lt;/code&gt; 는 쿼리에 대한 액세스 만 제공하고 &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="baad76a02be640103b9ef84e83db7f714f95545e" translate="yes" xml:space="preserve">
          <source>This class implements a character buffer that can be used as a character-input stream.</source>
          <target state="translated">이 클래스는 문자 입력 스트림으로 사용할 수있는 문자 버퍼를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1d1a1f0c028a92e072814256e8f4eb63bad6fa1d" translate="yes" xml:space="preserve">
          <source>This class implements a character buffer that can be used as an Writer.</source>
          <target state="translated">이 클래스는 Writer로 사용할 수있는 문자 버퍼를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="de33e90606c927d634844e37c43bab24c76b5361" translate="yes" xml:space="preserve">
          <source>This class implements a character buffer that can be used as an Writer. The buffer automatically grows when data is written to the stream. The data can be retrieved using toCharArray() and toString().</source>
          <target state="translated">이 클래스는 Writer로 사용할 수있는 문자 버퍼를 구현합니다. 데이터가 스트림에 기록되면 버퍼가 자동으로 커집니다. toCharArray () 및 toString ()을 사용하여 데이터를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33c9373a2537042b50b3e84133347112a203ce6" translate="yes" xml:space="preserve">
          <source>This class implements a concurrent variant of &lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot;&gt;SkipLists&lt;/a&gt; providing expected average</source>
          <target state="translated">이 클래스는 예상 평균을 제공하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot;&gt;SkipList&lt;/a&gt; 의 동시 변형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2b5d82534a0f233b03424a9f07ca7a811318e1aa" translate="yes" xml:space="preserve">
          <source>This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.</source>
          <target state="translated">이 클래스는 RFC 4648 및 RFC 2045에 지정된 Base64 인코딩 체계를 사용하여 바이트 데이터를 디코딩하기위한 디코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4f3639215ee0d1bb5b232f24c89ffd529e2afcaf" translate="yes" xml:space="preserve">
          <source>This class implements a hash table, which maps keys to values.</source>
          <target state="translated">이 클래스는 키를 값에 매핑하는 해시 테이블을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1afbbca910b972820ee6e671ebad24d463657bbd" translate="yes" xml:space="preserve">
          <source>This class implements a hash table, which maps keys to values. Any non-&lt;code&gt;null&lt;/code&gt; object can be used as a key or as a value.</source>
          <target state="translated">이 클래스는 키를 값에 매핑하는 해시 테이블을 구현합니다. &lt;code&gt;null&lt;/code&gt; 아닌 오브젝트는 키 또는 값으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3482ce37d428075fdb1a327b831a0f648f0c8f45" translate="yes" xml:space="preserve">
          <source>This class implements a stream filter for reading compressed data in the GZIP file format.</source>
          <target state="translated">이 클래스는 GZIP 파일 형식으로 압축 된 데이터를 읽기위한 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e57935a75c00f55d0a7c2b4a770d5088109669b9" translate="yes" xml:space="preserve">
          <source>This class implements a stream filter for uncompressing data in the &quot;deflate&quot; compression format.</source>
          <target state="translated">이 클래스는 &quot;deflate&quot;압축 형식으로 데이터를 압축 해제하기위한 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1a389365e0ee166c500af91b15a408c1d800eafd" translate="yes" xml:space="preserve">
          <source>This class implements a stream filter for uncompressing data in the &quot;deflate&quot; compression format. It is also used as the basis for other decompression filters, such as GZIPInputStream.</source>
          <target state="translated">이 클래스는 &quot;deflate&quot;압축 형식으로 데이터를 압축 해제하기위한 스트림 필터를 구현합니다. 또한 GZIPInputStream과 같은 다른 압축 해제 필터의 기초로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d32b9ae2ddeec1e957e4c9b4a9fa002314c0e37" translate="yes" xml:space="preserve">
          <source>This class implements a stream filter for writing compressed data in the GZIP file format.</source>
          <target state="translated">이 클래스는 GZIP 파일 형식으로 압축 된 데이터를 쓰기위한 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a3e2dd706f2a4c8a1ccd16cb574b686e61831f2a" translate="yes" xml:space="preserve">
          <source>This class implements a vector of bits that grows as needed.</source>
          <target state="translated">이 클래스는 필요에 따라 커지는 비트 벡터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="01ed67a1fb887460141312271abdaa85e27af705" translate="yes" xml:space="preserve">
          <source>This class implements a vector of bits that grows as needed. Each component of the bit set has a &lt;code&gt;boolean&lt;/code&gt; value. The bits of a &lt;code&gt;BitSet&lt;/code&gt; are indexed by nonnegative integers. Individual indexed bits can be examined, set, or cleared. One &lt;code&gt;BitSet&lt;/code&gt; may be used to modify the contents of another &lt;code&gt;BitSet&lt;/code&gt; through logical AND, logical inclusive OR, and logical exclusive OR operations.</source>
          <target state="translated">이 클래스는 필요에 따라 커지는 비트 벡터를 구현합니다. 비트 세트의 각 구성 요소에는 &lt;code&gt;boolean&lt;/code&gt; 값이 있습니다. &lt;code&gt;BitSet&lt;/code&gt; 의 비트는 음이 아닌 정수로 인덱싱됩니다. 개별 인덱스 비트를 검사, 설정 또는 지울 수 있습니다. 하나의 &lt;code&gt;BitSet&lt;/code&gt; 을 사용하여 논리적 AND, 논리적 포함 OR 및 논리적 독점 OR 연산을 통해 다른 &lt;code&gt;BitSet&lt;/code&gt; 의 내용을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6e2670f7d2d9b1dc4ec24ec27fc10c0d3b27504" translate="yes" xml:space="preserve">
          <source>This class implements an IP Socket Address (IP address + port number) It can also be a pair (hostname + port number), in which case an attempt will be made to resolve the hostname.</source>
          <target state="translated">이 클래스는 IP 소켓 주소 (IP 주소 + 포트 번호)를 구현합니다. 쌍 (호스트 이름 + 포트 번호) 일 수도 있습니다.이 경우 호스트 이름을 확인하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1fa0726ccfeaebc3e77d348232ff4528921df650" translate="yes" xml:space="preserve">
          <source>This class implements an IP Socket Address (IP address + port number) It can also be a pair (hostname + port number), in which case an attempt will be made to resolve the hostname. If resolution fails then the address is said to be</source>
          <target state="translated">이 클래스는 IP 소켓 주소 (IP 주소 + 포트 번호)를 구현합니다. 쌍 (호스트 이름 + 포트 번호) 일 수도 있습니다.이 경우 호스트 이름을 확인하려고 시도합니다. 해결에 실패하면 주소는</target>
        </trans-unit>
        <trans-unit id="fc6b822e66836a77598fe631f58367d5d54287ff" translate="yes" xml:space="preserve">
          <source>This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.</source>
          <target state="translated">이 클래스는 RFC 4648 및 RFC 2045에 지정된 Base64 인코딩 체계를 사용하여 바이트 데이터를 인코딩하기위한 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="098977e9d2407edeb71b650754e80ccc9eb33ffc" translate="yes" xml:space="preserve">
          <source>This class implements an input stream filter for reading files in the ZIP file format.</source>
          <target state="translated">이 클래스는 ZIP 파일 형식의 파일을 읽기위한 입력 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3b06ccf19ef90ba80b3384247cd1a192fe265ae0" translate="yes" xml:space="preserve">
          <source>This class implements an input stream filter for reading files in the ZIP file format. Includes support for both compressed and uncompressed entries.</source>
          <target state="translated">이 클래스는 ZIP 파일 형식의 파일을 읽기위한 입력 스트림 필터를 구현합니다. 압축 된 항목과 압축되지 않은 항목을 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2f90f14711c964b2a80a941d9bdf327bf9a1e149" translate="yes" xml:space="preserve">
          <source>This class implements an output stream filter for compressing data in the &quot;deflate&quot; compression format.</source>
          <target state="translated">이 클래스는 &quot;deflate&quot;압축 형식으로 데이터를 압축하기위한 출력 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="78a9cfdd21803201bf731967c8a1ff7bba457b74" translate="yes" xml:space="preserve">
          <source>This class implements an output stream filter for compressing data in the &quot;deflate&quot; compression format. It is also used as the basis for other types of compression filters, such as GZIPOutputStream.</source>
          <target state="translated">이 클래스는 &quot;deflate&quot;압축 형식으로 데이터를 압축하기위한 출력 스트림 필터를 구현합니다. 또한 GZIPOutputStream과 같은 다른 유형의 압축 필터의 기초로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec9b412e0f3542534bd54ad7aeaf28cfcbbc42a" translate="yes" xml:space="preserve">
          <source>This class implements an output stream filter for writing files in the ZIP file format.</source>
          <target state="translated">이 클래스는 ZIP 파일 형식의 파일을 쓰기위한 출력 스트림 필터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f9235a6e06a2b74b9ede6b10c9fb06d29a8e932f" translate="yes" xml:space="preserve">
          <source>This class implements an output stream filter for writing files in the ZIP file format. Includes support for both compressed and uncompressed entries.</source>
          <target state="translated">이 클래스는 ZIP 파일 형식의 파일을 쓰기위한 출력 스트림 필터를 구현합니다. 압축 된 항목과 압축되지 않은 항목을 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="abea2c7a576b4dbdd0fd3bc7b0b8cc11a1e53f22" translate="yes" xml:space="preserve">
          <source>This class implements an output stream in which the data is written into a byte array.</source>
          <target state="translated">이 클래스는 데이터가 바이트 배열에 기록되는 출력 스트림을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="549b64956f9981b4003014c36a37b78ce6da64e1" translate="yes" xml:space="preserve">
          <source>This class implements an output stream in which the data is written into a byte array. The buffer automatically grows as data is written to it. The data can be retrieved using &lt;code&gt;toByteArray()&lt;/code&gt; and &lt;code&gt;toString()&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 데이터가 바이트 배열에 기록되는 출력 스트림을 구현합니다. 데이터가 기록되면 버퍼가 자동으로 커집니다. &lt;code&gt;toByteArray()&lt;/code&gt; 및 &lt;code&gt;toString()&lt;/code&gt; 사용하여 데이터를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4f47882a1ffec82dc6c4b0f1b95934cbde7c36" translate="yes" xml:space="preserve">
          <source>This class implements client sockets (also called just &quot;sockets&quot;).</source>
          <target state="translated">이 클래스는 클라이언트 소켓 ( &quot;소켓&quot;이라고도 함)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="cc174a1ccc47b28c856fb71309214f251bc1137c" translate="yes" xml:space="preserve">
          <source>This class implements client sockets (also called just &quot;sockets&quot;). A socket is an endpoint for communication between two machines.</source>
          <target state="translated">이 클래스는 클라이언트 소켓 ( &quot;소켓&quot;이라고도 함)을 구현합니다. 소켓은 두 시스템 간의 통신을위한 엔드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="115afcbd0827348c0d6d0af9346fadc9103a21b3" translate="yes" xml:space="preserve">
          <source>This class implements of the &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt; interface for the &lt;a href=&quot;attributechangenotification&quot;&gt;&lt;code&gt;attribute change notification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스 는 &lt;a href=&quot;attributechangenotification&quot;&gt; &lt;code&gt;attribute change notification&lt;/code&gt; &lt;/a&gt; 위한 &lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="bfdfb7f8c2cd45f6183663376b83dc36c0c4399c" translate="yes" xml:space="preserve">
          <source>This class implements of the &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt; interface for the &lt;a href=&quot;attributechangenotification&quot;&gt;&lt;code&gt;attribute change notification&lt;/code&gt;&lt;/a&gt;. The filtering is performed on the name of the observed attribute.</source>
          <target state="translated">이 클래스 는 &lt;a href=&quot;attributechangenotification&quot;&gt; &lt;code&gt;attribute change notification&lt;/code&gt; &lt;/a&gt; 위한 &lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 관찰 된 속성의 이름에 대해 필터링이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c5a1b8ef3eb99d8acc7197735ca0e28fae6b2ee0" translate="yes" xml:space="preserve">
          <source>This class implements server sockets.</source>
          <target state="translated">이 클래스는 서버 소켓을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ab4e961fe3fd57910bc42ba11c3d3ea61d5dc018" translate="yes" xml:space="preserve">
          <source>This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester.</source>
          <target state="translated">이 클래스는 서버 소켓을 구현합니다. 서버 소켓은 네트워크를 통해 요청이 들어 오기를 기다립니다. 해당 요청에 따라 일부 작업을 수행 한 다음 요청자에게 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1bd35a92d7c9f959f0803313b9abd37c694be67" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;a href=&quot;../lang/charsequence&quot;&gt;&lt;code&gt;CharSequence&lt;/code&gt;&lt;/a&gt; interface so that character buffers may be used wherever character sequences are accepted, for example in the regular-expression package &lt;code&gt;&lt;a href=&quot;../util/regex/package-summary&quot;&gt;&lt;code&gt;java.util.regex&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../lang/charsequence&quot;&gt; &lt;code&gt;CharSequence&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하여 문자 시퀀스가 ​​허용되는 모든 위치 (예 : 정규식 패키지 &lt;code&gt;&lt;a href=&quot;../util/regex/package-summary&quot;&gt;&lt;code&gt;java.util.regex&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; ) 에서 문자 버퍼를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cba6c5dab24c2c3a14a2205b5f7075955603acd" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; type as defined in PKCS #8.</source>
          <target state="translated">이 클래스 는 PKCS # 8에 정의 &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; 유형을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="2c85a8537f4799bebae3138366bfa7ac70b6ad81" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;code&gt;Map&lt;/code&gt; interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values).</source>
          <target state="translated">이 클래스는 키와 값을 비교할 때 객체 평등 대신 참조 평등을 사용하여 해시 테이블로 &lt;code&gt;Map&lt;/code&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="cff55ae97711824a1154b4780df0d396383a5dca" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;code&gt;Map&lt;/code&gt; interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an &lt;code&gt;IdentityHashMap&lt;/code&gt;, two keys &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are considered equal if and only if &lt;code&gt;(k1==k2)&lt;/code&gt;. (In normal &lt;code&gt;Map&lt;/code&gt; implementations (like &lt;code&gt;HashMap&lt;/code&gt;) two keys &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are considered equal if and only if &lt;code&gt;(k1==null ? k2==null : k1.equals(k2))&lt;/code&gt;.)</source>
          <target state="translated">이 클래스는 키와 값을 비교할 때 객체 평등 대신 참조 평등을 사용하여 해시 테이블로 &lt;code&gt;Map&lt;/code&gt; 인터페이스를 구현합니다 . 즉, &lt;code&gt;IdentityHashMap&lt;/code&gt; 에서 &lt;code&gt;(k1==k2)&lt;/code&gt; 경우에만 두 개의 키 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 가 동일한 것으로 간주됩니다 . ( &lt;code&gt;HashMap&lt;/code&gt; 과 같은 일반 &lt;code&gt;Map&lt;/code&gt; 구현에서 두 키 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 는 &lt;code&gt;(k1==null ? k2==null : k1.equals(k2))&lt;/code&gt; 경우에만 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc0d68cb04b2f9ddf0d6666cdb1917011ae012ae" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;code&gt;Set&lt;/code&gt; interface, backed by a hash table (actually a &lt;code&gt;HashMap&lt;/code&gt; instance).</source>
          <target state="translated">이 클래스 는 해시 테이블 (실제로는 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스)을 기반으로 &lt;code&gt;Set&lt;/code&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e55fac8a1edacfcc68482b02dc802150c59dfa28" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;code&gt;Set&lt;/code&gt; interface, backed by a hash table (actually a &lt;code&gt;HashMap&lt;/code&gt; instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the &lt;code&gt;null&lt;/code&gt; element.</source>
          <target state="translated">이 클래스 는 해시 테이블 (실제로는 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스)을 기반으로 &lt;code&gt;Set&lt;/code&gt; 인터페이스를 구현합니다 . 세트의 반복 순서에 대해서는 보증하지 않습니다. 특히, 주문이 시간이 지남에 따라 일정하게 유지된다는 보장은 없습니다. 이 클래스는 &lt;code&gt;null&lt;/code&gt; 요소를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="65fc0e9ffefba5408169db17abbe7c9d7bdb32b2" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Control for paged-results as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2696.txt&quot;&gt;RFC 2696&lt;/a&gt;. The control's value has the following ASN.1 definition:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2696.txt&quot;&gt;RFC 2696에&lt;/a&gt; 정의 된 페이징 결과에 대한 LDAPv3 컨트롤을 구현합니다 . 컨트롤 값은 다음과 같은 ASN.1 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1f595d708b0121a74084d3162c6951639f1daaaa" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Extended Request for StartTLS as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2830.txt&quot;&gt;Lightweight Directory Access Protocol (v3): Extension for Transport Layer Security&lt;/a&gt; The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037 and no extended request value is defined.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2830.txt&quot;&gt;경량 디렉토리 액세스 프로토콜 (v3)에&lt;/a&gt; 정의 된대로 StartTLS에 대한 LDAPv3 확장 요청을 구현합니다 . 전송 계층 보안을위한 확장 StartTLS의 오브젝트 식별자는 1.3.6.1.4.1.1466.20037이며 확장 요청 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39cf6249a0ce18f93fb3383fda1deb09f4599850" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Extended Response for StartTLS as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2830.txt&quot;&gt;Lightweight Directory Access Protocol (v3): Extension for Transport Layer Security&lt;/a&gt; The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037 and no extended response value is defined.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2830.txt&quot;&gt;경량 디렉토리 액세스 프로토콜 (v3)에&lt;/a&gt; 정의 된대로 StartTLS에 대한 LDAPv3 확장 응답을 구현합니다 . 전송 계층 보안을위한 확장 StartTLS의 오브젝트 식별자는 1.3.6.1.4.1.1466.20037이며 확장 된 응답 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dc7ec26cb11f66381c895667e802166bedc7f90" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Request Control for ManageDsaIT as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3296.txt&quot;&gt;RFC 3296&lt;/a&gt;. The control has no control value.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3296.txt&quot;&gt;RFC 3296에&lt;/a&gt; 정의 된 대로 ManageDsaIT에 대한 LDAPv3 요청 제어를 구현합니다 . 컨트롤에는 컨트롤 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd113787648245439787720312dcfaa47bb92996" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Request Control for server-side sorting as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2891.txt&quot;&gt;RFC 2891&lt;/a&gt;. The control's value has the following ASN.1 definition:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2891.txt&quot;&gt;RFC 2891에&lt;/a&gt; 정의 된 서버 측 정렬을위한 LDAPv3 요청 제어를 구현합니다 . 컨트롤 값은 다음과 같은 ASN.1 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4b38ced794fddf3aae0a4be62444ea3327c4469e" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Response Control for paged-results as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2696&quot;&gt;RFC 2696&lt;/a&gt;. The control's value has the following ASN.1 definition:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2696&quot;&gt;RFC 2696에&lt;/a&gt; 정의 된 페이징 결과에 대한 LDAPv3 응답 제어를 구현합니다 . 컨트롤 값은 다음과 같은 ASN.1 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="dedc22457b24d662c95dfbd6e3fffc74f58a46cd" translate="yes" xml:space="preserve">
          <source>This class implements the LDAPv3 Response Control for server-side sorting as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2891.txt&quot;&gt;RFC 2891&lt;/a&gt;. The control's value has the following ASN.1 definition:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2891.txt&quot;&gt;RFC 2891에&lt;/a&gt; 정의 된 서버 측 정렬을위한 LDAPv3 응답 제어를 구현합니다 . 컨트롤 값은 다음과 같은 ASN.1 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2e8b2fbb6ba6e6cc4dbd749bb8f4b4b6f78e5a88" translate="yes" xml:space="preserve">
          <source>This class implements the Unicode Bidirectional Algorithm.</source>
          <target state="translated">이 클래스는 Unicode Bidirectional Algorithm을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6c7be12641a6fb204795114b7b5ed46a804d3c09" translate="yes" xml:space="preserve">
          <source>This class incorrectly assumes that bytes adequately represent characters.</source>
          <target state="translated">이 클래스는 바이트가 적절하게 문자를 나타내는 것으로 잘못 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2218ada1b5806864164463099508081ef7d157e5" translate="yes" xml:space="preserve">
          <source>This class incorrectly assumes that bytes adequately represent characters. As of JDK 1.1, the preferred way to operate on character streams is via the new character-stream classes, which include a class for counting line numbers.</source>
          <target state="translated">이 클래스는 바이트가 적절하게 문자를 나타내는 것으로 잘못 가정합니다. JDK 1.1부터, 문자 스트림에서 작동하는 선호되는 방법은 줄 번호를 계산하는 클래스를 포함하는 새로운 문자 스트림 클래스를 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f14e3b407357f9cce651c259b5c16d7f748eb980" translate="yes" xml:space="preserve">
          <source>This class is Serializable, but all fields are transient, so deserialized conditions have no waiters.</source>
          <target state="translated">이 클래스는 직렬화 가능하지만 모든 필드는 일시적이므로 직렬화 해제 된 조건에는 웨이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1cfd4a949232c7b25ea5e7b14b2468c8561fc12" translate="yes" xml:space="preserve">
          <source>This class is a collection of UI convenience methods which provide a graphical user dialog for browsing print services looked up through the Java Print Service API.</source>
          <target state="translated">이 클래스는 Java 인쇄 서비스 API를 통해 조회 된 인쇄 서비스를 찾아 볼 수있는 그래픽 사용자 대화 상자를 제공하는 UI 편의 메서드 모음입니다.</target>
        </trans-unit>
        <trans-unit id="9d778150f4d35c00bae50d428b4c01af107eea31" translate="yes" xml:space="preserve">
          <source>This class is a member of the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt; Java Collections Framework&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="ae73a21168a485b76a1ac50247c626ccd23df9df" translate="yes" xml:space="preserve">
          <source>This class is a mutable builder intended for use from a single thread.</source>
          <target state="translated">이 클래스는 단일 스레드에서 사용하도록 변경 가능한 빌더입니다.</target>
        </trans-unit>
        <trans-unit id="d583808e2526b135dffcab6a097906137b611799" translate="yes" xml:space="preserve">
          <source>This class is a simple holder for a key pair (a public key and a private key).</source>
          <target state="translated">이 클래스는 키 쌍 ​​(공개 키 및 개인 키)을위한 간단한 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="820cbd2e7b7d06b8267dc3b72ab349617e4e8157" translate="yes" xml:space="preserve">
          <source>This class is a simple holder for a key pair (a public key and a private key). It does not enforce any security, and, when initialized, should be treated like a PrivateKey.</source>
          <target state="translated">이 클래스는 키 쌍 ​​(공개 키 및 개인 키)을위한 간단한 홀더입니다. 보안을 강화하지 않으며 초기화 될 때 PrivateKey처럼 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="51babbce1e4e09bcc1b8784134a6a7fade70b099" translate="yes" xml:space="preserve">
          <source>This class is a useful aid for creating a spliterator when it is not possible or difficult to efficiently partition elements in a manner allowing balanced parallel computation.</source>
          <target state="translated">이 클래스는 균형 병렬 계산을 허용하는 방식으로 요소를 효율적으로 분할하는 것이 불가능하거나 어려운 경우 스플리터를 만드는 데 유용한 보조 도구입니다.</target>
        </trans-unit>
        <trans-unit id="0ee878f59ddfc490048939466c41b0731a3b2831" translate="yes" xml:space="preserve">
          <source>This class is an abstraction for certificates that have different formats but important common uses. For example, different types of certificates, such as X.509 and PGP, share general certificate functionality (like encoding and verifying) and some types of information (like a public key).</source>
          <target state="translated">이 클래스는 형식은 다르지만 중요한 용도로 사용되는 인증서에 대한 추상화입니다. 예를 들어 X.509 및 PGP와 같은 다른 유형의 인증서는 일반 인증서 기능 (인코딩 및 확인)과 일부 유형의 정보 (공개 키)를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c5609aa75f44c6153cfd605bcd7d877b783504e2" translate="yes" xml:space="preserve">
          <source>This class is an abstraction of certificate revocation lists (CRLs) that have different formats but important common uses.</source>
          <target state="translated">이 클래스는 형식은 다르지만 중요한 공통 용도로 사용되는 CRL (인증서 해지 목록)의 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="0291f23ff11fec678a3c29c6bc6545dc3baac078" translate="yes" xml:space="preserve">
          <source>This class is an abstraction of certificate revocation lists (CRLs) that have different formats but important common uses. For example, all CRLs share the functionality of listing revoked certificates, and can be queried on whether or not they list a given certificate.</source>
          <target state="translated">이 클래스는 형식은 다르지만 중요한 공통 용도로 사용되는 CRL (인증서 해지 목록)의 추상화입니다. 예를 들어 모든 CRL은 해지 된 인증서를 나열하는 기능을 공유하며 지정된 인증서를 나열하는지 여부를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d43115f6922f2c068b7296647bbaa635cfec4424" translate="yes" xml:space="preserve">
          <source>This class is an extension of &lt;code&gt;NamingManager&lt;/code&gt;. It contains methods for use by service providers for accessing object factories and state factories, and for getting continuation contexts for supporting federation.</source>
          <target state="translated">이 클래스는 &lt;code&gt;NamingManager&lt;/code&gt; 의 확장입니다 . 서비스 팩토리가 오브젝트 팩토리 및 상태 팩토리에 액세스하고 연합을 지원하기위한 연속 컨텍스트를 얻기 위해 사용하는 메소드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7b82996e97910b513075b5af1cf32f8d2eebf6" translate="yes" xml:space="preserve">
          <source>This class is an implementation of interface &lt;code&gt;Doc&lt;/code&gt; that can be used in many common printing requests.</source>
          <target state="translated">이 클래스는 많은 일반적인 인쇄 요청에 사용될 수있는 &lt;code&gt;Doc&lt;/code&gt; 인터페이스의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a18ed58769607c8c048964840e94cbe383504b75" translate="yes" xml:space="preserve">
          <source>This class is an implementation of interface &lt;code&gt;Doc&lt;/code&gt; that can be used in many common printing requests. It can handle all of the presently defined &quot;pre-defined&quot; doc flavors defined as static variables in the DocFlavor class.</source>
          <target state="translated">이 클래스는 많은 일반적인 인쇄 요청에 사용될 수있는 &lt;code&gt;Doc&lt;/code&gt; 인터페이스의 구현입니다 . DocFlavor 클래스에서 정적 변수로 정의 된 현재 정의 된 &quot;사전 정의 된&quot;doc 플레이버를 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7316afef7a52ab20f47b95a62ecfbe3c758038" translate="yes" xml:space="preserve">
          <source>This class is an input stream filter that provides the added functionality of keeping track of the current line number.</source>
          <target state="translated">이 클래스는 현재 행 번호를 추적하는 추가 기능을 제공하는 입력 스트림 필터입니다.</target>
        </trans-unit>
        <trans-unit id="1ced21a75d8a42fe694a2ee35274ec56b54ea257" translate="yes" xml:space="preserve">
          <source>This class is designed for use with the ISO calendar system. The fields of hours, minutes and seconds make assumptions that are valid for the standard ISO definitions of those fields. This class may be used with other calendar systems providing the definition of the time fields matches those of the ISO calendar system.</source>
          <target state="translated">이 클래스는 ISO 캘린더 시스템과 함께 사용하도록 설계되었습니다. 시간, 분 및 초 필드는 해당 필드의 표준 ISO 정의에 유효한 가정을합니다. 이 클래스는 다른 달력 시스템과 함께 사용하여 시간 필드의 정의가 ISO 달력 시스템의 시간 필드와 일치하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9b2362cd1aa51b3e17ae66a56b8d4233cf23ae53" translate="yes" xml:space="preserve">
          <source>This class is designed to handle many of the details of the decoding process, including the implementation of error actions. A decoder for a specific charset, which is a concrete subclass of this class, need only implement the abstract &lt;a href=&quot;charsetdecoder#decodeLoop-java.nio.ByteBuffer-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;decodeLoop&lt;/code&gt;&lt;/a&gt; method, which encapsulates the basic decoding loop. A subclass that maintains internal state should, additionally, override the &lt;a href=&quot;charsetdecoder#implFlush-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;implFlush&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;charsetdecoder#implReset--&quot;&gt;&lt;code&gt;implReset&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 클래스는 오류 동작의 구현을 포함하여 디코딩 프로세스의 많은 세부 사항을 처리하도록 설계되었습니다. 이 클래스의 구체적 서브 클래스 인 특정 문자 세트의 디코더 는 기본 디코딩 루프를 캡슐화하는 추상 &lt;a href=&quot;charsetdecoder#decodeLoop-java.nio.ByteBuffer-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;decodeLoop&lt;/code&gt; &lt;/a&gt; 메소드 만 구현하면 됩니다. 내부 상태를 유지 관리하는 하위 클래스는 또한 &lt;a href=&quot;charsetdecoder#implFlush-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;implFlush&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;charsetdecoder#implReset--&quot;&gt; &lt;code&gt;implReset&lt;/code&gt; &lt;/a&gt; 메소드를 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="13f03733315c0ce8ed4415eee284ec88ab9169a1" translate="yes" xml:space="preserve">
          <source>This class is designed to handle many of the details of the encoding process, including the implementation of error actions. An encoder for a specific charset, which is a concrete subclass of this class, need only implement the abstract &lt;a href=&quot;charsetencoder#encodeLoop-java.nio.CharBuffer-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;encodeLoop&lt;/code&gt;&lt;/a&gt; method, which encapsulates the basic encoding loop. A subclass that maintains internal state should, additionally, override the &lt;a href=&quot;charsetencoder#implFlush-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;implFlush&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;charsetencoder#implReset--&quot;&gt;&lt;code&gt;implReset&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 클래스는 오류 동작의 구현을 포함하여 인코딩 프로세스의 많은 세부 사항을 처리하도록 설계되었습니다. 이 클래스의 구체적 서브 클래스 인 특정 문자 세트의 인코더 는 기본 인코딩 루프를 캡슐화하는 추상 &lt;a href=&quot;charsetencoder#encodeLoop-java.nio.CharBuffer-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;encodeLoop&lt;/code&gt; &lt;/a&gt; 메소드 만 구현하면 됩니다. 내부 상태를 유지 관리하는 하위 클래스는 또한 &lt;a href=&quot;charsetencoder#implFlush-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;implFlush&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;charsetencoder#implReset--&quot;&gt; &lt;code&gt;implReset&lt;/code&gt; &lt;/a&gt; 메소드를 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3240cc4afb6076454063206022fe6517d12d0d64" translate="yes" xml:space="preserve">
          <source>This class is designed to work with (though does not require) &lt;a href=&quot;stream/package-summary&quot;&gt;streams&lt;/a&gt;. For example, you can compute summary statistics on a stream of doubles with:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;stream/package-summary&quot;&gt;stream&lt;/a&gt; 과 작동하도록 설계되었습니다 (필수는 아님) . 예를 들어, 다음을 사용하여 복식 스트림에 대한 요약 통계를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="534bf987e2d9f7c4f4fb1edd2c8721e673a2621f" translate="yes" xml:space="preserve">
          <source>This class is designed to work with (though does not require) &lt;a href=&quot;stream/package-summary&quot;&gt;streams&lt;/a&gt;. For example, you can compute summary statistics on a stream of ints with:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;stream/package-summary&quot;&gt;stream&lt;/a&gt; 과 작동하도록 설계되었습니다 (필수는 아님) . 예를 들어 다음을 사용하여 int 스트림에 대한 요약 통계를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52e6dd8b18199a8f82ef12d5c2918291e0b7cf1" translate="yes" xml:space="preserve">
          <source>This class is designed to work with (though does not require) &lt;a href=&quot;stream/package-summary&quot;&gt;streams&lt;/a&gt;. For example, you can compute summary statistics on a stream of longs with:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;stream/package-summary&quot;&gt;stream&lt;/a&gt; 과 작동하도록 설계되었습니다 (필수는 아님) . 예를 들어 다음을 사용하여 long 스트림에서 요약 통계를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d53fdae707712d0381e94f7dc21be6cf91f41e" translate="yes" xml:space="preserve">
          <source>This class is for Serializable permissions.</source>
          <target state="translated">이 클래스는 직렬화 가능 권한을위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0d1c4d1efe47256af28fe598bd92727eeb2782e8" translate="yes" xml:space="preserve">
          <source>This class is for Serializable permissions. A SerializablePermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 직렬화 가능 권한을위한 클래스입니다. SerializablePermission에는 이름 ( &quot;대상 이름&quot;이라고도 함)이 포함되지만 작업 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d53779bd7f7cce6e4c7e911761f037e0abf7c9d0" translate="yes" xml:space="preserve">
          <source>This class is for authentication permissions.</source>
          <target state="translated">이 클래스는 인증 권한을위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f126780ee50931b1510cb11c1cef9786cd20a73" translate="yes" xml:space="preserve">
          <source>This class is for authentication permissions. An AuthPermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 인증 권한을위한 클래스입니다. AuthPermission에는 이름 ( &quot;대상 이름&quot;이라고도 함)이 포함되지만 작업 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73f3bd1d9682040b3b23820eac252d315ab9fb0b" translate="yes" xml:space="preserve">
          <source>This class is for property permissions.</source>
          <target state="translated">이 클래스는 속성 권한을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf38ff071520a9f69c63d16a27ca4bdaf3eecf9c" translate="yes" xml:space="preserve">
          <source>This class is for runtime permissions.</source>
          <target state="translated">이 클래스는 런타임 권한을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="da64c9a234bc5d4220da0b155b1bcc82e0a2873a" translate="yes" xml:space="preserve">
          <source>This class is for runtime permissions. A RuntimePermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 런타임 권한을위한 것입니다. RuntimePermission에는 이름 ( &quot;대상 이름&quot;이라고도 함)이 포함되지만 조치 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f946b8ab89f87cbe6f5c790648f5cdeeb630b96f" translate="yes" xml:space="preserve">
          <source>This class is for security permissions.</source>
          <target state="translated">이 클래스는 보안 권한을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7039081a2c0b67ea5473cb08a9d0475faa52319d" translate="yes" xml:space="preserve">
          <source>This class is for security permissions. A SecurityPermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 보안 권한을위한 것입니다. SecurityPermission에는 이름 ( &quot;대상 이름&quot;이라고도 함)이 있지만 작업 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="983972e67289ccda7d34499493457e0efdad03ee" translate="yes" xml:space="preserve">
          <source>This class is for various network permissions.</source>
          <target state="translated">이 클래스는 다양한 네트워크 권한을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b479ce6e357940518728afad9719697ef2cb323" translate="yes" xml:space="preserve">
          <source>This class is for various network permissions. A NetPermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 다양한 네트워크 권한을위한 것입니다. NetPermission은 이름 ( &quot;대상 이름&quot;이라고도 함)을 포함하지만 조치 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3df37700c7b7b055b8f9c28ab127afc7e9516ccc" translate="yes" xml:space="preserve">
          <source>This class is for various network permissions. An SSLPermission contains a name (also referred to as a &quot;target name&quot;) but no actions list; you either have the named permission or you don't.</source>
          <target state="translated">이 클래스는 다양한 네트워크 권한을위한 것입니다. SSLPermission에는 이름 ( &quot;대상 이름&quot;이라고도 함)이 있지만 작업 목록은 없습니다. 당신은 명명 된 권한이 있거나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1efd3c02b16dbb6115b817a50e48113a428b6af7" translate="yes" xml:space="preserve">
          <source>This class is immutable and thread-safe.</source>
          <target state="translated">이 클래스는 변경 불가능하고 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="37b92d190d2b4d908f1a3b363886df450096e5f1" translate="yes" xml:space="preserve">
          <source>This class is implemented by a service and located by the implementation using the  SPI JAR File specification.</source>
          <target state="translated">이 클래스는 서비스에 의해 구현되며 SPI JAR 파일 스펙을 사용한 구현에 의해 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3dcf0734baa4f30537279e3b95a469a4430aa2b3" translate="yes" xml:space="preserve">
          <source>This class is in conformance with Level 1 of &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1 Canonical Equivalents.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical Standard # 18 : Unicode Regular Expression&lt;/i&gt;&lt;/a&gt; 의 레벨 1 과 RL2.1 정식 동등 물을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="164b1f255450de2132df34b2fc33bbfbd54b33fb" translate="yes" xml:space="preserve">
          <source>This class is intended for use in a single thread.</source>
          <target state="translated">이 클래스는 단일 스레드에서 사용하도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="eaa25a208a1545696e4b07e7a544a0930fdd83e9" translate="yes" xml:space="preserve">
          <source>This class is intended primarily for use with key objects whose &lt;code&gt;equals&lt;/code&gt; methods test for object identity using the &lt;code&gt;==&lt;/code&gt; operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a &lt;code&gt;WeakHashMap&lt;/code&gt; at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose &lt;code&gt;equals&lt;/code&gt; methods are not based upon object identity, such as &lt;code&gt;String&lt;/code&gt; instances. With such recreatable key objects, however, the automatic removal of &lt;code&gt;WeakHashMap&lt;/code&gt; entries whose keys have been discarded may prove to be confusing.</source>
          <target state="translated">이 클래스는 기본적으로 &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 &lt;code&gt;equals&lt;/code&gt; 메소드가 객체 ID를 테스트 하는 키 객체와 함께 사용하기위한 것 입니다. 이러한 키를 버린 후에는 다시 만들 수 없으므로 나중에 &lt;code&gt;WeakHashMap&lt;/code&gt; 에서 해당 키를 조회 하고 해당 항목이 제거되었다는 사실에 놀랄 수 없습니다. 이 클래스는 &lt;code&gt;equals&lt;/code&gt; 메소드가 &lt;code&gt;String&lt;/code&gt; 인스턴스 와 같은 객체 아이덴티티를 기반으로하지 않는 주요 객체와 완벽하게 작동 합니다. 그러나 이러한 재생성 가능한 키 개체를 사용하면 키가 삭제 된 &lt;code&gt;WeakHashMap&lt;/code&gt; 항목을 자동으로 제거 하는 것이 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7ce27329c1d1e958f1ffcae520eb7728a9796b0" translate="yes" xml:space="preserve">
          <source>This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various &lt;code&gt;Stream&lt;/code&gt; classes.</source>
          <target state="translated">이 클래스는 주로 데이터 구조의 스트림 뷰를 제공하는 라이브러리 작성자를위한 것입니다. 최종 사용자를위한 대부분의 정적 스트림 메서드는 다양한 &lt;code&gt;Stream&lt;/code&gt; 클래스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fe2a902b95293e868730a69eaf51ba0a0d6a9b0" translate="yes" xml:space="preserve">
          <source>This class is no longer used.</source>
          <target state="translated">이 클래스는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="660376da0a4ccb1bd664c468fe3e82f5289bd185" translate="yes" xml:space="preserve">
          <source>This class is no longer used. Its functionality has been replaced by &lt;code&gt;java.security.KeyStore&lt;/code&gt;, the &lt;code&gt;java.security.cert&lt;/code&gt; package, and &lt;code&gt;java.security.Principal&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 더 이상 사용되지 않습니다. 기능은 &lt;code&gt;java.security.KeyStore&lt;/code&gt; , &lt;code&gt;java.security.cert&lt;/code&gt; 패키지 및 &lt;code&gt;java.security.Principal&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3d251b916db18946db2616285c0c642d5b48160d" translate="yes" xml:space="preserve">
          <source>This class is not intended to be used for general XML processing. In particular, &lt;code&gt;Element&lt;/code&gt; nodes created within the Image I/O API are not compatible with those created by Sun's standard implementation of the &lt;code&gt;org.w3.dom&lt;/code&gt; API. In particular, the implementation is tuned for simple uses and may not perform well for intensive processing.</source>
          <target state="translated">이 클래스는 일반적인 XML 처리에 사용되지 않습니다. 특히, Image I / O API 내에서 작성된 &lt;code&gt;Element&lt;/code&gt; 노드는 Sun의 표준 &lt;code&gt;org.w3.dom&lt;/code&gt; API 구현으로 작성된 것과 호환되지 않습니다 . 특히, 구현은 간단한 용도로 조정되었으며 집중적 인 처리에는 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eba7f6e6663740fa5ed4b67a90734a23c04b77e" translate="yes" xml:space="preserve">
          <source>This class is only useful for raw secret keys that can be represented as a byte array and have no key parameters associated with them, e.g., DES or Triple DES keys.</source>
          <target state="translated">이 클래스는 바이트 배열로 표현할 수 있고 DES 또는 Triple DES 키와 같은 키 매개 변수가없는 원시 비밀 키에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="871d9c7734a81df3162e85bc48a290b36b988829" translate="yes" xml:space="preserve">
          <source>This class is separated from the &lt;code&gt;Chronology&lt;/code&gt; interface so that the static methods are not inherited. While &lt;code&gt;Chronology&lt;/code&gt; can be implemented directly, it is strongly recommended to extend this abstract class instead.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Chronology&lt;/code&gt; 인터페이스 와 분리되어 정적 메소드가 상속되지 않습니다. &lt;code&gt;Chronology&lt;/code&gt; 를 직접 구현할 수 있지만 대신이 추상 클래스를 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11169ff58ae451686a3bb3543b4e110f7e82ae52" translate="yes" xml:space="preserve">
          <source>This class is serializable. When it is serialized it will save (and restore) any listeners that are themselves serializable. Any non-serializable listeners will be skipped during serialization.</source>
          <target state="translated">이 클래스는 직렬화 가능합니다. 직렬화되면 직렬화 가능한 리스너를 저장 (및 복원)합니다. 직렬화 중에 직렬화 할 수없는 리스너는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9426781035a2e2be226ba027fd19bc80e14f02e2" translate="yes" xml:space="preserve">
          <source>This class is the base interface for hostname verification.</source>
          <target state="translated">이 클래스는 호스트 이름 확인을위한 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d527d905ecd0201340a04d72f9921af6063a64b4" translate="yes" xml:space="preserve">
          <source>This class is the base interface for providing algorithm-specific information to a KeyManagerFactory or TrustManagerFactory.</source>
          <target state="translated">이 클래스는 알고리즘 특정 정보를 KeyManagerFactory 또는 TrustManagerFactory에 제공하기위한 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="59e5f87ef8e36cef554f98c2e008f30d1f05a0d9" translate="yes" xml:space="preserve">
          <source>This class is the implementation of a ModelMBean.</source>
          <target state="translated">이 클래스는 ModelMBean의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="5ef4c4e335a9b9b553a000b7011fecc18fe31818" translate="yes" xml:space="preserve">
          <source>This class is the implementation of a ModelMBean. An appropriate implementation of a ModelMBean must be shipped with every JMX Agent and the class must be named RequiredModelMBean.</source>
          <target state="translated">이 클래스는 ModelMBean의 구현입니다. ModelMBean의 적절한 구현은 모든 JMX 에이전트와 함께 제공되어야하며 클래스의 이름은 RequiredModelMBean이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d92cf9fa60cc000ab8bf753f1b2d1bc89474f60" translate="yes" xml:space="preserve">
          <source>This class is the interface to be implemented by MBeans that are meant to be persistent.</source>
          <target state="translated">이 클래스는 영속적 인 MBean에 의해 구현되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f19d893de8054751cd2144ea0c9af06680e83543" translate="yes" xml:space="preserve">
          <source>This class is the interface to be implemented by MBeans that are meant to be persistent. MBeans supporting this interface should call the load method during construction in order to prime the MBean from the persistent store. In the case of a ModelMBean, the store method should be called by the MBeanServer based on the descriptors in the ModelMBean or by the MBean itself during normal processing of the ModelMBean.</source>
          <target state="translated">이 클래스는 영속적 인 MBean에 의해 구현되는 인터페이스입니다. 이 인터페이스를 지원하는 MBean은 영구 저장소에서 MBean을 프라이밍하기 위해 구성 중에로드 메소드를 호출해야합니다. ModelMBean의 경우, ModelMBean의 디스크립터를 기반으로 MBeanServer 또는 ModelMBean을 정상적으로 처리하는 동안 MBean 자체가 store 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="02b089396e28ddd557d223fa76961dbe37dd98f1" translate="yes" xml:space="preserve">
          <source>This class is the opposite of the &lt;code&gt;AbstractList&lt;/code&gt; class in the sense that it implements the &quot;random access&quot; methods (&lt;code&gt;get(int index)&lt;/code&gt;, &lt;code&gt;set(int index, E element)&lt;/code&gt;, &lt;code&gt;add(int index, E element)&lt;/code&gt; and &lt;code&gt;remove(int index)&lt;/code&gt;) on top of the list's list iterator, instead of the other way around.</source>
          <target state="translated">이 클래스는 &quot;랜덤 액세스&quot;메소드 ( &lt;code&gt;get(int index)&lt;/code&gt; , &lt;code&gt;set(int index, E element)&lt;/code&gt; , &lt;code&gt;add(int index, E element)&lt;/code&gt; 및 &lt;code&gt;remove(int index)&lt;/code&gt; )를 구현한다는 점에서 &lt;code&gt;AbstractList&lt;/code&gt; 클래스와 반대입니다. ) ) 대신 목록의 목록 반복자 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a20b94d128ff27c99a7d8a202407464a746096" translate="yes" xml:space="preserve">
          <source>This class is the starting context for performing LDAPv3-style extended operations and controls.</source>
          <target state="translated">이 클래스는 LDAPv3 스타일 확장 조작 및 제어를 수행하기위한 시작 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="c9ebeaec555c3a49f472defa5a4bac0fa1714a50" translate="yes" xml:space="preserve">
          <source>This class is the starting context for performing directory operations.</source>
          <target state="translated">이 클래스는 디렉토리 작업을 수행하기위한 시작 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="21e5dd06de2cd79c306d6b1432a8bd320196dfce" translate="yes" xml:space="preserve">
          <source>This class is the starting context for performing directory operations. The documentation in the class description of InitialContext (including those for synchronization) apply here.</source>
          <target state="translated">이 클래스는 디렉토리 작업을 수행하기위한 시작 컨텍스트입니다. InitialContext에 대한 클래스 설명의 문서 (동기화를위한 문서 포함)가 여기에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="24dc8db5f88a926a065c69e98c4eae0fb24a7dcc" translate="yes" xml:space="preserve">
          <source>This class is the starting context for performing naming operations.</source>
          <target state="translated">이 클래스는 이름 지정 작업을 수행하기위한 시작 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="255a199d1ff99484f944964c0ba5b4d38319281f" translate="yes" xml:space="preserve">
          <source>This class is the superclass of all classes that filter output streams.</source>
          <target state="translated">이 클래스는 출력 스트림을 필터링하는 모든 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="570e1f0ed10be9078abfb0bc5b5b38ef04540a8c" translate="yes" xml:space="preserve">
          <source>This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the</source>
          <target state="translated">이 클래스는 출력 스트림을 필터링하는 모든 클래스의 수퍼 클래스입니다. 이 스트림은 이미 존재하는 출력 스트림 (</target>
        </trans-unit>
        <trans-unit id="c9086e9e5125fd41f8ce69b188178fcee4eb3b88" translate="yes" xml:space="preserve">
          <source>This class is the superclass of any exception which can be raised during relation management.</source>
          <target state="translated">이 클래스는 관계 관리 중에 발생할 수있는 예외의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6865dfb89c6918bd65c9ac9d52259fccdb9544d9" translate="yes" xml:space="preserve">
          <source>This class is thread-safe: multiple threads can share a single &lt;code&gt;Properties&lt;/code&gt; object without the need for external synchronization.</source>
          <target state="translated">이 클래스는 스레드로부터 안전합니다. 여러 스레드가 외부 동기화없이 단일 &lt;code&gt;Properties&lt;/code&gt; 객체를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a95ebd2233ed1d121d6c92058975a03867bfc6de" translate="yes" xml:space="preserve">
          <source>This class is thread-safe: multiple threads can share a single &lt;code&gt;Timer&lt;/code&gt; object without the need for external synchronization.</source>
          <target state="translated">이 클래스는 스레드로부터 안전합니다. 여러 스레드가 외부 동기화없이 단일 &lt;code&gt;Timer&lt;/code&gt; 객체를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec33dba99b049da1b658092b3875f51dd398cbc1" translate="yes" xml:space="preserve">
          <source>This class is thrown when an attempt is made to add to an attribute a value that conflicts with the attribute's schema definition.</source>
          <target state="translated">이 클래스는 속성의 스키마 정의와 충돌하는 값을 속성에 추가하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1f00b94efb36932459464439d5ab0e12a6e9624" translate="yes" xml:space="preserve">
          <source>This class is thrown when an attempt is made to add to an attribute a value that conflicts with the attribute's schema definition. This could happen, for example, if attempting to add an attribute with no value when the attribute is required to have at least one value, or if attempting to add more than one value to a single valued-attribute, or if attempting to add a value that conflicts with the syntax of the attribute.</source>
          <target state="translated">이 클래스는 속성의 스키마 정의와 충돌하는 값을 속성에 추가하려고 할 때 발생합니다. 예를 들어, 속성에 최소한 하나의 값이 있어야 할 때 값이없는 속성을 추가하려고 시도하거나 단일 값 속성에 둘 이상의 값을 추가하려는 경우 또는 속성의 구문과 충돌하는 값.</target>
        </trans-unit>
        <trans-unit id="b28af93d9716907fa0b3541783bfa4007945f282" translate="yes" xml:space="preserve">
          <source>This class is used as an opaque representation of cryptographic parameters.</source>
          <target state="translated">이 클래스는 암호화 매개 변수의 불투명 한 표현으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2970f6f19d713db046765398cb1a4330b16978b" translate="yes" xml:space="preserve">
          <source>This class is used to allow multiple resources declarations.</source>
          <target state="translated">이 클래스는 여러 자원 선언을 허용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bead0d6f4eff16a0bf9f0abb5794db8cbd5f952" translate="yes" xml:space="preserve">
          <source>This class is used to associate an emitted notification with the listener ID to which it is targeted.</source>
          <target state="translated">이 클래스는 생성 된 알림을 대상 리스너 ID와 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f38a13b47a7a76e3e8210a856ed4604bc7ab7f96" translate="yes" xml:space="preserve">
          <source>This class is used to create operating system processes.</source>
          <target state="translated">이 클래스는 운영 체제 프로세스를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e29cdda5dc89630e2030edbd0cf8445c800b6fa6" translate="yes" xml:space="preserve">
          <source>This class is used to explicitly specify the value for encoding input P in OAEP Padding.</source>
          <target state="translated">이 클래스는 OAEP 패딩에서 입력 P를 인코딩하기위한 값을 명시 적으로 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc9176a6d652a52a000320c090cdf90b71c8fa1" translate="yes" xml:space="preserve">
          <source>This class is used to protect Kerberos services and the credentials necessary to access those services.</source>
          <target state="translated">이 클래스는 Kerberos 서비스 및 해당 서비스에 액세스하는 데 필요한 자격 증명을 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92bc108a8151bae0c08b4e05e2830669938179c5" translate="yes" xml:space="preserve">
          <source>This class is used to protect Kerberos services and the credentials necessary to access those services. There is a one to one mapping of a service principal and the credentials necessary to access the service. Therefore granting access to a service principal implicitly grants access to the credential necessary to establish a security context with the service principal. This applies regardless of whether the credentials are in a cache or acquired via an exchange with the KDC. The credential can be either a ticket granting ticket, a service ticket or a secret key from a key table.</source>
          <target state="translated">이 클래스는 Kerberos 서비스 및 해당 서비스에 액세스하는 데 필요한 자격 증명을 보호하는 데 사용됩니다. 서비스 프린시 펄과 서비스에 액세스하는 데 필요한 신임 정보의 일대일 맵핑이 있습니다. 따라서 서비스 주체에 대한 액세스 권한을 부여하면 서비스 주체와 보안 컨텍스트를 설정하는 데 필요한 자격 증명에 대한 액세스 권한이 암시 적으로 부여됩니다. 자격 증명이 캐시에 있는지 또는 KDC와의 교환을 통해 획득했는지에 관계없이 적용됩니다. 자격 증명은 티켓 부여 티켓, 서비스 티켓 또는 키 테이블의 비밀 키일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d72ed179fe7cf94952b4a53b575f7eb173f084" translate="yes" xml:space="preserve">
          <source>This class is used to protect access to private Credentials belonging to a particular &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 특정 &lt;code&gt;Subject&lt;/code&gt; 속하는 개인 자격 증명에 대한 액세스를 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d883a0a3d463009ba704e60e5528114d555eef95" translate="yes" xml:space="preserve">
          <source>This class is used to protect access to private Credentials belonging to a particular &lt;code&gt;Subject&lt;/code&gt;. The &lt;code&gt;Subject&lt;/code&gt; is represented by a Set of Principals.</source>
          <target state="translated">이 클래스는 특정 &lt;code&gt;Subject&lt;/code&gt; 속하는 개인 자격 증명에 대한 액세스를 보호하는 데 사용됩니다 . &lt;code&gt;Subject&lt;/code&gt; 주체의 집합으로 표현된다.</target>
        </trans-unit>
        <trans-unit id="81577962995ef1cc73f44c7cce8da044a21a41ac" translate="yes" xml:space="preserve">
          <source>This class is used to provide necessary configuration parameters (server name and port number) to implementations of the LDAP &lt;code&gt;CertStore&lt;/code&gt; algorithm.</source>
          <target state="translated">이 클래스는 LDAP &lt;code&gt;CertStore&lt;/code&gt; 알고리즘의 구현에 필요한 구성 매개 변수 (서버 이름 및 포트 번호)를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf73f6a65c294515963298059d6234dedb988be4" translate="yes" xml:space="preserve">
          <source>This class is used to provide necessary configuration parameters to implementations of the Collection &lt;code&gt;CertStore&lt;/code&gt; algorithm. The only parameter included in this class is the &lt;code&gt;Collection&lt;/code&gt; from which the &lt;code&gt;CertStore&lt;/code&gt; will retrieve certificates and CRLs.</source>
          <target state="translated">이 클래스는 Collection &lt;code&gt;CertStore&lt;/code&gt; 알고리즘의 구현에 필요한 구성 매개 변수를 제공하는 데 사용됩니다 . 이 클래스에 포함 된 유일한 매개 변수 는 &lt;code&gt;CertStore&lt;/code&gt; 가 인증서와 CRL을 검색 하는 &lt;code&gt;Collection&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="892d3a8ff21cefb061c50236667fa4c69d43c5ad" translate="yes" xml:space="preserve">
          <source>This class is used to read entries from a zip file.</source>
          <target state="translated">이 클래스는 zip 파일에서 항목을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e515046eee31b311bd69116828d827760c8d7a86" translate="yes" xml:space="preserve">
          <source>This class is used to represent a JAR file entry.</source>
          <target state="translated">이 클래스는 JAR 파일 항목을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcdc55a8d6493efd76c541ef916e043bc3a74029" translate="yes" xml:space="preserve">
          <source>This class is used to represent a ZIP file entry.</source>
          <target state="translated">이 클래스는 ZIP 파일 항목을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dedab4f3cb6292b2c66bd11055ed807ee60cf26a" translate="yes" xml:space="preserve">
          <source>This class is used to represent an Identity that can also digitally sign data.</source>
          <target state="translated">이 클래스는 데이터에 디지털 서명을 할 수있는 Identity를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f5bdfc27441534a2ef1fd5316d3ce6bc2812da" translate="yes" xml:space="preserve">
          <source>This class is used to restrict the usage of the Kerberos delegation model, ie: forwardable and proxiable tickets.</source>
          <target state="translated">이 클래스는 Kerberos 위임 모델 (예 : 전달 가능 및 프록시 가능 티켓)의 사용을 제한하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da32b0a5f6de72e86c176c93392b75f72e066a06" translate="yes" xml:space="preserve">
          <source>This class is usually preferable to &lt;a href=&quot;atomiclong&quot;&gt;&lt;code&gt;AtomicLong&lt;/code&gt;&lt;/a&gt; when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</source>
          <target state="translated">이 클래스는 일반적으로 여러 스레드가 세밀한 동기화 제어가 아닌 통계 수집과 같은 목적으로 사용되는 공통 합계를 업데이트 할 때 &lt;a href=&quot;atomiclong&quot;&gt; &lt;code&gt;AtomicLong&lt;/code&gt; &lt;/a&gt; 보다 선호됩니다 . 낮은 업데이트 경합에서 두 클래스는 비슷한 특성을 갖습니다. 그러나 높은 경합에서이 클래스의 예상 처리량은 더 높은 공간 소비를 희생하면서 상당히 높아집니다.</target>
        </trans-unit>
        <trans-unit id="96aaba84eac6ce0ad2e73cbde92bb3c4c4b745e5" translate="yes" xml:space="preserve">
          <source>This class is usually preferable to &lt;a href=&quot;atomiclong&quot;&gt;&lt;code&gt;AtomicLong&lt;/code&gt;&lt;/a&gt; when multiple threads update a common value that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</source>
          <target state="translated">이 클래스는 일반적으로 여러 스레드가 세밀한 동기화 제어가 아닌 통계 수집과 같은 목적으로 사용되는 공통 값을 업데이트 할 때 &lt;a href=&quot;atomiclong&quot;&gt; &lt;code&gt;AtomicLong&lt;/code&gt; &lt;/a&gt; 보다 선호됩니다 . 낮은 업데이트 경합에서 두 클래스는 비슷한 특성을 갖습니다. 그러나 높은 경합에서이 클래스의 예상 처리량은 더 높은 공간 소비를 희생하면서 상당히 높아집니다.</target>
        </trans-unit>
        <trans-unit id="c0e1446057f9ee2b23fc1e7c899c2d679af6b946" translate="yes" xml:space="preserve">
          <source>This class is usually preferable to alternatives when multiple threads update a common value that is used for purposes such as summary statistics that are frequently updated but less frequently read.</source>
          <target state="translated">이 클래스는 일반적으로 여러 스레드가 자주 업데이트되지만 덜 자주 읽히는 요약 통계와 같은 목적으로 사용되는 공통 값을 업데이트 할 때 대안보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c85a69b32032b59ad95c0d23120e07e505a591cb" translate="yes" xml:space="preserve">
          <source>This class loader is used to load classes and resources from a search path of URLs referring to both JAR files and directories.</source>
          <target state="translated">이 클래스 로더는 JAR 파일과 디렉토리를 모두 참조하는 URL의 검색 경로에서 클래스와 자원을로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="529a888cd1b34805c18df62f3ab778f092ad678a" translate="yes" xml:space="preserve">
          <source>This class loader is used to load classes and resources from a search path of URLs referring to both JAR files and directories. Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be opened as needed.</source>
          <target state="translated">이 클래스 로더는 JAR 파일과 디렉토리를 모두 참조하는 URL의 검색 경로에서 클래스와 자원을로드하는 데 사용됩니다. '/'로 끝나는 URL은 디렉토리를 나타내는 것으로 가정합니다. 그렇지 않으면 URL은 필요에 따라 열리는 JAR 파일을 참조한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a848bd89febcae11dc0644f5bb34dc339508d2af" translate="yes" xml:space="preserve">
          <source>This class manages a list of dated timer notifications. A method allows users to add/remove as many notifications as required. When a timer notification is emitted by the timer and becomes obsolete, it is automatically removed from the list of timer notifications.</source>
          <target state="translated">이 클래스는 날짜가 지정된 타이머 알림 목록을 관리합니다. 이 방법을 통해 사용자는 필요한만큼 알림을 추가 / 제거 할 수 있습니다. 타이머 알림이 타이머에 의해 생성되어 더 이상 사용되지 않으면 타이머 알림 목록에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d7fb18cf18f4efce410ba5b152b6f139bd0a822b" translate="yes" xml:space="preserve">
          <source>This class manages the configuration of time-zone rules. The static methods provide the public API that can be used to manage the providers. The abstract methods provide the SPI that allows rules to be provided.</source>
          <target state="translated">이 클래스는 표준 시간대 규칙의 구성을 관리합니다. 정적 메소드는 제공자를 관리하는 데 사용할 수있는 공용 API를 제공합니다. 추상 메소드는 규칙을 제공 할 수있는 SPI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31a7c86c419911a99a9dbaa4add38668de333305" translate="yes" xml:space="preserve">
          <source>This class may also be used to construct MXBeans. The usage is exactly the same as for Standard MBeans except that in the examples above, the &lt;code&gt;false&lt;/code&gt; parameter to the constructor or &lt;code&gt;super(...)&lt;/code&gt; invocation is instead &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 MXBean을 구성하는 데 사용될 수도 있습니다. 사용법은 위의 예제 에서 생성자 또는 &lt;code&gt;super(...)&lt;/code&gt; 호출에 대한 &lt;code&gt;false&lt;/code&gt; 매개 변수가 true 인 점을 제외하고 표준 MBean과 동일 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c9765f4cd7ab26b2e4409b5d937f6e3b566e8d3" translate="yes" xml:space="preserve">
          <source>This class models a quantity or amount of time in terms of seconds and nanoseconds. It can be accessed using other duration-based units, such as minutes and hours. In addition, the &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt; unit can be used and is treated as exactly equal to 24 hours, thus ignoring daylight savings effects. See &lt;a href=&quot;period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; for the date-based equivalent to this class.</source>
          <target state="translated">이 클래스는 초와 나노초로 양 또는 시간을 모델링합니다. 분 및 시간과 같은 다른 기간 기반 단위를 사용하여 액세스 할 수 있습니다. 또한 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 유닛을 사용할 수 있으며 정확히 24 시간으로 처리되므로 일광 절약 효과가 무시됩니다. 이 클래스에 해당하는 날짜 기반 &lt;a href=&quot;period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 은 기간 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04486e00606f23dc85340d6bae56c39641e3fa23" translate="yes" xml:space="preserve">
          <source>This class models a quantity or amount of time in terms of years, months and days. See &lt;a href=&quot;duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; for the time-based equivalent to this class.</source>
          <target state="translated">이 클래스는 년, 월, 일의 수량 또는 시간을 모델링합니다. 이 클래스와 동등한 시간 기반의 &lt;a href=&quot;duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f7ae18c67979186c2a80767b88b6ffcdc398382" translate="yes" xml:space="preserve">
          <source>This class models a single instantaneous point on the time-line. This might be used to record event time-stamps in the application.</source>
          <target state="translated">이 클래스는 타임 라인에서 단일 순간 지점을 모델링합니다. 응용 프로그램에서 이벤트 타임 스탬프를 기록하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c2d45c4ed07e6ca40c4c509a2bc564114bbf0f" translate="yes" xml:space="preserve">
          <source>This class must be implemented with care to ensure other classes operate correctly. All implementations that can be instantiated must be final, immutable and thread-safe. Subclasses should be Serializable wherever possible.</source>
          <target state="translated">이 클래스는 다른 클래스가 올바르게 작동하도록주의해서 구현해야합니다. 인스턴스화 할 수있는 모든 구현은 최종적이고 변경 불가능하며 스레드로부터 안전해야합니다. 서브 클래스는 가능하면 직렬화 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="77f368256389aaf440d58e7162a94829c8492f69" translate="yes" xml:space="preserve">
          <source>This class offers constant time performance for the basic operations (&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the &lt;code&gt;HashSet&lt;/code&gt; instance's size (the number of elements) plus the &quot;capacity&quot; of the backing &lt;code&gt;HashMap&lt;/code&gt; instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.</source>
          <target state="translated">이 클래스는 기본 작업 ( &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; )에 대해 일정한 시간 성능을 제공 하며 해시 함수가 버킷간에 요소를 올바르게 분산 시킨다고 가정합니다. 이 세트를 반복하려면 &lt;code&gt;HashSet&lt;/code&gt; 인스턴스의 크기 (요소 수)의 합과 백업 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스 의 &quot;용량&quot; (버킷 수)에 비례하는 시간이 필요합니다 . 따라서 반복 성능이 중요한 경우 초기 용량을 너무 높게 (또는로드 팩터가 너무 낮게) 설정하지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="572a8d65ebeff151932bda9611b422ec79f16007" translate="yes" xml:space="preserve">
          <source>This class performs the synchronization required to implement the &lt;a href=&quot;../channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; specification. Implementations of the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method need not synchronize against other threads that might be attempting to close the channel.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 스펙 을 구현하는 데 필요한 동기화를 수행합니다 . &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메소드의 구현은 채널을 닫으려고하는 다른 스레드와 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d07dbbe71cc840ce02b9469f3fc04a4b888acea3" translate="yes" xml:space="preserve">
          <source>This class provides &lt;code&gt;adapt&lt;/code&gt; methods for &lt;a href=&quot;../../lang/runnable&quot;&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;callable&quot;&gt;&lt;code&gt;Callable&lt;/code&gt;&lt;/a&gt;, that may be of use when mixing execution of &lt;code&gt;ForkJoinTasks&lt;/code&gt; with other kinds of tasks. When all tasks are of this form, consider using a pool constructed in &lt;em&gt;asyncMode&lt;/em&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../../lang/runnable&quot;&gt; &lt;code&gt;Runnable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;callable&quot;&gt; &lt;code&gt;Callable&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;adapt&lt;/code&gt; 메소드를 제공합니다.이 메소드 는 &lt;code&gt;ForkJoinTasks&lt;/code&gt; 실행을 다른 종류의 태스크와 혼합 할 때 사용할 수 있습니다 . 모든 작업이이 형식 인 경우 &lt;em&gt;asyncMode로&lt;/em&gt; 구성된 풀 사용을 고려 &lt;em&gt;하십시오&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c359178fcd5b6cf7a61127c158970f1b1cdfd554" translate="yes" xml:space="preserve">
          <source>This class provides &lt;code&gt;protected&lt;/code&gt; overridable &lt;a href=&quot;threadpoolexecutor#beforeExecute-java.lang.Thread-java.lang.Runnable-&quot;&gt;&lt;code&gt;beforeExecute(Thread, Runnable)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadpoolexecutor#afterExecute-java.lang.Runnable-java.lang.Throwable-&quot;&gt;&lt;code&gt;afterExecute(Runnable, Throwable)&lt;/code&gt;&lt;/a&gt; methods that are called before and after execution of each task. These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries. Additionally, method &lt;a href=&quot;threadpoolexecutor#terminated--&quot;&gt;&lt;code&gt;terminated()&lt;/code&gt;&lt;/a&gt; can be overridden to perform any special processing that needs to be done once the Executor has fully terminated.</source>
          <target state="translated">이 클래스는 각 작업의 실행 전후에 호출 &lt;code&gt;protected&lt;/code&gt; 재정의 가능한 재정의 &lt;a href=&quot;threadpoolexecutor#beforeExecute-java.lang.Thread-java.lang.Runnable-&quot;&gt; &lt;code&gt;beforeExecute(Thread, Runnable)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;threadpoolexecutor#afterExecute-java.lang.Runnable-java.lang.Throwable-&quot;&gt; &lt;code&gt;afterExecute(Runnable, Throwable)&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다. 이들은 실행 환경을 조작하는 데 사용될 수 있습니다. 예를 들어 ThreadLocals를 다시 초기화하거나 통계를 수집하거나 로그 항목을 추가 할 수 있습니다. 또한 Executor가 완전히 종료 된 후에 수행해야하는 특수 처리를 수행하기 위해 &lt;a href=&quot;threadpoolexecutor#terminated--&quot;&gt; &lt;code&gt;terminated()&lt;/code&gt; &lt;/a&gt; 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee562e98404070975b126b69dbde36027259809" translate="yes" xml:space="preserve">
          <source>This class provides a basic file object implementation which can be used as building block for creating file objects. For example, here is how to define a file object which represent source code stored in a string:</source>
          <target state="translated">이 클래스는 파일 객체를 만들기위한 빌딩 블록으로 사용할 수있는 기본 파일 객체 구현을 제공합니다. 예를 들어, 문자열에 저장된 소스 코드를 나타내는 파일 객체를 정의하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05d8d398d426ce102cd4aa03d16d04b81f601c82" translate="yes" xml:space="preserve">
          <source>This class provides a basic implementation of the &lt;code&gt;Attribute&lt;/code&gt; interface.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Attribute&lt;/code&gt; 인터페이스 의 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c76edbc01940fde3909601c41bf2745f78b06d41" translate="yes" xml:space="preserve">
          <source>This class provides a basic implementation of the &lt;code&gt;Control&lt;/code&gt; interface.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Control&lt;/code&gt; 인터페이스 의 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc26575db7c5009c2d93d0c55ec11a1843c5499" translate="yes" xml:space="preserve">
          <source>This class provides a basic implementation of the &lt;code&gt;Control&lt;/code&gt; interface. It represents an LDAPv3 Control as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Control&lt;/code&gt; 인터페이스 의 기본 구현을 제공합니다 . &lt;a href=&quot;http://www.ietf.org/rfc/rfc2251.txt&quot;&gt;RFC 2251에&lt;/a&gt; 정의 된 LDAPv3 컨트롤을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f2949ae857379632b9e3dc8c272a7c7d3f63ae6b" translate="yes" xml:space="preserve">
          <source>This class provides a basic implementation of the Attributes interface.</source>
          <target state="translated">이 클래스는 속성 인터페이스의 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5643c89b210834159b9a8538a094393fd0316f70" translate="yes" xml:space="preserve">
          <source>This class provides a cryptographically strong random number generator (RNG).</source>
          <target state="translated">이 클래스는 암호화 적으로 강력한 난수 생성기 (RNG)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f55fba4dd82d208d447b8686f1389a2aeaa74719" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface to minimize the effort required to implement this interface backed by a &quot;random access&quot; data store (such as an array).</source>
          <target state="translated">이 클래스는 &quot;랜덤 액세스&quot;데이터 저장소 (예 : 배열)로 지원되는이 인터페이스를 구현하는 데 필요한 노력을 최소화하기 위해 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스 의 골격 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a9a8bce22440471af4ffc08d7715360263e088b3" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface to minimize the effort required to implement this interface backed by a &quot;random access&quot; data store (such as an array). For sequential access data (such as a linked list), &lt;a href=&quot;abstractsequentiallist&quot;&gt;&lt;code&gt;AbstractSequentialList&lt;/code&gt;&lt;/a&gt; should be used in preference to this class.</source>
          <target state="translated">이 클래스는 &quot;랜덤 액세스&quot;데이터 저장소 (예 : 배열)로 지원되는이 인터페이스를 구현하는 데 필요한 노력을 최소화하기 위해 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스 의 골격 구현을 제공합니다 . 순차 액세스 데이터 (예 : 링크 된 목록)의 경우이 클래스에 우선하여 &lt;a href=&quot;abstractsequentiallist&quot;&gt; &lt;code&gt;AbstractSequentialList&lt;/code&gt; 를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c35b157721aaf532e29158ba2778a04b725647fc" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;a href=&quot;preferences&quot;&gt;&lt;code&gt;Preferences&lt;/code&gt;&lt;/a&gt; class, greatly easing the task of implementing it.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;preferences&quot;&gt; &lt;code&gt;Preferences&lt;/code&gt; &lt;/a&gt; 클래스 의 골격 구현을 제공하여 구현 작업을 크게 완화합니다.</target>
        </trans-unit>
        <trans-unit id="5e0f3b9d837b76b6b98e1f53a39f4805a7485580" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;code&gt;Collection&lt;/code&gt; interface, to minimize the effort required to implement this interface.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Collection&lt;/code&gt; 인터페이스 의 골격 구현을 제공 하여이 인터페이스를 구현하는 데 필요한 노력을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="5885275d5749220095df4b7df8255a2c192259bb" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;code&gt;List&lt;/code&gt; interface to minimize the effort required to implement this interface backed by a &quot;sequential access&quot; data store (such as a linked list).</source>
          <target state="translated">이 클래스는 &quot;순차 액세스&quot;데이터 저장소 (예 : 링크 된 목록)로 지원되는이 인터페이스를 구현하는 데 필요한 노력을 최소화하기 위해 &lt;code&gt;List&lt;/code&gt; 인터페이스 의 골격 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="10d88f93fe64649e0887b39da1d0c6744f97e975" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;code&gt;List&lt;/code&gt; interface to minimize the effort required to implement this interface backed by a &quot;sequential access&quot; data store (such as a linked list). For random access data (such as an array), &lt;code&gt;AbstractList&lt;/code&gt; should be used in preference to this class.</source>
          <target state="translated">이 클래스는 &quot;순차 액세스&quot;데이터 저장소 (예 : 링크 된 목록)로 지원되는이 인터페이스를 구현하는 데 필요한 노력을 최소화하기 위해 &lt;code&gt;List&lt;/code&gt; 인터페이스 의 골격 구현을 제공합니다 . 임의 액세스 데이터 (예 : 배열)의 경우이 클래스에 우선하여 &lt;code&gt;AbstractList&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e9c7178bf4df3b8e26e321d0c30eef08920002a" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;code&gt;Map&lt;/code&gt; interface, to minimize the effort required to implement this interface.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Map&lt;/code&gt; 인터페이스 의 골격 구현을 제공 하여이 인터페이스를 구현하는 데 필요한 노력을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="30ed5048a3885661e3872b83ab662fb50a15b98b" translate="yes" xml:space="preserve">
          <source>This class provides a skeletal implementation of the &lt;code&gt;Set&lt;/code&gt; interface to minimize the effort required to implement this interface.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Set&lt;/code&gt; 인터페이스 의 스켈 레탈 구현을 제공 하여이 인터페이스를 구현하는 데 필요한 노력을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="850b3f6a723e4a105d67846c4e199ce19413260f" translate="yes" xml:space="preserve">
          <source>This class provides additional methods for generating random streams, that employ the above techniques when used in &lt;code&gt;stream.parallel()&lt;/code&gt; mode.</source>
          <target state="translated">이 클래스는 &lt;code&gt;stream.parallel()&lt;/code&gt; 모드 에서 사용될 때 위의 기술을 사용하는 임의의 스트림을 생성하기위한 추가 메소드를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1e2e96e0f3ae47fd59d509ed69e427ed93ce4793" translate="yes" xml:space="preserve">
          <source>This class provides all of the optional &lt;code&gt;Map&lt;/code&gt; operations, and permits null elements. Like &lt;code&gt;HashMap&lt;/code&gt;, it provides constant-time performance for the basic operations (&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of &lt;code&gt;HashMap&lt;/code&gt;, due to the added expense of maintaining the linked list, with one exception: Iteration over the collection-views of a &lt;code&gt;LinkedHashMap&lt;/code&gt; requires time proportional to the</source>
          <target state="translated">이 클래스는 모든 선택적 &lt;code&gt;Map&lt;/code&gt; 작업을 제공하고 null 요소를 허용합니다. &lt;code&gt;HashMap&lt;/code&gt; 과 마찬가지로 해시 함수가 버킷간에 요소를 올바르게 분산시키는 것으로 가정하여 기본 작업 ( &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; )에 일정한 시간 성능을 제공합니다 . &lt;code&gt;LinkedHashMap&lt;/code&gt; 의 콜렉션 뷰에 대한 반복에는 링크 된 목록을 유지 보수하는 추가 비용으로 인해 성능이 &lt;code&gt;HashMap&lt;/code&gt; 의 성능보다 약간 떨어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff706953493a74746d04f26b24913b430916a541" translate="yes" xml:space="preserve">
          <source>This class provides all of the optional &lt;code&gt;Set&lt;/code&gt; operations, and permits null elements. Like &lt;code&gt;HashSet&lt;/code&gt;, it provides constant-time performance for the basic operations (&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of &lt;code&gt;HashSet&lt;/code&gt;, due to the added expense of maintaining the linked list, with one exception: Iteration over a &lt;code&gt;LinkedHashSet&lt;/code&gt; requires time proportional to the</source>
          <target state="translated">이 클래스는 모든 선택적 &lt;code&gt;Set&lt;/code&gt; 작업을 제공하고 null 요소를 허용합니다. &lt;code&gt;HashSet&lt;/code&gt; 과 마찬가지로 해시 함수가 버킷간에 요소를 올바르게 분산시키는 것으로 가정하여 기본 작업 ( &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; )에 일정한 시간 성능을 제공합니다 . 링크 된 목록을 유지 관리하는 추가 비용으로 인해 성능이 &lt;code&gt;HashSet&lt;/code&gt; 의 성능보다 약간 낮을 수 있습니다 . &lt;code&gt;LinkedHashSet&lt;/code&gt; 에 대한 반복 에는</target>
        </trans-unit>
        <trans-unit id="21691796695b60e351045a6a8026bd2180011a02" translate="yes" xml:space="preserve">
          <source>This class provides all of the optional map operations, and permits &lt;code&gt;null&lt;/code&gt; values and the &lt;code&gt;null&lt;/code&gt; key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</source>
          <target state="translated">이 클래스는 모든 선택적 맵 작업을 제공하고 &lt;code&gt;null&lt;/code&gt; 값과 &lt;code&gt;null&lt;/code&gt; 키를 허용 합니다. 이 클래스는지도의 순서를 보증하지 않습니다. 특히, 주문이 시간이 지남에 따라 일정하게 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7d16893e35e5bb2d3a4daa3d587380bb5244ac9" translate="yes" xml:space="preserve">
          <source>This class provides an efficient and scalable basis for synchronization in part by specializing its range of use to synchronizers that can rely on &lt;code&gt;int&lt;/code&gt; state, acquire, and release parameters, and an internal FIFO wait queue. When this does not suffice, you can build synchronizers from a lower level using &lt;a href=&quot;../atomic/package-summary&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; classes, your own custom &lt;a href=&quot;../../queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; classes, and &lt;a href=&quot;locksupport&quot;&gt;&lt;code&gt;LockSupport&lt;/code&gt;&lt;/a&gt; blocking support.</source>
          <target state="translated">이 클래스는 &lt;code&gt;int&lt;/code&gt; 상태에 의존 하고 매개 변수를 획득 및 해제 할 수있는 동기화 프로그램 과 내부 FIFO 대기 큐 에 사용할 수있는 범위를 전문화함으로써 부분적으로 효율적이고 확장 가능한 동기화 기반을 제공합니다 . 이것으로 충분하지 않으면 &lt;a href=&quot;../atomic/package-summary&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 클래스, 사용자 정의 &lt;a href=&quot;../../queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 클래스 및 &lt;a href=&quot;locksupport&quot;&gt; &lt;code&gt;LockSupport&lt;/code&gt; &lt;/a&gt; 차단 지원을 사용하여 하위 레벨에서 동기화 프로그램을 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="027df20526035274a2572144300b415422d0bcc5" translate="yes" xml:space="preserve">
          <source>This class provides common implementations of &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;. These are defined here as they must be constants, and the definition of lambdas does not guarantee that. By assigning them once here, they become 'normal' Java constants.</source>
          <target state="translated">이 클래스는 일반적인 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 구현을 제공합니다 . 이것들은 상수이어야하기 때문에 여기에 정의되어 있으며 람다의 정의는 그것을 보증하지 않습니다. 여기에 한 번 할당하면 '정상적인'Java 상수가됩니다.</target>
        </trans-unit>
        <trans-unit id="3d782ad4534620a208daae5188b15671d6dab525" translate="yes" xml:space="preserve">
          <source>This class provides constant-time performance for the basic operations (&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;), assuming the system identity hash function (&lt;a href=&quot;../lang/system#identityHashCode-java.lang.Object-&quot;&gt;&lt;code&gt;System.identityHashCode(Object)&lt;/code&gt;&lt;/a&gt;) disperses elements properly among the buckets.</source>
          <target state="translated">이 클래스는 시스템 아이덴티티 해시 함수 ( &lt;a href=&quot;../lang/system#identityHashCode-java.lang.Object-&quot;&gt; &lt;code&gt;System.identityHashCode(Object)&lt;/code&gt; &lt;/a&gt; )가 버킷간에 요소를 올바르게 분산시키는 것으로 가정 하여 기본 작업 ( &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; )에 일정한 시간 성능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a9cb2f8fd6fb692752836a91d6666165347f6e16" translate="yes" xml:space="preserve">
          <source>This class provides definitions of the notifications sent by timer MBeans.</source>
          <target state="translated">이 클래스는 타이머 MBean에 의해 송신 된 통지의 정의를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b305425f2398615078405474d162a9f3135b589" translate="yes" xml:space="preserve">
          <source>This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; for their synchronization mechanics.</source>
          <target state="translated">이 클래스는 내부 대기열에 대한 검사, 계측 및 모니터링 방법과 조건 객체에 대한 유사한 방법을 제공합니다. 동기화 메커니즘을 위해 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 를 사용하여 원하는대로 클래스로 내보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acf6161ba4b0d7b36a78134ed42c8d898e70d207" translate="yes" xml:space="preserve">
          <source>This class provides mechanisms to specify a source region and a destination region. When reading, the source is the stream and the in-memory image is the destination. When writing, these are reversed. In the case of writing, destination regions may be used only with a writer that supports pixel replacement.</source>
          <target state="translated">이 클래스는 소스 영역과 대상 영역을 지정하는 메커니즘을 제공합니다. 읽을 때 소스는 스트림이고 인 메모리 이미지는 대상입니다. 쓰면 이것들이 반대로됩니다. 기록의 경우, 대상 영역은 픽셀 교체를 지원하는 기록기에서만 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e8c5f6f7dc4757b4202226c0b0b9d6877bc3c5" translate="yes" xml:space="preserve">
          <source>This class provides services needed to instrument Java programming language code.</source>
          <target state="translated">이 클래스는 Java 프로그래밍 언어 코드를 계측하는 데 필요한 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3daf5d23b815ee7fc1850661ecdc8effd7d7409f" translate="yes" xml:space="preserve">
          <source>This class provides services needed to instrument Java programming language code. Instrumentation is the addition of byte-codes to methods for the purpose of gathering data to be utilized by tools. Since the changes are purely additive, these tools do not modify application state or behavior. Examples of such benign tools include monitoring agents, profilers, coverage analyzers, and event loggers.</source>
          <target state="translated">이 클래스는 Java 프로그래밍 언어 코드를 계측하는 데 필요한 서비스를 제공합니다. 인스 트루먼 테이션은 도구에서 사용할 데이터를 수집하기 위해 메소드에 바이트 코드를 추가하는 것입니다. 변경 사항은 순전히 추가되므로 이러한 도구는 응용 프로그램 상태 나 동작을 수정하지 않습니다. 이러한 양성 도구의 예로는 모니터링 에이전트, 프로파일 러, 범위 분석기 및 이벤트 로거가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e15f52dce02a6211946d8272a9bcc580b35b8f5" translate="yes" xml:space="preserve">
          <source>This class provides skeletal implementations of some &lt;a href=&quot;queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; operations.</source>
          <target state="translated">이 클래스는 일부 &lt;a href=&quot;queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 작업 의 골격 구현을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="630ba7fe37391ec51305ce9f5c26f1c93cf195dc" translate="yes" xml:space="preserve">
          <source>This class provides skeletal implementations of some &lt;a href=&quot;queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; operations. The implementations in this class are appropriate when the base implementation does &lt;em&gt;not&lt;/em&gt; allow &lt;code&gt;null&lt;/code&gt; elements. Methods &lt;a href=&quot;abstractqueue#add-E-&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractqueue#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;abstractqueue#element--&quot;&gt;&lt;code&gt;element&lt;/code&gt;&lt;/a&gt; are based on &lt;a href=&quot;queue#offer-E-&quot;&gt;&lt;code&gt;offer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;queue#poll--&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;queue#peek--&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt;, respectively, but throw exceptions instead of indicating failure via &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; returns.</source>
          <target state="translated">이 클래스는 일부 &lt;a href=&quot;queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 작업 의 골격 구현을 제공 합니다. 이 클래스의 구현은 기본 구현이 &lt;code&gt;null&lt;/code&gt; 요소를 허용 하지 &lt;em&gt;않을&lt;/em&gt; 때 적절 합니다. &lt;a href=&quot;abstractqueue#add-E-&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;abstractqueue#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;abstractqueue#element--&quot;&gt; &lt;code&gt;element&lt;/code&gt; &lt;/a&gt; 메소드 는 각각 &lt;a href=&quot;queue#offer-E-&quot;&gt; &lt;code&gt;offer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;queue#poll--&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;queue#peek--&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 기반 이지만 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 반환을 통한 실패를 나타내는 대신 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f44514648bc390b667dbff0288db9ab16c09a1df" translate="yes" xml:space="preserve">
          <source>This class provides some general purpose beans control methods.</source>
          <target state="translated">이 클래스는 일부 범용 Bean 제어 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67a252990dac3574afb495a8ad1caa09683e19e5" translate="yes" xml:space="preserve">
          <source>This class provides support for general purpose compression using the popular ZLIB compression library.</source>
          <target state="translated">이 클래스는 널리 사용되는 ZLIB 압축 라이브러리를 사용하여 범용 압축을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b2d5100e7e5c3b1fa28929ac1a9592d341ec37a8" translate="yes" xml:space="preserve">
          <source>This class provides support for general purpose compression using the popular ZLIB compression library. The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents. It is fully described in the specifications at the &lt;a href=&quot;package-summary#package_description&quot;&gt;java.util.zip package description&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 널리 사용되는 ZLIB 압축 라이브러리를 사용하여 범용 압축을 지원합니다. ZLIB 압축 라이브러리는 처음에 PNG 그래픽 표준의 일부로 개발되었으며 특허로 보호되지 않습니다. &lt;a href=&quot;package-summary#package_description&quot;&gt;java.util.zip 패키지 설명&lt;/a&gt; 의 스펙에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62783ba52ad30067c4bf97c27eb8a9f432cca20" translate="yes" xml:space="preserve">
          <source>This class provides support for general purpose decompression using the popular ZLIB compression library.</source>
          <target state="translated">이 클래스는 널리 사용되는 ZLIB 압축 라이브러리를 사용하여 범용 압축 해제를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="42a68b0f8134c883f72b838887540092c0c76680" translate="yes" xml:space="preserve">
          <source>This class provides support for general purpose decompression using the popular ZLIB compression library. The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents. It is fully described in the specifications at the &lt;a href=&quot;package-summary#package_description&quot;&gt;java.util.zip package description&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 널리 사용되는 ZLIB 압축 라이브러리를 사용하여 범용 압축 해제를 지원합니다. ZLIB 압축 라이브러리는 처음에 PNG 그래픽 표준의 일부로 개발되었으며 특허로 보호되지 않습니다. &lt;a href=&quot;package-summary#package_description&quot;&gt;java.util.zip 패키지 설명&lt;/a&gt; 의 스펙에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="058063ff23a514c72d17cf5bb02175b69f44f9bb" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of a &quot;Message Authentication Code&quot; (MAC) algorithm.</source>
          <target state="translated">이 클래스는 &quot;메시지 인증 코드&quot;(MAC) 알고리즘의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d17535455ee3a93a28bd48adb2f85d352576483" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of a cryptographic cipher for encryption and decryption.</source>
          <target state="translated">이 클래스는 암호화 및 암호 해독을위한 암호화 암호 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38056ecd3eb0041e31918a2cb122cb3971090037" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of a cryptographic cipher for encryption and decryption. It forms the core of the Java Cryptographic Extension (JCE) framework.</source>
          <target state="translated">이 클래스는 암호화 및 암호 해독을위한 암호화 암호 기능을 제공합니다. JCE (Java Cryptographic Extension) 프레임 워크의 핵심을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="b7f9af6863cfc7132c7b426fcb653626f2c59c5b" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of a key agreement (or key exchange) protocol.</source>
          <target state="translated">이 클래스는 키 계약 (또는 키 교환) 프로토콜의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e195f5a4aecf4d805b4067fb733d1fffc5c3580f" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of a secret (symmetric) key generator.</source>
          <target state="translated">이 클래스는 비밀 (대칭) 키 생성기의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71a7bb8d6c1cf35996c2c7d54ea430cc02fc2f0e" translate="yes" xml:space="preserve">
          <source>This class provides the functionality of an exemption mechanism, examples of which are</source>
          <target state="translated">이 클래스는 면제 메커니즘의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77361a95dede7f772c5daefc3f6fed52e2dd3203" translate="yes" xml:space="preserve">
          <source>This class provides the main application entry point for printing and parsing and provides common implementations of &lt;code&gt;DateTimeFormatter&lt;/code&gt;:</source>
          <target state="translated">이 클래스는 인쇄 및 구문 분석을위한 기본 응용 프로그램 진입 점을 제공하고 일반적인 &lt;code&gt;DateTimeFormatter&lt;/code&gt; 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="32c2e42c58d5563f589463d9769297959632d96f" translate="yes" xml:space="preserve">
          <source>This class provides the method &lt;code&gt;normalize&lt;/code&gt; which transforms Unicode text into an equivalent composed or decomposed form, allowing for easier sorting and searching of text.</source>
          <target state="translated">이 클래스는 유니 코드 텍스트를 동등한 구성 또는 분해 형식으로 변환하여 텍스트를보다 쉽게 ​​정렬하고 검색 할 수있는 &lt;code&gt;normalize&lt;/code&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d1f27e8c5361496e2bcd15eae00a46e2381ba122" translate="yes" xml:space="preserve">
          <source>This class provides the method &lt;code&gt;normalize&lt;/code&gt; which transforms Unicode text into an equivalent composed or decomposed form, allowing for easier sorting and searching of text. The &lt;code&gt;normalize&lt;/code&gt; method supports the standard normalization forms described in &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt; Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 유니 코드 텍스트를 동등한 구성 또는 분해 형식으로 변환하여 텍스트를보다 쉽게 ​​정렬하고 검색 할 수있는 &lt;code&gt;normalize&lt;/code&gt; 메소드를 제공합니다 . &lt;code&gt;normalize&lt;/code&gt; 방법에 설명 된 표준 정규화 형태의 지원 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/tr15-23.html&quot;&gt;유니 코드 표준화 양식 - 유니 코드 표준 부록 # 15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94f744e03b23887bcedd3bd044c9102d91afafb2" translate="yes" xml:space="preserve">
          <source>This class provides thread-local variables.</source>
          <target state="translated">이 클래스는 스레드 로컬 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="493cf5569ee6c8c562fbd1ca601aae11d69ef2db" translate="yes" xml:space="preserve">
          <source>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; method) has its own, independently initialized copy of the variable. &lt;code&gt;ThreadLocal&lt;/code&gt; instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</source>
          <target state="translated">이 클래스는 스레드 로컬 변수를 제공합니다. 이러한 변수는 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 메소드 를 통해 하나에 액세스하는 각 스레드가 독립적으로 초기화 된 변수의 사본을 가지고 있다는 점에서 일반적인 대응과 다릅니다 . &lt;code&gt;ThreadLocal&lt;/code&gt; 인스턴스는 일반적으로 상태를 스레드 (예 : 사용자 ID 또는 트랜잭션 ID)와 연결하려는 클래스의 전용 정적 필드입니다.</target>
        </trans-unit>
        <trans-unit id="af4f54ebb7bd4cdda400f1f7686b6b1996a12d34" translate="yes" xml:space="preserve">
          <source>This class provides two forms of linkage methods: a standard version (&lt;a href=&quot;lambdametafactory#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt;&lt;/a&gt;) using an optimized protocol, and an alternate version &lt;a href=&quot;lambdametafactory#altMetafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.Object...-&quot;&gt;&lt;code&gt;altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)&lt;/code&gt;&lt;/a&gt;). The alternate version is a generalization of the standard version, providing additional control over the behavior of the generated function objects via flags and additional arguments. The alternate version adds the ability to manage the following attributes of function objects:</source>
          <target state="translated">이 클래스는 최적화 된 프로토콜을 사용하는 표준 버전 ( &lt;a href=&quot;lambdametafactory#metafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.invoke.MethodType-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)&lt;/code&gt; &lt;/a&gt; )과 대체 버전 &lt;a href=&quot;lambdametafactory#altMetafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.Object...-&quot;&gt; &lt;code&gt;altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)&lt;/code&gt; &lt;/a&gt; )의 두 가지 연결 방법을 제공합니다. ...) ). 대체 버전은 표준 버전의 일반화로 플래그와 추가 인수를 통해 생성 된 함수 객체의 동작을 추가로 제어 할 수 있습니다. 대체 버전은 함수 객체의 다음 속성을 관리하는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bcfec68930e91dff3b974ffeb35fc31dc7b2d2f3" translate="yes" xml:space="preserve">
          <source>This class represents a &quot;most-trusted CA&quot;, which is used as a trust anchor for validating X.509 certification paths. A most-trusted CA includes the public key of the CA, the CA's name, and any constraints upon the set of paths which may be validated using this key. These parameters can be specified in the form of a trusted &lt;code&gt;X509Certificate&lt;/code&gt; or as individual parameters.</source>
          <target state="translated">이 클래스는 &quot;가장 신뢰할 수있는 CA&quot;를 나타내며 X.509 인증 경로의 유효성을 검사하기위한 신뢰 앵커로 사용됩니다. 가장 신뢰할 수있는 CA에는 CA의 공개 키, CA 이름 및이 키를 사용하여 유효성을 검사 할 수있는 경로 집합에 대한 제약 조건이 포함됩니다. 이러한 매개 변수는 신뢰할 수있는 &lt;code&gt;X509Certificate&lt;/code&gt; 의 형식으로 또는 개별 매개 변수로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c2f2d6911e310787abdbf5f9e48315e898c3b1e" translate="yes" xml:space="preserve">
          <source>This class represents a &quot;provider&quot; for the Java Security API, where a provider implements some or all parts of Java Security.</source>
          <target state="translated">이 클래스는 제공자가 Java Security의 일부 또는 전부를 구현하는 Java Security API의 &quot;제공자&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7a9e4a03a08b3eeea1fad1f3a1d55aaf545f0f7" translate="yes" xml:space="preserve">
          <source>This class represents a &quot;provider&quot; for the Java Security API, where a provider implements some or all parts of Java Security. Services that a provider may implement include:</source>
          <target state="translated">이 클래스는 제공자가 Java Security의 일부 또는 전부를 구현하는 Java Security API의 &quot;제공자&quot;를 나타냅니다. 제공자가 구현할 수있는 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ece3559be87e359f3d54d8c167b3dfbc5c0d531" translate="yes" xml:space="preserve">
          <source>This class represents a Network Interface address.</source>
          <target state="translated">이 클래스는 네트워크 인터페이스 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a07c1f6ae0be68a7f58c90ed1384c3217450954f" translate="yes" xml:space="preserve">
          <source>This class represents a Network Interface address. In short it's an IP address, a subnet mask and a broadcast address when the address is an IPv4 one. An IP address and a network prefix length in the case of IPv6 address.</source>
          <target state="translated">이 클래스는 네트워크 인터페이스 주소를 나타냅니다. 간단히 말해 주소가 IPv4 주소 인 경우 IP 주소, 서브넷 마스크 및 브로드 캐스트 주소입니다. IPv6 주소의 경우 IP 주소 및 네트워크 접두사 길이</target>
        </trans-unit>
        <trans-unit id="7040d5a44c74edc7402bbee1fc20547a6a1a81c0" translate="yes" xml:space="preserve">
          <source>This class represents a Network Interface made up of a name, and a list of IP addresses assigned to this interface.</source>
          <target state="translated">이 클래스는 이름과이 인터페이스에 할당 된 IP 주소 목록으로 구성된 네트워크 인터페이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="443d8a563e78bfb9a807f7f1f079ce2064dc19ba" translate="yes" xml:space="preserve">
          <source>This class represents a Network Interface made up of a name, and a list of IP addresses assigned to this interface. It is used to identify the local interface on which a multicast group is joined. Interfaces are normally known by names such as &quot;le0&quot;.</source>
          <target state="translated">이 클래스는 이름과이 인터페이스에 할당 된 IP 주소 목록으로 구성된 네트워크 인터페이스를 나타냅니다. 멀티 캐스트 그룹이 결합 된 로컬 인터페이스를 식별하는 데 사용됩니다. 인터페이스는 일반적으로 &quot;le0&quot;과 같은 이름으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="5606e78f7fbfecd77da8d162f001a91eea0a3cab" translate="yes" xml:space="preserve">
          <source>This class represents a Reference whose contents is a name, called the link name, that is bound to an atomic name in a context.</source>
          <target state="translated">이 클래스는 내용이 컨텍스트에서 원자 이름에 바인딩 된 이름 인 링크 이름이라고하는 Reference를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aaef20acd642190f418479ecd58ec3a5d3a99999" translate="yes" xml:space="preserve">
          <source>This class represents a Socket Address with no protocol attachment.</source>
          <target state="translated">이 클래스는 프로토콜 첨부가없는 소켓 주소를 나타냅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
