<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="4acf01c0df81cddc20d7dfb79ad62615a15e5c84" translate="yes" xml:space="preserve">
          <source>The interface to a Diffie-Hellman public key.</source>
          <target state="translated">Diffie-Hellman 공개 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bb7785adea75ae08367d3fad0898e7f74e3a25df" translate="yes" xml:space="preserve">
          <source>The interface to a PBE key.</source>
          <target state="translated">PBE 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5c1db7ae0638b04f0ceada2e49d2df2966d53fb8" translate="yes" xml:space="preserve">
          <source>The interface to an RSA multi-prime private key, as defined in the PKCS#1 v2.1, using the</source>
          <target state="translated">PKCS # 1 v2.1에 정의 된 RSA 멀티-프라임 개인 키에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="962644ae619db56ffc6c6dad22fd41157b2fd2a0" translate="yes" xml:space="preserve">
          <source>The interface to an RSA private key, as defined in the PKCS#1 standard, using the</source>
          <target state="translated">PKCS # 1 표준에 정의 된대로 RSA 개인 키에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="9af190896ba0f3ec911fd1ca9076fd92e2426bcb" translate="yes" xml:space="preserve">
          <source>The interface to an RSA private key.</source>
          <target state="translated">RSA 개인 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="40ba9f0717c9368de370e6c22458f351ecd83c45" translate="yes" xml:space="preserve">
          <source>The interface to an RSA public key.</source>
          <target state="translated">RSA 공개 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="21ca22444f4daa0fa309978083c83a357a706d1a" translate="yes" xml:space="preserve">
          <source>The interface to an RSA public or private key.</source>
          <target state="translated">RSA 공개 또는 개인 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="7eddc4f13981b28b7fc90f393624b67b1c6494e1" translate="yes" xml:space="preserve">
          <source>The interface to an elliptic curve (EC) key.</source>
          <target state="translated">타원 곡선 (EC) 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="e0aecd668220d63ab8af6b0ed5fd7985ec0495d5" translate="yes" xml:space="preserve">
          <source>The interface to an elliptic curve (EC) private key.</source>
          <target state="translated">EC (Elliptic Curve) 개인 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b4cca451c5f37a2fb4b20bef00c3b41668f48298" translate="yes" xml:space="preserve">
          <source>The interface to an elliptic curve (EC) public key.</source>
          <target state="translated">EC (Elliptic Curve) 공개 키에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4fa870ba5a0a544cc68fd31508316e7b610bd371" translate="yes" xml:space="preserve">
          <source>The interface whose implementing classes are used to connect Script Engines with objects, such as scoped Bindings, in hosting applications.</source>
          <target state="translated">호스팅 응용 프로그램에서 스크립트 엔진을 범위 바인딩과 같은 개체와 연결하는 데 구현 클래스가 사용되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ad68169d81438deea93e7cdddc0d3f1cc9aa0897" translate="yes" xml:space="preserve">
          <source>The interface whose implementing classes are used to connect Script Engines with objects, such as scoped Bindings, in hosting applications. Each scope is a set of named attributes whose values can be set and retrieved using the &lt;code&gt;ScriptContext&lt;/code&gt; methods. ScriptContexts also expose Readers and Writers that can be used by the ScriptEngines for input and output.</source>
          <target state="translated">호스팅 응용 프로그램에서 스크립트 엔진을 범위 바인딩과 같은 개체와 연결하는 데 구현 클래스가 사용되는 인터페이스입니다. 각 범위는 &lt;code&gt;ScriptContext&lt;/code&gt; 메서드를 사용하여 값을 설정하고 검색 할 수있는 명명 된 특성 집합입니다 . ScriptContext는 또한 ScriptEngine에서 입력 및 출력에 사용할 수있는 Reader 및 Writer를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b586a8bc8674bef4ff71be9874a1bca665e48ea2" translate="yes" xml:space="preserve">
          <source>The interfaces in this package are annotated with &lt;a href=&quot;../../lang/functionalinterface&quot;&gt;&lt;code&gt;FunctionalInterface&lt;/code&gt;&lt;/a&gt;. This annotation is not a requirement for the compiler to recognize an interface as a functional interface, but merely an aid to capture design intent and enlist the help of the compiler in identifying accidental violations of design intent.</source>
          <target state="translated">이 패키지의 인터페이스는 &lt;a href=&quot;../../lang/functionalinterface&quot;&gt; &lt;code&gt;FunctionalInterface&lt;/code&gt; &lt;/a&gt; 로 주석 처리됩니다 . 이 주석은 컴파일러가 인터페이스를 기능적 인터페이스로 인식하기위한 요구 사항이 아니라 설계 의도를 포착하고 우발적 인 설계 의도 위반을 식별하는 데 컴파일러의 도움을 모으는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e80ea45bc954fd03a7e9d97b2ac2fddee32d9c" translate="yes" xml:space="preserve">
          <source>The interfaces in this package are general purpose functional interfaces used by the JDK, and are available to be used by user code as well. While they do not identify a complete set of function shapes to which lambda expressions might be adapted, they provide enough to cover common requirements. Other functional interfaces provided for specific purposes, such as &lt;a href=&quot;../../io/filefilter&quot;&gt;&lt;code&gt;FileFilter&lt;/code&gt;&lt;/a&gt;, are defined in the packages where they are used.</source>
          <target state="translated">이 패키지의 인터페이스는 JDK에서 사용하는 범용 기능 인터페이스이며 사용자 코드에서도 사용할 수 있습니다. 람다 식을 적용 할 수있는 완전한 함수 셰이프 집합을 식별하지는 않지만 공통 요구 사항을 충분히 충족 할 수 있습니다. &lt;a href=&quot;../../io/filefilter&quot;&gt; &lt;code&gt;FileFilter&lt;/code&gt; &lt;/a&gt; 와 같은 특정 목적으로 제공되는 기타 기능 인터페이스 는 사용되는 패키지에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f0aedf60340a18f664d801740438927103a34c5" translate="yes" xml:space="preserve">
          <source>The interfaces of an AttributeSet resemble those of the Java Collections API's java.util.Map interface, but is more restrictive in the types it will accept, and combines keys and values into an Attribute.</source>
          <target state="translated">AttributeSet의 인터페이스는 Java Collections API의 java.util.Map 인터페이스의 인터페이스와 유사하지만 허용되는 유형이 더 제한적이며 키와 값을 속성으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="4c88b3d99811fc3ce8911d52260d63fb6bd23bc5" translate="yes" xml:space="preserve">
          <source>The internal buffer array where the data is stored. When necessary, it may be replaced by another array of a different size.</source>
          <target state="translated">데이터가 저장되는 내부 버퍼 배열. 필요한 경우 다른 크기의 다른 어레이로 교체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e467d22d50f08036b2d07e61bd60b6c01391383c" translate="yes" xml:space="preserve">
          <source>The internal buffer where data is stored.</source>
          <target state="translated">데이터가 저장되는 내부 버퍼.</target>
        </trans-unit>
        <trans-unit id="4b83e6877fa5cf0fe0c11f806ceb26931ce826b9" translate="yes" xml:space="preserve">
          <source>The internal details of converting an &lt;code&gt;IIOMetadata&lt;/code&gt; object into a writer-specific format will vary according to the context of the operation. Typically, an &lt;code&gt;ImageWriter&lt;/code&gt; will inspect the incoming object to see if it implements additional interfaces with which the writer is familiar. This might be the case, for example, if the object was obtained by means of a read operation on a reader plug-in written by the same vendor as the writer. In this case, the writer may access the incoming object by means of its plug-in specific interfaces. In this case, the re-encoding may be close to lossless if the image file format is kept constant. If the format is changing, the writer may still attempt to preserve as much information as possible.</source>
          <target state="translated">&lt;code&gt;IIOMetadata&lt;/code&gt; 객체를 작성 기별 형식으로 변환하는 내부 세부 사항은 작업의 컨텍스트에 따라 다릅니다. 일반적으로 &lt;code&gt;ImageWriter&lt;/code&gt; 는 들어오는 객체를 검사하여 작성기가 익숙한 추가 인터페이스를 구현하는지 확인합니다. 예를 들어, 작성자와 동일한 벤더가 작성한 리더 플러그인에서 읽기 조작을 통해 오브젝트를 얻은 경우가 이에 해당합니다. 이 경우 기록기는 플러그인 특정 인터페이스를 통해 수신 객체에 액세스 할 수 있습니다. 이 경우, 이미지 파일 포맷이 일정하게 유지되면 재 인코딩은 손실이 거의 없을 수있다. 형식이 변경되면 기록기는 가능한 한 많은 정보를 보존하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026c3bb1a08b7e0301eba9e3961c4a88004f9391" translate="yes" xml:space="preserve">
          <source>The internal field corresponding to the type name of this &lt;code&gt;ArrayType&lt;/code&gt; instance is also set to the class name of the array instances it describes. In other words, the methods &lt;code&gt;getClassName&lt;/code&gt; and &lt;code&gt;getTypeName&lt;/code&gt; return the same string value. The internal field corresponding to the description of this &lt;code&gt;ArrayType&lt;/code&gt; instance is set to a string value which follows the following template:</source>
          <target state="translated">이 &lt;code&gt;ArrayType&lt;/code&gt; 인스턴스 의 형식 이름에 해당하는 내부 필드 도 설명하는 배열 인스턴스의 클래스 이름으로 설정됩니다. 즉, &lt;code&gt;getClassName&lt;/code&gt; 및 &lt;code&gt;getTypeName&lt;/code&gt; 메소드 는 동일한 문자열 값을 리턴합니다. 이 &lt;code&gt;ArrayType&lt;/code&gt; 인스턴스 의 설명에 해당하는 내부 필드 는 다음 템플릿을 따르는 문자열 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc341f1196d05a1444add689183382b41f0973e8" translate="yes" xml:space="preserve">
          <source>The interpretation of &lt;code&gt;filterExpr&lt;/code&gt; is based on RFC 2254. It may additionally contain variables of the form &lt;code&gt;{i}&lt;/code&gt; -- where &lt;code&gt;i&lt;/code&gt; is an integer -- that refer to objects in the &lt;code&gt;filterArgs&lt;/code&gt; array. The interpretation of &lt;code&gt;filterExpr&lt;/code&gt; is otherwise identical to that of the &lt;code&gt;filter&lt;/code&gt; parameter of the method &lt;code&gt;search(Name, String, SearchControls)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filterExpr&lt;/code&gt; 의 해석은 RFC 2254를 기반으로 합니다. 또한 &lt;code&gt;filterArgs&lt;/code&gt; 배열의 오브젝트를 참조하는 &lt;code&gt;{i}&lt;/code&gt; 형식의 변수 ( 여기서 &lt;code&gt;i&lt;/code&gt; 는 정수임)를 포함 할 수 있습니다 . &lt;code&gt;filterExpr&lt;/code&gt; 의 해석은 &lt;code&gt;search(Name, String, SearchControls)&lt;/code&gt; 메소드 의 &lt;code&gt;filter&lt;/code&gt; 매개 변수의 해석과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b17b0be7e9649edb0287ead5101582dc5811a7d1" translate="yes" xml:space="preserve">
          <source>The ints between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the int at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 정수 (있는 경우)가 버퍼의 시작 부분에 복사됩니다. 즉, 인덱스의 int</target>
        </trans-unit>
        <trans-unit id="f319001c4eea02470448a8107b38966f0461733e" translate="yes" xml:space="preserve">
          <source>The invocation &lt;code&gt;new Random(seed)&lt;/code&gt; is equivalent to:</source>
          <target state="translated">&lt;code&gt;new Random(seed)&lt;/code&gt; 호출 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="babf9d5bd6a8a8c2f47c1a276ea3aea89de709e2" translate="yes" xml:space="preserve">
          <source>The invocation of this method, and the subsequent use of the resulting map, may cause time-consuming disk or network I/O operations to occur. This method is provided for applications that need to enumerate all of the available charsets, for example to allow user charset selection. This method is not used by the &lt;a href=&quot;charset#forName-java.lang.String-&quot;&gt;&lt;code&gt;forName&lt;/code&gt;&lt;/a&gt; method, which instead employs an efficient incremental lookup algorithm.</source>
          <target state="translated">이 메소드의 호출 및 결과 맵의 후속 사용으로 인해 시간이 많이 걸리는 디스크 또는 네트워크 I / O 조작이 발생할 수 있습니다. 이 방법은 사용 가능한 모든 문자 집합을 열거해야하는 응용 프로그램 (예 : 사용자 문자 집합 선택 허용)에 제공됩니다. 이 메소드는 효율적인 증분 조회 알고리즘을 사용하는 &lt;a href=&quot;charset#forName-java.lang.String-&quot;&gt; &lt;code&gt;forName&lt;/code&gt; &lt;/a&gt; 메소드에서 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1cd061a90ad70184b57e438747c712b7578eb71c" translate="yes" xml:space="preserve">
          <source>The invoker will invoke its target like a call to &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; with the indicated &lt;code&gt;type&lt;/code&gt;. That is, if the target is exactly of the given &lt;code&gt;type&lt;/code&gt;, it will behave like &lt;code&gt;invokeExact&lt;/code&gt;; otherwise it behave as if &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; is used to convert the target to the required &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">호출자는 표시된 &lt;code&gt;type&lt;/code&gt; 으로 호출하는 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 과 같이 대상을 호출 합니다 . 즉, 대상이 지정된 &lt;code&gt;type&lt;/code&gt; 인 경우 &lt;code&gt;invokeExact&lt;/code&gt; 처럼 동작합니다 . 그렇지 않으면 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 을 사용하여 대상을 필요한 &lt;code&gt;type&lt;/code&gt; 으로 변환하는 것처럼 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="310452cd1f3861f99c2e30719b2a1c80c625887f" translate="yes" xml:space="preserve">
          <source>The issuer name field contains an X.500 distinguished name (DN). The ASN.1 definition for this is:</source>
          <target state="translated">발급자 이름 필드에는 X.500 식별 이름 (DN)이 있습니다. 이에 대한 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43677bd6fb1d8e6b8fec88d0eb15823021a7a4bf" translate="yes" xml:space="preserve">
          <source>The iterator is</source>
          <target state="translated">반복자는</target>
        </trans-unit>
        <trans-unit id="89828064d0a9b123146c05ca87946b21b3543b5c" translate="yes" xml:space="preserve">
          <source>The iterator returned by the &lt;code&gt;iterator&lt;/code&gt; method traverses the elements in their</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 iterator는 해당 요소를 순회합니다.</target>
        </trans-unit>
        <trans-unit id="f9acc692e383944ec985155a5700e56e7ee30437" translate="yes" xml:space="preserve">
          <source>The iterator returned by this method does not support removal. Invoking its &lt;a href=&quot;iterator#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method will cause an &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">이 메소드에 의해 리턴 된 반복기는 제거를 지원하지 않습니다. &lt;a href=&quot;iterator#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메소드를 호출하면 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="98e2680cc8dc738c981f8a34b95901f4a62969ea" translate="yes" xml:space="preserve">
          <source>The iterator returned by this method first yields all of the elements of the provider cache, in instantiation order. It then lazily loads and instantiates any remaining providers, adding each one to the cache in turn.</source>
          <target state="translated">이 메소드에 의해 리턴 된 반복자는 먼저 인스턴스화 순서로 제공자 캐시의 모든 요소를 ​​생성합니다. 그런 다음 나머지 공급자를 느리게로드하고 인스턴스화하여 각 공급자를 차례로 캐시에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7596d0c3e99ad866c46e5d332b27bd327a16802e" translate="yes" xml:space="preserve">
          <source>The iterators returned by all of this class's &quot;collection view methods&quot; are</source>
          <target state="translated">이 클래스의 모든 &quot;컬렉션 뷰 메소드&quot;에 의해 리턴 된 반복자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34c7dfd11c16c2eb6589c6b0cbc4a3695a380b36" translate="yes" xml:space="preserve">
          <source>The iterators returned by the &lt;code&gt;iterator&lt;/code&gt; method of the collections returned by all of this class's &quot;collection view methods&quot; are</source>
          <target state="translated">이 클래스의 모든 &quot;컬렉션 뷰 메소드&quot;에 의해 리턴 된 콜렉션 의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec72967e40c5a796ec5761ebb8f998c720cf475e" translate="yes" xml:space="preserve">
          <source>The iterators returned by the &lt;code&gt;iterator&lt;/code&gt; method of the collections returned by all of this class's &quot;collection view methods&quot; are &lt;em&gt;fail-fast&lt;/em&gt;: if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own &lt;code&gt;remove&lt;/code&gt; method, the iterator will throw a &lt;a href=&quot;concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumerations returned by Hashtable's keys and elements methods are &lt;em&gt;not&lt;/em&gt; fail-fast.</source>
          <target state="translated">이 클래스의 모든 &quot;컬렉션 뷰 메소드&quot;에 의해 리턴 된 콜렉션 의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 는 &lt;em&gt;실패가 빠릅니다&lt;/em&gt; . 이터레이터가 작성된 후에 언제라도 Hashtable이 구조적으로 수정 된 경우 (반복자가 자체 &lt;code&gt;remove&lt;/code&gt; 제외하고) 메소드에서 반복자는 &lt;a href=&quot;concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 따라서, 동시 수정에 직면하여, 반복자는 미래에 결정되지 않은 시간에 임의의 비 결정적 행동을 위험에 빠뜨리기보다는 신속하고 깨끗하게 실패합니다. Hashtable의 키 및 요소 메소드가 리턴 한 열거는 실패 &lt;em&gt;하지&lt;/em&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8e4d6a942fbd556ea4a1ce02973c09959dfe624" translate="yes" xml:space="preserve">
          <source>The iterators returned by the &lt;code&gt;iterator&lt;/code&gt; method of the collections returned by all of this class's &quot;collection view methods&quot; are &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own &lt;code&gt;remove&lt;/code&gt; method, the iterator will throw a &lt;a href=&quot;concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</source>
          <target state="translated">이 클래스의 모든 &quot;컬렉션 뷰 메소드&quot;에 의해 리턴 된 콜렉션 의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 는 &lt;em&gt;실패가 빠릅니다&lt;/em&gt; . 반복자가 작성된 후 &lt;code&gt;remove&lt;/code&gt; 제외하고 어떤 식 으로든 반복자가 작성된 후 언제라도 맵이 구조적으로 수정 된 경우 메소드에서 반복자는 &lt;a href=&quot;concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 따라서, 동시 수정에 직면하여, 반복자는 미래에 결정되지 않은 시간에 임의의 비 결정적 행동을 위험에 빠뜨리기보다는 신속하고 깨끗하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cccc07ae6435dcf4ba8a8450330120f750cedaed" translate="yes" xml:space="preserve">
          <source>The iterators returned by the &lt;code&gt;iterator&lt;/code&gt; method of the collections returned by all of this class's collection view methods are &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own &lt;code&gt;remove&lt;/code&gt; method, the iterator will throw a &lt;a href=&quot;concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션 의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 는 &lt;em&gt;실패가 빠릅니다&lt;/em&gt; . 반복자가 작성된 후 언제라도 (반복자가 자체 &lt;code&gt;remove&lt;/code&gt; 메소드를 통해) 맵이 구조적으로 수정 된 경우 , 반복자는 &lt;a href=&quot;concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 따라서, 동시 수정에 직면하여, 반복자는 미래에 결정되지 않은 시간에 임의의 비 결정적 행동을 위험에 빠뜨리기보다는 신속하고 깨끗하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8c30ea8ce4044e97226c1fcafa002e966fc4f237" translate="yes" xml:space="preserve">
          <source>The iterators returned by this class's &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;listIterator&lt;/code&gt; methods are</source>
          <target state="translated">이 클래스의 &lt;code&gt;iterator&lt;/code&gt; 와 &lt;code&gt;listIterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b599f5e9e9a7e23378ba3619eaae05e0afe1eb2" translate="yes" xml:space="preserve">
          <source>The iterators returned by this class's &lt;code&gt;iterator&lt;/code&gt; method are</source>
          <target state="translated">이 클래스의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e2ec0ba428f721ed670c5e29b21fdd61f4f2917" translate="yes" xml:space="preserve">
          <source>The iterators returned by this class's &lt;code&gt;iterator&lt;/code&gt; method are &lt;em&gt;fail-fast&lt;/em&gt;: if the set is modified at any time after the iterator is created, in any way except through the iterator's own &lt;code&gt;remove&lt;/code&gt; method, the iterator will throw a &lt;a href=&quot;concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</source>
          <target state="translated">이 클래스의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 이터레이터 는 &lt;em&gt;실패가 빠릅니다&lt;/em&gt; . 이터레이터가 작성된 후 언제라도 세트가 수정되면 (이터레이터 자체의 &lt;code&gt;remove&lt;/code&gt; 메소드를 제외하고 ), 이터레이터는 &lt;a href=&quot;concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 따라서, 동시 수정에 직면하여, 반복자는 미래에 결정되지 않은 시간에 임의의 비 결정적 행동을 위험에 빠뜨리기보다는 신속하고 깨끗하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7057c3b7f819f2cd324cffa3c20a81381e435781" translate="yes" xml:space="preserve">
          <source>The java.lang.management API is thread-safe.</source>
          <target state="translated">java.lang.management API는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="e7c83bed6a4c21ec225e1e00cad4e5dd333ca4f4" translate="yes" xml:space="preserve">
          <source>The java.net package can be roughly divided in two sections:</source>
          <target state="translated">java.net 패키지는 크게 두 섹션으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c2bad11a3cf57b9ee11fb20fc537e2355f9273" translate="yes" xml:space="preserve">
          <source>The java.nio.file package defines classes to access files and file systems. The API to access file and file system attributes is defined in the &lt;a href=&quot;attribute/package-summary&quot;&gt;&lt;code&gt;java.nio.file.attribute&lt;/code&gt;&lt;/a&gt; package. The &lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.nio.file.spi&lt;/code&gt;&lt;/a&gt; package is used by service provider implementors wishing to extend the platform default provider, or to construct other provider implementations.</source>
          <target state="translated">java.nio.file 패키지는 파일 및 파일 시스템에 액세스하기위한 클래스를 정의합니다. 파일 및 파일 시스템 속성에 액세스하기위한 API는 &lt;a href=&quot;attribute/package-summary&quot;&gt; &lt;code&gt;java.nio.file.attribute&lt;/code&gt; &lt;/a&gt; 패키지에 정의되어 있습니다. &lt;a href=&quot;spi/package-summary&quot;&gt; &lt;code&gt;java.nio.file.spi&lt;/code&gt; 의&lt;/a&gt; 패키지는 플랫폼의 디폴트의 프로 바이더를 확장하기 위해, 또는 다른 프로 바이더 구현을 구축하고자하는 서비스 제공 업체 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99d0b7979f480d0de703c57bc073a94c2aeed640" translate="yes" xml:space="preserve">
          <source>The javax.print.attribute package includes &lt;a href=&quot;hashattributeset&quot;&gt;HashAttributeSet&lt;/a&gt; as a concrete implementation of the attribute set interface. &lt;code&gt;HashAttributeSet&lt;/code&gt; provides an attribute set based on a hash map. You can use this implementation or provide your own implementation of interface &lt;code&gt;AttributeSet&lt;/code&gt;.</source>
          <target state="translated">javax.print.attribute 패키지에는 &lt;a href=&quot;hashattributeset&quot;&gt;HashAttributeSet&lt;/a&gt; 가 속성 세트 인터페이스의 구체적 구현으로 포함 되어 있습니다. &lt;code&gt;HashAttributeSet&lt;/code&gt; 은 해시 맵을 기반으로 속성 세트를 제공합니다. 이 구현을 사용하거나 고유 한 &lt;code&gt;AttributeSet&lt;/code&gt; 인터페이스 구현을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b636fb4d8f71bf41576b4222e32f43072da2d49" translate="yes" xml:space="preserve">
          <source>The job completed successfully. This value should be supported.</source>
          <target state="translated">작업이 성공적으로 완료되었습니다. 이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0fd4acc47470905777d0757b6122b704c219c78d" translate="yes" xml:space="preserve">
          <source>The job completed with errors (and possibly warnings too). This value should be supported if the implementation detects errors.</source>
          <target state="translated">작업이 오류와 함께 완료되었습니다 (경고도 가능). 구현이 오류를 감지하면이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8272d85dfb27f8fd7635d41c55d941a998fa4421" translate="yes" xml:space="preserve">
          <source>The job completed with warnings. This value should be supported if the implementation detects warnings.</source>
          <target state="translated">작업이 경고와 함께 완료되었습니다. 구현이 경고를 감지하면이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1318a856b10c21c5a8306845084662ae891af882" translate="yes" xml:space="preserve">
          <source>The job has been aborted by the system (usually while the job was in the PROCESSING or PROCESSING_STOPPED state), the printer has completed aborting the job, and all job status attributes have reached their final values for the job. While the printer is aborting the job, the job remains in its current state, but the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute should contain the PROCESSING_TO_STOP_POINT and ABORTED_BY_SYSTEM values. When the job moves to the ABORTED state, the PROCESSING_TO_STOP_POINT value, if present, must be removed, but the ABORTED_BY_SYSTEM value, if present, must remain.</source>
          <target state="translated">시스템에서 작업이 중단되었습니다 (일반적으로 작업이 PROCESSING 또는 PROCESSING_STOPPED 상태 인 동안). 프린터가 작업 중단을 완료했으며 모든 작업 상태 속성이 작업의 최종 값에 도달했습니다. 프린터가 작업을 중단하는 동안 작업은 현재 상태로 유지되지만 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에는 PROCESSING_TO_STOP_POINT 및 ABORTED_BY_SYSTEM 값이 포함되어야합니다. 작업이 ABORTED 상태로 이동할 때 PROCESSING_TO_STOP_POINT 값 (있는 경우)을 제거해야하지만 ABORTED_BY_SYSTEM 값 (있는 경우)은 남아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4332eeb1d3703dff2185e0b2a548dc30deab2693" translate="yes" xml:space="preserve">
          <source>The job has been canceled by some human agency, the printer has completed canceling the job, and all job status attributes have reached their final values for the job. While the printer is canceling the job, the job remains in its current state, but the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute should contain the PROCESSING_TO_STOP_POINT value and one of the CANCELED_BY_USER, CANCELED_BY_OPERATOR, or CANCELED_AT_DEVICE values. When the job moves to the CANCELED state, the PROCESSING_TO_STOP_POINT value, if present, must be removed, but the CANCELED_BY_</source>
          <target state="translated">일부 휴먼 에이전시에 의해 작업이 취소되었고 프린터가 작업 취소를 완료했으며 모든 작업 상태 속성이 작업의 최종 값에 도달했습니다. 프린터가 작업을 취소하는 동안 작업은 현재 상태로 유지되지만 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에는 PROCESSING_TO_STOP_POINT 값과 CANCELED_BY_USER, CANCELED_BY_OPERATOR 또는 CANCELED_AT_DEVICE 값 중 하나가 포함되어야합니다. 작업이 CANCELED 상태로 이동하면 PROCESSING_TO_STOP_POINT 값 (있는 경우)을 제거해야하지만 CANCELED_BY_</target>
        </trans-unit>
        <trans-unit id="a653104c3b056ccc18c59053c73e2cb5305a3165" translate="yes" xml:space="preserve">
          <source>The job has been forwarded to a device or print system that is unable to send back status. The printer sets the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; attribute to COMPLETED and adds the QUEUED_IN_DEVICE reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute to indicate that the printer has no additional information about the job and never will have any better information.</source>
          <target state="translated">작업을 상태를 되돌릴 수없는 장치 또는 인쇄 시스템으로 전달했습니다. 프린터는 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 속성을 COMPLETED로 설정하고 QUEUED_IN_DEVICE 이유를 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하여 프린터에 해당 작업에 대한 추가 정보가없고 더 이상 더 나은 정보가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="266c985b90e5a872533d16a586b8f9e841a46189" translate="yes" xml:space="preserve">
          <source>The job has completed successfully or with warnings or errors after processing, all of the job media sheets have been successfully stacked in the appropriate output bin(s), and all job status attributes have reached their final values for the job. The job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute should contain one of these values: COMPLETED_SUCCESSFULLY, COMPLETED_WITH_WARNINGS, or COMPLETED_WITH_ERRORS.</source>
          <target state="translated">작업이 완료된 후 또는 처리 후 경고 또는 오류와 함께 완료되었으며 모든 작업 매체 시트가 해당 출력 용지함에 성공적으로 쌓였으며 모든 작업 상태 속성이 작업의 최종 값에 도달했습니다. 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성은 COMPLETED_SUCCESSFULLY, COMPLETED_WITH_WARNINGS 또는 COMPLETED_WITH_ERRORS 값 중 하나를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d9059818004d12f90da07d03f90fef85b39741b" translate="yes" xml:space="preserve">
          <source>The job has stopped while processing for any number of reasons and will return to the PROCESSING state as soon as the reasons are no longer present.</source>
          <target state="translated">여러 가지 이유로 처리하는 동안 작업이 중지되었으며 이유가 더 이상 존재하지 않는 즉시 처리 중 상태로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="675475d1527f18e49351cb37e1cfcf5fde5e8631" translate="yes" xml:space="preserve">
          <source>The job is a candidate to start processing, but is not yet processing.</source>
          <target state="translated">작업이 처리를 시작할 후보이지만 아직 처리되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="94fbbfda8878e9c8767ac15a0f96595971bbe119" translate="yes" xml:space="preserve">
          <source>The job is in the PENDING_HELD, PENDING, or PROCESSING state, but more specifically, the printer has completed enough processing of the document to be able to start marking and the job is waiting for the marker. Systems that require human intervention to release jobs put the job into the PENDING_HELD job state. Systems that automatically select a job to use the marker put the job into the PENDING job state or keep the job in the PROCESSING job state while waiting for the marker, depending on implementation. All implementations put the job into (or back into) the PROCESSING state when marking does begin.</source>
          <target state="translated">작업이 PENDING_HELD, PENDING 또는 PROCESSING 상태에 있지만,보다 구체적으로, 프린터가 문서 처리를 완료하여 표시를 시작할 수 있고 작업이 마커를 기다리고 있습니다. 작업을 해제하기 위해 사람의 개입이 필요한 시스템은 작업을 PENDING_HELD 작업 상태로 만듭니다. 마커를 사용할 작업을 자동으로 선택하는 시스템은 구현에 따라 마커를 기다리는 동안 작업을 보류 작업 상태로 만들거나 작업을 처리 중 작업 상태로 유지합니다. 모든 구현은 표시가 시작될 때 작업을 처리 중 상태로 (또는 다시) 처리 상태로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="440add9f3c70b123e291ba209d9d13c202aebf8a" translate="yes" xml:space="preserve">
          <source>The job is in the PROCESSING state, but more specifically, the printer has queued the document data.</source>
          <target state="translated">작업이 처리 중 상태에 있지만보다 구체적으로 프린터가 문서 데이터를 대기했습니다.</target>
        </trans-unit>
        <trans-unit id="6550860dc3bbe7f26a73280ffe7ded2c79054235" translate="yes" xml:space="preserve">
          <source>The job is in the PROCESSING state, but more specifically, the printer ia interpreting the document data.</source>
          <target state="translated">작업이 처리 중 상태에 있지만보다 구체적으로 프린터는 문서 데이터를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="50339846786a673ce932982a8475461929680e1d" translate="yes" xml:space="preserve">
          <source>The job is in the PROCESSING state, but more specifically, the printer is interpreting document data and producing another electronic representation.</source>
          <target state="translated">작업이 처리 중 상태에 있지만보다 구체적으로 프린터는 문서 데이터를 해석하고 다른 전자 표현을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7c883467e1f58bb632ab1fe6de3c39731be7c1e7" translate="yes" xml:space="preserve">
          <source>The job is not a candidate for processing for any number of reasons but will return to the PENDING state as soon as the reasons are no longer present. The job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute must indicate why the job is no longer a candidate for processing.</source>
          <target state="translated">작업은 여러 가지 이유로 처리 후보가 아니지만 더 이상 존재하지 않는 즉시 보류 상태로 돌아갑니다. 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성은 작업이 더 이상 처리 후보가 아닌 이유를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="c50316af496d257de7881101a659e9cde7e0ec16" translate="yes" xml:space="preserve">
          <source>The job is not necessarily printed yet, but the data has been transferred successfully from the client to the print service. The client may free data resources.</source>
          <target state="translated">작업이 아직 인쇄 될 필요는 없지만 데이터가 클라이언트에서 인쇄 서비스로 성공적으로 전송되었습니다. 클라이언트는 데이터 리소스를 비울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="209216b743606ba4c7f7175fec73f11c99e87d88" translate="yes" xml:space="preserve">
          <source>The job is processing. One or more of the following activities is occurring:</source>
          <target state="translated">작업이 처리 중입니다. 다음 활동 중 하나 이상이 발생하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a0dd57e931629de301fcb48e865636ac06175c" translate="yes" xml:space="preserve">
          <source>The job is using, or is attempting to use, one or more hardware devices that are interpreting a PDL, making marks on a medium, and/or performing finishing, such as stapling, etc.</source>
          <target state="translated">작업이 PDL을 해석하고 매체에 표시를하거나 스테이플 링과 같은 마무리 작업을 수행하는 하나 이상의 하드웨어 장치를 사용 중이거나 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cbbe4328ec52eb0099830e578ba82c98df184ae4" translate="yes" xml:space="preserve">
          <source>The job is using, or is attempting to use, one or more purely software processes that are analyzing, creating, or interpreting a PDL, etc.</source>
          <target state="translated">작업이 PDL 등을 분석, 작성 또는 해석하는 하나 이상의 순전히 소프트웨어 프로세스를 사용 중이거나 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4f96406038b892668822c1209d18a7df1c7acab9" translate="yes" xml:space="preserve">
          <source>The job must be printed exactly as specified. or else rejected.</source>
          <target state="translated">작업은 지정된대로 정확하게 인쇄해야합니다. 그렇지 않으면 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8c62716a47758e70f54b73e39fca959c16d48b" translate="yes" xml:space="preserve">
          <source>The job state is unknown.</source>
          <target state="translated">작업 상태를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3af2aeb06b03ea668e154919c750fa9342e5cced" translate="yes" xml:space="preserve">
          <source>The job was aborted by the system because the document data's document format (doc flavor) is not among those supported by the printer. If the client specifies a doc flavor with a MIME type of &lt;code&gt;&quot;application/octet-stream&quot;&lt;/code&gt;, the printer may abort the job if the printer cannot determine the document data's actual format through auto-sensing (even if the printer supports the document format if specified explicitly). This value must be supported, since a doc flavor is required to be specified for each doc.</source>
          <target state="translated">문서 데이터의 문서 형식 (doc 플레이버)이 프린터가 지원하는 형식이 아니기 때문에 시스템에서 작업이 중단되었습니다. 클라이언트가 MIME 유형의 &lt;code&gt;&quot;application/octet-stream&quot;&lt;/code&gt; 으로 문서 특성을 지정 하면 프린터가 자동 감지를 통해 문서 데이터의 실제 형식을 판별 할 수없는 경우 (프린터가 문서 형식을 지원하는 경우에도) 프린터가 작업을 중단 할 수 있습니다 명시 적으로 지정). 각 doc마다 doc 플레이버를 지정해야하므로이 값을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="64678937e2569caf310fb1b6b932bfb85891b875" translate="yes" xml:space="preserve">
          <source>The job was aborted by the system because the printer determined while attempting to decompress the document's data that the compression is actually not among those supported by the printer. This value must be supported, since &lt;a href=&quot;compression&quot;&gt;&lt;code&gt;Compression&lt;/code&gt;&lt;/a&gt; is a required doc description attribute.</source>
          <target state="translated">프린터가 문서 데이터를 압축 해제하려고 시도하는 동안 실제로 압축이 프린터에서 지원하는 데이터 중 하나가 아니라고 판별했기 때문에 시스템에서 작업이 중단되었습니다. &lt;a href=&quot;compression&quot;&gt; &lt;code&gt;Compression&lt;/code&gt; &lt;/a&gt; 은 필수 문서 설명 속성이므로이 값이 지원되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c9651e27388cf9a31a3794779e922572b6356320" translate="yes" xml:space="preserve">
          <source>The job was aborted by the system because the printer encountered an error in the document data while decompressing it. If the printer posts this reason, the document data has already passed any tests that would have led to the UNSUPPORTED_COMPRESSION job state reason.</source>
          <target state="translated">압축을 풀 때 문서 데이터에 프린터 오류가 발생하여 시스템에서 작업을 중단했습니다. 프린터가이 이유를 게시하면 문서 데이터가 이미 UNSUPPORTED_COMPRESSION 작업 상태 이유로 이어진 모든 테스트를 통과 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a1074380020f59f8ea4577a52c011d7142eb05b" translate="yes" xml:space="preserve">
          <source>The job was aborted by the system because the printer encountered an error in the document data while processing it. If the printer posts this reason, the document data has already passed any tests that would have led to the UNSUPPORTED_DOCUMENT_FORMAT job state reason.</source>
          <target state="translated">프린터가 문서 데이터를 처리하는 중에 오류가 발생하여 시스템에서 작업을 중단했습니다. 프린터가이 이유를 게시하면 문서 데이터가 이미 UNSUPPORTED_DOCUMENT_FORMAT 작업 상태 이유로 이어진 모든 테스트를 통과 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c81f6d0b7d6876f860772ffa689ed85b796bc1f" translate="yes" xml:space="preserve">
          <source>The job was aborted by the system. Either the job (1) is in the process of being aborted, (2) has been aborted by the system and placed in the ABORTED state, or (3) has been aborted by the system and placed in the PENDING_HELD state, so that a user or operator can manually try the job again. This value should be supported.</source>
          <target state="translated">시스템에 의해 작업이 중단되었습니다. 작업 (1)이 중단되는 중이거나, (2) 시스템에 의해 중단되고 ABORTED 상태에 놓이거나, (3) 시스템에 의해 중단되고 PENDING_HELD 상태에 있습니다. 사용자 또는 운영자는 수동으로 작업을 다시 시도 할 수 있습니다. 이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bf7d9b5fa01bc8bff3bfee2e8a72f12d197056b" translate="yes" xml:space="preserve">
          <source>The job was canceled by an unidentified local user, i.e., a user at a console at the device. This value should be supported if the implementation supports canceling jobs at the console.</source>
          <target state="translated">식별되지 않은 로컬 사용자, 즉 장치의 콘솔에있는 사용자가 작업을 취소했습니다. 구현이 콘솔에서 작업 취소를 지원하는 경우이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3cc153a43dcc333ffda8997278b8d3b1822d0927" translate="yes" xml:space="preserve">
          <source>The job was canceled by the &lt;a href=&quot;../printservice&quot;&gt;&lt;code&gt;PrintService&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../printservice&quot;&gt; &lt;code&gt;PrintService&lt;/code&gt; 에&lt;/a&gt; 의해 작업이 취소되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eede175a41da055cf9fbe7c9bea273be2babd32b" translate="yes" xml:space="preserve">
          <source>The job was canceled by the operator, i.e., by a user who has been authenticated as having operator privileges (whether local or remote). If the security policy is to allow anyone to cancel anyone's job, then this value may be used when the job is canceled by someone other than the owner of the job. For such a security policy, in effect, everyone is an operator as far as canceling jobs is concerned. This value should be supported if the implementation permits canceling by someone other than the owner of the job.</source>
          <target state="translated">운영자, 즉 운영자 권한이있는 사용자 (로컬 또는 원격)에 의해 작업이 취소되었습니다. 보안 정책이 누군가가 다른 사람의 작업을 취소하도록 허용하는 경우이 값은 작업 소유자 이외의 사람이 작업을 취소 할 때 사용될 수 있습니다. 이러한 보안 정책의 경우 사실상 작업 취소와 관련된 모든 사람이 운영자입니다. 구현이 작업 소유자 이외의 사람이 취소를 허용하는 경우이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e77770a6bf43cb0d83acec3fbfc99bccb18adceb" translate="yes" xml:space="preserve">
          <source>The job was canceled by the owner of the job, i.e., by a user whose authenticated identity is the same as the value of the originating user that created the Print Job, or by some other authorized end-user, such as a member of the job owner's security group. This value should be supported.</source>
          <target state="translated">작업 소유자, 즉 인증 된 ID가 인쇄 작업을 생성 한 원래 사용자의 값과 동일한 사용자 또는 인증 된 다른 최종 사용자 (예 : 작업 소유자의 보안 그룹. 이 값이 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a608d3651752def364a16735ed653b3688b7fab7" translate="yes" xml:space="preserve">
          <source>The job was not completely submitted for some unforeseen reason. Possibilities include (1) the printer has crashed before the job was fully submitted by the client, (2) the printer or the document transfer method has crashed in some non-recoverable way before the document data was entirely transferred to the printer, (3) the client crashed before the job was fully submitted.</source>
          <target state="translated">예상치 못한 이유로 작업이 완전히 제출되지 않았습니다. (1) 클라이언트가 작업을 완전히 제출하기 전에 프린터가 충돌했거나 (2) 문서 데이터가 프린터로 완전히 전송되기 전에 프린터 또는 문서 전송 방법이 복구 할 수없는 방식으로 충돌 한 경우 (3) ) 작업이 완전히 제출되기 전에 클라이언트가 충돌했습니다.</target>
        </trans-unit>
        <trans-unit id="e3b5dbd8418dde3945a7a407762a21b4f98ee6fc" translate="yes" xml:space="preserve">
          <source>The job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute may indicate why the job has stopped processing. For example, if the output device is stopped, the PRINTER_STOPPED value may be included in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성은 작업 처리가 중지 된 이유를 나타낼 수 있습니다. 예를 들어, 출력 장치가 중지되면 PRINTER_STOPPED 값이 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afeba22c76bd0a4c4accca690f5b24b6151023b3" translate="yes" xml:space="preserve">
          <source>The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;. The classes &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt; are streams over objects and the primitive &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; types. Streams differ from collections in several ways:</source>
          <target state="translated">이 패키지에 도입 된 주요 추상화는 &lt;em&gt;stream&lt;/em&gt; 입니다. &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; &lt;/a&gt; 클래스 는 객체와 기본 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 유형의 스트림 입니다. 스트림은 여러 가지면에서 컬렉션과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9a84e5030e8e2a0fb9cc31fad2393fb5bb07bb25" translate="yes" xml:space="preserve">
          <source>The key assumptions are that the class has a nullary constructor and that its state is accurately represented by matching pairs of &quot;setter&quot; and &quot;getter&quot; methods in the order they are returned by the Introspector. In addition to providing code-free persistence for JavaBeans, the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; provides a convenient means to effect persistent storage for classes that have a constructor that, while not nullary, simply requires some property values as arguments.</source>
          <target state="translated">주요 가정은 클래스에 nullary 생성자가 있고 해당 상태가 Introspector에 의해 반환되는 순서대로 &quot;setter&quot;및 &quot;getter&quot;메서드 쌍을 일치시켜 정확하게 표현된다는 것입니다. JavaBeans에 대한 코드없는 지속성을 제공하는 것 외에도 &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; 는 널 (null)은 아니지만 단순히 일부 특성 값을 인수로 요구하는 생성자가있는 클래스에 대해 지속적 저장에 영향을주는 편리한 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7b01a7825dcb6f5ba043067697b1d8be70e427a1" translate="yes" xml:space="preserve">
          <source>The key contains all of the characters in the line starting with the first non-white space character and up to, but not including, the first unescaped &lt;code&gt;'='&lt;/code&gt;, &lt;code&gt;':'&lt;/code&gt;, or white space character other than a line terminator. All of these key termination characters may be included in the key by escaping them with a preceding backslash character; for example,</source>
          <target state="translated">이 키에는 공백이 아닌 첫 번째 공백 문자로 시작하고 이스케이프 처리되지 않은 첫 번째 &lt;code&gt;'='&lt;/code&gt; , &lt;code&gt;':'&lt;/code&gt; 또는 행 종결자가 아닌 공백 문자를 포함하지 않는 행의 모든 ​​문자가 포함됩니다. 이 키 종료 문자는 모두 앞의 백 슬래시 문자로 이스케이프하여 키에 포함될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="10925f9bd3a7bf79574e77d146d7ce5cafee6d2d" translate="yes" xml:space="preserve">
          <source>The key elements of this package include:</source>
          <target state="translated">이 패키지의 핵심 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9a2b7616c25d87b7cce2eb0034e5fe8882713d0" translate="yes" xml:space="preserve">
          <source>The key for Unicode locale extension ('u').</source>
          <target state="translated">유니 코드 로캘 확장 ( 'u')의 키입니다.</target>
        </trans-unit>
        <trans-unit id="8428fe01972833a14a72389b516a924f19614bf1" translate="yes" xml:space="preserve">
          <source>The key for the private use extension ('x').</source>
          <target state="translated">개인용 확장 프로그램 ( 'x')의 키입니다.</target>
        </trans-unit>
        <trans-unit id="39adb11f6504601433950670cbefd81cef9c88e0" translate="yes" xml:space="preserve">
          <source>The key is &lt;code&gt;&quot;fruits&quot;&lt;/code&gt; and the associated element is:</source>
          <target state="translated">핵심은 &lt;code&gt;&quot;fruits&quot;&lt;/code&gt; 이며 관련 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8129dd58b1558046a43f513a6782825b85e25fcc" translate="yes" xml:space="preserve">
          <source>The key of a character is an integer composed of primary order(short), secondary order(byte), and tertiary order(byte). Java strictly defines the size and signedness of its primitive data types. Therefore, the static functions &lt;code&gt;primaryOrder&lt;/code&gt;, &lt;code&gt;secondaryOrder&lt;/code&gt;, and &lt;code&gt;tertiaryOrder&lt;/code&gt; return &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt; respectively to ensure the correctness of the key value.</source>
          <target state="translated">문자의 키는 1 차 순서 (short), 2 차 순서 (byte) 및 3 차 순서 (byte)로 구성된 정수입니다. Java는 기본 데이터 유형의 크기와 서명을 엄격하게 정의합니다. 따라서 정적 함수 &lt;code&gt;primaryOrder&lt;/code&gt; , &lt;code&gt;secondaryOrder&lt;/code&gt; 및 &lt;code&gt;tertiaryOrder&lt;/code&gt; 는 키 값의 정확성을 보장하기 위해 각각 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; 및 &lt;code&gt;short&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9f985888e1c35d4435d90834a189099e0d2cd718" translate="yes" xml:space="preserve">
          <source>The key of the preference that was changed.</source>
          <target state="translated">변경된 환경 설정의 키입니다.</target>
        </trans-unit>
        <trans-unit id="6e8fcf42cfa361807a43d2b30af7d9cda84c3efe" translate="yes" xml:space="preserve">
          <source>The key operations supported by this class are those of</source>
          <target state="translated">이 클래스에서 지원하는 주요 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3387fc9f2a2285c3b881b40c90c411fdd5064150" translate="yes" xml:space="preserve">
          <source>The key property list string. This string is independent of whether the ObjectName is a pattern.</source>
          <target state="translated">키 특성 목록 문자열 이 문자열은 ObjectName이 패턴인지 여부와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="591c5debdb55c54ccf4211c0d46262a7acb20492" translate="yes" xml:space="preserve">
          <source>The key returned when this channel was last registered with the given selector, or &lt;code&gt;null&lt;/code&gt; if this channel is not currently registered with that selector</source>
          <target state="translated">이 셀렉터가 지정된 셀렉터에 마지막으로 등록되었을 때에 리턴 된 키. 이 채널이 현재 그 셀렉터에 등록되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df978032106f5a48ada8ce642e290c157b95524" translate="yes" xml:space="preserve">
          <source>The key set is &lt;a href=&quot;#ksc&quot;&gt;not thread-safe&lt;/a&gt;.</source>
          <target state="translated">키 세트는 &lt;a href=&quot;#ksc&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57ef8dd9009d16c64f42c6500fb027397a1c181c" translate="yes" xml:space="preserve">
          <source>The key set is not directly modifiable. A key is removed only after it has been cancelled and its channel has been deregistered. Any attempt to modify the key set will cause an &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">키 세트는 직접 수정할 수 없습니다. 키는 취소되고 채널이 등록 해제 된 후에 만 ​​제거됩니다. 키 세트를 수정하려고하면 &lt;a href=&quot;../../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f370fcfd44322aa2b8d1091b0a099098abd9ad6" translate="yes" xml:space="preserve">
          <source>The keys involved in establishing a shared secret are created by one of the key generators (&lt;code&gt;KeyPairGenerator&lt;/code&gt; or &lt;code&gt;KeyGenerator&lt;/code&gt;), a &lt;code&gt;KeyFactory&lt;/code&gt;, or as a result from an intermediate phase of the key agreement protocol (&lt;a href=&quot;keyagreementspi#engineDoPhase-java.security.Key-boolean-&quot;&gt;&lt;code&gt;engineDoPhase&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">공유 비밀을 설정하는 데 관련된 키는 키 생성기 ( &lt;code&gt;KeyPairGenerator&lt;/code&gt; 또는 &lt;code&gt;KeyGenerator&lt;/code&gt; ) 중 하나 , &lt;code&gt;KeyFactory&lt;/code&gt; 또는 키 계약 프로토콜 ( &lt;a href=&quot;keyagreementspi#engineDoPhase-java.security.Key-boolean-&quot;&gt; &lt;code&gt;engineDoPhase&lt;/code&gt; &lt;/a&gt; ) 의 중간 단계에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="723f16f5244db1190e45ab85ded24007968e816f" translate="yes" xml:space="preserve">
          <source>The keys involved in establishing a shared secret are created by one of the key generators (&lt;code&gt;KeyPairGenerator&lt;/code&gt; or &lt;code&gt;KeyGenerator&lt;/code&gt;), a &lt;code&gt;KeyFactory&lt;/code&gt;, or as a result from an intermediate phase of the key agreement protocol.</source>
          <target state="translated">공유 비밀을 설정하는 데 관련된 키는 키 생성기 ( &lt;code&gt;KeyPairGenerator&lt;/code&gt; 또는 &lt;code&gt;KeyGenerator&lt;/code&gt; ) 중 하나 , &lt;code&gt;KeyFactory&lt;/code&gt; 또는 키 계약 프로토콜의 중간 단계에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="93449d8bc735c86f66b7af66ec3fc6632ea6e0e9" translate="yes" xml:space="preserve">
          <source>The keystore location.</source>
          <target state="translated">키 저장소 위치</target>
        </trans-unit>
        <trans-unit id="71b0abd8de97d396da90382775d49f0501bc9b82" translate="yes" xml:space="preserve">
          <source>The keystore type.</source>
          <target state="translated">키 스토어 타입.</target>
        </trans-unit>
        <trans-unit id="842a8022c0b70f37cfdb00d1ecc419e098528a20" translate="yes" xml:space="preserve">
          <source>The keytab file format is described at &lt;a href=&quot;http://www.ioplex.com/utilities/keytab.txt&quot;&gt; http://www.ioplex.com/utilities/keytab.txt&lt;/a&gt;.</source>
          <target state="translated">키탭 파일 형식은 &lt;a href=&quot;http://www.ioplex.com/utilities/keytab.txt&quot;&gt;http://www.ioplex.com/utilities/keytab.txt에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06cb2d0e49b96e83b7706a492fb99378d956821" translate="yes" xml:space="preserve">
          <source>The keywords are mapped to a BCP 47 extension value using the extension key 'u' (&lt;a href=&quot;locale#UNICODE_LOCALE_EXTENSION&quot;&gt;&lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt;&lt;/a&gt;). The above example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.code</source>
          <target state="translated">확장 키 'u'( &lt;a href=&quot;locale#UNICODE_LOCALE_EXTENSION&quot;&gt; &lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt; &lt;/a&gt; )를 사용하여 키워드가 BCP 47 확장 값에 맵핑됩니다 . 위의 예제 &quot;nu-thai&quot;는 확장자 &quot;u-nu-thai&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="3abc78cec7443be172a73f11d0ea46ef51b57125" translate="yes" xml:space="preserve">
          <source>The kind of a type mirror.</source>
          <target state="translated">타입 미러의 ​​종류.</target>
        </trans-unit>
        <trans-unit id="e71bcb16dc077322da2b88fd1337ba338c4914a1" translate="yes" xml:space="preserve">
          <source>The kind of this file object.</source>
          <target state="translated">이 파일 객체의 종류입니다.</target>
        </trans-unit>
        <trans-unit id="060ad24a2e020eedaf95c63bf56985e351899937" translate="yes" xml:space="preserve">
          <source>The language code &quot;und&quot; is mapped to language &quot;&quot;.</source>
          <target state="translated">언어 코드 &quot;und&quot;는 언어 &quot;&quot;에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eed90a84dfe6824cdfb069525f0a0cdbf5c234ed" translate="yes" xml:space="preserve">
          <source>The language code, or the empty string if none is defined.</source>
          <target state="translated">언어 코드 또는 정의되지 않은 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="098e8da937e9d6a746c9e6894744ca7720a21e02" translate="yes" xml:space="preserve">
          <source>The language codes &quot;he&quot;, &quot;yi&quot;, and &quot;id&quot; are mapped to &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot; respectively. (This is the same canonicalization that's done in Locale's constructors.)</source>
          <target state="translated">언어 코드 &quot;he&quot;, &quot;yi&quot;및 &quot;id&quot;는 각각 &quot;iw&quot;, &quot;ji&quot;및 &quot;in&quot;에 매핑됩니다. (이것은 로케일의 생성자에서 수행 된 것과 동일한 정식화입니다.)</target>
        </trans-unit>
        <trans-unit id="ab199358c4c30717fef9325e862f54f258b020c1" translate="yes" xml:space="preserve">
          <source>The large capacity input tray in the printer.</source>
          <target state="translated">프린터의 대용량 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="87a66203f240a0446e3e56749de0de7014433cb7" translate="yes" xml:space="preserve">
          <source>The largest valid &lt;code&gt;CHILD_POLICY_*&lt;/code&gt; constant, to be used for range checks.</source>
          <target state="translated">범위 점검에 사용될 가장 큰 유효한 &lt;code&gt;CHILD_POLICY_*&lt;/code&gt; 상수.</target>
        </trans-unit>
        <trans-unit id="63c95d7f54d8b200cb320258b2605a3a1ecdb740" translate="yes" xml:space="preserve">
          <source>The last access time is from the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt; when read from a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">마지막 액세스 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림에서 읽을 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 시간 소인 필드 에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="018404389cff4be23d8a44b9b108e339eccb815f" translate="yes" xml:space="preserve">
          <source>The last access time of the entry, null if not specified</source>
          <target state="translated">항목의 마지막 액세스 시간. 지정되지 않은 경우 null</target>
        </trans-unit>
        <trans-unit id="fe1aba57c57c1ac2f063c8c6fe24c263634b58f4" translate="yes" xml:space="preserve">
          <source>The last boundary before the specified offset or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the first text boundary is passed in as the offset.</source>
          <target state="translated">지정된 오프셋 이전의 마지막 경계 또는 첫 번째 텍스트 경계가 오프셋으로 전달 된 경우 &lt;code&gt;BreakIterator.DONE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3786764214c419fc8c5e1b4f929d864bbcb97cc1" translate="yes" xml:space="preserve">
          <source>The last example assumes that the extra arguments are of type &lt;code&gt;CONSTANT_String&lt;/code&gt; and &lt;code&gt;CONSTANT_Integer&lt;/code&gt;, respectively. The second-to-last example assumes that all extra arguments are of type &lt;code&gt;CONSTANT_String&lt;/code&gt;. The other examples work with all types of extra arguments.</source>
          <target state="translated">마지막 예는 추가 인수가 각각 &lt;code&gt;CONSTANT_String&lt;/code&gt; 및 &lt;code&gt;CONSTANT_Integer&lt;/code&gt; 유형이라고 가정합니다 . 마지막부터 두 번째까지의 예제는 모든 추가 인수가 &lt;code&gt;CONSTANT_String&lt;/code&gt; 유형이라고 가정합니다 . 다른 예제는 모든 유형의 추가 인수와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b90ed7ca70d3a841924037be711880b436dc3571" translate="yes" xml:space="preserve">
          <source>The last exception thrown by the Appendable or &lt;code&gt;null&lt;/code&gt; if no such exception exists.</source>
          <target state="translated">Appendable이 마지막으로 throw 한 예외 또는 해당 예외가 없으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04079ef138add28eebb8f572cbade8dbe2eced17" translate="yes" xml:space="preserve">
          <source>The last line will print &lt;code&gt;cn=Juicy\, Fruit&lt;/code&gt;.</source>
          <target state="translated">마지막 줄은 &lt;code&gt;cn=Juicy\, Fruit&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="c36ea3c145fcf0621af5506876da5c006b8fc7c5" translate="yes" xml:space="preserve">
          <source>The last line will print &lt;code&gt;cn=Juicy\, Fruit&lt;/code&gt;. The &lt;a href=&quot;rdn#unescapeValue-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;unescapeValue()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method can be used to unescape the escaped comma resulting in the original value &lt;code&gt;&quot;Juicy, Fruit&quot;&lt;/code&gt;. The &lt;a href=&quot;rdn#escapeValue-java.lang.Object-&quot;&gt;&lt;code&gt;&lt;code&gt;escapeValue()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method adds the escape back preceding the comma.</source>
          <target state="translated">마지막 줄은 &lt;code&gt;cn=Juicy\, Fruit&lt;/code&gt; 인쇄 합니다. &lt;a href=&quot;rdn#unescapeValue-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;unescapeValue()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드는 원래의 값으로 인한 도주 콤마 이스케이프를 위해 사용될 수있는 &lt;code&gt;&quot;Juicy, Fruit&quot;&lt;/code&gt; . &lt;a href=&quot;rdn#escapeValue-java.lang.Object-&quot;&gt; &lt;code&gt;&lt;code&gt;escapeValue()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드는 쉼표 앞에 이스케이프 다시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6704a2570d140aa6d4d1a0195309b7cded09294b" translate="yes" xml:space="preserve">
          <source>The last low order bit is always ignored as this corresponds to the MBZ (must be zero) bit.</source>
          <target state="translated">마지막 하위 비트는 MBZ (0이어야 함) 비트에 해당하므로 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="136ced763d4f0395ea838a91b0392e85ac9d09ec" translate="yes" xml:space="preserve">
          <source>The last modification time of the entry in milliseconds since the epoch, or -1 if not specified</source>
          <target state="translated">신기원 이후 엔트리의 마지막 수정 시간 (밀리 초) 또는 지정되지 않은 경우 -1</target>
        </trans-unit>
        <trans-unit id="d8097498df46abde4481e8c5cf7533f5f787ec54" translate="yes" xml:space="preserve">
          <source>The last modification time of the entry, null if not specified</source>
          <target state="translated">항목의 마지막 수정 시간. 지정하지 않으면 null</target>
        </trans-unit>
        <trans-unit id="3181bd7eca0b7159c1c88cf63d3760586057c6df" translate="yes" xml:space="preserve">
          <source>The last thread arrives; or</source>
          <target state="translated">마지막 실이 도착합니다. 또는</target>
        </trans-unit>
        <trans-unit id="24921a8e3a7f2cbc396820ff95cee47630697935" translate="yes" xml:space="preserve">
          <source>The last value returned by an operation may be cached in the operation's descriptor which is in the ModelMBeanOperationInfo's descriptor. The valid value will be in the 'value' field if there is one. If the 'currencyTimeLimit' field in the descriptor is:</source>
          <target state="translated">오퍼레이션에 의해 리턴 된 마지막 값은 ModelMBeanOperationInfo 디스크립터에있는 오퍼레이션 디스크립터에 캐시 될 수 있습니다. 유효한 값은 '값'필드에 있습니다 (있는 경우). 디스크립터의 'currencyTimeLimit'필드가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="0c946e02cf7bb113bde4f4cf3943bb511e4009b7" translate="yes" xml:space="preserve">
          <source>The layout of a variant 2 (Leach-Salz) UUID is as follows: The most significant long consists of the following unsigned fields:</source>
          <target state="translated">변형 2 (Leach-Salz) UUID의 레이아웃은 다음과 같습니다. 가장 중요한 long은 다음 부호없는 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7af9b55c9143f8cca06d1210ae464e4b24586bea" translate="yes" xml:space="preserve">
          <source>The leading plus/minus sign, and negative values for other units are not part of the ISO-8601 standard.</source>
          <target state="translated">다른 단위의 선행 플러스 / 마이너스 부호 및 음수 값은 ISO-8601 표준의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8afe06a23c97844adb78033caa70b9b0d3bbee8" translate="yes" xml:space="preserve">
          <source>The leading plus/minus sign, and negative values for other units are not part of the ISO-8601 standard. In addition, ISO-8601 does not permit mixing between the &lt;code&gt;PnYnMnD&lt;/code&gt; and &lt;code&gt;PnW&lt;/code&gt; formats. Any week-based input is multiplied by 7 and treated as a number of days.</source>
          <target state="translated">다른 단위의 선행 플러스 / 마이너스 부호 및 음수 값은 ISO-8601 표준의 일부가 아닙니다. 또한 ISO-8601은 &lt;code&gt;PnYnMnD&lt;/code&gt; 와 &lt;code&gt;PnW&lt;/code&gt; 형식의 혼합을 허용하지 않습니다 . 모든 주 기반 입력에 7을 곱하고 며칠로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="63cecf4a8fa95d4d0270f57a3e75af217a6a1a81" translate="yes" xml:space="preserve">
          <source>The least significant 64 bits of this UUID's 128 bit value</source>
          <target state="translated">이 UUID 128 비트 값 중 최하위 64 비트</target>
        </trans-unit>
        <trans-unit id="a83da07b2f48d8970311283f85c7e3bac23d44ea" translate="yes" xml:space="preserve">
          <source>The least significant long consists of the following unsigned fields:</source>
          <target state="translated">최하위 길이는 다음과 같은 부호없는 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="87c3957c33024c262a7af561fbc4382beb1c10cd" translate="yes" xml:space="preserve">
          <source>The length of each month is 29 or 30 days. Ordinary years have 354 days; leap years have 355 days.</source>
          <target state="translated">매월 길이는 29 일 또는 30 일입니다. 보통 354 일이 있습니다. 윤년에는 355 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddbb38752fc76e23de090a340e192731d09329a6" translate="yes" xml:space="preserve">
          <source>The length of the MIDI file in bytes.</source>
          <target state="translated">MIDI 파일의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="d2435fa816d6768395fd2a4aa385ef8e24c5ddee" translate="yes" xml:space="preserve">
          <source>The length of the array is the number of methods on the execution stack. The element at index &lt;code&gt;0&lt;/code&gt; is the class of the currently executing method, the element at index &lt;code&gt;1&lt;/code&gt; is the class of that method's caller, and so on.</source>
          <target state="translated">배열의 길이는 실행 스택의 메소드 수입니다. 인덱스 &lt;code&gt;0&lt;/code&gt; 의 요소 는 현재 실행중인 메소드 의 클래스이고 인덱스 &lt;code&gt;1&lt;/code&gt; 의 요소 는 해당 메소드의 호출자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b857f2f3bd91b155a9e3b739281c3f76ebd897e1" translate="yes" xml:space="preserve">
          <source>The length of the duration is stored using two fields - seconds and nanoseconds. The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to the length in seconds. The total duration is defined by calling this method and &lt;a href=&quot;duration#getNano--&quot;&gt;&lt;code&gt;getNano()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지속 시간의 길이는 초와 나노초의 두 필드를 사용하여 저장됩니다. 나노초 부분은 0에서 999,999,999 사이의 값으로 초 단위의 길이를 조정합니다. 총 지속 시간은이 메소드와 &lt;a href=&quot;duration#getNano--&quot;&gt; &lt;code&gt;getNano()&lt;/code&gt; &lt;/a&gt; 호출하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="799f33b236c13bbcd8f6b24c22ed60055e48b108" translate="yes" xml:space="preserve">
          <source>The length of the duration is stored using two fields - seconds and nanoseconds. The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to the length in seconds. The total duration is defined by calling this method and &lt;a href=&quot;duration#getSeconds--&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지속 시간의 길이는 초와 나노초의 두 필드를 사용하여 저장됩니다. 나노초 부분은 0에서 999,999,999 사이의 값으로 초 단위의 길이를 조정합니다. 총 지속 시간은이 메소드와 &lt;a href=&quot;duration#getSeconds--&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 호출하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="297f7fc3454a1ac9b72ec75e82b737d1c3e02d73" translate="yes" xml:space="preserve">
          <source>The length of the erroneous input, a positive integer</source>
          <target state="translated">잘못된 입력의 길이, 양의 정수</target>
        </trans-unit>
        <trans-unit id="919271a96dbead07bffe665f55582cbbbb8ef438" translate="yes" xml:space="preserve">
          <source>The length of the solar day is the standard way that humans measure time. This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds, forming a 86400 second day.</source>
          <target state="translated">태양의 하루는 인간이 시간을 측정하는 표준 방법입니다. 이것은 전통적으로 60 초 60 분의 24 시간으로 세분화되어 86400 초를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="33b014d560da82e0f5d8f763343933b2684c530a" translate="yes" xml:space="preserve">
          <source>The length of this character buffer</source>
          <target state="translated">이 문자 버퍼의 길이</target>
        </trans-unit>
        <trans-unit id="a1267c7d6b40b8c0d034f6025fd6b9fc8ca3a757" translate="yes" xml:space="preserve">
          <source>The length, in bytes, of the file denoted by this abstract pathname, or &lt;code&gt;0L&lt;/code&gt; if the file does not exist. Some operating systems may return &lt;code&gt;0L&lt;/code&gt; for pathnames denoting system-dependent entities such as devices or pipes.</source>
          <target state="translated">이 추상 경로명이 나타내는 파일의 길이 (바이트 단위) . 파일이 존재하지 않는 경우는 &lt;code&gt;0L&lt;/code&gt; 일부 운영 체제는 장치 또는 파이프와 같은 시스템 종속 엔터티를 나타내는 경로 이름에 대해 &lt;code&gt;0L&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="581d35e78b7ce49a00c13c4b7ee295fe5f34e3bd" translate="yes" xml:space="preserve">
          <source>The lengths of the 12 months of the year separated by whitespace. A numeric year property must be present for every year without any gaps. The month lengths must be between 29-32 inclusive.</source>
          <target state="translated">일년 중 12 개월 길이는 공백으로 구분됩니다. 숫자 연도 속성은 격차없이 매년 존재해야합니다. 월 길이는 29-32 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5b66e74de97e7f14be88c15b844d4047ab288d4b" translate="yes" xml:space="preserve">
          <source>The letter 'T'. Parsing is case insensitive.</source>
          <target state="translated">문자 'T'. 파싱은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc227fcf89d7cc814e4981de81e0c19a58943c38" translate="yes" xml:space="preserve">
          <source>The letter 'W'. Parsing is case insensitive.</source>
          <target state="translated">문자 'W'. 파싱은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d77c8cf193187a7a8a4df4378c110186f76ee90c" translate="yes" xml:space="preserve">
          <source>The letters A-Z in their uppercase (&lt;code&gt;'\u0041'&lt;/code&gt; through &lt;code&gt;'\u005A'&lt;/code&gt;), lowercase (&lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007A'&lt;/code&gt;), and full width variant (&lt;code&gt;'\uFF21'&lt;/code&gt; through &lt;code&gt;'\uFF3A'&lt;/code&gt; and &lt;code&gt;'\uFF41'&lt;/code&gt; through &lt;code&gt;'\uFF5A'&lt;/code&gt;) forms have numeric values from 10 through 35. This is independent of the Unicode specification, which does not assign numeric values to these &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="translated">대문자 ( &lt;code&gt;'\u0041'&lt;/code&gt; ~ &lt;code&gt;'\u005A'&lt;/code&gt; ), 소문자 ( &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007A'&lt;/code&gt; ) 및 전각 변형 ( &lt;code&gt;'\uFF21'&lt;/code&gt; ~ &lt;code&gt;'\uFF3A'&lt;/code&gt; 및 &lt;code&gt;'\uFF41'&lt;/code&gt; through &lt;code&gt;'\uFF5A'&lt;/code&gt; ) 형식은 10-35 사이의 숫자 값을 갖습니다. 이는 유니 코드 스펙과 무관하며 숫자 값을 이러한 &lt;code&gt;char&lt;/code&gt; 값에 지정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="099a2135b8e7e4f9044f572d83bbcd49c70dfd02" translate="yes" xml:space="preserve">
          <source>The levels in descending order are:</source>
          <target state="translated">내림차순의 레벨은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4ba24e69512c484f4d6ceb119bca02cab802a8d" translate="yes" xml:space="preserve">
          <source>The limit of persistent storage allocated for spooling has been reached. The printer is temporarily unable to accept more jobs. The printer will remove this reason when it is able to accept more jobs. This value should be used by a non-spooling printer that only accepts one or a small number jobs at a time or a spooling printer that has filled the spool space.</source>
          <target state="translated">스풀링에 할당 된 지속적 스토리지 한계에 도달했습니다. 프린터가 일시적으로 더 많은 작업을 수락 할 수 없습니다. 프린터는 더 많은 작업을 수락 할 수 있으면이 이유를 제거합니다. 이 값은 한 번에 하나 또는 적은 수의 작업 만 허용하는 스풀링이 아닌 프린터 또는 스풀 공간을 채운 스풀링 프린터에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="38ae39f9f342a1c60cd5cbb9ab2d4d849160241e" translate="yes" xml:space="preserve">
          <source>The limit of this buffer</source>
          <target state="translated">이 버퍼의 한계</target>
        </trans-unit>
        <trans-unit id="77c032fbbd794d07ea48f8c91991c009a7b8b837" translate="yes" xml:space="preserve">
          <source>The line number begins at &lt;code&gt;0&lt;/code&gt;, and is incremented by &lt;code&gt;1&lt;/code&gt; when a &lt;code&gt;read&lt;/code&gt; returns a newline character.</source>
          <target state="translated">행 번호에서 시작 &lt;code&gt;0&lt;/code&gt; , 및 씩 증가 &lt;code&gt;1&lt;/code&gt; 때 &lt;code&gt;read&lt;/code&gt; 개행 문자를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="6d055d92518c915ab1ac205ce84b4eb5bcc880a5" translate="yes" xml:space="preserve">
          <source>The line number. Returns -1 if a line number is unavailable.</source>
          <target state="translated">줄 번호. 행 번호를 사용할 수없는 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0fbc9f6cfd3d04e440801fa393ad994718e72cd" translate="yes" xml:space="preserve">
          <source>The lines of a file can be obtained from &lt;a href=&quot;../../io/bufferedreader#lines--&quot;&gt;&lt;code&gt;BufferedReader.lines()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">파일의 라인은 &lt;a href=&quot;../../io/bufferedreader#lines--&quot;&gt; &lt;code&gt;BufferedReader.lines()&lt;/code&gt; &lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1da4ff24559b092bdd6dbfa74dfe3af5beeb0606" translate="yes" xml:space="preserve">
          <source>The list containing all the enabled attribute names.</source>
          <target state="translated">사용 가능한 모든 속성 이름이 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f6baad02fe3b9954bd6badb60ae27c47fc3bb918" translate="yes" xml:space="preserve">
          <source>The list containing all the enabled notification types.</source>
          <target state="translated">사용 가능한 모든 알림 유형이 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f3ea619d9f715deb3d2e3f1b2741f191c4bbc56c" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;Certificate&lt;/code&gt;s is an ordered &lt;code&gt;List&lt;/code&gt; of zero or more &lt;code&gt;Certificate&lt;/code&gt;s. This &lt;code&gt;List&lt;/code&gt; and all of the &lt;code&gt;Certificate&lt;/code&gt;s contained in it must be immutable.</source>
          <target state="translated">목록 &lt;code&gt;Certificate&lt;/code&gt; 들 순서입니다 &lt;code&gt;List&lt;/code&gt; 0 개 이상의 &lt;code&gt;Certificate&lt;/code&gt; 의. 이 &lt;code&gt;List&lt;/code&gt; 과 그 안에 포함 된 모든 &lt;code&gt;Certificate&lt;/code&gt; 는 변경 불가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd0934730ffafda86be98b2e11c9a6431cd700ca" translate="yes" xml:space="preserve">
          <source>The list of IDs for currently-open connections to this connector server.</source>
          <target state="translated">이 커넥터 서버에 현재 열려있는 연결의 ID 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d3edf1b8ae53c360c1c5b20e97917aa355190641" translate="yes" xml:space="preserve">
          <source>The list of attributes retrieved.</source>
          <target state="translated">검색된 속성 목록.</target>
        </trans-unit>
        <trans-unit id="a733a32deedbd729aa7b488bf3de06d8d71e5e72" translate="yes" xml:space="preserve">
          <source>The list of attributes that were set, with their new values.</source>
          <target state="translated">새로운 값으로 설정된 속성 목록.</target>
        </trans-unit>
        <trans-unit id="0fdae3bd72419d0a97c00be302983175d31ccb88" translate="yes" xml:space="preserve">
          <source>The list of children affected by this event notification.</source>
          <target state="translated">이 이벤트 알림의 영향을받는 자식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7ae61477db1267667809d3a08c8f514fa6a79474" translate="yes" xml:space="preserve">
          <source>The list of extensions.</source>
          <target state="translated">확장명 목록.</target>
        </trans-unit>
        <trans-unit id="6ebc6df8965040b3ce7dc92bd4596d6121981619" translate="yes" xml:space="preserve">
          <source>The list of mime types.</source>
          <target state="translated">MIME 유형의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2a7748aeeee58a5b52705cd02ff41d8df27062b6" translate="yes" xml:space="preserve">
          <source>The list of the retrieved attributes.</source>
          <target state="translated">검색된 속성의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="aba858810c5aa18739c636e7b18c7408ef0a29c0" translate="yes" xml:space="preserve">
          <source>The list of units completely and uniquely represents the state of the object without omissions, overlaps or duplication. The units are in order from longest duration to shortest.</source>
          <target state="translated">단위 목록은 누락, 겹침 또는 복제없이 객체의 상태를 완전하고 고유하게 나타냅니다. 단위는 가장 긴 시간부터 가장 짧은 시간 순서입니다.</target>
        </trans-unit>
        <trans-unit id="f0a31b4438d214ff5ab44fbf1e6df091597039c9" translate="yes" xml:space="preserve">
          <source>The list will be empty for fixed offset rules and for any time-zone where there has only ever been a single offset. The list will also be empty if the transition rules are unknown.</source>
          <target state="translated">고정 오프셋 규칙 및 단일 오프셋 만있는 시간대에 대해서는 목록이 비어 있습니다. 전환 규칙을 알 수없는 경우에도 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="df0c9468b72bfab4969f222df61b6ab502e1a758" translate="yes" xml:space="preserve">
          <source>The list will be empty for fixed offset rules and for any time-zone where there is no daylight saving time. The list will also be empty if the transition rules are unknown.</source>
          <target state="translated">고정 오프셋 규칙 및 일광 절약 시간 제가없는 시간대의 경우 목록이 비어 있습니다. 전환 규칙을 알 수없는 경우에도 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27844bc6af8434ed5116d0992a6ff6c763ad2302" translate="yes" xml:space="preserve">
          <source>The list-iterator is</source>
          <target state="translated">리스트 반복자는</target>
        </trans-unit>
        <trans-unit id="7f92bf7d6987c47057b3f2bdbf85f39eb676f3f9" translate="yes" xml:space="preserve">
          <source>The listener &lt;code&gt;myListener&lt;/code&gt; will only receive notifications the type of which equals/starts with &quot;my_example.my_type&quot;.</source>
          <target state="translated">리스너 &lt;code&gt;myListener&lt;/code&gt; 는 &quot;my_example.my_type&quot;과 같은 유형의 알림 만 수신합니다.</target>
        </trans-unit>
        <trans-unit id="6084d864c4b6f5b4544fc69b60315b434163b6f4" translate="yes" xml:space="preserve">
          <source>The listener ID.</source>
          <target state="translated">리스너 ID</target>
        </trans-unit>
        <trans-unit id="3ca4adf4d22463d5be377865984608d8896c3b85" translate="yes" xml:space="preserve">
          <source>The listener interface for receiving &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; 객체 를 받기위한 리스너 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="9831fa0c76b61ac6b48f7edcb579a53278a9108b" translate="yes" xml:space="preserve">
          <source>The listener interface for receiving &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; objects. A class that is interested in processing a &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; implements this interface.</source>
          <target state="translated">&lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; 객체 를 받기위한 리스너 인터페이스입니다 . &lt;code&gt;BeanContextServiceAvailableEvent&lt;/code&gt; 처리에 관심이있는 클래스는 이 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="609d94d290b2f275c653b99c1f7e5a6a92448bc7" translate="yes" xml:space="preserve">
          <source>The listener interface for receiving &lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; 객체 를 받기위한 리스너 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="5b8110e74303433769bb43009b8ee46a1e6e9536" translate="yes" xml:space="preserve">
          <source>The listener interface for receiving &lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; objects. A class that is interested in processing a &lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; implements this interface.</source>
          <target state="translated">&lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; 객체 를 받기위한 리스너 인터페이스입니다 . &lt;code&gt;BeanContextServiceRevokedEvent&lt;/code&gt; 처리에 관심이있는 클래스는 이 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e4590d176c2f3cdb63c4fefc574df69b196589b3" translate="yes" xml:space="preserve">
          <source>The listener method is executed in the same thread as this method. See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">리스너 메소드는이 메소드와 동일한 스레드에서 실행됩니다. 스레딩 문제에 대한 자세한 내용은 &lt;a href=&quot;package-summary#THREADING&quot;&gt;패키지 설명&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62e7843c514bbb78ca4f4720402ec2ddbbae0aa7" translate="yes" xml:space="preserve">
          <source>The listener object that receives notifications is the one that is registered with the given name at the time this method is called. Even if it is subsequently unregistered, it will continue to receive notifications.</source>
          <target state="translated">통지를받는 리스너 객체는이 메소드가 호출 될 때 지정된 이름으로 등록 된 리스너 객체입니다. 이후에 등록이 해제 되더라도 계속 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="58ed8ea8bc03ea144ba1b908e1725a3240f27929" translate="yes" xml:space="preserve">
          <source>The local date time and first combined to form a local date-time. The local date-time is then resolved to a single instant on the time-line. This is achieved by finding a valid offset from UTC/Greenwich for the local date-time as defined by the &lt;a href=&quot;zone/zonerules&quot;&gt;&lt;code&gt;rules&lt;/code&gt;&lt;/a&gt; of the zone ID.</source>
          <target state="translated">현지 날짜 시간과 현지 날짜-시간을 만들기 위해 처음 결합되었습니다. 그런 다음 현지 날짜-시간이 타임 라인에서 단일 인스턴트로 분석됩니다. 이것은 존 ID &lt;a href=&quot;zone/zonerules&quot;&gt; &lt;code&gt;rules&lt;/code&gt; &lt;/a&gt; 에 의해 정의 된 현지 날짜-시간에 대해 UTC / 그리니치로부터 유효한 오프셋을 찾아서 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd77d03e50afe46d82e00a8893f50de031896408" translate="yes" xml:space="preserve">
          <source>The local date-time is expressed in terms of the UTC offset.</source>
          <target state="translated">현지 날짜-시간은 UTC 오프셋으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="062cd543edcf93d28b39a205798c522e0df4cbd0" translate="yes" xml:space="preserve">
          <source>The local date-time is expressed in terms of the standard offset.</source>
          <target state="translated">현지 날짜-시간은 표준 오프셋으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="43473430726ae9afe2869644c4fa1a6cc3eb2c73" translate="yes" xml:space="preserve">
          <source>The local date-time is expressed in terms of the wall offset.</source>
          <target state="translated">현지 날짜-시간은 월 오프셋으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba325c8ca4eea5edc4128597b124ea80adfafce" translate="yes" xml:space="preserve">
          <source>The local date-time is resolved to a single instant on the time-line. This is achieved by finding a valid offset from UTC/Greenwich for the local date-time as defined by the &lt;a href=&quot;../zone/zonerules&quot;&gt;&lt;code&gt;rules&lt;/code&gt;&lt;/a&gt; of the zone ID.</source>
          <target state="translated">현지 날짜-시간은 타임 라인에서 단일 인스턴트로 해석됩니다. 이것은 존 ID &lt;a href=&quot;../zone/zonerules&quot;&gt; &lt;code&gt;rules&lt;/code&gt; &lt;/a&gt; 에 의해 정의 된 현지 날짜-시간에 대해 UTC / 그리니치로부터 유효한 오프셋을 찾아서 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc0d2dd18ffa81c5846139cec04f27fc21a2f918" translate="yes" xml:space="preserve">
          <source>The local date-time is resolved to a single instant on the time-line. This is achieved by finding a valid offset from UTC/Greenwich for the local date-time as defined by the &lt;a href=&quot;zone/zonerules&quot;&gt;&lt;code&gt;rules&lt;/code&gt;&lt;/a&gt; of the zone ID.</source>
          <target state="translated">현지 날짜-시간은 타임 라인에서 단일 인스턴트로 해석됩니다. 이것은 존 ID &lt;a href=&quot;zone/zonerules&quot;&gt; &lt;code&gt;rules&lt;/code&gt; &lt;/a&gt; 에 의해 정의 된 현지 날짜-시간에 대해 UTC / 그리니치로부터 유효한 오프셋을 찾아서 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="01c1227cbd2c58d3edc580370fa60fb57d2529eb" translate="yes" xml:space="preserve">
          <source>The local port number to which this socket is connected.</source>
          <target state="translated">이 소켓이 연결된 로컬 포트 ​​번호입니다.</target>
        </trans-unit>
        <trans-unit id="d5c20c55cb87df99a369c70cbea570fb23af8461" translate="yes" xml:space="preserve">
          <source>The local port number.</source>
          <target state="translated">로컬 포트 ​​번호</target>
        </trans-unit>
        <trans-unit id="164d4cf144a6005f646e68ccb7201e68e4df1175" translate="yes" xml:space="preserve">
          <source>The local time can be converted to an instant using the standard offset, the wall offset or UTC.</source>
          <target state="translated">현지 시간은 표준 오프셋, 월 오프셋 또는 UTC를 사용하여 순간으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930043567de1d9c36d9065d240bbac838f2c72a8" translate="yes" xml:space="preserve">
          <source>The locale 'en_US' will always be present.</source>
          <target state="translated">로케일 'en_US'는 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6b35dc1cb6dc43f6b2f67f74ddcd4a6124b64160" translate="yes" xml:space="preserve">
          <source>The locale always used is the one returned by &lt;a href=&quot;../util/locale#getDefault--&quot;&gt;&lt;code&gt;Locale.getDefault()&lt;/code&gt;&lt;/a&gt;, regardless of any previous invocations of other formatting methods on this object.</source>
          <target state="translated">사용 된 로케일은 이 객체에 대한 다른 형식화 ​​메소드의 이전 호출과 상관없이 항상 &lt;a href=&quot;../util/locale#getDefault--&quot;&gt; &lt;code&gt;Locale.getDefault()&lt;/code&gt; &lt;/a&gt; 의해 리턴되는 로케일 입니다.</target>
        </trans-unit>
        <trans-unit id="e47fa25a26b7655787b36c2d11262ab526454c0c" translate="yes" xml:space="preserve">
          <source>The locale always used is the one returned by &lt;a href=&quot;../util/locale#getDefault--&quot;&gt;&lt;code&gt;Locale.getDefault()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">항상 사용되는 로케일은 &lt;a href=&quot;../util/locale#getDefault--&quot;&gt; &lt;code&gt;Locale.getDefault()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 로케일 입니다.</target>
        </trans-unit>
        <trans-unit id="366a0be68a17c43905b7bd782f1e30699df8f11a" translate="yes" xml:space="preserve">
          <source>The locale is determined from the formatter. The formatter returned directly by this method will use the &lt;a href=&quot;../../util/locale#getDefault--&quot;&gt;&lt;code&gt;default FORMAT locale&lt;/code&gt;&lt;/a&gt;. The locale can be controlled using &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt;&lt;code&gt;withLocale(Locale)&lt;/code&gt;&lt;/a&gt; on the result of this method.</source>
          <target state="translated">로케일은 포맷터에서 결정됩니다. 이 메소드에 의해 직접 돌려 주어진 포매터는 &lt;a href=&quot;../../util/locale#getDefault--&quot;&gt; &lt;code&gt;default FORMAT locale&lt;/code&gt; &lt;/a&gt; 사용합니다 . 이 메소드의 결과에서 &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt; &lt;code&gt;withLocale(Locale)&lt;/code&gt; &lt;/a&gt; 을 사용하여 로케일을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65991f7ad7454909e91fa953adc69eb74b95bfbb" translate="yes" xml:space="preserve">
          <source>The locale is determined from the formatter. The formatter returned directly by this method will use the &lt;a href=&quot;../../util/locale#getDefault-java.util.Locale.Category-&quot;&gt;&lt;code&gt;default FORMAT locale&lt;/code&gt;&lt;/a&gt;. The locale can be controlled using &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt;&lt;code&gt;withLocale(Locale)&lt;/code&gt;&lt;/a&gt; on the result of this method.</source>
          <target state="translated">로케일은 포맷터에서 결정됩니다. 이 메소드에 의해 직접 돌려 주어진 포매터는 &lt;a href=&quot;../../util/locale#getDefault-java.util.Locale.Category-&quot;&gt; &lt;code&gt;default FORMAT locale&lt;/code&gt; &lt;/a&gt; 사용합니다 . 이 메소드의 결과에서 &lt;a href=&quot;datetimeformatter#withLocale-java.util.Locale-&quot;&gt; &lt;code&gt;withLocale(Locale)&lt;/code&gt; &lt;/a&gt; 을 사용하여 로케일을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d27a035926e24202e324c8dbaceea94c517d56fb" translate="yes" xml:space="preserve">
          <source>The locale that best represents the language tag.</source>
          <target state="translated">언어 태그를 가장 잘 나타내는 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="ad8955176109149292d2490f96896813a8b15f84" translate="yes" xml:space="preserve">
          <source>The locale used is the &lt;a href=&quot;locale#getDefault-java.util.Locale.Category-&quot;&gt;default locale&lt;/a&gt; for &lt;a href=&quot;locale.category#FORMAT&quot;&gt;formatting&lt;/a&gt; for this instance of the Java virtual machine.</source>
          <target state="translated">사용되는 로케일은,이다 &lt;a href=&quot;locale#getDefault-java.util.Locale.Category-&quot;&gt;기본 로케일&lt;/a&gt; 에 대한 &lt;a href=&quot;locale.category#FORMAT&quot;&gt;서식&lt;/a&gt; 이 Java 가상 머신 인스턴스.</target>
        </trans-unit>
        <trans-unit id="e6a785aadaa78a38e75567a0f703ed28d6b3f7e0" translate="yes" xml:space="preserve">
          <source>The locale-independent names of the parameters. May return a null array if the parameter names aren't known.</source>
          <target state="translated">매개 변수의 로케일 독립적 이름. 매개 변수 이름을 모르면 null 배열을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5bd420f4c65808d7d95a170751fbed05770db22" translate="yes" xml:space="preserve">
          <source>The localized description of this throwable.</source>
          <target state="translated">이 Throwable에 대한 현지화 된 설명입니다.</target>
        </trans-unit>
        <trans-unit id="f6a467b908d5d92876f19e97efb8504a392a6111" translate="yes" xml:space="preserve">
          <source>The localized display name for the property/method/event. This defaults to the same as its programmatic name from getName.</source>
          <target state="translated">특성 / 방법 / 이벤트의 현지화 된 표시 이름입니다. 기본적으로 getName의 프로그램 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="41938becbbbdbf5e0fb9f5e208b9fb0515a70942" translate="yes" xml:space="preserve">
          <source>The localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's &lt;a href=&quot;../text/decimalformat&quot;&gt;&lt;code&gt;DecimalFormat&lt;/code&gt;&lt;/a&gt; object, &lt;code&gt;df&lt;/code&gt;, and its and &lt;a href=&quot;../text/decimalformatsymbols&quot;&gt;&lt;code&gt;DecimalFormatSymbols&lt;/code&gt;&lt;/a&gt; object, &lt;code&gt;dfs&lt;/code&gt;.</source>
          <target state="translated">지역화 된 형식은 다음 매개 변수로 정의되며, 특정 로케일의 경우 해당 로케일의 &lt;a href=&quot;../text/decimalformat&quot;&gt; &lt;code&gt;DecimalFormat&lt;/code&gt; &lt;/a&gt; 객체 &lt;code&gt;df&lt;/code&gt; 및 해당 &lt;a href=&quot;../text/decimalformatsymbols&quot;&gt; &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; &lt;/a&gt; 객체 &lt;code&gt;dfs&lt;/code&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3bc5f7897b9b13130f88e8ac225afff134b290bc" translate="yes" xml:space="preserve">
          <source>The location string</source>
          <target state="translated">위치 문자열</target>
        </trans-unit>
        <trans-unit id="6f1ed4b2d7d8226fd944d0cbe6eea2ec95a9f2b3" translate="yes" xml:space="preserve">
          <source>The lock associated with this &lt;code&gt;Condition&lt;/code&gt; is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until &lt;em&gt;one&lt;/em&gt; of four things happens:</source>
          <target state="translated">이 &lt;code&gt;Condition&lt;/code&gt; 과 관련된 잠금 은 원자 적으로 해제되며 현재 스레드는 스레드 예약 목적으로 비활성화되며 다음 4 가지 &lt;em&gt;중 하나&lt;/em&gt; 가 발생할 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="61d711789cff8fa58268433d15e08dadb98f0892" translate="yes" xml:space="preserve">
          <source>The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until &lt;em&gt;one&lt;/em&gt; of five things happens:</source>
          <target state="translated">이 조건과 관련된 잠금은 원자 적으로 해제되며 현재 스레드는 스레드 예약 목적으로 비활성화되고 5 가지 &lt;em&gt;중 하나&lt;/em&gt; 가 발생할 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="65da01b12ed06c1129194ab04ecdfefe3305ba72" translate="yes" xml:space="preserve">
          <source>The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until &lt;em&gt;one&lt;/em&gt; of three things happens:</source>
          <target state="translated">이 조건과 관련된 잠금은 원자 적으로 해제되며 현재 스레드는 스레드 예약 목적으로 비활성화되고 다음 세 가지 &lt;em&gt;중 하나&lt;/em&gt; 가 발생할 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f9b6f8110f68ff501a635d948cf5536975a242" translate="yes" xml:space="preserve">
          <source>The lock is acquired by the current thread; or</source>
          <target state="translated">잠금은 현재 스레드에 의해 획득됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="936446f11735d6f00e64d3dc5894e2b30dc3b6a3" translate="yes" xml:space="preserve">
          <source>The lock returned by method &lt;a href=&quot;reentrantreadwritelock#readLock--&quot;&gt;&lt;code&gt;ReentrantReadWriteLock.readLock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reentrantreadwritelock#readLock--&quot;&gt; &lt;code&gt;ReentrantReadWriteLock.readLock()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 잠금 입니다.</target>
        </trans-unit>
        <trans-unit id="a63fbd323480ae7eac9b087b684a954032e23d63" translate="yes" xml:space="preserve">
          <source>The lock returned by method &lt;a href=&quot;reentrantreadwritelock#readLock--&quot;&gt;&lt;code&gt;readLock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잠금이 메소드에 의해 반환 &lt;a href=&quot;reentrantreadwritelock#readLock--&quot;&gt; &lt;code&gt;readLock()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39b8fdb8be94320a454a1547f61b7660e9a57cf7" translate="yes" xml:space="preserve">
          <source>The lock returned by method &lt;a href=&quot;reentrantreadwritelock#writeLock--&quot;&gt;&lt;code&gt;ReentrantReadWriteLock.writeLock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reentrantreadwritelock#writeLock--&quot;&gt; &lt;code&gt;ReentrantReadWriteLock.writeLock()&lt;/code&gt; &lt;/a&gt; 메소드에서 리턴 한 잠금 입니다.</target>
        </trans-unit>
        <trans-unit id="905e63fe2eb05904cf02aa94f5b5e717a84245ed" translate="yes" xml:space="preserve">
          <source>The lock returned by method &lt;a href=&quot;reentrantreadwritelock#writeLock--&quot;&gt;&lt;code&gt;writeLock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reentrantreadwritelock#writeLock--&quot;&gt; &lt;code&gt;writeLock()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 락 입니다.</target>
        </trans-unit>
        <trans-unit id="45d3fceafada8cb1318b2a1c9ef2a9a359190c9a" translate="yes" xml:space="preserve">
          <source>The locks held on a particular file by a single Java virtual machine do not overlap. The &lt;a href=&quot;filelock#overlaps-long-long-&quot;&gt;&lt;code&gt;overlaps&lt;/code&gt;&lt;/a&gt; method may be used to test whether a candidate lock range overlaps an existing lock.</source>
          <target state="translated">단일 Java 가상 머신이 특정 파일에 보유한 잠금은 겹치지 않습니다. &lt;a href=&quot;filelock#overlaps-long-long-&quot;&gt; &lt;code&gt;overlaps&lt;/code&gt; &lt;/a&gt; 방법은 후보 로크 범위 기존 로크 중첩 여부를 테스트하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="8b536145c701b36ffc6ce15241826909032276e3" translate="yes" xml:space="preserve">
          <source>The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has &lt;code&gt;null&lt;/code&gt; as its level will inherit its effective level from its parent.</source>
          <target state="translated">LogManager 클래스 설명에 설명 된대로 로깅 구성 파일의 특성을 기반으로 로그 레벨을 구성 할 수 있습니다. 그러나 Logger.setLevel 메서드를 호출하여 동적으로 변경 될 수도 있습니다. 로거 레벨이 변경되면, 레벨로 &lt;code&gt;null&lt;/code&gt; 하위 로거가 상위 레벨에서 유효 레벨을 상속 하므로 변경 사항이 하위 로거에도 영향을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5efe6a79a4cc53f2502e279de30e6e5f2feda9d7" translate="yes" xml:space="preserve">
          <source>The logger will be initially configured with a null Level and with useParentHandlers set to true.</source>
          <target state="translated">로거는 초기에 널 레벨로 설정되고 useParentHandlers가 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="136797d5f389dccc8697d89b60c4d8a0eba2f6fd" translate="yes" xml:space="preserve">
          <source>The logging methods are grouped in five main categories:</source>
          <target state="translated">로깅 방법은 5 가지 주요 범주로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="641b7e7a10638613ca35f5abccd985aaf6071af7" translate="yes" xml:space="preserve">
          <source>The logging request was made initially to a &lt;code&gt;Logger&lt;/code&gt; object, which initialized the &lt;code&gt;LogRecord&lt;/code&gt; and forwarded it here.</source>
          <target state="translated">로깅 요청은 처음에 &lt;code&gt;Logger&lt;/code&gt; 객체 에 이루어졌으며 &lt;code&gt;LogRecord&lt;/code&gt; 객체를 초기화하여 여기에 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="f3195ba410c910cb1453bdf6d15fa282cb473f14" translate="yes" xml:space="preserve">
          <source>The long at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 길다</target>
        </trans-unit>
        <trans-unit id="9b857784a51cb5186a4c310af8fad668265cd2f5" translate="yes" xml:space="preserve">
          <source>The long at the given index</source>
          <target state="translated">주어진 색인에서 긴</target>
        </trans-unit>
        <trans-unit id="d925d78726502c1517a0719c5c67fa836bb30baf" translate="yes" xml:space="preserve">
          <source>The long buffer is not modified by this method, and no reference to the buffer is retained by the bit set.</source>
          <target state="translated">긴 버퍼는이 방법으로 수정되지 않으며 비트 세트에 의해 버퍼에 대한 참조가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b26bffcfbc958bd15ecb825f2a9fae2f40f6a817" translate="yes" xml:space="preserve">
          <source>The long value at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치에서 긴 값</target>
        </trans-unit>
        <trans-unit id="c79239282ea84b694c2ff3f7994ebbc2e5632bef" translate="yes" xml:space="preserve">
          <source>The long value at the given index</source>
          <target state="translated">주어진 인덱스에서 긴 값</target>
        </trans-unit>
        <trans-unit id="1d72b29a13e96aa2ab5bec4f4960d9bf05dd4ca7" translate="yes" xml:space="preserve">
          <source>The longs between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the long at index</source>
          <target state="translated">버퍼의 현재 위치와 한계 사이의 길이 (있는 경우)가 버퍼의 시작 부분에 복사됩니다. 즉, 인덱스에서 긴</target>
        </trans-unit>
        <trans-unit id="1dafcee2bd49424918b839236e0943f9a18e833f" translate="yes" xml:space="preserve">
          <source>The lookup operation returns the best matching language tags. It is defined in RFC 4647 as follows: &quot;By contrast with filtering, each language range represents the most specific tag that is an acceptable match. The first matching tag found, according to the user's priority, is considered the closest match and is the item returned.&quot;</source>
          <target state="translated">조회 작업은 가장 일치하는 언어 태그를 반환합니다. RFC 4647에 다음과 같이 정의되어 있습니다. &quot;필터링과 달리 각 언어 범위는 허용 가능한 일치하는 가장 구체적인 태그를 나타냅니다. 사용자의 우선 순위에 따라 첫 번째 일치하는 태그가 가장 근접한 것으로 간주되며 항목입니다 돌아 왔습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="0b15aba7014ff4a3b81f3cf9a325dec861715d64" translate="yes" xml:space="preserve">
          <source>The low threshold value.</source>
          <target state="translated">임계 값이 낮습니다.</target>
        </trans-unit>
        <trans-unit id="e1027b0c41f8a52e9615bc3f18f897cf025a055b" translate="yes" xml:space="preserve">
          <source>The low-level description of the method</source>
          <target state="translated">방법의 저수준 설명</target>
        </trans-unit>
        <trans-unit id="89c09aa4a3982e510232a448559f376283539736" translate="yes" xml:space="preserve">
          <source>The lowercase letters &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; through &lt;code&gt;'\u007a'&lt;/code&gt;),</source>
          <target state="translated">소문자 &lt;code&gt;'a'&lt;/code&gt; ~ &lt;code&gt;'z'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; ~ &lt;code&gt;'\u007a'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c289c722dc9ced058183a4c8dddca407e0a3bc2d" translate="yes" xml:space="preserve">
          <source>The lowest scope. Returns -1 if no attribute with the given name is defined in any scope.</source>
          <target state="translated">가장 낮은 범위입니다. 지정된 이름의 속성이 범위에 정의되어 있지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd3e31a106389ea2a7d2a231b5298c5fd7241a88" translate="yes" xml:space="preserve">
          <source>The m-let service extends the &lt;code&gt;java.net.URLClassLoader&lt;/code&gt; and can be used to load remote classes and jar files in the VM of the agent.</source>
          <target state="translated">m-let 서비스는 &lt;code&gt;java.net.URLClassLoader&lt;/code&gt; 를 확장 하며 에이전트의 VM에서 원격 클래스 및 jar 파일을로드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f854df23c307bcb9e34b9849451f1d804656d22" translate="yes" xml:space="preserve">
          <source>The magnitude is formatted as the integer part of</source>
          <target state="translated">크기는 정수 부분으로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="de144eeaeb048750a7b6ca494a4484b91c3ca8c0" translate="yes" xml:space="preserve">
          <source>The main API for dates, times, instants, and durations.</source>
          <target state="translated">날짜, 시간, 인스턴트 및 기간에 대한 기본 API입니다.</target>
        </trans-unit>
        <trans-unit id="87ad397b72e4e2670cb9fd154ad2b5c78ebccb49" translate="yes" xml:space="preserve">
          <source>The main API is based around the calendar system defined in ISO-8601. However, there are other calendar systems, and this package provides basic support for them. The alternate calendars are provided in the &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;java.time.chrono&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">기본 API는 ISO-8601에 정의 된 캘린더 시스템을 기반으로합니다. 그러나 다른 달력 시스템이 있으며이 패키지는이를 지원합니다. 대체 캘린더는 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;java.time.chrono&lt;/code&gt; &lt;/a&gt; 패키지에 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8f745cb8e21c4eb3d06ea2d2c82dc8a5899e5a" translate="yes" xml:space="preserve">
          <source>The main areas of functionality of &lt;code&gt;javax.script&lt;/code&gt; package include</source>
          <target state="translated">&lt;code&gt;javax.script&lt;/code&gt; 패키지 의 주요 기능 영역은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c8b07dc81c5cae446072ef321854dc8c9b754b2" translate="yes" xml:space="preserve">
          <source>The main computation performed by this task.</source>
          <target state="translated">이 작업으로 수행되는 주요 계산입니다.</target>
        </trans-unit>
        <trans-unit id="b5a067152faa9b4aadd51479a1dd861ea68df4fd" translate="yes" xml:space="preserve">
          <source>The main date and time API is built on the ISO calendar system. The chronology operates behind the scenes to represent the general concept of a calendar system.</source>
          <target state="translated">기본 날짜 및 시간 API는 ISO 캘린더 시스템에 구축되어 있습니다. 연대기는 배후에서 작동하여 달력 시스템의 일반적인 개념을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b853030ffb2c3edc982b0284b46a35af47f22884" translate="yes" xml:space="preserve">
          <source>The main date and time API is built on the ISO calendar system. The chronology operates behind the scenes to represent the general concept of a calendar system. For example, the Japanese, Minguo, Thai Buddhist and others.</source>
          <target state="translated">기본 날짜 및 시간 API는 ISO 캘린더 시스템에 구축되어 있습니다. 연대기는 배후에서 작동하여 달력 시스템의 일반적인 개념을 나타냅니다. 예를 들어, 일본어, Minguo, 태국 불교 등.</target>
        </trans-unit>
        <trans-unit id="9e477ae5e9b40e17482fe2bfa8054488de70b68c" translate="yes" xml:space="preserve">
          <source>The main date-time classes provide two methods - one for formatting, &lt;code&gt;format(DateTimeFormatter formatter)&lt;/code&gt;, and one for parsing, &lt;code&gt;parse(CharSequence text, DateTimeFormatter formatter)&lt;/code&gt;.</source>
          <target state="translated">기본 날짜-시간 클래스는 &lt;code&gt;format(DateTimeFormatter formatter)&lt;/code&gt; 지정 ( format (DateTimeFormatter formatter) )과 &lt;code&gt;parse(CharSequence text, DateTimeFormatter formatter)&lt;/code&gt; 두 가지 메소드를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="bb46ba1feb50e25623a3a5d3b3522e2efd2bea39" translate="yes" xml:space="preserve">
          <source>The main input tray in the printer.</source>
          <target state="translated">프린터의 기본 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="cc02b164970a6d4a21efa3fd53651baa0221e88b" translate="yes" xml:space="preserve">
          <source>The main package of the Java Image I/O API.</source>
          <target state="translated">Java Image I / O API의 기본 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="41ec39971544e0ec4cf01b3d1f692a5a209747ec" translate="yes" xml:space="preserve">
          <source>The management interface for a buffer pool, for example a pool of &lt;a href=&quot;../../nio/bytebuffer#allocateDirect-int-&quot;&gt;&lt;code&gt;direct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../nio/mappedbytebuffer&quot;&gt;&lt;code&gt;mapped&lt;/code&gt;&lt;/a&gt; buffers.</source>
          <target state="translated">버퍼 풀의 관리 인터페이스 (예 : &lt;a href=&quot;../../nio/bytebuffer#allocateDirect-int-&quot;&gt; &lt;code&gt;direct&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../nio/mappedbytebuffer&quot;&gt; &lt;code&gt;mapped&lt;/code&gt; &lt;/a&gt; 버퍼 풀)</target>
        </trans-unit>
        <trans-unit id="479285103caa46331ea7728d61e5be1ac361ef47" translate="yes" xml:space="preserve">
          <source>The management interface for a memory manager.</source>
          <target state="translated">메모리 관리자를위한 관리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="fcf3a8512fdd807d7e4faed1fbe89790494ceb21" translate="yes" xml:space="preserve">
          <source>The management interface for a memory manager. A memory manager manages one or more memory pools of the Java virtual machine.</source>
          <target state="translated">메모리 관리자를위한 관리 인터페이스. 메모리 관리자는 Java 가상 머신의 하나 이상의 메모리 풀을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="f4fab39cd8224c3b1514a8f32e67ab83b0c8eab2" translate="yes" xml:space="preserve">
          <source>The management interface for a memory pool.</source>
          <target state="translated">메모리 풀의 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="7a14f43b2f6f8cac13a2fed4f0e0a1d632571b59" translate="yes" xml:space="preserve">
          <source>The management interface for a memory pool. A memory pool represents the memory resource managed by the Java virtual machine and is managed by one or more &lt;a href=&quot;memorymanagermxbean&quot;&gt;&lt;code&gt;memory managers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 풀의 관리 인터페이스 메모리 풀은 Java 가상 머신이 관리하는 메모리 자원을 나타내며 하나 이상의 &lt;a href=&quot;memorymanagermxbean&quot;&gt; &lt;code&gt;memory managers&lt;/code&gt; &lt;/a&gt; 가 관리 합니다 .</target>
        </trans-unit>
        <trans-unit id="45ce2f8d545e61efecccb099b6f99b2e77692328" translate="yes" xml:space="preserve">
          <source>The management interface for the &lt;a href=&quot;../../util/logging/package-summary&quot;&gt;logging&lt;/a&gt; facility.</source>
          <target state="translated">&lt;a href=&quot;../../util/logging/package-summary&quot;&gt;로깅&lt;/a&gt; 기능을 위한 관리 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="e5da84562122ccb1a4b9947a79eb4868f2181d64" translate="yes" xml:space="preserve">
          <source>The management interface for the class loading system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 클래스로드 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8a6fb7cb11948cb467a53e0c5155033baa489d24" translate="yes" xml:space="preserve">
          <source>The management interface for the compilation system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 컴파일 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="28e4b42aecf0c56a50db52a87728efbf52162f13" translate="yes" xml:space="preserve">
          <source>The management interface for the garbage collection of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 가비지 콜렉션을위한 관리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="cd92e36a53dffe8143090f88af9bf00d44b66033" translate="yes" xml:space="preserve">
          <source>The management interface for the garbage collection of the Java virtual machine. Garbage collection is the process that the Java virtual machine uses to find and reclaim unreachable objects to free up memory space. A garbage collector is one type of &lt;a href=&quot;memorymanagermxbean&quot;&gt;&lt;code&gt;memory manager&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Java 가상 머신의 가비지 콜렉션을위한 관리 인터페이스. 가비지 콜렉션은 JVM (Java Virtual Machine)이 도달 할 수없는 오브젝트를 찾아서 회수하여 메모리 공간을 확보하는 데 사용하는 프로세스입니다. 가비지 수집기는 &lt;a href=&quot;memorymanagermxbean&quot;&gt; &lt;code&gt;memory manager&lt;/code&gt; &lt;/a&gt; 유형 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="0440ae4e2f0264de76917a1f8baa0480d3a12abc" translate="yes" xml:space="preserve">
          <source>The management interface for the logging facility.</source>
          <target state="translated">로깅 기능을위한 관리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="3ef314b5f9f21eb1016958cad7f6ed16998f4dbf" translate="yes" xml:space="preserve">
          <source>The management interface for the logging facility. It is recommended to use the &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt;&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;&lt;/a&gt; management interface that implements all attributes defined in this &lt;code&gt;LoggingMXBean&lt;/code&gt;. The &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt;&lt;/a&gt; method can be used to obtain the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; object representing the management interface for logging.</source>
          <target state="translated">로깅 기능을위한 관리 인터페이스. 이 &lt;code&gt;LoggingMXBean&lt;/code&gt; 에 정의 된 모든 속성을 구현 하는 &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt; &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; &lt;/a&gt; 관리 인터페이스 를 사용하는 것이 좋습니다 . &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt; &lt;/a&gt; 방법은 취득 할 수 &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 로깅을위한 관리 인터페이스를 나타내는 개체.</target>
        </trans-unit>
        <trans-unit id="10c44d718b1a21753bf3b069730f590be918c45f" translate="yes" xml:space="preserve">
          <source>The management interface for the memory system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 메모리 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="847ac3d0883ec1a323c757fc548b0fd4d2e2c36d" translate="yes" xml:space="preserve">
          <source>The management interface for the operating system on which the Java virtual machine is running.</source>
          <target state="translated">JVM (Java Virtual Machine)이 실행중인 운영 체제의 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="6eb52bce02ed0ce174dbff28ae7ecc47698722a7" translate="yes" xml:space="preserve">
          <source>The management interface for the runtime system of the Java virtual machine.</source>
          <target state="translated">JVM (Java Virtual Machine)의 런타임 시스템에 대한 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="8e39ca7a7b013a02644c7fe0d0da87295154d935" translate="yes" xml:space="preserve">
          <source>The management interface for the thread system of the Java virtual machine.</source>
          <target state="translated">JVM (Java Virtual Machine)의 스레드 시스템에 대한 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="0f89f384aef1c053634fba77e812dec13d803a9b" translate="yes" xml:space="preserve">
          <source>The management interface of this Standard MBean (or MXBean).</source>
          <target state="translated">이 Standard MBean (또는 MXBean)의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9a8a459cca47f20b145ecf310bebc20942a80db0" translate="yes" xml:space="preserve">
          <source>The management interfaces are also registered with the platform &lt;a href=&quot;../../../javax/management/mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../../../javax/management/objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt; that uniquely identifies the management interface within the &lt;code&gt;MBeanServer&lt;/code&gt; takes the form:</source>
          <target state="translated">관리 인터페이스는 플랫폼 &lt;a href=&quot;../../../javax/management/mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; 에도 등록됩니다 . &lt;a href=&quot;../../../javax/management/objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 고유 내에서 관리 인터페이스를 식별 &lt;code&gt;MBeanServer&lt;/code&gt; 형식을 취합니다 :</target>
        </trans-unit>
        <trans-unit id="351e7dc77ed2411113c4e0ace52b31f98531806d" translate="yes" xml:space="preserve">
          <source>The management of a signer's private keys is an important and sensitive issue that should be handled by subclasses as appropriate to their intended use.</source>
          <target state="translated">서명자의 개인 키 관리는 중요하고 민감한 문제로 의도 된 용도에 맞게 서브 클래스에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="0971fe683af5a5e2e54b47c769fab0246a3b75de" translate="yes" xml:space="preserve">
          <source>The manual feed input tray in the printer.</source>
          <target state="translated">프린터의 수동 급지 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="9d81f1be91cb53728efc46880aacfe384ada117f" translate="yes" xml:space="preserve">
          <source>The map is unmodifiable.</source>
          <target state="translated">지도를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="148614dffcd2a1483f4669ef60a289f4891d5d8f" translate="yes" xml:space="preserve">
          <source>The map returned by this method will have one entry for each charset for which support is available in the current Java virtual machine. If two or more supported charsets have the same canonical name then the resulting map will contain just one of them; which one it will contain is not specified.</source>
          <target state="translated">이 메소드가 리턴 한 맵에는 현재 Java 가상 머신에서 지원되는 각 문자 세트마다 하나의 항목이 있습니다. 둘 이상의 지원되는 문자 집합이 동일한 정식 이름을 가진 경우 결과 맵에는 그 중 하나만 포함됩니다. 어떤 것이 포함 될지 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cc3989e3137f8abc67f81771ff3d11582e2763d1" translate="yes" xml:space="preserve">
          <source>The map will not contain a mapping for the specified key once the call returns.</source>
          <target state="translated">호출이 반환되면 맵에 지정된 키에 대한 매핑이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5efef9ce16d66b6a65a451ff2af5a09326eda0bc" translate="yes" xml:space="preserve">
          <source>The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">매핑 된 Java 유형 인 &lt;em&gt;opendata ( &lt;/em&gt; &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;)&lt;/em&gt; 는 &lt;code&gt;String[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd167e9165a3f6429397c891dd64da4bb93b1858" translate="yes" xml:space="preserve">
          <source>The mapped byte buffer</source>
          <target state="translated">매핑 된 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="b2312b24991b37933ebe862c787f3ef5bd90a444" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 의 매핑 된 유형 은 &lt;code&gt;String[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b54d5b016c52978ccbd2bdfb38bb414673876d40" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt; is &lt;a href=&quot;../../../javax/management/openmbean/tabulardata&quot;&gt;&lt;code&gt;TabularData&lt;/code&gt;&lt;/a&gt; with two items in each row as follows:</source>
          <target state="translated">&lt;code&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt; 의 매핑 된 유형은 다음과 같이 각 행에 두 개의 항목 이있는 &lt;a href=&quot;../../../javax/management/openmbean/tabulardata&quot;&gt; &lt;code&gt;TabularData&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e952ed904175c8930ea48403051b5d05c5545c6" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;MemoryType&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt; and the value is the name of the &lt;code&gt;MemoryType&lt;/code&gt;.</source>
          <target state="translated">맵핑 된 &lt;code&gt;MemoryType&lt;/code&gt; 유형 은 &lt;code&gt;String&lt;/code&gt; 이고 값은 &lt;code&gt;MemoryType&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="fbaf85954f7772b1959d714dcd3394a5212a77f6" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;MemoryUsage&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in &lt;a href=&quot;memoryusage#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;MemoryUsage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;MemoryUsage&lt;/code&gt; 의가 있다 &lt;code&gt;CompositeData&lt;/code&gt; 에를 로 지정된 속성을 가지는 &lt;a href=&quot;memoryusage#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;MemoryUsage&lt;/code&gt; 의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61f3a8b7b0aafedaf94c7afc27dfb44c20f6f872" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;ThreadInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;threadinfo#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;ThreadInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;ThreadInfo&lt;/code&gt; 에가 있다 &lt;code&gt;CompositeData&lt;/code&gt; 에을 에 지정된대로 속성을 &lt;a href=&quot;threadinfo#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;ThreadInfo.from&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="3c087cdbe45fea6b6b9ec0f6437a67475b253bf7" translate="yes" xml:space="preserve">
          <source>The mapping from a local date-time to an offset is not straightforward. There are three cases:</source>
          <target state="translated">로컬 날짜-시간에서 오프셋으로의 매핑은 간단하지 않습니다. 세 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e8672b358b7324e88869fe3994e4595f187b3a" translate="yes" xml:space="preserve">
          <source>The mapping from an instant to an offset is simple, there is only one valid offset for each instant. This method returns that offset.</source>
          <target state="translated">인스턴트에서 오프셋으로의 매핑은 간단하며 각 인스턴트에 대해 하나의 유효한 오프셋 만 있습니다. 이 메소드는 해당 오프셋을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b44258d85a346a4c9b6eb26fc12ad6d8021de13a" translate="yes" xml:space="preserve">
          <source>The match flags specified when this pattern was compiled</source>
          <target state="translated">이 패턴이 컴파일 될 때 지정된 일치 플래그</target>
        </trans-unit>
        <trans-unit id="b6161dc0d1d482e470d3b40c8580a8c7a9b72e62" translate="yes" xml:space="preserve">
          <source>The matchAllNames flag is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">matchAllNames 플래그는 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9bde4024a82b87c160e08374c35154b8fc469748" translate="yes" xml:space="preserve">
          <source>The matching of &lt;a href=&quot;path#getRoot--&quot;&gt;&lt;code&gt;root&lt;/code&gt;&lt;/a&gt; components is highly implementation-dependent and is not specified.</source>
          <target state="translated">&lt;a href=&quot;path#getRoot--&quot;&gt; &lt;code&gt;root&lt;/code&gt; &lt;/a&gt; 구성 요소 의 일치는 구현에 따라 다르며 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="da03290405b7c1d565b96a7f711d623661662ec8" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments is limited by the maximum dimension of a Java array as defined by</source>
          <target state="translated">최대 인수 수는 다음에 의해 정의 된 Java 배열의 최대 차원에 의해 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2a7698e53e08ca40902d31c125a0421b565e34" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes that will be produced per character of input</source>
          <target state="translated">입력 문자 당 생성되는 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="7e9aed519157935d36669fabf1cedde3311fc915" translate="yes" xml:space="preserve">
          <source>The maximum number of characters that will be produced per byte of input</source>
          <target state="translated">입력 바이트 당 생성되는 최대 문자 수</target>
        </trans-unit>
        <trans-unit id="91152b63e685cd48eb7d0248d3371320972bb796" translate="yes" xml:space="preserve">
          <source>The maximum number of entries that will be returned.</source>
          <target state="translated">리턴 될 최대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="c789ee02ecf9b1e05f4f980e654a03a1c6c8656a" translate="yes" xml:space="preserve">
          <source>The maximum number of progressive passes to read from the source. By default, the value is set to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, which indicates that passes up to and including the last available pass should be decoded.</source>
          <target state="translated">소스에서 읽을 최대 진행 패스 수입니다. 기본적으로 값은 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 로 설정되며 , 사용 가능한 마지막 패스까지의 패스를 디코딩해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbbdc1258f7173253696d9e64d4c4a658afd6ade" translate="yes" xml:space="preserve">
          <source>The maximum priority that a thread can have.</source>
          <target state="translated">스레드가 가질 수있는 최대 우선 순위.</target>
        </trans-unit>
        <trans-unit id="a36a818c4f9c33f17fb433826771d2ce806e0080" translate="yes" xml:space="preserve">
          <source>The maximum queue length for incoming connection indications (a request to connect) is set to &lt;code&gt;50&lt;/code&gt;. If a connection indication arrives when the queue is full, the connection is refused.</source>
          <target state="translated">들어오는 연결 표시 (연결 요청)의 최대 큐 길이는 &lt;code&gt;50&lt;/code&gt; 으로 설정되어 있습니다. 큐가 가득 찼을 때 연결 표시가 도착하면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc426f28f7320449dfe90a3a16a1a1b1f8164e7" translate="yes" xml:space="preserve">
          <source>The maximum queue length for incoming connection indications (a request to connect) is set to the &lt;code&gt;backlog&lt;/code&gt; parameter. If a connection indication arrives when the queue is full, the connection is refused.</source>
          <target state="translated">들어오는 연결 표시 (연결 요청)의 최대 큐 길이는 &lt;code&gt;backlog&lt;/code&gt; 매개 변수로 설정됩니다 . 큐가 가득 찼을 때 연결 표시가 도착하면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6409d2fd9d317951cab0b13d3c92c453ac5d7d" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings. The constant value of this field is the largest value permitted for the radix argument in radix-conversion methods such as the &lt;code&gt;digit&lt;/code&gt; method, the &lt;code&gt;forDigit&lt;/code&gt; method, and the &lt;code&gt;toString&lt;/code&gt; method of class &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최대 기수입니다. 이 필드의 상수 값은 &lt;code&gt;digit&lt;/code&gt; 메소드, &lt;code&gt;forDigit&lt;/code&gt; 메소드 및 &lt;code&gt;Integer&lt;/code&gt; 클래스 의 &lt;code&gt;toString&lt;/code&gt; 메소드 와 같은 기수 변환 메소드에서 기수 인수에 허용되는 최대 값 입니다.</target>
        </trans-unit>
        <trans-unit id="686e085cad769598f4690d3665f22a215c1c0ea4" translate="yes" xml:space="preserve">
          <source>The maximum read ahead allowed after a call to the &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the &lt;code&gt;reset&lt;/code&gt; method fail. Whenever the difference between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;markpos&lt;/code&gt; exceeds &lt;code&gt;marklimit&lt;/code&gt;, then the mark may be dropped by setting &lt;code&gt;markpos&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">후속 &lt;code&gt;reset&lt;/code&gt; 메소드 호출이 실패 하기 전에 &lt;code&gt;mark&lt;/code&gt; 메소드 호출 후 허용되는 최대 미리 읽기 입니다. &lt;code&gt;pos&lt;/code&gt; 와 &lt;code&gt;markpos&lt;/code&gt; 의 차이 가 &lt;code&gt;marklimit&lt;/code&gt; 를 초과 할 때마다 &lt;code&gt;markpos&lt;/code&gt; 를 &lt;code&gt;-1&lt;/code&gt; 로 설정하여 마크를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04ce11fe3c27aa7aa9f2ef249ac2e65e1dc4e4ea" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;Instant&lt;/code&gt;, '1000000000-12-31T23:59:59.999999999Z'. This could be used by an application as a &quot;far future&quot; instant.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;Instant&lt;/code&gt; , '1000000000-12-31T23 : 59 : 59.999999999Z'. 응용 프로그램에서 &quot;먼 미래&quot;순간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0429cd3a2343e86a77ff7f695d6193f6a24e2a6" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDate&lt;/code&gt;, '+999999999-12-31'. This could be used by an application as a &quot;far future&quot; date.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalDate&lt;/code&gt; , '+ 999999999-12-31'. 응용 프로그램에서 &quot;먼 미래&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="744d761c58cd3ade37321eaf06b55bc7687217a1" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999'. This is the local date-time just before midnight at the end of the maximum date. This combines &lt;a href=&quot;localdate#MAX&quot;&gt;&lt;code&gt;LocalDate.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#MAX&quot;&gt;&lt;code&gt;LocalTime.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date-time.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalDateTime&lt;/code&gt; , '+ 999999999-12-31T23 : 59 : 59.999999999'. 최대 날짜가 끝나는 자정 직전의 현지 날짜-시간입니다. &lt;a href=&quot;localdate#MAX&quot;&gt; &lt;code&gt;LocalDate.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;localtime#MAX&quot;&gt; &lt;code&gt;LocalTime.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a192d7e44fca6c6034ef03db938f5c28d8840499" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalTime&lt;/code&gt;, '23:59:59.999999999'. This is the time just before midnight at the end of the day.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalTime&lt;/code&gt; , '23 : 59 : 59.999999999 ' 이것은 하루가 끝나는 자정 직전의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="251ab3d26132087a17d987a3306ea536b764e3b4" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999-18:00'. This is the local date-time just before midnight at the end of the maximum date in the minimum offset (larger negative offsets are later on the time-line). This combines &lt;a href=&quot;localdatetime#MAX&quot;&gt;&lt;code&gt;LocalDateTime.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MIN&quot;&gt;&lt;code&gt;ZoneOffset.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date-time.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;OffsetDateTime&lt;/code&gt; , '+ 999999999-12-31T23 : 59 : 59.999999999-18 : 00'. 최소 오프셋에서 최대 날짜 끝에서 자정 직전의 현지 날짜-시간입니다 (큰 음수 오프셋은 나중에 타임 라인에 표시됨). &lt;a href=&quot;localdatetime#MAX&quot;&gt; &lt;code&gt;LocalDateTime.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffset#MIN&quot;&gt; &lt;code&gt;ZoneOffset.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b48f7359abf2b721e4ffc36d002f51c3e787a1e9" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '23:59:59.999999999-18:00'. This is the time just before midnight at the end of the day in the minimum offset (larger negative offsets are later on the time-line). This combines &lt;a href=&quot;localtime#MAX&quot;&gt;&lt;code&gt;LocalTime.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MIN&quot;&gt;&lt;code&gt;ZoneOffset.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date.</source>
          <target state="translated">최대 지원 &lt;code&gt;OffsetTime&lt;/code&gt; 59 : 59.999999999-18 : 00 ', '23한다. 최소 오프셋에서 하루가 끝나는 자정 직전의 시간입니다 (큰 음수 오프셋은 나중에 타임 라인에 표시됨). &lt;a href=&quot;localtime#MAX&quot;&gt; &lt;code&gt;LocalTime.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffset#MIN&quot;&gt; &lt;code&gt;ZoneOffset.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db55fe69812e7a35add31fe3f898cbec3f75e877" translate="yes" xml:space="preserve">
          <source>The maximum supported range is from +18:00 to -18:00 inclusive.</source>
          <target state="translated">지원되는 최대 범위는 +18 : 00 ~ -18 : 00입니다.</target>
        </trans-unit>
        <trans-unit id="c0a2c5b8a90ac648ea5c3d32022df7abb7a348b9" translate="yes" xml:space="preserve">
          <source>The maximum supported year, '+999,999,999'.</source>
          <target state="translated">지원되는 최대 연도는 '+999,999,999'입니다.</target>
        </trans-unit>
        <trans-unit id="edefbb253da2c09881430a08425fc9be7f90b625" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+10FFFF&lt;/code&gt;.</source>
          <target state="translated">a의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+10FFFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9cb824afcd96246aeae16307929222db177a085" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">(A)의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 높은 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uDBFF'&lt;/code&gt; . 높은 대리모는</target>
        </trans-unit>
        <trans-unit id="b33263a788749bdc77ddfac4323c224cdfbe9ba3" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">(A)의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 저 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; . 낮은 대리모는</target>
        </trans-unit>
        <trans-unit id="286d3939ee86174adc9c52569b3a684b11bce46b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; 의 유니 코드 대리 코드 단위의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1f4e7db5483a3dd3186cbf249393ad7015cc5aae" translate="yes" xml:space="preserve">
          <source>The means by which a file type detector determines the file type is highly implementation specific. A simple implementation might examine the &lt;em&gt;file extension&lt;/em&gt; (a convention used in some platforms) and map it to a file type. In other cases, the file type may be stored as a file &lt;a href=&quot;../attribute/package-summary&quot;&gt; attribute&lt;/a&gt; or the bytes in a file may be examined to guess its file type.</source>
          <target state="translated">파일 유형 탐지기가 파일 유형을 결정하는 방법은 구현에 따라 다릅니다. 간단한 구현은 &lt;em&gt;파일 확장명&lt;/em&gt; (일부 플랫폼에서 사용되는 규칙)을 검사하여 파일 형식에 매핑 할 수 있습니다. 다른 경우, 파일 유형이 파일 &lt;a href=&quot;../attribute/package-summary&quot;&gt;속성&lt;/a&gt; 으로 저장 되거나 파일 의 바이트가 파일 유형을 추측하기 위해 검사 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4770c800d3e35c0011221e1a554258227b54744" translate="yes" xml:space="preserve">
          <source>The means by which this method determines the file type is highly implementation specific. It may simply examine the file name, it may use a file &lt;a href=&quot;../attribute/package-summary&quot;&gt;attribute&lt;/a&gt;, or it may examines bytes in the file.</source>
          <target state="translated">이 방법으로 파일 형식을 결정하는 방법은 구현에 따라 다릅니다. 단순히 파일 이름을 검사하거나 파일 &lt;a href=&quot;../attribute/package-summary&quot;&gt;속성을&lt;/a&gt; 사용하거나 파일의 바이트를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab45809aa21711bcf5f58537fef1609f4b9533bd" translate="yes" xml:space="preserve">
          <source>The mechanism described here does not apply when the IIOP Remote objects (Stubs or Servers) are created and connected to an ORB manually before being passed to the RMIConnector and RMIConnectorServer.</source>
          <target state="translated">여기에 설명 된 메커니즘은 IIMI 원격 오브젝트 (스텁 또는 서버)가 RMIConnector 및 RMIConnectorServer로 전달되기 전에 ORB에 수동으로 작성되고 연결될 때 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75b2b887cd766344d43dde743abd52969399d0c6" translate="yes" xml:space="preserve">
          <source>The media type, media subtype, and parameter names are converted to lowercase.</source>
          <target state="translated">미디어 유형, 미디어 하위 유형 및 매개 변수 이름은 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="81485a662e4b18e73d7e50de595c401a66405a84" translate="yes" xml:space="preserve">
          <source>The media type, media subtype, and parameters are retained, but all comments and whitespace characters are discarded.</source>
          <target state="translated">미디어 유형, 미디어 하위 유형 및 매개 변수는 유지되지만 모든 주석 및 공백 문자는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f97e6177805adf7afc68c7962dee0fa667febf49" translate="yes" xml:space="preserve">
          <source>The membership key</source>
          <target state="translated">멤버쉽 키</target>
        </trans-unit>
        <trans-unit id="0e5fa7adb21c0e325c51267052603c4f999c8037" translate="yes" xml:space="preserve">
          <source>The memory effects for accesses and updates of atomics generally follow the rules for volatiles, as stated in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt; The Java Language Specification (17.4 Memory Model)&lt;/a&gt;:</source>
          <target state="translated">원자의 액세스 및 업데이트에 대한 메모리 효과는 일반적으로 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt;Java 언어 사양 (17.4 메모리 모델)에&lt;/a&gt; 명시된대로 휘발성에 대한 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="aab7acbfa43834ab7dc033f83c5c606d75b26760" translate="yes" xml:space="preserve">
          <source>The memory system of the Java virtual machine manages the following kinds of memory:</source>
          <target state="translated">Java 가상 머신의 메모리 시스템은 다음과 같은 종류의 메모리를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="27790702c54d1d404915dd82c93b620fa3c28c6a" translate="yes" xml:space="preserve">
          <source>The memory usage can be monitored in three ways:</source>
          <target state="translated">메모리 사용량은 세 가지 방법으로 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d607f7f1ba30cb36c630b3c22647d62e99ce92fd" translate="yes" xml:space="preserve">
          <source>The memory usage monitoring mechanism is intended for load-balancing or workload distribution use. For example, an application would stop receiving any new workload when its memory usage exceeds a certain threshold. It is not intended for an application to detect and recover from a low memory condition.</source>
          <target state="translated">메모리 사용량 모니터링 메커니즘은로드 밸런싱 또는 워크로드 분배 사용을위한 것입니다. 예를 들어, 메모리 사용량이 특정 임계 값을 초과하면 애플리케이션이 새 워크로드 수신을 중지합니다. 응용 프로그램이 메모리 부족 상태를 감지하고 복구하기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="093780ce78707d757dc19b614256bc2e6651b1d0" translate="yes" xml:space="preserve">
          <source>The memory usage of the memory pool when the notification was constructed.</source>
          <target state="translated">알림이 구성 될 때 메모리 풀의 메모리 사용량.</target>
        </trans-unit>
        <trans-unit id="f920b80ca0223cf0e98906f5968692215bf83a73" translate="yes" xml:space="preserve">
          <source>The memory usage of the system can be monitored using &lt;a href=&quot;#Polling&quot;&gt;polling&lt;/a&gt; or &lt;a href=&quot;#ThresholdNotification&quot;&gt;threshold notification&lt;/a&gt; mechanisms.</source>
          <target state="translated">&lt;a href=&quot;#Polling&quot;&gt;폴링&lt;/a&gt; 또는 &lt;a href=&quot;#ThresholdNotification&quot;&gt;임계 값 알림&lt;/a&gt; 메커니즘을 사용하여 시스템의 메모리 사용량을 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e5edb0774127d7a66acbb52bd0020f5a0df1d4e" translate="yes" xml:space="preserve">
          <source>The mention of URL in the documentation for this class refers to a URL string as defined by RFC 1738 and its related RFCs. It is any string that conforms to the syntax described therein, and may not always have corresponding support in the java.net.URL class or Web browsers.</source>
          <target state="translated">이 클래스의 문서에서 URL은 RFC 1738 및 관련 RFC에서 정의한 URL 문자열을 나타냅니다. 문자열은 여기에 설명 된 구문을 준수하며 java.net.URL 클래스 또는 웹 브라우저에서 항상 해당 지원을하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3019b6df3d7638a94395e6881f48979a9dad4a64" translate="yes" xml:space="preserve">
          <source>The message digest associated with this stream.</source>
          <target state="translated">이 스트림에 관련한 메세지 다이제스트</target>
        </trans-unit>
        <trans-unit id="70409d0fa2f61f14b8e11191ac964557890078df" translate="yes" xml:space="preserve">
          <source>The message string is first localized to a format string using the record's ResourceBundle. (If there is no ResourceBundle, or if the message key is not found, then the key is used as the format string.) The format String uses java.text style formatting.</source>
          <target state="translated">메시지 문자열은 먼저 레코드의 ResourceBundle을 사용하여 형식 문자열로 지역화됩니다. ResourceBundle이 없거나 메시지 키를 찾을 수없는 경우 키는 형식 문자열로 사용됩니다. 형식 문자열은 java.text 스타일 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1bd240084381979a10006bdb738cc8c1d94c319c" translate="yes" xml:space="preserve">
          <source>The message string of this notification object.</source>
          <target state="translated">이 통지 오브젝트의 메세지 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="b54d9c568e6be1f20ad4f6aa93ae581e62015ccb" translate="yes" xml:space="preserve">
          <source>The messages's status byte</source>
          <target state="translated">메시지의 상태 바이트</target>
        </trans-unit>
        <trans-unit id="d2920b888cd3183590608cb7f05eefbb9147b9fa" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../chrono/chronology#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;Chronology::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a chronology cannot be obtained.</source>
          <target state="translated">방법 &lt;a href=&quot;../chrono/chronology#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;Chronology::from&lt;/code&gt; . 이 방법은 연대기를 얻을 수없는 경우 예외가 발생한다는 점을 제외하고는이 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0fadbd5dc81bbd2e66fe9ce72197e29cd159b1e9" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneid#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneId::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a zone cannot be obtained.</source>
          <target state="translated">방법 &lt;a href=&quot;../zoneid#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;ZoneId::from&lt;/code&gt; . 해당 메소드는 영역을 확보 할 수없는 경우 예외를 처리한다는 점을 제외하고이 조회와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="99349278854aaea800ab628dbf65223df309ab09" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalDate::from&lt;/code&gt;. This query and &lt;code&gt;LocalDate::from&lt;/code&gt; will return the same result if the temporal object contains a date. If the temporal object does not contain a date, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">방법 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 비아 &lt;code&gt;LocalDate::from&lt;/code&gt; . 이 쿼리와 &lt;code&gt;LocalDate::from&lt;/code&gt; 은 임시 개체에 날짜가 포함 된 경우 동일한 결과를 반환합니다. 시간 객체에 날짜가 포함되어 있지 않으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6936a4796665371bcc6fe68524a9d8cf7935a697" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalTime::from&lt;/code&gt;. This query and &lt;code&gt;LocalTime::from&lt;/code&gt; will return the same result if the temporal object contains a time. If the temporal object does not contain a time, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">메서드 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 는 메서드 참조 &lt;code&gt;LocalTime::from&lt;/code&gt; 통해 &lt;code&gt;TemporalQuery&lt;/code&gt; 로 사용할 수 있습니다 . 이 쿼리와 &lt;code&gt;LocalTime::from&lt;/code&gt; 은 시간 객체에 시간이 포함 된 경우 동일한 결과를 반환합니다. 시간 객체에 시간이 포함되어 있지 않으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="017484d9fd6cdf516726d1ddbd8dc6b63c039d60" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneOffset::from&lt;/code&gt;. This query and &lt;code&gt;ZoneOffset::from&lt;/code&gt; will return the same result if the temporal object contains an offset. If the temporal object does not contain an offset, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">방법 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;ZoneOffset::from&lt;/code&gt; . 이 쿼리와 &lt;code&gt;ZoneOffset::from&lt;/code&gt; 은 임시 객체에 오프셋이 포함 된 경우 동일한 결과를 반환합니다. temporal 객체에 오프셋이 포함되어 있지 않으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acbe203a39f1e4dfd332d8350eb660e8d8a90fb4" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;character#isDigit-int-&quot;&gt;&lt;code&gt;isDigit(codePoint)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</source>
          <target state="translated">메소드 &lt;a href=&quot;character#isDigit-int-&quot;&gt; &lt;code&gt;isDigit(codePoint)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; 지정된 기수 미만 문자와 문자 (또는 단일 문자의 분해)의 유니 소수점 숫자 값. 이 경우 10 진수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2581bfa41d0a1a93c4108b866c01432ab81d9ff9" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Locale&lt;/code&gt; object for a well-formed BCP 47 language tag.</source>
          <target state="translated">&lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 의 메소드는 올바르게 구성된 BCP 47 언어 태그에 대한 &lt;code&gt;Locale&lt;/code&gt; 오브젝트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="8a7df96b80827737fe37d1466bc469409efb4f5f" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#gc--&quot;&gt;&lt;code&gt;System.gc()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#gc--&quot;&gt; &lt;code&gt;System.gc()&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="d67ec53b39aba953770ea5d557a9a19d55511e10" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#load-java.lang.String-&quot;&gt;&lt;code&gt;System.load(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#load-java.lang.String-&quot;&gt; &lt;code&gt;System.load(String)&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="70d78eaa0709f4675ae6dbbcc4cd52c5b6f29b8d" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt;&lt;code&gt;System.loadLibrary(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it &lt;code&gt;LibFile&lt;/code&gt;) and then to put a static initializer:</source>
          <target state="translated">&lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt; &lt;code&gt;System.loadLibrary(String)&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다. 네이티브 메소드가 클래스 구현에 사용되는 경우 표준 전략은 네이티브 코드를 라이브러리 파일 에 넣고 ( &lt;code&gt;LibFile&lt;/code&gt; 이라고 함 ) 정적 초기화 프로그램을 배치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5effd9dbcb49e11e99f1d710b3ca201a6b6a9939" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#runFinalization--&quot;&gt;&lt;code&gt;System.runFinalization()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#runFinalization--&quot;&gt; &lt;code&gt;System.runFinalization()&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="b0a8b68af3f04771fc8e7e14e5e1f96e743317be" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;LdapContext.getResponseControls()&lt;/code&gt; is used to retrieve the response controls generated by LDAP operations executed as the result of invoking a &lt;code&gt;Context&lt;/code&gt;/&lt;code&gt;DirContext&lt;/code&gt; operation. The result is all of the responses controls generated by the underlying LDAP operations, including any implicit reconnection. To get only the reconnection response controls, use &lt;code&gt;reconnect()&lt;/code&gt; followed by &lt;code&gt;getResponseControls()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LdapContext.getResponseControls()&lt;/code&gt; 메소드 는 &lt;code&gt;Context&lt;/code&gt; / &lt;code&gt;DirContext&lt;/code&gt; 오퍼레이션 호출 결과로 실행 된 LDAP 오퍼레이션에 의해 생성 된 응답 제어를 검색하는 데 사용됩니다 . 결과는 암시 적 재 연결을 포함하여 기본 LDAP 조작에 의해 생성 된 모든 응답 제어입니다. 재 연결 응답 제어 만 얻으려면 &lt;code&gt;reconnect()&lt;/code&gt; 와 &lt;code&gt;getResponseControls()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38efe8e37d65c58afa7204d2c1ff16cacc51ef82" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; defines an attribute called &lt;code&gt;Product&lt;/code&gt;. The Open Type for this attribute is &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt;, and the corresponding &lt;code&gt;ObjectName&lt;/code&gt; value will be the name under which the referenced &lt;code&gt;ProductMXBean&lt;/code&gt; is registered in the MBean Server.</source>
          <target state="translated">&lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; 메소드 는 &lt;code&gt;Product&lt;/code&gt; 라는 속성을 정의합니다 . 이 속성의 공개 유형은 &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt; 이며 해당 &lt;code&gt;ObjectName&lt;/code&gt; 값은 참조 된 &lt;code&gt;ProductMXBean&lt;/code&gt; 이 MBean 서버에 등록 된 이름이됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0a8992dddeafc6e212c01d0a03a038c45a92273" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;clone&lt;/code&gt; for class &lt;code&gt;Object&lt;/code&gt; performs a specific cloning operation. First, if the class of this object does not implement the interface &lt;code&gt;Cloneable&lt;/code&gt;, then a &lt;code&gt;CloneNotSupportedException&lt;/code&gt; is thrown. Note that all arrays are considered to implement the interface &lt;code&gt;Cloneable&lt;/code&gt; and that the return type of the &lt;code&gt;clone&lt;/code&gt; method of an array type &lt;code&gt;T[]&lt;/code&gt; is &lt;code&gt;T[]&lt;/code&gt; where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 메서드 &lt;code&gt;clone&lt;/code&gt; 은 특정 복제 작업을 수행합니다. 이 객체의 클래스가 인터페이스를 구현하지 않는 경우, 최초로 &lt;code&gt;Cloneable&lt;/code&gt; , 다음 &lt;code&gt;CloneNotSupportedException&lt;/code&gt; 발생합니다. 모든 배열은 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하는 것으로 간주되며 배열 유형 &lt;code&gt;T[]&lt;/code&gt; 의 &lt;code&gt;clone&lt;/code&gt; 메소드의 리턴 유형 은 &lt;code&gt;T[]&lt;/code&gt; 여기서 T는 참조 또는 기본 유형입니다. 그렇지 않은 경우,이 메소드는이 객체의 클래스의 새 인스턴스를 작성하고 할당에 의한 것처럼이 객체의 해당 필드의 내용으로 정확하게 모든 필드를 초기화합니다. 필드의 내용 자체는 복제되지 않습니다. 따라서이 방법은 &quot;깊은 복사&quot;작업이 아니라이 개체의 &quot;얕은 복사&quot;를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d7f8cbf555e81b515ebed5fd01a023f91544a6b4" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;getLastChangedTime&lt;/code&gt; defines an attribute of type &lt;code&gt;long&lt;/code&gt; called &lt;code&gt;LastChangedTime&lt;/code&gt;. This is a read-only attribute, since there is no method &lt;code&gt;setLastChangedTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getLastChangedTime&lt;/code&gt; 메소드 는 &lt;code&gt;LastChangedTime&lt;/code&gt; 이라는 &lt;code&gt;long&lt;/code&gt; 유형의 속성을 정의합니다 . &lt;code&gt;setLastChangedTime&lt;/code&gt; 메소드가 없기 때문에 읽기 전용 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="c3c5b184cc21ee7d95602d090b1e08067e68c2a2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;isDigit&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</source>
          <target state="translated">메소드 &lt;code&gt;isDigit&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 지정된 기수 미만 문자와 문자 (또는 단일 문자의 분해)의 유니 소수점 숫자 값. 이 경우 10 진수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="535bd995faa93342a266284ae4a21196cdfdbc7f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextBoolean&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextBoolean&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="39aec606639296b0b09aa7ce76c7792db0c9e8d1" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextBytes&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextBytes&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5e2878d870d8e6bb6b3436cc61343f5dff5aef" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextDouble&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextDouble&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="b61e5112029d8cee888287c3757ccf1df1bbebf8" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextFloat&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextFloat&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="52e435482b4a6bf7b9cc5a218513f721c3170375" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextGaussian&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by a threadsafe version of the following:</source>
          <target state="translated">&lt;code&gt;nextGaussian&lt;/code&gt; 메소드 는 다음의 스레드 안전 버전에서와 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="5153d25dbf172da98da0741daa09a59b0ad63eea" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextInt&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextInt&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="8497b578fc5004656d89b7e6983aaffbdc2fbd06" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextLong&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextLong&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="c67214681cb12eb1b4e0da6760e30a88882e1833" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the stream. Java's safe casting should be used to get the desired type. In Java, strings and arrays are objects and are treated as objects during serialization. When read they need to be cast to the expected type.</source>
          <target state="translated">&lt;code&gt;readObject&lt;/code&gt; 메소드 는 스트림에서 객체를 읽는 데 사용됩니다. 원하는 유형을 얻으려면 Java의 안전한 캐스팅을 사용해야합니다. Java에서 문자열 및 배열은 객체이며 직렬화 중에 객체로 처리됩니다. 읽을 때 예상되는 유형으로 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="4459bd46bf4834bc8d1f2a66533eab615320b4ee" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InflaterInputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InflaterInputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13e620608483b508819a8c26cd124d1d4afc2a94" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d0d3bcb4b06a0837cd3dc72144af017482e0c6d5" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;PushbackInputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PushbackInputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f69dcbba5a7b1c0b5dad3540d98ac2d5ae36da0b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;save&lt;/code&gt; defines an operation called &lt;code&gt;save&lt;/code&gt;. It is not an attribute, since its name does not begin with &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">방법은 &lt;code&gt;save&lt;/code&gt; 을 정의라는 작업을 &lt;code&gt;save&lt;/code&gt; . 이름이 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;is&lt;/code&gt; 로 시작하지 않으므로 속성이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="d3ca789241e6d14c3ac15e790f37b9b79ea366c7" translate="yes" xml:space="preserve">
          <source>The method MAY be final.</source>
          <target state="translated">방법은 최종적 일 수있다.</target>
        </trans-unit>
        <trans-unit id="af8fe63e17d04ea68ffd008d010e54db7de4fd6e" translate="yes" xml:space="preserve">
          <source>The method MUST NOT be static except for the application client.</source>
          <target state="translated">이 방법은 응용 프로그램 클라이언트를 제외하고 정적이어서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="1fe676d9fffea60e7a8f68402d907c0a2c03baa3" translate="yes" xml:space="preserve">
          <source>The method MUST NOT be static.</source>
          <target state="translated">이 방법은 정적이어서는 안된다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="caac4ec314c6a1971b464984c3166dc42073086b" translate="yes" xml:space="preserve">
          <source>The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.</source>
          <target state="translated">이 메소드는 인터셉터의 경우를 제외하고는 매개 변수를 가져서는 안됩니다.이 경우 인터셉터 스펙에 정의 된대로 InvocationContext 오브젝트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5bd74d8dca79474f68b7ace3eb464b4b46924655" translate="yes" xml:space="preserve">
          <source>The method Object.toString(), Object.hashCode(), or Object.equals(Object), when invoked on a proxy using this invocation handler, is forwarded to the MBean server as a method on the proxied MBean only if it appears in one of the proxy's interfaces. For a proxy created with &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMBeanProxy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, this means that the method must appear in the Standard MBean or MXBean interface. Otherwise these methods have the following behavior:</source>
          <target state="translated">이 호출 핸들러를 사용하여 프록시에서 호출 될 때 Object.toString (), Object.hashCode () 또는 Object.equals (Object) 메소드는 프록시 MBean에 메소드로 표시되는 경우에만 MBean 서버에 메소드로 전달됩니다. 프록시 인터페이스 중 하나입니다. &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMBeanProxy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; 로&lt;/a&gt; 작성된 프록시의 경우 이는 메소드가 표준 MBean 또는 MXBean 인터페이스에 나타나야 함을 의미합니다. 그렇지 않으면이 메소드는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="bf837832e7854579616fcc0c7961e2c0f8eb7c68" translate="yes" xml:space="preserve">
          <source>The method also makes sure that the key passed in is the same as the one this exemption mechanism used in initializing and generating phases.</source>
          <target state="translated">이 방법은 또한 전달 된 키가 단계를 초기화하고 생성 할 때이 면제 메커니즘과 동일한 키인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a2ebce3cfc3d67e5a06b1146951b4c5544283d64" translate="yes" xml:space="preserve">
          <source>The method area is logically part of the heap but a Java virtual machine implementation may choose not to either garbage collect or compact it. Similar to the heap, the method area may be of a fixed size or may be expanded and shrunk. The memory for the method area does not need to be contiguous.</source>
          <target state="translated">메소드 영역은 논리적으로 힙의 일부이지만 Java 가상 머신 구현은이를 가비지 수집하거나 압축하지 않도록 선택할 수 있습니다. 힙과 유사하게, 방법 영역은 고정 된 크기이거나 확장 및 축소 될 수있다. 메소드 영역의 메모리는 연속적 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2f787f787f66e4c7fe7596b60f067bd719396f2" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 구문 분석에 성공하면 &lt;code&gt;pos&lt;/code&gt; 색인은 마지막으로 사용한 문자 이후에 색인으로 업데이트되고 (구문 분석이 반드시 문자열 끝까지 모든 문자를 사용할 필요는 없음) 구문 분석 된 날짜가 리턴됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="bdc63bdbe6175542e0c05d24ad602abe98b3317a" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 구문 분석에 성공하면 &lt;code&gt;pos&lt;/code&gt; 의 색인은 마지막으로 사용한 문자 이후의 색인으로 업데이트되고 (구문 분석이 반드시 문자열 끝까지 모든 문자를 사용할 필요는 없음) 구문 분석 된 숫자가 리턴됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="755b2d6e0868e85486b4720a3bf6fb663c77e645" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 해석이 완료하면 (자), 인덱스 &lt;code&gt;pos&lt;/code&gt; (해석에서는 캐릭터 라인의 끝까지의 모든 문자를 사용하지 않습니다) 사용 된 마지막 문자의 뒤의 인덱스에 갱신되어 해석 된 객체 배열이 반환됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="728edd8d0c7fa7fe83058e87c898460ae69879c1" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 해석이 완료하면 (자), 인덱스 &lt;code&gt;pos&lt;/code&gt; (해석에서는 캐릭터 라인의 끝까지의 모든 문자를 사용하지 않습니다) 사용 된 마지막 문자의 뒤의 인덱스에 갱신되어 해석 된 객체가 돌려 주어집니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="d9a2756aa6193355e7784a53a8731be0aabbdbef" translate="yes" xml:space="preserve">
          <source>The method defined on a non-interceptor class MUST HAVE the following signature:</source>
          <target state="translated">인터셉터가 아닌 클래스에 정의 된 메소드에는 다음 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7fc31a8c1bb691e0963a145eeb54ea63fdff422" translate="yes" xml:space="preserve">
          <source>The method defined on an interceptor class MUST HAVE one of the following signatures:</source>
          <target state="translated">인터셉터 클래스에 정의 된 메소드에는 다음 서명 중 하나가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="874cf916c1f10aad774a741a754ad2423996c2b7" translate="yes" xml:space="preserve">
          <source>The method does not treat a backslash character, &lt;code&gt;\&lt;/code&gt;, before a non-valid escape character as an error; the backslash is silently dropped. For example, in a Java string the sequence &lt;code&gt;&quot;\z&quot;&lt;/code&gt; would cause a compile time error. In contrast, this method silently drops the backslash. Therefore, this method treats the two character sequence &lt;code&gt;&quot;\b&quot;&lt;/code&gt; as equivalent to the single character &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 유효하지 않은 이스케이프 문자 앞에 백 슬래시 문자 &lt;code&gt;\&lt;/code&gt; 를 오류로 처리하지 않습니다 . 백 슬래시가 자동으로 삭제됩니다. 예를 들어, Java 문자열에서 &lt;code&gt;&quot;\z&quot;&lt;/code&gt; 시퀀스 는 컴파일 시간 오류를 발생시킵니다. 반대로이 방법은 백 슬래시를 자동으로 삭제합니다. 따라서이 방법은 두 문자 시퀀스 &lt;code&gt;&quot;\b&quot;&lt;/code&gt; 를 단일 문자 &lt;code&gt;'b'&lt;/code&gt; 와 동등한 것으로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="dff2253dcf2dbdbeb818932622f47c017d711d4d" translate="yes" xml:space="preserve">
          <source>The method does override or implement a method declared in a supertype.</source>
          <target state="translated">이 메소드는 수퍼 타입에 선언 된 메소드를 대체하거나 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d874850a3069b1faecbf73c1fdbee24f36633207" translate="yes" xml:space="preserve">
          <source>The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made.</source>
          <target state="translated">필요한 페어 와이즈 변환 중 하나를 수행 할 수없는 경우 메소드 핸들 변환을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6801c974c56cb2c89e9773e9f5501edc995c2ac" translate="yes" xml:space="preserve">
          <source>The method handle may throw an &lt;em&gt;undeclared exception&lt;/em&gt;, which means any checked exception (or other checked throwable) not declared by the requested type's single abstract method. If this happens, the throwable will be wrapped in an instance of &lt;a href=&quot;../reflect/undeclaredthrowableexception&quot;&gt;&lt;code&gt;UndeclaredThrowableException&lt;/code&gt;&lt;/a&gt; and thrown in that wrapped form.</source>
          <target state="translated">메소드 핸들은 &lt;em&gt;선언되지 않은 예외를&lt;/em&gt; 던질 수 있는데, 이는 요청 된 유형의 단일 추상 메소드에 의해 선언 &lt;em&gt;되지 않은&lt;/em&gt; 모든 체크 된 예외 (또는 다른 체크 된 &lt;em&gt;예외&lt;/em&gt; )를 의미합니다. 이런 일이 발생하면 Throwable은 &lt;a href=&quot;../reflect/undeclaredthrowableexception&quot;&gt; &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; &lt;/a&gt; 의 인스턴스에 랩핑되고 랩핑 된 폼에 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="041d039fea09ec912b2f7c0f54da21a3bfd1e44b" translate="yes" xml:space="preserve">
          <source>The method has a signature that is override-equivalent to that of any public method declared in &lt;a href=&quot;object&quot;&gt;Object&lt;/a&gt;.</source>
          <target state="translated">이 메소드에는 &lt;a href=&quot;object&quot;&gt;Object에&lt;/a&gt; 선언 된 모든 공개 메소드의 서명과 대체되는 서명이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7616838d561dfc62e3dd4e5cdb730d2042aaf10e" translate="yes" xml:space="preserve">
          <source>The method makes a best effort attempt to close all opened files, by catching &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;s internally. Unchecked exceptions and errors are not caught. Calling close on an already closed loader has no effect.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을&lt;/a&gt; 내부적 으로 포착하여 열려있는 모든 파일을 닫으려고 최선을 다합니다 . 확인되지 않은 예외 및 오류는 포착되지 않습니다. 이미 닫힌 로더에서 닫기를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="01f8d9463e6eb038e7275bbee56c959165f19559" translate="yes" xml:space="preserve">
          <source>The method must have the same effect as calling the &lt;code&gt;setBindings&lt;/code&gt; method of &lt;code&gt;ScriptContext&lt;/code&gt; with the corresponding value of &lt;code&gt;scope&lt;/code&gt; on the default &lt;code&gt;ScriptContext&lt;/code&gt; of the &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">이 방법은 호출과 같은 효과가 있어야 &lt;code&gt;setBindings&lt;/code&gt; 의 방법 &lt;code&gt;ScriptContext&lt;/code&gt; 의 대응하는 값 &lt;code&gt;scope&lt;/code&gt; 의 기본에 &lt;code&gt;ScriptContext&lt;/code&gt; 의 &lt;code&gt;ScriptEngine&lt;/code&gt; 를 검색 .</target>
        </trans-unit>
        <trans-unit id="15a01b8573f438dbb644e46e679a12309fb238bb" translate="yes" xml:space="preserve">
          <source>The method names &quot;get&quot; and &quot;set&quot; defined in the &lt;a href=&quot;../util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface may also be applied to array instances, mapping to the static methods of the same name in the &lt;code&gt;Array&lt;/code&gt; class.</source>
          <target state="translated">&lt;a href=&quot;../util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스에 정의 된 메소드 이름 &quot;get&quot;및 &quot;set&quot; 도 Array 인스턴스에 적용되어 &lt;code&gt;Array&lt;/code&gt; 클래스 에서 동일한 이름의 정적 메소드에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="31ea5c5f1f94c274b3d01eb1641bbe42804b8496" translate="yes" xml:space="preserve">
          <source>The method on which PostConstruct is applied MAY be public, protected, package private or private.</source>
          <target state="translated">PostConstruct가 적용되는 방법은 public, protected, package private 또는 private 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d54155e020311194231f7107f4623669daac2c" translate="yes" xml:space="preserve">
          <source>The method on which PreDestroy is applied MAY be public, protected, package private or private.</source>
          <target state="translated">PreDestroy가 적용되는 방법은 public, protected, package private 또는 private 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca55322435324027e26d48fb8b856f2cd4798e10" translate="yes" xml:space="preserve">
          <source>The method retrieves the source and destination band setting arrays from param using the &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt;methods (or considers them to be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;). If the source band setting array is &lt;code&gt;null&lt;/code&gt;, it is considered to be equal to the array &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt;, and similarly for the destination band setting array.</source>
          <target state="translated">이 메소드는 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 메소드를 사용하여 param에서 소스 및 대상 밴드 설정 배열을 검색합니다 (또는 &lt;code&gt;param&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;null&lt;/code&gt; 간주 ). 소스 밴드 설정 배열이 &lt;code&gt;null&lt;/code&gt; 인 경우, 배열 &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt; 와 같고 대상 밴드 설정 배열 과 동일하게 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec049c98e4152761fc23d3a62699d89db08b276a" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;null&lt;/code&gt; for territories that don't have a currency, such as Antarctica.</source>
          <target state="translated">이 방법은 남극 대륙과 같이 통화가없는 영토에 대해서는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ceab077d59c6d554d1d17fd8d17c58c9283f7971" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback search is desired.</source>
          <target state="translated">추가 폴백 검색이 필요하지 않은 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0c99f16cb456d9d761214c183263d3daa238152b" translate="yes" xml:space="preserve">
          <source>The method returns an estimate of the number of nanoseconds remaining to wait given the supplied &lt;code&gt;nanosTimeout&lt;/code&gt; value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form:</source>
          <target state="translated">이 메소드는 반환 시 제공된 &lt;code&gt;nanosTimeout&lt;/code&gt; 값 또는 시간이 초과 된 경우 0보다 작거나 같은 값을 제공 할 때까지 대기하기 위해 남아있는 나노초 수의 추정치를 반환합니다 . 이 값은 대기가 리턴되지만 대기 상태가 여전히 유지되지 않는 경우 대기 대기 시간 및 대기 시간을 판별하는 데 사용할 수 있습니다. 이 방법의 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="769dd36c2f309466661aec7a75b851fd30f66882" translate="yes" xml:space="preserve">
          <source>The method returns the sum of the number of bytes that have been pushed back and the value returned by &lt;a href=&quot;filterinputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 푸시 된 바이트 수와 &lt;a href=&quot;filterinputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; 에서&lt;/a&gt; 리턴 한 값의 합계를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="1a5895c513c19101d431f066651cadee4994a6cd" translate="yes" xml:space="preserve">
          <source>The method that should be used to read an indexed property value. May return null if the property isn't indexed or is write-only.</source>
          <target state="translated">인덱싱 된 속성 값을 읽는 데 사용해야하는 방법입니다. 속성이 색인화되지 않았거나 쓰기 전용 인 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b08ff4ef56a4f901d8176c3c9d3e4ffa7c0f0db" translate="yes" xml:space="preserve">
          <source>The method that should be used to read the property value. May return null if the property can't be read.</source>
          <target state="translated">속성 값을 읽는 데 사용해야하는 방법입니다. 속성을 읽을 수없는 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d046710b3e478e214106309178510fcd767174" translate="yes" xml:space="preserve">
          <source>The method that should be used to write an indexed property value. May return null if the property isn't indexed or is read-only.</source>
          <target state="translated">인덱싱 된 속성 값을 작성하는 데 사용해야하는 방법입니다. 속성이 색인화되지 않았거나 읽기 전용 인 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="908a1d912ea96d1085e886bbb7a0220276726cc9" translate="yes" xml:space="preserve">
          <source>The method that should be used to write the property value. May return null if the property can't be written.</source>
          <target state="translated">속성 값을 작성하는 데 사용해야하는 방법입니다. 속성을 쓸 수 없으면 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2a6855e5dad9257b6848b559469ffc4f5de113" translate="yes" xml:space="preserve">
          <source>The method then tests that both arrays are equal in length, and that neither array contains a value larger than the largest available band index.</source>
          <target state="translated">그런 다음이 방법은 두 배열의 길이가 동일하고 어느 배열도 사용 가능한 최대 밴드 인덱스보다 큰 값을 포함하지 않는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="ec0804b3da18a61f222951f395dd58dd51623934" translate="yes" xml:space="preserve">
          <source>The method used to access the array of listeners at the event source or null if it doesn't exist.</source>
          <target state="translated">이벤트 소스에서 리스너의 배열에 액세스하는 데 사용되는 메소드이거나 존재하지 않는 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="d1b1e281970d0ec8d5c6cbefb1e926c1a0c3863c" translate="yes" xml:space="preserve">
          <source>The method used to register a listener at the event source.</source>
          <target state="translated">이벤트 소스에서 리스너를 등록하는 데 사용되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="3cfa4fe325cf93f02d82653b486a7ae683ea287e" translate="yes" xml:space="preserve">
          <source>The method used to remove a listener at the event source.</source>
          <target state="translated">이벤트 소스에서 리스너를 제거하는 데 사용되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="2a56f0a297591ec761ffc4464906f2896e34b7f6" translate="yes" xml:space="preserve">
          <source>The method writeObject is used to write an object to the stream. Any object, including Strings and arrays, is written with writeObject. Multiple objects or primitives can be written to the stream. The objects must be read back from the corresponding ObjectInputstream with the same types and in the same order as they were written.</source>
          <target state="translated">writeObject 메소드는 객체를 스트림에 쓰는 데 사용됩니다. 문자열과 배열을 포함한 모든 객체는 writeObject로 작성됩니다. 여러 객체 또는 프리미티브를 스트림에 쓸 수 있습니다. 해당 ObjectInputstream에서 작성된 것과 동일한 유형 및 순서로 오브젝트를 다시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d2f32a4b9ffbf5e3d66a95c06be2ec95ffc9ed9" translate="yes" xml:space="preserve">
          <source>The methods &lt;a href=&quot;zoneoffsettransition#getInstant--&quot;&gt;&lt;code&gt;getInstant()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zoneoffsettransition#getDateTimeBefore--&quot;&gt;&lt;code&gt;getDateTimeBefore()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffsettransition#getDateTimeAfter--&quot;&gt;&lt;code&gt;getDateTimeAfter()&lt;/code&gt;&lt;/a&gt; all represent the same instant.</source>
          <target state="translated">&lt;a href=&quot;zoneoffsettransition#getInstant--&quot;&gt; &lt;code&gt;getInstant()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zoneoffsettransition#getDateTimeBefore--&quot;&gt; &lt;code&gt;getDateTimeBefore()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffsettransition#getDateTimeAfter--&quot;&gt; &lt;code&gt;getDateTimeAfter()&lt;/code&gt; &lt;/a&gt; 메소드 는 모두 동일한 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fa8e3c1943bf599da02611ada531a6bffa15fa8" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;getCacheSize&lt;/code&gt; and &lt;code&gt;setCacheSize&lt;/code&gt; define a read-write attribute of type &lt;code&gt;int&lt;/code&gt; called &lt;code&gt;CacheSize&lt;/code&gt; (with an initial capital, unlike the JavaBeans convention).</source>
          <target state="translated">&lt;code&gt;getCacheSize&lt;/code&gt; 및 &lt;code&gt;setCacheSize&lt;/code&gt; 메소드 는 JavaBeans 규칙과 달리 초기 대문자를 사용하여 &lt;code&gt;CacheSize&lt;/code&gt; 라는 &lt;code&gt;int&lt;/code&gt; 유형의 읽기-쓰기 속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f68f66a9cc678fa78140ffed606a6d1a687876f8" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt; are declared to throw &lt;a href=&quot;../throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt;, which is to say that there is no static restriction on what a method handle can throw. Since the JVM does not distinguish between checked and unchecked exceptions (other than by their class, of course), there is no particular effect on bytecode shape from ascribing checked exceptions to method handle invocations. But in Java source code, methods which perform method handle calls must either explicitly throw &lt;code&gt;Throwable&lt;/code&gt;, or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 및 &lt;code&gt;invoke&lt;/code&gt; 메소드 는 &lt;a href=&quot;../throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 을 던지도록 선언됩니다 . 즉, 메소드 핸들이 던질 수있는 대상에 대한 정적 제한이 없습니다. JVM은 물론 체크되지 않은 예외와 체크되지 않은 예외를 구분하지 않기 때문에 (확인 된 예외를 확인하는 것부터 메소드 핸들을 호출하는 것까지) 바이트 코드 형태에는 특별한 영향이 없습니다. 그러나 Java 소스 코드에서 메소드 핸들 호출을 수행하는 메소드는 명시 적으로 &lt;code&gt;Throwable&lt;/code&gt; 을 발생 시키거나 그렇지 않은 경우 모든 Throwable을 로컬에서 포착하여 컨텍스트에서 올바른 항목 만 다시 던져서 불법 인 항목을 랩해야합니다.</target>
        </trans-unit>
        <trans-unit id="f23e34ba9de16e07759fdba49f95969f12bcc468" translate="yes" xml:space="preserve">
          <source>The methods and constants which specify options in this interface are for implementation only. If you're not subclassing SocketImpl or DatagramSocketImpl, &lt;b&gt;you won't use these directly.&lt;/b&gt; There are type-safe methods to get/set each of these options in Socket, ServerSocket, DatagramSocket and MulticastSocket.</source>
          <target state="translated">이 인터페이스에서 옵션을 지정하는 메소드 및 상수는 구현 전용입니다. SocketImpl 또는 DatagramSocketImpl을 서브 클래 싱 &lt;b&gt;하지 않으면 직접 사용하지 않습니다. &lt;/b&gt;Socket, ServerSocket, DatagramSocket 및 MulticastSocket에는 이러한 각 옵션을 가져오고 설정하는 형식에 안전한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c8839f76f0c1cc8a34ad4ed7dc5ee39ef85f5c" translate="yes" xml:space="preserve">
          <source>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method of the class loader that originally created the class.</source>
          <target state="translated">클래스 로더에 의해 생성 된 객체의 메소드와 생성자는 다른 클래스를 참조 할 수 있습니다. 참조 된 클래스를 판별하기 위해 JVM (Java Virtual Machine)은 원래 클래스를 작성한 클래스 로더 의 &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="39c7b8f07a9efbfd307fba62e3dde13e6f8f3ece" translate="yes" xml:space="preserve">
          <source>The methods and data of class &lt;code&gt;Character&lt;/code&gt; are defined by the information in the</source>
          <target state="translated">&lt;code&gt;Character&lt;/code&gt; 클래스의 메소드와 데이터 는 다음의 정보로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2b4113e05c3868eafe1fc665c48c2e34550e14" translate="yes" xml:space="preserve">
          <source>The methods in this class all throw a &lt;code&gt;NullPointerException&lt;/code&gt;, if the specified array reference is null, except where noted.</source>
          <target state="translated">지정된 배열 참조가 null 인 경우, 이 클래스의 메소드는 모두 &lt;code&gt;NullPointerException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="f9b1c1ad7998b39c0048260abd8cc2313f1bb8c1" translate="yes" xml:space="preserve">
          <source>The methods in this class are used by the service provider to construct the bits to send to the LDAP server. Applications typically only deal with the classes that implement this interface, supplying them with any information required for a particular extended operation request. It would then pass such a class as an argument to the &lt;code&gt;LdapContext.extendedOperation()&lt;/code&gt; method for performing the LDAPv3 extended operation.</source>
          <target state="translated">이 클래스의 메소드는 서비스 제공자가 LDAP 서버로 보낼 비트를 구성하는 데 사용됩니다. 응용 프로그램은 일반적으로이 확장 인터페이스를 구현하는 클래스 만 처리하여 특정 확장 작업 요청에 필요한 정보를 제공합니다. 그런 다음 LDAPv3 확장 작업을 수행하기 위해 이러한 클래스를 &lt;code&gt;LdapContext.extendedOperation()&lt;/code&gt; 메서드에 인수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="bf8f7e029ac8a3874d50034ad3f38bf2b8cd6257" translate="yes" xml:space="preserve">
          <source>The methods in this class can be used by the application to get low level information about the extended operation response. However, typically, the application will be using methods specific to the class that implements this interface. Such a class should have decoded the BER buffer in the response and should provide methods that allow the user to access that data in the response in a type-safe and friendly manner.</source>
          <target state="translated">이 클래스의 메소드는 애플리케이션이 확장 조작 응답에 대한 저수준 정보를 얻기 위해 사용할 수 있습니다. 그러나 일반적으로 응용 프로그램은이 인터페이스를 구현하는 클래스에 특정한 메서드를 사용합니다. 이러한 클래스는 응답에서 BER 버퍼를 디코딩해야하며 사용자가 형식 안전하고 친숙한 방식으로 응답에서 해당 데이터에 액세스 할 수있는 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e44b2a0e16d7c476c1e2b813535b71f1d47ccc33" translate="yes" xml:space="preserve">
          <source>The methods in this class may be invoked concurrently by multiple threads in a single JVM without the need for external synchronization, and the results will be equivalent to some serial execution. If this class is used concurrently</source>
          <target state="translated">이 클래스의 메소드는 외부 동기화없이 단일 JVM에서 여러 스레드에 의해 동시에 호출 될 수 있으며 결과는 일부 직렬 실행과 같습니다. 이 클래스를 동시에 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="256f0bfec8af2d80099c39667ba98e0fa83558c6" translate="yes" xml:space="preserve">
          <source>The methods in this interface support identification of objects by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; search filters.</source>
          <target state="translated">이 인터페이스의 메소드는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; 검색 필터 로 오브젝트 식별을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="1f232e016bcfec5180a282093404d0a4a6882d22" translate="yes" xml:space="preserve">
          <source>The methods of all classes in &lt;code&gt;java.util.concurrent&lt;/code&gt; and its subpackages extend these guarantees to higher-level synchronization. In particular:</source>
          <target state="translated">&lt;code&gt;java.util.concurrent&lt;/code&gt; 및 그 서브 패키지 에있는 모든 클래스의 메소드는 이러한 보증을 상위 레벨 동기화로 확장합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="ac66d0aaaacddda7c8628c76f8814b7513844fdf" translate="yes" xml:space="preserve">
          <source>The methods of this class all throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the collections or class objects provided to them are null.</source>
          <target state="translated">제공된 컬렉션 또는 클래스 객체가 null 인 경우이 클래스의 메서드는 모두 &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b15b6e874e547e9e8ec5c26b9a529230eaf2be38" translate="yes" xml:space="preserve">
          <source>The methods previous() and next() are used for iteration. They return DONE if they would move outside the range from getBeginIndex() to getEndIndex() -1, signaling that the iterator has reached the end of the sequence. DONE is also returned by other methods to indicate that the current index is outside this range.</source>
          <target state="translated">previous () 및 next () 메소드가 반복에 사용됩니다. getBeginIndex ()에서 getEndIndex () -1의 범위 밖으로 이동하면 반복자가 시퀀스의 끝에 도달했음을 알리는 DONE을 리턴합니다. 현재 색인이이 범위 밖에 있음을 나타 내기 위해 다른 메소드에 의해 DONE도 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dcf7ce0d82f3dbedc197b205333a23ce9baeeeb9" translate="yes" xml:space="preserve">
          <source>The methods that accept an &lt;code&gt;int&lt;/code&gt; value support all Unicode characters, including supplementary characters. For example, &lt;code&gt;Character.isLetter(0x2F81A)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the code point value represents a letter (a CJK ideograph).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값 을 허용하는 메소드는 보충 문자를 포함한 모든 유니 코드 문자를 지원합니다. 예를 들어, 코드 포인트 값이 문자 (CJK 표의 문자)를 나타내므로 &lt;code&gt;Character.isLetter(0x2F81A)&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0e9f59343b1741d2ad18d4f64373c4897b94448c" translate="yes" xml:space="preserve">
          <source>The methods that create processes may not work well for special processes on certain native platforms, such as native windowing processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell scripts.</source>
          <target state="translated">프로세스를 작성하는 메소드는 고유 윈도우 프로세스, 디먼 프로세스, Microsoft Windows의 Win16 / DOS 프로세스 또는 쉘 스크립트와 같은 특정 고유 플랫폼의 특수 프로세스에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71e3777c8c977b532490037689faa12fb9e2e35" translate="yes" xml:space="preserve">
          <source>The methods that only accept a &lt;code&gt;char&lt;/code&gt; value cannot support supplementary characters. They treat &lt;code&gt;char&lt;/code&gt; values from the surrogate ranges as undefined characters. For example, &lt;code&gt;Character.isLetter('\uD840')&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, even though this specific value if followed by any low-surrogate value in a string would represent a letter.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 값만 허용하는 메소드는 보충 문자를 지원할 수 없습니다. 대리 범위의 &lt;code&gt;char&lt;/code&gt; 값을 정의되지 않은 문자로 취급 합니다. 예를 들어, &lt;code&gt;Character.isLetter('\uD840')&lt;/code&gt; 은 문자열에 낮은 대리 값이 오는 경우이 특정 값이 문자를 나타내더라도 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cce05671072ffa768c3e060a4fed0ba60bfcf876" translate="yes" xml:space="preserve">
          <source>The micro-of-day.</source>
          <target state="translated">미세한 날.</target>
        </trans-unit>
        <trans-unit id="012bea3abbd9eec2b60f0cb944c493f58a31a682" translate="yes" xml:space="preserve">
          <source>The micro-of-second.</source>
          <target state="translated">초 단위입니다.</target>
        </trans-unit>
        <trans-unit id="eb2247eaaba02959af49dbd11b3740337dcf42ce" translate="yes" xml:space="preserve">
          <source>The middle input tray in the printer.</source>
          <target state="translated">프린터의 중간 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="32c153e5d584c8cab991115e3522d22d789d047f" translate="yes" xml:space="preserve">
          <source>The milli-of-day.</source>
          <target state="translated">밀리 일.</target>
        </trans-unit>
        <trans-unit id="3b415ac04f1b330955bf35e2afa52b9cb732bd02" translate="yes" xml:space="preserve">
          <source>The milli-of-second.</source>
          <target state="translated">밀리 초</target>
        </trans-unit>
        <trans-unit id="2f6279f49fbee882c0c522be365eba539b886cf5" translate="yes" xml:space="preserve">
          <source>The millis property will be initialized to the current time.</source>
          <target state="translated">millis 속성은 현재 시간으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="6777e9b07e5f7f3af56c4b55dd6d8aed2307bf58" translate="yes" xml:space="preserve">
          <source>The milliseconds to add to UTC to get local time.</source>
          <target state="translated">현지 시간을 얻기 위해 UTC에 추가 할 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c1888dd3fc2c61164d0f647a31d752f705f37737" translate="yes" xml:space="preserve">
          <source>The minimal number of days in the first week. For example, the ISO-8601 standard counts the first week as needing at least 4 days.</source>
          <target state="translated">첫 주에 최소 일수. 예를 들어 ISO-8601 표준은 첫 주에 최소 4 일이 필요하다고 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a23319c3216e82c5bdfb981d32b492582aa4945e" translate="yes" xml:space="preserve">
          <source>The minimum and maximum number of integer digits are interpreted together:</source>
          <target state="translated">정수의 최소 및 최대 수는 함께 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4e8a0a7939184991efd16774d48fcc9a4d9dfcd2" translate="yes" xml:space="preserve">
          <source>The minimum index of a progressive pass to read from the source. By default, the value is set to 0, which indicates that passes starting with the first available pass should be decoded.</source>
          <target state="translated">소스에서 읽을 점진적 패스의 최소 인덱스입니다. 기본적으로이 값은 0으로 설정되며 사용 가능한 첫 번째 패스로 시작하는 패스를 디코딩해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b08e3d0656c9b7803ad29c8b58ae2ace6e4bd253" translate="yes" xml:space="preserve">
          <source>The minimum priority that a thread can have.</source>
          <target state="translated">스레드가 가질 수있는 최소 우선 순위.</target>
        </trans-unit>
        <trans-unit id="3077331e7366d18fa715ceb7d901dde04546de29" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings. The constant value of this field is the smallest value permitted for the radix argument in radix-conversion methods such as the &lt;code&gt;digit&lt;/code&gt; method, the &lt;code&gt;forDigit&lt;/code&gt; method, and the &lt;code&gt;toString&lt;/code&gt; method of class &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최소 기수입니다. 이 필드의 정수 값은 작은 값이 예로서 기수 변환 메소드 인수 허용이다 &lt;code&gt;digit&lt;/code&gt; 에있어서, 상기 &lt;code&gt;forDigit&lt;/code&gt; 에 있어서, 상기 &lt;code&gt;toString&lt;/code&gt; 클래스의 메소드 &lt;code&gt;Integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1079249c31ebba26f6b94e4287d0c29dd8ca364c" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;Instant&lt;/code&gt;, '-1000000000-01-01T00:00Z'. This could be used by an application as a &quot;far past&quot; instant.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;Instant&lt;/code&gt; , '-1000000000-01-01T00 : 00Z'. 응용 프로그램에서 &quot;원거리&quot;순간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f720ed7cf76100435b3548f72b4aa7a8f78154b" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDate&lt;/code&gt;, '-999999999-01-01'. This could be used by an application as a &quot;far past&quot; date.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDate&lt;/code&gt; '-999999999-01-01' 응용 프로그램에서 &quot;과거&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edda553e59b5b183f028875cb568ae44225c29be" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00'. This is the local date-time of midnight at the start of the minimum date. This combines &lt;a href=&quot;localdate#MIN&quot;&gt;&lt;code&gt;LocalDate.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#MIN&quot;&gt;&lt;code&gt;LocalTime.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date-time.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00'. 최소 날짜 시작시 자정의 현지 날짜-시간입니다. &lt;a href=&quot;localdate#MIN&quot;&gt; &lt;code&gt;LocalDate.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;localtime#MIN&quot;&gt; &lt;code&gt;LocalTime.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;원거리&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de8290bca9f960ba54ce582e866ef778c1c4612" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalTime&lt;/code&gt;, '00:00'. This is the time of midnight at the start of the day.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalTime&lt;/code&gt; '00 : 00 ' 이것은 하루가 시작되는 자정의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b3ce16d870d460569b094ad8fc0c1bff37370482" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00+18:00'. This is the local date-time of midnight at the start of the minimum date in the maximum offset (larger offsets are earlier on the time-line). This combines &lt;a href=&quot;localdatetime#MIN&quot;&gt;&lt;code&gt;LocalDateTime.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MAX&quot;&gt;&lt;code&gt;ZoneOffset.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date-time.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00 + 18 : 00'. 최대 오프셋에서 최소 날짜 시작시 자정의 로컬 날짜-시간입니다 (큰 오프셋은 타임 라인에서 더 빠름). &lt;a href=&quot;localdatetime#MIN&quot;&gt; &lt;code&gt;LocalDateTime.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;zoneoffset#MAX&quot;&gt; &lt;code&gt;ZoneOffset.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;원거리&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffec1f8e75141092e1bede08d9de5db86a65aee4" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '00:00:00+18:00'. This is the time of midnight at the start of the day in the maximum offset (larger offsets are earlier on the time-line). This combines &lt;a href=&quot;localtime#MIN&quot;&gt;&lt;code&gt;LocalTime.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MAX&quot;&gt;&lt;code&gt;ZoneOffset.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetTime&lt;/code&gt; , '00 : 00 : 00 + 18 : 00 ' 최대 오프셋에서 하루 시작시 자정의 시간입니다 (큰 오프셋은 타임 라인에서 더 빠름). &lt;a href=&quot;localtime#MIN&quot;&gt; &lt;code&gt;LocalTime.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;zoneoffset#MAX&quot;&gt; &lt;code&gt;ZoneOffset.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;과거&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceea9174f0075d07f9e4c2621111a5f2e242d4a" translate="yes" xml:space="preserve">
          <source>The minimum supported year, '-999,999,999'.</source>
          <target state="translated">지원되는 최소 연도 인 '-999,999,999'입니다.</target>
        </trans-unit>
        <trans-unit id="04b4fe66babc8e1e2a91d1f915c13f553008f5e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+0000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb8698589d666395f680bde3fffc23eb4f65729" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">a의 최소값 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 높은 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uD800'&lt;/code&gt; . 높은 대리모는</target>
        </trans-unit>
        <trans-unit id="9341aef5dc8c567df1ec3d8097f6edae0ce1571d" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; 의 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 &lt;/a&gt;저서 로 게이트 코드 단위 의 최소값 입니다. 낮은 대리모는</target>
        </trans-unit>
        <trans-unit id="b8ea878708f2a3189c4f60757a5b8113d3717cbd" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt; Unicode supplementary code point&lt;/a&gt;, constant &lt;code&gt;U+10000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt;유니 코드 보조 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbc35eee66637501d6257be2b6fdd1c93811164" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uD800'&lt;/code&gt; 의 유니 코드 대리 코드 단위의 최소값 입니다.</target>
        </trans-unit>
        <trans-unit id="667a30120007f381c89db949ed47ebe336fec88a" translate="yes" xml:space="preserve">
          <source>The minute-of-day.</source>
          <target state="translated">분.</target>
        </trans-unit>
        <trans-unit id="bdf3bd78cbbce8ca5c3b8eb81726aefb24544a82" translate="yes" xml:space="preserve">
          <source>The minute-of-hour.</source>
          <target state="translated">시간입니다.</target>
        </trans-unit>
        <trans-unit id="6f280eaac6e54be7e34e3642f6ff855dccab09c2" translate="yes" xml:space="preserve">
          <source>The mode argument determines how the progression parameters are chosen, and must be either &lt;code&gt;MODE_DISABLED&lt;/code&gt;, &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, or &lt;code&gt;MODE_DEFAULT&lt;/code&gt;. Otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">mode 인수는 진행 매개 변수 선택 방법을 결정하며 &lt;code&gt;MODE_DISABLED&lt;/code&gt; , &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 또는 &lt;code&gt;MODE_DEFAULT&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7f15fced94f4787a730192e708c8082a30aebb9f" translate="yes" xml:space="preserve">
          <source>The mode controlling compression settings, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">압축 설정을 제어하는 ​​모드는 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정되어야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3de7dfb6d10df1074cd5714724b32c3da19cb20a" translate="yes" xml:space="preserve">
          <source>The mode controlling progressive encoding, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">점진적 인코딩을 제어하는 ​​모드 . &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 를 제외한 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다 . 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f25060df8ca2f2296a1ced1bd3e2a4bdeb249eca" translate="yes" xml:space="preserve">
          <source>The mode controlling tiling settings, which Must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">타일링 설정을 제어하는 ​​모드로, 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="244c6099e5c9d507a776de051659ea7a5f6ced2a" translate="yes" xml:space="preserve">
          <source>The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds. Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and alterations to the length of the notional second. As of 2012, discussions are underway to change the definition of UTC again, with the potential to remove leap seconds or introduce other changes.</source>
          <target state="translated">현대 UTC 타임 스케일은 1972 년에 도입되어 전체 윤초 개념을 소개합니다. 1958 년에서 1972 년 사이에 UTC의 정의는 복잡했으며, 초 이하의 작은 도약과 명목 초의 길이로 변경되었습니다. 2012 년 현재, 윤초를 제거하거나 다른 변경 사항을 도입 할 가능성이있는 UTC 정의를 다시 변경하기위한 논의가 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c9c8d93b57522e87b93d7fcd2ed2c2ba506c62e6" translate="yes" xml:space="preserve">
          <source>The modes are interpreted as follows:</source>
          <target state="translated">모드는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3cc6805c08b8481a43ee22b87218eba5bf5978e2" translate="yes" xml:space="preserve">
          <source>The modification code. It is one of: DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE</source>
          <target state="translated">수정 코드 DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3b8710293df9488348bad7d24782355247e162f4" translate="yes" xml:space="preserve">
          <source>The modification time and deflation hint attributes are not available, for the JAR manifest file and its containing directory.</source>
          <target state="translated">JAR Manifest 파일 및 포함 디렉토리에는 수정 시간 및 수축 힌트 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae5392e591961cef35e6113a0d61745bb18d5cf2" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63ec4993c4772cec3247257c7af88444f99bd5d4" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;default&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b79ffc26fe09a60c57670ba9443868f3e378227" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4caecde01acdabdee3af4deddef05c9345eee88d" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;native&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d84914d32c0b59de560ef406f5fd476bb609a72" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;private&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca2a774915ce47a0621b004260cfcdf34bae0b19" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;protected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d5d79646fb8f27e87d578f47719e85be208200f" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;public&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;public&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0e06d76cb207037ed375002dc516a6bbcfd082" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843644ccb0d5da6c49b878e18a5c3bf04e5a41bd" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;strictfp&lt;/code&gt;</source>
          <target state="translated">한정자 &lt;code&gt;strictfp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e064fce2e476a78dbc9a1b50a393aead551b075c" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;synchronized&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;synchronized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f0463dc16506480712ec2a64c8d394dc5a179d0" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;transient&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;transient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8adc7b2e81a65197a52783e56e73bede59c438b8" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;volatile&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53c43243f455d925c46f284aad81cc7fec157428" translate="yes" xml:space="preserve">
          <source>The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;, table 4.1.</source>
          <target state="translated">수정 자 인코딩은 &lt;em&gt;Java 가상 머신 스펙&lt;/em&gt; , 표 4.1에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea943ef7605756df7d4c1d9a2ba6aa05951d0cb1" translate="yes" xml:space="preserve">
          <source>The modifier flags for this parameter.</source>
          <target state="translated">이 매개 변수에 대한 수정 자 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="d9015ba8f3732b054992024e20f5e48c6d7fa0d5" translate="yes" xml:space="preserve">
          <source>The modifier names are returned in an order consistent with the suggested modifier orderings given in sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1 of</source>
          <target state="translated">수정 자 이름은 8.1.1, 8.3.1, 8.4.3, 8.8.3 및 9.1.1의 섹션 8.1.1에 제시된 제안 된 수정 자 순서와 일치하는 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c051f323123e2496ae8ef9f68dd6f61e20d85875" translate="yes" xml:space="preserve">
          <source>The modifiers are placed in canonical order as specified by &quot;The Java Language Specification&quot;. This is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; first, and then other modifiers in the following order: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;transient&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">수정자는 &quot;The Java Language Specification&quot;에 지정된대로 정식 순서로 배치됩니다. 이것은 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 이며, 다음 순서로 &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;final&lt;/code&gt; , &lt;code&gt;transient&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; 순서로 다른 수정 자입니다 .</target>
        </trans-unit>
        <trans-unit id="62ab14799d4062196ce892d3b8d807e65d9fde90" translate="yes" xml:space="preserve">
          <source>The modulus value.</source>
          <target state="translated">모듈러스 값.</target>
        </trans-unit>
        <trans-unit id="52e5f16469f41afd7f7f1a42b853a6034f970843" translate="yes" xml:space="preserve">
          <source>The month-of-year, such as March.</source>
          <target state="translated">3 월과 같은 달입니다.</target>
        </trans-unit>
        <trans-unit id="ad63462cba81985606db9ca1b76cff069f0f97bd" translate="yes" xml:space="preserve">
          <source>The months unit is not automatically normalized with the years unit. This means that a period of &quot;15 months&quot; is different to a period of &quot;1 year and 3 months&quot;.</source>
          <target state="translated">개월 단위는 년 단위로 자동 정규화되지 않습니다. 이는 &quot;15 개월&quot;기간이 &quot;1 년 3 개월&quot;기간과 다르다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4513060ec32ffaef9ffecbdcf9d778476ec0f897" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided as static methods in &lt;a href=&quot;temporalqueries&quot;&gt;&lt;code&gt;TemporalQueries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 같은 메소드 참조 입니다 . 추가 일반 쿼리는 &lt;a href=&quot;temporalqueries&quot;&gt; &lt;code&gt;TemporalQueries&lt;/code&gt; &lt;/a&gt; 에서 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e2c1befd40582f5a4726afbca33854db8dbfdc7" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided to return:</source>
          <target state="translated">가장 일반적인 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 같은 메소드 참조 입니다 . 다음을 리턴하기 위해 추가 공통 조회가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3d41a4cbf15b731db6bda6714c5e00e992b9f579" translate="yes" xml:space="preserve">
          <source>The most common query implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional implementations are provided as static methods on &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 쿼리 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 같은 메서드 참조 입니다 . 추가 구현은 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; 에&lt;/a&gt; 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c13dd68f0c8f57bb59ccd6903b4447f288e54694" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. Further fields are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields&quot;&gt;&lt;code&gt;WeekFields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;julianfields&quot;&gt;&lt;code&gt;JulianFields&lt;/code&gt;&lt;/a&gt;. Fields can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 추가 필드는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weekfields&quot;&gt; &lt;code&gt;WeekFields&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;julianfields&quot;&gt; &lt;code&gt;JulianFields&lt;/code&gt; 에 제공&lt;/a&gt; 됩니다. 이 인터페이스를 구현하여 응용 프로그램 코드로 필드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7dd9ea927fa70049276104e84510298e783b39" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. Further units are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;. Units can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 추가 단위는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에 제공됩니다 . 이 인터페이스를 구현하여 응용 프로그램 코드로 단위를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="336862f66e49b850485d5a43840dcf02567602aa" translate="yes" xml:space="preserve">
          <source>The most significant 64 bits of this UUID's 128 bit value</source>
          <target state="translated">이 UUID 128 비트 값의 최상위 64 비트</target>
        </trans-unit>
        <trans-unit id="e5b6b0ee327c4dda6a29cf8a360a7d3afa18127d" translate="yes" xml:space="preserve">
          <source>The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. If the move cannot be performed as an atomic file system operation then &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt;&lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt;&lt;/a&gt; is thrown. This can arise, for example, when the target location is on a different &lt;code&gt;FileStore&lt;/code&gt; and would require that the file be copied, or target location is associated with a different provider to this object.</source>
          <target state="translated">이동은 원자 파일 시스템 조작으로 수행되며 다른 모든 옵션은 무시됩니다. 대상 파일이 존재하는 경우 기존 파일이 대체되거나 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을&lt;/a&gt; 발생시켜이 메소드가 실패하면 구현 고유의 것입니다 . 원자 파일 시스템 조작으로 이동을 수행 할 수없는 경우 &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt; &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 예를 들어, 대상 위치가 다른 &lt;code&gt;FileStore&lt;/code&gt; 에 있고 파일을 복사해야하거나 대상 위치가이 오브젝트의 다른 제공자와 연관되어 있어야하는 경우가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf8d2bee39940d0f0e5b63f3da1a2f2575577f74" translate="yes" xml:space="preserve">
          <source>The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized.</source>
          <target state="translated">msg 문자열은 이름 지정된 자원 번들을 사용하여 현지화됩니다. 자원 번들 이름이 널이거나 비어있는 문자열이거나 유효하지 않은 경우 msg 문자열이 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f37cfad4e06252721b39abc7c9955ec39b17924d" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c63c91d04a939fcd587cbc1f9e978924f9d2ad7" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets. A MulticastSocket is a (UDP) DatagramSocket, with additional capabilities for joining &quot;groups&quot; of other multicast hosts on the internet.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다. MulticastSocket은 인터넷에서 다른 멀티 캐스트 호스트의 &quot;그룹&quot;에 참여하기위한 추가 기능이있는 (UDP) DatagramSocket입니다.</target>
        </trans-unit>
        <trans-unit id="679be2f4ae9c2488715346a40d11f01c153c9386" translate="yes" xml:space="preserve">
          <source>The multicast implementation is intended to map directly to the native multicasting facility. Consequently, the following items should be considered when developing an application that receives IP multicast datagrams:</source>
          <target state="translated">멀티 캐스트 구현은 기본 멀티 캐스팅 기능에 직접 매핑하기위한 것입니다. 따라서 IP 멀티 캐스트 데이터 그램을 수신하는 응용 프로그램을 개발할 때는 다음 사항을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce7b19820280a66b240e2ab7bb11f5dc03d3553e" translate="yes" xml:space="preserve">
          <source>The multiple input documents are combined into a single output document. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on this single output document. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of this single output document to produce. The MultipleDocumentHandling values SINGLE_DOCUMENT and SINGLE_DOCUMENT_NEW_SHEET specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서가 단일 출력 문서로 결합됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은이 단일 출력 문서에서 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성이 단일 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SINGLE_DOCUMENT 및 SINGLE_DOCUMENT_NEW_SHEET은이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="028e483478001df55d9b96778a1edffa0bfb1289" translate="yes" xml:space="preserve">
          <source>The multiple input documents remain separate output documents. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on each output document separately. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of each separate output document to produce. The MultipleDocumentHandling values SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서는 별도의 출력 문서로 유지됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은 각 출력 문서에서 개별적으로 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성은 각각 별도의 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SEPARATE_DOCUMENTS_UNCOLLATED_COPIES 및 SEPARATE_DOCUMENTS_COLLATED_COPIES는이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fc368dbc299b8ec9a50b33ed2e8162f1e9e9148a" translate="yes" xml:space="preserve">
          <source>The mutable reduction operation is called &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as it collects together the desired results into a result container such as a &lt;code&gt;Collection&lt;/code&gt;. A &lt;code&gt;collect&lt;/code&gt; operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction:</source>
          <target state="translated">변경 가능한 축소 연산은 원하는 결과를 &lt;code&gt;Collection&lt;/code&gt; 과 같은 결과 컨테이너로 수집하기 때문에 &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라고 합니다 . &lt;code&gt;collect&lt;/code&gt; 동작은 세 가지 기능을 필요 공급 기능을 다른 것으로 한 결과, 용기의 내용을 병합 한 결과 컨테이너 결과 용기에 입력 요소를 포함하는 누적 기 함수 및 합성 함수의 새로운 인스턴스를 생성하기. 이것의 형태는 일반적인 형태의 일반 축소와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6bf363cc62a0d3c9d944fdceea262606a0bad8a4" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 페일 빠른 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d66e6381fee28dcc7d4fb931e8ee888e87c11040" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 실패하지 않은 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f78fc2805fc5d07a59044553456ac5cd7dd26fa" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">가변 소스는 비 지연 바인딩 및 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dbe168307666cea493e681f1f4347bdcea853c7c" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding but fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 바인딩이 아닌 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7bae1d90225c65e4241b4140c7e704c983e32a7" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;gc&lt;/code&gt; stands for &quot;garbage collector&quot;. The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;gc&lt;/code&gt; 라는 이름 은 &quot;가비지 수집기&quot;를 의미합니다. 가상 머신은 &lt;code&gt;gc&lt;/code&gt; 메소드가 명시 적으로 호출되지 않더라도 필요한 경우 별도의 스레드에서이 재활용 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="544bf051094ed67f6eb578a4628c2bb2628ed3d9" translate="yes" xml:space="preserve">
          <source>The name as a list of RDNs which are instances of the class &lt;a href=&quot;rdn&quot;&gt;&lt;code&gt;Rdn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rdn&quot;&gt; &lt;code&gt;Rdn&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 인 RDN리스트로서의 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="504eb3737ea1138b3f84bac07b01bdfb6961254c" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="211caa8f49b864cd1bbad3bd9135f34a8bd884f4" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt;&lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt; &lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="89d3f5a0a3d4ea6ce2bb9307cf0651027e621ab6" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd71c93b574504f37799ee1431d64b7c869dace9" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e99975d51bf3d1c8399965f8cf3b760f5a960107" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2a86ce9761888022d92a9c1c1d8d272ebe5b60b" translate="yes" xml:space="preserve">
          <source>The name constraints have been violated.</source>
          <target state="translated">이름 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="61219587bf820289ff27cf1e6a6218813200b244" translate="yes" xml:space="preserve">
          <source>The name for a BasicPermission is the name of the given permission (for example, &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;, etc). The naming convention follows the hierarchical property naming convention. An asterisk may appear by itself, or if immediately preceded by a &quot;.&quot; may appear at the end of the name, to signify a wildcard match. For example, &quot;*&quot; and &quot;java.*&quot; signify a wildcard match, while &quot;*java&quot;, &quot;a*b&quot;, and &quot;java*&quot; do not.</source>
          <target state="translated">BasicPermission의 이름은 주어진 권한의 이름입니다 (예 : &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 별표가 단독으로 표시되거나 바로 앞에 &quot;.&quot;가 표시 될 수 있습니다. 와일드 카드 일치를 나타 내기 위해 이름 끝에 표시 될 수 있습니다. 예를 들어, &quot;*&quot;및 &quot;java. *&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;, &quot;a * b&quot;및 &quot;java *&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82ff8cd92cff0415e94e8baa63e9f434898b77cd" translate="yes" xml:space="preserve">
          <source>The name in the binding is to be resolved relative to the event source &lt;code&gt;getEventContext()&lt;/code&gt;. The object returned by &lt;code&gt;Binding.getObject()&lt;/code&gt; may be null if such information is unavailable.</source>
          <target state="translated">바인딩의 이름은 이벤트 소스 &lt;code&gt;getEventContext()&lt;/code&gt; 됩니다. 이러한 정보를 사용할 수없는 경우 &lt;code&gt;Binding.getObject()&lt;/code&gt; 의해 반환 된 객체는 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9f47c549f8f573a54eea31230a13704fa78151b" translate="yes" xml:space="preserve">
          <source>The name is a URL, or a name to be resolved relative to the initial context, or if the first character of the name is &quot;.&quot;, the name is relative to the context in which the link is bound.</source>
          <target state="translated">이름은 URL이거나 초기 컨텍스트를 기준으로 확인할 이름이거나 이름의 첫 문자가 &quot;.&quot;인 경우 링크가 바인딩 된 컨텍스트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61679979254cb486e82d74694afb2ea52ea52989" translate="yes" xml:space="preserve">
          <source>The name is finally normalized using normalization form KD, as described in the Unicode Standard and UAX #15</source>
          <target state="translated">이름은 유니 코드 표준 및 UAX # 15에 설명 된대로 정규화 양식 KD를 사용하여 최종적으로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="6b968c3e471f5cb8bcebdf43477ac33f88899fb6" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure appears in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 X.501에 정의 된대로 단일 DER 인코딩 식별 이름이 포함되어야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d62c30e2e16759f0de7f148ea8688978e4f0848c" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears in the documentation for &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 이 구조의 ASN.1 정의는 &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c854a97c7935726ec4f0b93f3dec6e0b700626" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 인코딩 된 바이트 배열은 이름의 인코딩 된 값만 포함해야하며 GeneralName 구조에서 이름과 연관된 태그를 포함하지 않아야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b4157e3b20b0d08a63e804105869ab9b80b570f" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 RFC 3280에 포함 된 제한 사항에 따라 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다. IPv4 주소 이름은 점으로 구분 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="07a1eed59f77ed056220265851c4bb840c68eb88" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt;&lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. RFC 822, DNS 및 URI 이름은 RFC 3280에 포함 된 제한 사항에 따라 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다. IPv4 주소 이름은 점으로 구분 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt; &lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="062b23aadb7d34d7c8b4e9c121e5a95a465b4012" translate="yes" xml:space="preserve">
          <source>The name is the name of the property (&quot;java.home&quot;, &quot;os.name&quot;, etc). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*java&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">이름은 속성의 이름입니다 ( &quot;java.home&quot;, &quot;os.name&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어, &quot;java. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfa54156ec30f9bc348736a478f8a06c98b8284b" translate="yes" xml:space="preserve">
          <source>The name must conform to RFC 2965. That means it can contain only ASCII alphanumeric characters and cannot contain commas, semicolons, or white space or begin with a $ character. The cookie's name cannot be changed after creation.</source>
          <target state="translated">이름은 RFC 2965를 준수해야합니다. 즉, ASCII 영숫자 문자 만 포함 할 수 있으며 쉼표, 세미콜론 또는 공백을 포함하거나 $ 문자로 시작할 수 없습니다. 쿠키 이름은 생성 후 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0b966f42feea9c33f3253f299c07faeb601d6d2" translate="yes" xml:space="preserve">
          <source>The name of a generic type does not include any reference to its formal type parameters. For example, the fully qualified name of the interface &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; is &quot;&lt;code&gt;java.util.Set&lt;/code&gt;&quot;. Nested types use &quot;&lt;code&gt;.&lt;/code&gt;&quot; as a separator, as in &quot;&lt;code&gt;java.util.Map.Entry&lt;/code&gt;&quot;.</source>
          <target state="translated">제네릭 형식의 이름에는 형식 형식 매개 변수에 대한 참조가 포함되어 있지 않습니다. 예를 들어, 인터페이스 &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; 의 완전한 이름 은 &quot; &lt;code&gt;java.util.Set&lt;/code&gt; &quot;입니다. 중첩 유형 은 &quot; &lt;code&gt;java.util.Map.Entry&lt;/code&gt; &quot; 에서와 같이 &quot; &lt;code&gt;.&lt;/code&gt; &quot;을 분리 자로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="6dc7a8ad79c2d57c4b3606f2370da251a94ec44b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server. A server is created as an unbound server by setting the &lt;code&gt;serverName&lt;/code&gt; argument in &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt;&lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt;&lt;/a&gt; as null. The property contains the bound host name after the authentication exchange has completed. It is only available on the server side.</source>
          <target state="translated">바인딩되지 않은 서버의 바인딩 된 서버 이름을 지정하는 속성의 이름입니다. 서버는 &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt; &lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;serverName&lt;/code&gt; 인수를 설정하여 언 바운드 서버로 작성됩니다. .security.auth.callback.CallbackHandler) 를 null로 반환합니다 . 인증 교환이 완료된 후 속성에 바인딩 된 호스트 이름이 포함됩니다. 서버 측에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31543f2d17616a509f1542da77a0190a933ae420" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the cipher strength to use. The property contains a comma-separated, ordered list of cipher strength values that the client or server is willing to support. A strength value is one of</source>
          <target state="translated">사용할 암호 강도를 지정하는 특성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서대로 암호화 수준 값 목록이 포함됩니다. 강도 값은</target>
        </trans-unit>
        <trans-unit id="55e2920c36428c57f886e32853d1f39a8e1f86e0" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the credentials to use. The property contains a mechanism-specific Java credential object. Mechanism implementations may examine the value of this property to determine whether it is a class that they support. The property may be used to supply credentials to a mechanism that supports delegated authentication.</source>
          <target state="translated">사용할 자격 증명을 지정하는 속성의 이름입니다. 이 특성에는 메커니즘 별 Java 신임 오브젝트가 포함되어 있습니다. 메커니즘 구현은이 특성의 값을 검사하여 이들이 지원하는 클래스인지 판별 할 수 있습니다. 이 속성은 위임 된 인증을 지원하는 메커니즘에 자격 증명을 제공하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b920153e04b83edb9986c955cfd7fb277a67ff" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the raw send buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer. The value of this property is negotiated between the client and server during the authentication exchange.</source>
          <target state="translated">원시 전송 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다. 이 특성의 값은 인증 교환 중에 클라이언트와 서버간에 협상됩니다.</target>
        </trans-unit>
        <trans-unit id="5e65556f8d43cf173606f56669dc9e1376a6357a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the receive buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer.</source>
          <target state="translated">수신 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7c2208ad557360dbabcdcb1796613d7ab45b49c2" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the quality-of-protection to use. The property contains a comma-separated, ordered list of quality-of-protection values that the client or server is willing to support. A qop value is one of</source>
          <target state="translated">사용할 보호 수준을 지정하는 속성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서대로 보호 품질 값 목록이 포함됩니다. qop 값은</target>
        </trans-unit>
        <trans-unit id="b8d78b06c714a7846430cd85289564a8ba25548a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to active (non-dictionary) attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to active attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">활성 (사전이 아닌) 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 활성 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ccacffcd7e795c6f2158de9fc95195180770467" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to passive dictionary attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to dictionary attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">수동 사전 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 사전 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b6e642921edcbb0aeb070dc85a3fae28c660e0e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to simple plain passive attacks (e.g., &quot;PLAIN&quot;) are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if such mechanisms are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">단순한 일반 수동 공격에 취약한 메커니즘 (예 : &quot;PLAIN&quot;)이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 이러한 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f4fcba71a86df30c02372fc37f3f03794d3958d1" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that accept anonymous login are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that accept anonymous login are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">익명 로그인을 허용하는 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 익명 로그인을 허용하는 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06776ce760218a8bb3c69a553b99504e2368a22b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that implement forward secrecy between sessions are required. Forward secrecy means that breaking into one session will not automatically provide information for breaking into future sessions. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that implement forward secrecy between sessions are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">세션 사이에 포워드 보안을 구현하는 메커니즘이 필요한지 여부를 지정하는 특성의 이름입니다. 순방향 비밀은 한 세션으로 침입해도 향후 세션으로 침입하기위한 정보를 자동으로 제공하지 않음을 의미합니다. 세션간에 순방향 비밀을 구현하는 메커니즘이 필요한 경우이 속성에는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 이러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ce55bb11912a17b35cd30b5ec6b2d3629fbdf83" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that pass client credentials are required. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that pass client credentials are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">클라이언트 자격 증명을 전달하는 메커니즘이 필요한지 여부를 지정하는 속성의 이름입니다. 클라이언트 자격 증명을 전달하는 메커니즘이 필요한 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 이러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11148564aae0a7b5ceb776e3ad9122d4f8cc5031" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether the server must authenticate to the client. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if the server must authenticate the to client; &lt;code&gt;&quot;false&quot;&lt;/code&gt; otherwise. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">서버가 클라이언트를 인증해야하는지 여부를 지정하는 특성의 이름입니다. 서버가 클라이언트를 인증해야하는 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그렇지 않으면 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8afde55a67986c5517be4ac59b9842900fb0c1e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether to reuse previously authenticated session information. The property contains &quot;true&quot; if the mechanism implementation may attempt to reuse previously authenticated session information; it contains &quot;false&quot; if the implementation must not reuse previously authenticated session information. A setting of &quot;true&quot; serves only as a hint: it does not necessarily entail actual reuse because reuse might not be possible due to a number of reasons, including, but not limited to, lack of mechanism support for reuse, expiration of reusable information, and the peer's refusal to support reuse. The property's default value is &quot;false&quot;. The value of this constant is &quot;javax.security.sasl.reuse&quot;. Note that all other parameters and properties required to create a SASL client/server instance must be provided regardless of whether this property has been supplied. That is, you cannot supply any less information in anticipation of reuse. Mechanism implementations that support reuse might allow customization of its implementation, for factors such as cache size, timeouts, and criteria for reusability. Such customizations are implementation-dependent.</source>
          <target state="translated">이전에 인증 된 세션 정보를 재사용할지 여부를 지정하는 특성의 이름입니다. 메커니즘 구현이 이전에 인증 된 세션 정보를 재사용하려고 시도하는 경우 특성에 &quot;true&quot;가 포함됩니다. 구현이 이전에 인증 된 세션 정보를 재사용해서는 안되는 경우 &quot;false&quot;를 포함합니다. &quot;true&quot;로 설정하면 힌트로만 사용됩니다. 재사용에 대한 메커니즘 지원 부족, 재사용 가능한 정보의 만료 등 여러 가지 이유로 재사용이 불가능할 수 있으므로 실제 재사용이 반드시 필요한 것은 아닙니다. , 동료의 재사용 지원 거부. 속성의 기본값은 &quot;false&quot;입니다. 이 상수의 값은 &quot;javax.security.sasl.reuse&quot;입니다.SASL 클라이언트 / 서버 인스턴스를 작성하는 데 필요한 다른 모든 매개 변수 및 특성은이 특성의 제공 여부에 관계없이 제공되어야합니다. 즉, 재사용을 예상 할 때 더 적은 정보를 제공 할 수 없습니다. 재사용을 지원하는 메커니즘 구현은 캐시 크기, 제한 시간 및 재사용 성 기준과 같은 요소에 대해 구현을 사용자 정의 할 수 있습니다. 이러한 사용자 지정은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="883225677e8f8e5b399c448f823a43abbfc061ea" translate="yes" xml:space="preserve">
          <source>The name of a resource is a '&lt;code&gt;/&lt;/code&gt;'-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 ' &lt;code&gt;/&lt;/code&gt; '로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a515910aa70c3ebcc7ce4ca607dd0dd4f6d0da22" translate="yes" xml:space="preserve">
          <source>The name of a resource is a &lt;code&gt;/&lt;/code&gt;-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 &lt;code&gt;/&lt;/code&gt; 로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="02a87ad296b6a16e86ed792fcd23b2d436a8aa38" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#defaultValue&quot;&gt;&lt;code&gt;defaultValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#defaultValue&quot;&gt; &lt;code&gt;defaultValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="21a7183405f994f4abb54ab06bb8d0ca6abd1b33" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;immutableInfo&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt;immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="4cae14c94ea437e28b95eb63b65b9dc19f3b9961" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#interfaceClassName&quot;&gt;&lt;code&gt;interfaceClassName&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#interfaceClassName&quot;&gt; &lt;code&gt;interfaceClassName&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9fe458bf94e08c2715db3ba7353f7b20a329fde6" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#legalValues&quot;&gt;&lt;code&gt;legalValues&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#legalValues&quot;&gt; &lt;code&gt;legalValues&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="7f056bc651ef11844698474a4860bfd2b3c8422c" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#maxValue&quot;&gt;&lt;code&gt;maxValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#maxValue&quot;&gt; &lt;code&gt;maxValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b5458eeba59dcfbb2d86cb008e54ef4459974966" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#minValue&quot;&gt;&lt;code&gt;minValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#minValue&quot;&gt; &lt;code&gt;minValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3d12e5d2c43700fffd1f2acdcc9bfb6314cfa143" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#mxbean&quot;&gt;&lt;code&gt;mxbean&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#mxbean&quot;&gt; &lt;code&gt;mxbean&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="c0f4d31dececcf3cbe425b7676d150fa31bfc39e" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#openType&quot;&gt;&lt;code&gt;openType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#openType&quot;&gt; &lt;code&gt;openType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="019614432873d92a45cf0bd7b968f9482692078a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#originalType&quot;&gt;&lt;code&gt;originalType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#originalType&quot;&gt; &lt;code&gt;originalType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="48744229149f107d48a57a9a32fe47303158d512" translate="yes" xml:space="preserve">
          <source>The name of the Cryptography Package Provider is designated also by the Signature parameter to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. If the provider is not specified, the default provider is used. Each installation can be configured to use a particular provider as default.</source>
          <target state="translated">암호화 패키지 제공자의 이름은 Signature 매개 변수에 의해 생성자와 &lt;code&gt;verify&lt;/code&gt; 메소드 에도 지정됩니다 . 공급자를 지정하지 않으면 기본 공급자가 사용됩니다. 각 설치는 특정 공급자를 기본값으로 사용하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3374bc67db57b47fa67041ab369a402111b546bf" translate="yes" xml:space="preserve">
          <source>The name of the MBean within the MBean server to which methods are forwarded.</source>
          <target state="translated">메소드가 전달되는 MBean 서버 내의 MBean 이름.</target>
        </trans-unit>
        <trans-unit id="a80646cd5cb31601fc4aac5527e3c066f071889e" translate="yes" xml:space="preserve">
          <source>The name of the class implementing &lt;code&gt;IIOMetadataFormat&lt;/code&gt; and representing the native metadata format, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 을 구현 하고 기본 메타 데이터 형식을 나타내는 클래스 이름 으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="14628be31dd329e555df1f6bfb10c67eaffa4605" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the given locale.</source>
          <target state="translated">주어진 로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="4acb982db435eb2721de142ef807bacda4ac4425" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="5bb84751719d943c1bdfe595f0b620fdf05a9b4b" translate="yes" xml:space="preserve">
          <source>The name of the display language appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="60b08c752ba73a8a294eb2dc32a69396a5bd0e3a" translate="yes" xml:space="preserve">
          <source>The name of the display language.</source>
          <target state="translated">표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0cef399fec1ed02c817bd26adc657c6bf0cd05e8" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c6f8f604377a983983396835745055e795e7955c" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="120a36a79f97ac5cca7e6072a7f24815aa4e4e51" translate="yes" xml:space="preserve">
          <source>The name of the engine implementation.</source>
          <target state="translated">엔진 구현의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="95a2547de9061a70c8901a9a9ae8316a19182943" translate="yes" xml:space="preserve">
          <source>The name of the feature. It is recommended that subclasses call &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">기능의 이름입니다. 서브 클래스는 이 필드를 읽지 않고 &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="94428221f570bbc866fd9fb07f0332af0c0604fc" translate="yes" xml:space="preserve">
          <source>The name of the file or directory denoted by this abstract pathname, or the empty string if this pathname's name sequence is empty</source>
          <target state="translated">이 추상 경로명이 나타내는 파일 또는 디렉토리의 이름, 또는이 경로명의 이름 순서가 비어있는 경우는 빈 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="78e529e47375c2632b7b035e64454552347f35c2" translate="yes" xml:space="preserve">
          <source>The name of the keystore's JCE provider.</source>
          <target state="translated">키 스토어의 JCE 프로 바이더의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="710b3a74bf068fa8de9ebf8e26c80f7f253ab602" translate="yes" xml:space="preserve">
          <source>The name of the locale appropriate to display.</source>
          <target state="translated">표시 할 로케일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dc4668583967ec894c4fc99eff383fa78666fc18" translate="yes" xml:space="preserve">
          <source>The name of the log level of the specified logger; or an empty string if the log level of the specified logger is &lt;code&gt;null&lt;/code&gt;. If the specified logger does not exist, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 로거의 로그 레벨 이름입니다. 또는 지정된 로거의 로그 레벨은 빈 문자열 인 경우 &lt;code&gt;null&lt;/code&gt; . 지정된 로거가 없으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb2d73104061df95f17818382bae8dff8ab298b0" translate="yes" xml:space="preserve">
          <source>The name of the m-let registered.</source>
          <target state="translated">등록 된 m-let의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="093ff0ae78d61a47dcf7ef6063cf858716b59de9" translate="yes" xml:space="preserve">
          <source>The name of the memory pool.</source>
          <target state="translated">메모리 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c7ad1c87eb9dcdbd25ae935d16c25ad0f224ed52" translate="yes" xml:space="preserve">
          <source>The name of the method is denoted by the &quot;method&quot; attribute.</source>
          <target state="translated">메소드의 이름은 &quot;method&quot;속성으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a672ec3f5d7f1814d41e28cb442fc9ba334b3bdc" translate="yes" xml:space="preserve">
          <source>The name of the monitor MBean registered.</source>
          <target state="translated">등록 된 모니터 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c291f6decb6f8d5426876dff90ab34f56da868c4" translate="yes" xml:space="preserve">
          <source>The name of the native metadata format for this object, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">이 객체의 고유 메타 데이터 형식의 이름으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ec919114b57c6c6f0bddee6582f54e56c541ab2a" translate="yes" xml:space="preserve">
          <source>The name of the parameter, either provided by the class file or synthesized if the class file does not provide a name.</source>
          <target state="translated">클래스 파일에서 제공하거나 클래스 파일이 이름을 제공하지 않으면 합성되는 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0fde951d6d267c7761faf39ef1278ab5b4594efa" translate="yes" xml:space="preserve">
          <source>The name of the resolved object, relative to &lt;code&gt;altNameCtx&lt;/code&gt;. It is a composite name. If null, then no name is specified.</source>
          <target state="translated">&lt;code&gt;altNameCtx&lt;/code&gt; 에 상대적인 해결 된 객체의 이름입니다 . 합성 이름입니다. null의 경우는 이름이 지정되지 않는다</target>
        </trans-unit>
        <trans-unit id="cd1bd73ac27aa215798a1528ac7cb6d12a80bc26" translate="yes" xml:space="preserve">
          <source>The name of the resource that the reference points to. It can link to any compatible resource using the global JNDI names.</source>
          <target state="translated">참조가 가리키는 자원의 이름입니다. 글로벌 JNDI 이름을 사용하여 호환 가능한 모든 자원에 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1292f65aa82f44923949346d4e1e691d616e2a33" translate="yes" xml:space="preserve">
          <source>The name of the supported language.</source>
          <target state="translated">지원되는 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ea3ee1b66718d70c98586654a55a17d890a101c8" translate="yes" xml:space="preserve">
          <source>The name of the timer MBean registered.</source>
          <target state="translated">등록 된 타이머 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac8d30e1489df051168dc38caa12a3e3879c648b" translate="yes" xml:space="preserve">
          <source>The name of the unsupported charset</source>
          <target state="translated">지원되지 않는 문자 집합의 이름</target>
        </trans-unit>
        <trans-unit id="126564f90a129c4441e4a2c75da79a1d030e99b6" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-readable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용될 수있는 사람이 읽을 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="962ba302c34f721b90ce31af44446e3c52ade33c" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-writable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용할 수있는 사람이 쓸 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dd4993f396f86b98140b04a30ad081da0cc6b41" translate="yes" xml:space="preserve">
          <source>The name of this buffer pool.</source>
          <target state="translated">이 버퍼 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c533fca0bdf1847378d972e6408702bbaa3f035" translate="yes" xml:space="preserve">
          <source>The name of this class is taken from the terms used in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278&lt;/i&gt;&lt;/a&gt;. In that document a</source>
          <target state="translated">이 클래스의 이름은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278에&lt;/i&gt;&lt;/a&gt; 사용 된 용어에서 가져 왔습니다 . 그 문서에서</target>
        </trans-unit>
        <trans-unit id="6879a68caf1d6a7ab9d9a4a53cc53b346d66fe6f" translate="yes" xml:space="preserve">
          <source>The name parameter in the &lt;code&gt;addNamingListener()&lt;/code&gt; methods is referred to as the &lt;em&gt;target&lt;/em&gt;. The target, along with the scope, identify the object(s) that the listener is interested in. It is possible to register interest in a target that does not exist, but there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service.</source>
          <target state="translated">&lt;code&gt;addNamingListener()&lt;/code&gt; 메소드 의 이름 매개 변수를 &lt;em&gt;target&lt;/em&gt; 이라고합니다 . 대상은 범위와 함께 리스너가 관심있는 오브젝트를 식별합니다. 존재하지 않는 대상에 관심을 등록 할 수는 있지만이를 지원할 수있는 범위에는 제한이있을 수 있습니다. 서비스 제공자 및 기본 프로토콜 / 서비스.</target>
        </trans-unit>
        <trans-unit id="860c4f0c945e8ceccccb8c32dcd64ba5a09ada9e" translate="yes" xml:space="preserve">
          <source>The name separator</source>
          <target state="translated">이름 구분자</target>
        </trans-unit>
        <trans-unit id="35fd956615f3183b2a27cf861192a4328ba79011" translate="yes" xml:space="preserve">
          <source>The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific &lt;em&gt;default&lt;/em&gt; name separator. This separator is used when creating path strings by invoking the &lt;a href=&quot;path#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름 구분 기호는 경로 문자열에서 이름을 구분하는 데 사용됩니다. 구현시 여러 이름 구분 기호를 지원할 수 있으며이 경우이 메서드는 구현 별 &lt;em&gt;기본&lt;/em&gt; 이름 구분 기호를 반환합니다 . 이 구분 기호는 &lt;a href=&quot;path#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 경로 문자열을 작성할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5428a05faaeaed33e2f9ec7686064395200f6cf6" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered.</source>
          <target state="translated">MBean을 등록 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52573a98988fd98ad0050a1dc9a6c1143b22efbf" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered. This value must not be null. If the &lt;code&gt;name&lt;/code&gt; parameter is not null, it will usually but not necessarily be the returned value.</source>
          <target state="translated">MBean을 등록 할 이름입니다. 이 값은 null이 아니어야합니다. &lt;code&gt;name&lt;/code&gt; 매개 변수가 null이 아닌 경우 일반적으로 반환되는 값일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4ea4ead5eaedd88911039ea1b43c07d7392cc64" translate="yes" xml:space="preserve">
          <source>The named ClassLoader. If &lt;var&gt;l&lt;/var&gt; is the actual ClassLoader with that name, and &lt;var&gt;r&lt;/var&gt; is the returned value, then either:</source>
          <target state="translated">명명 된 ClassLoader 경우 &lt;var&gt;l&lt;/var&gt; 그 이름을 가진 실제 클래스 로더이고, &lt;var&gt;r&lt;/var&gt; 은 다음 중 반환 된 값입니다 :</target>
        </trans-unit>
        <trans-unit id="5c1d5b92b4e57a45a5307ad7f0334127b6e48d33" translate="yes" xml:space="preserve">
          <source>The named character construct, &lt;code&gt;\N{&lt;/code&gt;</source>
          <target state="translated">명명 된 문자 구조 &lt;code&gt;\N{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd3a4268a61dca16f11df59322f0d23569e1bd03" translate="yes" xml:space="preserve">
          <source>The named child node.</source>
          <target state="translated">명명 된 자식 노드</target>
        </trans-unit>
        <trans-unit id="5845346cc0cc0f0d59912000c5fce352fb493340" translate="yes" xml:space="preserve">
          <source>The names in &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; are to be resolved relative to the event source &lt;code&gt;source&lt;/code&gt;. For an &lt;code&gt;OBJECT_ADDED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; event type, &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; event type, one of &lt;code&gt;newBd&lt;/code&gt; or &lt;code&gt;oldBd&lt;/code&gt; may be null if the new or old binding is outside of the scope for which the listener has registered.</source>
          <target state="translated">&lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 의 이름 은 이벤트 소스 &lt;code&gt;source&lt;/code&gt; 기준으로 분석 됩니다. 를 들어 &lt;code&gt;OBJECT_ADDED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; 이벤트 유형, &lt;code&gt;oldBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 은 널 (null)이 아니어야합니다. 들어 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; 이벤트 타입 중 하나 &lt;code&gt;newBd&lt;/code&gt; 또는 &lt;code&gt;oldBd&lt;/code&gt; 는 (가) 또는 새로운 결합 이전 리스너가 등록되어있는 범위를 벗어나면 널이 될 수있다.</target>
        </trans-unit>
        <trans-unit id="f0a8616907b43c47c1c091877850ead64500f009" translate="yes" xml:space="preserve">
          <source>The names of the available metadata formats may be queried using the &lt;code&gt;getMetadataFormatNames&lt;/code&gt; method.</source>
          <target state="translated">사용 가능한 메타 데이터 형식의 이름은 &lt;code&gt;getMetadataFormatNames&lt;/code&gt; 메소드를 사용하여 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="252ba1c56374166baaa96e269996326d63427fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-day.</source>
          <target state="translated">오늘의 나노.</target>
        </trans-unit>
        <trans-unit id="5eab94f056909b0481546e3eec3879a8647f2fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-second.</source>
          <target state="translated">나노초.</target>
        </trans-unit>
        <trans-unit id="2bb5963aab34db2c750039ae2c23921252e470b4" translate="yes" xml:space="preserve">
          <source>The nanosecond field is set to zero.</source>
          <target state="translated">나노초 필드는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1f9f634c617722a2cc7a183fbeaa32e432ed0a" translate="yes" xml:space="preserve">
          <source>The nanosecond in second field is set to zero.</source>
          <target state="translated">두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="83d052126d41940b2289154ad002f598ff00e77e" translate="yes" xml:space="preserve">
          <source>The nanosecond-of-second value measures the total number of nanoseconds from the second returned by &lt;code&gt;getEpochSecond&lt;/code&gt;.</source>
          <target state="translated">나노초 값은 &lt;code&gt;getEpochSecond&lt;/code&gt; 가 반환 한 초부터 총 나노초 수를 측정합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9af2aeac2c5039b9c64536435d8f3fb400bacf" translate="yes" xml:space="preserve">
          <source>The native byte order of the hardware upon which this Java virtual machine is running</source>
          <target state="translated">이 Java 가상 머신이 실행되고있는 하드웨어의 원시 바이트 순서</target>
        </trans-unit>
        <trans-unit id="97bded427ee67f08fd9eb95689f83724ec8164db" translate="yes" xml:space="preserve">
          <source>The native character encoding of the Java programming language is UTF-16. A charset in the Java platform therefore defines a mapping between sequences of sixteen-bit UTF-16 code units (that is, sequences of chars) and sequences of bytes.</source>
          <target state="translated">Java 프로그래밍 언어의 기본 문자 인코딩은 UTF-16입니다. 따라서 Java 플랫폼의 문자 세트는 16 비트 UTF-16 코드 단위 시퀀스 (즉, 문자 시퀀스)와 바이트 시퀀스 간의 맵핑을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e72b8d07ae2a52493e69fa910beb1a9da83caf12" translate="yes" xml:space="preserve">
          <source>The natural ordering for a class &lt;code&gt;C&lt;/code&gt; is said to be</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 자연스러운 순서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b84120c20a6bdf6d7f5ae3856a89d9473555ad90" translate="yes" xml:space="preserve">
          <source>The negotiated SSL session</source>
          <target state="translated">협상 된 SSL 세션</target>
        </trans-unit>
        <trans-unit id="29d0ba30c08b06286e5f241683ca2b4246f089a6" translate="yes" xml:space="preserve">
          <source>The network class loader subclass must define the methods &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;loadClassData&lt;/code&gt; to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method &lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt;&lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; to create a class instance. A sample implementation is:</source>
          <target state="translated">네트워크 클래스 로더 서브 클래스는 &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;loadClassData&lt;/code&gt; 메소드를 정의하여 네트워크에서 클래스 를로드해야합니다. 클래스를 구성하는 바이트를 다운로드 한 후에는 &lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt; &lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 클래스 인스턴스를 작성 해야 합니다. 샘플 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60bdca0ec3065d96f7c4fa13ff060a6ac497223a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스</target>
        </trans-unit>
        <trans-unit id="67864d43181467d0e750e9cf2430f7984db2145a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams.</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c6fe308b0ca1ecd4664a44845bd1ebbb9f779e7d" translate="yes" xml:space="preserve">
          <source>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">네트워크 소프트웨어는 소켓에 의해 버퍼링 된 바이트를 버릴 수 있습니다. 네트워크 소프트웨어에서 버리지 않은 바이트는 read를 사용하여 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55670e5d5dd2d95a1600413eeec6cbda76a343d6" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac784c4d64146b5dcf94b8e436a19a6c04e1010d" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2735dd48d8041cfacd708718becc725a951d4601" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 메소드보다 새로운 &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7265ccc5d623c310cc3ac47a66fc5eed1ffa49bf" translate="yes" xml:space="preserve">
          <source>The new URI</source>
          <target state="translated">새로운 URI</target>
        </trans-unit>
        <trans-unit id="a2b375f7ec337d0b7321744b498b77bbbb43dc04" translate="yes" xml:space="preserve">
          <source>The new binding: information about the object after the change.</source>
          <target state="translated">새로운 바인딩 : 변경 후 객체에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="a9f750a1ec47c53e6933e7367f0dd037a6159afe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="b87cda267359dfa7e6d3c0f1f70075ab22125777" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3a25bef4c13a14c4415962bc64f251e299155ad6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="0d2674995ec7db927894a48c261ddea8d595a398" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="35306637861eed16af88b4e2dfb5c1e37c341a44" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="8dceaea7882e5d50ea82b5e02eaccd6768f24042" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="a4320fd76f9f4ca139f58312ae6d89d82b8751b8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7911665bb7451ce6034993a67b89354cf0e0fe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3fd84a12e6c22a3ee3939f3f6a961f726d7f5c1a" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c8228e64f023a9d3a8c7700654a22211275f6638" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b259e53add3a5528efdfbd8e55c0de407403a961" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="78548868dc1648694724e198deaa1f84f096b4c8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="d08a08b839ac302da9552db1b3bb522b1eeb1ba6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="b7616ef26b29d3dbc28547aecc940e0b07b48cc8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c14e82168abd4ac4df9c13b98e0a4c8e7cfc8643" translate="yes" xml:space="preserve">
          <source>The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt;, and its limit will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼는이 버퍼의 내용을 공유합니다. 즉,이 버퍼의 내용이 변경 가능한 경우 한 버퍼를 수정하면 다른 버퍼가 수정됩니다. 새로운 버퍼의 용량은이 버퍼의 용량이며, 위치는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt; 이며, 한계는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt; 입니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="7d665df25b33f41e16e1676893f85747fee6206b" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1441a0ea6ee677b09ef764abcace356aff8ffb6a" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="a13d0be56226b191c2b44377cfe1a92626a44776" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 8로 나눈 값이되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="90552048b6aa0101e52962a0d5b974862e391b43" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 4로 나눈 값이되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="cfc7272e6b5899b3b2bcbd70bb498a4197e3a159" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 2로 나눈 값이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="9a09a10dc3d2fc25e63569ae94bfd86cd530afbc" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="fba588f426f87edc19c14d7f0682ef96259b59dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 문자 수이며 표시는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f0973afd84caee05155e2681a55128180674a18a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 그 용량과 한계는이 버퍼에 남아있는 더블의 수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="8222a6605391ceeccd212b79d0de137bdee941ea" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 플로트의 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="409703dd3fa5e15595f45b7bfa97d23dfc879f75" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 정수의 개수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="184e102258e542a41b9bc5bd5712cf1b45f7ba82" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 길이의 수이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="db4d05da05e11921709f2c45d3cc55f4a61dcdd8" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 쇼트 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e873cc2a43337dc6d0f48726bcbfe54afbbbb3dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0bc120342e8b1870b356b3688bd19e6b6d771658" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="4499f8809b64cea17e4ae935e38e57b0f0d75938" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="98fcf6ac3b1e8e48717c044627e4568fcf5fbd06" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b824b2632dba5cfa58058d0964f1ea0de5c6b90e" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0f405c739bacda631028ecb69ab8e7e2935ea317" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="ab6d02b7d7ce9994222ab6506d8bcc54c8589506" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b9f0b692e41b510f435757041e930b3ca3d5e9be" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. Whether or not it has a &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; is unspecified.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 이 있는지 여부 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1662b58ac08c19eb90fcbe51af1d61f93d2d097" translate="yes" xml:space="preserve">
          <source>The new byte buffer</source>
          <target state="translated">새로운 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="a45f4c65b0bb36650376b631e6594f501b8c823a" translate="yes" xml:space="preserve">
          <source>The new channel</source>
          <target state="translated">새로운 채널</target>
        </trans-unit>
        <trans-unit id="a0c64b8684bdcf86946498ab7c59c1c46403fb26" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newFileChannel&lt;/code&gt;&lt;/a&gt; method on the provider that created the &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">새 채널은 &lt;code&gt;Path&lt;/code&gt; 를 작성한 제공자 에서 &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newFileChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="30644cb35aeeea5e1c72b112f048cacccf59280e" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object that created the given group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">지정된 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 새 채널을 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa05ef1e428bfbeed57a213a4e34a9d9876bffe" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; that created the group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a7232600a19d5c749f1ed775c91b5c69237ecde" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3805a8ad4425a07e7b9601f1dc5f49f6555fb05" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="640a2a8aa11bc64a4a6a49aefd39e43c327cdc4d" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt;&lt;code&gt;openServerSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt; &lt;code&gt;openServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3c960cf1b6fdeb74926d0f06d9ebb63c6b2bfe2" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt;&lt;code&gt;openSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt; &lt;code&gt;openSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="4166a9ca9c991a66f299641f2e32e0fece1a98ba" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before connections can be accepted.</source>
          <target state="translated">새로운 채널의 소켓은 초기에 언 바운드입니다. 연결을 수락하기 전에 소켓의 &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="405a847e27c80c831a52b3ca25e1aee97b0b63cd" translate="yes" xml:space="preserve">
          <source>The new char buffer</source>
          <target state="translated">새로운 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="a3bfde5271747a153dbc45be6dd7b2fa8d92c106" translate="yes" xml:space="preserve">
          <source>The new character buffer</source>
          <target state="translated">새로운 캐릭터 버퍼</target>
        </trans-unit>
        <trans-unit id="105e02b325849c87768426ba794cd482fa2cf5d4" translate="yes" xml:space="preserve">
          <source>The new context has the same environment properties and connection request controls as this context. See the class description for details. Implementations might also allow this context and the new context to share the same network connection or other resources if doing so does not impede the independence of either context.</source>
          <target state="translated">새 컨텍스트에는이 컨텍스트와 동일한 환경 특성 및 연결 요청 제어가 있습니다. 자세한 내용은 수업 설명을 참조하십시오. 구현시이 컨텍스트와 새 컨텍스트가 동일한 네트워크 연결 또는 다른 리소스를 공유 할 수 있으므로 컨텍스트의 독립성을 방해하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32225c2b2a4cd61beeafae6360573239239143d8" translate="yes" xml:space="preserve">
          <source>The new directory stream, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon newly created directory stream.</source>
          <target state="translated">일단 작성된 새 디렉토리 스트림은이를 작성하는 데 사용 된 디렉토리 스트림에 종속되지 않습니다. 이 디렉토리 스트림을 닫아도 새로 작성된 디렉토리 스트림에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1472dd980957833880e469fd869da118a620a1d" translate="yes" xml:space="preserve">
          <source>The new double buffer</source>
          <target state="translated">새로운 더블 버퍼</target>
        </trans-unit>
        <trans-unit id="2f0532ed60ab4132dd9d65f7412ae3fdaace63d3" translate="yes" xml:space="preserve">
          <source>The new float buffer</source>
          <target state="translated">새로운 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="1f6194d825d6dc0688d142cdf98fae1e64221945" translate="yes" xml:space="preserve">
          <source>The new int buffer</source>
          <target state="translated">새로운 int 버퍼</target>
        </trans-unit>
        <trans-unit id="16916b8d2254968908c21ac68fdf72fdd3794032" translate="yes" xml:space="preserve">
          <source>The new iterator</source>
          <target state="translated">새로운 반복자</target>
        </trans-unit>
        <trans-unit id="779eee0d9cf7a611f52c9afc435db4ffc9a7b2aa" translate="yes" xml:space="preserve">
          <source>The new long buffer</source>
          <target state="translated">새로운 긴 버퍼</target>
        </trans-unit>
        <trans-unit id="a049a6df3cdeeeac083a1b0492d8837e20ab7728" translate="yes" xml:space="preserve">
          <source>The new method handle, when invoked, will perform the following steps:</source>
          <target state="translated">새 메소드 핸들은 호출 될 때 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c7edac962c9fdf5e1ed3e30ef75f9b85854bb6c3" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor DeflaterOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 개의 인수 생성자 DeflaterOutputStream (out, false)을 호출하여 것처럼 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="17e00405c9d859e5ea535348ea74cc91e9987eea" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor GZIPOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 인수 생성자 GZIPOutputStream (out, false)을 호출하여 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eba31038050930f93163a540e115ac8b731c66f1" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor DeflaterOutputStream(out, def, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 DeflaterOutputStream (out, def, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d9335ad9c012ce1f2b92b1f6698fcccb2cb17791" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor GZIPOutputStream(out, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 GZIPOutputStream (out, size, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f12bbb4d87ec052fcf9300036f1e190a6c68064b" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 4-argument constructor DeflaterOutputStream(out, def, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 4- 인수 생성자 DeflaterOutputStream (out, def, size, false)을 호출하여 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d884f874f7014685b458a4af3391ba4d45f11053" translate="yes" xml:space="preserve">
          <source>The new pipe</source>
          <target state="translated">새로운 파이프</target>
        </trans-unit>
        <trans-unit id="2c83e22c89152847eb837b14970d1ac61dec5b58" translate="yes" xml:space="preserve">
          <source>The new pipe is created by invoking the &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt;&lt;code&gt;openPipe&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt; &lt;code&gt;openPipe&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 새 파이프가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e219b1425b7017143bc6b763f1e3479269fe8f77" translate="yes" xml:space="preserve">
          <source>The new process will invoke the command and arguments given by &lt;a href=&quot;processbuilder#command--&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;processbuilder#directory--&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;processbuilder#environment--&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 프로세스는 &lt;a href=&quot;processbuilder#environment--&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 주어진 프로세스 환경과 함께 &lt;a href=&quot;processbuilder#directory--&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 주어진 작업 디렉토리에서 &lt;a href=&quot;processbuilder#command--&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 주어진 명령과 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="95ac9042239c405df39132ca4d6a54dd4895fee9" translate="yes" xml:space="preserve">
          <source>The new selector</source>
          <target state="translated">새로운 선택기</target>
        </trans-unit>
        <trans-unit id="4d90a5fbf3072fbdd10fb888cd77c2fecc69894d" translate="yes" xml:space="preserve">
          <source>The new selector is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt;&lt;code&gt;openSelector&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 선택기는 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt; &lt;code&gt;openSelector&lt;/code&gt; &lt;/a&gt; 메소드를 호출함으로써 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="51a2e917f552d1b6e1f23856874476d3b036cddf" translate="yes" xml:space="preserve">
          <source>The new short buffer</source>
          <target state="translated">새로운 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="cdfb6de24569ebdf6e37ac2a01c85f6c9999b45a" translate="yes" xml:space="preserve">
          <source>The new string.</source>
          <target state="translated">새로운 문자열.</target>
        </trans-unit>
        <trans-unit id="256bfd55d3498eaaeab282ef6a86ba7b61007791" translate="yes" xml:space="preserve">
          <source>The new value for the preference, or &lt;code&gt;null&lt;/code&gt; if the preference was removed.</source>
          <target state="translated">환경 설정의 새 값 . 환경 설정이 제거 된 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca7055dc46762027e9a170faf3c4bd0af39a754d" translate="yes" xml:space="preserve">
          <source>The new value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 새로운 값으로, Object로 표현됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fed342089a94d554987b9df830e98f728b84e13" translate="yes" xml:space="preserve">
          <source>The new, read-only byte buffer</source>
          <target state="translated">새로운 읽기 전용 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="051bb43b66b4c67456aad2b704f6aa6b0ddd97f5" translate="yes" xml:space="preserve">
          <source>The new, read-only char buffer</source>
          <target state="translated">새로운 읽기 전용 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="5f53d1fe5257c7586da9f701a660008b6cdc42d4" translate="yes" xml:space="preserve">
          <source>The new, read-only double buffer</source>
          <target state="translated">새로운 읽기 전용 이중 버퍼</target>
        </trans-unit>
        <trans-unit id="ab388d6a1900bbf211a8682234f0d28e544b3f90" translate="yes" xml:space="preserve">
          <source>The new, read-only float buffer</source>
          <target state="translated">새로운 읽기 전용 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="f25346b335ad55392706741def759dd809ecac74" translate="yes" xml:space="preserve">
          <source>The new, read-only int buffer</source>
          <target state="translated">새로운 읽기 전용 int 버퍼</target>
        </trans-unit>
        <trans-unit id="38c3e68c7e1d834b8bc5df3c59964660afd47865" translate="yes" xml:space="preserve">
          <source>The new, read-only long buffer</source>
          <target state="translated">새로운 읽기 전용 롱 버퍼</target>
        </trans-unit>
        <trans-unit id="9632c9f4a41cbd94b91ee4867c7f6daa96d1578b" translate="yes" xml:space="preserve">
          <source>The new, read-only short buffer</source>
          <target state="translated">새로운 읽기 전용 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="c2c6f911faa099e683e433008f099f0a9b73bf5d" translate="yes" xml:space="preserve">
          <source>The newline (line feed) character (&lt;code&gt;'\u000A'&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 (줄 바꿈) 문자 ( &lt;code&gt;'\u000A'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c7384c3bb09727310bc462bab676b4596e47e94b" translate="yes" xml:space="preserve">
          <source>The newly constructed Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions.</source>
          <target state="translated">새로 구성된 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정되어 있는지 확인합니다 . 새로 생성 된 세트는 또한 발신자가 충분한 권한을 갖도록하여 불법 수정을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="3ecdb2179dd90bd6fc6af860dcdb167b3e9dd7a7" translate="yes" xml:space="preserve">
          <source>The newly created permission object replaces the UnresolvedPermission, which is removed.</source>
          <target state="translated">새로 만든 권한 개체가 제거 된 UnresolvedPermission을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="526425b0b2a6b0567b0294d2b4111ab89f47f622" translate="yes" xml:space="preserve">
          <source>The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread. The method &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; may be used to change whether or not a thread is a daemon.</source>
          <target state="translated">새로 작성된 스레드는 스레드를 작성하는 스레드가 현재 디먼 스레드로 표시되는 경우에만 데몬 스레드로 표시됩니다. &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; 메소드 는 스레드가 데몬인지 여부를 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1012a0ca0d70327fd286d7c29cb6bd15b1c082" translate="yes" xml:space="preserve">
          <source>The newly defined &lt;code&gt;Package&lt;/code&gt; object</source>
          <target state="translated">새롭게 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="e8a1d4d9b98ec9cdee82b685b8101093972dd311" translate="yes" xml:space="preserve">
          <source>The newly instantiated object.</source>
          <target state="translated">새로 인스턴스화 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6b1ca923fcbee792afab001c0bf4d34e084c719f" translate="yes" xml:space="preserve">
          <source>The next simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that sets the &lt;code&gt;nextFocusableComponent&lt;/code&gt; property of the target (myButton) object to the value of the &quot;source&quot; property of the event.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 다음으로 가장 간단한 용도 는 리스너 인터페이스에서 메소드의 첫 번째 인수 (일반적으로 이벤트 오브젝트)에서 특성 값을 추출하고이를 사용하여 대상 오브젝트에서 특성 값을 설정하는 것입니다. 다음 예제 에서는 대상 (myButton) 객체 의 &lt;code&gt;nextFocusableComponent&lt;/code&gt; 속성을 이벤트의 &quot;source&quot;속성 값으로 설정 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f9a2faf9fb3b9f8ae2040c7c4e5d190ce7ecc0af" translate="yes" xml:space="preserve">
          <source>The next type of ID are offset-style IDs with some form of prefix, such as 'GMT+2' or 'UTC+01:00'. The recognised prefixes are 'UTC', 'GMT' and 'UT'. The offset is the suffix and will be normalized during creation. These IDs can be normalized to a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;code&gt;normalized()&lt;/code&gt;.</source>
          <target state="translated">다음 유형의 ID는 'GMT + 2'또는 'UTC + 01 : 00'과 같은 접두사 형식의 오프셋 스타일 ID입니다. 인식되는 접두사는 'UTC', 'GMT'및 'UT'입니다. 오프셋은 접미사이며 작성 중에 정규화됩니다. 이 ID는 &lt;code&gt;normalized()&lt;/code&gt; 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 으로 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e44f1d28b1ed0c6128cf75964dda2af57cb4bc43" translate="yes" xml:space="preserve">
          <source>The node at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NodeList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">상기 노드 &lt;code&gt;index&lt;/code&gt; 번째 위치에서 상기 &lt;code&gt;NodeList&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 인덱스가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="2244b9f1c988f6ab45e1adc3aeaad05d28dd975b" translate="yes" xml:space="preserve">
          <source>The node that was added or removed.</source>
          <target state="translated">추가 또는 제거 된 노드입니다.</target>
        </trans-unit>
        <trans-unit id="4c914679c177f8361a70044b7d9e5fed26293161" translate="yes" xml:space="preserve">
          <source>The node value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 노드 값입니다.</target>
        </trans-unit>
        <trans-unit id="5bbeb5b168502d18da4f1fe9867711841ff15466" translate="yes" xml:space="preserve">
          <source>The node value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">노드 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 UUID가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2c083ad90bd1defea28a63436df660a7fd1208e" translate="yes" xml:space="preserve">
          <source>The node value of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 노드 치</target>
        </trans-unit>
        <trans-unit id="abbf56635d9b1770e8f377f88d7eb5625296e6d7" translate="yes" xml:space="preserve">
          <source>The non-negative number of components in this LDAP name.</source>
          <target state="translated">이 LDAP 이름에서 음수가 아닌 수의 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0ec6632ce3dac4952c6d1e6de9a5a4ac96bd4964" translate="yes" xml:space="preserve">
          <source>The non-negative number of type/value pairs in this Rdn.</source>
          <target state="translated">이 Rdn에서 음수가 아닌 유형 / 값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="04c40e79aa1d2b145632c16a6ba96e3ddd6f6561" translate="yes" xml:space="preserve">
          <source>The non-null &lt;code&gt;EventContext&lt;/code&gt; that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 &lt;code&gt;EventContext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9835e454d9aa1da3cda1a5d111588c0dd9c03234" translate="yes" xml:space="preserve">
          <source>The non-null Attribute ID of the sort key.</source>
          <target state="translated">정렬 키의 널이 아닌 속성 ID.</target>
        </trans-unit>
        <trans-unit id="72f787f2a198f8fedf6cb84c6fe0b5e362381096" translate="yes" xml:space="preserve">
          <source>The non-null RDN at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 RDN입니다.</target>
        </trans-unit>
        <trans-unit id="e27f3c4b638ce7540d85488b7dcdab9e1e5afc40" translate="yes" xml:space="preserve">
          <source>The non-null Reference of this object.</source>
          <target state="translated">이 객체의 null 이외의 Reference</target>
        </trans-unit>
        <trans-unit id="3a820348b05a92e3255fb97f0c53e3ffddc88be6" translate="yes" xml:space="preserve">
          <source>The non-null address type of this address.</source>
          <target state="translated">이 주소의 널이 아닌 주소 유형.</target>
        </trans-unit>
        <trans-unit id="d2201b95b88b6f901440dc4bbfb1317bf8e7ee42" translate="yes" xml:space="preserve">
          <source>The non-null attribute to use for the modification.</source>
          <target state="translated">수정에 사용할 널이 아닌 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c9313ebf57ec9424f831b52f67bbfc348328c4ee" translate="yes" xml:space="preserve">
          <source>The non-null attribute type.</source>
          <target state="translated">널이 아닌 속성 유형.</target>
        </trans-unit>
        <trans-unit id="e8b69252e6ee01638d108902e5793b76660660f5" translate="yes" xml:space="preserve">
          <source>The non-null attribute value.</source>
          <target state="translated">널이 아닌 속성 값.</target>
        </trans-unit>
        <trans-unit id="2715e88a065e5152070b841d877e00fdf01a9b7e" translate="yes" xml:space="preserve">
          <source>The non-null attributes containing the type/value mappings of this Rdn.</source>
          <target state="translated">이 Rdn의 형태 / 치의 매핑을 포함한 null 이외의 속성</target>
        </trans-unit>
        <trans-unit id="e7d5ad9946b78e64d8017c4154edc754f5fde616" translate="yes" xml:space="preserve">
          <source>The non-null attributes in this search result. Can be empty.</source>
          <target state="translated">이 검색 결과의 널이 아닌 속성입니다. 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e85cdf81db9eeec068d8d09a8ef2fb4c407fd0" translate="yes" xml:space="preserve">
          <source>The non-null buffer containing this address's contents.</source>
          <target state="translated">이 주소의 내용을 포함한 null 이외의 버퍼</target>
        </trans-unit>
        <trans-unit id="3d9f08aa3696853e49ea210dd84b71a816664327" translate="yes" xml:space="preserve">
          <source>The non-null cached initial context.</source>
          <target state="translated">널이 아닌 캐시 된 초기 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="ff3c6126fdf1cc140a98a5cb1cbb91b07b9dae34" translate="yes" xml:space="preserve">
          <source>The non-null component at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a0cd8693286f7ab03bf8dfc7ae7e3825ff062d8e" translate="yes" xml:space="preserve">
          <source>The non-null context at which to continue the method.</source>
          <target state="translated">메소드를 계속할 널이 아닌 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="d451c4f1e3abd2fc769f4b6cdd808b41cafdf4b1" translate="yes" xml:space="preserve">
          <source>The non-null context that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6ccd0c9d630cefab9c9188537f5d448330d7fbd1" translate="yes" xml:space="preserve">
          <source>The non-null fully-qualified class name of the object. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">객체의 null이 아닌 정규화 된 클래스 이름입니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="55a9d1f6cd92ef1fb0cc4c11ee02219bb6a9c640" translate="yes" xml:space="preserve">
          <source>The non-null name of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="379e7340b01855217e56feddfd0c3f522ce31421" translate="yes" xml:space="preserve">
          <source>The non-null name of this link.</source>
          <target state="translated">이 링크의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="42b9a5b2a8d6c68424fd72083172c212655d9589" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string representing the LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; component.</source>
          <target state="translated">LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; 구성 요소를 나타내는 널이 아닌 오브젝트 ID 문자열 .</target>
        </trans-unit>
        <trans-unit id="2cb882abf23a7aa368fb5faa23b533a76c55bbc5" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string.</source>
          <target state="translated">널이 아닌 오브젝트 ID 문자열.</target>
        </trans-unit>
        <trans-unit id="b295dc0fd888ea6d48259db4af3e90633d18ef36" translate="yes" xml:space="preserve">
          <source>The non-null object representing &lt;code&gt;obj&lt;/code&gt;'s state for binding. It could be the object (&lt;code&gt;obj&lt;/code&gt;) itself.</source>
          <target state="translated">바인딩의 &lt;code&gt;obj&lt;/code&gt; 상태를 나타내는 null 이외의 객체 객체 ( &lt;code&gt;obj&lt;/code&gt; ) 자체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f69773c16095a881d10252c9218f6c6e3c34b88" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation of this exception.</source>
          <target state="translated">이 예외의 캐릭터 라인 표현을 포함한 null 이외의 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="44e96a35fa5e2445cf72315bf35956f839cecc36" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation.</source>
          <target state="translated">문자열 표현을 포함하는 널이 아닌 문자열.</target>
        </trans-unit>
        <trans-unit id="b5944a034b359b83174f56a2a7f96839e7b38494" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this address.</source>
          <target state="translated">이 주소의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c14b6c44d0bf24b5cea45b3da8630bae20b53ad4" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this attribute.</source>
          <target state="translated">이 속성의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="e489b76b389ad519e5854a5f41ece2a22837acbc" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="5bd52f1e3944566dde82d6b472de7f01b46708e3" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this exception.</source>
          <target state="translated">이 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="42db8fc25d73e560ebf5468300a8bc2116164162" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this link exception.</source>
          <target state="translated">이 링크 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="514dc42a6376eec82b1d1ca24105735005dbb207" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this modification item.</source>
          <target state="translated">이 수정 아이템의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c944d1dbf9885fa579e084db281b25ba8d8a9512" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this reference.</source>
          <target state="translated">이 참조의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="f67fe15778905975a7fa5a2327a8581b53a9f83e" translate="yes" xml:space="preserve">
          <source>The non-null unsolicited notification that caused this event to be fired.</source>
          <target state="translated">이 이벤트를 발생시키는 널이 아닌 원치 않는 알림입니다.</target>
        </trans-unit>
        <trans-unit id="d47f97097499b7920b445b44552f3b93fe502268" translate="yes" xml:space="preserve">
          <source>The nonnegative number of addresses in this reference.</source>
          <target state="translated">이 참조에서 음수가 아닌 주소 수입니다.</target>
        </trans-unit>
        <trans-unit id="763b0638d66b2e279fdcda534bfb0307f9e14a5c" translate="yes" xml:space="preserve">
          <source>The nonnegative number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 음수가 아닌 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="27a92262272f2e066164e4797757c92e88b495a7" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this composite name.</source>
          <target state="translated">이 컴퍼 짓 이름의 음수가 아닌 수의 컴포넌트.</target>
        </trans-unit>
        <trans-unit id="2ae208f4c4b22b7904207d628361c77d6ba61f42" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this compound name.</source>
          <target state="translated">이 화합물 명의 음수가 아닌 수의 성분.</target>
        </trans-unit>
        <trans-unit id="933031459aff054e43a842b4fd2dd5ed57b4a079" translate="yes" xml:space="preserve">
          <source>The nonnegative number of values in this attribute.</source>
          <target state="translated">이 속성의 음수가 아닌 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="f552faffb0355ddf1b05a015bb7baf11154da3d5" translate="yes" xml:space="preserve">
          <source>The normal argument conversion rules for &lt;code&gt;MethodHandle.invoke&lt;/code&gt; apply to all stacked arguments. For example, if a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">&lt;code&gt;MethodHandle.invoke&lt;/code&gt; 의 일반 인수 변환 규칙은 모든 누적 인수에 적용됩니다. 예를 들어, 푸시 된 값이 기본 유형 인 경우 복싱 변환을 통해 참조로 변환 될 수 있습니다. 부트 스트랩 방법이 가변 arity 방법 인 경우 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; 이 설정 됨) 여기에 지정된 인수 중 일부 또는 전부가 후행 배열 매개 변수로 수집 될 수 있습니다. (이것은 특별한 규칙이 아니라 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수, 변수 arity 메소드의 수정 자 비트 및 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 변환 간의 상호 작용으로 인한 유용한 결과입니다 .)</target>
        </trans-unit>
        <trans-unit id="92e831571304f766e53b7678f2c8bc953d39e95a" translate="yes" xml:space="preserve">
          <source>The normal use of the &quot;privileged&quot; feature is as follows. If you don't need to return a value from within the &quot;privileged&quot; block, do the following:</source>
          <target state="translated">&quot;권한있는&quot;기능의 일반적인 사용법은 다음과 같습니다. &quot;privileged&quot;블록 내에서 값을 반환 할 필요가 없으면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1713b6c492038d81b6717f471a6bc21770c3edef" translate="yes" xml:space="preserve">
          <source>The normalization checks if the rules of this &lt;code&gt;ZoneId&lt;/code&gt; have a fixed offset. If they do, then the &lt;code&gt;ZoneOffset&lt;/code&gt; equal to that offset is returned. Otherwise &lt;code&gt;this&lt;/code&gt; is returned.</source>
          <target state="translated">정규화는이 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙에 고정 오프셋 이 있는지 확인합니다 . 그렇게 하면 해당 오프셋과 같은 &lt;code&gt;ZoneOffset&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;this&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cd0ae79d9cf181d6f2f03a35a1f43855bdc7fd" translate="yes" xml:space="preserve">
          <source>The normalized String</source>
          <target state="translated">정규화 된 문자열</target>
        </trans-unit>
        <trans-unit id="b815b7a69fff83a89aecb794ceb17aa59e315dbf" translate="yes" xml:space="preserve">
          <source>The notification emitted is a &lt;a href=&quot;../../../javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; instance whose &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt;&lt;code&gt;user data&lt;/code&gt;&lt;/a&gt; is set to a &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt; that represents a &lt;a href=&quot;memorynotificationinfo&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt; object containing information about the memory pool when the notification was constructed. The &lt;code&gt;CompositeData&lt;/code&gt; contains the attributes as described in &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;MemoryNotificationInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 알림은 &lt;a href=&quot;../../../javax/management/notification#setUserData-java.lang.Object-&quot;&gt; &lt;code&gt;user data&lt;/code&gt; &lt;/a&gt; 가 알림이 생성 될 때 메모리 풀에 대한 정보를 포함 하는 &lt;a href=&quot;memorynotificationinfo&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; 객체 를 나타내는 &lt;a href=&quot;../../../javax/management/openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 로 설정된 &lt;a href=&quot;../../../javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 . &lt;code&gt;CompositeData&lt;/code&gt; 에은 에 설명 된대로 속성을 포함 &lt;a href=&quot;memorynotificationinfo#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;MemoryNotificationInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d43792640468618be4943696b58814c5982d2f01" translate="yes" xml:space="preserve">
          <source>The notification sequence number within the source object. It's a serial number identifying a particular instance of notification in the context of the notification source. The notification model does not assume that notifications will be received in the same order that they are sent. The sequence number helps listeners to sort received notifications.</source>
          <target state="translated">소스 객체 내의 알림 시퀀스 번호입니다. 알림 소스와 관련하여 특정 알림 인스턴스를 식별하는 일련 번호입니다. 통지 모델은 통지가 송신 된 순서와 동일한 순서로 수신된다고 가정하지 않습니다. 시퀀스 번호는 리스너가 수신 된 알림을 정렬하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="047c41230a085945fb649a5ebbbac0f9cc2023e7" translate="yes" xml:space="preserve">
          <source>The notification source and a set of parameters concerning the monitor MBean's state need to be specified when creating a new object of this class. The list of notifications fired by the monitor MBeans is the following:</source>
          <target state="translated">이 클래스의 새 오브젝트를 작성할 때 모니터 MBean 상태에 관한 알림 소스 및 매개 변수 세트를 지정해야합니다. 모니터 MBean에 의해 발생 된 통지 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5e52f5aa1ac9e3d0cc53022642f1d2fa738c7f5" translate="yes" xml:space="preserve">
          <source>The notification timestamp.</source>
          <target state="translated">알림 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="1cc0bdffa957699c3503e9a21edd9c5510954093" translate="yes" xml:space="preserve">
          <source>The notification type is one of the following:</source>
          <target state="translated">알림 유형은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="54f36e19da8052d6b002a6408bea252c14dac4d8" translate="yes" xml:space="preserve">
          <source>The notification type. It's a string expressed in a dot notation similar to Java properties. It is recommended that the notification type should follow the reverse-domain-name convention used by Java package names. An example of a notification type is com.example.alarm.router.</source>
          <target state="translated">알림 유형 Java 특성과 유사한 점 표기법으로 표현 된 문자열입니다. 알림 유형은 Java 패키지 이름에서 사용하는 역 도메인 이름 규칙을 따라야합니다. 알림 유형의 예는 com.example.alarm.router입니다.</target>
        </trans-unit>
        <trans-unit id="1924a5b15b3249ce092a029bd89121d0f77e325f" translate="yes" xml:space="preserve">
          <source>The notification.</source>
          <target state="translated">알림.</target>
        </trans-unit>
        <trans-unit id="fab265b6684bbffb1f218488bc04b79bf0141ad3" translate="yes" xml:space="preserve">
          <source>The null byte &lt;code&gt;'\u0000'&lt;/code&gt; is encoded in 2-byte format rather than 1-byte, so that the encoded strings never have embedded nulls.</source>
          <target state="translated">널 바이트 &lt;code&gt;'\u0000'&lt;/code&gt; 은 1 바이트가 아닌 2 바이트 형식으로 인코딩되므로 인코딩 된 문자열에 널이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b8e10011b092d252f9eb3176c082893795abb5d" translate="yes" xml:space="preserve">
          <source>The null character &lt;code&gt;'\u0000'&lt;/code&gt; and characters in the range &lt;code&gt;'\u0080'&lt;/code&gt; to &lt;code&gt;'\u07FF'&lt;/code&gt; are represented by a pair of bytes:</source>
          <target state="translated">널 문자 &lt;code&gt;'\u0000'&lt;/code&gt; 범위의 문자 &lt;code&gt;'\u0080'&lt;/code&gt; 에 &lt;code&gt;'\u07FF'&lt;/code&gt; 바이트 쌍으로 표현된다 :</target>
        </trans-unit>
        <trans-unit id="fdf012dbbee5e63f7359a0dcd636e783461bf0ec" translate="yes" xml:space="preserve">
          <source>The null type.</source>
          <target state="translated">널 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bfa4624adbb58928ef8efb29a2f80d2c80dac18c" translate="yes" xml:space="preserve">
          <source>The null value.</source>
          <target state="translated">널값.</target>
        </trans-unit>
        <trans-unit id="62bb929eddf4e5076a6c1af6a73ff7f12b318660" translate="yes" xml:space="preserve">
          <source>The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers in dates and times. Subclasses should initialize this to a number format appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DateFormat&lt;/code&gt; 이 날짜 및 시간 의 숫자를 형식화하는 데 사용하는 숫자 형식 기입니다 . 서브 클래스는 이것을이 &lt;code&gt;DateFormat&lt;/code&gt; 에 관련한 로케일에 적절한 수치 형식으로 초기화 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e937f460d16c2dd03c469010edefe2fdea52818a" translate="yes" xml:space="preserve">
          <source>The number is equal to or greater than 70 and followed by a space, comma, slash, or end of string</source>
          <target state="translated">숫자는 70 이상이며 공백, 쉼표, 슬래시 또는 문자열 끝이 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="20c65393a3bac9d4d95cbcb35c3376b737c51fb4" translate="yes" xml:space="preserve">
          <source>The number is less than 70, and both a month and a day of the month have already been recognized</source>
          <target state="translated">숫자는 70보다 작으며 한 달과 한 달이 이미 인식되었습니다.</target>
        </trans-unit>
        <trans-unit id="1cc438c896ef962d5026bc123197b09edc413720" translate="yes" xml:space="preserve">
          <source>The number is regarded as a year number if one of the following conditions is true:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 숫자는 연도 숫자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="df8cbf65b57833acddb4ff0a78d9a0353df9a3f4" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;char&lt;/code&gt; values added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 &lt;code&gt;char&lt;/code&gt; 값 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="f3a97128719266ddb790af1c18af9062d75593ec" translate="yes" xml:space="preserve">
          <source>The number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="6ec090dddd82f048df0c06bf0d557ff56e2af995" translate="yes" xml:space="preserve">
          <source>The number of audio channels in this format (1 for mono, 2 for stereo).</source>
          <target state="translated">이 형식의 오디오 채널 수입니다 (모노의 경우 1, 스테레오의 경우 2).</target>
        </trans-unit>
        <trans-unit id="ebe508295acf5978d83f70bb43c4b3bd8b4274fb" translate="yes" xml:space="preserve">
          <source>The number of available bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. On systems where this information is not available, this method will be equivalent to a call to &lt;a href=&quot;file#getFreeSpace--&quot;&gt;&lt;code&gt;getFreeSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 사용 가능한 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 정보를 사용할 수없는 시스템에서이 메소드는 &lt;a href=&quot;file#getFreeSpace--&quot;&gt; &lt;code&gt;getFreeSpace()&lt;/code&gt; &lt;/a&gt; 호출에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="1130b4382f1b7fe878fe4148c6bceffdb27b5491" translate="yes" xml:space="preserve">
          <source>The number of bits in each sample of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 각 사운드 샘플의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2c6ef0f30695893dbdb9d64573a808a0335d172d" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;byte&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="15e790ed5a0a48d5374c994c58d90003c84875ca" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form, constant &lt;code&gt;16&lt;/code&gt;.</source>
          <target state="translated">부호없는 이진 형식으로 상수 &lt;code&gt;16&lt;/code&gt; 을 &lt;code&gt;char&lt;/code&gt; 값 으로 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="262c8f5ae61f9348f39f6db260ec423eb0e0fc41" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="db7608f15c88ac6b6517884137b2698cc2061366" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e0bfa0a3ed9120efd3be680d6da69e3fb3b7ff5a" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8b6311d22d425e5b3c17619c262b0fb241a15127" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="11b4eca6a42f5c3d86eeb7e9b58d5fd4c96c3c69" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="17d4e70f10cd5538ecaddea27e5925f3b39b1260" translate="yes" xml:space="preserve">
          <source>The number of bytes in each frame of a sound that has this format.</source>
          <target state="translated">이 형식을 가진 사운드의 각 프레임에있는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="10ce5b479dd18c652ab8267df15337a3c496022c" translate="yes" xml:space="preserve">
          <source>The number of bytes in the MIDI message, including the status byte and any data bytes.</source>
          <target state="translated">상태 바이트 및 데이터 바이트를 포함한 MIDI 메시지의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d13a4622dc0f210135891bcff08ace66977b3820" translate="yes" xml:space="preserve">
          <source>The number of bytes of primitive data available to be read in the current buffer.</source>
          <target state="translated">현재 버퍼에서 읽을 수있는 기본 데이터의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cfdd8b77cfc1f1b2a6f5515e18f818690cf800f0" translate="yes" xml:space="preserve">
          <source>The number of bytes read, or -1 if the end of the stream has already been reached</source>
          <target state="translated">읽은 바이트 수 또는 스트림 끝에 이미 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="cbcb5512c2972dbeb5124314fe8397ab9324ba4c" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero</source>
          <target state="translated">읽은 바이트 수, 아마도 0</target>
        </trans-unit>
        <trans-unit id="e54fa04ce29f88473805b5e56fe5895a6e99f815" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the channel has reached end-of-stream</source>
          <target state="translated">읽은 바이트 수 (0 일 수 있음) 또는 채널이 스트림 끝에 도달 한 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2adccbd80eaab01d04b629a86d5b76357c7316e9" translate="yes" xml:space="preserve">
          <source>The number of bytes read, possibly zero, or &lt;code&gt;-1&lt;/code&gt; if the given position is greater than or equal to the file's current size</source>
          <target state="translated">읽은 바이트 수 (0 또는 가능)- 주어진 위치가 파일의 현재 크기보다 크거나 같은 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57a7079e650bee5a8a354dd28ed5d308b1f47e06" translate="yes" xml:space="preserve">
          <source>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</source>
          <target state="translated">전송 된 바이트 수.이 메소드가 호출 될 때 소스 버퍼에 남아있는 바이트 수이거나이 채널이 비 블로킹 인 경우 기본 데이터 그램의 데이터 그램에 대한 공간이 충분하지 않으면 0이 될 수 있습니다. 출력 버퍼</target>
        </trans-unit>
        <trans-unit id="9e97ccf1d843b3b3580662091dfd95f1358e8031" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be read without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be read without blocking, there is no guarantee that attempts to read additional data will block.)</source>
          <target state="translated">차단없이 읽을 수있는 바이트 수 는 &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 의 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드를 사용하여 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 읽을 수는 있지만 추가 데이터를 읽으려고하면 차단 될 것이라는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="f0013bec32edf3c0c9dad2765e90a066acc9e7ad" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written without blocking can be ascertained using the &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of the &lt;code&gt;DataLine&lt;/code&gt; interface. (While it is guaranteed that this number of bytes can be written without blocking, there is no guarantee that attempts to write additional data will block.)</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;DataLine&lt;/code&gt; 인터페이스 메소드를 사용하여 차단하지 않고 쓸 수있는 바이트 수를 확인할 수 있습니다 . (이 바이트 수를 차단하지 않고 기록 할 수 있지만 추가 데이터 쓰기 시도가 차단된다는 보장은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="80f6fef15a305bb856be09b4ef7409dc0dfb2fc8" translate="yes" xml:space="preserve">
          <source>The number of bytes to be read must represent an integral number of sample frames, such that:</source>
          <target state="translated">읽을 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="4523152343dab6798c93c7c3562ed8220c409f7a" translate="yes" xml:space="preserve">
          <source>The number of bytes to write must represent an integral number of sample frames, such that:</source>
          <target state="translated">쓸 바이트 수는 다음과 같이 정수의 샘플 프레임 수를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="a610a04d9530184116d0938a5b3f9e488bba7801" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;byte&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;byte&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1796e9529f51151f2a6f5b7fcdc6d4bd70c786af" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;char&lt;/code&gt; value in unsigned binary form.</source>
          <target state="translated">부호없는 이진 형식으로 &lt;code&gt;char&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d71b8f32cede9bbb676411377aebced3b7d4c67" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="229d3c03b3ae3c1ed8f12a7910a48a2be5adc533" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;float&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="aa4672a7d102168489149e5d5e7d36728647ebc6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;int&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;int&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="dcc8fa85fe3017a1bc6d96fbdb414b709a9b995c" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;long&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;long&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="d331db734169c052769944e176d28ab646bccf3a" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a &lt;code&gt;short&lt;/code&gt; value in two's complement binary form.</source>
          <target state="translated">2의 보수 이진 형태 로 &lt;code&gt;short&lt;/code&gt; 값 을 나타내는 데 사용되는 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="ccba44d3bc4162d753710c71c12cf8138d21d82d" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the data output stream so far. If this counter overflows, it will be wrapped to Integer.MAX_VALUE.</source>
          <target state="translated">지금까지 데이터 출력 스트림에 쓴 바이트 수입니다. 이 카운터가 오버플로되면 Integer.MAX_VALUE로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f42b4506dd9b1a24e0be2228b3cc5e5f34c15a" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the output byte array</source>
          <target state="translated">출력 바이트 배열에 쓴 바이트 수</target>
        </trans-unit>
        <trans-unit id="6624a626639ad8ac1c8cb97de741a539df918fa9" translate="yes" xml:space="preserve">
          <source>The number of bytes written, possibly zero</source>
          <target state="translated">쓴 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="2e83b9c69c8e5617a17c757bc7b8be745b27a54c" translate="yes" xml:space="preserve">
          <source>The number of bytes, possibly zero, that were actually transferred</source>
          <target state="translated">실제로 전송 된 바이트 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="af7ab7cd4f3072661b7c20abd685bf0c436d55bc" translate="yes" xml:space="preserve">
          <source>The number of capturing groups in this matcher's pattern</source>
          <target state="translated">이 매처의 패턴에있는 캡처 그룹 수</target>
        </trans-unit>
        <trans-unit id="2f329af4f477cd85e689456398c923d81cd9c8c1" translate="yes" xml:space="preserve">
          <source>The number of channels (1 for mono, 2 for stereo, etc.), or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</source>
          <target state="translated">채널 수 (모노의 경우 1, 스테레오의 경우 2 등) 또는 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">실제로 건너 뛴 문자 수</target>
        </trans-unit>
        <trans-unit id="386f609288a9f0b220b6ac9838664b0f43846b2d" translate="yes" xml:space="preserve">
          <source>The number of characters added to the buffer, or -1 if this source of characters is at its end</source>
          <target state="translated">버퍼에 추가 된 문자 수 또는이 문자 소스가 끝에있는 경우 -1</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">읽은 문자 수 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="205c7f1702ff1d1066de34202d523525add5dd9e" translate="yes" xml:space="preserve">
          <source>The number of chars in the buffer.</source>
          <target state="translated">버퍼의 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="929430c1d8c5ac6d7a42cbccdfc2c26fcd50c43a" translate="yes" xml:space="preserve">
          <source>The number of days considered to define the first week of a month or year varies by culture. For example, the ISO-8601 requires 4 days (more than half a week) to be present before counting the first week.</source>
          <target state="translated">월 또는 연도의 첫 주를 정의하는 것으로 간주되는 일 수는 문화에 따라 다릅니다. 예를 들어, ISO-8601은 첫 주를 계산하기 전에 4 일 (1 주일 이상)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82d024cc379193ffdf9a30ee6d903c40b1cdc418" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to add. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">추가 할 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의에 기반합니다.</target>
        </trans-unit>
        <trans-unit id="080fc6c7c7c958c7b7e37d0533887be92a47406d" translate="yes" xml:space="preserve">
          <source>The number of days is multiplied by 86400 to obtain the number of seconds to subtract. This is based on the standard definition of a day as 24 hours.</source>
          <target state="translated">빼는 초 수를 얻기 위해 일 수에 86400을 곱합니다. 이는 하루 24 시간의 표준 정의에 기반합니다.</target>
        </trans-unit>
        <trans-unit id="4c5a8510ea5cd109d91d0cd1e886868f35891a33" translate="yes" xml:space="preserve">
          <source>The number of digit characters after the exponent character gives the minimum exponent digit count. There is no maximum. Negative exponents are formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix from the pattern. This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.</source>
          <target state="translated">지수 문자 뒤의 숫자는 최소 지수 숫자를 나타냅니다. 최대 값이 없습니다. 음수 지수는 패턴의 접두사와 접미사가 &lt;em&gt;아닌&lt;/em&gt; 지역화 된 빼기 부호를 사용하여 형식이 지정됩니다 . 이것은 &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt; 와 같은 패턴을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4b53b240407fd962e2dd3b27a91febfe24bbf171" translate="yes" xml:space="preserve">
          <source>The number of digits in the result for the fractional part of</source>
          <target state="translated">소수 부분에 대한 결과의 자릿수</target>
        </trans-unit>
        <trans-unit id="05d292761fd82f9f0dd80c9070f0ac52df331589" translate="yes" xml:space="preserve">
          <source>The number of dimensions of the new array must not exceed 255.</source>
          <target state="translated">새 배열의 차원 수는 255를 초과하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5a45d0d315d987c393e3a2c515c64048ccf875d3" translate="yes" xml:space="preserve">
          <source>The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. Field numbers range from &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 이 인식하는 고유 필드 수입니다 . 필드 번호 범위는 &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acd4fd691fac05bdf2d5e37af4276341169d50a8" translate="yes" xml:space="preserve">
          <source>The number of elements remaining in this buffer</source>
          <target state="translated">이 버퍼에 남아있는 요소의 수</target>
        </trans-unit>
        <trans-unit id="b2e83b34b6fc477f1ef053898329bc6fcb7133b3" translate="yes" xml:space="preserve">
          <source>The number of entries in the search result, or zero if unknown.</source>
          <target state="translated">검색 결과의 항목 수이거나 알 수없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="a84c6c62b5a42df25220cabbfa4124476735b0f2" translate="yes" xml:space="preserve">
          <source>The number of formal parameters for the executable this object represents</source>
          <target state="translated">이 객체가 나타내는 실행 파일의 형식 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="dfefc77d44f13f44ad950d4ebe9a5e1dcbcc6e1d" translate="yes" xml:space="preserve">
          <source>The number of frames played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="4edbcfc8aa45cc498cde3e783850921f5632be3c" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 3600을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="307478f090dcd23f5ff03bb51efd07fb84315e34" translate="yes" xml:space="preserve">
          <source>The number of hours is multiplied by 60 to obtain the number of seconds to subtract.</source>
          <target state="translated">빼는 초 수를 얻기 위해 시간 수에 60을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="78247313d86cd76765e1c133a2b09bbb32f29107" translate="yes" xml:space="preserve">
          <source>The number of instances of a serializable &lt;code&gt;BeanContextServceProvider&lt;/code&gt;.</source>
          <target state="translated">직렬화 가능한 &lt;code&gt;BeanContextServceProvider&lt;/code&gt; 의 인스턴스 수입니다 .</target>
        </trans-unit>
        <trans-unit id="3e1adaf0033f7bba7e092443336bc7fbe43cefde" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated</source>
          <target state="translated">준비 작업 세트가 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="4418abf384fb3ff1dd1752bbc4761bc8afef107c" translate="yes" xml:space="preserve">
          <source>The number of keys, possibly zero, whose ready-operation sets were updated by the selection operation</source>
          <target state="translated">준비 작업 세트가 선택 작업으로 업데이트 된 키 수 (0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="10c3a3ca6ddaa4e8f11f7782659de88cb00a5425" translate="yes" xml:space="preserve">
          <source>The number of nodes in the list. The range of valid child node indices is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.</source>
          <target state="translated">목록의 노드 수 유효한 자식 노드 인덱스의 범위는 0에서 &lt;code&gt;length-1&lt;/code&gt; 까지입니다.</target>
        </trans-unit>
        <trans-unit id="d0b15529b633a23cd3e86f0403d34390bbda7486" translate="yes" xml:space="preserve">
          <source>The number of parameters (parameter_count) is wrong for the method</source>
          <target state="translated">메소드의 매개 변수 수 (parameter_count)가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="305a1cc134b6c645204fd4641631706c7a3bf073" translate="yes" xml:space="preserve">
          <source>The number of pixels and scanlines to be used are calculated as follows.</source>
          <target state="translated">사용되는 픽셀 수와 스캔 라인은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b09023fb617952757d1c12c7474a0c419e6159" translate="yes" xml:space="preserve">
          <source>The number of samples played or recorded per second, for sounds that have this format.</source>
          <target state="translated">이 형식의 사운드에 대해 초당 재생 또는 녹음 된 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="9bbc1ff0553b0381a0869f137c83f31dcb608500" translate="yes" xml:space="preserve">
          <source>The number of scanlines to be used can be computed similarly.</source>
          <target state="translated">사용될 스캔 라인의 수는 유사하게 계산 될 수있다.</target>
        </trans-unit>
        <trans-unit id="be3893e01cc76c096f13435ff5df0b674f3d85d4" translate="yes" xml:space="preserve">
          <source>The number of sessions that can be stored in context can be limited.</source>
          <target state="translated">컨텍스트에 저장할 수있는 세션 수는 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc312459807625f373e756dee442f9bfa948a13e" translate="yes" xml:space="preserve">
          <source>The number of significant digits in the mantissa is the sum of the &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is unaffected by the maximum integer digits. For example, 12345 formatted with &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set the significant digits count to zero. The number of significant digits does not affect parsing.</source>
          <target state="translated">가수의 유효 자릿수는 &lt;em&gt;최소 정수&lt;/em&gt; 와 &lt;em&gt;최대 소수&lt;/em&gt; 자릿수 의 합이며 최대 정수 자릿수의 영향을받지 않습니다. 예를 들어 &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; 으로 형식이 지정된 12345 는 &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt; 입니다. 모든 자릿수를 표시하려면 유효 자릿수를 0으로 설정하십시오. 유효 자릿수는 구문 분석에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d91005939f84137a8df80f671cacf84df36e6b8" translate="yes" xml:space="preserve">
          <source>The number of subsampled pixels in a scanline is given by</source>
          <target state="translated">스캔 라인에서 서브 샘플링 된 픽셀 수는</target>
        </trans-unit>
        <trans-unit id="ff212c63b39ca97d00e31f372ba96ac08c1c2239" translate="yes" xml:space="preserve">
          <source>The number of timer notifications.</source>
          <target state="translated">타이머 알림 수입니다.</target>
        </trans-unit>
        <trans-unit id="19bd983290a225549adc50288431558c89bf12d7" translate="yes" xml:space="preserve">
          <source>The number of times that the memory usage has crossed a threshold when the notification was constructed. For usage threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;usage threshold
       count&lt;/code&gt;&lt;/a&gt;. For collection threshold notifications, this count will be the &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt;&lt;code&gt;collection usage threshold count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알림이 생성 될 때 메모리 사용량이 임계 값을 초과 한 횟수입니다. 사용 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다. 수집 임계 값 알림의 경우이 수는 &lt;a href=&quot;memorypoolmxbean#getCollectionUsageThresholdCount--&quot;&gt; &lt;code&gt;collection usage threshold count&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d5233e312eca4b40bdcfff8caabd2847f926280" translate="yes" xml:space="preserve">
          <source>The number of times that the thread has blocked for synchronization or waited for notification.</source>
          <target state="translated">스레드가 동기화를 차단하거나 알림을 기다린 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="3736904d09a27872b02330b53922aff48808ffef" translate="yes" xml:space="preserve">
          <source>The number of times this list has been</source>
          <target state="translated">이 목록의 횟수</target>
        </trans-unit>
        <trans-unit id="357ec448a341d2b228db1dbd27bc9cf72c53aabb" translate="yes" xml:space="preserve">
          <source>The number of type arguments must either equal the number of the type element's formal type parameters, or must be zero. If zero, and if the type element is generic, then the type element's raw type is returned.</source>
          <target state="translated">형식 인수의 수는 형식 요소의 형식 형식 매개 변수의 수와 같거나 0이어야합니다. 0이고 유형 요소가 제네릭이면 유형 요소의 원시 유형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5dcdeeed728c559a3fe4b12406c534b1b7846c" translate="yes" xml:space="preserve">
          <source>The number of unallocated bytes on the partition or &lt;code&gt;0L&lt;/code&gt; if the abstract pathname does not name a partition. This value will be less than or equal to the total file system size returned by &lt;a href=&quot;file#getTotalSpace--&quot;&gt;&lt;code&gt;getTotalSpace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파티션에서 할당되지 않은 바이트 수 또는 추상 경로 이름으로 파티션 이름을 지정하지 않은 경우 &lt;code&gt;0L&lt;/code&gt; 이 값은 &lt;a href=&quot;file#getTotalSpace--&quot;&gt; &lt;code&gt;getTotalSpace()&lt;/code&gt; &lt;/a&gt; 반환 한 총 파일 시스템 크기보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="87c541a3e7a17d1566331ea8f74b8b01cec37942" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="24896816bf723dc5a3b4b2e1bd2ca0f9074de51b" translate="yes" xml:space="preserve">
          <source>The number of valid bytes in the buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;; elements &lt;code&gt;buf[0]&lt;/code&gt; through &lt;code&gt;buf[count-1]&lt;/code&gt; contain valid byte data.</source>
          <target state="translated">버퍼에서 유효한 바이트 수입니다. 이 값의 범위는 항상 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;buf.length&lt;/code&gt; 입니다 . 요소 &lt;code&gt;buf[0]&lt;/code&gt; 통해 &lt;code&gt;buf[count-1]&lt;/code&gt; 유효 바이트 데이터를 포함한다.</target>
        </trans-unit>
        <trans-unit id="2e96ff8f9eedefb579c2382e0dc82d928321f101" translate="yes" xml:space="preserve">
          <source>The number of valid characters in the input stream buffer.</source>
          <target state="translated">입력 스트림 버퍼의 유효한 문자 수</target>
        </trans-unit>
        <trans-unit id="e57f66c301a924e445314f3299d3af941360076b" translate="yes" xml:space="preserve">
          <source>The number of valid components in the vector of observed objects.</source>
          <target state="translated">관찰 된 객체의 벡터에서 유효한 구성 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="f6b3f8e949ab3c4c73047ca1f7e1396e53ad0edf" translate="yes" xml:space="preserve">
          <source>The number of valid components in this &lt;code&gt;Vector&lt;/code&gt; object. Components &lt;code&gt;elementData[0]&lt;/code&gt; through &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; are the actual items.</source>
          <target state="translated">이 &lt;code&gt;Vector&lt;/code&gt; 객체 의 유효한 구성 요소 수입니다 . 부품 &lt;code&gt;elementData[0]&lt;/code&gt; 내지 &lt;code&gt;elementData[elementCount-1]&lt;/code&gt; 의 실제 항목이다.</target>
        </trans-unit>
        <trans-unit id="ee52cc4a979dfa290de71fa0d59778b99e3b2595" translate="yes" xml:space="preserve">
          <source>The object at the top of this stack (the last item of the &lt;code&gt;Vector&lt;/code&gt; object).</source>
          <target state="translated">이 스택의 맨 위에있는 객체입니다 ( &lt;code&gt;Vector&lt;/code&gt; 객체 의 마지막 항목 ).</target>
        </trans-unit>
        <trans-unit id="e3463f0dce6f74d0351102935f5ca5c5e97f8ec9" translate="yes" xml:space="preserve">
          <source>The object being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="549576c93743bbc010ab0c4c1c93ac04bc78070c" translate="yes" xml:space="preserve">
          <source>The object bound; null if this binding does not contain an object.</source>
          <target state="translated">개체가 바인딩되었습니다. 이 바인딩에 객체가없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="ab8401c61b78ecc0ded2083081b9915784d7e095" translate="yes" xml:space="preserve">
          <source>The object created; null if an object cannot be created.</source>
          <target state="translated">생성 된 객체; 객체를 작성할 수없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="25101b399f33f9945d69632115c3f921d4a373f9" translate="yes" xml:space="preserve">
          <source>The object currently attached to this key, or &lt;code&gt;null&lt;/code&gt; if there is no attachment</source>
          <target state="translated">이 키에 현재 접속되어있는 객체. 첨부가없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83e78860e5f6b1711764595fee4d0cebd5f6dd80" translate="yes" xml:space="preserve">
          <source>The object factories tried must implement either &lt;code&gt;ObjectFactory&lt;/code&gt; or &lt;code&gt;DirObjectFactory&lt;/code&gt;. If it implements &lt;code&gt;DirObjectFactory&lt;/code&gt;, &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; is used, otherwise, &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; is used.</source>
          <target state="translated">시도한 객체 팩토리는 &lt;code&gt;ObjectFactory&lt;/code&gt; 또는 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirObjectFactory&lt;/code&gt; 를 , &lt;code&gt;DirObjectFactory.getObjectInstance()&lt;/code&gt; 사용하고, 그렇지 않으면 &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="ab1ce82fc4930728131e5f5b4937333efd1a4cdb" translate="yes" xml:space="preserve">
          <source>The object identifier string, &quot;1.3.6.1.4.1.1466.20037&quot;.</source>
          <target state="translated">개체 식별자 문자열 &quot;1.3.6.1.4.1.1466.20037&quot;</target>
        </trans-unit>
        <trans-unit id="d478c804036047e663cb169378cb0113711a662b" translate="yes" xml:space="preserve">
          <source>The object implementing the &lt;code&gt;ModuleMXBean&lt;/code&gt; interface returns from its &lt;code&gt;getProduct&lt;/code&gt; method an object implementing the &lt;code&gt;ProductMXBean&lt;/code&gt; interface. The &lt;code&gt;ModuleMXBean&lt;/code&gt; object and the returned &lt;code&gt;ProductMXBean&lt;/code&gt; objects must both be registered as MXBeans in the same MBean Server.</source>
          <target state="translated">구현하는 객체 &lt;code&gt;ModuleMXBean&lt;/code&gt; 의에서 인터페이스를 반환 &lt;code&gt;getProduct&lt;/code&gt; 의 메소드 구현하는 객체 &lt;code&gt;ProductMXBean&lt;/code&gt; 인터페이스를. &lt;code&gt;ModuleMXBean&lt;/code&gt; 의 객체와 반환되는 &lt;code&gt;ProductMXBean&lt;/code&gt; 은 반드시 모두 동일한의 MBean 서버에 MXBean에로 등록 객체.</target>
        </trans-unit>
        <trans-unit id="acbe0492ed2a56ae25a5b225e810323a17ee9567" translate="yes" xml:space="preserve">
          <source>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays. The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</source>
          <target state="translated">객체는 readExternal 메소드를 구현하여 기본 유형에 대해서는 DataInput 메소드를, 객체, 문자열 및 배열에 대해서는 readObject 메소드를 호출하여 컨텐츠를 복원합니다. readExternal 메소드는 writeExternal이 작성한 것과 동일한 순서 및 유형으로 값을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="c660c0ad9f3d328f1f20a48dcdf28911ebb8dafe" translate="yes" xml:space="preserve">
          <source>The object implements the writeExternal method to save its contents by calling the methods of DataOutput for its primitive values or calling the writeObject method of ObjectOutput for objects, strings, and arrays.</source>
          <target state="translated">객체는 기본 값으로 DataOutput의 메소드를 호출하거나 객체, 문자열 및 배열에 대해 ObjectOutput의 writeObject 메소드를 호출하여 컨텐츠를 저장하기 위해 writeExternal 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="38b36518730fd2c13f206fa344da4fbf71908e2b" translate="yes" xml:space="preserve">
          <source>The object name is written using the usual syntax for &lt;a href=&quot;objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt;. It may contain any legal characters, including &lt;code&gt;]&lt;/code&gt;. It is terminated by a &lt;code&gt;]&lt;/code&gt; character that is the last character in the string.</source>
          <target state="translated">객체 이름은 일반적인 &lt;a href=&quot;objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 구문을 사용하여 작성 됩니다 . &lt;code&gt;]&lt;/code&gt; 를 포함하여 유효한 문자를 포함 할 수 있습니다 . 문자열에서 마지막 문자 인 &lt;code&gt;]&lt;/code&gt; 문자 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcd8b487cf6c43869dd95c8f0bff1303f6f407e8" translate="yes" xml:space="preserve">
          <source>The object on which the Event initially occurred.</source>
          <target state="translated">이벤트가 처음 발생한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="81130672cbc8ff967d42b441aaca30a9b8bdf723" translate="yes" xml:space="preserve">
          <source>The object returned by the action, which represents the result of invoking the action on the MBean specified.</source>
          <target state="translated">액션이 돌려주는 오브젝트. 지정된 MBean상에서 액션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36afb72a7b72fb42fa69bd024e797eb65658034c" translate="yes" xml:space="preserve">
          <source>The object returned by the method, which represents the result of invoking the method on the specified managed resource.</source>
          <target state="translated">메소드가 리턴 한 오브젝트. 지정된 관리 자원에서 메소드를 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4aed1f261990252b69271a77a6e7502c08d201c0" translate="yes" xml:space="preserve">
          <source>The object returned by the operation, which represents the result of invoking the operation on the MBean specified.</source>
          <target state="translated">오퍼레이션에 의해 돌려 주어지는 오브젝트. 지정된 MBean상에서 오퍼레이션을 호출 한 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19c49d417b2958f22cd9e8d59294bafdefc26984" translate="yes" xml:space="preserve">
          <source>The object returned by this method is a &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is an &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt;&lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 돌려주는 오브젝트는 , &lt;code&gt;InvocationHandler&lt;/code&gt; 가 &lt;a href=&quot;mbeanserverinvocationhandler&quot;&gt; &lt;code&gt;MBeanServerInvocationHandler&lt;/code&gt; &lt;/a&gt; 인 &lt;a href=&quot;../../java/lang/reflect/proxy&quot;&gt; &lt;code&gt;Proxy&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="2fd75977ed6de60086bb423f950b0a7c4c202381" translate="yes" xml:space="preserve">
          <source>The object returned by this method is owned by the caller. The implementation will not subsequently modify it. It will contain either a new &lt;code&gt;Attributes&lt;/code&gt; object that is likewise owned by the caller, or a reference to the original &lt;code&gt;attrs&lt;/code&gt; parameter.</source>
          <target state="translated">이 메소드에 의해 리턴 된 오브젝트는 호출자가 소유합니다. 구현은 나중에 수정하지 않습니다. 호출자가 소유 한 새로운 &lt;code&gt;Attributes&lt;/code&gt; 객체 또는 원래 &lt;code&gt;attrs&lt;/code&gt; 매개 변수에 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3a04190473c4b64ec143351918e9e15b033c0e14" translate="yes" xml:space="preserve">
          <source>The object that will generate the parameters can be initialized in two different ways: in an algorithm-independent manner, or in an algorithm-specific manner:</source>
          <target state="translated">매개 변수를 생성하는 객체는 알고리즘 독립적 방식 또는 알고리즘 특정 방식의 두 가지 방식으로 초기화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bfa8896361883de50652f049a3abf89fa5b629" translate="yes" xml:space="preserve">
          <source>The object to which this reference refers, or &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</source>
          <target state="translated">이 참조가 참조하는 오브젝트.이 참조 오브젝트가 클리어 된 경우 는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479e4c581de3dc9c3988355f57b5a21b657c8262" translate="yes" xml:space="preserve">
          <source>The object upon which the thread is blocked due to:</source>
          <target state="translated">다음으로 인해 스레드가 차단 된 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="47d5085633f8d27160804ec39a21ef33e1d60c26" translate="yes" xml:space="preserve">
          <source>The object used to synchronize operations on this stream. For efficiency, a character-stream object may use an object other than itself to protect critical sections. A subclass should therefore use the object in this field rather than &lt;code&gt;this&lt;/code&gt; or a synchronized method.</source>
          <target state="translated">이 스트림의 조작을 동기화하는데 사용되는 객체입니다. 효율을 높이기 위해 캐릭터 스트림 객체는 중요한 섹션을 보호하기 위해 자체 이외의 객체를 사용할 수 있습니다. 따라서 서브 클래스보다는이 분야에서 객체를 사용해야 &lt;code&gt;this&lt;/code&gt; 또는 동기화 방법.</target>
        </trans-unit>
        <trans-unit id="a07b833139a6ad3c188a63203fee507e5dfad4ab" translate="yes" xml:space="preserve">
          <source>The object's state for binding; null if the factory is not returning any changes.</source>
          <target state="translated">바인딩을위한 객체의 상태. 팩토리가 변경을 돌려주지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="66b636c530e62514647286e66dec68718239aedb" translate="yes" xml:space="preserve">
          <source>The object, null if the object has not been seen before.</source>
          <target state="translated">객체. 이전에 객체를 보지 못한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="4b2eb00905a91560fe1394f171982be773d4da7b" translate="yes" xml:space="preserve">
          <source>The objects being observed.</source>
          <target state="translated">관찰되는 물체.</target>
        </trans-unit>
        <trans-unit id="429abc75cd4f81d9b58c4ca6b602d61ef39ec33b" translate="yes" xml:space="preserve">
          <source>The observed attribute has differed from the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="871c7770e55cdc1bbf71029ab54209655d703ea8" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold high value.</source>
          <target state="translated">관찰 된 속성이 임계 값 상한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="672d698adf676e55830651a3e0dd447d91d839f5" translate="yes" xml:space="preserve">
          <source>The observed attribute has exceeded the threshold low value.</source>
          <target state="translated">관찰 된 속성이 임계 값 하한값을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="999e98019d02c1e1a5253c17913dd0ced4ce971f" translate="yes" xml:space="preserve">
          <source>The observed attribute has matched the &quot;string to compare&quot; value.</source>
          <target state="translated">관찰 된 속성이 &quot;string to compare&quot;값과 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="46421981f801d958da0b6eee8f1acb3f27c41fd9" translate="yes" xml:space="preserve">
          <source>The observed attribute has reached the threshold value.</source>
          <target state="translated">관찰 된 속성이 임계 값에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="fca6efcbf0300595dc90421a5999ce724786f218" translate="yes" xml:space="preserve">
          <source>The observed attribute is not contained in the observed object.</source>
          <target state="translated">관찰 된 속성은 관찰 된 개체에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a495e45796ee85b6f7b4712f3dc6b44dbd9667b" translate="yes" xml:space="preserve">
          <source>The observed attribute is not initialized by default (set to null).</source>
          <target state="translated">관찰 된 속성은 기본적으로 초기화되지 않습니다 (null로 설정).</target>
        </trans-unit>
        <trans-unit id="01626b79ebba8880f72349668f94f078b89c13bd" translate="yes" xml:space="preserve">
          <source>The observed attribute.</source>
          <target state="translated">관찰 된 속성.</target>
        </trans-unit>
        <trans-unit id="0a9f956d167d7d6dbfd3e8ba63d5548489a146e8" translate="yes" xml:space="preserve">
          <source>The observed object is not registered in the MBean server.</source>
          <target state="translated">관찰 된 오브젝트가 MBean 서버에 등록되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="416b7e765f8103a9eb70b7e15edec19bb2ecc0e9" translate="yes" xml:space="preserve">
          <source>The observed object.</source>
          <target state="translated">관찰 된 물체.</target>
        </trans-unit>
        <trans-unit id="57e624d8b36b41f9dc5b92485a65e92541347bbe" translate="yes" xml:space="preserve">
          <source>The official ISO-8601 standard does not define eras, however &lt;code&gt;IsoChronology&lt;/code&gt; does. It defines two eras, 'CE' from year one onwards and 'BCE' from year zero backwards. Since dates before the Julian-Gregorian cutover are not in line with history, the cutover between 'BCE' and 'CE' is also not aligned with the commonly used eras, often referred to using 'BC' and 'AD'.</source>
          <target state="translated">공식 ISO-8601 표준은 시대를 정의 하지 않지만 &lt;code&gt;IsoChronology&lt;/code&gt; 는 시대를 정의하지 않습니다 . 1 년부터 'CE', 0 년부터 'BCE'의 두 시대를 정의합니다. Julian-Gregorian 컷 오버 이전 날짜는 역사와 일치하지 않기 때문에 'BCE'와 'CE'사이의 컷 오버는 흔히 'BC'와 'AD'를 사용하는 데 사용되는 일반적으로 사용되는 시대와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7452b72544afe4ea17383b9c1a0ddd335f187953" translate="yes" xml:space="preserve">
          <source>The offset after the last character captured by the group, or &lt;code&gt;-1&lt;/code&gt; if the match was successful but the group itself did not match anything</source>
          <target state="translated">그룹이 마지막으로 캡처 한 문자 이후의 오프셋 또는 일치하지만 그룹 자체가 아무 것도 일치하지 않으면 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a514a96e4c706169df1bae50ab993a34ff2649" translate="yes" xml:space="preserve">
          <source>The offset after the last character matched</source>
          <target state="translated">마지막 문자 이후의 오프셋</target>
        </trans-unit>
        <trans-unit id="95184cd7d4878804e4744550fed5412ac87a781a" translate="yes" xml:space="preserve">
          <source>The offset does not affect the calculation and will be the same in the result.</source>
          <target state="translated">오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8d0ea8f68c9762891010ddff46c446503f293682" translate="yes" xml:space="preserve">
          <source>The offset from UTC/Greenwich.</source>
          <target state="translated">UTC / 그리니치와의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="f5e45443bbef26f421b83a68935e17782face615" translate="yes" xml:space="preserve">
          <source>The offset in the destination where the upper-left decoded pixel should be placed. By default, the value is (0, 0).</source>
          <target state="translated">왼쪽 상단의 디코딩 된 픽셀을 배치 할 대상의 오프셋입니다. 기본적으로 값은 (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bcad531c02ce778e413b93f44d2a73d86d13c97e" translate="yes" xml:space="preserve">
          <source>The offset must be in the range &lt;code&gt;-18:00&lt;/code&gt; to &lt;code&gt;+18:00&lt;/code&gt;, which corresponds to -64800 to +64800.</source>
          <target state="translated">오프셋은 &lt;code&gt;-18:00&lt;/code&gt; ~ &lt;code&gt;+18:00&lt;/code&gt; 범위에 있어야하며 이는 -64800 ~ +64800에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="dbff04852ae6dc7f91ef52e4416eeb9c4bdba3f8" translate="yes" xml:space="preserve">
          <source>The offset value.</source>
          <target state="translated">오프셋 값.</target>
        </trans-unit>
        <trans-unit id="1ee05bd1235e40acbee8bde4cc93361e017df6f0" translate="yes" xml:space="preserve">
          <source>The offset within this buffer's array of the first element of the buffer</source>
          <target state="translated">버퍼의 첫 번째 요소에 대한이 버퍼의 배열 내 오프셋</target>
        </trans-unit>
        <trans-unit id="c2f54cdf947745f8f0b6ab00403e70f969ef9fcc" translate="yes" xml:space="preserve">
          <source>The offset-based date-time types &lt;code&gt;OffsetTime&lt;/code&gt; and &lt;code&gt;OffsetDateTime&lt;/code&gt;, are intended primarily for use with network protocols and database access. For example, most databases cannot automatically store a time-zone like 'Europe/Paris', but they can store an offset like '+02:00'.</source>
          <target state="translated">오프셋 기반 날짜-시간 유형 &lt;code&gt;OffsetTime&lt;/code&gt; 및 &lt;code&gt;OffsetDateTime&lt;/code&gt; 은 주로 네트워크 프로토콜 및 데이터베이스 액세스에 사용하기위한 것입니다. 예를 들어, 대부분의 데이터베이스는 '유럽 / 파리'와 같은 시간대를 자동으로 저장할 수 없지만 '+02 : 00'과 같은 오프셋을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118a1e86d2011a80aabb35687d2f8db1fc48e418" translate="yes" xml:space="preserve">
          <source>The offsets are compared in the order that they occur for the same time of day around the world. Thus, an offset of &lt;code&gt;+10:00&lt;/code&gt; comes before an offset of &lt;code&gt;+09:00&lt;/code&gt; and so on down to &lt;code&gt;-18:00&lt;/code&gt;.</source>
          <target state="translated">오프셋은 전 세계 동일한 시간에 발생하는 순서대로 비교됩니다. 따라서 &lt;code&gt;+10:00&lt;/code&gt; 오프셋은 &lt;code&gt;+09:00&lt;/code&gt; 오프셋 앞에오고 &lt;code&gt;-18:00&lt;/code&gt; 까지 내려갑니다 .</target>
        </trans-unit>
        <trans-unit id="e102309a5333ab2237cebc7d402fc7f4a95ad222" translate="yes" xml:space="preserve">
          <source>The old binding: information about the object before the change.</source>
          <target state="translated">기존 바인딩 : 변경 전 객체에 대한 정보</target>
        </trans-unit>
        <trans-unit id="eaa830de2cd1ee40ef0e64424b6658b54dfedf50" translate="yes" xml:space="preserve">
          <source>The old value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 이전 값으로, Object로 표시됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8804e2adfeaa4e67e196991549e2b345ab8e8bf" translate="yes" xml:space="preserve">
          <source>The old/new binding in &lt;code&gt;NamingEvent&lt;/code&gt; may be null if the old name or new name is outside of the scope for which the listener has registered.</source>
          <target state="translated">이전 이름 ​​또는 새 이름이 리스너가 등록한 범위를 벗어나면 &lt;code&gt;NamingEvent&lt;/code&gt; 의 이전 / 새 바인딩 이 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3680a0d410cbf7c86a348b63caf1fd252cbc022a" translate="yes" xml:space="preserve">
          <source>The only characters in attribute values that are escaped are those which section 2.4 of RFC 2253 states must be escaped (they are escaped using a preceding backslash character)</source>
          <target state="translated">이스케이프되는 속성 값의 유일한 문자는 RFC 2253 상태의 2.4 섹션을 이스케이프해야하는 문자입니다 (앞의 백 슬래시 문자를 사용하여 이스케이프됩니다).</target>
        </trans-unit>
        <trans-unit id="8c196d72932e1d175e571f345ae61f12d79c6347" translate="yes" xml:space="preserve">
          <source>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using &quot;&lt;code&gt;parallelStream()&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;stream()&lt;/code&gt;&quot;. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked. Whether a stream will execute in serial or parallel can be determined with the &lt;code&gt;isParallel()&lt;/code&gt; method, and the orientation of a stream can be modified with the &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basestream#parallel--&quot;&gt;&lt;code&gt;BaseStream.parallel()&lt;/code&gt;&lt;/a&gt; operations. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked.</source>
          <target state="translated">이 예제의 직렬 버전과 병렬 버전의 유일한 차이점 은 &quot; &lt;code&gt;stream()&lt;/code&gt; &quot; 대신 &quot; &lt;code&gt;parallelStream()&lt;/code&gt; &quot;을 사용하여 초기 스트림을 만드는 것입니다 . 터미널 작업이 시작되면 스트림 파이프 라인은 호출 된 스트림의 방향에 따라 순차적으로 또는 병렬로 실행됩니다. 직렬 또는 병렬로 스트림을 실행할지 여부는 &lt;code&gt;isParallel()&lt;/code&gt; 메서드를 사용하여 확인할 수 있으며 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basestream#parallel--&quot;&gt; &lt;code&gt;BaseStream.parallel()&lt;/code&gt; &lt;/a&gt; 작업 을 사용하여 스트림 방향을 수정할 수 있습니다 . 터미널 작업이 시작되면 스트림 파이프 라인은 호출 된 스트림의 모드에 따라 순차적으로 또는 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f349a38007f0fe5c739a24493c39f2bc7e05087f" translate="yes" xml:space="preserve">
          <source>The only possible modifiers for constructors are the access modifiers &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;. Only one of these may appear, or none if the constructor has default (package) access.</source>
          <target state="translated">생성자에 가능한 유일한 수정자는 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 액세스 수정 자 입니다. 이 중 하나만 표시되거나 생성자가 기본 (패키지) 액세스 권한을 가진 경우 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="757cee3ea404c7279f0c6b75405f9e5d965d2914" translate="yes" xml:space="preserve">
          <source>The operating system program file was not found.</source>
          <target state="translated">운영 체제 프로그램 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="47390cdf3b88c3e58ad9e0ae77f10ad59aa1eaf6" translate="yes" xml:space="preserve">
          <source>The operation just closed this side of the &lt;code&gt;SSLEngine&lt;/code&gt;, or the operation could not be completed because it was already closed.</source>
          <target state="translated">작업이 &lt;code&gt;SSLEngine&lt;/code&gt; 의 이면을 닫았 거나 이미 닫혀서 작업을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d716f5e6eb73ca33a6b17f0e7fa84479a8ab34c7" translate="yes" xml:space="preserve">
          <source>The operation of this method is slightly different to similar methods using &lt;code&gt;ParsePosition&lt;/code&gt; on &lt;code&gt;java.text.Format&lt;/code&gt;. That class will return errors using the error index on the &lt;code&gt;ParsePosition&lt;/code&gt;. By contrast, this method will throw a &lt;a href=&quot;datetimeparseexception&quot;&gt;&lt;code&gt;DateTimeParseException&lt;/code&gt;&lt;/a&gt; if an error occurs, with the exception containing the error index. This change in behavior is necessary due to the increased complexity of parsing and resolving dates/times in this API.</source>
          <target state="translated">이 메소드의 조작은 &lt;code&gt;java.text.Format&lt;/code&gt; 에서 &lt;code&gt;ParsePosition&lt;/code&gt; 을 사용하는 유사한 메소드와 약간 다릅니다 . 해당 클래스는 &lt;code&gt;ParsePosition&lt;/code&gt; 의 오류 인덱스를 사용하여 오류를 반환합니다 . 반대로,이 메서드는 오류 인덱스가 포함 된 예외를 제외하고 오류가 발생 하면 &lt;a href=&quot;datetimeparseexception&quot;&gt; &lt;code&gt;DateTimeParseException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 이 동작의 변경은이 API에서 구문 분석 및 날짜 / 시간의 복잡성이 증가함에 따라 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c2dbe5cb88129c338520227f951d5d21bc3adc0" translate="yes" xml:space="preserve">
          <source>The operation proceeds as follows:</source>
          <target state="translated">작업은 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e9b100e7d6bf71d9d81c5cf765dd6e9312adf7f" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is near end of life.</source>
          <target state="translated">광학 포토 컨덕터의 수명이 거의 다되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc98736e760491006a9169783a49bc78538cc3ca" translate="yes" xml:space="preserve">
          <source>The optical photo conductor is no longer functioning.</source>
          <target state="translated">광학 포토 컨덕터가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c62ce663f6e5bbb6451017676b19762e1fbf3161" translate="yes" xml:space="preserve">
          <source>The option must be set prior to entering a blocking operation to take effect. If the timeout expires and the operation would continue to block, &lt;b&gt;java.io.InterruptedIOException&lt;/b&gt; is raised. The Socket is not closed in this case.</source>
          <target state="translated">차단 작업을 시작하기 전에 옵션을 설정해야 적용됩니다. 시간 종료가 만료되고 조작이 계속 차단되면 &lt;b&gt;java.io.InterruptedIOException&lt;/b&gt; 이 발생합니다. 이 경우 소켓이 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fde895ca15e28398e2093122f9b0e89dd2c837e" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 와&lt;/a&gt; 같습니다 . 링크 된 노드는 용량을 초과하지 않는 한 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1b391ca196a239752a071899940b30e945c7e626" translate="yes" xml:space="preserve">
          <source>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt;&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/a&gt;. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.</source>
          <target state="translated">선택적 용량 바운드 생성자 인수는 과도한 큐 확장을 방지하는 방법으로 사용됩니다. 지정되지 않은 경우 용량은 &lt;a href=&quot;../../lang/integer#MAX_VALUE&quot;&gt; &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 와&lt;/a&gt; 같습니다 . 큐가 용량을 초과하지 않는 한 링크 된 노드는 각 삽입시 동적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40329cb44fef466069a746e7e8616ce88f318acf" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods allow the invocation of procedures in scripts that have previously been executed.</source>
          <target state="translated">이전에 실행 된 스크립트에서 프로 시저를 호출 할 수있는 메소드를 가진 ScriptEngine에 의해 구현 된 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="af44167d5098cd1640942f676f56da64386bc769" translate="yes" xml:space="preserve">
          <source>The optional interface implemented by ScriptEngines whose methods compile scripts to a form that can be executed repeatedly without recompilation.</source>
          <target state="translated">스크립트 엔진이 다시 컴파일하지 않고 반복적으로 실행할 수있는 형식으로 스크립트를 컴파일하는 ScriptEngine에서 구현 한 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0d323759d66423b856604e1ca269cc6f1231f8e4" translate="yes" xml:space="preserve">
          <source>The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.</source>
          <target state="translated">알림이 전달되는 순서는 지정되지 않았습니다. Observable 클래스에서 제공되는 기본 구현은 Observer에게 관심 등록 된 순서대로 통지하지만 서브 클래스는이 순서를 변경하거나 보장 된 순서를 사용하지 않으며 별도의 스레드에 알림을 전달하거나 서브 클래스가이 순서를 따르도록 보장 할 수 있습니다 고르다.</target>
        </trans-unit>
        <trans-unit id="786679264f791da220873f1e88f2073a40d4300a" translate="yes" xml:space="preserve">
          <source>The order in which the certificates are presented to the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; may be either in the forward direction (from target to most-trusted CA) or in the reverse direction (from most-trusted CA to target). A &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; implementation &lt;b&gt;must&lt;/b&gt; support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and &lt;b&gt;may&lt;/b&gt; support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction). The &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt;&lt;code&gt;isForwardCheckingSupported&lt;/code&gt;&lt;/a&gt; method indicates whether forward checking is supported.</source>
          <target state="translated">인증서가 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 에 제공되는 순서 는 정방향 (대상에서 가장 신뢰할 수있는 CA로) 또는 역방향 (가장 신뢰할 수있는 CA에서 대상으로) 일 수 있습니다. &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 구현 &lt;b&gt;한다&lt;/b&gt; (이 역방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 역방향 확인을 지원하고 &lt;b&gt;있다&lt;/b&gt; (이 순방향으로 인증서를 제시 할 때의 검사를 수행 할 수있는 능력)을 검사 전방지지한다. &lt;a href=&quot;pkixcertpathchecker#isForwardCheckingSupported--&quot;&gt; &lt;code&gt;isForwardCheckingSupported&lt;/code&gt; &lt;/a&gt; 방법 방향의 체크가 지원되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="3007914f7a4138270cf5fa55368f3ef46fd6ca3f" translate="yes" xml:space="preserve">
          <source>The order of MBeans in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt; is significant. For any two MBeans &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; in the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;, &lt;em&gt;X&lt;/em&gt; must appear before &lt;em&gt;Y&lt;/em&gt; if the registration of &lt;em&gt;X&lt;/em&gt; was completed before the registration of &lt;em&gt;Y&lt;/em&gt; started. If &lt;em&gt;X&lt;/em&gt; and &lt;em&gt;Y&lt;/em&gt; were registered concurrently, their order is indeterminate. The registration of an MBean corresponds to the call to &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt;&lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt;&lt;/a&gt; or one of the &lt;a href=&quot;../mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.createMBean&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ClassLoaderRepository&lt;/code&gt; 의 MBean 순서 는 중요합니다. 두 MBean의 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y&lt;/em&gt; 에서 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에 , &lt;em&gt;X는&lt;/em&gt; 이전에 나타나야 &lt;em&gt;Y&lt;/em&gt; 의 등록하면 &lt;em&gt;X가&lt;/em&gt; 의 등록 이전에 완료 &lt;em&gt;Y는&lt;/em&gt; 시작했다. &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y&lt;/em&gt; 가 동시에 등록 된 경우 순서가 불확실합니다. MBean 등록은 &lt;a href=&quot;../mbeanserver#registerMBean-java.lang.Object-javax.management.ObjectName-&quot;&gt; &lt;code&gt;MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.createMBean&lt;/code&gt; 메소드 중 하나에 대한 호출에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="6726bce2cabc5276351a481e6e10cf57a7fb4a23" translate="yes" xml:space="preserve">
          <source>The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Long::max&lt;/code&gt; along with &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; as the identity.</source>
          <target state="translated">스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않으며 의존 할 수 없으므로이 클래스는 누적 순서가 중요하지 않은 함수에만 적용 할 수 있습니다. 제공된 누산기 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Long::max&lt;/code&gt; 를 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 와 함께 ID로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39109fa74536dbd205739a657a79c8c946a6365" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. An implementation should allow configuration of the meaning of these values. An application may use the Java Cryptography Extension (JCE) with JCE-aware mechanisms to control the selection of cipher suites that match the strength values.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 구현시 이러한 값의 의미를 구성 할 수 있어야합니다. 애플리케이션은 JCE 인식 메커니즘과 함께 JCE (Java Cryptography Extension)를 사용하여 강도 값과 일치하는 암호 스위트 선택을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7e2a675c70b61b722a61131dcca11cbc86fea1" translate="yes" xml:space="preserve">
          <source>The order of the list specifies the preference order of the client or server. If this property is absent, the default qop is &lt;code&gt;&quot;auth&quot;&lt;/code&gt;. The value of this constant is &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt;.</source>
          <target state="translated">목록의 순서는 클라이언트 또는 서버의 기본 설정 순서를 지정합니다. 이 특성이 없으면 기본 qop는 &lt;code&gt;&quot;auth&quot;&lt;/code&gt; 입니다. 이 상수의 값은 &lt;code&gt;&quot;javax.security.sasl.qop&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f586d409022fb2da015fb1af6296fa734a0d31fd" translate="yes" xml:space="preserve">
          <source>The order of transformation is described in the &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; method. This same order is used in the automatic reapplication of retransformation incapable transforms.</source>
          <target state="translated">변환 순서는 &lt;a href=&quot;classfiletransformer#transform-java.lang.ClassLoader-java.lang.String-java.lang.Class-java.security.ProtectionDomain-byte:A-&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 방법에 설명되어 있습니다. 동일한 순서가 재 변환 불가능 변환의 자동 재 적용에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="218227e103dee75adf30e33cccee9cc838d6df1c" translate="yes" xml:space="preserve">
          <source>The ordering imposed by a comparator &lt;code&gt;c&lt;/code&gt; on a set of elements &lt;code&gt;S&lt;/code&gt; is said to be</source>
          <target state="translated">일련의 요소 &lt;code&gt;S&lt;/code&gt; 에 비교기 &lt;code&gt;c&lt;/code&gt; 에 의해 부과되는 순서 는</target>
        </trans-unit>
        <trans-unit id="fa90a160007f418563c4b70e7a41641e8b8af99c" translate="yes" xml:space="preserve">
          <source>The ordering of URIs is defined as follows:</source>
          <target state="translated">URI의 순서는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d740108fcacd8b33f949d001977d3ba5521ae114" translate="yes" xml:space="preserve">
          <source>The ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been waiting the longest.</source>
          <target state="translated">대기 메소드에서 리턴하는 스레드에 대한 잠금 재 취득 순서는 기본적으로 지정되지 않은 초기 잠금을 획득하는 스레드의 순서와 동일하지만 &lt;em&gt;공정&lt;/em&gt; 잠금의 경우 가장 오래 기다린 스레드를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="c351a0d0a5c5fd7fc6873693e09a2f6e8d0c8198" translate="yes" xml:space="preserve">
          <source>The ordering will be used by the &lt;code&gt;getServiceProviders&lt;/code&gt; methods when their &lt;code&gt;useOrdering&lt;/code&gt; argument is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">순서는 &lt;code&gt;useOrdering&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;getServiceProviders&lt;/code&gt; 메소드에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2fbbc68a36c3656118ddcba9b24016a519952e2" translate="yes" xml:space="preserve">
          <source>The origin and dimensions are the same.</source>
          <target state="translated">원점과 치수는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="03642eebd1c6e8a163c4a73ff3af624d3fa4e141" translate="yes" xml:space="preserve">
          <source>The original Java type of this element as it appeared in the &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt; interface method that produced this &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; (etc). For example, a method</source>
          <target state="translated">이 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 등 을 생성 한 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 인터페이스 메소드에 나타난이 요소의 원의 Java 타입입니다 . 예를 들어, 방법</target>
        </trans-unit>
        <trans-unit id="1bb7eb8c45dbc81d8fd70bf5884b22ccd1f62cb9" translate="yes" xml:space="preserve">
          <source>The original object that was sealed can be recovered in two different ways:</source>
          <target state="translated">봉인 된 원본 개체는 두 가지 방법으로 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="506f78a81958986cbe8e40931c749b16889f1e47" translate="yes" xml:space="preserve">
          <source>The original version. The language described in</source>
          <target state="translated">원본 버전. 에 설명 된 언어</target>
        </trans-unit>
        <trans-unit id="18b3f2a40bb0908a20b25677701f7f3b90d224d0" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68ee463661f375d777c74d840458ef8c9dd98143" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; LocalTime}. In this case, the offset is not part of the calculation and will be unchanged.</source>
          <target state="translated">&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; LocalTime} 에서 일치하는 방법에 따라 동작합니다 . 이 경우 오프셋은 계산에 포함되지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485d2eb713590b6bb807248ee4372d5241f39e32" translate="yes" xml:space="preserve">
          <source>The other &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;&lt;/a&gt;. The zone is not part of the calculation and will be unchanged. When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 다른 필드 는 &lt;a href=&quot;localdatetime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDateTime&lt;/code&gt; &lt;/a&gt; 의 일치하는 메소드에 따라 작동합니다 . 영역은 계산의 일부가 아니며 변경되지 않습니다. &lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 가능한 경우 오프셋이 유지되고, 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이 있으면 현지 날짜-시간이 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="731e6c57f9e5ae4ccf59a456cb37bb4538303681" translate="yes" xml:space="preserve">
          <source>The other approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values. To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.</source>
          <target state="translated">다른 접근 방식은 알고리즘 별 시맨틱을 사용하여 매개 변수 생성기 객체를 초기화하며, 이는 알고리즘 별 매개 변수 생성 값 세트로 표시됩니다. 예를 들어, Diffie-Hellman 시스템 매개 변수를 생성하기 위해 매개 변수 생성 값은 일반적으로 비트 수로 지정된 소수 지수와 랜덤 지수의 크기로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="55d2cad5bd07439d3de3adc5deca101f2c106f10" translate="yes" xml:space="preserve">
          <source>The other syntaxes defined by RFC 2609 are not currently supported by this class.</source>
          <target state="translated">RFC 2609에 의해 정의 된 다른 구문은 현재이 클래스에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f670b4981f0a114b5c79dad80bac9bc5c125b90" translate="yes" xml:space="preserve">
          <source>The other type of pairs consists of those that create Java language Bindings, the values are usually represented in scripts by the corresponding keys or by decorated forms of them.</source>
          <target state="translated">다른 유형의 쌍은 Java 언어 바인딩을 작성하는 쌍으로 구성되며, 값은 일반적으로 해당 키 또는 장식 된 형식으로 스크립트에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b004cd696742da98b715116f439633a968fa96c" translate="yes" xml:space="preserve">
          <source>The other way to create a thread is to declare a class that implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can then be allocated, passed as an argument when creating &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other style looks like the following:</source>
          <target state="translated">스레드를 작성하는 다른 방법은 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스 를 구현하는 클래스를 선언하는 것 입니다. 그런 다음 해당 클래스는 &lt;code&gt;run&lt;/code&gt; 메소드 를 구현합니다 . 그런 다음 클래스의 인스턴스를 할당하고 &lt;code&gt;Thread&lt;/code&gt; 를 만들 때 인수로 전달한 다음 시작할 수 있습니다. 이 다른 스타일의 동일한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c8adc64c31daab6de1a7235e69f69308c772876" translate="yes" xml:space="preserve">
          <source>The output IO stream is buffered, but is flushed after each &lt;code&gt;LogRecord&lt;/code&gt; is written.</source>
          <target state="translated">출력 IO 스트림은 버퍼링되지만 각 &lt;code&gt;LogRecord&lt;/code&gt; 가 작성된 후에 플러시 됩니다.</target>
        </trans-unit>
        <trans-unit id="84e58d292a5274ac7143c456712868ef9a668dc0" translate="yes" xml:space="preserve">
          <source>The output device is marking media. This value is useful for printers which spend a great deal of time processing (1) when no marking is happening and then want to show that marking is now happening or (2) when the job is in the process of being canceled or aborted while the job remains in the PROCESSING state, but the marking has not yet stopped so that impression or sheet counts are still increasing for the job.</source>
          <target state="translated">출력 장치가 미디어를 표시하고 있습니다. 이 값은 (1) 마킹이 발생하지 않았을 때 마킹이 진행 중이거나 (2) 작업이 취소 또는 중단되는 중일 때 표시하는 데 많은 시간을 소비하는 프린터에 유용합니다. 작업이 처리 중 상태로 유지되지만 표시가 아직 중지되지 않아 작업에 대한 인상 또는 시트 수가 계속 증가합니다.</target>
        </trans-unit>
        <trans-unit id="688afe174c47eb9329383daa0efbfa513f94d552" translate="yes" xml:space="preserve">
          <source>The output is right-justified within the &lt;code&gt;width&lt;/code&gt;</source>
          <target state="translated">출력은 &lt;code&gt;width&lt;/code&gt; 내에서 오른쪽으로 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="804ab937140ab8aceea397468da48794c9e5c156" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using either the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 미리 출력을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5834d251964586e73d7e57cd4080802c92b44a58" translate="yes" xml:space="preserve">
          <source>The output must have been set beforehand using the &lt;code&gt;setOutput&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;setOutput&lt;/code&gt; 메소드를 사용하여 출력을 미리 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c137f9ad4568084e0eada82e7dc19a7e9d63517" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt;&lt;code&gt;optionalStart()&lt;/code&gt;&lt;/a&gt; and ended using this method (or at the end of the builder).</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은 &lt;a href=&quot;datetimeformatterbuilder#optionalStart--&quot;&gt; &lt;code&gt;optionalStart()&lt;/code&gt; &lt;/a&gt; 를 호출하여 시작 되고이 메소드 (또는 빌더의 끝)를 사용하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4ace7699a2d9bc0b73e1579908c8e14ceff6a861" translate="yes" xml:space="preserve">
          <source>The output of formatting can include optional sections, which may be nested. An optional section is started by calling this method and ended by calling &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt;&lt;code&gt;optionalEnd()&lt;/code&gt;&lt;/a&gt; or by ending the build process.</source>
          <target state="translated">서식의 출력에는 중첩 될 수있는 선택적 섹션이 포함될 수 있습니다. 선택적 섹션은이 메소드를 호출하여 시작하고 &lt;a href=&quot;datetimeformatterbuilder#optionalEnd--&quot;&gt; &lt;code&gt;optionalEnd()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 빌드 프로세스를 종료하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c86979c68dfa75a5ea8a4fa4ebc1ad3a84cf42c6" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 format &lt;code&gt;uuuu-MM-dd&lt;/code&gt;.</source>
          <target state="translated">출력은 ISO-8601 형식 &lt;code&gt;uuuu-MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b633ef40153b0f7e5fd9c57a4eaf98a09ebc8bd" translate="yes" xml:space="preserve">
          <source>The output will be in the ISO-8601 period format. A zero period will be represented as zero days, 'P0D'.</source>
          <target state="translated">출력은 ISO-8601 기간 형식입니다. 0 기간은 0 일 'P0D'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="68588c3b93830eb7b05eaa2a32bd88e2e6401d4a" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;--MM-dd&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;--MM-dd&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="bdf3023f62cba73bbd1a514729bd330ebd38319c" translate="yes" xml:space="preserve">
          <source>The output will be in the format &lt;code&gt;uuuu-MM&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;uuuu-MM&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="dd014c7d6b437b473d734099818c5531d372f334" translate="yes" xml:space="preserve">
          <source>The output will be one of the following ISO-8601 formats:</source>
          <target state="translated">출력은 다음 ISO-8601 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="705acc7715ef6cf8f5d79566a8f63147ba3837f5" translate="yes" xml:space="preserve">
          <source>The output will include the full local date-time.</source>
          <target state="translated">출력에는 전체 현지 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2e50f340847768af08514b08ccbbc3cfbeecb6" translate="yes" xml:space="preserve">
          <source>The output will include the full local date.</source>
          <target state="translated">출력에는 전체 현지 날짜가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="569b52322e6eb839ec665dce679a13d3f5ed0afe" translate="yes" xml:space="preserve">
          <source>The output will include the full zoned date-time.</source>
          <target state="translated">출력에는 전체 영역 날짜-시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc58e9e7951c47f5031287fcfab530275c088ee0" translate="yes" xml:space="preserve">
          <source>The output will include the period amounts and chronology.</source>
          <target state="translated">출력에는 기간과 연대기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="234157b711ff9b8171f42b7b203bce27d2d2b18a" translate="yes" xml:space="preserve">
          <source>The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fileCount&lt;/code&gt; 에 대해 다른 값을 가진 출력 :</target>
        </trans-unit>
        <trans-unit id="a40c1fc8cccf601ed7cf89f2562ee058faba7bf0" translate="yes" xml:space="preserve">
          <source>The overall authentication succeeds only if all</source>
          <target state="translated">전체 인증은 모든 경우에만 성공</target>
        </trans-unit>
        <trans-unit id="f59ea59df05be113fd52c10e956f63fb5a862338" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be6d5695ee207edc76227a4e67c6ab0ba325ae3c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a &lt;code&gt;char&lt;/code&gt; array by the method &lt;a href=&quot;character#toChars-int-&quot;&gt;&lt;code&gt;Character.toChars(int)&lt;/code&gt;&lt;/a&gt; and the character in that array were then &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;character#toChars-int-&quot;&gt; &lt;code&gt;Character.toChars(int)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 인수를 &lt;code&gt;char&lt;/code&gt; 배열 로 변환 한 다음 해당 배열의 문자 를이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-char:A-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57cba855e92025ba54d5320f086b0dbf8cfec25b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7df0f951a6156117783dfb422bf5ed58fb06623" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="845b434e13a8aaf2c9d866bceb0cd542c9f36bae" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07f151c65ac0110f86fef11dd3f3f19d05c7cbc5" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4fdc466e4bb623ea414c11f74ab2ab2710302ca" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="157765951de65cc003ce1491b4ef26e8c342399d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c95847b7e89b7021cc6b64b5b06284de479600b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e4e8c68ad219b2ca4384b64637aee75cfb33a09" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047be1cada456ef70fd59c3ee3f044b4b3346662" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5533d40c6ced212dd75bac0fd6a34c6fac9422b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55f999bd369940307c24bebb765ca5b872fb76b7" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b879652398b41d309d1476f2c2e969058129bf6" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27d2cb16c3fe6c766ce861a61273f35f95a4220f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f3315b830429e7a9bc3e205fa95bae92504588c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5885c63fcfaae322b7ea095a9fac9b6f29e099cc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7336e95827ca7bca837791a580e9cd1b62d7c706" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 마치 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 똑같이 해당 문자열의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f590370647a03195ad36ca13c3dafc9d17830de" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="667446b3ce7a38fb13fed317aa887df961ff9edc" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the arguments were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt;&lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt;&lt;code&gt;appended&lt;/code&gt;&lt;/a&gt; to this character sequence.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-char:A-int-int-&quot;&gt; &lt;code&gt;String.valueOf(char[],int,int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#append-java.lang.String-&quot;&gt; &lt;code&gt;appended&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e3ad882f1370e6a19c92030d372ebea043ac08c" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7af047a811aea03c7cfb551fb7745eca0c8286b" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf(boolean)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf(boolean)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5d50176eafd06dde20c9510416b4ea1abd05817" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="99669c326a383e25b074e12ce49230f42dee9d3d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char-&quot;&gt;&lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/a&gt;, and the character in that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char-&quot;&gt; &lt;code&gt;String.valueOf(char)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자 가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="73138bb845b641098da27eae98dd3fcc96960e8a" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="c64220b96dbb589d7148353f7e1cfad95e5e608f" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-char:A-&quot;&gt;&lt;code&gt;String.valueOf(char[])&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-char:A-&quot;&gt; &lt;code&gt;String.valueOf(char[])&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e313b4e5bbaa022d9225aca73fc6c42986754cf" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cce5181b8ce0af8aa47d1fcfeb79ba05fe223d1d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-double-&quot;&gt;&lt;code&gt;String.valueOf(double)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-double-&quot;&gt; &lt;code&gt;String.valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="324cc7be6c9dedfbe10fe3f90387bf61ecd27c01" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="db08c56eaebf244ff3142963ce2d28f1d66ab880" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-float-&quot;&gt;&lt;code&gt;String.valueOf(float)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-float-&quot;&gt; &lt;code&gt;String.valueOf(float)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 , 해당 문자열의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="38951459bdb968fe8d267a2144f2daab8015b7ff" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 정확히 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5fc542b259600a887b19200ae27aaaa00be8b9a0" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-int-&quot;&gt;&lt;code&gt;String.valueOf(int)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-int-&quot;&gt; &lt;code&gt;String.valueOf(int)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 정확히 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f58159ca31b8acb9ea067910b0f31bafe22b3cbe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f522c3927d765d22340b0bebf81d5e0e71e191d" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt;&lt;code&gt;String.valueOf(Object)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전반적인 효과는 &lt;a href=&quot;string#valueOf-java.lang.Object-&quot;&gt; &lt;code&gt;String.valueOf(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="01523b80576e2b49f83dc67247fbc3f9819c22d9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuffer#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b87b84c4a13dc2c6e5e702e25ec10a27e27371fe" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the second argument were converted to a string by the method &lt;a href=&quot;string#valueOf-long-&quot;&gt;&lt;code&gt;String.valueOf(long)&lt;/code&gt;&lt;/a&gt;, and the characters of that string were then &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt;&lt;code&gt;inserted&lt;/code&gt;&lt;/a&gt; into this character sequence at the indicated offset.</source>
          <target state="translated">전체적인 효과는 &lt;a href=&quot;string#valueOf-long-&quot;&gt; &lt;code&gt;String.valueOf(long)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 두 번째 인수가 문자열로 변환 된 것과 동일하며 해당 문자열 의 문자가 표시된 오프셋에서이 문자 시퀀스에 &lt;a href=&quot;stringbuilder#insert-int-java.lang.String-&quot;&gt; &lt;code&gt;inserted&lt;/code&gt; &lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f770b2501486fad821354a61f138150a2a3b6c92" translate="yes" xml:space="preserve">
          <source>The overall effect is to force all future readers of each call site's target to accept the most recently stored value. (&quot;Most recently&quot; is reckoned relative to the &lt;code&gt;syncAll&lt;/code&gt; itself.) Conversely, the &lt;code&gt;syncAll&lt;/code&gt; call may block until all readers have (somehow) decached all previous versions of each call site's target.</source>
          <target state="translated">전반적인 효과는 각 콜 사이트 대상의 미래의 모든 독자가 가장 최근에 저장된 값을 수락하도록하는 것입니다. ( &quot;가장 최근&quot;은 &lt;code&gt;syncAll&lt;/code&gt; 자체 와 관련하여 계산 됩니다.) 반대로, &lt;code&gt;syncAll&lt;/code&gt; 호출은 모든 독자가 각 호출 사이트 대상의 모든 이전 버전을 캐시 할 때까지 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81d6288655d85e74abf1180320ee72013eb469e" translate="yes" xml:space="preserve">
          <source>The overloads that accept &lt;code&gt;Name&lt;/code&gt; are useful for applications that need to manipulate names: composing them, comparing components, and so on. The overloads that accept string names are likely to be more useful for simple applications, such as those that simply read in a name and look up the corresponding object.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 을 허용하는 오버로드는 이름을 구성하고 구성 요소를 비교하는 등의 이름을 조작해야하는 응용 프로그램에 유용합니다. 문자열 이름을 허용하는 오버로드는 단순히 이름을 읽고 해당 객체를 찾는 것과 같은 간단한 응용 프로그램에 더 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf7fb65cedad5b648dd187476b8ae459f6736b04" translate="yes" xml:space="preserve">
          <source>The owner of this decoder.</source>
          <target state="translated">이 디코더의 소유자</target>
        </trans-unit>
        <trans-unit id="960d60a6630ecd199aafa78b55469fbc9767c71b" translate="yes" xml:space="preserve">
          <source>The owner of this encoder.</source>
          <target state="translated">이 인코더의 소유자</target>
        </trans-unit>
        <trans-unit id="1f5a4430fc7ac0d6794758f4e8205b46eb2301e9" translate="yes" xml:space="preserve">
          <source>The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using &lt;a href=&quot;pack200.packer#properties--&quot;&gt;&lt;code&gt;properties()&lt;/code&gt;&lt;/a&gt;) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in</source>
          <target state="translated">팩 엔진은 아래 속성에 설명 된대로 초기 상태로 초기화됩니다. 엔진 속성을 가져오고 ( &lt;a href=&quot;pack200.packer#properties--&quot;&gt; &lt;code&gt;properties()&lt;/code&gt; &lt;/a&gt; ) 수정 된 속성을 맵에 저장하여 초기 상태를 조작 할 수 있습니다 . 리소스 파일은 전혀 변경되지 않고 전달됩니다. 압축 풀기 프로그램은 상수 풀 순서와 같은 부 클래스 파일 기능을 자유롭게 변경할 수 있으므로 클래스 파일에는 동일한 바이트가 포함되지 않습니다. 그러나 클래스 파일은 다음과 같이 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d825e3d7dabee111214c86ef931cdc1b54776a9a" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e60248a43a81f58023b88492a2d08616c29b5dfb" translate="yes" xml:space="preserve">
          <source>The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newPacker--&quot;&gt;&lt;code&gt;Pack200.newPacker()&lt;/code&gt;&lt;/a&gt;. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.</source>
          <target state="translated">패커 엔진은 입력 JAR 파일에 다양한 변환을 적용하여 gzip 또는 zip과 같은 압축기로 압축 가능한 압축 스트림을 만듭니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newPacker--&quot;&gt; &lt;code&gt;Pack200.newPacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 . 높은 압축률은 JSR 200 사양에 설명 된 여러 기술을 사용하여 달성됩니다. 기술 중 일부는 상수 풀의 정렬, 재정렬 및 ​​배치입니다.</target>
        </trans-unit>
        <trans-unit id="5254cf384974df4bf22cb621e6eb98fe1516e0c5" translate="yes" xml:space="preserve">
          <source>The paged-results control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 된 결과 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.319입니다.</target>
        </trans-unit>
        <trans-unit id="866b80818a098f96114ee08abb23a44885090886" translate="yes" xml:space="preserve">
          <source>The paged-results response control's assigned object identifier is 1.2.840.113556.1.4.319.</source>
          <target state="translated">페이징 된 결과 응답 컨트롤의 할당 된 개체 식별자는 1.2.840.113556.1.4.319입니다.</target>
        </trans-unit>
        <trans-unit id="24552a8980b41276ccd5905a6aaeeb53f392d59d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;n&lt;/code&gt; must be in the range 0 through 999999999, inclusive. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; returns &lt;a href=&quot;bigdecimal#ONE&quot;&gt;&lt;code&gt;ONE&lt;/code&gt;&lt;/a&gt;. Note that future releases may expand the allowable exponent range of this method.</source>
          <target state="translated">매개 변수 &lt;code&gt;n&lt;/code&gt; 은 0-999999999 범위에 있어야합니다. &lt;code&gt;ZERO.pow(0)&lt;/code&gt; 은 &lt;a href=&quot;bigdecimal#ONE&quot;&gt; &lt;code&gt;ONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 향후 릴리스에서는이 방법의 허용 가능한 지수 범위가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ef4f0e5646bef0741f18b4f02a8cea83921ea8" translate="yes" xml:space="preserve">
          <source>The parameter values retain their original case, except a charset parameter value for a text media type is converted to lowercase.</source>
          <target state="translated">텍스트 매체 유형의 문자 세트 매개 변수 값이 소문자로 변환되는 것을 제외하고 매개 변수 값은 원래 대소 문자를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bb39ffff0d8075952f90c8c237468e1f45f1c684" translate="yes" xml:space="preserve">
          <source>The parameters are arranged in ascending order of parameter name.</source>
          <target state="translated">매개 변수는 매개 변수 이름의 오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="11e0d4edf362f7c76332fc4450bc63049b256eb3" translate="yes" xml:space="preserve">
          <source>The parameters are not authenticated by the &lt;code&gt;SSLEngine&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;SSLEngine&lt;/code&gt; 에 의해 인증되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a4ae335f84321e13f212ee4b121568c174875cb3" translate="yes" xml:space="preserve">
          <source>The parameters consist of a version number, a rounds count, a word size, and optionally an initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 버전 번호, 반올림 횟수, 단어 크기 및 선택적으로 초기화 벡터 (IV) (피드백 모드에서만)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f8d6f3c8b03d8da1385862cfad5502762462d5" translate="yes" xml:space="preserve">
          <source>The parameters consist of an effective key size and optionally an 8-byte initialization vector (IV) (only in feedback mode).</source>
          <target state="translated">매개 변수는 유효 키 크기와 선택적으로 8 바이트 IV (IV)로 구성됩니다 (피드백 모드에서만).</target>
        </trans-unit>
        <trans-unit id="0b947091ed01239ac2c63710914b838d30a607d9" translate="yes" xml:space="preserve">
          <source>The parameters of the underlying executable do not necessarily have unique names, or names that are legal identifiers in the Java programming language (JLS 3.8).</source>
          <target state="translated">기본 실행 파일의 매개 변수에 고유 이름 또는 Java 프로그래밍 언어 (JLS 3.8)의 유효한 식별자 인 이름이 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76d53ff74b412d6d37047d16013d75e50df36de2" translate="yes" xml:space="preserve">
          <source>The parameters represent the two parts of a phrase like '6 Hours'. For example:</source>
          <target state="translated">매개 변수는 '6 Hours'와 같은 문구의 두 부분을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad7182414b3d2ec2fdd16dc0fcb2c6566049a62c" translate="yes" xml:space="preserve">
          <source>The parameters specified by an &lt;code&gt;ImageReadParam&lt;/code&gt; are applied to an image as follows. First, if a rendering size has been set by &lt;code&gt;setSourceRenderSize&lt;/code&gt;, the entire decoded image is rendered at the size given by &lt;code&gt;getSourceRenderSize&lt;/code&gt;. Otherwise, the image has its natural size given by &lt;code&gt;ImageReader.getWidth&lt;/code&gt; and &lt;code&gt;ImageReader.getHeight&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 에 의해 지정된 매개 변수 는 다음과 같이 이미지에 적용됩니다. 먼저, 렌더링 크기가 &lt;code&gt;setSourceRenderSize&lt;/code&gt; 에 의해 설정된 경우 , 디코딩 된 전체 이미지는 &lt;code&gt;getSourceRenderSize&lt;/code&gt; 가 제공 한 크기로 렌더링됩니다 . 그렇지 않으면 이미지는 &lt;code&gt;ImageReader.getWidth&lt;/code&gt; 및 &lt;code&gt;ImageReader.getHeight&lt;/code&gt; 에 의해 주어진 자연 크기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf95408183e18e8026be8d135af97a9475df373" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuite and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 ciphersuite 및 protocols 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b52384d72a0f4af8de4f042358cf9996bbe18cf1" translate="yes" xml:space="preserve">
          <source>The parameters will always have the ciphersuites and protocols arrays set to non-null values.</source>
          <target state="translated">매개 변수는 항상 암호 스위트 및 프로토콜 배열이 널이 아닌 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc871c3368e0f342532a2f5e48a852376491cab" translate="yes" xml:space="preserve">
          <source>The parent &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">부모 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d74755cef612aee13f4b446f05e5c5a94e3a7a37" translate="yes" xml:space="preserve">
          <source>The parent Preferences node whose child was added or removed</source>
          <target state="translated">하위가 추가 또는 제거 된 상위 환경 설정 노드</target>
        </trans-unit>
        <trans-unit id="f994dff1510a6e8c2918e9b6d01ec794ebf2150e" translate="yes" xml:space="preserve">
          <source>The parent bundle of this bundle. The parent bundle is searched by &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt;&lt;code&gt;getObject&lt;/code&gt;&lt;/a&gt; when this bundle does not contain a particular resource.</source>
          <target state="translated">이 번들의 상위 번들입니다. 이 번들에 특정 자원이없는 경우 &lt;a href=&quot;resourcebundle#getObject-java.lang.String-&quot;&gt; &lt;code&gt;getObject&lt;/code&gt; &lt;/a&gt; 가 상위 번들을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="3ecda3b1f4f94be292091c923d129f7d53c68915" translate="yes" xml:space="preserve">
          <source>The parent of this path object consists of this path's root component, if any, and each element in the path except for the &lt;em&gt;farthest&lt;/em&gt; from the root in the directory hierarchy. This method does not access the file system; the path or its parent may not exist. Furthermore, this method does not eliminate special names such as &quot;.&quot; and &quot;..&quot; that may be used in some implementations. On UNIX for example, the parent of &quot;&lt;code&gt;/a/b/c&lt;/code&gt;&quot; is &quot;&lt;code&gt;/a/b&lt;/code&gt;&quot;, and the parent of &lt;code&gt;&quot;x/y/.&lt;/code&gt;&quot; is &quot;&lt;code&gt;x/y&lt;/code&gt;&quot;. This method may be used with the &lt;a href=&quot;path#normalize--&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; method, to eliminate redundant names, for cases where &lt;em&gt;shell-like&lt;/em&gt; navigation is required.</source>
          <target state="translated">이 경로 객체의 부모는이 경로의 루트 구성 요소 (있는 경우)와 디렉토리 계층의 루트에서 &lt;em&gt;가장 먼&lt;/em&gt; 것을 제외하고 경로의 각 요소로 구성됩니다 . 이 방법은 파일 시스템에 액세스하지 않습니다. 경로 나 그 부모가 존재하지 않을 수 있습니다. 또한이 방법은 &quot;.&quot;와 같은 특수 이름을 제거하지 않습니다. 및 일부 구현에 사용될 수있는 &quot;..&quot; 예를 들어 UNIX에서 &quot; &lt;code&gt;/a/b/c&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;/a/b&lt;/code&gt; &quot;이고 &lt;code&gt;&quot;x/y/.&lt;/code&gt; &quot; 의 부모 는 &quot; &lt;code&gt;x/y&lt;/code&gt; &quot;입니다. &lt;em&gt;쉘과 같은&lt;/em&gt; 탐색이 필요한 경우 중복 이름을 제거하기 &lt;a href=&quot;path#normalize--&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 방법을 normalize 방법 과 함께 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a34ccef159a0d71e1f63c70bb6fe8aedb77a7a54" translate="yes" xml:space="preserve">
          <source>The parsed value. Passing an integer that corresponds to a known name (e.g., 700) will return the associated name (e.g., &lt;code&gt;CONFIG&lt;/code&gt;). Passing an integer that does not (e.g., 1) will return a new level name initialized to that value.</source>
          <target state="translated">파싱 ​​된 값입니다. 알려진 이름 (예 : 700)에 해당하는 정수를 전달하면 관련 이름 (예 : &lt;code&gt;CONFIG&lt;/code&gt; ) 이 반환됩니다 . 그렇지 않은 정수 (예 : 1)를 전달하면 해당 값으로 초기화 된 새 수준 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21ff5f3cdc66539833c1fbafaf60db7a54685bb2" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 최대한 많은 자릿수를 허용하면서 탐욕스럽게 동작합니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f6b73693478a0455ddabfd20c4e13a83419854e" translate="yes" xml:space="preserve">
          <source>The parser for a variable width value such as this normally behaves greedily, requiring one digit, but accepting as many digits as possible. This behavior can be affected by 'adjacent value parsing'. See &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt;&lt;/a&gt; for full details.</source>
          <target state="translated">이와 같은 가변 너비 값에 대한 파서는 일반적으로 탐욕스럽게 동작하며 한 자리를 요구하지만 가능한 한 많은 자리를 받아들입니다. 이 동작은 '인접한 값 구문 분석'의 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;datetimeformatterbuilder#appendValue-java.time.temporal.TemporalField-int-&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ee7fce3ce38754400a5fb2ffa707a2159a2a86a" translate="yes" xml:space="preserve">
          <source>The parsing and conversion to a path object is inherently implementation dependent. In the simplest case, the path string is rejected, and &lt;a href=&quot;invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; thrown, if the path string contains characters that cannot be converted to characters that are &lt;em&gt;legal&lt;/em&gt; to the file store. For example, on UNIX systems, the NUL (\u0000) character is not allowed to be present in a path. An implementation may choose to reject path strings that contain names that are longer than those allowed by any file store, and where an implementation supports a complex path syntax, it may choose to reject path strings that are &lt;em&gt;badly formed&lt;/em&gt;.</source>
          <target state="translated">경로 객체에 대한 구문 분석 및 변환은 본질적으로 구현에 따라 다릅니다. 가장 간단한 경우, 경로 문자열 에 파일 저장소에 &lt;em&gt;적합한&lt;/em&gt; 문자로 변환 할 수없는 문자가 포함 된 경우 경로 문자열이 거부되고 &lt;a href=&quot;invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 이&lt;/a&gt; 발생 합니다. 예를 들어, UNIX 시스템에서 NUL (\ u0000) 문자는 경로에 존재할 수 없습니다. 구현은 파일 저장소가 허용하는 것보다 긴 이름을 포함하는 경로 문자열을 거부하도록 선택할 수 있으며 구현이 복잡한 경로 구문을 지원하는 경우 &lt;em&gt;잘못 구성된&lt;/em&gt; 경로 문자열을 거부하도록 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0514c11ef515545f2db88b599f4ee46a343c496c" translate="yes" xml:space="preserve">
          <source>The part of the link name that has not been resolved. It is a composite name. It can be null, which means the link remaining name field has not been set.</source>
          <target state="translated">해결되지 않은 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있으며, 이는 링크 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="47baf3ca1b3134d4434d6cb4c6eec321ec81a768" translate="yes" xml:space="preserve">
          <source>The part of the link name that was resolved successfully. It is a composite name. It can be null, which means the link resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 링크 이름 부분. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 링크 해석 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="32726d1c2037f095bb11ef491521f5e2b8d6ac95" translate="yes" xml:space="preserve">
          <source>The part of the name that has not been resolved. It is a composite name. It can be null, which means the remaining name field has not been set.</source>
          <target state="translated">확인되지 않은 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 나머지 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ec9433b1d02006377972147afe60dd9073ccb8e0" translate="yes" xml:space="preserve">
          <source>The part of the name that was resolved successfully. It is a composite name. It can be null, which means the resolved name field has not been set.</source>
          <target state="translated">성공적으로 해결 된 이름의 일부입니다. 합성 이름입니다. 널 (null) 일 수 있습니다. 이는 해석 된 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a0ccdd4edd6b9daa6601aef32f68b66801d49f2d" translate="yes" xml:space="preserve">
          <source>The particular &lt;code&gt;ImageReader&lt;/code&gt; implementation may choose how often to provide updates. Each update specifies that a given region of the image has been updated since the last update. A region is described by its spatial bounding box (&lt;code&gt;minX&lt;/code&gt;, &lt;code&gt;minY&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;); X and Y subsampling factors (&lt;code&gt;periodX&lt;/code&gt; and &lt;code&gt;periodY&lt;/code&gt;); and a set of updated bands (&lt;code&gt;bands&lt;/code&gt;). For example, the update:</source>
          <target state="translated">특정 &lt;code&gt;ImageReader&lt;/code&gt; 구현은 업데이트를 제공하는 빈도를 선택할 수 있습니다. 각 업데이트는 마지막 업데이트 이후 이미지의 특정 영역이 업데이트되었음을 ​​지정합니다. 영역은 공간 경계 상자 ( &lt;code&gt;minX&lt;/code&gt; , &lt;code&gt;minY&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; )로 설명됩니다. X 및 Y 서브 샘플링 인자 ( &lt;code&gt;periodX&lt;/code&gt; 및 &lt;code&gt;periodY&lt;/code&gt; ); 및 업데이트 된 밴드 세트 ( &lt;code&gt;bands&lt;/code&gt; ). 예를 들어, 업데이트 :</target>
        </trans-unit>
        <trans-unit id="2d05bd905575708b902adb79797980be7e49876a" translate="yes" xml:space="preserve">
          <source>The particular compression scheme to be used can be specified by using the &lt;code&gt;setCompressionType()&lt;/code&gt; method with the appropriate type string. The compression scheme specified will be honored if and only if it is compatible with the type of image being written. If the specified compression scheme is not compatible with the type of image being written then the &lt;code&gt;IOException&lt;/code&gt; will be thrown by the BMP image writer. If the compression type is not set explicitly then &lt;code&gt;getCompressionType()&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;. In this case the BMP image writer will select a compression type that supports encoding of the given image without loss of the color resolution.</source>
          <target state="translated">사용되는 특정 압축 체계 는 적절한 유형 문자열과 함께 &lt;code&gt;setCompressionType()&lt;/code&gt; 메소드를 사용하여 지정할 수 있습니다 . 지정된 압축 방식은 작성중인 이미지 유형과 호환되는 경우에만 적용됩니다. 지정된 압축 방식이 기록중인 이미지 유형과 호환되지 않으면 BMP 이미지 기록기에 의해 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다. 압축 유형이 명시 적으로 설정되지 않으면 &lt;code&gt;getCompressionType()&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 이 경우 BMP 이미지 기록기는 색상 해상도 손실없이 지정된 이미지의 인코딩을 지원하는 압축 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e8241d354a88f83dd6e313eef3dc68fb3e944175" translate="yes" xml:space="preserve">
          <source>The password can be viewed as some kind of raw key material, from which the encryption mechanism that uses it derives a cryptographic key.</source>
          <target state="translated">암호는 일종의 원시 키 자료로 볼 수 있으며 암호 키를 사용하는 암호화 메커니즘은 암호 키를 파생합니다.</target>
        </trans-unit>
        <trans-unit id="820e2577f359bf6935013e53ac3bf2a5b32541fa" translate="yes" xml:space="preserve">
          <source>The past notifications sending on/off flag value.</source>
          <target state="translated">과거 / 이전 알림 전송 / 해제 플래그 값.</target>
        </trans-unit>
        <trans-unit id="2dff58ea6e8968b95e225bc5373e375d5474c33c" translate="yes" xml:space="preserve">
          <source>The path</source>
          <target state="translated">경로</target>
        </trans-unit>
        <trans-unit id="34dc364ae2dbeed42a8b0e59b6b7f50e29642280" translate="yes" xml:space="preserve">
          <source>The path component of a URI, if defined, only contains the slash character (&lt;code&gt;'/'&lt;/code&gt;), the commercial-at character (&lt;code&gt;'@'&lt;/code&gt;), and characters in the</source>
          <target state="translated">URI의 경로 구성 요소에는 정의 된 경우 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; ), 상업 문자 ( &lt;code&gt;'@'&lt;/code&gt; ) 및</target>
        </trans-unit>
        <trans-unit id="ce374624d095692df597972be967a92da604ae1f" translate="yes" xml:space="preserve">
          <source>The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character (&lt;code&gt;'/'&lt;/code&gt;); otherwise it is relative. The path of a hierarchical URI that is either absolute or specifies an authority is always absolute.</source>
          <target state="translated">계층 적 URI의 경로 구성 요소는 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작하는 경우 절대적이라고합니다 . 그렇지 않으면 상대적입니다. 절대적이거나 권한을 지정하는 계층 적 URI의 경로는 항상 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="984a1006edcb13d7a44e0aa4a2152ea60b272a92" translate="yes" xml:space="preserve">
          <source>The path component of this URI, or &lt;code&gt;null&lt;/code&gt; if the path is undefined</source>
          <target state="translated">이 URI의 패스 컴퍼넌트 . 패스가 정의되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a70f79521a69bb3942223fa682e3262fee7ae26f" translate="yes" xml:space="preserve">
          <source>The path length constraint has been violated.</source>
          <target state="translated">경로 길이 제약 조건을 위반했습니다.</target>
        </trans-unit>
        <trans-unit id="5c2d067f7af76e2b06945d71f3ec990142c7f99d" translate="yes" xml:space="preserve">
          <source>The pathname string of the parent directory named by this abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</source>
          <target state="translated">이 추상 패스 명이 가리키는 친 디렉토리의 패스 명 문자열.이 패스 명이 부모를 나타내지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44bfbe0740e4812ab2ebef01403857fd4763cbc0" translate="yes" xml:space="preserve">
          <source>The pattern for which this matcher was created</source>
          <target state="translated">이 매 처가 작성된 패턴</target>
        </trans-unit>
        <trans-unit id="228163f26ece9e76769fe19d43640bb8467f3d60" translate="yes" xml:space="preserve">
          <source>The period added is a multiple of this unit. For example, this method could be used to add &quot;3 days&quot; to a date by calling this method on the instance representing &quot;days&quot;, passing the date and the period &quot;3&quot;. The period to be added may be negative, which is equivalent to subtraction.</source>
          <target state="translated">추가 된 기간은이 단위의 배수입니다. 예를 들어, &quot;days&quot;를 나타내는 인스턴스에서이 메소드를 호출하고 날짜와 기간을 &quot;3&quot;으로 전달하여이 메소드를 사용하여 날짜에 &quot;3 일&quot;을 추가 할 수 있습니다. 더해지는주기는 음수 일 수 있으며, 이는 빼기와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fdc88c8af0c7b558ba1c4c23f7e65140ebfa762" translate="yes" xml:space="preserve">
          <source>The period character &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;, &lt;small&gt;FULL STOP&lt;/small&gt;),</source>
          <target state="translated">마침표 문자 &lt;code&gt;'.'&lt;/code&gt; ( &lt;code&gt;'\u002e'&lt;/code&gt; , 완전 &lt;small&gt;정지&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8a43a4749a0092ff01f681602eba4d1752639395" translate="yes" xml:space="preserve">
          <source>The period is defined by the chronology. It controls the supported units and restricts addition/subtraction to &lt;code&gt;ChronoLocalDate&lt;/code&gt; instances of the same chronology.</source>
          <target state="translated">기간은 연대기에 의해 정의됩니다. 지원되는 단위를 제어하고 동일한 연대기의 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 인스턴스에 더하기 / 빼기를 ​​제한 합니다.</target>
        </trans-unit>
        <trans-unit id="1a70990b9e6545d7eddd1d2d67af5b8ba6080247" translate="yes" xml:space="preserve">
          <source>The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.</source>
          <target state="translated">기간은 지정된 시간으로 모델링되므로 기간의 개별 부분이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905e0e83c9c4d3f7868b0477d055820ab11f5e8d" translate="yes" xml:space="preserve">
          <source>The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com.</source>
          <target state="translated">반환 된 권한은 연결 상태에 따라 달라질 수 있습니다. 예를 들어 연결 전의 권한이 연결 후의 권한과 다를 수 있습니다. 예를 들어 foo.com과 같은 HTTP 서버는 다른 호스트 (예 : bar.com)로 연결을 리디렉션 할 수 있습니다. 연결 전에 반환 된 권한은 foo.com에 연결하는 데 필요한 권한을 나타내며 연결 후 반환 된 권한은 bar.com입니다.</target>
        </trans-unit>
        <trans-unit id="9aec82e1b8e6d992b0690a908ac3aedc9b31e177" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls methods defined in the management interface for the Java platform.</source>
          <target state="translated">SecurityManager로 실행중인 코드가 Java 플랫폼의 관리 인터페이스에 정의 된 메소드를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="e5faa7a6949030f63d05138d5d40aa6ac04a730d" translate="yes" xml:space="preserve">
          <source>The permission which the SecurityManager will check when code that is running with a SecurityManager calls one of the logging control methods (such as Logger.setLevel).</source>
          <target state="translated">SecurityManager로 실행중인 코드가 로깅 제어 방법 중 하나 (예 : Logger.setLevel)를 호출 할 때 SecurityManager가 확인하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="3ddf2138bdbeea3a72c2017234d8cedbfdba2c4d" translate="yes" xml:space="preserve">
          <source>The platform uses signed two's complement integer arithmetic with int and long primitive types. The developer should choose the primitive type to ensure that arithmetic operations consistently produce correct results, which in some cases means the operations will not overflow the range of values of the computation. The best practice is to choose the primitive type and algorithm to avoid overflow. In cases where the size is &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; and overflow errors need to be detected, the methods &lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt;, &lt;code&gt;multiplyExact&lt;/code&gt;, and &lt;code&gt;toIntExact&lt;/code&gt; throw an &lt;code&gt;ArithmeticException&lt;/code&gt; when the results overflow. For other arithmetic operations such as divide, absolute value, increment, decrement, and negation overflow occurs only with a specific minimum or maximum value and should be checked against the minimum or maximum as appropriate.</source>
          <target state="translated">이 플랫폼은 int 및 long 기본 유형의 부호있는 2의 보수 정수 산술을 사용합니다. 개발자는 산술 연산이 일관되게 올바른 결과를 생성 할 수 있도록 기본 유형을 선택해야합니다. 이는 경우에 따라 연산이 계산 값 범위를 오버플로하지 않습니다. 가장 좋은 방법은 오버플로를 피하기 위해 기본 유형과 알고리즘을 선택하는 것입니다. 크기가 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이고 오버플로 오류를 감지 &lt;code&gt;addExact&lt;/code&gt; 경우 addExact , &lt;code&gt;subtractExact&lt;/code&gt; , &lt;code&gt;multiplyExact&lt;/code&gt; 및 &lt;code&gt;toIntExact&lt;/code&gt; 메소드 에서 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생합니다.결과가 오버플로 될 때 나누기, 절대 값, 증분, 감소 및 부정 오버플로와 같은 다른 산술 연산의 경우 특정 최소값 또는 최대 값으로 만 발생하며, 최소값 또는 최대 값에 대해 적절하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7521e50eec810dafda8ec390ca964f1fb534790" translate="yes" xml:space="preserve">
          <source>The plus character &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;, &lt;small&gt;PLUS SIGN&lt;/small&gt;),</source>
          <target state="translated">더하기 문자 &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; , &lt;small&gt;PLUS SIGN&lt;/small&gt; ),</target>
        </trans-unit>
        <trans-unit id="8de422a879c63cd1d08f600a6e2474b68479ffa1" translate="yes" xml:space="preserve">
          <source>The plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot; is converted into a space character &quot; &quot; .</source>
          <target state="translated">더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot;는 공백 문자 &quot;&quot;로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="770068703e30a0ae5899254519c58354757383e7" translate="yes" xml:space="preserve">
          <source>The policies can be certificate-based or may depend on other authentication schemes.</source>
          <target state="translated">정책은 인증서 기반이거나 다른 인증 체계에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9410b63b7333b991d16e974b0ea1ae55586212" translate="yes" xml:space="preserve">
          <source>The policy constraints have been violated.</source>
          <target state="translated">정책 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b63ad61faf90a50a857b840faad61a57d9a475d" translate="yes" xml:space="preserve">
          <source>The policy for a Java runtime (specifying which permissions are available for code from various principals) is represented by a Policy object. Whenever a Policy is initialized or refreshed, Permission objects of appropriate classes are created for all permissions allowed by the Policy.</source>
          <target state="translated">Java 런타임에 대한 정책 (다양한 주체의 코드에 사용 가능한 권한 지정)은 Policy 개체로 표시됩니다. 정책이 초기화되거나 새로 고쳐질 때마다 정책에서 허용하는 모든 권한에 대해 적절한 클래스의 권한 개체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2fdaf80d95e0f5e31151be71383e818b9ccadd36" translate="yes" xml:space="preserve">
          <source>The port component of a URI, if defined, is a non-negative integer.</source>
          <target state="translated">URI의 포트 구성 요소는 정의 된 경우 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="465e20b5e3d6b616ff936762b108d3831a17ee64" translate="yes" xml:space="preserve">
          <source>The port component of this URI, or &lt;code&gt;-1&lt;/code&gt; if the port is undefined</source>
          <target state="translated">이 URI의 포트 컴퍼넌트 . 포트가 정의되어 있지 않은 경우는 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2770c496726c2c6a1fb08bb232925adc856e5e7f" translate="yes" xml:space="preserve">
          <source>The port number on the remote host to which this socket is connected.</source>
          <target state="translated">이 소켓이 연결된 원격 호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="17cb13d2105c7d415ffa295626d4a87fddb85329" translate="yes" xml:space="preserve">
          <source>The port of the Service URL. If no port was specified, the returned value is 0.</source>
          <target state="translated">서비스 URL의 포트입니다. 포트가 지정되지 않은 경우 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="356c1293f756ffbef5fc572bed0d988e81455650" translate="yes" xml:space="preserve">
          <source>The port or portrange is optional. A port specification of the form &quot;N-&quot;, where</source>
          <target state="translated">포트 또는 포트 범위는 선택 사항입니다. &quot;N-&quot;형식의 포트 사양. 여기서</target>
        </trans-unit>
        <trans-unit id="a50d6c96a3e4d969a207bbe35ece3c77d64fdbff" translate="yes" xml:space="preserve">
          <source>The portion of a private use subtag prefixed by &quot;lvariant&quot;, if any, is removed and appended to the variant field in the result locale (without case normalization). If it is then empty, the private use subtag is discarded:</source>
          <target state="translated">접두사가 &quot;lvariant&quot;인 접두사가있는 개인용 서브 태그 부분이 제거되고 결과 로케일의 변형 필드에 추가됩니다 (사례 정규화없이). 비어있는 경우 개인용 하위 태그는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dade22179ed59dcfbad33f06553c3e366962e9c8" translate="yes" xml:space="preserve">
          <source>The position</source>
          <target state="translated">위치</target>
        </trans-unit>
        <trans-unit id="9aa972c882e959af5cfa74686b743fa2cca90fbe" translate="yes" xml:space="preserve">
          <source>The position of mark in buffer.</source>
          <target state="translated">버퍼에서 마크의 위치.</target>
        </trans-unit>
        <trans-unit id="5a10a32b9ba1b850952eb01a2dac5b8e40ece025" translate="yes" xml:space="preserve">
          <source>The position of this buffer</source>
          <target state="translated">이 버퍼의 위치</target>
        </trans-unit>
        <trans-unit id="c4ecb0a7945551375751ca2e25e871a33f35f2b7" translate="yes" xml:space="preserve">
          <source>The position prior to which data may be discarded. Seeking to a smaller position is not allowed. &lt;code&gt;flushedPos&lt;/code&gt; will always be &amp;gt;= 0.</source>
          <target state="translated">데이터를 버릴 수있는 위치입니다. 더 작은 위치를 찾는 것은 허용되지 않습니다. &lt;code&gt;flushedPos&lt;/code&gt; 는 항상&amp;gt; = 0입니다.</target>
        </trans-unit>
        <trans-unit id="ce0957d483aceb3b45553d641f8c629ba289ca24" translate="yes" xml:space="preserve">
          <source>The position within the pushback buffer from which the next byte will be read. When the buffer is empty, &lt;code&gt;pos&lt;/code&gt; is equal to &lt;code&gt;buf.length&lt;/code&gt;; when the buffer is full, &lt;code&gt;pos&lt;/code&gt; is equal to zero.</source>
          <target state="translated">다음 바이트를 읽을 푸시 백 버퍼 내의 위치입니다. 버퍼가 비어 있으면 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;buf.length&lt;/code&gt; 와 같습니다 . 버퍼가 가득 차면 &lt;code&gt;pos&lt;/code&gt; 는 0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7548ff65d5ee10f38621f470acbd0447c4140b54" translate="yes" xml:space="preserve">
          <source>The possible actions are these:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30057bbd133f892768abece91c4328fc6c016d37" translate="yes" xml:space="preserve">
          <source>The possible actions are:</source>
          <target state="translated">가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b7bd960ee00d4b00678a55c5cbb406785c27c39" translate="yes" xml:space="preserve">
          <source>The possible target names for an Authentication Permission are:</source>
          <target state="translated">인증 권한의 가능한 대상 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a3e78cdd39c4f87760b3390e7efcd189cdc7308" translate="yes" xml:space="preserve">
          <source>The possible ways to connect to the host are</source>
          <target state="translated">호스트에 연결하는 가능한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="080f48b0aa6b32cedd5af01121bd7b1bfc958102" translate="yes" xml:space="preserve">
          <source>The possibly null ID of the bad attribute.</source>
          <target state="translated">잘못된 속성의 null ID 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7991f6067c19c449119e08d159087dc4972217" translate="yes" xml:space="preserve">
          <source>The possibly null address contents.</source>
          <target state="translated">가능한 null 주소 내용.</target>
        </trans-unit>
        <trans-unit id="4ed5af77681adda9a6ccec629fa59a1a47e0566d" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt; that was removed; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 에서 제거 되었을 가능성이있는 속성 값입니다 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="75e1e093b3b31beab3f725db1a7a97f735291ed2" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index &lt;code&gt;ix&lt;/code&gt;; null if the attribute value is null.</source>
          <target state="translated">인덱스 &lt;code&gt;ix&lt;/code&gt; 의 null 가능성이있는 속성치 . 속성 값이 null의 경우는 null</target>
        </trans-unit>
        <trans-unit id="01e53a4583b8b632e31e23e545835d7fb151953e" translate="yes" xml:space="preserve">
          <source>The possibly null attribute value at index ix that was replaced. Null if the attribute value was null.</source>
          <target state="translated">대체 된 인덱스 ix의 null 가능성이있는 속성 값입니다. 속성 값이 null 인 경우는 null</target>
        </trans-unit>
        <trans-unit id="77bb1fce5266fd4ed13f0e3a64b2e033cc88d05b" translate="yes" xml:space="preserve">
          <source>The possibly null attributes to be bound.</source>
          <target state="translated">바인딩 가능한 null 속성입니다.</target>
        </trans-unit>
        <trans-unit id="71f9a1ed0e575411b69d0a23112e14cf08307845" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object after the change.</source>
          <target state="translated">변경 후 객체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="303282c69dc7d698ff760f2ed06dfbbad81206cb" translate="yes" xml:space="preserve">
          <source>The possibly null binding of the object before the change.</source>
          <target state="translated">변경 전의 개체의 null 바인딩 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be200430acab3902acee3be25723c5883a236b4b" translate="yes" xml:space="preserve">
          <source>The possibly null challenge to send to the client. It is null if the authentication has succeeded and there is no more challenge data to be sent to the client.</source>
          <target state="translated">클라이언트에게 보낼 가능성이있는 챌린지. 인증에 성공했으며 클라이언트에 더 이상 시도 할 데이터가없는 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="288430f98d1d8dc902d6cd0f841e573864bef168" translate="yes" xml:space="preserve">
          <source>The possibly null change information of this event.</source>
          <target state="translated">이 이벤트의 null 가능성이있는 정보</target>
        </trans-unit>
        <trans-unit id="ef5328e9a2c12269fc3c9790ffb3bdf7b904c77d" translate="yes" xml:space="preserve">
          <source>The possibly null class name of object bound. It is null if the object bound is null.</source>
          <target state="translated">바인딩 된 개체의 null 클래스 이름입니다. 바인드 된 오브젝트가 널인 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="ffd8994818808e7044f5a7bd47401c36f2d57625" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about the problem with resolving a link. If null, it means there is no link detail message for this exception.</source>
          <target state="translated">링크를 해결하는 데 대한 문제점에 대해 자세히 설명하는 가능한 상세 문자열입니다. null의 경우,이 예외에 대한 링크 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="67a7663ef453f501bcf8141dc78d296c77c8d264" translate="yes" xml:space="preserve">
          <source>The possibly null detail string explaining more about this exception. If null, it means there is no detail message for this exception.</source>
          <target state="translated">이 예외에 대해 더 설명하는 null 가능성이있는 문자열입니다. null의 경우,이 예외에 관한 상세 메세지가없는 것을 의미한다</target>
        </trans-unit>
        <trans-unit id="2dbbcea44ff699506e27e77c0ad6dc0d7cd34a86" translate="yes" xml:space="preserve">
          <source>The possibly null element in the enumeration. null is only valid for enumerations that can return null (e.g. Attribute.getAll() returns an enumeration of attribute values, and an attribute value can be null).</source>
          <target state="translated">열거에서 가능한 null 요소입니다. null은 null을 반환 할 수있는 열거에만 유효합니다 (예 : Attribute.getAll ()은 속성 값의 열거를 반환하고 속성 값은 null 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="50e6ea1bbf4d3d242e0442515defbd02966a7734" translate="yes" xml:space="preserve">
          <source>The possibly null exception that caused this naming exception. If null, it means no root cause has been set for this naming exception.</source>
          <target state="translated">이 이름 지정 예외의 원인이 된 null 예외입니다. null의 경우,이 네이밍 예외에 근본 원인이 설정되어 있지 않은 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce85339be4b00e60548e7a67ece14ecc99dfce86" translate="yes" xml:space="preserve">
          <source>The possibly null fully-qualified class name of the factory. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">팩토리의 null 정규화 클래스 명일 가능성이 있습니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="53819d8f2ff0666381a9127d62f2914f015d222f" translate="yes" xml:space="preserve">
          <source>The possibly null matching rule ID. If null then the ordering matching rule defined for the sort key attribute is used.</source>
          <target state="translated">가능한 null 일치 규칙 ID입니다. null의 경우, 소트 키 속성으로 정의 된 순서 일치 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7693eebba3b1d8e8aed9065f755c90ca9438ca" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. If null, it means the link resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. 널인 경우, 링크 분석 오브젝트 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97169d9b8c4d89f8a301ca6eb28fad9af6f33b5c" translate="yes" xml:space="preserve">
          <source>The possibly null object that was resolved so far. null means that the resolved object field has not been set.</source>
          <target state="translated">지금까지 해결 된 null 가능성이있는 개체입니다. null은 확인 된 개체 필드가 ​​설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ce6afd310045ea10e313ef96d7542591a1cd218" translate="yes" xml:space="preserve">
          <source>The possibly null object to be bound.</source>
          <target state="translated">바인딩 가능한 null 개체입니다.</target>
        </trans-unit>
        <trans-unit id="644a895b0ec7420afe1f7206497a62be42cccfd6" translate="yes" xml:space="preserve">
          <source>The possibly null part of the new name that has not been resolved. It is a composite name. It can be null, which means the remaining new name field has not been set.</source>
          <target state="translated">해결되지 않은 새 이름의 null 부분 일 수 있습니다. 합성 이름입니다. 널일 수 있으며, 이는 나머지 새 이름 필드가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="227b72d26062a0a4a65406d6b2400d858977938f" translate="yes" xml:space="preserve">
          <source>The possibly null response of the operation. null means the operation did not generate any response.</source>
          <target state="translated">작업의 null 응답 일 수 있습니다. null은 작업이 응답을 생성하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95751c0e2100386276d5fbab10fec9eadc434b68" translate="yes" xml:space="preserve">
          <source>The possibly null response to send to the server. It is null if the challenge accompanied a &quot;SUCCESS&quot; status and the challenge only contains data for the client to update its state and no response needs to be sent to the server. The response is a zero-length byte array if the client is to send a response with no data.</source>
          <target state="translated">서버에 보낼 수있는 null 응답입니다. 챌린지에 &quot;SUCCESS&quot;상태가 수반되고 챌린지에 클라이언트가 상태를 업데이트하기위한 데이터 만 포함되어 있고 응답을 서버로 보낼 필요가없는 경우 null입니다. 클라이언트가 데이터없이 응답을 보내야하는 경우 응답은 길이가 0 인 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a9f4959d404525b8010782edbbb82d1a4a73f2c7" translate="yes" xml:space="preserve">
          <source>The possibly null string containing the location for loading in the factory's class.</source>
          <target state="translated">팩토리 클래스에서로드 할 위치가 포함 된 null 문자열 일 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
