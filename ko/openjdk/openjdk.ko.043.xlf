<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="55e80b82ba0e613e2bb9e96436b7f7884b762e6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , 다음하자 &lt;code&gt;ct&lt;/code&gt; 그 수 &lt;code&gt;CompositeType&lt;/code&gt; 에 의해 반환 &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt; . 경우, 결과는 사실 &lt;code&gt;this&lt;/code&gt; 이다 &lt;em&gt;에서 할당 &lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; . 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c5b21be35113bc2c3c5695016e41e7a8961aa607" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 의 인스턴스 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 말 &lt;code&gt;td&lt;/code&gt; 이되면 그 결과는 true입니다 &lt;code&gt;TabularType&lt;/code&gt; 의가 있습니다 &lt;em&gt;에서 할당 &lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt; 에 정의 된대로, &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bc555f2367ab62f427bf89fb970ff34e2a7eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fca7400d753ab2ac94fb4572ae69584ddad617" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;obj&lt;/var&gt; 가 널 (null)이거나의 인스턴스가 아닌 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; , &lt;code&gt;isValue&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6eb29fd93b0c765afc3bd3b512f90a195dcbb2f" translate="yes" xml:space="preserve">
          <source>If BeanContext parameter is null, then it shall associate the Applet with its appropriate Container by adding that Applet to its Container via an invocation of add(). If the BeanContext parameter is non-null, then it is the responsibility of the BeanContext to associate the Applet with its Container during the subsequent invocation of its addChildren() method.</source>
          <target state="translated">BeanContext 파라미터가 null의 경우, add ()의 호출을 사용해 그 애플릿을 컨테이너에 추가하는 것으로 애플릿을 적절한 컨테이너에 관련 짓습니다. BeanContext 매개 변수가 널이 아닌 경우, 이후 addChildren () 메소드 호출 중에 애플릿을 컨테이너와 연관시키는 것은 BeanContext의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b3801f11fd37bcce7f8fba639fe8d4ee887aad7e" translate="yes" xml:space="preserve">
          <source>If C declares a public field with the name specified, that is the field to be reflected.</source>
          <target state="translated">C가 지정된 이름으로 공개 필드를 선언하면 해당 필드가 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="ca26ee5702ced758c636159001396b48df22d8a6" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then this algorithm is invoked recursively on the superclass of C.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 이외의 클래스 인 경우이 알고리즘은 C의 수퍼 클래스에서 재귀 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9b9649ab976d62198d1ec3dfed66527d11d467" translate="yes" xml:space="preserve">
          <source>If C is the class &lt;code&gt;Object&lt;/code&gt;, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</source>
          <target state="translated">C가 &lt;code&gt;Object&lt;/code&gt; 클래스 이거나 C가 인터페이스 인 경우 C (있는 경우)의 수퍼 인터페이스에서 일치하는 메소드를 검색합니다. 그러한 방법이 발견되면 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="2d85abeeeb1aa21f2267ac0f2f921e008ecb6b5d" translate="yes" xml:space="preserve">
          <source>If CPU time measurement is enabled after the thread has started, the Java virtual machine implementation may choose any time up to and including the time that the capability is enabled as the point where CPU time measurement starts.</source>
          <target state="translated">스레드가 시작된 후 CPU 시간 측정이 사용 가능한 경우, JVM (Java Virtual Machine) 구현은 기능이 사용 가능한 시간을 포함하여 CPU 시간 측정이 시작되는 시점을 포함하여 언제든지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b2e184e73a9f507b63cab71f6b6a0fc51255aa" translate="yes" xml:space="preserve">
          <source>If CredentialClass is &quot;*&quot;, then access is granted to all private Credentials belonging to the specified &lt;code&gt;Subject&lt;/code&gt;. If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has the specified &lt;code&gt;Principal&lt;/code&gt; (the actual PrincipalName doesn't matter). For example, the following grants access to the a.b.Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has an a.b.Principal.</source>
          <target state="translated">CredentialClass가 &quot;*&quot;이면 지정된 &lt;code&gt;Subject&lt;/code&gt; 에 속하는 모든 개인 자격 증명에 액세스 권한이 부여됩니다 . &quot;PrincipalName&quot;이 &quot;*&quot;이면 지정된 &lt;code&gt;Principal&lt;/code&gt; 이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 자격 증명에 대한 액세스 권한이 부여됩니다 (실제 PrincipalName은 중요하지 않음). 예를 들어, 다음 은 abPrincipal이있는 모든 &lt;code&gt;Subject&lt;/code&gt; 소유 한 abCredential에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="6a39eb1a01812d32c33a1ca34fe7c0a3f9fe824c" translate="yes" xml:space="preserve">
          <source>If January 1st is Friday then week 1 starts on January 4th</source>
          <target state="translated">1 월 1 일이 금요일이면 1 주차는 1 월 4 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="8212bef3cde7fd918667a428a4beb2926b2aaf30" translate="yes" xml:space="preserve">
          <source>If January 1st is Monday then week 1 starts on January 1st</source>
          <target state="translated">1 월 1 일이 월요일이면 1 월 1 일에 1 주차가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1d8c7e06d2ed477961cc6b9bf02767f72d2e8e" translate="yes" xml:space="preserve">
          <source>If January 1st is Saturday then week 1 starts on January 3rd</source>
          <target state="translated">1 월 1 일이 토요일이면 1 주차는 1 월 3 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="93384845075a732cc09f28c1fdb3a1493434370f" translate="yes" xml:space="preserve">
          <source>If January 1st is Sunday then week 1 starts on January 2nd</source>
          <target state="translated">1 월 1 일이 일요일이면 1 주차는 1 월 2 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d773a45b8b76332ac1c9cf30d6d26cbed25b1ef6" translate="yes" xml:space="preserve">
          <source>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year</source>
          <target state="translated">1 월 1 일이 목요일이면 1 주차는 이전 표준 연도의 12 월 29 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="dff679f893694acfcb5844ad440b7fd91f379885" translate="yes" xml:space="preserve">
          <source>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year</source>
          <target state="translated">1 월 1 일이 화요일이면 1 주차는 이전 표준 연도의 12 월 31 일에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4487b7e39c0d7129e69d67e0df2749862989ef" translate="yes" xml:space="preserve">
          <source>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year</source>
          <target state="translated">1 월 1 일이 수요일이면 1 주차는 전년도의 12 월 30 일에 시작됩니다</target>
        </trans-unit>
        <trans-unit id="f38e0c7c32dd408bc04c87c04c2100fa3feb4c90" translate="yes" xml:space="preserve">
          <source>If N equals &lt;code&gt;className&lt;/code&gt;, the result is true.</source>
          <target state="translated">N이 &lt;code&gt;className&lt;/code&gt; 인 경우 결과는 true입니다.</target>
        </trans-unit>
        <trans-unit id="0ba990b0a52d90609129011e460cfce22958559a" translate="yes" xml:space="preserve">
          <source>If Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types</source>
          <target state="translated">Q가 기본 랩퍼가 아닌 경우 Q를 기본 랩퍼로 캐스트하십시오. 예를 들어 숫자 유형의 경우 Number</target>
        </trans-unit>
        <trans-unit id="d4e43d0787d6a1f0ea103acb6274a424055f2393" translate="yes" xml:space="preserve">
          <source>If UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e9892804baed9af42e82a13b8ef76149b94c399" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present and no factory is specified, then the default pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">경우 &lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 존재하고 어떤 공장이 지정되지 않은, 디폴트 풀은 더 한 스레드 공급하는 공장 사용 &lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt; 활성화되지합니다. 시스템 클래스 로더는 이러한 클래스를로드하는 데 사용됩니다. 이러한 설정을 설정하는 중 오류가 발생하면 기본 매개 변수가 사용됩니다. parallelism 속성을 0으로 설정하거나 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수있는 팩토리를 사용하여 공통 풀에서 스레드 사용을 비활성화하거나 제한 할 수 있습니다 . 그러나 이렇게하면 결합되지 않은 작업이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56cfbf9c11a3bf93497432039e845c2caa01626" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&quot;..&quot;&lt;/code&gt; segment is preceded by a non-&lt;code&gt;&quot;..&quot;&lt;/code&gt; segment then both of these segments are removed. This step is repeated until it is no longer applicable.</source>
          <target state="translated">경우 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 세그먼트가 비 앞에는 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 다음 부분이 세그먼트는 모두 제거된다. 이 단계는 더 이상 적용되지 않을 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a595fa88f9f83de3f8fcc49ca39b0b97a48f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CONCURRENT&lt;/code&gt; collector is not also &lt;code&gt;UNORDERED&lt;/code&gt;, then it should only be evaluated concurrently if applied to an unordered data source.</source>
          <target state="translated">경우 &lt;code&gt;CONCURRENT&lt;/code&gt; 콜렉터도되지 &lt;code&gt;UNORDERED&lt;/code&gt; 정렬되지 않은 데이터 소스에인가하는 경우, 그것은 동시에 만 평가되어야한다.</target>
        </trans-unit>
        <trans-unit id="87a0262c290ea66e1e4a3ee02285d9a618034184" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt; is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least one fully qualified audio format, the last one will be used as the default format of the returned &lt;code&gt;DataLine&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;DataLine&lt;/code&gt; 요구되며, &lt;code&gt;info&lt;/code&gt; 의 인스턴스 &lt;code&gt;DataLine.Info&lt;/code&gt; 적어도 하나의 완전한 오디오 형식을 지정, 마지막은 반환의 기본 형식으로 사용됩니다 &lt;code&gt;DataLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96e5812f9668e1871b3f46e04c3c43773aa3cf41" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">하면 &lt;code&gt;KeyTab&lt;/code&gt; 개체로부터 얻어진다 &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt; , 그 바인딩 해제하고 따라서 모든 서비스 주체에 의해 사용될 수있다. 그렇지 않은 경우, &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt; 에서 확보 한 경우 특정 서비스 프린시 펄에 바인드되어 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d851531cc7c0ba18b4dbffa855d090b319da4df2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 구현 클래스 파일이에 볼 수있는 jar 파일에 설치되어있는 &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt; , 그 jar 파일이 이름의 프로 바이더 구성 파일이 포함되어 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 그러한 jar 파일이 두 개 이상 제공되면 처음 발견 된 jar 파일이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99e2b5ed00fcac649fe3f3623264074d666a2942" translate="yes" xml:space="preserve">
          <source>If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">인쇄 작업에 JobPriority 속성이 지정된 경우 작업 예약 우선 순위를 지정합니다. 값이 클수록 우선 순위가 높습니다. 값 1은 가능한 최저 우선 순위를 나타냅니다. 값 100은 가능한 가장 높은 우선 순위를 나타냅니다. 인쇄 준비가 된 작업 중에서 프린터는 우선 순위 값이 모든 작업을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="efa62e398135fa151e6296eb9565e2ee0a846e6d" translate="yes" xml:space="preserve">
          <source>If a PageRanges attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the PageRanges attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">인쇄 작업에 PageRanges 속성을 지정하지 않으면 문서의 모든 페이지가 인쇄됩니다. 즉, PageRanges 속성의 기본값은 항상 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54875f0ae002ae009f6261e6ee89713bac0fc513" translate="yes" xml:space="preserve">
          <source>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</source>
          <target state="translated">Spliterator가 일관되지 않은 특성 세트 (단일 호출에서 또는 여러 호출에서 리턴 된 특성)를보고하면이 Spliterator를 사용한 계산에 대해 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a91c9f9234bda5620ef4d3e6ac923de910e62499" translate="yes" xml:space="preserve">
          <source>If a UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">UDP 소켓을 사용하는 경우 TCP / IP 관련 소켓 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27875d35d17c64c41e9933d166925700a1b171f4" translate="yes" xml:space="preserve">
          <source>If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.</source>
          <target state="translated">바인딩이이 컨텍스트에 추가되거나이 컨텍스트에서 제거되면 이전에 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b8644225e60775049f73144977a4d20b30637be" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;engineSetSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom implementation to seed itself. This self-seeding will not occur if &lt;code&gt;engineSetSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;engineSetSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 구현을 강제로 시드합니다. &lt;code&gt;engineSetSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자동 시딩이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="911ec002bf686d39657f3069553cf1c3b5b5def4" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;setSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">&lt;code&gt;setSeed&lt;/code&gt; 에 대한 호출 이 이전에 발생하지 않은 경우, 이 메소드에 대한 첫 번째 호출은이 SecureRandom 오브젝트를 강제로 시드합니다. &lt;code&gt;setSeed&lt;/code&gt; 가 이전에 호출 된 경우이 자체 시드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="05d89b94bbc85cf7d77886e27828d6c62151d272" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;\u0000&lt;/code&gt; or is in the range &lt;code&gt;\u0080&lt;/code&gt; through &lt;code&gt;\u07ff&lt;/code&gt;, then it is represented by two bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0000&lt;/code&gt; 이거나 &lt;code&gt;\u0080&lt;/code&gt; ~ &lt;code&gt;\u07ff&lt;/code&gt; 범위에있는 경우 , 표시된 순서대로 기록되도록 2 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cced7ce9329a5beb13d9d0de6d94d760dcc0c4e8" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0001&lt;/code&gt; through &lt;code&gt;\u007f&lt;/code&gt;, it is represented by one byte:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0001&lt;/code&gt; ~ &lt;code&gt;\u007f&lt;/code&gt; 범위에 있으면 1 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07952f6eaca135b300da4ff28ea9b192ef542fea" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is represented by three bytes, to be written in the order shown:</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;\u0800&lt;/code&gt; 에서 &lt;code&gt;uffff&lt;/code&gt; 까지 의 범위에있는 경우, 표시된 순서대로 3 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5494a676f207ae321fc2c494aa6a96120e143c" translate="yes" xml:space="preserve">
          <source>If a character with value &lt;code&gt;ch&lt;/code&gt; occurs in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object at an index no smaller than &lt;code&gt;fromIndex&lt;/code&gt;, then the index of the first such occurrence is returned. For values of &lt;code&gt;ch&lt;/code&gt; in the range from 0 to 0xFFFF (inclusive), this is the smallest value</source>
          <target state="translated">값이 &lt;code&gt;ch&lt;/code&gt; 인 문자 가 &lt;code&gt;fromIndex&lt;/code&gt; 보다 작은 인덱스 에서이 &lt;code&gt;String&lt;/code&gt; 객체가 나타내는 문자 시퀀스에서 발생하는 경우 , 그러한 첫 번째 발생의 인덱스가 리턴됩니다. 0에서 0xFFFF (포함) 범위 의 &lt;code&gt;ch&lt;/code&gt; 값의 경우 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="88d64da6fa30bc481b1c1898ad57b4a92324448a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA&lt;/i&gt;&lt;/a&gt; 문자 세트 &lt;i&gt;레지스트리에&lt;/i&gt; 나열된 문자 세트 가 Java 플랫폼의 구현에서 지원되는 경우 표준 이름은 레지스트리에 나열된 이름이어야합니다. 많은 문자 집합에 레지스트리에 둘 이상의 이름이 지정됩니다.이 경우 레지스트리는 이름 중 하나를</target>
        </trans-unit>
        <trans-unit id="2e1f6c2a012c9ee1480d2aea7e18a07e1c842c87" translate="yes" xml:space="preserve">
          <source>If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.</source>
          <target state="translated">클래스가 자신에 대한 명시 적 BeanInfo를 제공하는 경우 파생 클래스를 분석하여 얻은 BeanInfo 정보에 해당 정보를 추가하지만 명시 적 정보는 현재 클래스 및 기본 클래스에 대해 결정적인 것으로 간주하고 더 이상 진행하지 않습니다. 슈퍼 클래스 체인.</target>
        </trans-unit>
        <trans-unit id="acece6c1313b9c506151182d4c10bc5adcf63087" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.</source>
          <target state="translated">클라이언트가 필요한 최소값보다 큰 해상도를 지원하는 프린터를 찾으려면이 속성을 조회 요청에서 제외하고 지원되는 해상도를 직접 쿼리하고 클라이언트의 요구 사항에 가장 적합한 프린터를 지정해야합니다. 요구 사항. 경우에 따라 종종 해상도를 제어하는 ​​PrintQuality 속성을 지정하여보다 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ce72ead2f2b5aae2c69c76ea112e52bebf52e8" translate="yes" xml:space="preserve">
          <source>If a collection refuses to add a particular element for any reason other than that it already contains the element, it</source>
          <target state="translated">컬렉션이 이미 요소를 포함하고있는 것 이외의 다른 이유로 특정 요소 추가를 거부하면 컬렉션</target>
        </trans-unit>
        <trans-unit id="c4776000b1707ea1d8288ccc9e65458bb1c58a2d" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">프록시 (PROXY 또는 SOCKS) 서버에 연결할 수없는 경우 호출자는 프록시 선택기 에게 프록시 서버를 사용할 수 없음을 알리기 위해 프록시 선택기 의 &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="66d389f1702f33b50016c87da612c3454fb27ac7" translate="yes" xml:space="preserve">
          <source>If a cookie corresponding to the given URI already exists, then it is replaced with the new one.</source>
          <target state="translated">주어진 URI에 해당하는 쿠키가 이미 존재하면 새로운 쿠키로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="df8f1040f8046d584674ec649bf9175bb489aff9" translate="yes" xml:space="preserve">
          <source>If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">데이터 그램을 즉시 사용할 수 있거나이 채널이 블로킹 모드에 있고 결국 하나를 사용할 수있게되면 데이터 그램이 지정된 바이트 버퍼에 복사되고 소스 주소가 반환됩니다. 이 채널이 비 블로킹 모드에 있고 데이터 그램을 즉시 사용할 수없는 경우이 메서드는 즉시 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1a7a080897c03d2a2dec7ade95e887516b9ac13d" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">소수 구분 기호가 있으면 로케일 별 &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;소수 구분 기호&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef151b03b8bdfd0c5b1285060dc05b180bd41b5a" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">&lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 기본 컨텍스트를 설정 한 경우 리턴됩니다. 그렇지 않은 경우,이 메소드의 첫 번째 호출은 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 호출을 트리거합니다 . 성공하면 해당 오브젝트가 기본 SSL 컨텍스트가되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="14abd8b4a751858e76b43b1c734186c7f7ef97b3" translate="yes" xml:space="preserve">
          <source>If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown. The PrintException may implement URIException to provide a more specific cause.</source>
          <target state="translated">목적지 URI가 PrintRequest에 지정되고 PrintService에서 출력 할 수없는 경우 PrintException이 발생합니다. PrintException은보다 구체적인 원인을 제공하기 위해 URIException을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bacc9e3344a41d79a4651f2c7e9da527b4943d5" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively. For example, the property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getReceiver&lt;/code&gt; is called: if the class &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; exists in the list of installed MIDI device providers, the first &lt;code&gt;Receiver&lt;/code&gt; device with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Receiver&lt;/code&gt; from that provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Receiver&lt;/code&gt; with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; in the list of all devices (as returned by &lt;code&gt;getMidiDeviceInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Receiver&lt;/code&gt; that can be found in the list of all devices is returned. If that fails, too, a &lt;code&gt;MidiUnavailableException&lt;/code&gt; is thrown.</source>
          <target state="translated">장치 이름을 지정하면 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;MidiDevice&lt;/code&gt; 가 해당 인터페이스를 구현 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체가 없거나 장치 이름을 지정하지 않으면 결과 목록에서 첫 번째로 적합한 장치가 반환됩니다. 시퀀서 및 신시사이저의 경우, 각 인터페이스를 구현하는 경우 장치가 적합합니다. 수신기와 송신기의 경우 장치는 시퀀서 나 신시사이저를 구현하지 않고 각각 하나 이상의 수신기 나 송신기를 제공하는 경우에 적합합니다. 예를 들어, 값이있는 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 특성 &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; 때 다음과 같은 결과를 초래할 &lt;code&gt;getReceiver&lt;/code&gt; 가 호출됩니다 클래스의 경우 &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; 가 설치된 MIDI 장치 공급자 목록에있는 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 장치를 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 이라는 이름 이 반환됩니다. 찾을 수 없으면 이름에 관계없이 해당 제공자 의 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다. 없는 경우, 모든 장치 목록에서 이름이 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; ( &lt;code&gt;getMidiDeviceInfo&lt;/code&gt; 가 리턴 한 )가 리턴되거나 발견되지 않은 경우 첫 번째 &lt;code&gt;Receiver&lt;/code&gt; 가 리턴됩니다.모든 장치 목록에서 찾을 수 있습니다. 이것도 실패하면 &lt;code&gt;MidiUnavailableException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1dc1d0d7d632f8adb52a90a5d33de0f5ebfd86ab" translate="yes" xml:space="preserve">
          <source>If a factory is instantiated, it is invoked with the following parameters to produce the resulting context.</source>
          <target state="translated">팩토리가 인스턴스화되면 결과 매개 변수를 생성하기 위해 다음 매개 변수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="61b02e48c383e6261e3240e4271679924e0689b0" translate="yes" xml:space="preserve">
          <source>If a fieldValue is an object then the toString() method is called on it and its returned value is used as the value for the field enclosed in parenthesis.</source>
          <target state="translated">fieldValue가 객체이면 toString () 메서드가 호출되고 반환 된 값이 괄호로 묶인 필드의 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbb5e24d20d361c0ea0a62c5f3f2f90aea684d9" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;documentationtool.location&quot;&gt;&lt;code&gt;DocumentationTool.Location&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt;&lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;documentationtool.location&quot;&gt; &lt;code&gt;DocumentationTool.Location&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치 와 &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt; &lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt; &lt;/a&gt; 를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdbf6cb18404a64f45d2b8abf710d01eb9d7f2cb" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;standardlocation&quot;&gt;&lt;code&gt;StandardLocation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 관리자가 제공되면 &lt;a href=&quot;standardlocation&quot;&gt; &lt;code&gt;StandardLocation&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 위치를 처리 할 수 ​​있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e77610d088ca1d95b7392fcd2274aef9c2f8d21" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;F&lt;/code&gt; applies to the &lt;code&gt;N&lt;/code&gt;th argument of the target, then &lt;code&gt;F&lt;/code&gt; must be a method handle which takes exactly one argument. The type of &lt;code&gt;F&lt;/code&gt;'s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of &lt;code&gt;F&lt;/code&gt; must be identical to the corresponding parameter type of the target.</source>
          <target state="translated">필터하면 &lt;code&gt;F&lt;/code&gt; 가 받는 적용 &lt;code&gt;N&lt;/code&gt; 타겟의 번째 인수 후 &lt;code&gt;F&lt;/code&gt; 는 한 인자를 취하는 방법 핸들이어야한다. 의 타입 &lt;code&gt;F&lt;/code&gt; 의 유일한 인자 생성하도록 핸들 방법에서 대상의 대응하는 인수 유형을 대체한다. &lt;code&gt;F&lt;/code&gt; 의 리턴 유형은 대상의 해당 매개 변수 유형과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="77fff40663a1f21028623e35281e042a8419f5f8" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">형식 매개 변수 유형이 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="48218943f2a8994e2b422a9456a012477f87f4f0" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">형식 매개 변수 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa45ce5030fe67e696cd9c90f1c3d32a9e26312" translate="yes" xml:space="preserve">
          <source>If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an &lt;a href=&quot;illegalformatconversionexception&quot;&gt;&lt;code&gt;IllegalFormatConversionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">형식 지정자에 해당 인수에 적용 할 수없는 변환 문자가 포함 된 경우 &lt;a href=&quot;illegalformatconversionexception&quot;&gt; &lt;code&gt;IllegalFormatConversionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47e2137fd18da09bdd7e054d7015bc33023b31e0" translate="yes" xml:space="preserve">
          <source>If a given &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either &lt;code&gt;MethodHandle.invoke&lt;/code&gt; or &lt;code&gt;invokeWithArguments&lt;/code&gt;. (There is no way to tell the difference.)</source>
          <target state="translated">주어진 &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 정적 인수를 지정하지 않으면 명령의 부트 스트랩 메소드는 명령의 호출자 클래스, 이름 및 메소드 유형을 전달하는 세 개의 인수에서 호출됩니다. 경우] &lt;code&gt;invokedynamic&lt;/code&gt; 명령이 하나 개 이상의 정적 인수 지정이 값은 방법 핸들 추가적인 인수로 전달한다. (모든 메소드에는 255 개의 인수가 제한되어 있기 때문에 부트 스트랩 메소드 자체를 처리하고 처음 세 개의 인수도 스택해야하므로 최대 251 개의 추가 인수를 제공 할 수 있습니다.) 부트 스트랩 메소드는 다음과 같이 호출됩니다. &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 또는 &lt;code&gt;invokeWithArguments&lt;/code&gt; 중 하나 입니다. (차이를 알 수있는 방법이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="1b302c4fa309e55608aa77d71aa898540e38e284" translate="yes" xml:space="preserve">
          <source>If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) then the square brackets are added.</source>
          <target state="translated">호스트가 제공되면 호스트가 추가됩니다. 호스트가 리터럴 IPv6 주소이지만 대괄호 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; )로 묶이지 않은 경우 대괄호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7a15cd0977f55c58d7c0850d3c01c8a63da1d40d" translate="yes" xml:space="preserve">
          <source>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is</source>
          <target state="translated">논리적 선이 여러 개의 자연 선으로 분산 된 경우 선 종결 자 시퀀스, 선 종결 자 시퀀스 및 다음 줄의 시작 부분의 공백을 이스케이프하는 백 슬래시는 키 또는 요소 값에 영향을 미치지 않습니다. 키 및 요소 구문 분석 (로드시)에 대한 나머지 설명에서는 키와 요소를 구성하는 모든 문자가 줄 연속 문자가 제거 된 후 하나의 자연 줄에 나타나는 것으로 가정합니다. 참고</target>
        </trans-unit>
        <trans-unit id="3a82003bc08000c8f46219ed82ab846fd6727cbe" translate="yes" xml:space="preserve">
          <source>If a match to the specified pattern is not found at the current position, then no input is skipped and a &lt;code&gt;NoSuchElementException&lt;/code&gt; is thrown.</source>
          <target state="translated">지정된 패턴과 일치하는 항목이 현재 위치에 없으면 입력을 건너 뛰지 않고 &lt;code&gt;NoSuchElementException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03f7ab2c34aa311345e83cbc387505226e713e48" translate="yes" xml:space="preserve">
          <source>If a method handle for a caller-sensitive method is requested, the general rules for &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.</source>
          <target state="translated">호출자 구분 메소드에 대한 메소드 핸들이 요청되면 &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;바이트 코드 동작에&lt;/a&gt; 대한 일반 규칙이 적용되지만 특수한 방식으로 조회 클래스를 고려합니다. 결과 메소드 핸들은 조회 클래스에 포함 된 명령에서 호출 된 것처럼 작동하므로 호출자 감지 메소드는 조회 클래스를 감지합니다. 대조적으로, 메소드 핸들의 호출자는 무시됩니다. 따라서 호출자 감지 메소드의 경우, 다른 검색 클래스가 다르게 작동하는 메소드 핸들을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f4e595c2df825132a51481c97b50495434dfe5e" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned. For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt; instance: if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists in the list of installed mixer providers, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer of the specified provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first &lt;code&gt;Mixer&lt;/code&gt; with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; in the list of all mixers (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all mixers is returned. If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">믹서 이름을 지정하면 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체 의 결과 목록 이 검색됩니다. 이름이 일치하고 &lt;code&gt;Mixer&lt;/code&gt; 가 해당 회선 인터페이스를 제공 하는 첫 번째 목록 이 반환됩니다. 일치하는 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체가 없거나 믹서 이름을 지정하지 않으면 결과 목록에서 각 라인 인터페이스를 제공하는 첫 번째 믹서가 반환됩니다. 예를 들어, 값이 &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; 인 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 등록 정보 는 &lt;code&gt;getLine&lt;/code&gt; 이 &lt;code&gt;Clip&lt;/code&gt; 인스턴스 요청 시 호출 될 때 다음과 같은 결과를 초래 합니다. 클래스 &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; 설치된 믹서 제공 업체 목록에 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 이라는 이름을 가진 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 반환됩니다. 찾을 수 없으면 지정된 공급자의 첫 번째 믹서의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 이름에 관계없이 반환됩니다. 없는 경우, 모든 믹서 목록에서 이름이 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 인 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; ( &lt;code&gt;getMixerInfo&lt;/code&gt; 에서 반환 됨 )이 반환되거나 발견되지 않으면 첫 번째 &lt;code&gt;Mixer&lt;/code&gt; 의 첫 번째 &lt;code&gt;Clip&lt;/code&gt; 이 발견 될 수 있습니다 모든 믹서 목록에 반환됩니다. 이것도 실패하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8a0c1b372f5ed387a77d0a8139d565c090fb292" translate="yes" xml:space="preserve">
          <source>If a mutable target is not required, an &lt;code&gt;invokedynamic&lt;/code&gt; instruction may be permanently bound by means of a &lt;a href=&quot;constantcallsite&quot;&gt;constant call site&lt;/a&gt;.</source>
          <target state="translated">변경 가능한 대상이 필요하지 않은 경우 &lt;code&gt;invokedynamic&lt;/code&gt; 명령은 &lt;a href=&quot;constantcallsite&quot;&gt;상수 호출 사이트를&lt;/a&gt; 통해 영구적으로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d153e3199dbf3a239e1e74edc668dcfac7b620a7" translate="yes" xml:space="preserve">
          <source>If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a &lt;a href=&quot;volatilecallsite&quot;&gt;volatile call site&lt;/a&gt; may be used.</source>
          <target state="translated">휘발성 변수 의미가있는 가변 대상이 필요한 경우 다른 스레드가 대상에 대한 업데이트를 즉시 확실하게 감시해야하므로 &lt;a href=&quot;volatilecallsite&quot;&gt;휘발성 호출 사이트를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657a9f6756d750ee4adc0e4bbc100a654dce7128" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82b7eb3aeab5135e75a853270d3a38d65b14ccb2" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름이 바이트 배열로 지정된 경우 X.501에 정의 된대로 단일 DER로 인코딩 된 식별 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96afaaa19f7e5c5798f8d8403e551ecc219a3743" translate="yes" xml:space="preserve">
          <source>If a native receiver provided by the default device does not implement the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface. The corresponding &lt;code&gt;Receiver&lt;/code&gt; method calls will be forwarded to the native receiver.</source>
          <target state="translated">기본 장치에서 제공하는 기본 수신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Receiver&lt;/code&gt; 메소드 호출은 기본 수신자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f15617aacf84e28d7719762bc77a6e2a240fb2d8" translate="yes" xml:space="preserve">
          <source>If a native transmitter provided by the default device does not implement the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface. The corresponding &lt;code&gt;Transmitter&lt;/code&gt; method calls will be forwarded to the native transmitter.</source>
          <target state="translated">기본 장치에서 제공하는 기본 송신기가 구현하지 않는 경우 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를, 그것은 래퍼 클래스가 구현하는 것을 감싸됩니다 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 의 인터페이스를 제공합니다. 해당 &lt;code&gt;Transmitter&lt;/code&gt; 메소드 호출은 기본 송신기로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e885f68e1bc095b374d6b1ebbe1a47153753c95e" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager를 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e945b5d1146ab0148461e7bb66b4cc1b6317073" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">새 로거가 작성되면 로그 레벨은 LogManager 구성을 기반으로 구성되며 로깅 출력을 상위 핸들러로 보내도록 구성됩니다. LogManager 글로벌 네임 스페이스에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e4374be394b79479c7e1fa5bcc1e8102ae6664e5" translate="yes" xml:space="preserve">
          <source>If a non-null CodeSource is supplied a ProtectionDomain is constructed and associated with the class being defined.</source>
          <target state="translated">널이 아닌 코드 소스가 제공되면 ProtectionDomain이 구성되고 정의중인 클래스와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="ed948d67e59d3b1ab1a6ab69b72cf90841f818b2" translate="yes" xml:space="preserve">
          <source>If a non-null value is returned, then the PropertyEditor should be prepared to parse that string back in setAsText().</source>
          <target state="translated">널이 아닌 값이 리턴되면 PropertyEditor는 해당 문자열을 다시 setAsText ()로 구문 분석 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9d7fb43a6f9ab347881ca798d47872764ac074f" translate="yes" xml:space="preserve">
          <source>If a number is preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding &lt;code&gt;-&lt;/code&gt; means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, &lt;code&gt;-5&lt;/code&gt; occurring in the string would mean &quot;five hours west of Greenwich&quot; and &lt;code&gt;+0430&lt;/code&gt; would mean &quot;four hours and thirty minutes east of Greenwich.&quot; It is permitted for the string to specify &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UT&lt;/code&gt;, or &lt;code&gt;UTC&lt;/code&gt; redundantly-for example, &lt;code&gt;GMT-5&lt;/code&gt; or &lt;code&gt;utc+0430&lt;/code&gt;.</source>
          <target state="translated">숫자 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 있고 연도가 이미 인식 된 경우 숫자는 시간대 오프셋입니다. 숫자가 24보다 작 으면 시간 단위로 측정 된 오프셋입니다. 그렇지 않으면 구두점없이 24 시간 형식으로 표현 된 분 단위 오프셋으로 간주됩니다. 앞에 &lt;code&gt;-&lt;/code&gt; 는 서쪽 방향 오프셋을 의미합니다. 시간대 오프셋은 항상 UTC (그리니치)를 기준으로합니다. 예를 들어, 문자열에서 &lt;code&gt;-5&lt;/code&gt; 가 발생하면 &quot;그리니치에서 서쪽으로 5 시간&quot; 을 의미 하고 &lt;code&gt;+0430&lt;/code&gt; 은 &quot;그리니치에서 동쪽으로 4 시간 30 분&quot;을 의미합니다. 문자열이 &lt;code&gt;GMT&lt;/code&gt; , &lt;code&gt;UT&lt;/code&gt; 또는 &lt;code&gt;UTC&lt;/code&gt; 를 중복 으로 지정할 수 있습니다 (예 : &lt;code&gt;GMT-5&lt;/code&gt; 또는 &lt;code&gt;utc+0430&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7e7b1f4d4e8c47890d4e04c211a6340b6dc972a" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수화 된 유형이 리턴되는 경우 해당 유형 요소는 일반 외부 클래스 내에 포함되지 않아야합니다. 예를 들어, 매개 변수화 된 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; 메소드를 사용하여 유형 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; 을 가져온 후 &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt; 을 호출 하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b860cee6c1daa1284a85c7a9b7c1c7d6c9380907" translate="yes" xml:space="preserve">
          <source>If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 콘크리트 문자 세트 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fbd441057e8700833c9533c87ba431e637f763c4" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 이것은 파일이 실제로로드 된 클래스 로더 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da4bf007198af6025012fc0fecd914082583539" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">특정 구체적 제공자 클래스가 둘 이상의 구성 파일에서 이름이 지정되거나 동일한 구성 파일에서 두 번 이상 이름이 지정된 경우 중복은 무시됩니다. 특정 제공자를 명명하는 구성 파일은 제공자 자체와 동일한 jar 파일 또는 기타 분배 장치에있을 필요는 없습니다. 구성 파일을 찾기 위해 처음 쿼리 한 동일한 클래스 로더에서 제공자에 액세스 할 수 있어야합니다. 반드시 파일을로드 한 클래스 로더는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d5668fe10c0723c5fca50dcc78c1b35e4b358bc9" translate="yes" xml:space="preserve">
          <source>If a path is given then it is appended. Any character not in the</source>
          <target state="translated">경로가 제공되면 추가됩니다. 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="0e5a965d6474edf02c5830767daff8c0d82cf26d" translate="yes" xml:space="preserve">
          <source>If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.</source>
          <target state="translated">패턴을 여러 번 사용하는 경우 한 번 컴파일 한 후 재사용하면 매번이 메소드를 호출하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="89b4c008a45797eef3268e7fe508720bf307f893" translate="yes" xml:space="preserve">
          <source>If a permit is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="619e1dee8db482adbcc19510b522caad9b3dd86b" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">지속성 대리자가 &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하여 지정된 유형과 연관되어 있으면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="11d9ed1e56dc29ed992752f78c70910959ce2ab4" translate="yes" xml:space="preserve">
          <source>If a port number is given then a colon character (&lt;code&gt;':'&lt;/code&gt;) is appended, followed by the port number in decimal.</source>
          <target state="translated">포트 번호가 제공되면 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 추가되고 그 뒤에 포트 번호가 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="38d056108653d02210141b2a751f0e69e31fb1fd" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the AttributeSet. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">인쇄 서비스가 공급 업체 확장을 제공하는 경우 공급 업체 제공 탭 패널 구성 요소를 통해 사용자가 액세스 할 수 있습니다. 이러한 공급 업체 확장 프로그램은 Swing! 접근성 API를 지원합니다. 공급 업체 확장은 설정을 AttributeSet의 일부로 반환해야합니다. 사용자 설정을 유지하려는 응용 프로그램은 해당 설정을 사용하여 인쇄 작업을 지정해야합니다. 이 클래스는 Java 인쇄 서비스의 다른 부분에서 참조되지 않으며 AWT 패키지의 존재에 의존 할 수없는 프로파일에는 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29ea7b220242b9cb8462cb83e9acfd3082297b2" translate="yes" xml:space="preserve">
          <source>If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.</source>
          <target state="translated">프린터가 SheetCollate 특성을 지원하지 않으면 (클라이언트가 특정 시트 정렬을 지정할 수 없음을 의미) 프린터는 SheetCollate가 항상 COLLATED로 설정된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="49665e43d0c605dc9888cfc626aa1ab47db7f814" translate="yes" xml:space="preserve">
          <source>If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.</source>
          <target state="translated">위의 프로토콜을 따르지 않고 프로세서 객체를 만들어 사용하는 경우이 인터페이스 사양에 따라 프로세서의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca6e8c92cea494ed3f4a024c3b0fdf6756539fd3" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">프로세서가 포착되지 않은 예외를 처리하면 도구가 다른 활성 주석 프로세서를 중지 할 수 있습니다. 프로세서에서 오류가 발생하면 현재 라운드가 완료되고 다음 라운드에서 &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;오류가 발생&lt;/a&gt; 했음을 나타냅니다 . 어노테이션 프로세서는 협업 환경에서 실행되므로 오류 복구 또는보고가 불가능한 상황에서만 프로세서가 포착되지 않은 예외를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe881171d1c239ccd44b6c4f0b3100103c51b330" translate="yes" xml:space="preserve">
          <source>If a property is indexed, then its entry in the result array belongs to the &lt;a href=&quot;indexedpropertydescriptor&quot;&gt;&lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;&lt;/a&gt; subclass of the &lt;a href=&quot;propertydescriptor&quot;&gt;&lt;code&gt;PropertyDescriptor&lt;/code&gt;&lt;/a&gt; class. A client of the &lt;code&gt;getPropertyDescriptors&lt;/code&gt; method can use the &lt;code&gt;instanceof&lt;/code&gt; operator to check whether a given &lt;code&gt;PropertyDescriptor&lt;/code&gt; is an &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;.</source>
          <target state="translated">특성이 색인화되는 경우 결과 배열의 해당 항목 은 &lt;a href=&quot;propertydescriptor&quot;&gt; &lt;code&gt;PropertyDescriptor&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;a href=&quot;indexedpropertydescriptor&quot;&gt; &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; &lt;/a&gt; 서브 클래스에 속합니다 . &lt;code&gt;getPropertyDescriptors&lt;/code&gt; 메소드 의 클라이언트는 &lt;code&gt;instanceof&lt;/code&gt; 연산자를 사용하여 지정된 &lt;code&gt;PropertyDescriptor&lt;/code&gt; 가 &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; 인지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73b5d72f7f083f370b03d87e8286e01120577634" translate="yes" xml:space="preserve">
          <source>If a property value is a directory name, all files under that directory will be passed also.</source>
          <target state="translated">특성 값이 디렉토리 이름 인 경우 해당 디렉토리 아래의 모든 파일도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9c4d961909cb1d8509dc7e80ad518ce9be7c9742" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdfa29d9e3e5dd048f606f387c561e986beb3b1f" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">제공자 클래스가 시스템 클래스 로더가 볼 수있는 jar 파일에 설치되었고 해당 jar 파일 에 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 라는 제공자 구성 파일이 포함 된 경우 , 그런 다음 해당 파일에 지정된 첫 번째 클래스 이름이 사용됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40aff6af09d58df40b7fd9256b872b6c75872438" translate="yes" xml:space="preserve">
          <source>If a proxy class implements a non-public interface, then it will be defined in the same package as that interface. Otherwise, the package of a proxy class is also unspecified. Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.</source>
          <target state="translated">프록시 클래스가 공용 인터페이스를 구현하지 않으면 해당 인터페이스와 동일한 패키지에 정의됩니다. 그렇지 않으면 프록시 클래스의 패키지도 지정되지 않습니다. 패키지 씰링은 프록시 클래스가 런타임에 특정 패키지에서 성공적으로 정의되는 것을 막지 않으며, 동일한 클래스 로더에 의해 이미 정의 된 클래스와 특정 서명자와 동일한 패키지가 이미 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="796aaf5cfdf7fbf122008c7936a12a38e2eb7d28" translate="yes" xml:space="preserve">
          <source>If a proxy interface contains a method with the same name and parameter signature as the &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, or &lt;code&gt;toString&lt;/code&gt; methods of &lt;code&gt;java.lang.Object&lt;/code&gt;, when such a method is invoked on a proxy instance, the &lt;code&gt;Method&lt;/code&gt; object passed to the invocation handler will have &lt;code&gt;java.lang.Object&lt;/code&gt; as its declaring class. In other words, the public, non-final methods of &lt;code&gt;java.lang.Object&lt;/code&gt; logically precede all of the proxy interfaces for the determination of which &lt;code&gt;Method&lt;/code&gt; object to pass to the invocation handler.</source>
          <target state="translated">프록시 인터페이스 에 &lt;code&gt;java.lang.Object&lt;/code&gt; 의 &lt;code&gt;hashCode&lt;/code&gt; , &lt;code&gt;equals&lt;/code&gt; 또는 &lt;code&gt;toString&lt;/code&gt; 메소드 와 이름 및 매개 변수 특성이 동일한 메소드가 포함 된 경우, 해당 &lt;code&gt;Method&lt;/code&gt; 가 프록시 인스턴스 에서 호출 될 때 호출 핸들러에 전달 된 Method 오브젝트는 선언 클래스로 &lt;code&gt;java.lang.Object&lt;/code&gt; 가 있습니다 . 다시 말해, &lt;code&gt;java.lang.Object&lt;/code&gt; 의 최종 비 최종 메소드 는 호출 핸들러에 전달할 &lt;code&gt;Method&lt;/code&gt; 오브젝트를 판별하기 위해 모든 프록시 인터페이스보다 논리적으로 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="da20e235784a287eb944654e195ab8c9e647b20d" translate="yes" xml:space="preserve">
          <source>If a query is given then a question-mark character (&lt;code&gt;'?'&lt;/code&gt;) is appended, followed by the query. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.</source>
          <target state="translated">쿼리가 제공되면 물음표 문자 ( &lt;code&gt;'?'&lt;/code&gt; )가 추가되고 그 뒤에 쿼리가옵니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd66988b876e62bc3940fc9fa272fb4aa056a6e8" translate="yes" xml:space="preserve">
          <source>If a redefined method has active stack frames, those active frames continue to run the bytecodes of the original method. The redefined method will be used on new invokes.</source>
          <target state="translated">재정의 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재정의 된 메소드는 새로운 호출에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24ef3bceba0cb2aab5212a59ddb1c10b5a5728ca" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e159606ce958fbbed771df76f4f0eabd266798cd" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">나머지 요소가 존재하면 주어진 조치를 수행하여 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . else는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 스플리터가&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 이면 다음 요소에서 발생 순서대로 작업이 수행됩니다. 작업에 의해 발생한 예외는 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1839ce02fdf0a084101d2dedb7a7ec30b1eddf93" translate="yes" xml:space="preserve">
          <source>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</source>
          <target state="translated">요청을 대기열에 넣을 수 없으면 maximumPoolSize를 초과하지 않는 한 새 스레드가 만들어지며이 경우 작업이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8dcd6f2eb2f000d41479fe75ebb34b375f18a3c4" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="887186d0f2e36f1ee7e723c9cc603e07ae277a39" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, an AccessControlException is thrown. AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value. Such information is given whenever possible. Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m. Then caller m invoked the &lt;code&gt;checkPermission&lt;/code&gt; method. The &lt;code&gt;checkPermission&lt;/code&gt; method determines whether access is granted or denied based on the following algorithm:</source>
          <target state="translated">요청 된 액세스가 허용되면 &lt;code&gt;checkPermission&lt;/code&gt; 이 자동으로 리턴됩니다. 거부되면 AccessControlException이 발생합니다. 요청 된 권한이 올바르지 않은 유형이거나 유효하지 않은 값을 포함하는 경우 AccessControlException이 발생할 수도 있습니다. 그러한 정보는 가능할 때마다 제공됩니다. 현재 스레드가 호출자 1-호출자 2-호출자 m의 순서로 m 호출자를 순회한다고 가정하십시오. 그런 다음 호출자 m은 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출했습니다 . &lt;code&gt;checkPermission&lt;/code&gt; 방법은 액세스가 부여되거나 다음과 같은 알고리즘을 기반으로 거부 여부를 결정합니다 :</target>
        </trans-unit>
        <trans-unit id="ef31bdb236c1be020d8ae03fbd2d0a2a44475408" translate="yes" xml:space="preserve">
          <source>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</source>
          <target state="translated">결과가 컴 바이 너 또는 피니셔 함수로 전달되고 해당 함수에서 동일한 오브젝트가 리턴되지 않으면 다시 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f6485f2810241e1f59964a0306f13fb66de588c" translate="yes" xml:space="preserve">
          <source>If a retransformed method has active stack frames, those active frames continue to run the bytecodes of the original method. The retransformed method will be used on new invokes.</source>
          <target state="translated">재 변환 된 메소드에 활성 스택 프레임이있는 경우 해당 활성 프레임은 원래 메소드의 바이트 코드를 계속 실행합니다. 재 변환 된 메소드는 새로운 호출에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14bfd111544b6485485ff232a946c27189f15782" translate="yes" xml:space="preserve">
          <source>If a scheme is given then it is appended to the result, followed by a colon character (&lt;code&gt;':'&lt;/code&gt;).</source>
          <target state="translated">체계가 제공되면 결과에 추가되고 그 뒤에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; )가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e5292412b3ee897a572e5c7195ad6e65ff3c8f5e" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter or, in the case of the &lt;code&gt;port&lt;/code&gt; parameter, by passing &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달 하거나 &lt;code&gt;port&lt;/code&gt; 매개 변수 의 경우 &lt;code&gt;-1&lt;/code&gt; 을 전달 하여 정의되지 않은 채로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eb7b84865919239961f0fcc50c50d09850970cc" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter.</source>
          <target state="translated">구성표가 제공되면 경로도 지정되거나 비어 있거나 슬래시 문자 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작해야합니다 . 그렇지 않으면 새 URI의 구성 요소 는 해당 매개 변수에 대해 &lt;code&gt;null&lt;/code&gt; 을 전달하여 정의되지 않은 채로있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952cc358b56318941d6e6ab799e6dc4bef4fa5ce" translate="yes" xml:space="preserve">
          <source>If a scheme-specific part is given then it is appended. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">구성표 별 부품이 제공되면 추가됩니다. &lt;a href=&quot;#legal-chars&quot;&gt;유효한 URI 문자&lt;/a&gt; 가 아닌 문자 는 &lt;a href=&quot;#quote&quot;&gt;인용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="13bf2d89737ab4f9e4f3365daa8c4a8a75373b41" translate="yes" xml:space="preserve">
          <source>If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">유효하지 않은 변수 대체가있는 검색 필터가이 메소드에 제공되면 결과는 정의되지 않습니다. 이 DirContext가 변경되면,이 메소드에 대한 이전 호출에 의해 리턴 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e97fd2ab90897223be3d44a61e5dac3ab116baef" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 검사에 실패하면, 메소드는 &lt;a href=&quot;../../java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="9dea5876966fa5396ec8f16c92b8e2f701b1ace9" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재 하면 배열 &lt;code&gt;cmdarray&lt;/code&gt; 의 첫 번째 구성 요소를 인수로 사용하여 &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 이 발생 .</target>
        </trans-unit>
        <trans-unit id="53168f421aa4d312fe84c343c76a94712c016bae" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be9fb106610b30c8cb7f763862c74ced2b9d9be" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 . 예외가 발생하지 않으면 변수 &lt;code&gt;name&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="799c889390e9c989ec60d735a9738bf280d5b1a4" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가 존재하면 해당 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1659595caad59762dfff687e8404d52f631d93f" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">보안 관리자가 설치된 경우 원격 주소에 대한 액세스를 확인하기 위해 호출됩니다. 주어진 경우 특히, &lt;code&gt;address&lt;/code&gt; A는 &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt; , 보안 매니저의 &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt; 방법은 주어진를 호출 &lt;code&gt;address&lt;/code&gt; . 그렇지 않으면, 주어진 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 로 보안 관리자의 &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되어 데이터 그램이 각각 송수신 될 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e62ef67bcdaa9aa21e31d7d487c07bd914492ed8" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가 설치된 경우 보안 관리자의 &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt; 메소드 가 연결 원격 엔드 포인트의 주소 및 포트 번호를 허용하는지 확인합니다 . 권한 확인은이 메소드의 호출 컨텍스트에 의해 제한된 권한으로 수행됩니다. 권한 점검에 실패하면 연결이 닫히고 조작이 &lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 으로&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="774bb30d85acccb9e7832ec0c0d531eef6b9e9b6" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (where &lt;code&gt;name&lt;/code&gt; is the provider name) to see if it's ok to clear this provider.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임) 문자열로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출 되어이 제공자를 지울 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f35e03213aea8a9f7162a4e6061b476c733a84f5" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 문자열 ( 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 임 )로 호출 되어이 제공자의 특성 값을 설정해도 괜찮은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97b050d112e298b259d22c6b122aa0f103951b1a" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 문자열과 함께 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름 이며이 제공자의 특성을 제거 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ece65adbb64e89095abfe9c2349b473bbf31084f" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the strings &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; and &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values and remove this provider's properties.</source>
          <target state="translated">보안 관리자가 사용 가능한 경우, 문자열 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 및 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; 으로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 메소드가 호출됩니다 . 여기서 &lt;code&gt;name&lt;/code&gt; 은 제공자 이름입니다.이 제공자의 특성 값을 설정하고이를 제거해도 괜찮은지 확인하십시오. 공급자의 속성.</target>
        </trans-unit>
        <trans-unit id="cf20f936473755f39be868cd9845f771cb103a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed and the specified &lt;code&gt;AccessControlContext&lt;/code&gt; was not created by system code and the caller's &lt;code&gt;ProtectionDomain&lt;/code&gt; has not been granted the &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt;&lt;code&gt;SecurityPermission&lt;/code&gt;&lt;/a&gt;, then the action is performed with no permissions.</source>
          <target state="translated">보안 관리자가 설치되어 있고 지정된 &lt;code&gt;AccessControlContext&lt;/code&gt; 가 시스템 코드로 작성되지 않고 호출자의 &lt;code&gt;ProtectionDomain&lt;/code&gt; 에 &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt; &lt;code&gt;SecurityPermission&lt;/code&gt; &lt;/a&gt; 이 부여되지 않은 경우, 권한없이 조치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="71505a5d56a109fcf20595110953779d866b2e80" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94817a0d003779bd7b3676c9e779ce36983364b9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 기존 파일 시스템에 대한 참조를 리턴하기 전에 권한을 점검해야합니다. &lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8b4d6a644688d37bf4f42e678ef49d5a579de5" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">보안 관리자가 설치된 경우 제공자 구현은 권한을 확인해야 할 수 있습니다. &lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 파일 시스템 의 경우 권한 점검이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0d87efa51aa6969d6f0da372f01e957e877983c" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-</source>
          <target state="translated">보안 관리자가 설치되어 있고 연결을 시도하는 메소드가 호출 된 경우 호출자는 다음 중 하나를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="e951d48b2804e2b72e838d29cf84001eb9605eaa" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectInputStream.readFields or ObjectInputStream.readUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectInputStream.readFields 또는 ObjectInputStream.readUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97bae6ffb96e1d4b174839ef22d4e1aad74be094" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared methods.</source>
          <target state="translated">보안 관리자가 설치된 경우이 생성자는 ObjectOutputStream.putFields 또는 ObjectOutputStream.writeUnshared 메소드를 대체하는 서브 클래스의 생성자가 직접 또는 간접적으로 호출 할 때 &quot;enableSubclassImplementation&quot;SerializablePermission을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d92bb3509ac791abbf0139a9c7f57cc935e83b78" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this method is caller sensitive. During any invocation of the target method handle via the returned wrapper, the original creator of the wrapper (the caller) will be visible to context checks requested by the security manager.</source>
          <target state="translated">보안 관리자가 설치된 경우이 방법은 호출자에 민감합니다. 리턴 된 랩퍼를 통해 대상 메소드 핸들을 호출하는 동안 랩퍼의 원래 작성자 (호출자)는 보안 관리자가 요청한 컨텍스트 확인에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a665c3d954d0fc47740977c830812c0a85b298" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the class loader for the class.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 널 (null)이 아니고 호출자의 클래스 로더가 클래스 로더가 요청 된 클래스에 대한 클래스 로더의 조상과 같거나 같지 않은 경우,이 메소드는 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다. 로모그래퍼 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 의 허가는 클래스의 클래스 로더에 액세스 할 수있는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="fae23e2153f023848b4e6ff03b38daa20b992dd7" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not an ancestor of this class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the parent class loader is permitted. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고이 클래스 로더 의 조상이 아닌 경우이 메소드는 상위 클래스에 대한 액세스를 확인하기 위해 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 로더가 허용됩니다. 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d340f476b6c3ae11657fddd0392b049fcfa29b4e" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not the same as or an ancestor of the context class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; permission to verify that retrieval of the context class loader is permitted.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 컨텍스트 클래스 로더의 조상과 같거나 같지 않은 경우이 메소드는 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. 컨텍스트 클래스 로더 검색이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7bab9ae3bc48ceb4d26ca9f16abf87e363a12c" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the system class loader. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">보안 관리자가 존재하고 호출자의 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 이 아니고 호출자의 클래스 로더가 시스템 클래스 로더와 동일하거나 상위 클래스가 아닌 경우,이 메소드는 &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 사용하여 보안 관리자의 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다. ) 시스템 클래스 로더에 대한 액세스를 확인하는 권한 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="459bc04b32cd4cdbb41e230932994ba0a7971ad8" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">보안 관리자가 존재하면 해당 클래스의 컨텍스트 설정이 허용되는지 확인하기 위해 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; 권한으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="944477a6804441726a3b8f252f78eae83726e3a4" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">보안 관리자가있는 경우 멤버 조회에는 추가 검사가 적용됩니다. 1 ~ 3 번의 보안 관리자 호출 이러한 호출은 &lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 액세스를 거부 할 수 있습니다 . &lt;code&gt;smgr&lt;/code&gt; 을 보안 관리자로 정의 하고, &lt;code&gt;lookc&lt;/code&gt; 를 현재 조회 오브젝트의 검색 클래스로, &lt;code&gt;refc&lt;/code&gt; 를 멤버를 찾는 포함 클래스로, &lt;code&gt;defc&lt;/code&gt; 를 멤버를 실제로 정의한 클래스로 정의하십시오. 현재 조회 오브젝트에 &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;개인 액세스 권한&lt;/a&gt; 이없는 경우 &lt;code&gt;lookc&lt;/code&gt; 값 은 &lt;em&gt;존재하지 않는 것으로&lt;/em&gt; 정의됩니다 . 다음 규칙에 따라 전화를 겁니다.</target>
        </trans-unit>
        <trans-unit id="401c7fd6161f35837fa11c7a250b7f821910874a" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">직렬화 가능 클래스가 serialVersionUID를 명시 적으로 선언하지 않으면 직렬화 런타임은 Java (TM) 객체 직렬화 스펙에 설명 된대로 클래스의 다양한 측면을 기반으로 해당 클래스의 기본 serialVersionUID 값을 계산합니다. 그러나 기본 serialVersionUID 계산은 컴파일러 구현에 따라 달라질 수있는 클래스 세부 사항에 매우 민감하므로 예기치 않은 &lt;code&gt;InvalidClassException&lt;/code&gt; 이 발생할 수 있으므로 모든 serializable 클래스는 serialVersionUID 값을 명시 적으로 선언 &lt;em&gt;하는 것이 좋습니다.&lt;/em&gt;직렬화 해제 중입니다. 따라서 다른 Java 컴파일러 구현에서 일관된 serialVersionUID 값을 보장하려면 직렬화 가능 클래스가 명시 적 serialVersionUID 값을 선언해야합니다. 또한 명시 적 serialVersionUID 선언 은 가능한 경우 &lt;code&gt;private&lt;/code&gt; 수정자를 사용하는 것이 좋습니다. 이러한 선언은 즉시 선언하는 클래스에만 적용되므로 serialVersionUID 필드는 상속 된 멤버로 유용하지 않습니다. 배열 클래스는 명시적인 serialVersionUID를 선언 할 수 없으므로 항상 기본 계산 된 값을 갖지만 serialVersionUID 값과 일치하는 요구 사항은 배열 클래스에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a284373bcb59e24e39e3dac459820aaa1124e2" translate="yes" xml:space="preserve">
          <source>If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a &lt;code&gt;NameNotFoundException&lt;/code&gt; being thrown as early as possible, preferably at the time &lt;code&gt;addNamingListener()&lt;/code&gt; is called, or if that is not possible, the listener will receive the exception through the &lt;code&gt;NamingExceptionEvent&lt;/code&gt;.</source>
          <target state="translated">서비스가 기존 대상에 대한 등록 만 지원하는 경우 존재하지 않는 대상에 대한 등록을 시도하면 바람직하게 &lt;code&gt;addNamingListener()&lt;/code&gt; 가 호출되거나 가능하지 않은 경우 리스너가 수신 할 때 &lt;code&gt;NameNotFoundException&lt;/code&gt; 이 가능한 빨리 발생 합니다 관통 예외 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="f0a93070904cd7e6062d269f73ed4cf640917a73" translate="yes" xml:space="preserve">
          <source>If a service supports this method it cannot be concluded that job cancellation will always succeed. A job may not be able to be cancelled once it has reached and passed some point in its processing. A successful cancellation means only that the entire job was not printed, some portion may already have printed when cancel returns.</source>
          <target state="translated">서비스가이 방법을 지원하면 작업 취소가 항상 성공할 것이라고 결론을 내릴 수 없습니다. 처리 중 어느 시점에 도달하여 작업을 통과 한 후에는 작업을 취소하지 못할 수 있습니다. 성공적으로 취소한다는 것은 전체 작업이 인쇄되지 않았 음을 의미하며, 취소가 반환되면 일부 부분이 이미 인쇄되었을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2255c8ae3c0e253b4d1c3edfe6c7951b6b7652" translate="yes" xml:space="preserve">
          <source>If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans. Only MBeans from trusted sources may be registered in the MBeanServer.</source>
          <target state="translated">서명자 또는 코드 소스에이 권한이 부여되면 MBean의 신뢰할 수있는 소스로 간주됩니다. 신뢰할 수있는 소스의 MBean 만 MBeanServer에 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ecf67fc16b1bbea18316b3fee73e9a01230e4e" translate="yes" xml:space="preserve">
          <source>If a single argument is parsed more than once in the string, then the later parse wins.</source>
          <target state="translated">문자열에서 단일 인수가 두 번 이상 구문 분석되면 나중에 구문 분석이 승리합니다.</target>
        </trans-unit>
        <trans-unit id="31689da1ab6eb24083df20cceed8f165c2b092ae" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">&lt;code&gt;InetSocketAddress &lt;/code&gt; 로 표시되는 엔드 포인트에 바인드 된 소켓 이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 이 메소드는 소켓이 닫힌 후에도 &lt;code&gt;InetSocketAddress&lt;/code&gt; 를 계속 리턴합니다 . 이 경우 반환 된 &lt;code&gt;InetSocketAddress&lt;/code&gt; 의 주소는 &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt; 주소이고 해당 포트는 바인딩 된 로컬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="bb0809c0cf763cd6b646a20d3b4af68f3b750ce9" translate="yes" xml:space="preserve">
          <source>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is specified it applies to the whole collator object.</source>
          <target state="translated">&amp;lt;modifier&amp;gt;에 의해 제어되는 특수 데이터 정렬 규칙이 지정된 경우 전체 데이터 정렬 기 개체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dde854bb0f9389f51a8a547bcdbab6e693c555ad" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">spliterator는 그 이상 다음에 요소 추가 특성 값의보고를 포함하지 않는 경우 &lt;code&gt;SIZED&lt;/code&gt; 와 &lt;code&gt;SUBSIZED&lt;/code&gt; 을 제어 전문화 또는 단순화 계산에 클라이언트를 도움이되지 않습니다. 그러나 이렇게하면 빈 컬렉션 에 대해 불변의 빈 스플리터 인스턴스 ( &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt; 참조 )를 공유하여 사용할 수 있으며 클라이언트가 그러한 스플리터가 요소를 포함하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eceb3e8bdd7aa7928b72e084cf57d623f635838d" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">스트림에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 지정된 테이블 이 무시됩니다. 또한 스트림의 첫 번째 이미지에 테이블이 포함되고 후속 이미지에 테이블이 포함되지 않은 경우 첫 번째 이미지에 제공된 테이블이 모든 약어 이미지에 사용됩니다. 스트림에서 테이블을 읽은 후에는 동일한 스트림에서 읽은 테이블 만 재정의 할 수 있습니다. 새 테이블을 지정 하려면 스트림을 변경하기 위해 리더 의 &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2750feeb92c351bda0cd825237cf381d71b3604" translate="yes" xml:space="preserve">
          <source>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;[1, 2, 3]&lt;/code&gt;, then the result of executing &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; must be &lt;code&gt;[2, 4, 6]&lt;/code&gt;. However, if the source has no defined encounter order, then any permutation of the values &lt;code&gt;[2, 4, 6]&lt;/code&gt; would be a valid result.</source>
          <target state="translated">스트림이 정렬되면 대부분의 작업은 요소에 대해 발생 순서대로 작동하도록 제한됩니다. 스트림의 소스가 &lt;code&gt;List&lt;/code&gt; 인 경우 가 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 포함 경우 &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; 실행 결과는 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 이어야합니다 . 그러나 소스에 정의 된 조우 순서가 없으면 값 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 순열이 올바른 결과가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3da9f5ed3a50caf2ebc15ff55bbd7387d78001" translate="yes" xml:space="preserve">
          <source>If a string quote character is encountered, then a string is recognized, consisting of all characters after (but not including) the string quote character, up to (but not including) the next occurrence of that same string quote character, or a line terminator, or end of file. The usual escape sequences such as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and &lt;code&gt;&quot;\t&quot;&lt;/code&gt; are recognized and converted to single characters as the string is parsed.</source>
          <target state="translated">문자열 따옴표 문자가 발견되면 문자열 따옴표 문자 다음의 모든 문자 (포함되지는 않음), 같은 문자열 따옴표 문자의 다음 발생 (또는 포함하지 않음)까지의 문자열이 인식됩니다. 또는 파일 끝입니다. &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 와 같은 일반적인 이스케이프 시퀀스 는 문자열을 구문 분석 할 때 인식되어 단일 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cee086fbf4e72f394e2cd369d7a1a31214c885ef" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">수퍼 인터페이스가 매개 변수화 된 유형 인 경우 &lt;code&gt;Type&lt;/code&gt; 리턴 Type 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 각 슈퍼 인터페이스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a6f96de5e57069f6d14d17aca38943e0fdc8ff7" translate="yes" xml:space="preserve">
          <source>If a thread does not lock any object monitor or &lt;code&gt;lockedMonitors&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;MonitorInfo&lt;/code&gt; array. Similarly, if a thread does not lock any synchronizer or &lt;code&gt;lockedSynchronizers&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;LockInfo&lt;/code&gt; array.</source>
          <target state="translated">스레드가 객체 모니터를 잠그지 않거나 &lt;code&gt;lockedMonitors&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체는 빈 &lt;code&gt;MonitorInfo&lt;/code&gt; 배열을 갖습니다 . 마찬가지로 스레드가 동기화 프로그램을 잠그지 않거나 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 반환 된 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체에는 빈 &lt;code&gt;LockInfo&lt;/code&gt; 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="423d67d62c33ea4b987acaba9861af6927d6c017" translate="yes" xml:space="preserve">
          <source>If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providers then the method will block until the loading completes.</source>
          <target state="translated">스레드가 설치된 파일 시스템 제공자의로드를 시작하고 다른 스레드가 제공자를로드하려고 시도하는 메소드를 호출하면로드가 완료 될 때까지 메소드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c7ba95dc1b6c41c9659ab72fa979fc5c3b29d122" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 대기가 종료됩니다.&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt; 이 발생하며 스레드의 중단 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="9af6babb2d89b7b1bcb5f61c939d4682bb0b8bf3" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 차단 된 스레드의 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 그러면 채널이 닫히고 차단 된 스레드가 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt; 을 수신 하고 차단 된 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fd99bc1eee5eed72f1e348ec811d11b7678f072e" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;interruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인터럽트 가능한 채널의 I / O 작업에서 스레드가 차단되면 다른 스레드가 채널의 &lt;a href=&quot;interruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . 차단 된 스레드가 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 을 수신하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="da330aea3c98594d1083e77da98a318f71baeb0d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가이 선택기의 선택 방법 중 하나에서 현재 차단 된 경우 선택기의 호출을 호출하는 것처럼 스레드가 중단됩니다. &lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="d5afbadf14eba91b88bef9af2e17ba1b04cf7b04" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;watchservice#take--&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid--&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드가 현재 키 대기를 기다리는 &lt;a href=&quot;watchservice#take--&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 경우 즉시 &lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; 을&lt;/a&gt; 수신합니다 . 이 시계 서비스와 관련된 모든 유효한 키는&lt;a href=&quot;watchkey#isValid--&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="79a80fec9ac0e51a906db8a969589f57b8d53771" translate="yes" xml:space="preserve">
          <source>If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">주어진 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c7367fdf45de9116c0531a4eb673c46e4df10f0d" translate="yes" xml:space="preserve">
          <source>If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;; its interrupt status will remain set.</source>
          <target state="translated">스레드의 인터럽트 상태가 이미 설정되어 있고 채널에서 차단 I / O 작업을 호출하면 채널이 닫히고 스레드는 즉시 &lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; 을&lt;/a&gt;. 인터럽트 상태는 설정된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f20c8ec4cbcd889326c0ec36148d75b1de4b78c0" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않는다고 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="085511ee4e6f8838601b8420555dabe5caf417db" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 예외와 함께 완료됩니다. &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;. 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고 시도하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1e6a9ea34cc15cb7dc234bc610d3da7fd2fd1d7" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">시간 종료가 지정되고 조작이 완료되기 전에 시간 종료가 경과되면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외와 함께 완료됩니다. . 시간 초과가 발생하고 구현시 바이트가 기록되지 않았거나 지정된 버퍼에서 채널에 기록되지 않을 것을 보장 할 수없는 경우 채널에 쓰려고하면 추가로 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aeea9b2c990269d554f71236286a06879279f31" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">제한 시간이 지정되고 조작이 완료되기 전에 제한 시간이 경과하면 &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt; 예외로 조작이 완료됩니다 . 시간 초과가 발생하고 구현에서 바이트를 읽지 못했거나 채널에서 지정된 버퍼로 읽지 않을 것을 보장 할 수없는 경우 채널에서 계속 읽으려고하면 특정 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b059429e7b4fbc4030cc099662067f32b6c7ab30" translate="yes" xml:space="preserve">
          <source>If a type is annotated with this annotation type, compilers are required to generate an error message unless:</source>
          <target state="translated">이 주석 유형으로 유형에 주석이 달린 경우 다음과 같은 경우를 제외하고 컴파일러는 오류 메시지를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="860fe4e2923a6695add73192da6784b1d700c654" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;Optional&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Optional&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="ac19fb5ed0433a6a84bbf9870c3d0508394c1ec9" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalDouble&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="77f8284a88fc486cd8c49e73e5157ec4382cced0" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalInt&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="b442beaf0679fd03d92130f9d3a16dff8abc1a47" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;OptionalLong&lt;/code&gt; 에 값이 있으면 값을 반환하고, 그렇지 않으면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="d4e270a2bbe380815af7730e0b32eed7b9b310b0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present Optionals must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어 있고 존재하는 옵션은 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="53843db157010fe9437f6ec6848ceaa2431d68a8" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present instances must be unambiguously differentiable.</source>
          <target state="translated">값이 있으면 결과에 문자열 표현이 포함되어야합니다. 비어있는 인스턴스와 현재 인스턴스는 명확하게 구분할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0706b2c7911a55318a829716b41ba2d3be31b10d" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, return an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하고 값이 주어진 술어와 일치 하면 값을 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="891603f3a0de1e1f312f4666b625f9fb23d2e9c9" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to it, return that result, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;. This method is similar to &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt;&lt;code&gt;map(Function)&lt;/code&gt;&lt;/a&gt;, but the provided mapper is one whose result is already an &lt;code&gt;Optional&lt;/code&gt;, and if invoked, &lt;code&gt;flatMap&lt;/code&gt; does not wrap it with an additional &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 존재하면 제공된 &lt;code&gt;Optional&lt;/code&gt; 베어링 맵핑 함수를 적용하고 결과를 리턴하고 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 리턴하십시오 . 이 메소드는 &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt; &lt;code&gt;map(Function)&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 제공된 매퍼는 결과가 이미 &lt;code&gt;Optional&lt;/code&gt; 인 결과이며 , 호출 된 경우 &lt;code&gt;flatMap&lt;/code&gt; 은 추가 &lt;code&gt;Optional&lt;/code&gt; 로 랩핑하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b5560d2bb98c2edc06f003311054df22294d95" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an &lt;code&gt;Optional&lt;/code&gt; describing the result. Otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 제공된 맵핑 함수를 적용하고 결과가 널이 아닌 경우 결과를 설명 하는 &lt;code&gt;Optional&lt;/code&gt; 을 리턴 하십시오. 그렇지 않으면 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fad40f63b1a2a9bdb013e89c0f84f329771e8703" translate="yes" xml:space="preserve">
          <source>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</source>
          <target state="translated">값이 존재하면 지정된 소비자를 값으로 호출하십시오. 그렇지 않으면 아무 것도 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92cb4d374f2fe9448ca335ac55aeaabe71a1f569" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">방문자가의 결과를 돌려주는 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;NullPointerException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="5e01b98873a0cadbbe64c47b2b726716a54e9964" translate="yes" xml:space="preserve">
          <source>If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected. In particular, it is not required that changes to files carried out on remote systems be detected.</source>
          <target state="translated">감시 된 파일이 로컬 저장 장치에 없으면 파일 변경이 감지 될 수있는 경우 구현에 따라 다릅니다. 특히, 원격 시스템에서 수행 된 파일의 변경을 감지 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bee200d444da7e51810a8f81ba5dffe16cc316fc" translate="yes" xml:space="preserve">
          <source>If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned.</source>
          <target state="translated">addr이 IPv4 주소를 지정하면 Inet4Address의 인스턴스가 리턴됩니다. 그렇지 않으면 Inet6Address의 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="923186511eab92209b32f15d3fb01aaacb2e442c" translate="yes" xml:space="preserve">
          <source>If adjacent parsing is active, then parsing must match exactly the specified number of digits in both strict and lenient modes. In addition, no positive or negative sign is permitted.</source>
          <target state="translated">인접 구문 분석이 활성화 된 경우 구문 분석은 엄격 모드와 무성 모드에서 지정된 자릿수와 정확히 일치해야합니다. 또한 양수 또는 음수 부호는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8c6c1fd23bed92157c4876b59e8a94de5ba0fe9" translate="yes" xml:space="preserve">
          <source>If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.</source>
          <target state="translated">이 단계를 시작할 때 키 세트의 모든 키에 비어있는 관심 세트가 있으면 선택한 키 세트와 키의 준비 작업 세트가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478f44b721763a191efa4a005ca8cf8c23dac1b2" translate="yes" xml:space="preserve">
          <source>If all the date objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date is used. To compare the dates of two &lt;code&gt;TemporalAccessor&lt;/code&gt; instances, including dates in two different chronologies, use &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as a comparator.</source>
          <target state="translated">비교되는 모든 날짜 개체가 동일한 연대기 인 경우 추가 연대기 단계가 필요하지 않으며 현지 날짜 만 사용됩니다. 두 개의 다른 연대기 날짜를 포함하여 두 &lt;code&gt;TemporalAccessor&lt;/code&gt; 인스턴스 의 날짜를 비교하려면 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 비교 자로 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="920032b96bedf78cb11745b4b01ea2b9da62f86c" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date-time is used.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기에있는 경우 추가 연대기 단계가 필요하지 않으며 로컬 날짜-시간 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91e24b45b1050248e3d9b0f32a1bfe41649a4f37" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required.</source>
          <target state="translated">비교되는 모든 날짜-시간 객체가 동일한 연대기이면 추가 연대기 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7af80a78ccebdf694054065e68649e1c92533dff" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜-시간이 &lt;code&gt;LocalDateTime&lt;/code&gt; 의 인스턴스 인 경우 비교는 전적으로 날짜-시간을 기반으로합니다. 비교중인 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다. &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70daeec02ec422b3471ddc6193b4b37b8cb8342" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비교중인 모든 날짜가 &lt;code&gt;LocalDate&lt;/code&gt; 인스턴스 인 경우 비교는 전적으로 날짜를 기준으로합니다. 비교되는 일부 날짜가 다른 연대기 인 경우 연대기도 고려됩니다 . &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95938a0cd815321f6453791f7f4283d94220e212" translate="yes" xml:space="preserve">
          <source>If all the docs have the same binding specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 지정된 바인딩이 동일 하면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7869c5e4ed330a875f3cd70b80530f1cdf968256" translate="yes" xml:space="preserve">
          <source>If all the docs have the same number up value</source>
          <target state="translated">모든 문서의 번호가 같은 값을 갖는 경우</target>
        </trans-unit>
        <trans-unit id="323feabb33d09245620f68d33109a728cd260051" translate="yes" xml:space="preserve">
          <source>If all the docs have the same page ranges specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">모든 문서에 동일한 페이지 범위가 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 이 의미가 있으며 프린터 처리는 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="43de23ce23841ef0c6a6fa16c30e0adac32dff5f" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">모든 문서에 동일한 시트 데이터 정렬이 지정된 경우 다음 SheetCollate 및 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 조합 이 허용되며 다른 조합이 지정된 경우 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="53f4aefa8b3b18b801db7105e517f135c3160808" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sides value</source>
          <target state="translated">모든 문서의 측면 값이 동일한 경우</target>
        </trans-unit>
        <trans-unit id="4098503fbcb241fe10627044b2064dc72f141550" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after returned from this method, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 메서드에서 반환 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="088dd2d19f784625275b483d3f0f4f2ddbb175e3" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after this method has returned, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 이는&lt;/a&gt; 이 방법이 리턴 한 후 디렉토리에 액세스 할 때 발생합니다, 그것은는에 싸여 &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 자리를 차지할 액세스의 원인이 된 방법에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="448273579cd0c1573f50adb27cc551f6240ac792" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">는 IF &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;일을 초과하는 수는&lt;/a&gt; 다음 구문 분석 그것은 날짜가 사용할 수있는 경우 날짜에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f440d6e16437287ae444b44920a0eee99c549130" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the underlying &lt;code&gt;BufferedReader&lt;/code&gt;, it is wrapped in an &lt;a href=&quot;uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the &lt;code&gt;Stream&lt;/code&gt; method that caused the read to take place. This method will return a Stream if invoked on a BufferedReader that is closed. Any operation on that stream that requires reading from the BufferedReader after it is closed, will cause an UncheckedIOException to be thrown.</source>
          <target state="translated">경우 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 가이&lt;/a&gt; 기본에 액세스 할 때 발생합니다 &lt;code&gt;BufferedReader&lt;/code&gt; 로를 , 그것은에 싸여 &lt;a href=&quot;uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; &lt;/a&gt; 으로부터 발생합니다 &lt;code&gt;Stream&lt;/code&gt; 읽기가 발생하는 원인 방법. 이 메소드는 닫힌 BufferedReader에서 호출 된 경우 스트림을 리턴합니다. 해당 스트림에서 BufferedReader를 닫은 후 읽기가 필요한 작업을 수행하면 UncheckedIOException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="959df27348a054da287e538a4f7d1a74313d32f5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt; , then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 주석 형에 존재하지 않는 &lt;code&gt;T&lt;/code&gt; 를 입력 한 다음의 주석 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터 선언 제외한 선언 개질제로서 기록 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8371b963c2b6f04360837c6404d40bc176c92b9b" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is present, the compiler will enforce the usage restrictions indicated by &lt;code&gt;ElementType&lt;/code&gt; enum constants, in line with JLS 9.7.4.</source>
          <target state="translated">는 IF &lt;code&gt;@Target&lt;/code&gt; 의 메타 주석이 존재하는, 사용 제한을 적용합니다 컴파일러에 의해 표시 &lt;code&gt;ElementType&lt;/code&gt; 에의 JLS 9.7.4에 맞춰, 열거 상수.</target>
        </trans-unit>
        <trans-unit id="9496a4d3cf27eda519ac141e2a00e405156b6ffb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the particular type of the input stream.</source>
          <target state="translated">는 IF &lt;code&gt;IOException&lt;/code&gt; 가이 발생되지 않고, 그 스트림은 입력 스트림의 특정 유형에 따라 고정 된 상태로 리셋되고 그것이 어떻게 만들어졌다. &lt;code&gt;read&lt;/code&gt; 메소드 의 후속 호출자에게 제공 될 바이트 는 입력 스트림의 특정 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6de50cf0b5b005c73f2b22f23092356cfbc265a6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; reference was previously allowed, the previous settings are overwritten.</source>
          <target state="translated">경우 &lt;code&gt;Object&lt;/code&gt; 참조가 이전에 허용 된 이전 설정을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ce889769df21717dff5602aeddeab9f3a68fa96a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the constructor, it is used.</source>
          <target state="translated">&lt;code&gt;RMIServerImpl&lt;/code&gt; 이 생성자에 제공된 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c147456e60cfbfb343d2b171d44a03397a71498d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optionType&lt;/code&gt; was specified to this &lt;code&gt;ConfirmationCallback&lt;/code&gt;, this option may be specified as a &lt;code&gt;defaultOption&lt;/code&gt; or returned as the selected index.</source>
          <target state="translated">&lt;code&gt;optionType&lt;/code&gt; 이이 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 에 지정된 경우 ,이 옵션은 &lt;code&gt;defaultOption&lt;/code&gt; 으로 지정 되거나 선택된 색인으로 리턴 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bddc19f4e2a7499584504adbd2e120339e8a9d2c" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal--&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">ACL 항목 에이 속성보기와 동일한 제공자와 연관되지 않은 &lt;a href=&quot;aclentry#principal--&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt; 이 포함 된 경우 &lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 추가 검증 (있는 경우)은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e691cd0ee7a41eeed3186a97648a8370581048b" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered when accessing the directory then it causes the &lt;code&gt;Iterator&lt;/code&gt;'s &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; methods to throw &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; as the cause. As stated above, the &lt;code&gt;hasNext&lt;/code&gt; method is guaranteed to read-ahead by at least one element. This means that if &lt;code&gt;hasNext&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, and is followed by a call to the &lt;code&gt;next&lt;/code&gt; method, then it is guaranteed that the &lt;code&gt;next&lt;/code&gt; method will not fail with a &lt;code&gt;DirectoryIteratorException&lt;/code&gt;.</source>
          <target state="translated">디렉토리에 액세스 할 때 I / O 오류가 발생하면 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 을 원인으로하여 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다. 위에서 언급 한 바와 같이, &lt;code&gt;hasNext&lt;/code&gt; 방법은 적어도 하나의 요소에 의해 미리 읽히도록 보장된다. 즉, &lt;code&gt;hasNext&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 후 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하면 &lt;code&gt;next&lt;/code&gt; 메소드가 &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 과 함께 실패하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="feeedb640cf4499009e04bb26412c9322b88b5ad" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">파일에서 읽거나 출력 스트림에 쓰는 동안 I / O 오류가 발생하면 일부 바이트를 읽거나 쓴 후에 오류가 발생할 수 있습니다. 결과적으로 출력 스트림이 일치하지 않는 상태에있을 수 있습니다. I / O 오류가 발생하면 출력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c872125a1307797d25e4f9f64998713cf5ca5f3" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">입력 스트림에서 읽거나 파일에 쓰는 동안 I / O 오류가 발생하면 대상 파일을 작성한 후 일부 바이트를 읽거나 쓴 후에 발생할 수 있습니다. 결과적으로, 입력 스트림은 스트림의 끝에 있지 않을 수 있으며 불일치 상태에있을 수 있습니다. I / O 오류가 발생하면 입력 스트림을 즉시 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="190c966c8992a3839001e7e1af1d2b89e9457c04" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context. Otherwise, the class specified in the &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; environment property is used. Note that an initial context factory (an object that implements the InitialContextFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">InitialContextFactoryBuilder가 설치된 경우 초기 컨텍스트를 작성하기위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; 환경 특성에 가 사용됩니다. 초기 컨텍스트 팩토리 (InitialContextFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="98657208ee304eaeabe25e126ff14f176c167883" translate="yes" xml:space="preserve">
          <source>If an MBean implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, then it is not added to the class loader repository. The class &lt;a href=&quot;privatemlet&quot;&gt;&lt;code&gt;PrivateMLet&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;MLet&lt;/code&gt; that implements &lt;code&gt;PrivateClassLoader&lt;/code&gt;.</source>
          <target state="translated">MBean가 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 , 클래스 로더 저장소에 추가되지 않습니다. 클래스 &lt;a href=&quot;privatemlet&quot;&gt; &lt;code&gt;PrivateMLet&lt;/code&gt; 를는&lt;/a&gt; 의 서브 클래스 &lt;code&gt;MLet&lt;/code&gt; 를 그 구현의 &lt;code&gt;PrivateClassLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7dbdf0d0215e39ffb9e056dc435071a7e3d1afd" translate="yes" xml:space="preserve">
          <source>If an ObjectName is not a pattern, it must contain at least one key with its associated value.</source>
          <target state="translated">ObjectName이 패턴이 아닌 경우 연관된 값을 가진 하나 이상의 키를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0bc3775989ff9a0fa2129381bf0e75ba0c93374" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. The article &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Dynamic code downloading using Java RMI&lt;/em&gt;&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">RMI 커넥터 클라이언트 또는 서버가 자신의 피어에서 알 수없는 클래스의 인스턴스를 수신하고 RMI 연결에 대해 동적 코드 다운로드가 활성화 된 경우 피어가 지정한 코드베이스에서 클래스를 다운로드 할 수 있습니다. &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Java RMI를 사용한 동적 코드 다운로드&lt;/em&gt;&lt;/a&gt; 기사&lt;em&gt;&lt;/em&gt; 에서이를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9c4c5268bcffbf9c0c5b98ecb4ed28911043818e" translate="yes" xml:space="preserve">
          <source>If an annotation of type</source>
          <target state="translated">유형이 주석 인 경우</target>
        </trans-unit>
        <trans-unit id="9df83510632408ed0d5232c4209c863ed75fc2b2" translate="yes" xml:space="preserve">
          <source>If an annotation returned by a method in this interface contains (directly or indirectly) a &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a &lt;a href=&quot;../typenotpresentexception&quot;&gt;&lt;code&gt;TypeNotPresentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스의 메소드에 의해 리턴 된 주석 이이 VM에서 액세스 할 수없는 클래스를 참조 하는 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 값 멤버를 (직접 또는 간접적으로) 포함하는 경우, 리턴 된 주석 에서 관련 클래스 리턴 메소드를 호출하여 클래스를 읽으려고합니다. &lt;a href=&quot;../typenotpresentexception&quot;&gt; &lt;code&gt;TypeNotPresentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0227ca62999d931b56d6f6658a6e345f41f26f21" translate="yes" xml:space="preserve">
          <source>If an annotation type</source>
          <target state="translated">주석 유형 인 경우</target>
        </trans-unit>
        <trans-unit id="ed99bca3e6f592b88e87557055d253e0c0b22f1a" translate="yes" xml:space="preserve">
          <source>If an application caches method handles for broad sharing, it should use &lt;code&gt;publicLookup()&lt;/code&gt; to create them. If there is a lookup of &lt;code&gt;Class.forName&lt;/code&gt;, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.</source>
          <target state="translated">응용 프로그램이 광범위한 공유를 위해 메서드 핸들을 캐시하는 경우 &lt;code&gt;publicLookup()&lt;/code&gt; 을 사용하여 만들어야합니다. 조회가있는 경우 &lt;code&gt;Class.forName&lt;/code&gt; 실패하고 애플리케이션은 적절한 조치를 취해야합니다. 아마도 부트 스트랩 메서드를 호출하는 동안 나중에 조회하면 호출자의 특정 ID를 통합하여 메서드에 액세스 할 수있게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dbacd8fdd96aa697bee57950998d0a96108abc1" translate="yes" xml:space="preserve">
          <source>If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this locale matching documentation.</source>
          <target state="translated">응용 프로그램 또는 시스템이 국제화되어 있고 여러 로캘에 대한 지역화 된 리소스를 제공하는 경우 각 사용자의 특정 기본 설정을 충족하는 하나 이상의 로캘 (또는 언어 태그)을 찾아야하는 경우가 있습니다. 이 로케일 일치 문서에서 &quot;언어 태그&quot;라는 용어는 &quot;로케일&quot;과 상호 교환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d7860179acd56276c79c3590549cb4c6e64204" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 해당하는 모든 형식 요소에 해당하는 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 해당하는 새 형식이 무시됩니다. 필요한 것보다 적은 형식이 제공되는 경우 인수 색인의 형식 만 &lt;code&gt;newFormats.length&lt;/code&gt; 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1f72387046823cf7698e1a0b6d176b89054ec4a7" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.</source>
          <target state="translated">패턴 문자열에서 둘 이상의 형식 요소에 인수 색인이 사용되면 마지막 형식 요소에 사용 된 형식이 배열에 리턴됩니다. 패턴 문자열의 형식 요소에 인수 색인이 사용되지 않으면 배열에서 널이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bd454c7aa8c21821eb903a4d4d4438d54e9d0c75" translate="yes" xml:space="preserve">
          <source>If an attribute class extends &lt;code&gt;EnumSyntax&lt;/code&gt;, and the value of the attribute is an IPP-compatible value, the attribute's &lt;code&gt;toString&lt;/code&gt; method returns the IPP string representation of the attribute value, such as &quot;processing-stopped&quot; for the &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; attribute. However, because the &lt;code&gt;EnumSyntax&lt;/code&gt; class is extensible, vendors can define their own attribute values. If an attribute uses the &lt;code&gt;EnumSyntax&lt;/code&gt; class and is set to one of these vendor-defined values then the &lt;code&gt;toString&lt;/code&gt; method will not return the IPP string representation of the value.</source>
          <target state="translated">속성 클래스가 &lt;code&gt;EnumSyntax&lt;/code&gt; 를 확장 하고 속성 값이 IPP 호환 값인 경우 속성의 &lt;code&gt;toString&lt;/code&gt; 메소드는 &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; 속성에 대한 &quot;processing-stopped&quot;와 같은 속성 값의 IPP 문자열 표시를 리턴 합니다. 그러나 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스는 확장 가능 하므로 공급 업체가 고유 한 속성 값을 정의 할 수 있습니다. 속성이 &lt;code&gt;EnumSyntax&lt;/code&gt; 클래스를 사용하고 이러한 공급 업체 정의 값 중 하나로 설정된 경우 &lt;code&gt;toString&lt;/code&gt; 메소드는 의 IPP 문자열 표시를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2271d961817d69ed166f3999b4fca55a2a3bfd1" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as PrintRequestAttribute, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;}'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">속성이 &lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt; 및 PrintRequestAttribute를 구현하는 경우 클라이언트는 속성을 &lt;code&gt;Doc&lt;/code&gt; 해당 문서에만 관련된 작업 설정을 지정하기 위해 Doc 의 속성 세트에 .</target>
        </trans-unit>
        <trans-unit id="8553a6030a41f0e392620a86588d848a2d5646af" translate="yes" xml:space="preserve">
          <source>If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities.</source>
          <target state="translated">주어진 이름의 속성이 이미 존재하면 그 값이 대체됩니다. 속성이 존재하지 않으면 작성됩니다. 속성의 존재와 속성의 생성을 검사하는 테스트가 다른 파일 시스템 활동과 관련하여 원자적인 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="27440a763ede5ab8ba752691c8d7cfa12b2cc574" translate="yes" xml:space="preserve">
          <source>If an authority is given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">권한이 주어지면 문자열 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 이 추가되고 그 뒤에 권한이옵니다. 기관에 리터럴 IPv6 주소가 포함 된 경우 주소는 대괄호로 묶어야합니다 ( &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; ) . 에없는 모든 문자</target>
        </trans-unit>
        <trans-unit id="30c03b38fd51437f34d169d8c1845e0f976cba81" translate="yes" xml:space="preserve">
          <source>If an element &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of &lt;code&gt;Arrays.toString(e)&lt;/code&gt;. If an element &lt;code&gt;e&lt;/code&gt; is an array of a reference type, it is converted to a string as by invoking this method recursively.</source>
          <target state="translated">요소 &lt;code&gt;e&lt;/code&gt; 가 프리미티브 유형의 배열 인 경우, 적절한 &lt;code&gt;Arrays.toString(e)&lt;/code&gt; 오버로드를 호출하여 문자열로 변환됩니다 . 요소 &lt;code&gt;e&lt;/code&gt; 가 참조 유형의 배열 인 경우,이 메소드를 재귀 적으로 호출하여 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="261e54ff065700a24467a3b37a05bc35f1bc1e0e" translate="yes" xml:space="preserve">
          <source>If an entry already exists for the specified alias, it is overridden.</source>
          <target state="translated">지정된 별명에 대한 항목이 이미 있으면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9f14cb55aec7f7c0b7e951ed92525cdc983689" translate="yes" xml:space="preserve">
          <source>If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.</source>
          <target state="translated">초기 핸드 셰이크 중에 오류가 발생하면이 메소드는 유효하지 않은 세션 스위트 &quot;SSL_NULL_WITH_NULL_NULL&quot;을보고하는 유효하지 않은 세션 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1773b2b10f572a15df1a83f51dfc4260cdf90a56" translate="yes" xml:space="preserve">
          <source>If an error occurs then the SSL socket is closed and an IOException is thrown. The underlying connection remains intact.</source>
          <target state="translated">오류가 발생하면 SSL 소켓이 닫히고 IOException이 발생합니다. 기본 연결은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0469e2eb38e10c985523abc8d2b5541786c72d7d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during an enumeration, the enumeration becomes invalid. Subsequent invocation of any method on that enumeration will yield undefined results.</source>
          <target state="translated">열거 중에 예외가 발생하면 열거가 유효하지 않게됩니다. 해당 열거에서 메소드를 계속 호출하면 정의되지 않은 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4edf72f63744ff4e52753a8efa7493d7a0576ed0" translate="yes" xml:space="preserve">
          <source>If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">예외 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 예외 유형이 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa77166dccaba4fc56b68f0c67338ce9025815" translate="yes" xml:space="preserve">
          <source>If an existing &lt;code&gt;Processor&lt;/code&gt; object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</source>
          <target state="translated">기존 &lt;code&gt;Processor&lt;/code&gt; 개체를 사용하지 않는 경우 프로세서 인스턴스를 만들기 위해 도구는 프로세서 클래스의 인수 없음 생성자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7d315c92816e5851e4dc9c39278030e06b4e20d6" translate="yes" xml:space="preserve">
          <source>If an implementation does not support schemas, it should throw OperationNotSupportedException. If an implementation does support schemas, it should define this method to return the appropriate information.</source>
          <target state="translated">구현이 스키마를 지원하지 않으면 OperationNotSupportedException을 발생시켜야합니다. 구현이 스키마를 지원하는 경우 적절한 정보를 리턴하도록이 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4c73fde229aaf78d628130cf2dc942c93b26494" translate="yes" xml:space="preserve">
          <source>If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.</source>
          <target state="translated">시스템 특성으로 구현을 지정하지 않은 경우 시스템 기본 구현 클래스가 인스턴스화되고 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="043b26dca2264b1abb0bfae84593fcda3d702603" translate="yes" xml:space="preserve">
          <source>If an implementation represents a field that can be simplified, or combined with others, then this method must be implemented.</source>
          <target state="translated">구현이 단순화되거나 다른 필드와 결합 될 수있는 필드를 나타내는 경우이 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b30c559fc9c71304701a7f40146dfcf10b6d44b" translate="yes" xml:space="preserve">
          <source>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:</source>
          <target state="translated">오브젝트 팩토리 빌더가 설치된 경우 오브젝트 작성을위한 팩토리를 작성하는 데 사용됩니다. 그렇지 않으면 다음 규칙을 사용하여 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2b3be881430739dc065ccc4b9432e347d8bc309f" translate="yes" xml:space="preserve">
          <source>If an override is added, then any date that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 날짜가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="255c469340eb5e4421672d0f2a54c086d1b3a334" translate="yes" xml:space="preserve">
          <source>If an override is added, then any instant that is formatted or parsed will be affected.</source>
          <target state="translated">재정의가 추가되면 형식이 지정되거나 구문 분석 된 모든 인스턴트가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="0fbebb5dc8d306792468bfb85d5fadc68fc9bcac" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원 , 메소드는 현재 날짜의 원시 오프셋 값을 리턴합니다. 예를 들어, 호놀룰루에서는 1947 년에 원시 오프셋이 GMT-10 : 30에서 GMT-10 : 00으로 변경되었으며이 방법은 항상 -36000000 밀리 초 (예 : -10 시간)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a926ad586a71b3f84679e24d71e358a0ff83b65" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 히스토리 GMT 오프셋 변경을 지원하는 경우 지정된 GMT 오프셋이 최신 GMT 오프셋으로 설정되고 알려진 최신 GMT 오프셋 값과의 차이가 모든 히스토리 GMT 오프셋 값을 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0ae28c236839ff6f2827de1f4455a2f8e23e12d" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 하는 경우 ,이 방법은 미래 예측 일 수 있고 현재 규칙과 동일하지 않을 수있는 마지막으로 알려진 일광 절약 시간제 규칙을 참조합니다. 현재 규칙도 고려해야하는 경우 &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt; 호출을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceae883a33c038a59aa9297cd34719c700a68dfa" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction.</source>
          <target state="translated">기본 &lt;code&gt;TimeZone&lt;/code&gt; 인 경우 구현 서브 클래스가 과거 및 미래 일광 절약 시간제 스케줄 변경을 지원 ,이 메소드는 미래 예측이 될 수있는 마지막으로 알려진 일광 절약 시간제 규칙의 절약 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e6cdcb6abb3fe6a57aabba3c4945a777923f2bd3" translate="yes" xml:space="preserve">
          <source>If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread.</source>
          <target state="translated">다른 스레드가 교환 지점에서 이미 대기중인 경우 스레드 스케줄링을 위해 재개되고 현재 스레드가 전달한 오브젝트를 수신합니다. 현재 스레드는 다른 스레드가 교환으로 전달한 오브젝트를 수신하여 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="55a602e52f31c6fce149aff8e6c8a2bb72960c45" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in an invocation of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the &lt;a href=&quot;selector#selectNow--&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">다른 스레드가 현재 &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 메소드 호출에서 차단 된 경우 해당 호출이 즉시 리턴됩니다. 현재 진행중인 선택 작업이 없으면 그 동안 &lt;a href=&quot;selector#selectNow--&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하지 않으면 이러한 메서드 중 하나를 다음에 호출하면 즉시 반환 됩니다. 어쨌든 해당 호출에 의해 리턴되는 값은 0이 아닐 수 있습니다. &lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt; 의 후속 호출 메소드 이 메소드가 다시 호출되지 않는 한 평소와 같이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8c2ef8a9bb952f18badf3b5ecafae0a465fefa" translate="yes" xml:space="preserve">
          <source>If any attributes are unsupported only because they are in conflict with other attributes then it is at the discretion of the service to select the attribute(s) to be identified as the cause of the conflict.</source>
          <target state="translated">속성이 다른 속성과 충돌하여 지원되지 않는 속성 인 경우 서비스의 재량에 따라 충돌의 원인으로 식별 할 속성을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebc8985caafe276614f95fc78ffd3e5249f1603" translate="yes" xml:space="preserve">
          <source>If any bits of a particular byte have never been set at the time the byte is flushed to the destination, those bits will be set to 0 automatically.</source>
          <target state="translated">바이트가 대상으로 플러시 될 때 특정 바이트의 비트가 설정되지 않은 경우 해당 비트는 자동으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="702be5b9ebfbe3a5f1d1aa77356733e4327d5c79" translate="yes" xml:space="preserve">
          <source>If any keys were added to the cancelled-key set while step (2) was in progress then they are processed as in step (1).</source>
          <target state="translated">단계 (2)가 진행되는 동안 취소 된 키 세트에 키가 추가되면 단계 (1)에서와 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="51f61f6cbbe9d425e171c7d86f0b2ee40a25ba9f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">임의의 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 또는 &lt;code&gt;createTime&lt;/code&gt; 파라미터 값을 갖는 &lt;code&gt;null&lt;/code&gt; 그 대응하는 타임 스탬프는 변경되지 않는다. 타임 스탬프 속성 중 일부만 업데이트 될 때 구현시 파일 속성의 기존 값을 읽어야 할 수도 있습니다. 결과적으로이 방법은 다른 파일 시스템 작업과 관련하여 원 자성 작업이 아닐 수 있습니다. 기존 값을 읽고 다시 쓰면 정밀도 손실이 발생할 수 있습니다. 의 모든 경우 &lt;code&gt;lastModifiedTime&lt;/code&gt; , &lt;code&gt;lastAccessTime&lt;/code&gt; 및 &lt;code&gt;createTime&lt;/code&gt; 매개 변수는 &lt;code&gt;null&lt;/code&gt; 이 메소드는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8c0135add7c8b60bb88502e1753b104e3e7777d" translate="yes" xml:space="preserve">
          <source>If any of the CA certificates contain the &lt;code&gt;BasicConstraintsExtension&lt;/code&gt;, the value of the &lt;code&gt;pathLenConstraint&lt;/code&gt; field of the extension overrides the maximum path length parameter whenever the result is a certification path of smaller length.</source>
          <target state="translated">CA 인증서 중 하나에 &lt;code&gt;BasicConstraintsExtension&lt;/code&gt; 이 포함 된 경우 확장 의 &lt;code&gt;pathLenConstraint&lt;/code&gt; 필드 값은 결과가 더 작은 길이의 인증 경로 일 때마다 최대 경로 길이 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3ec333633e17c9be083cec2c06b962a41326b457" translate="yes" xml:space="preserve">
          <source>If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="21a8f6cbf8da0180ca327e40df0d37c1951e9068" translate="yes" xml:space="preserve">
          <source>If any of these restrictions are violated, &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. If the &lt;code&gt;interfaces&lt;/code&gt; array argument or any of its elements are &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 위반하면 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 에서 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생 합니다. 는 IF &lt;code&gt;interfaces&lt;/code&gt; 배열 인수 또는 요소 중 하나가 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="ff3b12e4e909401d37518b8a3b2f0f268050f07d" translate="yes" xml:space="preserve">
          <source>If any one of the given (name, filter) pairs cannot be registered, then the operation fails with an exception, and no names or filters are registered.</source>
          <target state="translated">주어진 (이름, 필터) 쌍 중 하나를 등록 할 수 없으면 예외로 작업이 실패하고 이름이나 필터가 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c41f89efd65d6831c5b78321674605fbf8e57d9a" translate="yes" xml:space="preserve">
          <source>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">스트림 요소가 NaN이거나 합계가 NaN 인 경우 합계는 NaN이됩니다. 부동 소수점 합의 값은 입력 값과 덧셈 연산 순서 모두의 함수입니다. 이 방법의 추가 연산 순서는 계산 결과의 속도와 정확성을 향상시키기 위해 구현 유연성을 허용하도록 의도적으로 정의되지 않았습니다. 특히,이 방법은 보상 된 합산 또는 다른 기술을 사용하여 구현되어 &lt;code&gt;double&lt;/code&gt; 값 의 단순한 합산과 비교하여 수치 합의 오차 한계를 감소시킬 수있다 .</target>
        </trans-unit>
        <trans-unit id="0366cecb1a7ed3c3842ffb9c2ca86a1363dd9a67" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">기다리는 동안 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 다른 모든 대기 스레드에서 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; 이 발생합니다.&lt;/a&gt; 을 발생시키고 장벽이 중단 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4afdb9645427c72b2b449dab0d6dc64d70f5f7ed" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">이 상태에서 대기중인 스레드가 있으면 깨우기 위해 선택됩니다. 그러면 해당 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 돌아 오기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c78a7fa649adbc90dbb23129fc74d5e1c06006a" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">스레드가이 상태에서 대기중인 경우 모두 깨어납니다. 각 스레드는 &lt;code&gt;await&lt;/code&gt; 에서 복귀하기 전에 잠금을 다시 확보해야합니다 .</target>
        </trans-unit>
        <trans-unit id="47fbfc22f0224fd32a90e5910c55321028c1907f" translate="yes" xml:space="preserve">
          <source>If attribute already exists, replaces all existing values with new specified values. If the attribute does not exist, creates it. If no value is specified, deletes all the values of the attribute. Removal of the last value will remove the attribute if the attribute is required to have at least one value. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 이미 존재하는 경우 기존의 모든 값을 지정된 새 값으로 바꿉니다. 속성이 존재하지 않으면 작성합니다. 값을 지정하지 않으면 속성의 모든 값을 삭제합니다. 속성에 하나 이상의 값이 필요한 경우 마지막 값을 제거하면 속성이 제거됩니다. 단일 값 특성에 둘 이상의 값을 추가하려고하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="a71ec53a572d41f56b8978727aaa4319a3583553" translate="yes" xml:space="preserve">
          <source>If attribute does not exist, create the attribute. The resulting attribute has a union of the specified value set and the prior value set. Adding an attribute with no value will throw &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have at least one value. For a single-valued attribute where that attribute already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">속성이 존재하지 않으면 속성을 작성하십시오. 결과 속성에는 지정된 값 세트와 이전 값 세트의 합집합이 있습니다. 값이없는 속성을 추가하면 속성에 하나 이상의 값이 있어야하는 경우 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생합니다. 해당 속성이 이미 존재하는 단일 값 속성의 경우 &lt;code&gt;AttributeInUseException&lt;/code&gt; 을 발생 시킵니다. 단일 값 속성에 둘 이상의 값을 추가하려고 시도하면 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3989b3dfcf79c0772b368fc99263d6921c534321" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">인증이 성공하면 연관된 &lt;a href=&quot;../../../java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt; 채워진 인증 된 주제가 리턴됩니다. 그런 다음 지정된 프린시 펄 세트를 기반으로 권한 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="384a750120cc655c818a55ff4a92437e6d8b5336" translate="yes" xml:space="preserve">
          <source>If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL.</source>
          <target state="translated">자동 리디렉션이 활성화되어 있고이 요청이 다른 대상으로 리디렉션되면 호출자에게 리디렉션 된 호스트 / URL에 연결할 수있는 권한도 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="214c67c3b5c1b48a5612e6002691988064bf0ec4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">두 &lt;code&gt;Path&lt;/code&gt; 객체가 &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 이 메서드는 파일이 있는지 확인하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 두 &lt;code&gt;Path&lt;/code&gt; 객체가 서로 다른 공급자와 연결되어 있으면 이 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면이 메소드는 두 &lt;code&gt;Path&lt;/code&gt; 객체가 동일한 파일을 찾는 지 확인 하고 구현에 따라 두 파일을 열거 나 액세스해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4547af366065ff735c348a2ae9741324e8b7ac" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">두 인수가 모두 정수인 경우 결과는 실제로 &lt;code&gt;double&lt;/code&gt; 인수로 거듭 제곱 할 수있는 경우 첫 번째 인수를 두 번째 인수의 거듭 제곱으로 올린 수학적 결과와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9e16fe4a0bb9164db40801221f5bd4724181b86e" translate="yes" xml:space="preserve">
          <source>If both arguments are negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -3*</source>
          <target state="translated">두 인수가 모두 음의 무한대이면 결과는 -3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7882093d9bf21c1a62a7634c6a186d1b60176" translate="yes" xml:space="preserve">
          <source>If both arguments are positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">두 인수가 모두 양의 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="fc50ec0abca10e371c02173b94982f3dab4ec295" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, &lt;code&gt;direction&lt;/code&gt; is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal).</source>
          <target state="translated">두 인수 모두 0 &lt;code&gt;direction&lt;/code&gt; 부호 가 지정된 경우 방향 이 변경되지 않은 상태로 리턴됩니다 (인수가 동일한 것으로 비교되는 경우 두 번째 인수를 리턴해야 함을 의미 함).</target>
        </trans-unit>
        <trans-unit id="1ae942765abc7210f5202cbe952dc04cbb521ee9" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, a value equivalent to &lt;code&gt;direction&lt;/code&gt; is returned.</source>
          <target state="translated">두 인수 모두 0으로 부호가 지정된 경우 &lt;code&gt;direction&lt;/code&gt; 에 해당하는 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="70f5cab03df99b6ce504b587920dfb5e98d8aa1e" translate="yes" xml:space="preserve">
          <source>If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports.</source>
          <target state="translated">두 권한 구성 요소가 모두 서버 기반 인 경우 URI는 사용자 정보 구성 요소에 따라 정렬됩니다. 이러한 구성 요소가 동일하면 URI는 호스트의 순서에 따라 대소 문자를 구분하지 않고 정렬됩니다. 호스트가 동일하면 포트 순서에 따라 URI가 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="35daff90f12a3fdfb2ee7aaec5156a628122493a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">두 경우 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;' '&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="86fead13194ade589a2825bc28cba12789046f04" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공되면 &lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37322522f6007d5f007c17ebbe89695f06d7d158" translate="yes" xml:space="preserve">
          <source>If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">PrincipalClass 및 &quot;PrincipalName&quot;이 모두 &quot;*&quot;이면 모든 &lt;code&gt;Subject&lt;/code&gt; 가 소유 한 지정된 신임 정보에 대한 액세스 권한이 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f1f59b1990a9778560b4bab37a8896d7e2ca6a4" translate="yes" xml:space="preserve">
          <source>If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code).</source>
          <target state="translated">언어 및 국가 필드가 모두 누락 된 경우 변형, 스크립트 또는 확장 필드가있는 경우에도이 함수는 빈 문자열을 반환합니다 (변형 만 포함하는 로캘을 가질 수없는 경우 변형은 형성된 언어 또는 국가 코드).</target>
        </trans-unit>
        <trans-unit id="f17a471a0efa20dccdfd9df73789528ef03ee4cd" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">이 풀에서 작동하는 ForkJoinTask에 의해 호출되면 &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 그렇지 않으면,이 풀이 &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt; 이거나 지정된 시간 종료가 경과 할 때까지 작업 수행을 대기 및 / 또는 지원하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8be13a39c3ce6b65d510654f24b14ebdee6bb3" translate="yes" xml:space="preserve">
          <source>If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.</source>
          <target state="translated">다른 값으로 동일한 헤더를 여러 번 설정하는 연결에서 호출 된 경우 마지막 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c482125ee1539de1724656d21516fd3060b7e464" translate="yes" xml:space="preserve">
          <source>If cipher suites have been set via &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; then they are enabled before the TLS handshake begins.</source>
          <target state="translated">&lt;code&gt;setEnabledCipherSuites&lt;/code&gt; 를 통해 암호 스위트가 설정된 경우 TLS 핸드 셰이크가 시작되기 전에 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5def33651e6193aa37639feee2e1bacd4151be" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="239b3d190809a5bb14183b924e8a7fef0e270a8a" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; with type &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt;&lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">클라이언트 연결을 닫으면 예외가 발생하면이 메소드에서 해당 예외가 발생하지 않습니다. &lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; &lt;/a&gt; 유형 &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt; &lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt; 을&lt;/a&gt; 종료 할 수 없었던 접속의 접속 ID와이 MBean로부터 방출된다.</target>
        </trans-unit>
        <trans-unit id="6cc58710f7a52a62031b39086a811bf5c62f9be6" translate="yes" xml:space="preserve">
          <source>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</source>
          <target state="translated">corePoolSize 이상의 스레드가 실행중인 경우 실행자는 항상 새 스레드를 추가하는 대신 요청 큐를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="cb543f07d153ad84e16f6614709ff0723e83f00b" translate="yes" xml:space="preserve">
          <source>If currencyTimeLimit is &amp;gt; 0, then the new value for the attribute is cached in the attribute descriptor's 'value' field and the 'lastUpdatedTimeStamp' field is set to the current time stamp.</source>
          <target state="translated">currencyTimeLimit이&amp;gt; 0이면 속성의 새 값이 속성 설명 자의 'value'필드에 캐시되고 'lastUpdatedTimeStamp'필드가 현재 시간 소인으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="318a070d46817b0d3e2904d4f73faabc24bf182e" translate="yes" xml:space="preserve">
          <source>If current thread is interrupted, throw InterruptedException.</source>
          <target state="translated">현재 스레드가 중단 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d2831e950ddf2d38fc039e2e83359dc77d52eecc" translate="yes" xml:space="preserve">
          <source>If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.</source>
          <target state="translated">연결에서 데이터가 이미 전송 된 경우이 핸드 셰이크 동안 데이터가 계속 흐릅니다. 핸드 셰이크가 완료되면 이벤트가 표시됩니다. 이 메소드는 연결의 초기 핸드 셰이크와 동기화되며 협상 된 핸드 셰이크가 완료되면 리턴합니다. 일부 프로토콜은 기존 소켓에서 다중 핸드 셰이크를 지원하지 않을 수 있으며 IOException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23edc5313c1114129c0451e0f085c188db85181" translate="yes" xml:space="preserve">
          <source>If different docs have different bindings specified, then only two values of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; make sense, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 서로 다른 바인딩이 지정되어 있으면 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의&lt;/a&gt; 두 값만 의미가 있으며 다른 값을 지정하면 작업이 제출 될 때 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6a5c3e077d48f57da30ae30c448c6f813a923be7" translate="yes" xml:space="preserve">
          <source>If different docs have different sheet collations specified, then only one value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; is permitted, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">다른 문서에 다른 시트 데이터 정렬이 지정된 경우 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 값은 하나만 허용되며 다른 값이 지정된 경우 작업을 제출하면 프린터에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4cc730ea4ab4177fe6780dd6b3762cbb0dc9f71f" translate="yes" xml:space="preserve">
          <source>If disabled, only the name and class of the object is returned. If enabled, the object will be returned.</source>
          <target state="translated">비활성화하면 개체의 이름과 클래스 만 반환됩니다. 활성화하면 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="332d8e7d0f59b9812b7d8680ca5e21ee5e3a7a49" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 경우 &lt;code&gt;sourceXSubsampling&lt;/code&gt; 또는 &lt;code&gt;sourceYSubsampling&lt;/code&gt; 가 0 또는 음수, &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="10859c24a221b0a1a8f8c2d45e2dd5f29f7ffaa0" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or equal to the corresponding period, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">어느 쪽이든 &lt;code&gt;subsamplingXOffset&lt;/code&gt; 또는 &lt;code&gt;subsamplingYOffset&lt;/code&gt; 가 네거티브 이상을 초과하거나 동기 같 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 발생한다.</target>
        </trans-unit>
        <trans-unit id="f1bccf0359c9d2523582443e154621147124c9b2" translate="yes" xml:space="preserve">
          <source>If either argument is NaN and neither argument is infinite, then the result is NaN.</source>
          <target state="translated">인수가 NaN이고 인수가 모두 무한대 인 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a87ec8779fbe2da84925808f31ac1112c6261d11" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 첫 번째 인수가 무한하거나 두 번째 인수가 양의 0 또는 음의 0이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="b78f08e2975896437871c452fd60393fe6909b91" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, then the result is NaN.</source>
          <target state="translated">인수 중 하나가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="34eb1a13a1d41fedad71ac94304afaf4d3b30061" translate="yes" xml:space="preserve">
          <source>If either argument is a NaN, then NaN is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1dead44a3b56a54e43e3eaa910e00403c25df167" translate="yes" xml:space="preserve">
          <source>If either argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수 중 하나가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="e2a88d05f4fde9c492de3341283adf63bc8f2e9c" translate="yes" xml:space="preserve">
          <source>If either of the destination offsets are negative, the source region is clipped so that its top left will coincide with the top left of the destination image, taking subsampling into account. Then the result is clipped to the destination image on the right and bottom, if one is specified, taking subsampling and destination offsets into account.</source>
          <target state="translated">대상 오프셋 중 하나가 음수이면 소스 영역이 클리핑되어 서브 샘플링을 고려하여 왼쪽 상단이 대상 이미지의 왼쪽 상단과 일치합니다. 그런 다음 서브 샘플링 및 대상 오프셋을 고려하여 지정된 경우 오른쪽과 아래쪽의 대상 이미지에 결과가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="03f21ceb73c687836a6489d537281750ea1dd4dd" translate="yes" xml:space="preserve">
          <source>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</source>
          <target state="translated">지정된 배열 중 하나 이상이 하나 이상의 배열 수준을 통해 직접 또는 간접적으로 요소로 포함 된 경우이 메서드의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3db76a27295abd8950cde00cc86a08c8f4f37d6" translate="yes" xml:space="preserve">
          <source>If either the source or destination regions end up having a width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">소스 또는 대상 영역 중 하나의 너비 또는 높이가 0이면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16d93984ca72bf8d13d016fde295c0c3effdeb16" translate="yes" xml:space="preserve">
          <source>If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned.</source>
          <target state="translated">이 URI 또는 ​​제공된 URI가 불투명하거나 두 URI의 체계 및 권한 구성 요소가 동일하지 않거나이 URI의 경로가 지정된 URI 경로의 접 두부가 아닌 경우 제공된 URI는 다음과 같습니다. 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="3ec3c5e0a4dd72da9a56884a1749a8ec51b24003" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e02489afb24dcd898ea786f1764d129a6f696e32" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 전체 프로세스 중에 언제라도 파일 끝이 발견되면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69e5b4feef83c14b8462d2220d828694ae4230e4" translate="yes" xml:space="preserve">
          <source>If end of file is encountered before even one byte can be read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte that is read is converted to type &lt;code&gt;char&lt;/code&gt; by zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is encountered, it is discarded and reading ceases. If the character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded and, if the following byte converts to the character &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is encountered, reading ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt; is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than &lt;code&gt;\u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.</source>
          <target state="translated">1 바이트라도 읽기 전에 파일 끝이 발견되면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 읽은 각 바이트는 0 확장에 의해 &lt;code&gt;char&lt;/code&gt; 유형으로 변환됩니다 . 문자 &lt;code&gt;'\n'&lt;/code&gt; 이 있으면 문자 가 삭제되고 읽기가 중단됩니다. 문자 &lt;code&gt;'\r'&lt;/code&gt; 이 발견 되면 해당 문자 는 버리고 다음 바이트가 문자 &lt;code&gt;'\n'&lt;/code&gt; 변환되면 파기됩니다. 그런 다음 독서가 중단됩니다. 문자 &lt;code&gt;'\n'&lt;/code&gt; 및 &lt;code&gt;'\r'&lt;/code&gt; 중 하나가 발견되기 전에 파일 끝 이 발견되면 읽기가 중단됩니다. 독서가 끝나면 &lt;code&gt;String&lt;/code&gt; 을 읽고 삭제하지 않은 모든 문자를 순서대로 가져 오는을 반환합니다. 이 문자열의 모든 문자는 &lt;code&gt;\u0100&lt;/code&gt; 보다 작은 값 , 즉 &lt;code&gt;(char)256&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3e73ecba896208f50db9710798b46a965a908cf" translate="yes" xml:space="preserve">
          <source>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</source>
          <target state="translated">corePoolSize 스레드보다 적은 수의 스레드가 실행중인 경우 실행자는 항상 큐 대신 새 스레드를 추가하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ca5a8548f3fbffd915bbf435ebb21f7a97c206bb" translate="yes" xml:space="preserve">
          <source>If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">URL의 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net, 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc3cf47c73dc6fc1a7d51257f1c70d39038a258" translate="yes" xml:space="preserve">
          <source>If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">처리기 프로토콜 (예 : HTTP 또는 JAR)의 경우 java.lang, java.io, java.util, java.net 패키지 중 하나 또는 해당 하위 패키지 중 하나에 속하는 공용 특수 URLConnection 서브 클래스가 있습니다. 리턴 된 연결은 해당 서브 클래스의 연결입니다. 예를 들어, HTTP의 경우 HttpURLConnection이 리턴되고 JAR의 경우 JarURLConnection이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a4abed1287821693f6da736875b1dd20090fd9c3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the the given socket addresses IP address and port number.</source>
          <target state="translated">&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; 가&lt;/a&gt; 제공된 경우 ,이 메소드 는, 지정된 소켓 주소 IP 주소 및 포트 번호로 &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="e516526c9c2357988df1234780c497763164fab1" translate="yes" xml:space="preserve">
          <source>If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt; is closed, and no further communications can be done.</source>
          <target state="translated">어떤 이유로 든 핸드 셰이 킹에 실패하면 &lt;code&gt;SSLSocket&lt;/code&gt; 이 닫히고 더 이상 통신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a00d8a2054c6cca37fdcf90a95f1f7f1ad5e5f0" translate="yes" xml:space="preserve">
          <source>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</source>
          <target state="translated">후크 또는 콜백 메소드에서 예외가 발생하면 내부 작업자 스레드가 실패하고 갑자기 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085d6508b165d7efeb827d901170784516d5c017" translate="yes" xml:space="preserve">
          <source>If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern.</source>
          <target state="translated">수평선이 &lt;code&gt;0&lt;/code&gt; 이면 horizon이 무시되고이 메소드는 입력을 통해 계속해서 지정된 패턴을 경계없이 찾습니다. 이 경우 패턴을 검색하는 모든 입력을 버퍼링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e185e59957de1a2d9502a435e3bf5d9b3e15599e" translate="yes" xml:space="preserve">
          <source>If horizon is negative, then an IllegalArgumentException is thrown.</source>
          <target state="translated">수평선이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c672e7792e737065f944dcb4cec0eb9d5372d1e1" translate="yes" xml:space="preserve">
          <source>If implementing JavaSound on a I3DL2-compliant device:</source>
          <target state="translated">I3DL2 호환 장치에서 JavaSound를 구현하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3fd0a906cb89e2de9c5076d850930cae34f103b9" translate="yes" xml:space="preserve">
          <source>If implementing an unusual calendar system that is not based on years, months and days, or where you want direct control, then the &lt;code&gt;ChronoPeriod&lt;/code&gt; interface must be directly implemented.</source>
          <target state="translated">연도, 월, 일을 기준으로하지 않거나 직접 제어 할 위치가 아닌 비정상적인 달력 시스템을 구현하는 경우 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인터페이스를 직접 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="07b0ad2086ad124aeb2593860505d4dc09bcafc2" translate="yes" xml:space="preserve">
          <source>If implicit and explicit opening and closing are mixed on the same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:</source>
          <target state="translated">암시 적 및 명시 적 개폐가 동일한 &lt;code&gt;MidiDevice&lt;/code&gt; 에서 혼합 된 경우 인스턴스에서 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b6c1ac0801d0f32085f65cf19851af72a8b38e1" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="41f0c20f43c3bf64e0efed44e2fb775806ea99b7" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 예약 용도로 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6392fbf3bc8eb96daeacf7450eb84b4b39a684c9" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면 현재 스레드가 스레드 스케줄링 목적으로 사용 불가능하게되고 다른 스레드 가이 세마포어 에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 호출 할 때까지 휴면 상태 가됩니다. .</target>
        </trans-unit>
        <trans-unit id="2f81c133b1f0b74c30d4d20073c4db1886f54e67" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt; and the number of available permits is unchanged.</source>
          <target state="translated">사용 가능한 권한이 충분하지 않으면이 방법은 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 반환되며 사용 가능한 허용 수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ee886087a23f0ef283d53172b5a86b2108daa86" translate="yes" xml:space="preserve">
          <source>If interrupted while blocked in step 4, throw InterruptedException.</source>
          <target state="translated">4 단계에서 차단 된 동안 인터럽트 된 경우 InterruptedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8d2bc19f50633c8c0c8e271655bc0f3233284658" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹에서 모든 활성 하위 그룹을 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc469862baa4b5e3d18bc2ca8c5358c4773f7d5f" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in the current thread's thread group and its subgroups, the invoker should verify that the returned int value is strictly less than the length of &lt;code&gt;tarray&lt;/code&gt;.</source>
          <target state="translated">현재 스레드의 스레드 그룹 및 해당 하위 그룹에있는 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;tarray&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22683bf338326eeebb95e34c255b900a9e0a2f93" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">이 스레드 그룹의 모든 활성 스레드를 확보해야하는 경우 호출자는 리턴 된 int 값이 &lt;code&gt;list&lt;/code&gt; 길이보다 엄격하게 작은 지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a140e583fff0cfc9d06bbb68afa76210088042" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt; 로 설정 되면 패커는 요소를 재정렬하고 JAR 디렉토리 항목을 제거하여 Java 애플리케이션에 유용한 정보를 제공하지 않습니다. 일반적으로 압축률이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="349c3ce48f2850808153616db77878ba7dc35133" translate="yes" xml:space="preserve">
          <source>If iterables and sets containing &lt;code&gt;null&lt;/code&gt; are passed as arguments to methods in this class, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이 포함 된 iterables 및 세트 가이 클래스의 메소드에 인수로 전달되면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f90529506d3a0958fad7a3ecbf1c1171a153e5b" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform and that are in the usual extension directories (installed extensions) are loaded.</source>
          <target state="translated">loader가 &lt;code&gt;null&lt;/code&gt; 인 경우 플랫폼과 함께 번들로 제공되고 일반적인 확장 디렉토리 (설치된 확장)에있는 스크립트 엔진 팩토리가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ee069a1e9967d9348b8218cc73e384bb53741058" translate="yes" xml:space="preserve">
          <source>If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.</source>
          <target state="translated">많은 수의 항목을 &lt;code&gt;Hashtable&lt;/code&gt; 로 만들려면 충분히 큰 용량으로 입력하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 더 효율적으로 항목을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc60d765a093b43a6239eb2d5685c05051e44ee" translate="yes" xml:space="preserve">
          <source>If many mappings are to be stored in a &lt;code&gt;HashMap&lt;/code&gt; instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">많은 매핑을 &lt;code&gt;HashMap&lt;/code&gt; 인스턴스에 저장해야하는 경우 충분한 대용량으로 매핑하면 테이블을 확장하는 데 필요한 자동 재해시를 수행하는 것보다 매핑을보다 효율적으로 저장할 수 있습니다. 동일한 &lt;code&gt;hashCode()&lt;/code&gt; 와 함께 많은 키를 사용 하면 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403efbf3d99b9a55860af122e7ea1fa369ccd1ea" translate="yes" xml:space="preserve">
          <source>If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.</source>
          <target state="translated">패턴 문자열에 필요한 것보다 많은 형식이 제공되면 나머지 형식은 무시됩니다. 필요한 것보다 적은 형식이 제공되면 첫 번째 &lt;code&gt;newFormats.length&lt;/code&gt; 형식 만 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="d6b342590893d7d01546097e9b3ca381aee04072" translate="yes" xml:space="preserve">
          <source>If multiple language tags match as a result of the subtag &lt;code&gt;'*'&lt;/code&gt; included in a language range, the first matching language tag returned by an &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; of language tags is treated as the best matching one.</source>
          <target state="translated">여러 언어 태그가 서브 태그의 결과로 일치하면 &lt;code&gt;'*'&lt;/code&gt; 언어의 범위에 포함 된 첫 번째 일치하는 언어 태그는에 의해 반환 된 &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 이상 &lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 최고 매칭 하나로 처리 언어 태그의.</target>
        </trans-unit>
        <trans-unit id="5fbfbdd8794986ee056ce3b4b224daa409c09c76" translate="yes" xml:space="preserve">
          <source>If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;lib/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">이 특성 중 어느 것도 정의되지 않으면 LogManager는 기본 구성을 사용합니다. 기본 구성은 일반적으로 Java 설치 디렉토리의 &quot; &lt;code&gt;lib/logging.properties&lt;/code&gt; &quot; 특성 파일에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3ae7424666e0772e32faa1585ee99d03123f286" translate="yes" xml:space="preserve">
          <source>If no &quot;%g&quot; field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.</source>
          <target state="translated">&quot;% g&quot;필드가 지정되지 않고 파일 수가 1보다 큰 경우 생성 번호는 생성 된 파일 이름 끝에 점 뒤에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c49e64ec417bf53b53b9cae02beab8814230bf7f" translate="yes" xml:space="preserve">
          <source>If no 'getMethod' field is defined then the default value of the attribute is returned. If the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드가 정의되어 있지 않으면 속성의 기본값이 리턴됩니다. 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf903b34c15e4e7c1e0d072f0b913417b22851de" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;floatdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25494f57433f4174256b8e508bd8d48cd34d752d" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">&lt;a name=&quot;intdFlags&quot;&gt;플래그&lt;/a&gt; 가 제공 되지 않으면 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48c606520866ed3b5c7ab60dadf8ce7019bfde30" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the value of the system property:</source>
          <target state="translated">어떤 경우 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 를가 아직 설정되어 있지 않은 공장의 경우, 또는 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 의 메소드가 리턴은 &lt;code&gt;null&lt;/code&gt; , 다음 생성자는 시스템 프로퍼티의 값을 찾습니다</target>
        </trans-unit>
        <trans-unit id="e563df7258f13a8f225773d813627e3543639a63" translate="yes" xml:space="preserve">
          <source>If no Configuration object has been installed in the runtime, a call to &lt;code&gt;getConfiguration&lt;/code&gt; installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class). The default Configuration implementation can be changed by setting the value of the &lt;code&gt;login.configuration.provider&lt;/code&gt; security property to the fully qualified name of the desired Configuration subclass implementation.</source>
          <target state="translated">런타임에 Configuration 객체가 설치되지 않은 경우 &lt;code&gt;getConfiguration&lt;/code&gt; 을 호출 하면 기본 Configuration 구현 (이 추상 클래스의 기본 서브 클래스 구현)의 인스턴스가 설치됩니다. &lt;code&gt;login.configuration.provider&lt;/code&gt; 보안 특성 값을 원하는 구성 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 구성 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f28da2d05be1c33c6f8a1b624ec1c4eb508ea0e9" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation.</source>
          <target state="translated">런타임에 Policy 객체가 설치되어 있지 않은 경우, &lt;code&gt;getPolicy&lt;/code&gt; 를 호출 하면 기본 Policy 구현의 인스턴스 (이 추상 클래스의 기본 서브 클래스 구현)가 설치됩니다. &lt;code&gt;policy.provider&lt;/code&gt; 보안 특성 의 값을 원하는 Policy 서브 클래스 구현의 완전한 이름 으로 설정하여 기본 Policy 구현을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8103a3ac14929d0ea6f76a89ffe79e5d895f4e5" translate="yes" xml:space="preserve">
          <source>If no access is allowed, the suffix is &quot;/noaccess&quot;.</source>
          <target state="translated">액세스가 허용되지 않으면 접미 부는 &quot;/ noaccess&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="51d8e33d13184ce0c057a13cfc7fd7024a488d5d" translate="yes" xml:space="preserve">
          <source>If no array is specified on the constructor, but tiling is allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">생성자에 배열이 지정되지 않았지만 타일링이 허용되는 경우이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8225a781e6aeb21876e42212e39dd339fac75791" translate="yes" xml:space="preserve">
          <source>If no attribute with this name is found, this method has no effect.</source>
          <target state="translated">이 이름을 가진 속성이 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f57aed5ec85446dac8b881e2e9691de38db155c7" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 호출로 일정 관리 유형이 명시 적으로 제공되지 않으면 &lt;code&gt;Locale&lt;/code&gt; 값을 사용하여 빌드 할 &lt;code&gt;Calendar&lt;/code&gt; 유형을 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="635db19022015f7488d5435599c4fb48937a985a" translate="yes" xml:space="preserve">
          <source>If no class can be found in this way, this method will use an implementation-specific way to locate an implementation. If none is found, a NamingException is thrown.</source>
          <target state="translated">이런 방식으로 클래스를 찾을 수 없으면이 메소드는 구현 별 방법을 사용하여 구현을 찾습니다. 아무것도 발견되지 않으면 NamingException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ca30507c3453e7a86b86ecc80fdbdb06caf5ff95" translate="yes" xml:space="preserve">
          <source>If no compiler is available, these methods do nothing.</source>
          <target state="translated">사용 가능한 컴파일러가없는 경우이 메소드는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243bf1d6846d6372968ae561b146475eecd8f1fd" translate="yes" xml:space="preserve">
          <source>If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places. By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property. The class name must be of the form:</source>
          <target state="translated">컨텐츠 핸들러를 찾을 수없는 경우 URLConnection은 사용자가 정의 할 수있는 장소 세트에서 컨텐츠 핸들러를 찾습니다. 기본적으로 sun.net.www.content에 있지만 사용자는 java.content.handler.pkgs 등록 정보를 정의하여 검색 할 세로 막대로 구분 된 클래스 접두사 세트를 정의 할 수 있습니다. 클래스 이름은 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="521ced0b1e8fb5511e3ff3521639bbd2e1d892dd" translate="yes" xml:space="preserve">
          <source>If no content handler factory has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:</source>
          <target state="translated">컨텐츠 핸들러 팩토리가 아직 설정되지 않았거나 팩토리의 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴 하면 애플리케이션은 다음과 같은 이름의 클래스를로드합니다.</target>
        </trans-unit>
        <trans-unit id="8116296a26510935b6c10d95ea6e65ff6f455a64" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2514c39dc0080097bab43387d9c7ddb3546f473f" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 설명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;null&lt;/code&gt; 에서 반환 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; ,이 방법은 반환해야 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14c96365230fe95d4c170b5d326eb6ff39f4595" translate="yes" xml:space="preserve">
          <source>If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a &lt;code&gt;Calendar&lt;/code&gt;. For example, if the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the &lt;a href=&quot;calendar#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied. Therefore, the order of field setting matters.</source>
          <target state="translated">날짜 및 / 또는 시간을 결정하기위한 충분한 필드 매개 변수가 제공되지 않으면 &lt;code&gt;Calendar&lt;/code&gt; 를 작성할 때 달력 특정 기본값이 사용됩니다 . 예를 들어, Gregorian 달력에 &lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt; 값을 지정하지 않으면 1970이 사용됩니다. 필드 매개 변수간에 충돌이 있으면 &lt;a href=&quot;calendar#resolution&quot;&gt;해결 규칙&lt;/a&gt; 이 적용됩니다. 따라서 필드 설정 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3c3b8e9ce2ba433f5bd56b760aee79cd23850c9f" translate="yes" xml:space="preserve">
          <source>If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</source>
          <target state="translated">위의 1 단계에서 필드를 찾지 못하면이 알고리즘은 C의 각 직접 슈퍼 인터페이스에 재귀 적으로 적용됩니다. 직접 슈퍼 인터페이스는 선언 된 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3a478bf1473f7f2d59cb1ae1a418bd4cb78d9c7e" translate="yes" xml:space="preserve">
          <source>If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a &lt;code&gt;NoSuchFieldException&lt;/code&gt; is thrown.</source>
          <target state="translated">위의 1, 2 단계에서 필드를 찾을 수없고 C에 수퍼 클래스 S가 있으면이 알고리즘은 S에 대해 재귀 적으로 호출됩니다. C에 수퍼 클래스가 없으면 &lt;code&gt;NoSuchFieldException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85d8b2f1396493ecd88a1cad4f6f3c76ce079715" translate="yes" xml:space="preserve">
          <source>If no localization information is available, the non-localized name is returned.</source>
          <target state="translated">현지화 정보가 없으면 현지화되지 않은 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fd3bbeb9c5dbaa32c21b11f1b89bc4bd8ecdd6" translate="yes" xml:space="preserve">
          <source>If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method parameter or return value in an MXBean interface.</source>
          <target state="translated">맵핑 규칙을 도출하도록 없으면 &lt;em&gt;오픈 (J)&lt;/em&gt; 에서 &lt;em&gt;J&lt;/em&gt; 후 &lt;em&gt;J는&lt;/em&gt; MXBean의 인터페이스 메소드 파라미터 나 리턴 값의 타입이 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="b5ddd6654d9c602c5f7f5aebb431141368be7c43" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, mark의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bebf4b9fd62e0e0e062741afac69f1752343555c" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of the mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">마크가 설정되어 있지 않은 경우, 마크의 값은 생성자에게 건네지는 오프셋 (또는 오프셋이 제공되어 있지 않은 경우는 0)입니다.</target>
        </trans-unit>
        <trans-unit id="04e67c9a77bba1f9d49ec8d97898bd5df73e6e1e" translate="yes" xml:space="preserve">
          <source>If no matching method is found by step 1 then:</source>
          <target state="translated">1 단계에서 일치하는 방법을 찾지 못하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bd216b7387fe2dee5dd00b4fdaab3ce4feee3b7f" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않은 경우, 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하며 다음 세 가지 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f82da2a19e504b2d12c547c6cd21c732ba85238d" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 교환을 기다리고 있지 않으면 스레드 예약을 위해 현재 스레드가 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c99a978e37655f05ece5d09a50cf601a4c0974" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="05c5dee407f95ed89e404e9d431ede44a984e5d6" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">사용 가능한 허가가없는 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c61688e7523da669464298c2f1d9cfc1f08b7" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">사용 가능한 허가가없는 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다른 스레드 가이 세마포어에 대한 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하고 현재 스레드에 허가가 할당 될 때까지 휴면 상태 가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd133845b033ac7223fae8a2a495d3b108c36d1d" translate="yes" xml:space="preserve">
          <source>If no permit is available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 허가가없는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="91b1ae1535d1f33ae0e732627166d15b6a2cc1cc" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70dda654250368e808b6b425e672a82e81efe712" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">공급자 패키지 목록이없는 기본 사례를 포함하여 위의 단계에서 공급자를 찾지 못하면 구현시 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 에 자체 공급자를 사용 하거나 없는 경우 &lt;code&gt;MalformedURLException&lt;/code&gt; 을 발생시킵니다. 구현은 다른 방법으로 공급자를 찾도록 선택할 수 있습니다. 예를 들어, 서비스 인터페이스가 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 인&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;서비스 제공자에 대한 JAR 규칙을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f99c7ebdd694b15a7a1884c5882e8188c69e3f" translate="yes" xml:space="preserve">
          <source>If no such value of</source>
          <target state="translated">그러한 가치가 없다면</target>
        </trans-unit>
        <trans-unit id="8098cc1dcdc7eef18c37176303f3d539ee64942f" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="172481aa19fb2665297fe8e01e1a105abb6a4821" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;era#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="36c6de59e58640f47a0ec5a526b903e6cdb5056b" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26dec5e0aab4853771305a15bb1f061f803aacdf" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;zoneid#getId--&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">텍스트 매핑이 없으면 &lt;a href=&quot;zoneid#getId--&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2720f481dd9e3309673a042872b8da0c6951d663" translate="yes" xml:space="preserve">
          <source>If no update listeners are present, the reader may choose to perform fewer updates to the pixels of the destination images and/or thumbnails, which may result in more efficient decoding.</source>
          <target state="translated">업데이트 리스너가 존재하지 않으면, 리더기는 목적지 이미지 및 / 또는 썸네일의 픽셀에 대해 더 적은 업데이트를 수행하도록 선택할 수 있으며, 이는 더 효율적인 디코딩을 초래할 수있다.</target>
        </trans-unit>
        <trans-unit id="a2e2d9f63d3b68d988634ea3a7fd560c86f5e146" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 주 정의 매개 변수를 명시 적으로 지정하지 않으면 &lt;code&gt;Locale&lt;/code&gt; 의 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4076d96bb4d80dea21dec4f9083af903b3282c51" translate="yes" xml:space="preserve">
          <source>If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</source>
          <target state="translated">위의 어느 것도 해당하지 않는 경우, &lt;code&gt;implies&lt;/code&gt; 를 반환 거짓을.</target>
        </trans-unit>
        <trans-unit id="65b4b808e5f83fdac6e6f8fa54fe10637573639b" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">위의 어느 경우에도 해당되지 않는 경우 전체 액세스 (공용, 패키지, 개인 및 보호)가 허용되는 경우입니다. 이 경우 접미사가 추가되지 않습니다. 이것은 원래 &lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt; 에서 얻은 객체에만 해당됩니다 . &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; 으로&lt;/a&gt; 만든 개체는 항상 액세스가 제한되며 접미사를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9afb92f74699e092dd43aa6f4a4f20ab8baaf008" translate="yes" xml:space="preserve">
          <source>If none of the package prefixes work, null is returned.</source>
          <target state="translated">작동하는 패키지 접두사가 없으면 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa3a39e0c5471c8e92b9112af6f11814ae21d0e" translate="yes" xml:space="preserve">
          <source>If none of the previous conditions hold then this thread's interrupt status will be set.</source>
          <target state="translated">이전 조건 중 어느 것도 유지되지 않으면이 스레드의 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="346f69aa8643809549df322ad150080572449fc7" translate="yes" xml:space="preserve">
          <source>If none of these conditions is met, the MBean is invalid and the attempt to register it will generate &lt;a href=&quot;notcompliantmbeanexception&quot;&gt;&lt;code&gt;NotCompliantMBeanException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 조건 중 어느 것도 충족되지 않으면 MBean이 유효하지 않으며 등록을 시도하면 &lt;a href=&quot;notcompliantmbeanexception&quot;&gt; &lt;code&gt;NotCompliantMBeanException&lt;/code&gt; &lt;/a&gt; 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c5743411e869e01038b5d76b71612dce8dfd329" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드의 호출로 지정된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="716a361131a6632fa2e7d2e54111159994780e51" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a &lt;a href=&quot;completionexception&quot;&gt;&lt;code&gt;CompletionException&lt;/code&gt;&lt;/a&gt; caused by this &lt;code&gt;CancellationException&lt;/code&gt;.</source>
          <target state="translated">아직 완료하지 않은 경우,이 CompletableFuture를 &lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt; 과 함께 완료하십시오 . 아직 완료되지 않은 종속 CompletableFuture는 이 &lt;code&gt;CancellationException&lt;/code&gt; 으로 인한 &lt;a href=&quot;completionexception&quot;&gt; &lt;code&gt;CompletionException&lt;/code&gt; &lt;/a&gt; 과 함께 예외적으로 완료 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f1a9e000d1c1d155d951430a94c358745c05ace" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">아직 완료되지 않은 경우 &lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드가 리턴 한 값을 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="06df59153329c54021d8f318749947771342b429" translate="yes" xml:space="preserve">
          <source>If not running in a ForkJoinPool, this method is behaviorally equivalent to</source>
          <target state="translated">ForkJoinPool에서 실행되지 않는 경우이 방법은 동작과 동일합니다</target>
        </trans-unit>
        <trans-unit id="4963d6f03243f1b1eefc52d1ee78e3de46655e5a" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompositeName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompositeName 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cfed25f27277239376cbbd5795fd1f2017c24525" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompoundName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 CompoundName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1c9d5558d685db1a02cae49432f75e2eb93c619" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of LdapName, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 LdapName의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bf13cf38688995f01fe92d7c8213b9203d51d95" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, ClassCastException is thrown.</source>
          <target state="translated">obj가 null이거나 Rdn의 인스턴스가 아닌 경우 ClassCastException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b1bd38492a7c5fc97a66ea1dc538a1fb693b2c3" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, false is returned.</source>
          <target state="translated">obj가 null이거나 Rdn 인스턴스가 아닌 경우 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc0bc4fab7d5c4262f47e32108a9c0ec0a06d6f" translate="yes" xml:space="preserve">
          <source>If one is not found, it searches the set of &lt;code&gt;ScriptEngineFactory&lt;/code&gt; instances stored by the constructor for one with the specified name. If a &lt;code&gt;ScriptEngineFactory&lt;/code&gt; is found by either method, it is used to create instance of &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">하나를 찾지 못하면 생성자가 저장 한 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 인스턴스 세트 에서 지정된 이름을 가진 인스턴스를 검색합니다 . 경우 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 에이 중 하나의 방법으로 발견,의 인스턴스를 생성하는 데 사용됩니다 &lt;code&gt;ScriptEngine&lt;/code&gt; 를 검색 .</target>
        </trans-unit>
        <trans-unit id="624173e017b005ddaae7fe37b2623ee7c893a0a0" translate="yes" xml:space="preserve">
          <source>If one of the arguments does not occur in the pattern.</source>
          <target state="translated">패턴에서 인수 중 하나가 발생하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="a2cb09ff6c56a4c92e19e76c548f38b158889e4b" translate="yes" xml:space="preserve">
          <source>If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components.</source>
          <target state="translated">하나 또는 두 개의 권한 구성 요소가 레지스트리 기반 인 경우 URI는 해당 권한 구성 요소의 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="2fb7857e904a130ed28ddd9eed419d0b930d6e9e" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 검색 할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 목록이 &lt;code&gt;attributes&lt;/code&gt; 배열 과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하려면 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb46e59026371f237c846d747b96cfab81aa6f7" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">어떤 이유로 하나 이상의 속성을 설정할 수 없으면 반환 된 &lt;code&gt;AttributeList&lt;/code&gt; 에서 생략됩니다 . 호출자는 입력 된 &lt;code&gt;AttributeList&lt;/code&gt; 가 출력되는 것과 동일한 크기인지 확인해야합니다 . 주어진 속성을 검색 할 수없는 문제점을 발견하기 위해 일반적으로 해당 속성에 대해 &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 는 있지만 작동하지 않을 수도 있습니다. 예를 들어, 두 속성의 값이 서로 일치하지 않아 거부되었을 수 있습니다. 둘 중 하나만 설정하는 것이 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea5108f8ecd0c55ef6981d1ca12427bdd2d199c" translate="yes" xml:space="preserve">
          <source>If one value is a primitive array then the other must be a primitive array of the same type with the same elements.</source>
          <target state="translated">하나의 값이 기본 배열 인 경우 다른 값은 동일한 요소를 가진 동일한 유형의 기본 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="83b598a4bb6d8d15d44e8e6f9778b65445620655" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">한 값이 객체 배열이면 다른 값도 있어야하고 &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca221d63216bb033111f2713610351d2376eca45" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">하나의 값이 객체 배열이면 다른 값도 같아야하며 &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt; 는 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8317f7140fbe4d8e0a19dbbc989d6c95b4bba3de" translate="yes" xml:space="preserve">
          <source>If one value is null then the other must be too.</source>
          <target state="translated">하나의 값이 null이면 다른 값도 null이어야합니다.</target>
        </trans-unit>
        <trans-unit id="46ccc3cea31a77de6874e4d69188651ef3350460" translate="yes" xml:space="preserve">
          <source>If only public access is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">공개 액세스 만 허용되는 경우 접미사는 &quot;/ public&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="17e35151d3a9c5e62004f06cdd120c3d5af02427" translate="yes" xml:space="preserve">
          <source>If only public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">공개 및 패키지 액세스 만 허용되는 경우 접미사는 &quot;/ package&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="78a5d707938565d1ab21a382651974405944eeaa" translate="yes" xml:space="preserve">
          <source>If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">공개, 패키지 및 개인 액세스 만 허용되는 경우 접미사는 &quot;/ private&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5ff5bcea26eb9f57c1f61e4d4b69139bd9e67391" translate="yes" xml:space="preserve">
          <source>If passed to the appropriate variant of java.beans.Beans.instantiate this method will be called in order to associate the newly instantiated Applet (JavaBean) with its AppletContext, AppletStub, and Container.</source>
          <target state="translated">적절한 java.beans.Beans.instantiate 변형에 전달되면 새로 인스턴스화 된 애플릿 (JavaBean)을 AppletContext, AppletStub 및 Container와 연관시키기 위해이 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63592e8ff0ed49f336b285894d4830d793307f4a" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; subsequent start requests are not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 시작 요청은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9cbc94cbe4e5c51dea79fe6a36851f807b7c43f" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; the behavior of subsequent loop and start requests is not affected by an interrupted loop operation.</source>
          <target state="translated">루핑 중에 재생이 중지되면 현재 루프 상태가 지워집니다. 후속 루프 및 시작 요청의 동작은 인터럽트 된 루프 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49bbc2bd93bc284a0af94a66587e35a5d285e02f" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means ignore the case when comparing name components. If its value is not &quot;true&quot;, or if the property is not present, case is considered when comparing name components.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 이름 구성 요소를 비교할 때 대소 문자를 무시 함을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 이름 구성 요소를 비교할 때 대 / 소문자가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="76f581deb106b2ac36d486ca5972b20b2708e882" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means trim any leading and trailing whitespaces in a name component for comparison purposes. If its value is not &quot;true&quot;, or if the property is not present, blanks are significant.</source>
          <target state="translated">있는 경우 &quot;true&quot;는 비교 목적으로 이름 구성 요소에서 선행 및 후행 공백을 제거하는 것을 의미합니다. 값이 &quot;true&quot;가 아니거나 속성이 없으면 공백이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f71c029405d6c4413ebcbb2a962ddc2c412a1ce0" translate="yes" xml:space="preserve">
          <source>If present, specifies the escape string for overriding separator, escapes and quotes.</source>
          <target state="translated">존재하는 경우 구분 기호, 이스케이프 및 따옴표를 재정의하는 이스케이프 문자열을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b3051402e5a243fd5b4ebf35b610a599bf72fd9d" translate="yes" xml:space="preserve">
          <source>If present, specifies the string delimiting start of a quoted string.</source>
          <target state="translated">있는 경우 인용 문자열의 문자열 구분 시작을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ac3c844cdeac2520127d85d40f83a50ed68f9c88" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs. (e.g. &quot;,&quot; in age=65,gender=male).</source>
          <target state="translated">있는 경우 여러 속성 / 값 쌍을 지정할 때 속성-값-어설 션을 구분하는 문자열을 지정합니다. (예 : 연령 = 65, 성별 = 남성에서 &quot;,&quot;).</target>
        </trans-unit>
        <trans-unit id="839f44a4939d27c69ac39a75a7ee01b1f1bbc830" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separators attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">존재하는 경우 속성을 값과 구분하는 문자열을 지정합니다 (예 : &quot;age = 65&quot;의 &quot;=&quot;).</target>
        </trans-unit>
        <trans-unit id="a8b99e1ebf742f5bd861cd2fd56fba8c921820bf" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling Doc's &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">클라이언트에서 스트림으로 인쇄 데이터를 얻는 경우 Doc의 &lt;code&gt;getReaderForText()&lt;/code&gt; 또는 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 를 호출하여인쇄 데이터 소스가 이미 InputStream 또는 Reader이기 때문에 인쇄 서비스는 모든 작업 완료 조건에서 클라이언트에 대해 항상 이러한 스트림을 닫아야합니다. 다음과 같은 경고가 있습니다. 인쇄 데이터 자체가 스트림 인 경우 서비스는 항상 데이터를 닫습니다. 인쇄 데이터가 스트림으로 요청 될 수있는 것이면 서비스는 스트림을 종료하기 전에 스트림을 얻은 경우에만 스트림을 닫습니다. 즉, 인쇄 서비스가 데이터를 스트림으로 요청할 수 있다고해서 데이터를 닫기 위해 서비스에 의존하는 Doc 구현자가 서비스의 요청에 대한 응답으로 만 해당 스트림을 작성해야 함을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="698e747d05614178dfac851043daa01f20a613ea" translate="yes" xml:space="preserve">
          <source>If readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown.</source>
          <target state="translated">역 참조를 직렬화 해제하기 위해 readUnshared를 호출하면 (이전에 스트림에 기록 된 객체의 스트림 표현) ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4f57444325034269269b979e9040fba82af28a1" translate="yes" xml:space="preserve">
          <source>If readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown.</source>
          <target state="translated">readUnshared가 성공적으로 리턴되면, readUnshared에 의해 역 직렬화 된 스트림 핸들에 대한 역 참조를 역 직렬화하려고 시도하면 ObjectStreamException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa301e6f70a966a031213bd64c45f05d89ac7164" translate="yes" xml:space="preserve">
          <source>If resolution should be possible, but the data is invalid, the resolver style should be used to determine an appropriate level of leniency, which may require throwing a &lt;code&gt;DateTimeException&lt;/code&gt; or &lt;code&gt;ArithmeticException&lt;/code&gt;. If no resolution is possible, the resolve method must return null.</source>
          <target state="translated">확인이 가능하지만 데이터가 유효하지 않은 경우, 리졸버 스타일을 사용하여 적절한 수준의 신뢰도를 결정해야합니다 . &lt;code&gt;DateTimeException&lt;/code&gt; 또는 &lt;code&gt;ArithmeticException&lt;/code&gt; 이 발생해야 할 수도 있습니다 . 해결 방법이 없으면 resolve 메서드는 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3812495ff2c8cc9bdfa1044d03962dc8bf6711c5" translate="yes" xml:space="preserve">
          <source>If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to &lt;code&gt;blocker.block()&lt;/code&gt;.</source>
          <target state="translated">ForkJoinPool에서 실행중인 경우 &lt;code&gt;blocker.block()&lt;/code&gt; 호출하는 동안 사용 가능한 병렬 처리를 보장하기 위해 풀을 먼저 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae78817156ff952aba10e581c466f3b983c1decc" translate="yes" xml:space="preserve">
          <source>If script or extensions are present and variant is missing, no underscore is added before the &quot;#&quot;.</source>
          <target state="translated">스크립트 또는 확장자가 존재하고 변형이 누락 된 경우 &quot;#&quot;앞에 밑줄이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aca1859a49861db1474a56d8e3d2f23a51a9b08b" translate="yes" xml:space="preserve">
          <source>If set, the creation time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 생성 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="254aa9b5d6babc55c52a29bf015e860182b09607" translate="yes" xml:space="preserve">
          <source>If set, the data will be written out in a top-down manner, the first scanline being written first.</source>
          <target state="translated">설정된 경우 데이터는 하향식으로 기록되며 첫 번째 스캔 라인이 먼저 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d3fe3fca46a00d556efb3e52ff334ccc25f6d2f2" translate="yes" xml:space="preserve">
          <source>If set, the last access time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">설정된 경우, 마지막 액세스 시간은 ZIP 파일 또는 ZIP 파일 형식의 스트림으로 출력 될 때 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 의 확장 된 타임 스탬프 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f308d30cc56ad52b3bab469509470a688175d5d" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one &lt;code&gt;CallSite&lt;/code&gt; object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.</source>
          <target state="translated">여러 스레드가 단일 동적 호출 사이트에 대해 부트 스트랩 메소드를 동시에 실행하는 경우 JVM은 하나의 &lt;code&gt;CallSite&lt;/code&gt; 오브젝트를 선택 하여 모든 스레드에 시각적으로 설치해야합니다. 다른 부트 스트랩 메소드 호출은 완료 할 수 있지만 결과는 무시되고 동적 호출 사이트 호출은 원래 선택된 대상 오브젝트로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="3080743f4d15c8fc1f75465fc6801e428e44fe7c" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of PropertyChangeListeners and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환되는 배열은 PropertyChangeListeners와 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행 한 후 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cf497c1785865189fe796ed0e1d220915d011be" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of VetoableChangeListeners and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">명명 된 속성으로 일부 리스너가 추가 된 경우 반환 된 배열은 VetoableChangeListeners와 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 의 혼합입니다 . 호출 메소드가 리스너를 구별하는 데 관심이있는 경우 각 요소를 테스트하여 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 인지 확인 하고 캐스트를 수행하고 매개 변수를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="36119d6ef751d0ba1a40bc06d8c08c0232acb626" translate="yes" xml:space="preserve">
          <source>If still no result bundle is found, the base name alone is looked up. If this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</source>
          <target state="translated">여전히 결과 번들이 없으면 기본 이름 만 찾습니다. 여전히 실패하면 &lt;code&gt;MissingResourceException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49c2d956b15c160db2755278d76b95411d1638e9" translate="yes" xml:space="preserve">
          <source>If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.</source>
          <target state="translated">이러한 서비스가 컨텍스트 또는 중첩 컨텍스트 중 하나에 등록 된 경우 컨텍스트가 컨텍스트에 위임되어 서비스 요청을 충족시키는 경우 서비스와 연관된 BeanContextServiceProvider는 해당 서비스의 인스턴스를 제공하도록 요청됩니다. .</target>
        </trans-unit>
        <trans-unit id="94b0570a3ef5bacc1df2844b6f6f55155f5164cd" translate="yes" xml:space="preserve">
          <source>If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by any bytes that otherwise would have been the next input data as of the time of the call to &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;IOException&lt;/code&gt; 이 발생하지 않으면, 스트림은 가장 최근의 &lt;code&gt;mark&lt;/code&gt; 호출 이후 (또는 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않은 경우 파일의 시작 이후) 읽은 모든 바이트 가 후속으로 재 공급되도록 상태로 재설정됩니다. &lt;code&gt;read&lt;/code&gt; 메소드의 호출자 다음에, &lt;code&gt;reset&lt;/code&gt; 호출의 시점에서 다음의 입력 데이터가 된 바이트가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba67a915702ddd93a2439399e9e5620bf22a0c62" translate="yes" xml:space="preserve">
          <source>If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed.</source>
          <target state="translated">이러한 오류가 발생하면 이후 반복자를 호출하면 사용 가능한 다음 제공자를 찾고 인스턴스화하기 위해 최선을 다하지만 일반적으로 이러한 복구를 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="483297556e0d86a729fc879bc3d6a3a654a16eca" translate="yes" xml:space="preserve">
          <source>If system exclusive data from &lt;code&gt;SysexMessages&lt;/code&gt; objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a &lt;code&gt;SysexMessage&lt;/code&gt; contains continuing system exclusive data should not be propagated via MIDI wire protocol.</source>
          <target state="translated">&lt;code&gt;SysexMessages&lt;/code&gt; 객체의 시스템 독점 데이터가 MIDI 유선 프로토콜을 사용하여 전송되는 경우 초기 0xF0 상태 바이트, 시스템 독점 데이터 자체 및 최종 0xF7 (EOX) 바이트 만 전파되어야합니다. &lt;code&gt;SysexMessage&lt;/code&gt; 에 지속적인 시스템 독점 데이터가 포함되어 있음을 나타내는 데 사용되는 0xF7 상태 바이트는 MIDI 와이어 프로토콜을 통해 전파되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8a60148766d9542dcdda7613f880094d44b2ef2c" translate="yes" xml:space="preserve">
          <source>If system properties &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined or they are defined in the file &quot;sound.properties&quot;, they are used to retrieve default lines. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If the respective property is not set, or the mixer requested in the property is not installed or does not provide the requested line, all installed mixers are queried for the requested line type. A Line will be returned from the first mixer providing the requested line type.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt; , &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 및 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 줄을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 해당 속성이 설정되지 않았거나 속성에서 요청 된 믹서가 설치되지 않았거나 요청 된 라인을 제공하지 않으면 설치된 모든 믹서가 요청 된 라인 유형에 대해 쿼리됩니다. 요청 된 라인 유형을 제공하는 첫 번째 믹서에서 라인이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1f583398dc1f86dc2870e17e17525bfe7bcb7fe2" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">&quot;java.util.logging.config.class&quot;특성이 설정되면 특성 값이 클래스 이름으로 처리됩니다. 지정된 클래스가로드되고 객체가 인스턴스화되며 해당 객체의 생성자가 초기 구성을 읽습니다. 이 객체는 다른 시스템 속성을 사용하여 구성을 제어 할 수 있습니다. 대체 구성 클래스는 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 을 사용하여 LogManager에서 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d3e35bcf72871950c117a29249ba322eaf7916a" translate="yes" xml:space="preserve">
          <source>If the 'getMethod' field contains the name of a valid operation descriptor, then the method described by the operation descriptor is executed. The response from the method is returned as the value of the attribute. If the operation fails or the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">'getMethod'필드에 유효한 작업 설명 자의 이름이 포함되어 있으면 작업 설명자가 설명하는 방법이 실행됩니다. 메소드의 응답은 속성 값으로 리턴됩니다. 작업이 실패하거나 반환 된 값이 선언 된 속성 유형과 호환되지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cf976d251facbb1b28639a31b11358b94746e84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; for this type has a &lt;a href=&quot;beandescriptor&quot;&gt;&lt;code&gt;BeanDescriptor&lt;/code&gt;&lt;/a&gt; which defined a &quot;persistenceDelegate&quot; attribute, the value of this named attribute is returned.</source>
          <target state="translated">이 유형 의 &lt;a href=&quot;beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt; 에 &quot;persistenceDelegate&quot;속성을 정의한 &lt;a href=&quot;beandescriptor&quot;&gt; &lt;code&gt;BeanDescriptor&lt;/code&gt; &lt;/a&gt; 가 있으면 이 이름 지정된 속성의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f7796e655e99564bb42833b6c22ae781567c8b7e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">는 IF &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어있는 &lt;code&gt;true&lt;/code&gt; ,이 방법으로 재 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69cea4d19b20fb91d97db82c5ca57aaf842e28d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">IF로 &lt;a name=&quot;floatDPrec&quot;&gt;변환&lt;/a&gt; 인 &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'f'&lt;/code&gt; , 그 정밀도의 소수점 이하의 자리수이다. 정밀도가 지정되지 않으면 &lt;code&gt;6&lt;/code&gt; 으로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="244d88b2fe1f7cc3d006bcc6bed47c61fe2ec794" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;zh&quot;&lt;/code&gt;-to-&lt;code&gt;&quot;zh&quot;&lt;/code&gt; mapping isn't included in the map, a simple replacement will be performed and the customized list won't include &lt;code&gt;&quot;zh&quot;&lt;/code&gt; and &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&quot;zh&quot;&lt;/code&gt; Di의 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 매핑이 맵에 포함되지 않은 단순 교체가 수행되고 사용자 정의 목록은 포함되지 않습니다 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f4d1d76d4c61640485815093054acc02ce819f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되어 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="1c680cd1a5cd595f752bed838baa38292f42bbcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt; , then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하고 인수가되지이다 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 가&lt;/a&gt; , 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3ca6b4a24528a74561304ff78b46e45f7ce091" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="95f5e2ee606537dc80cd0c08600e71779319b292" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="705393d5e4190c15bb4ded3f92e669b7967af3af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with &lt;code&gt;'0'&lt;/code&gt; prefix.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 출력은 항상 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; 접두사.</target>
        </trans-unit>
        <trans-unit id="d94fd5d1c396bfff4fed3e4917313944fa0d8ce4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;&quot;0x&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af351499ffe1eb584449ad1db1312af2f6169806" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;'0'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되었을 경우, 출력은 항상 기수 지시자로 시작됩니다 &lt;code&gt;'0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e2b33eac4b29de7dc276798ef6bb121e0f191c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 다음 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="193a49527f28f69b767038d67c1984e036b12529" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then the decimal separator will always be present.</source>
          <target state="translated">경우] &lt;code&gt;'#'&lt;/code&gt; 플래그가 지정되고, 소수점이 항상 존재할 것이다.</target>
        </trans-unit>
        <trans-unit id="170d2f39d6b7a451069152ef956aa45571ac5f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;','&lt;/code&gt; flags are given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;'('&lt;/code&gt; 또는 &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="25f8f50b77134591d75e17a674bec028e9c6e997" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'+'&lt;/code&gt; flag is given and the value is positive or zero (or floating-point positive zero), then a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;) will be prepended.</source>
          <target state="translated">경우] &lt;code&gt;'+'&lt;/code&gt; 플래그가 지정하고, 값이 양수 또는 제로 (또는 부동 소수점 긍정적 영) 다음, &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;'\u002b'&lt;/code&gt; ) 붙을.</target>
        </trans-unit>
        <trans-unit id="910241aebecc3c9182f2e0462c8f58f123333d6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;','&lt;/code&gt; ( &lt;code&gt;'\u002c'&lt;/code&gt; ) &lt;a name=&quot;L10nGroup&quot;&gt;플래그는&lt;/a&gt; , 그 로케일 특정 주어진다 &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;세퍼레이터 그룹화&lt;/a&gt; 로케일에 의해 정의 된 간격으로 세퍼레이터를 적어도 상당한 최상위 자릿수의 문자열의 정수 부분을 스캐닝하고 삽입하여 삽입 &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;그룹핑 크기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9f549cf29b75acc2fdec3fc183e7f16568846" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정하는 &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="45726f7fab2e09c7f3869df2e50226749801e01e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given, then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;','&lt;/code&gt; 플래그가 지정되고있는 경우, &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; 가&lt;/a&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="970c69f921423c9cb9e926402bc01ce17c9690e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'-'&lt;/code&gt; flag is not given, then the space padding will occur before the sign.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 플래그가 지정되어 있지 않은 경우, 공간 패딩은 기호 앞에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4999add0ec4ab7e8f065de52e1702ab41f20c0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given and the value is negative, then the zero padding will occur after the sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되어 값이 부의되어, 다음 제로 패딩은 기호 다음에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c36904575776fe73769eda50759d8e13da3acc3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 부여되는 출력 기수 지시자 또는 기호 (존재하는 경우) 이후의 선두에 제로 필드 폭으로 패딩한다.</target>
        </trans-unit>
        <trans-unit id="b5e7f4a54ddb769b1293d2814dfdf865f8198b97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded with leading zeros to the field width following any indication of sign.</source>
          <target state="translated">경우 &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되는 출력 기호의 표시를 다음과 폭 필드에 0을 선도하는 패딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ba1bcf00b5c45bf451134d21adaed5e63f1fcd56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">경우] &lt;code&gt;'0'&lt;/code&gt; 플래그가 지정되고, 그 로케일 특정 &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;제로 숫자&lt;/a&gt; 기호 문자 뒤에 삽입되어있는 경우와되어 제 비제 자리 전에, 문자열의 길이가 요구 된 필드 폭과 동일 할 때까지.</target>
        </trans-unit>
        <trans-unit id="9ecc4eb34ec8dfb382771373ad86df4d2c178e13" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Collection&lt;/code&gt; will be modified by one thread while another thread is calling a method of a Collection &lt;code&gt;CertStore&lt;/code&gt; that has been initialized with this &lt;code&gt;Collection&lt;/code&gt;, the &lt;code&gt;Collection&lt;/code&gt; must have fail-fast iterators.</source>
          <target state="translated">는 IF &lt;code&gt;Collection&lt;/code&gt; 다른 스레드가 수집하는 방법 호출되는 동안 하나 개의 스레드에 의해 수정되는 &lt;code&gt;CertStore&lt;/code&gt; 에 이로 초기화 된 &lt;code&gt;Collection&lt;/code&gt; 의 &lt;code&gt;Collection&lt;/code&gt; 르파 반복자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="810e8374c563e183f8b4590c3bc968fbd81b2167" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CompositeData&lt;/code&gt; came from an earlier version of &lt;em&gt;J&lt;/em&gt;, some items might not be present. In this case, the corresponding setters will not be called.</source>
          <target state="translated">&lt;code&gt;CompositeData&lt;/code&gt; 가 이전 버전의 &lt;em&gt;J&lt;/em&gt; 에서 온 경우 일부 항목이 없을 수 있습니다. 이 경우 해당 세터가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="179c5197a088bdfb3577b89615e0f80069ec54a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">는 IF &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 이 설정되어있는 &lt;code&gt;false&lt;/code&gt; , 지연 시간이 경과하고 있지 않는 기존의 지연 태스크는 삭제됩니다. &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 향후 기존 작업의 향후 실행이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="4d9438386cfe32fda0c1181ccd31aab76978f092" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;InvocationHandler&lt;/code&gt; is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type. For example, with the method</source>
          <target state="translated">상기 중간 &lt;code&gt;InvocationHandler&lt;/code&gt; MXBean에위한 다음 방법의 파라미터는 해당 타입에 매핑 MXBean의 인터페이스에서 선언 된 형태로 변환되고, 복귀 값은 선언 된 유형에 맵핑 형태로 변환된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b773147646e5d6ae4684d585a997f76f520542ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="3f268e97c59dcc626388a2e991c9c9562516a82d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; uses the directory syntax, as described above under &lt;a href=&quot;#directory&quot;&gt;&quot;connector addresses based on directory entries&quot;&lt;/a&gt;, then the client may obtain it as just explained, or client and server may both know the appropriate directory entry to use. For example, if the connector server for the Whatsit agent uses the entry &lt;code&gt;whatsit-agent-connector&lt;/code&gt; in the RMI registry on host &lt;code&gt;myhost&lt;/code&gt;, then client and server can both know that the appropriate &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 이 위에서 &lt;a href=&quot;#directory&quot;&gt;&quot;디렉토리 항목을 기반으로하는 커넥터 주소&quot;에&lt;/a&gt; 설명 된대로 디렉토리 구문을 사용하는 경우, 클라이언트는 방금 설명한대로이를 얻거나 클라이언트와 서버가 사용할 적절한 디렉토리 항목을 알 수 있습니다. 예를 들어, Whatsit 에이전트의 커넥터 서버가 호스트 &lt;code&gt;myhost&lt;/code&gt; 의 RMI 레지스트리에있는 &lt;code&gt;whatsit-agent-connector&lt;/code&gt; 항목을 사용하는 경우 클라이언트와 서버는 적절한 &lt;code&gt;JMXServiceURL&lt;/code&gt; 이 다음과 같은 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f826af6b5dd95bfc92e77f04fdf460591da5f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; was generated by the server, as described above under &lt;a href=&quot;#servergen&quot;&gt;&quot;connector addresses generated by the server&quot;&lt;/a&gt;, then the client will need to obtain it directly or indirectly from the server. Typically, the server makes the &lt;code&gt;JMXServiceURL&lt;/code&gt; available by storing it in a file or a lookup service.</source>
          <target state="translated">는 IF &lt;code&gt;JMXServiceURL&lt;/code&gt; 서버에서 생성하고, 같은에서 설명한 &lt;a href=&quot;#servergen&quot;&gt;&quot;서버에서 생성 커넥터 주소&quot;&lt;/a&gt; , 클라이언트는 서버로부터 직접 또는 간접적으로 획득해야한다. 일반적으로 서버는 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 파일 또는 검색 서비스에 저장하여 사용 가능 하게합니다 .</target>
        </trans-unit>
        <trans-unit id="e3f171d07666393092d63f7170ed5ec052f7118d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Level&lt;/code&gt; of the specified logger is &lt;code&gt;null&lt;/code&gt;, which means that this logger's effective level is inherited from its parent, an empty string will be returned.</source>
          <target state="translated">지정된 로거 의 &lt;code&gt;Level&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 ,이 로거의 유효 레벨이 부모로부터 상속되는 경우는 빈 캐릭터 라인이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="458d82c56d9fb33c66e562fe6ab97aea8cc80904" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;MBeanPermission&lt;/code&gt; 의 확인에 성공, MBean에의 클래스는 그 것을 확인하여 검증 &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt; 의미한다 &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="021af7bb755cf93cf54c9f5f352c98d0f4ca4622" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains more than one period, for example &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt;, then the above rules are applied iteratively. Here,</source>
          <target state="translated">경우] &lt;code&gt;ObservedAttribute&lt;/code&gt; 는 예를 들어, 하나 이상의주기를 포함 &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt; 후 상기 규칙은 반복적으로 적용된다. 여기,</target>
        </trans-unit>
        <trans-unit id="7cb7f5f842a73d2190c2e8a4561e728aa057bb8f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">경우 &lt;code&gt;RMIServerImpl&lt;/code&gt; 의이 바이는 JNDI 디렉토리에 바인드 된 &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 방법,이 방법으로 디렉토리에서 언 바운드입니다.</target>
        </trans-unit>
        <trans-unit id="5e181fd53600dcd77e327b5091e7925935330a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;LENIENT&lt;/code&gt; and a time is parsed without a date, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; and an excess &lt;code&gt;Period&lt;/code&gt; in days.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;LENIENT&lt;/code&gt; 하고 시간이 날없이 구문 분석, 다음 구문 분석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 과 초과 &lt;code&gt;Period&lt;/code&gt; 일이다.</target>
        </trans-unit>
        <trans-unit id="801480d1156ab6ed42af2047f9f67f81a9ed2968" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;SMART&lt;/code&gt; and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; of 00:00:00 and an excess &lt;code&gt;Period&lt;/code&gt; of one day.</source>
          <target state="translated">경우 &lt;code&gt;ResolverStyle&lt;/code&gt; 가 있다 &lt;code&gt;SMART&lt;/code&gt; 과 시간이 24:00:00이고 시간은 날짜없이 구문 분석하고 해석의 전체 결과는 구성 &lt;code&gt;LocalTime&lt;/code&gt; 00:00:00 및 초과 &lt;code&gt;Period&lt;/code&gt; 1 일.</target>
        </trans-unit>
        <trans-unit id="679d594737099d64f4c8a7bd67a360d72bcf8bdd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">는 IF &lt;code&gt;Type&lt;/code&gt; 파라미터 화 된 형태의 인 &lt;code&gt;Type&lt;/code&gt; 정확하게 소스 코드로 사용되는 실제의 형태 파라미터를 반영해야합니다 반환 된 객체가.</target>
        </trans-unit>
        <trans-unit id="be1a0f77a615842bdf82ef7b9ebede6a9bce0b3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;code&gt;ZoneId&lt;/code&gt; 사용될는 인 &lt;code&gt;ZoneOffset&lt;/code&gt; ,이 방법은 동일하다 &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d86f839b1695227093964559a355f46055cbd60" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;abort&lt;/code&gt; phase fails for any reason, then this method propagates the original exception thrown either during the &lt;code&gt;login&lt;/code&gt; phase or the &lt;code&gt;commit&lt;/code&gt; phase. In either case, the overall authentication fails.</source>
          <target state="translated">는 IF &lt;code&gt;abort&lt;/code&gt; 단계는 어떤 이유로 실패,이 메소드는 동안 하나 던져 원래 예외 전파 &lt;code&gt;login&lt;/code&gt; 단계 또는이 &lt;code&gt;commit&lt;/code&gt; 단계. 두 경우 모두 전체 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="446c80fa5bc5f4e37afc5fc9e155b09818c5562f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll()&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll()&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ef5598f3ce002caa707d0e8dab5fc3e129e43c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">경우] &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 연산이 예외를 발생이 속성 세트의 상태에 대한 영향은 구현 의존적이다; 예외 시점 이전에 지정된 세트의 요소가이 속성 세트에 추가되었거나 추가되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0511263cbc485e9efb3be19eb199baa7484f96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">경우 &lt;code&gt;algorithm&lt;/code&gt; 매개 변수가 null 또는 비 비어, 엔드 포인트 식별은 / 검증 절차는 SSL / TLS 핸드 쉐이크 동안 처리해야합니다. 이는 중간자 공격을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="df2ce529fb9d0af1fa8bdee431df9ad0c85e4344" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an Attribute whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the AttributeSet.</source>
          <target state="translated">는 IF &lt;code&gt;attributes&lt;/code&gt; 카테고리의 속성을 보관 매개 변수와 동일한 &lt;code&gt;category&lt;/code&gt; 매개 변수, 서비스는 속성 세트에이 속성을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="66b2ac942fdab810011fedc70461bf42a1dedd98" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;boolean&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;, this method causes the virtual machine to stop performing the detailed instruction trace it is performing.</source>
          <target state="translated">경우 &lt;code&gt;boolean&lt;/code&gt; 인수가 &lt;code&gt;false&lt;/code&gt; 이 방법은 수행하는 상세 명령 추적을 중단 가상 머신됩니다.</target>
        </trans-unit>
        <trans-unit id="88001e51dd6c79b8369de89a8cbe2fdfe3865e70" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index - 1)&lt;/code&gt; is in the low-surrogate range, &lt;code&gt;(index - 2)&lt;/code&gt; is not negative, and the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index -
 2)&lt;/code&gt; is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;index -
 1&lt;/code&gt; is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 1)&lt;/code&gt; 저 대리 범위이고, &lt;code&gt;(index - 2)&lt;/code&gt; 네거티브 아니며, &lt;code&gt;char&lt;/code&gt; 의 값 &lt;code&gt;(index - 2)&lt;/code&gt; 높은 surrogate 범위에있는 경우, 부가 코드 포인트 대리 쌍의 값이 반환됩니다. &lt;code&gt;index - 1&lt;/code&gt; 의 &lt;code&gt;char&lt;/code&gt; 값 이 짝을 이루지 않은 낮은 서로 게이트 또는 높은 서로 게이트 인 경우 서로 게이트 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc1506abc2a5f78b19fe3dd96f18038b15e4e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this &lt;code&gt;String&lt;/code&gt;, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는 이것의 길이보다 짧은 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c3a606e3f3d827b22e0257098f87d4bbd176eb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">경우] &lt;code&gt;char&lt;/code&gt; 지정된 인덱스 지정된 값이 높은 대리 범위에 다음 인덱스는이 시퀀스의 길이보다 작은, 상기 &lt;code&gt;char&lt;/code&gt; 다음 인덱스의 값은, 저 대리 범위에서 보조 코드 포인트 인 이 대리 쌍에 해당하는이 반환됩니다. 그렇지 않으면 주어진 인덱스 의 &lt;code&gt;char&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7059bfb26c628d831ae809e02477cb1879e60f94" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">경우 &lt;code&gt;char&lt;/code&gt; 인덱스로 지정된 값이 인 &lt;a href=&quot;character#unicode&quot;&gt;대리&lt;/a&gt; , 대리 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8250d512b905f35c6a410fcb5609b7900e346a5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;commit&lt;/code&gt; phase of the authentication process fails, then the overall authentication fails and this method invokes the &lt;code&gt;abort&lt;/code&gt; method for each configured &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">인증 프로세스 의 &lt;code&gt;commit&lt;/code&gt; 단계가 실패하면 전체 인증이 실패하고이 메소드는 구성된 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84555e61977552659f8d8d7542bd52057f6a2286" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt; field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.</source>
          <target state="translated">상기 중간 &lt;code&gt;connect&lt;/code&gt; 접속이 이미 개방되었을 때 메소드가 호출된다 (의해 표시된 &lt;code&gt;connected&lt;/code&gt; 값을 갖는 필드 &lt;code&gt;true&lt;/code&gt; ), 호는 무시된다.</target>
        </trans-unit>
        <trans-unit id="671e297a3a1ea6f0c42770e029c80abaa60e1bfb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS handshake must be permitted by the constraints.</source>
          <target state="translated">&lt;code&gt;constraints&lt;/code&gt; 매개 변수가 널이 아닌 경우, SSL / TLS 핸드 쉐이크에 사용 된 모든 암호화 알고리즘, 키 및 알고리즘 매개 변수는 제한 조건에 의해 허용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="44563c51972a22c15c4aac96132c92755f5fb940" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property &lt;code&gt;java.io.tmpdir&lt;/code&gt;. On UNIX systems the default value of this property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;. A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.</source>
          <target state="translated">는 IF &lt;code&gt;directory&lt;/code&gt; 인수가 &lt;code&gt;null&lt;/code&gt; 다음 시스템에 의존하는 기본 임시 파일 디렉토리가 사용됩니다. 기본 임시 파일 디렉토리는 시스템 특성 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 에 의해 지정됩니다 . UNIX 시스템에서이 특성의 기본값은 일반적으로 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 일반적으로 &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt; 입니다. JVM (Java Virtual Machine)이 호출 될 때이 시스템 특성에 다른 값이 제공 될 수 있지만이 특성의 프로그래밍 방식 변경이이 메소드가 사용하는 임시 디렉토리에 영향을 미치지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="61b3f5e27ccdfa6299b991fa9397c7fbc31d2c50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;emitter&lt;/code&gt; 생성자에 매개 변수의 인스턴스이었다 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 이 메소드는 호출 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab969fd58c84fba8fefef4d68297aff8fba763d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this engine.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 같은 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용 등을 준수하기 위해 필요로 필드 이 엔진의 알고리즘 제약 조건에</target>
        </trans-unit>
        <trans-unit id="4eab346c804a32d54771d78aef5cb1081f3a8a5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">는 IF &lt;code&gt;engine&lt;/code&gt; 매개 변수를 사용할 수 있으며의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;engine&lt;/code&gt; 에 연결이 최종 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔티티 X509 인증서.</target>
        </trans-unit>
        <trans-unit id="56c06cc3e424dcdff076cdd1bf18f2a3b0d87e7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d005cee8b528479b05c0be85b9c4205d983a4967" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="826709e7b964ff5f55e8bba64d589128adee0453" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자를로드하는 데 사용할 클래스 로더입니다. 연관된 값이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 인스턴스가 아닌 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57ace146c6c02d090ae1128a0850bf8c4adb9e91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;environment&lt;/code&gt; 매개 변수에 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; 키가 포함 된 경우 연관된 값은 제공자 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f6b8bda61da14baa6de0517de831488bd2ee3ae0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are treated as white space and serve only to separate tokens.</source>
          <target state="translated">&lt;code&gt;flag&lt;/code&gt; 가 false 인 경우 줄 끝 문자는 공백으로 처리되며 별도의 토큰에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f96a39d4789943d7d6902746fb2340490af74ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">경우 &lt;code&gt;info&lt;/code&gt; 배열이 비어 있지 않은, 다음은 경우와 같이 생성자에 의해 복제됩니다 &lt;code&gt;info.clone()&lt;/code&gt; 및 호출 할 때마다 &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 새로운 복제를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="b2eafd26f57a8ac8bfe07dee9777924ccc1ddeef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is specified and does not point to an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; will be thrown.</source>
          <target state="translated">는 IF &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 를의 속성이 지정되고 가리 키지 않는 &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="c4278296c23500bf6c0cea864ef00fd56ed5236d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the calling thread's context class loader is used.</source>
          <target state="translated">는 IF &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 의 키에 존재하지 않는 &lt;code&gt;environment&lt;/code&gt; 매개 변수, 호출 thread의 문맥 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3056297b7728c6033d8b58edc893075abdeaf0f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be executed on the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listenerMethodName&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 인터페이스의 &lt;em&gt;모든&lt;/em&gt; 메소드 가 &lt;code&gt;target&lt;/code&gt; 실행되도록 &lt;code&gt;action&lt;/code&gt; 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c26cc70217e4df47d29c0c2d3d16af4b3ed49f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the bootstrap class loader.</source>
          <target state="translated">는 IF &lt;code&gt;loader&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 및 시큐리티 매니저가 존재 해, 호출 측의 클래스 로더가 null는 아니고,이 메소드는 보안 매니저의 호출 &lt;code&gt;checkPermission&lt;/code&gt; 와 방법 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 는 부트 스트랩 클래스 로더에 액세스 할 수있는 것을 보증 할 수있는 권한 .</target>
        </trans-unit>
        <trans-unit id="883de64909ad64380525bc73b0b1943d2957d4ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;login&lt;/code&gt; method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the &lt;code&gt;getSubject&lt;/code&gt; method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective &lt;code&gt;getPrincipals&lt;/code&gt;, &lt;code&gt;getPublicCredentials&lt;/code&gt;, and &lt;code&gt;getPrivateCredentials&lt;/code&gt; methods.</source>
          <target state="translated">경우 &lt;code&gt;login&lt;/code&gt; 메소드가 예외를 throw하지 않고 반환, 인증 전체가 성공했다. 그러면 호출자는 &lt;code&gt;getSubject&lt;/code&gt; 메소드 를 호출하여 새로 인증 된 주제를 검색 할 수 있습니다 . 주제와 연관된 프린시 펄 및 신임은 주제의 해당 &lt;code&gt;getPrincipals&lt;/code&gt; , &lt;code&gt;getPublicCredentials&lt;/code&gt; 및 &lt;code&gt;getPrivateCredentials&lt;/code&gt; 메소드 를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b49049ac47e926595641db8085788c19725bedae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;minimumCapacity&lt;/code&gt; argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.</source>
          <target state="translated">는 IF &lt;code&gt;minimumCapacity&lt;/code&gt; 의 인수가 정의 값이 아닌,이 메소드는 아무 작업도 간단하게 수익을지지 않습니다. 이 개체에 대한 후속 작업으로 인해 여기에서 요청한 것보다 실제 용량이 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848f1dae842a9e3e26ccb5fe35a5a76ed09b5792" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modes&lt;/code&gt; parameter is of length zero, then the existence of the file is checked.</source>
          <target state="translated">는 IF &lt;code&gt;modes&lt;/code&gt; 매개 변수는 길이가 0이며, 파일의 존재가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a314f2aa28a80e456c2b1019bb7151fb7190ec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; begins with a &lt;code&gt;'/'&lt;/code&gt; (&lt;code&gt;'\u002f'&lt;/code&gt;), then the absolute name of the resource is the portion of the &lt;code&gt;name&lt;/code&gt; following the &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;name&lt;/code&gt; 로 시작할 &lt;code&gt;'/'&lt;/code&gt; ( &lt;code&gt;'\u002f'&lt;/code&gt; ), 그 자원의 절대 이름의 부분 인 &lt;code&gt;name&lt;/code&gt; 다음 &lt;code&gt;'/'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64bdc0e92c398401f342c415851da39654a29de8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot; a &lt;code&gt;NoSuchMethodException&lt;/code&gt; is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">상기 중간 &lt;code&gt;name&lt;/code&gt; &quot;입니다 &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &quot;는 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 발생합니다. 그렇지 않으면, 반영 될 방법은 다음 알고리즘에 의해 결정됩니다. C를이 객체가 나타내는 클래스 또는 인터페이스라고하자.</target>
        </trans-unit>
        <trans-unit id="83d37bcba2e6c3af77d7d4ae04d7689d9a46d013" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute with the same local name and namespace URI, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 같은 로컬 명과 이름 공간 URI와 기존 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c99c4ecff1480f789773edec7e413ca2eabcdc6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;newAttr&lt;/code&gt; 속성이 기존의 속성을 대체, 교체 &lt;code&gt;Attr&lt;/code&gt; 노드는 달리, 반환되는 &lt;code&gt;null&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e562c3377bc531b17a3856d97697e38d3cf5595e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newLength&lt;/code&gt; argument is greater than or equal to the current length, sufficient null characters (&lt;code&gt;'\u0000'&lt;/code&gt;) are appended so that length becomes the &lt;code&gt;newLength&lt;/code&gt; argument.</source>
          <target state="translated">경우] &lt;code&gt;newLength&lt;/code&gt; 인수보다 크거나 현재의 길이와 동일 충분한 널 문자 ( &lt;code&gt;'\u0000'&lt;/code&gt; 그 길이는가되도록) 추가된다 &lt;code&gt;newLength&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="301c55c1d2d5648b427ee3a645ab8146cd1a941a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음 스트림이 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 주기가 감지되면 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; 인스턴스의 입출력 오류로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecea4dec8dcb1fadb716a28cf7ec70ca81e1d565" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 포함 매개 변수 &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; 의&lt;/a&gt; 옵션은 다음이 방법은 너무 사이클이 검출 될 수 있음을 방문한 디렉토리를 추적합니다. 디렉토리의 조상 인 디렉토리에 항목이있을 때주기가 발생합니다. 디렉토리 탐지는 디렉토리 의 &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt; 를 기록 하거나 파일 키를 사용할 수없는 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 디렉토리가 상위 파일과 동일한 파일인지 테스트하여 수행됩니다. 사이클이 검출 될 때는 I / O 에러로 처리하고, &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; 의&lt;/a&gt; 방법의 인스턴스를 호출 &lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88ff2d156a33a9f0f1f1ee553f98ff8909648b12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">경우] &lt;code&gt;other&lt;/code&gt; 파라미터가있다 &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 경로가이 메소드는 반환 소소 &lt;code&gt;other&lt;/code&gt; . 경우 &lt;code&gt;other&lt;/code&gt; 인</target>
        </trans-unit>
        <trans-unit id="9865b3d772f73983f404112e79623aa8e389cc36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="3573d5215011c7d840ccb006ba46e8ea91465ab0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4e86a833a3d986a22969c431219896e2f0d39b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b14a126287c47f1542560e798db984f2eaa1bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">상기 중간 &lt;code&gt;output&lt;/code&gt; 버퍼가 너무 작아 결과를 보관 유지할하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생된다. 이 경우 더 큰 출력 버퍼로이 호출을 반복하십시오. &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt; 를 사용 하여 출력 버퍼 크기를 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e09b11d717ca9d2b9db6e423c314021366d5f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;pri&lt;/code&gt; argument is less than &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt;&lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt;&lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt;&lt;/a&gt;, the maximum priority of the group remains unchanged.</source>
          <target state="translated">경우] &lt;code&gt;pri&lt;/code&gt; 인수 미만이다 &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt; &lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt; &lt;/a&gt; 또는보다 &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt; &lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt; &lt;/a&gt; 그룹의 최고 우선 순위는 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="72da6eb0f51543265c08bfdc0d2bc08c5c28b9d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it indicates that this method is being called because the previously loaded resource bundle has expired.</source>
          <target state="translated">경우 &lt;code&gt;reload&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; , 그것은 이전에로드 된 자원 번들이 만료 되었기 때문에이 메소드가 호출되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9cf1a2b060b2436670293c7813d34eef4b639e76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only serve as separators between tokens.</source>
          <target state="translated">는 IF &lt;code&gt;returnDelims&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 를 , 단락 문자도 토큰으로 반환됩니다. 각 분리 문자는 길이가 1 인 문자열로 리턴됩니다. 플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 건너 뛰고 토큰 사이의 구분자 역할 만합니다.</target>
        </trans-unit>
        <trans-unit id="814c644fd80ff6c6cfb5225d71687f0ea854f3a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; looks like:</source>
          <target state="translated">경우] &lt;code&gt;serviceURL&lt;/code&gt; 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="135f589d26f864ce90f30a25047418b479d5f710" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; you specify has an empty URL path (after the optional host and port), or if you do not specify a &lt;code&gt;serviceURL&lt;/code&gt;, then the connector server will fabricate a new &lt;code&gt;JMXServiceURL&lt;/code&gt; that clients can use to connect:</source>
          <target state="translated">는 IF &lt;code&gt;serviceURL&lt;/code&gt; 지정은 (옵션의 호스트와 포트) 하늘의 URL 경로가 당신이 지정하지 않은 경우, 또는 &lt;code&gt;serviceURL&lt;/code&gt; 다음 커넥터 서버는 새로운 제조됩니다 &lt;code&gt;JMXServiceURL&lt;/code&gt; 를 클라이언트가 연결하는 데 사용할 수를 :</target>
        </trans-unit>
        <trans-unit id="a4c7fe60b96360a2fce6906e7dfb1015497d385d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sharedSecret&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, this call should be repeated with a larger output buffer.</source>
          <target state="translated">는 IF &lt;code&gt;sharedSecret&lt;/code&gt; 에 버퍼가 너무 작아 결과를 보관 유지할 수하는 &lt;code&gt;ShortBufferException&lt;/code&gt; 가 발생합니다. 이 경우이 호출은 더 큰 출력 버퍼로 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="a59bde6bd9cfdf4f9c0e2000a8690929361fab50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this socket.</source>
          <target state="translated">는 IF &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 알고리즘 제약 &lt;code&gt;SSLParameters&lt;/code&gt; 인증 경로에있는 모든 인증서, null가 아닌, 등 주제의 공개 키, 서명 알고리즘, 키 사용, 확장 키 사용으로 필드 이 소켓에있는 알고리즘 제약 조건을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9eeaa551ce6db761bfe71fcd9d95ed24d11d58e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">경우 &lt;code&gt;socket&lt;/code&gt; 매개 변수의 인스턴스 &lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 와의 엔드 포인트 식별 알고리즘 &lt;code&gt;SSLParameters&lt;/code&gt; 비 비어, man-in-the-middle 공격은 그 주소를 방지하기 위해 &lt;code&gt;socket&lt;/code&gt; 에 연결이 제시 피어의 식별 정보에 대해 확인되어야한다 엔드 포인트 식별 알고리즘에 지정된 엔드 엔티티 X509 인증서</target>
        </trans-unit>
        <trans-unit id="a8ad5fb90dd67b864239c52c78d91a33b02bcd3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</source>
          <target state="translated">If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</target>
        </trans-unit>
        <trans-unit id="384a467e1b3d5e62425baa603c92bb9909dbf0dc" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of the characters asterisk or question mark and they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">는 IF &lt;em&gt;인용 값이&lt;/em&gt; 문자의 별표 (*) 또는 물음표 중 하나 개 이상 발생을 포함하고는 앞에 백 슬래시되지 않습니다, 그들은이 와일드 카드 문자로 간주하고 개체 이름은이다하는 &lt;em&gt;속성 값 패턴&lt;/em&gt; . 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="383d196bbc70848d6d2a83c15bee341a49633abd" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">&lt;em&gt;따옴표없는 값&lt;/em&gt; 에 와일드 카드 문자 별표 또는 물음표가 하나 이상 포함 된 경우 개체 이름은 &lt;em&gt;속성 값 pattern&lt;/em&gt; 입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8fc60c08a8c50456909645784a1769d622137e78" translate="yes" xml:space="preserve">
          <source>If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error.</source>
          <target state="translated">ALLOW_UNASSIGNED 플래그가 사용되는 경우, 변환 될 도메인 이름 문자열은 유니 코드 3.2에서 할당되지 않은 코드 포인트를 포함 할 수 있으며, 이는 IDN 변환이 기반으로하는 유니 코드 버전입니다. 플래그를 사용하지 않으면 할당되지 않은 코드 포인트가 존재하는 것은 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2a7c711b7120183f899af59849df74982f595de0" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="27052094f3a72a9f04c55988b8fcc4b55c99cb46" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments, then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="bf6802705f363000e83d105cf3b075ebc1fbcacb" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 이전에 내부 검사 된 경우 BeanInfo 캐시에서 BeanInfo 클래스가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="74b13711d7aed1bc07acd1271fe358967b6f6726" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">Java Bean의 BeanInfo 클래스가 동일한 인수를 기반으로 이전에 검사 된 경우 BeanInfo 클래스가 BeanInfo 캐시에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="b9320150224d23795105d0b84d8ba0219f014f46" translate="yes" xml:space="preserve">
          <source>If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the &lt;code&gt;abort&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. In this case, the &lt;code&gt;LoginModule&lt;/code&gt; removes/destroys any authentication state originally saved.</source>
          <target state="translated">LoginContext의 전체 인증에 실패한 경우 (관련된 REQUIRED, REQUISITE, SUFFICIENT 및 OPTIONAL LoginModules가 실패한 경우) 각 &lt;code&gt;LoginModule&lt;/code&gt; 에 대한 &lt;code&gt;abort&lt;/code&gt; 메소드 가 호출됩니다. 이 경우 &lt;code&gt;LoginModule&lt;/code&gt; 은 원래 저장된 인증 상태를 제거 / 파기합니다.</target>
        </trans-unit>
        <trans-unit id="8b1ca264c954dc0a754372106598096735c9ddf1" translate="yes" xml:space="preserve">
          <source>If the MXBean is a notification emitter (i.e., it implements &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;), both the &lt;code&gt;mxbeanInterface&lt;/code&gt; and &lt;code&gt;NotificationEmitter&lt;/code&gt; will be implemented by this proxy.</source>
          <target state="translated">MXBean가 통지 이미 터 인 경우 (즉, &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; 를&lt;/a&gt; 구현 하는 경우) &lt;code&gt;mxbeanInterface&lt;/code&gt; 와 &lt;code&gt;NotificationEmitter&lt;/code&gt; 가이 프록시에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="b43d6c84cc6fb1e54fa1b85884c057f4a6774967" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ModelMBean가 현재 등록되어있는 경우,이 메소드는 &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을&lt;/a&gt; 랩핑하는 &lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e5cc0b4b6523113fb60bbdd890e2ed587190e3eb" translate="yes" xml:space="preserve">
          <source>If the PropertyEditor doesn't honor paint requests (see isPaintable) this method should be a silent noop.</source>
          <target state="translated">PropertyEditor가 페인트 요청을 준수하지 않으면 (isPaintable 참조)이 메소드는 자동 스킵이어야합니다.</target>
        </trans-unit>
        <trans-unit id="edc7ecb68896dc99cf3bfe6d1c68065fc233cc04" translate="yes" xml:space="preserve">
          <source>If the ProtectionDomain was constructed to a &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt;&lt;code&gt;statically bound&lt;/code&gt;&lt;/a&gt; PermissionCollection then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">ProtectionDomain이 &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt; &lt;code&gt;statically bound&lt;/code&gt; &lt;/a&gt; PermissionCollection 으로 구성된 경우 권한은 구성시 제공된 PermissionCollection에 대해서만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb3e9bfa37e0fb36cbe25f740fc69395067b33e" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt;&lt;code&gt;getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; and &lt;code&gt;iiop&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;JMXServiceURL&lt;/code&gt; 의 URL 경로 부분 이 비어 있거나 단일 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 인 경우 RMI 오브젝트는 디렉토리에 바인드되지 않습니다. 대신, 이에 대한 참조는 RMIConnectorServer 주소의 URL 경로 ( &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt; &lt;code&gt;getAddress()&lt;/code&gt; &lt;/a&gt; 로 리턴 됨 ) 로 인코딩됩니다 . &lt;code&gt;rmi&lt;/code&gt; 및 &lt;code&gt;iiop&lt;/code&gt; 의 인코딩은 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 의 패키지 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c88147c00b169cc4a7d700bc22d47ae19dc49b7" translate="yes" xml:space="preserve">
          <source>If the URL specified is &lt;code&gt;null&lt;/code&gt; or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.</source>
          <target state="translated">지정된 URL이 &lt;code&gt;null&lt;/code&gt; 이거나 이미 URL 목록에 있거나이 로더가 닫혀 있으면이 메소드를 호출해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c0237f144da2fa8c67cb271e88ffe70a6e43f35" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">USE_STD3_ASCII_RULES 플래그가 사용되면 ASCII 문자열이 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt; 에 대해 검사 됩니다. 요구 사항을 충족하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27b1988df75b26444a795d6673a2d8719150a662" translate="yes" xml:space="preserve">
          <source>If the Unicode Standard changes block names, both the previous and current names will be accepted.</source>
          <target state="translated">유니 코드 표준이 블록 이름을 변경하면 이전 이름과 현재 이름이 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4474e2c1fcf43dbf037954df628912501189beb2" translate="yes" xml:space="preserve">
          <source>If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector &lt;em&gt;only&lt;/em&gt; if the caller knows that the Vector does not contain any null elements.)</source>
          <target state="translated">여유 공간이있는 지정된 배열에 Vector가 적합하면 (즉, 배열에 Vector보다 많은 요소가있는 경우) Vector의 끝 바로 뒤에있는 배열의 요소는 null로 설정됩니다. (이것은 호출자가 Vector에 null 요소가 없음을 알고있는 경우 &lt;em&gt;에만&lt;/em&gt; Vector의 길이를 결정하는 데 유용 합니다.)</target>
        </trans-unit>
        <trans-unit id="9f95877bd50006d6d00056ef2a51aa22bd21083c" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">위의 규칙이 값을 생성하지 않고 introspection 인 경우 &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt; 를 호출 하여</target>
        </trans-unit>
        <trans-unit id="9b05835af2c154a7c76f77377aa6c52d404cdcb8" translate="yes" xml:space="preserve">
          <source>If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.</source>
          <target state="translated">첫 번째 인수의 절대 값이 1이고 두 번째 인수가 무한하면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="d6afccfd8739251584afc0914039b51c90ada53f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66516904fde9701dc7f61bc426819fb4f146f708" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e52e55025286a627afde1b1d2b384ea2bee735b" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;DoubleConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;DoubleConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;DoubleConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;DoubleConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6eb467bff49959d09e05c7bab75146704c0dc28d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc7b37b752547334d50d87c5179ebe5f7826e35" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4a7f713f21116ad3b228e0623aa03e2b62a6679" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;IntConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;IntConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;IntConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;IntConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="290eeb3f1f54f16b09955c88d8cfd90d14b9557d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0dcd5ef32e41f4bca014a916ec5e3e0e6b1fab7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00bbc10814534bf0219172f193911a9aeadd7e16" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업이의 인스턴스 인 경우 &lt;code&gt;LongConsumer&lt;/code&gt; 다음이로 캐스팅 &lt;code&gt;LongConsumer&lt;/code&gt; 과 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 동작은 인스턴스로 구성된다 &lt;code&gt;LongConsumer&lt;/code&gt; 의 인수 복싱, &lt;code&gt;LongConsumer&lt;/code&gt; 을 다음에 전달 &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5ff8c69ea26957c669b0830c3787c984d9d074" translate="yes" xml:space="preserve">
          <source>If the action performed in your &lt;code&gt;run&lt;/code&gt; method could throw a &quot;checked&quot; exception (those listed in the &lt;code&gt;throws&lt;/code&gt; clause of a method), then you need to use the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; interface instead of the &lt;code&gt;PrivilegedAction&lt;/code&gt; interface:</source>
          <target state="translated">작업이 수행되면 &lt;code&gt;run&lt;/code&gt; 던질 수있는 방법 A 예외를 (에 나열된 사람들은 &quot;확인&quot; &lt;code&gt;throws&lt;/code&gt; 방법의 절을), 당신은 사용할 필요가 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 와의 대신의 인터페이스 &lt;code&gt;PrivilegedAction&lt;/code&gt; 인터페이스를 :</target>
        </trans-unit>
        <trans-unit id="f8b6f3a11b20582c114df00bdb40a1e0e0cbd27f" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가</target>
        </trans-unit>
        <trans-unit id="6baa6ffe1bf64066619e4375881dfdc0f383d936" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an (unchecked) exception, it will propagate through this method.</source>
          <target state="translated">액션의 &lt;code&gt;run&lt;/code&gt; 메소드가 (확인되지 ​​않은) 예외를 throw하면이 메소드를 통해 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="102269f064fade95ae910ba7bdf983251013c399" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up an ephemeral port and a valid local address to bind the socket.</source>
          <target state="translated">주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 시스템은 임시 포트와 유효한 로컬 주소를 선택하여 소켓을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="e4c80757c9e2ecb6b75dc0a37636c30cb9490032" translate="yes" xml:space="preserve">
          <source>If the algorithm is the</source>
          <target state="translated">알고리즘이</target>
        </trans-unit>
        <trans-unit id="0e8d5a3e745f1450eac261edbc32910b4882938f" translate="yes" xml:space="preserve">
          <source>If the amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must use the ISO chronology.</source>
          <target state="translated">금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우 ISO 연대기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d740232e114f21d31c73ca4687c4057fb29ccd4" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get-int-&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">지정된 타임 스탬프에서 절약 시간이 필요한 경우이 &lt;code&gt;TimeZone&lt;/code&gt; 과 타임 스탬프를 사용 하여 &lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; 를 구성하고 &lt;a href=&quot;calendar#get-int-&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; ( Calendar.DST_OFFSET &lt;code&gt;)&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="272549f61fd737d1e73b2c36c4aa004c00079132" translate="yes" xml:space="preserve">
          <source>If the answer is NO, go to the next step.</source>
          <target state="translated">대답이 아니오이면 다음 단계로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f57b79608f2a3ff0ec11e483aaaa3a019d8c2b5b" translate="yes" xml:space="preserve">
          <source>If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; exception.</source>
          <target state="translated">대답이 NO이면 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="434e3dee0acd3560230fa30595feca5a213bbce4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 및 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1eb85cb2614bd41f0d6af38673aa7528bca07f4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="de83ee4eae564494ffc414cfaf8cc18d47b2bed1" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">대답이 예이면 인스턴스화 하고 새 인스턴스에서 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="56a7594c327855897bea9f06e5423ff72ccb1d7b" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it.</source>
          <target state="translated">대답이 예이면 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="160782cdb54c84087be65e0efddfac392e283c77" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.</source>
          <target state="translated">대답이 YES 인 경우,이 클래스를 인스턴스화하십시오 (제공자가 제공 한 모드 및 패딩 구성표 기본값이 사용됨).</target>
        </trans-unit>
        <trans-unit id="968a78947275cffe7a67b6a953d091962ffdb8ec" translate="yes" xml:space="preserve">
          <source>If the application has previously set up an instance of &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory, then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance is called with the protocol string as an argument to create the stream protocol handler.</source>
          <target state="translated">애플리케이션이 이전 에 스트림 핸들러 팩토리로 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 의 인스턴스를 설정 한 경우 해당 인스턴스의 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 메소드가 스트림 문자열 핸들러를 작성하기위한 인수로 프로토콜 문자열과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2070d70078ec2db5e6d48447de6438828f0279ed" translate="yes" xml:space="preserve">
          <source>If the application has set up a content handler factory instance using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called with the content type as an argument; the result is a content handler for that content type.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;setContentHandlerFactory&lt;/code&gt; 메소드를 사용하여 컨텐츠 핸들러 팩토리 인스턴스를 설정 한 경우 &lt;code&gt;createContentHandler&lt;/code&gt; 메소드가 컨텐츠 유형을 인수로 사용하여 호출됩니다. 결과는 해당 컨텐츠 유형에 대한 컨텐츠 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="91fdcd973932e65f09e9bdaebd48fb198c503271" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">응용 프로그램에서 서버 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="221a9611027772cf1f0b3bdc427ffc5e66a9af4e" translate="yes" xml:space="preserve">
          <source>If the application has specified a socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">애플리케이션이 소켓 팩토리를 지정한 경우 해당 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출되어 실제 소켓 구현을 작성합니다. 그렇지 않으면 &quot;일반&quot;소켓이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8dff9cb695d7cf445c13c7a8630fbe3ce30315" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">응용 프로그램이 &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt; 를 호출하여 종료 프로세스를 시작한 경우, 경우에 따라 초기자가 피어의 해당 닫기 메시지를 기다릴 필요가 없습니다. ( 클로저 경보 대기에 대한 자세한 정보 는 TLS 스펙 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt; )의 7.2.1 섹션을 참조하십시오 .) 이러한 경우이 메소드를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="18ba07a0dacca161f919bf38b3942c5cbf0de7b4" translate="yes" xml:space="preserve">
          <source>If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.</source>
          <target state="translated">인수 색인이 패턴 문자열에서 둘 이상의 형식 요소에 사용되는 경우, 모든 형식 요소에 새 형식이 사용됩니다. 패턴 문자열의 형식 요소에 인수 인덱스를 사용하지 않으면 새 형식이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="201ffc4148225e00891b41aafa471a7bc0ae4e31" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; 인 경우 결과는 2 &lt;sup&gt;971&lt;/sup&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0500f3687980d0c066085bfc637859d5a0f94f45" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.</source>
          <target state="translated">인수가 &amp;plusmn; 경우 &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; , 결과는 2와 동일하다 &lt;sup&gt;(104)&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b56eeca30ec55767a713e51154185f73b688" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7f800000&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800000&lt;/code&gt; 이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="cc33fb1734d8e8472093718dadfa691efa944850" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 인 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="67ad4ce5c4db05b329a5cf076b7ace8df7e07d24" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xff800000&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xff800000&lt;/code&gt; 이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="44b83a1db6251fafa0226412a16d0a5aa743a573" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">인수가 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="970f258bf10d8b6db35da86a6962bea7e6f056c5" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 의 경우, 결과는 &quot; &lt;code&gt;false&lt;/code&gt; &quot;입니다. 인수가 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 인 경우 결과는 &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt; 반환 한 문자열 입니다. 그렇지 않으면 결과는 &quot; &lt;code&gt;true&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4acdffc199e6f4f9b1d96e0f15f8a4c625bb7edd" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;null&lt;/code&gt;&quot;. If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;null&lt;/code&gt; 인 경우 결과는 &quot; &lt;code&gt;null&lt;/code&gt; &quot;입니다. 인수가 &lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; 을&lt;/a&gt; 구현하면 해당 &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그렇지 않으면 인수의 &lt;code&gt;toString()&lt;/code&gt; 메소드 를 호출하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="fe94a89675405323875ef4ec6ff361112380225e" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 NaN이거나 무한대 또는 양수 0 또는 음수 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f1490c0a73a4bdc7beee59aa0b2e8886fa1ac76" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 무한대이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e8d658cc42466718800cf906b23004b8262a330a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt;&lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt; &lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="cc7b80c9b72e91dff938c54c51871d14f95c81ca" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt;&lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">인수가 NaN 또는 무한이면 결과는 &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt; &lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1입니다.</target>
        </trans-unit>
        <trans-unit id="745e5106ba9365f2bce0539ab810d8720f71215b" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or its absolute value is greater than 1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 절대 값이 1보다 크면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="07291af92544374b52ef8f433433f39f1dbb80d9" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than -1, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 -1보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="13a256cb6eee91493a6f005cfe5cd4ae37f9697f" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than zero, then the result is NaN.</source>
          <target state="translated">인수가 NaN이거나 0보다 작은 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="31b76fec8c3bc86ab1662b04d7bb45867ec9f9d7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is 0.</source>
          <target state="translated">인수가 NaN이면 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="3aa89491f3556c271cee0931546f3e5660ec7ac7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7fc00000&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7fc00000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a83c5a6baaa1bd2366e8865b925beaeea4e26b42" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7ff8000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 NaN이면 결과는 &lt;code&gt;0x7ff8000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="118d734407198a907583b63ea2fc64d7c89b2c28" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="e064879a9427f94b4430bb8b2822c39d482f8755" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the &lt;code&gt;long&lt;/code&gt; integer representing the actual NaN value. Unlike the &lt;code&gt;doubleToLongBits&lt;/code&gt; method, &lt;code&gt;doubleToRawLongBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN이면 결과는 실제 NaN 값을 나타내는 &lt;code&gt;long&lt;/code&gt; 정수입니다. &lt;code&gt;doubleToLongBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;표준&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bca2d981cbc0638a09fdc8f8c3691bf1f893da00" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the integer representing the actual NaN value. Unlike the &lt;code&gt;floatToIntBits&lt;/code&gt; method, &lt;code&gt;floatToRawIntBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">인수가 NaN 인 경우 결과는 실제 NaN 값을 나타내는 정수입니다. &lt;code&gt;floatToIntBits&lt;/code&gt; 메서드 와 달리 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 는 NaN을 인코딩하는 모든 비트 패턴을 단일 &quot;정식&quot;NaN 값으로 축소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db8eab43bb6026b1e9b4780ecae1f1526f2beff3" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the string &quot;&lt;code&gt;NaN&lt;/code&gt;&quot;.</source>
          <target state="translated">인수가 NaN이면 결과는 문자열 &quot; &lt;code&gt;NaN&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c12f1031f1e9c83194d8ac6506dee76af527571a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, then the result is NaN.</source>
          <target state="translated">인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="5a923aa0ff948589bbbea2c5c98edba0c8041581" translate="yes" xml:space="preserve">
          <source>If the argument is already a localized stream, it may be returned as the result.</source>
          <target state="translated">인수가 이미 지역화 된 스트림 인 경우 결과로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9264d5fd055500aa5c8726a54e413523844cbaf" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7f800001&lt;/code&gt; through &lt;code&gt;0x7fffffff&lt;/code&gt; or in the range &lt;code&gt;0xff800001&lt;/code&gt; through &lt;code&gt;0xffffffff&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7f800001&lt;/code&gt; ~ &lt;code&gt;0x7fffffff&lt;/code&gt; 범위 또는 &lt;code&gt;0xff800001&lt;/code&gt; ~ &lt;code&gt;0xffffffff&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 값은 &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e09c36577e890868103778c6cad080360d9fef25" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; through &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; or in the range &lt;code&gt;0xfff0000000000001L&lt;/code&gt; through &lt;code&gt;0xffffffffffffffffL&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; method.</source>
          <target state="translated">인수가 &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; - &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; 범위 또는 &lt;code&gt;0xfff0000000000001L&lt;/code&gt; - &lt;code&gt;0xffffffffffffffffL&lt;/code&gt; 범위의 값 이면 결과는 NaN입니다. Java가 제공하는 IEEE 754 부동 소수점 연산은 비트 패턴이 다른 동일한 유형의 두 NaN 값을 구별 할 수 없습니다. NaN의 고유 한 값은 &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; 메소드를 사용하여 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="108d000cc41c657851b0d27f0a1ac78cf5e4ee70" translate="yes" xml:space="preserve">
          <source>If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for integer</source>
          <target state="translated">정수 의 인수가 &lt;sup&gt;&lt;i&gt;10n 인&lt;/i&gt;&lt;/sup&gt; 경우</target>
        </trans-unit>
        <trans-unit id="65efe2e81fa8d1ba670e4b1992ae1775f4b62a76" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, the result is positive infinity.</source>
          <target state="translated">인수가 무한한 경우 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="336889ed81a3144be451220af338acfcbb6c9ba3" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is an infinity with the same sign as the argument.</source>
          <target state="translated">인수가 무한하면 결과는 인수와 같은 부호를 가진 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="4691c35189f88af211fb42ae9607c8ae123c02d6" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is positive infinity.</source>
          <target state="translated">인수가 무한하면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ec376818cb2e255655d1881f54f64a5f81a51e7b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 값이면 결과는 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5a08fe9d371940e4f9d92ad57a75f846bb063ec2" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이거나 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값보다 작거나 같은 경우 결과는 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c38692773d898bd9643813b94e0ae1993eb556" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xff800000&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대 &lt;code&gt;0xff800000&lt;/code&gt; 결과는 0xff800000 입니다.</target>
        </trans-unit>
        <trans-unit id="3bb987ea3c954538087573e2f402d9fdf305369d" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6a939ea1df7c37cb72e17d44d1754a7325b1cce" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is negative infinity.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ba927f3f79a46354d9209dcd811d86b8a661221b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is -1.0.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 -1.0입니다.</target>
        </trans-unit>
        <trans-unit id="20f8e0486c54aeb853e7804b4611ce1c56a73d1b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 &lt;code&gt;-1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9e3b1cc495f1cc8092755d393fd54a8be9e0bff" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is positive zero.</source>
          <target state="translated">인수가 음의 무한대이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="d08b29e2ea8c8a74d04b752def011f9cda30c497" translate="yes" xml:space="preserve">
          <source>If the argument is negative one, then the result is negative infinity.</source>
          <target state="translated">인수가 음수 인 경우 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="ad3d4a3e9566e2c0df155d95c37161c79599330f" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eff50c12018038db62b68855eb707df57d7cd5ae" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이거나 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값보다 크거나 같은 값 이면 결과는 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a13758d0f976c89623e38e841da2cbc62912670" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7f800000&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7f800000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c05eefbf6b8959edbbea1c8b9a02322d8935ca7" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf429a21c2dc34b66e4269078332483b3641ead6" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="31b9de6b24ff8d5ffbebf56f3f1cecc792456081" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is &lt;code&gt;+1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 &lt;code&gt;+1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f87ee2c0e3d173098373d3990b3903acb3bfadf9" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="96dab47247ae7e1056e56799ef0665e4ab651c26" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative infinity, then the result is positive infinity.</source>
          <target state="translated">인수가 양의 무한대이거나 음의 무한대이면 결과는 양의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="78148cd34a5b7680af0ed6412b4903e44701b46c" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Double.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c4032eb755d363cebfbea8af5b3c0b4a94596cf" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Float.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">인수가 양수 또는 음수 0이면 결과는 &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f15f3f96dc5106b38775f4ba76d739b00aa110dd" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, the result is positive zero.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="0553928b250b89074ae0163da0309f356dd0aea5" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is negative infinity.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 음의 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="f8ad8830694a6f7c940aad7bd91216f8c775287b" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">인수가 양의 0 또는 음의 0이면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="11b6940276c4e767ac8a361ca5f19636e270c2d9" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt;&lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt; &lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="3905704a484368c3992190c17ec803f5c9734872" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt;&lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">인수가 0이거나 비정규이면 결과는 &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt; &lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1입니다.</target>
        </trans-unit>
        <trans-unit id="65b605eea787dfcd26a427a347ea4ad7abd516d5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="82de080d3a1d56fdbaf695d271e223d79695fa9d" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="368d7952fccceed4084cffb62407a857e1140ff5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="e43dae92e6e1f445b98367ed57735c6219a0d0f9" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt; 입니다 .MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="5db3ba052bf056b3adf9c2be7e6188d33a4e952e" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">인수가 0이면 결과는 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8d665f9570f8b5f180ad4bdb572f1e1aab98bad" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is a zero with the same sign as the argument.</source>
          <target state="translated">인수가 0이면 결과는 인수와 같은 부호를 갖는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d1f82cc652138d856ee89a85be827d630ca9f31c" translate="yes" xml:space="preserve">
          <source>If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</source>
          <target state="translated">인수 값이 이미 수학 정수와 같으면 결과는 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="38b3adaab247759b54b2aa2e88f5b5ce2609340f" translate="yes" xml:space="preserve">
          <source>If the argument value is less than zero but greater than -1.0, then the result is negative zero.</source>
          <target state="translated">인수 값이 0보다 작지만 -1.0보다 큰 경우 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="acfd94f24240c24943c8ec432b5700b6212aa09a" translate="yes" xml:space="preserve">
          <source>If the argument,</source>
          <target state="translated">인수가</target>
        </trans-unit>
        <trans-unit id="7b613ad1d7b1ad953ca4724e10cf0c2ca14a21e9" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 요소 유형이 원래 대상의 해당 인수 유형과 다른 경우, 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 호출로 배열 요소를 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c623454e44ca641a6c552859181a701097e3dda" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 유형이 원래 대상의 최종 인수 유형과 다른 경우 원래 대상은 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 을&lt;/a&gt; 호출하는 것처럼 배열 유형을 직접 가져 오도록 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="4389eb5f009bdfaeb30b67c701fdcfe35730fb30" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">이 클래스를로드하려고하면 &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt; 이 생성 되면 핸들러 검색은 목록의 다음 요소로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="3de2839318027a87b01d1160931d4ec1a7e54992" translate="yes" xml:space="preserve">
          <source>If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context.</source>
          <target state="translated">권한 구성 요소가 스펙에 존재하면 스펙이 절대 값으로 처리되고 스펙 권한 및 경로가 컨텍스트 권한 및 경로를 대체합니다. 권한 구성 요소가 스펙에 없으면 새 URL의 권한이 컨텍스트에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="bf5687cbde3be28238012b6e16935454ba496a38" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;cyclicbarrier#await--&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">장벽 조치가 실행될 때 일시 중단 된 당사자에 의존하지 않으면 당사자의 스레드 중 하나가 해제 될 때 해당 조치를 실행할 수 있습니다. 이것을 용이하게하기 위해, &lt;a href=&quot;cyclicbarrier#await--&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 의 각 호출은 장벽에서 해당 스레드의 도달 색인을 리턴합니다. 그런 다음 차단 작업을 실행할 스레드를 선택할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="dac9df73081697b7b7531c1d6a0b9c3e69c870d7" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">스레드가 대기 중일 때 장벽이 &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 이거나 &lt;code&gt;await&lt;/code&gt; 가 호출 될 때 장벽 &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;이 끊어 지거나&lt;/a&gt; 스레드가 대기 중일 때 &lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="575a83a87991707c167ff499c572b2c82c888c2d" translate="yes" xml:space="preserve">
          <source>If the bean also implemented the zero argument get listener method:</source>
          <target state="translated">Bean이 0 인수를 구현 한 경우 리스너 메소드를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="2c223aaa7bd3533fb82949d6d90648ac9350bba7" translate="yes" xml:space="preserve">
          <source>If the bean is a subtype of java.applet.Applet, then it is given some special initialization. First, it is supplied with a default AppletStub and AppletContext. Second, if it was instantiated from a classname the applet's &quot;init&quot; method is called. (If the bean was deserialized this step is skipped.)</source>
          <target state="translated">Bean이 java.applet.Applet의 하위 유형 인 경우 특수 초기화가 제공됩니다. 먼저, 기본 AppletStub 및 AppletContext가 제공됩니다. 둘째, 클래스 이름에서 인스턴스화 된 경우 애플릿의 &quot;init&quot;메소드가 호출됩니다. Bean이 직렬화 해제 된 경우이 단계는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="80874718dd7a5a6c0f974bdb517de9b9cdeaa788" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt; of those side-effects to other threads, nor are there any guarantees that different operations on the &quot;same&quot; element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">동작 매개 변수에 부작용이있는 경우 (특별히 언급되지 않는 한) 다른 스레드에 대한 부작용 의 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;가시성&lt;/i&gt;&lt;/a&gt; 에 대한 보장이 없으며 동일한 스트림 파이프 라인 내의 &quot;동일한&quot;요소에 대한 다른 조작이 보장되지 않습니다. 같은 스레드에서 실행됩니다. 또한 이러한 효과의 순서는 놀랍습니다. 파이프 라인이 스트림 소스의 발생 순서와 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 생성하도록 제한되는 경우에도 (예 : &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 는 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; 생성해야합니다 .)의 경우 매퍼 함수가 개별 요소에 적용되는 순서 또는 특정 요소에 대해 동작 매개 변수가 실행되는 스레드에 대해서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f00562687194200d7d3d4e8dbcd71f247eefddae" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one. This method should be called by subclasses at the beginning of the &lt;code&gt;write(int)&lt;/code&gt; and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods.</source>
          <target state="translated">비트 오프셋이 0이 아닌 경우 현재 바이트의 나머지 비트를 0으로 강제하고 스트림 위치를 1 씩 증가시킵니다. 이 메소드는 &lt;code&gt;write(int)&lt;/code&gt; 및 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 메소드 시작시 서브 클래스에 의해 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="92b946e43c30c152e86047538b9789992732b7fc" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="a17bf4b09c9d50c7630d0558298715e241010710" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">스트림 내의 비트 오프셋이 0이 아닌 경우, 현재 바이트의 나머지는 0으로 채워지고 먼저 쓰여집니다. 쓰기 후 비트 오프셋은 0이됩니다. 구현 &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt; 의 flushBits 메소드를 사용하여 이를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c99084a7828ec1a975c99c15549a5685147fb7b" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">부울 시스템 특성 &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 기본 서브 타입 특수화에서 조작 할 때 기본 값의 복싱이 발생하면 진단 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="486a42feea23b408f730eefa4db49a5a9bbd4a21" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">달력 유형 인 경우 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;그레고리 변경 일&lt;/a&gt; 의 &lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 를가&lt;/a&gt; 로 설정되어 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 로 &lt;em&gt;예 기적&lt;/em&gt; 그레고리 안 달력. 주 정의 매개 변수도 &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;ISO 8601 표준과 호환되도록&lt;/a&gt; 설정되어 있습니다 . &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 로 작성된 &lt;code&gt;GregorianCalendar&lt;/code&gt; 의 &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aa913ecbed54558eb291f0922076e469c78e1e5a" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;methodhandle#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 사이트의 기호 유형 설명 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 메소드 핸들의 &lt;a href=&quot;methodhandle#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 과 정확히 일치 하면 호출은 invokeExact에 의한 것처럼 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8da6d1bbefc65f4e59f9e3250b8dcf1e6a450b67" translate="yes" xml:space="preserve">
          <source>If the call was executed on Windows, with SOURCE_PATH set to &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt;, a valid result would be a file object representing the file &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 SOURCE_PATH가 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt; 설정된 상태에서 호출이 실행 된 경우 유효한 결과는 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt; 파일을 나타내는 파일 객체입니다 . src \ share \ classes \ com \ sun \ tools \ javac \ resources \ compiler.properties &quot; .</target>
        </trans-unit>
        <trans-unit id="9bab532ba6bbba009ffbae752606d6da2e48286a" translate="yes" xml:space="preserve">
          <source>If the caller specifies a &lt;code&gt;null&lt;/code&gt; Subject and a &lt;code&gt;null&lt;/code&gt; value is permitted, the LoginContext instantiates a new Subject.</source>
          <target state="translated">호출자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 제목과 &lt;code&gt;null&lt;/code&gt; 값을 허용, LoginContext에 새로운 주제를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="269b3f0fe8fb44df4ce0a6fe047dfebd11282f41" translate="yes" xml:space="preserve">
          <source>If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.</source>
          <target state="translated">호출 메소드가 이름 지정된 특성을 검색하는 데 관심이있는 경우 요소를 테스트하여 프록시 클래스인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9253130a27a78e3a08350cf89cd42b9d30c402d8" translate="yes" xml:space="preserve">
          <source>If the certificate is of type X.509 and has a</source>
          <target state="translated">인증서가 X.509 유형이고 인증서가</target>
        </trans-unit>
        <trans-unit id="b697d0518cb0986befd095c4c07f371b7bc19eb6" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">채널이 이미 닫혀 있으면이 메소드는 즉시 리턴합니다. 그렇지 않으면 채널을 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="258471a2858a2bd50b28d36eb9c0232d73db11d8" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 멀티 캐스트 그룹의 구성원 인 경우 멤버 자격이 &lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt; 됩니다. 돌아 오면 &lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fca12487d5034313786755dfdbb1487ee9174606" translate="yes" xml:space="preserve">
          <source>If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready. Any readiness information previously recorded in the ready set is discarded.</source>
          <target state="translated">채널 키가 아직 선택된 키 세트에없는 경우 해당 키가 해당 세트에 추가되고 채널이 준비된 것으로보고 된 작업을 정확하게 식별하도록 준비된 작업 세트가 수정됩니다. 준비 세트에 이전에 기록 된 준비 정보는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a74fcb99fe153ea5c299a617e13d7e98b79feb03" translate="yes" xml:space="preserve">
          <source>If the character &lt;code&gt;oldChar&lt;/code&gt; does not occur in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence identical to the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, except that every occurrence of &lt;code&gt;oldChar&lt;/code&gt; is replaced by an occurrence of &lt;code&gt;newChar&lt;/code&gt;.</source>
          <target state="translated">문자 경우 &lt;code&gt;oldChar&lt;/code&gt; 는 문자 순서가 발생하지 않습니다이로 표현 &lt;code&gt;String&lt;/code&gt; 객체,이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 돌려 주어집니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 목적이 나타내는 문자 시퀀스와 동일한 문자 시퀀스 나타내 리턴 &lt;code&gt;String&lt;/code&gt; 마다 발생하는 것을 제외 객체 &lt;code&gt;oldChar&lt;/code&gt; 이 의 발생으로 대체 &lt;code&gt;newChar&lt;/code&gt; 에이 .</target>
        </trans-unit>
        <trans-unit id="7e2733b75e92ebe16a2ce70438529de312b56641" translate="yes" xml:space="preserve">
          <source>If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.</source>
          <target state="translated">문자에 숫자 값이 없으면 -1이 반환됩니다. 문자에 음이 아닌 정수 (예 : 분수 값)로 표현할 수없는 숫자 값이 있으면 -2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef817a66adab96584398608e88fbe1d608af344" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; 특성 이 설정된 경우이 함수는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;R&lt;/code&gt; 로의 캐스트가 검사되지 않은 ID 변환 인 것으로 추정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="497068c1a55f2d965c9c1d485ba0e4ac4c0bfb03" translate="yes" xml:space="preserve">
          <source>If the check fails we throw a SecurityException, otherwise we return normally.</source>
          <target state="translated">검사에 실패하면 SecurityException이 발생하고 그렇지 않으면 정상적으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f200f54b8913d720a0fc8f80cb58e7fb832b09" translate="yes" xml:space="preserve">
          <source>If the chronology makes active use of eras, such as &lt;code&gt;JapaneseChronology&lt;/code&gt; then the year-of-era will be validated against the era. For other chronologies, validation is optional.</source>
          <target state="translated">연대기가 &lt;code&gt;JapaneseChronology&lt;/code&gt; 와 같은 시대를 적극적으로 사용하는 경우 시대 를 기준으로 시대가 검증됩니다. 다른 연대기의 경우 유효성 검사는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="0c7a6047da53758486c24b6ceb6b4575875d974a" translate="yes" xml:space="preserve">
          <source>If the class implements the interface &lt;a href=&quot;dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; then the MBean is a Dynamic MBean. Note that the class &lt;code&gt;StandardMBean&lt;/code&gt; implements this interface, so this case applies to a Standard MBean or MXBean created using the class &lt;code&gt;StandardMBean&lt;/code&gt;.</source>
          <target state="translated">클래스가 &lt;a href=&quot;dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 MBean은 Dynamic MBean입니다. 클래스주의 &lt;code&gt;StandardMBean&lt;/code&gt; 이 인터페이스는,이 경우는 표준의 MBean 또는 MXBean의 적용 구현 클래스 사용하여 만든 &lt;code&gt;StandardMBean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="952c977645377144d1e9387499dba9c6a0e6f790" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type, or void,then this method returns null.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 또는 인터페이스 가 다른 클래스의 멤버 인 경우 선언 된 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체를 반환합니다 . 이 클래스 또는 인터페이스가 다른 클래스의 멤버가 아닌 경우이 메소드는 널을 리턴합니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스, 프리미티브 유형 또는 void를 나타내는 경우이 메소드는 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5149c7a2ea949082634b5eade9a189fb43ba3574" translate="yes" xml:space="preserve">
          <source>If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the &lt;b&gt;javax.management.builder.initial&lt;/b&gt; system property is reset to valid value.</source>
          <target state="translated">등록 정보가 가리키는 클래스를로드 할 수 없거나 MBeanServerBuilder의 유효한 서브 클래스에 해당하지 않으면 예외가 전파되고 &lt;b&gt;javax.management.builder.initial&lt;/b&gt; 시스템 등록 정보가 유효한 값으로 재설정 될 때까지 MBeanServer를 작성할 수 없습니다 &lt;b&gt;.&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a48f463646ddc67b0927be2d8f5a0d7e6779ec57" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">위의 단계를 사용하여 클래스를 찾았고 &lt;code&gt;resolve&lt;/code&gt; 플래그가 true 인 경우이 메소드는 결과 &lt;code&gt;Class&lt;/code&gt; 오브젝트 에서 &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="0cb1171375f133959d5fe66bf3b2a054030b8896" translate="yes" xml:space="preserve">
          <source>If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">클라이언트가 인쇄 작업에 JobPriority 속성을 지정하지 않고 프린터가 JobPriority 속성을 지원하는 경우 프린터는 구현 정의 기본 JobPriority 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8819695d5b9293144506d78213d046dbf29c7943" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">클라이언트가 인쇄 요청에이 속성을 제공하지 않고 프린터가이 속성을 지원하는 경우, 프린터는 작업 제출시 필요한 (구현 종속) 기본 JobHoldUntil 값을 사용해야합니다 (작업 처리에 필요한 경우 사용되는 대부분의 작업 템플리트 속성과는 달리) 시각).</target>
        </trans-unit>
        <trans-unit id="6f068094c0b9101658e1bd4638d11b46b0682d00" translate="yes" xml:space="preserve">
          <source>If the combiner has a void return, no result will be inserted, and the first &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">컴 바이 너에 void 리턴이 있으면 결과가 삽입되지 않으며 대상 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 컴 바이 너의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd33812eb44d59d69e1fa86993dc6c1b417f658" translate="yes" xml:space="preserve">
          <source>If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">결합기가 값을 반환하면 대상의 첫 번째 매개 변수 유형이 결합기의 반환 유형과 동일해야하며 대상의 다음 &lt;code&gt;N&lt;/code&gt; 매개 변수 유형이 결합기의 매개 변수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="700d0c6d66bdf7dd366a71fc298f1463af466dfa" translate="yes" xml:space="preserve">
          <source>If the comments argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt; character, the comments string, and a line separator are first written to the output stream. Thus, the &lt;code&gt;comments&lt;/code&gt; can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the &lt;code&gt;Writer&lt;/code&gt; and if the next character in comments is not character &lt;code&gt;#&lt;/code&gt; or character &lt;code&gt;!&lt;/code&gt; then an ASCII &lt;code&gt;#&lt;/code&gt; is written out after that line separator.</source>
          <target state="translated">comments 인수가 널이 아닌 경우 ASCII &lt;code&gt;#&lt;/code&gt; 문자, 주석 문자열 및 행 구분 기호가 먼저 출력 스트림에 기록됩니다. 따라서, &lt;code&gt;comments&lt;/code&gt; 식별 주석으로서 기능 할 수있다. 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r') 또는 주석에서 줄 바꿈 바로 다음에 오는 캐리지 리턴은 &lt;code&gt;Writer&lt;/code&gt; 가 생성 한 줄 구분자로 대체되며 다음 문자 인 경우 코멘트에서 문자 &lt;code&gt;#&lt;/code&gt; 또는 문자 가 아닙니다 &lt;code&gt;!&lt;/code&gt; 그런 다음 줄 구분 기호 뒤에 ASCII &lt;code&gt;#&lt;/code&gt; 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2c31ff2ad53aa80158077167d3c0952e042633e3" translate="yes" xml:space="preserve">
          <source>If the compression level is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.</source>
          <target state="translated">압축 수준이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 수준으로 사용 가능한 입력이 압축되고 플러시 될 수 있습니다. 새 레벨은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="392c53482c9474c39ea6e8d51c4ff85e2db64e08" translate="yes" xml:space="preserve">
          <source>If the compression strategy is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.</source>
          <target state="translated">압축 전략이 변경되면 다음에 &lt;code&gt;deflate&lt;/code&gt; 를 호출 하면 이전 전략으로 사용 가능한 입력이 압축됩니다 (플러시 될 수 있음). 새로운 전략은 해당 호출 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f881d8d4f5f09d46f8c2856b6d2d804f3ec96cc6" translate="yes" xml:space="preserve">
          <source>If the constructor completes normally, returns the newly created and initialized instance.</source>
          <target state="translated">생성자가 정상적으로 완료되면 새로 생성되고 초기화 된 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2aeb09eb6e0fcfe242a17792207492aa120605ac" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; CallbackHandler object (and a &lt;code&gt;null&lt;/code&gt; value is permitted), the LoginContext queries the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user.</source>
          <target state="translated">생성자 않으면 &lt;b&gt;하지&lt;/b&gt; CallbackHandler를 입력 매개 변수를 가지고, 또는 발신자 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 의 CallbackHandler 객체 (그리고 &lt;code&gt;null&lt;/code&gt; 값이 허용된다), LoginContext에는 쿼리 &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 의 기본 핸들러의 완전한 클래스 이름에 대한 보안 속성을 이행. 보안 특성이 설정되지 않은 경우 기본 모듈에는 사용자와 통신하는 데 사용할 CallbackHandler가 없습니다. 따라서 호출자는 구성된 모듈에 사용자를 인증하기위한 대체 수단이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="96edcc96b78112d3bb9f9d209b5477cb96759906" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; Configuration object, the constructor uses the following call to get the installed Configuration:</source>
          <target state="translated">생성자 않으면 &lt;b&gt;되지&lt;/b&gt; 구성 입력 매개 변수를 가지고, 또는 발신자가 지정하는 경우 &lt;code&gt;null&lt;/code&gt; 구성 객체를 생성자는 설치된 구성 얻기 위해 다음 호출을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="56ea3a3517b6a27cca0834c9f4eb544d3dc38d39" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject input parameter, the LoginContext instantiates a new Subject.</source>
          <target state="translated">생성자 에 Subject 입력 매개 변수 가 &lt;b&gt;없는&lt;/b&gt; 경우 LoginContext는 새 Subject를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="51d999e9fc75b0313b56adf5745b9fffcd061b50" translate="yes" xml:space="preserve">
          <source>If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.</source>
          <target state="translated">생성자가 CallbackHandler 입력 매개 변수를 갖는 경우 LoginContext는 호출자 지정 CallbackHandler 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1e00d077c5cc21a366671e33a8a738802bc618a" translate="yes" xml:space="preserve">
          <source>If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.</source>
          <target state="translated">생성자가 구성 입력 매개 변수를 가지고 있고 호출자가 널이 아닌 구성을 지정하면 LoginContext는 호출자 지정 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3de799a960e7be55aab3ca032d285e2179f3390f" translate="yes" xml:space="preserve">
          <source>If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.</source>
          <target state="translated">생성자에 Subject 입력 매개 변수가있는 경우 LoginContext는 호출자 지정 Subject 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8c9ed368492503e51fcc4ae43d3e8d4462771fd7" translate="yes" xml:space="preserve">
          <source>If the constructor's &lt;code&gt;accessible&lt;/code&gt; flag is not set, access checking is performed immediately on behalf of the lookup class.</source>
          <target state="translated">생성자의 &lt;code&gt;accessible&lt;/code&gt; 플래그가 설정되어 있지 않으면 조회 클래스 대신 즉시 액세스 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2473d04d22b81fa38fb3fac97ebfc248b300280e" translate="yes" xml:space="preserve">
          <source>If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of</source>
          <target state="translated">생성자의 선언 클래스가 정적이 아닌 컨텍스트의 내부 클래스 인 경우 생성자의 첫 번째 인수는 둘러싸는 인스턴스 여야합니다. 섹션 15.9.3 참조</target>
        </trans-unit>
        <trans-unit id="12ab1266a164c0f6072aaf95e501de64c7ac066d" translate="yes" xml:space="preserve">
          <source>If the containing type is a parameterized type, the number of type arguments must equal the number of &lt;code&gt;typeElem&lt;/code&gt;'s formal type parameters. If it is not parameterized or if it is &lt;code&gt;null&lt;/code&gt;, this method is equivalent to &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt;.</source>
          <target state="translated">포함하는 유형이 매개 변수화 된 유형 인 경우 유형 인수의 수는 &lt;code&gt;typeElem&lt;/code&gt; 의 공식 유형 매개 변수 수와 같아야합니다 . 파라미터 화되어 있지 않은 경우, 또는 &lt;code&gt;null&lt;/code&gt; 의 경우 ,이 메소드는 &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt; 와 동등합니다 .</target>
        </trans-unit>
        <trans-unit id="54595108c68c9e1528174df34d61161ee7d1002c" translate="yes" xml:space="preserve">
          <source>If the context is available and there is a security manager installed, the caller may require permission to access it or a security exception may be thrown. In a Java environment, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">컨텍스트가 사용 가능하고 보안 관리자가 설치되어 있으면 호출자에게 액세스 권한이 필요하거나 보안 예외가 발생할 수 있습니다. Java 환경에서 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드는 &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d873373059873c2f9dda2243106e00e462486c8" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">변환이 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'A'&lt;/code&gt; 이면 정밀도는 기수 포인트 뒤의 16 진수 수입니다. 정밀도가 제공되지 않으면 &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 모든 숫자 가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4920cb3a35e9ffdd181f2cc1c02598946a361975" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;, then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is &lt;code&gt;6&lt;/code&gt;. If the precision is &lt;code&gt;0&lt;/code&gt;, then it is taken to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">변환이 &lt;code&gt;'g'&lt;/code&gt; 또는 &lt;code&gt;'G'&lt;/code&gt; 이면 정밀도는 반올림 후 결과 크기에서 유효 자릿수의 총 수입니다. 정밀도가 지정되지 않은 경우 기본값은 &lt;code&gt;6&lt;/code&gt; 입니다. 정밀도가 &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;1&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="5b740696da8433363284a2a09b00def3e5dd32a1" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the base indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'X'&lt;/code&gt; 이고 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 플래그가 둘 다 제공된 경우 결과에 기본 표시기 ( 8 진 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;'0'&lt;/code&gt; 의 경우 '0') 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="8d9565e696ad547e1a513117ec394adf4606346c" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the radix indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">변환이 경우 &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'X'&lt;/code&gt; 와 모두 &lt;code&gt;'#'&lt;/code&gt; 및 &lt;code&gt;'0'&lt;/code&gt; 을 플래그 후 기수 (지시약 결과에는 주어진 &lt;code&gt;'0'&lt;/code&gt; 진수 및 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; 16 진수의 경우 0X &quot; ), 폭 (너비를 기준으로 한) 0, 값.</target>
        </trans-unit>
        <trans-unit id="f92ee64ab913667741eadac9533a1057cb848b90" translate="yes" xml:space="preserve">
          <source>If the count reaches zero then the method returns with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">카운트가 0에 도달하면 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf6135f725f6abcb2f61e9b10a4d1d32a5ee738" translate="yes" xml:space="preserve">
          <source>If the counter can wrap around its maximum value, the modulus needs to be specified. The modulus is the value at which the counter is reset to zero.</source>
          <target state="translated">카운터가 최대 값을 감쌀 수있는 경우 계수를 지정해야합니다. 계수는 카운터가 0으로 재설정되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b2012ddc4ebb24e7045b7a055ac3ae1d060dc81" translate="yes" xml:space="preserve">
          <source>If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations. If this difference is negative, the value of the derived gauge is incremented by the value of the modulus. The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">카운터 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 된 카운터 값의 차이로 계산됩니다. 이 차이가 음수이면 파생 게이지 값이 모듈러스 값만큼 증가합니다. 파생 게이지 값 (V [t])은 다음 방법을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="0f1b34ff7dc9bdfbc17c9da13d95b1516d17ebbc" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Receiver&lt;/code&gt; 작성 하여 기본 디바이스를 내재적으로 열면 디바이스는이 메소드에 의해 내재적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 단말기 &lt;code&gt;Receiver&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Receiver&lt;/code&gt; 역시 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ae995006fbd46da8baab1bfa646c3f1a74c6123" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;Transmitter&lt;/code&gt; 생성 하여 기본 장치를 암시 적으로 열면이 방법으로 장치가 암시 적으로 닫힙니다. 장치를 암시 적으로 연 다른 &lt;code&gt;Receiver&lt;/code&gt; 또는 &lt;code&gt;Transmitter&lt;/code&gt; 인스턴스에 의해 장치가 열린 상태로 유지 되지 않고 장치가 명시 적으로 열리지 않은 경우에도 마찬가지 입니다. 이 경우 장치 &lt;code&gt;Transmitter&lt;/code&gt; 에서 검색을 호출하여 명시 적으로 폐쇄 &lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; 를&lt;/a&gt; 상기 &lt;code&gt;Transmitter&lt;/code&gt; 도 폐쇄된다. 열기 / 닫기 동작에 대한 자세한 설명은 &lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt; 클래스 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c179704df7cb8ed1b3ce0d3934ef2876dfdab64" translate="yes" xml:space="preserve">
          <source>If the current capacity of this vector is less than &lt;code&gt;minCapacity&lt;/code&gt;, then its capacity is increased by replacing its internal data array, kept in the field &lt;code&gt;elementData&lt;/code&gt;, with a larger one. The size of the new data array will be the old size plus &lt;code&gt;capacityIncrement&lt;/code&gt;, unless the value of &lt;code&gt;capacityIncrement&lt;/code&gt; is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than &lt;code&gt;minCapacity&lt;/code&gt;, then the new capacity will be &lt;code&gt;minCapacity&lt;/code&gt;.</source>
          <target state="translated">이 벡터의 전류 용량보다 작 으면 &lt;code&gt;minCapacity&lt;/code&gt; 가 다음, 그 용량은 필드에서 유지 내부 데이터 배열로 대체함으로써 증가 &lt;code&gt;elementData&lt;/code&gt; 큰 하나. &lt;code&gt;capacityIncrement&lt;/code&gt; 값이 0보다 작거나 같지 않은 한 새 데이터 배열의 크기는 이전 크기 에 &lt;code&gt;capacityIncrement&lt;/code&gt; 가됩니다.이 경우 새 용량은 이전 용량의 두 배가됩니다. 그러나이 새 크기가 여전히 &lt;code&gt;minCapacity&lt;/code&gt; 보다 작 으면 새 용량은 &lt;code&gt;minCapacity&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="15aa95f18520c9768c5e75e2d00df5cd87e5c814" translate="yes" xml:space="preserve">
          <source>If the current count equals zero then nothing happens.</source>
          <target state="translated">현재 카운트가 0이면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94ee3549183c062116cda5b26a97df611673964" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</source>
          <target state="translated">현재 카운트가 0보다 크면 감소합니다. 새 개수가 0이면 모든 대기중인 스레드가 스레드 예약 목적으로 다시 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7db62e9957e4a583a5bb47860c808eb80b034b" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우, 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ac4173a35be7aa72f90b5ce9f676b82ef7108f" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:</source>
          <target state="translated">현재 카운트가 0보다 큰 경우 현재 스레드는 스레드 예약을 위해 비활성화되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e615f8a82085afa953ed38e8e8581f0bc679866" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf13f63814d624078b38288a8fd1cdef5534f01f" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately.</source>
          <target state="translated">현재 카운트가 0이면이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a37f29b7a24ab724ec62dade14ae458a9a6defe6" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">현재 메소드 핸들이 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;가변 arity&lt;/a&gt; 가 아닌 경우 현재 메소드 핸들이 리턴됩니다. 현재 메소드 핸들이 &lt;code&gt;asVarargsCollector&lt;/code&gt; 에 유효한 입력이 아니더라도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="c10541f1b7a87a46fca0e82cb887f1f5cdfbfc64" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types.</source>
          <target state="translated">현재 메소드가 가변 arity 메소드 인 경우 인수 목록 변환에는 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;다른 곳에 설명 된대로&lt;/a&gt; 여러 인수를 배열로 변환 및 수집하는 작업이 포함될 수 있습니다 . 다른 모든 경우에 모든 변환은 &lt;em&gt;pairwise&lt;/em&gt; 적용됩니다. 즉, 각 인수 또는 반환 값이 정확히 하나의 인수 또는 반환 값 (또는 반환 값 없음)으로 변환됩니다. 적용된 변환은 이전 및 새 메소드 핸들 유형의 해당 구성 요소 유형을 참조하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3234b563a8a8287e5245f9226141091af776f5ee" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback continues to the end of the sequence without looping, unless the loop end point is changed subsequently.</source>
          <target state="translated">이 메소드가 호출 될 때 현재 위치가 루프 종료점보다 큰 경우, 루프 종료 점이 이후에 변경되지 않는 한 반복없이 루프의 끝까지 재생이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="7e2a55a1a8bd4ad8685ae28cb47b45b0f898fa44" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback simply continues to the end of the clip without looping.</source>
          <target state="translated">이 메서드가 호출 될 때 현재 위치가 루프 끝점보다 크면 재생은 단순히 루프없이 클립의 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="53f9e2fbf2a84ba1f43f8095838a4643dc8b642a" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bea401fb42f3ffdcd05852cff501d885235ba3f7" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가 이미 쓰기 잠금을 보유한 경우 보유 횟수는 1 씩 증가하고 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5d5c6242f9711c787eadd91061f9abc9aef5a8f" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">현재의 thread가 벌써이 락을 보관 유지하는 경우, 홀드 카운트는 1 씩 증가 해 메소드는 &lt;code&gt;true&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e1db59e340b43fddf7a6d53a8527759fc071b7e9" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">현재 스레드가이 잠금을 이미 보유하고 있으면 보유 횟수가 1 씩 증가하고 메소드가 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c86b44509cfe15cabcfd2d4aab1300bc1d4ef97f" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허가를 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하지만 스레드에 허가가 할당 된 시간은 중단이 발생하지 않은 허가를받은 시간과 비교하여 변경 될 수 있습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="40fca319282952e93dfb024ecdef67ea1fa9292a" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">허용을 기다리는 동안 현재 스레드가 &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;중단&lt;/a&gt; 되면 계속 대기하며 큐의 위치는 영향을받지 않습니다. 스레드가이 메소드에서 복귀하면 인터럽트 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b1885c7979cce95514869fcb5fe52518650ad751" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">현재 스레드가 대기하기 전 또는 대기중인 스레드에 의해 &lt;a href=&quot;thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 된 경우 &lt;code&gt;InterruptedException&lt;/code&gt; 이 발생합니다. 이 예외는이 객체의 잠금 상태가 위에서 설명한대로 복원 될 때까지 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ed769eb7f1d50760a5de23563feab0d013a7eb" translate="yes" xml:space="preserve">
          <source>If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:</source>
          <target state="translated">현재 스레드가 마지막으로 도착하지 않은 경우 스레드 스케줄링을 위해 비활성화되고 다음 중 하나가 발생할 때까지 휴면 상태입니다.</target>
        </trans-unit>
        <trans-unit id="644fbda54838e93f9bd7f153a0b223117b46c3c3" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">현재 스레드가 ForkJoinPool에서 작동중인 경우, 현재 스레드에 의해 대기 중이지만 아직 실행되지 않은 다음 작업 (사용 가능한 경우 또는 사용 가능한 경우 다른 스레드에 의해 분기 된 작업)을 실행하지 않고 예약을 취소하고 반환합니다. 가능한 경우. 가용성은 일시적 일 수 있으므로 &lt;code&gt;null&lt;/code&gt; 결과가이 작업이 실행중인 풀의 정지를 의미하지는 않습니다.이 방법은 주로 확장을 지원하도록 설계되었으며 다른 방법으로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d049c03bd38570f1b5a5d1aad9ff5cbfe4db5f0" translate="yes" xml:space="preserve">
          <source>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">현재 스레드가이 잠금의 홀더 인 경우 보류 횟수가 감소합니다. 보류 카운트가 이제 0이면 잠금이 해제됩니다. 현재 스레드가이 잠금의 홀더가 아닌 경우 &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2cbfc6598ed6d1e50de22bbc3b671f7d2bef7cad" translate="yes" xml:space="preserve">
          <source>If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.</source>
          <target state="translated">현재 스레드가 마지막으로 도착한 스레드이고 생성자에 널이 아닌 배리어 조치가 제공된 경우 현재 스레드는 다른 스레드가 계속되도록 조치를 실행합니다. 장벽 동작 중에 예외가 발생하면 해당 예외가 현재 스레드에서 전파되고 장벽이 파손 된 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="480b46196b0983b7baf6bc149cb22ece25ccb0df" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">현재 스레드의 인터럽트 상태가이 메소드에 진입 할 때 설정되거나 대기하는 동안 &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;인터럽트&lt;/a&gt; 되면 신호가 날 때까지 계속 대기합니다. 이 메소드에서 마지막으로 리턴 될 때 인터럽트 된 상태는 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ceafb860d280bdbbb95ef180a5ebfa010ab70b" translate="yes" xml:space="preserve">
          <source>If the current thread:</source>
          <target state="translated">현재 스레드가</target>
        </trans-unit>
        <trans-unit id="a766629228a237157e338578f73608fe87ee3533" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number. The current token is a number when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">현재 토큰이 숫자 인 경우이 필드에는 해당 숫자의 값이 포함됩니다. 현재 토큰은 &lt;code&gt;ttype&lt;/code&gt; 필드 의 값 이 &lt;code&gt;TT_NUMBER&lt;/code&gt; 일 때의 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="6e1d9b63def477efdc3e54487d9fe89e9c35bd3c" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token. When the current token is a quoted string token, this field contains the body of the string.</source>
          <target state="translated">현재 토큰이 단어 토큰 인 경우이 필드에는 단어 토큰의 문자를 제공하는 문자열이 포함됩니다. 현재 토큰이 인용 문자열 토큰 인 경우이 필드에는 문자열 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a247e695dc806480de65475cdb7e49df5eec14fe" translate="yes" xml:space="preserve">
          <source>If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5735c07ca103e22b6407b4ed7457c3834e66f98c" translate="yes" xml:space="preserve">
          <source>If the day-of-week is not available to format or parse then jump to day-of-month.</source>
          <target state="translated">요일을 형식화하거나 구문 분석 할 수없는 경우에는 요일로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa93f2a463d291904aa277d4928f5e5cc774981" translate="yes" xml:space="preserve">
          <source>If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching. Likewise, a system admin can configure a different negative caching TTL value when needed.</source>
          <target state="translated">기본 동작이 필요하지 않은 경우, 긍정적 인 캐싱을 위해 Java 보안 특성을 다른 TTL (Time-to-live) 값으로 설정할 수 있습니다. 마찬가지로, 시스템 관리자는 필요할 때 다른 네거티브 캐싱 TTL 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2cac5e3a466b13ae80c01fca973dcf37b93b686" translate="yes" xml:space="preserve">
          <source>If the descriptor is empty the following String is returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;</source>
          <target state="translated">디스크립터가 비어 있으면 다음 문자열이 리턴됩니다. &amp;lt;Descriptor&amp;gt; &amp;lt;/ Descriptor&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3e04d7b4037ef0253d1eb9639910efd968b0cd89" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">원하는 멤버가 &lt;code&gt;protected&lt;/code&gt; 되는 경우 조회 클래스가 원하는 멤버와 동일한 패키지에 있어야하거나 해당 멤버를 상속해야한다는 요구 사항을 포함하여 일반적인 JVM 규칙이 적용됩니다. (Java Virtual Machine 사양, 섹션 4.9.2, 5.4.3.5 및 6.4를 참조하십시오.) 또한 원하는 멤버가 정적이 아닌 필드 또는 다른 패키지의 메소드 인 경우 결과 메소드 핸들은 조회 클래스의 객체 또는 해당 서브 클래스 중 하나 이 요구 사항은 &lt;code&gt;this&lt;/code&gt; 매개 변수 의 선행 유형을 &lt;code&gt;C&lt;/code&gt; (조회 클래스의 수퍼 클래스 임)에서 조회 클래스 자체 로 좁 히면 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f1759b66bcf0473ca1f75eb77e287f807f0be61" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 반환 한 입력 스트림을 사용하여 하위 프로세스의 오류 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b68154bc9bb15cf5c833579d040cf02c8940944f" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">대상이 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 입력 스트림을 사용하여 서브 프로세스의 표준 출력을 읽을 수 있습니다 . 대상이 다른 값으로 설정된 경우 &lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5814c260a49a2bf524faa7ed1d2bd24188a54959" translate="yes" xml:space="preserve">
          <source>If the destination's &lt;code&gt;append()&lt;/code&gt; method never throws &lt;code&gt;IOException&lt;/code&gt;, then this method will always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">목적지의 &lt;code&gt;append()&lt;/code&gt; 메소드가 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키지 않는 경우 ,이 메소드는 항상 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ec907f76145e8ddd032cdc8267ff559cc1c48182" translate="yes" xml:space="preserve">
          <source>If the digit is less than 10, then &lt;code&gt;'0' + digit&lt;/code&gt; is returned. Otherwise, the value &lt;code&gt;'a' + digit - 10&lt;/code&gt; is returned.</source>
          <target state="translated">숫자가 10보다 작 으면 &lt;code&gt;'0' + digit&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 값 &lt;code&gt;'a' + digit - 10&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d397471c9fa609642a9cc71822d0d3db3f61ef8d" translate="yes" xml:space="preserve">
          <source>If the directory does not support a string representation of some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that accepts filter arguments in the form of Objects can be used instead. The service provider for such a directory would then translate the filter arguments to its service-specific representation for filter evaluation. See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.</source>
          <target state="translated">디렉토리가 일부 또는 모든 속성의 문자열 표현을 지원하지 않으면 Objects 형식의 필터 인수를 허용 하는 &lt;code&gt;search&lt;/code&gt; 형식을 대신 사용할 수 있습니다. 그런 디렉토리에 대한 서비스 제공자는 필터 인수를 필터 평가를 위해 서비스 특정 표시로 변환합니다. 참조 &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="762fcdd3511f74261ffaaa36150e2a54b62d2512" translate="yes" xml:space="preserve">
          <source>If the domain includes at least one occurrence of the wildcard characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">도메인에 와일드 카드 문자 별표 ( &lt;code&gt;*&lt;/code&gt; ) 또는 물음표 ( &lt;code&gt;?&lt;/code&gt; )가 하나 이상 포함 된 경우 객체 이름은 패턴입니다. 별표는 0 개 이상의 문자 시퀀스와 일치하고 물음표는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b1cec24c27c8efb590156606b357f3a860a3a802" translate="yes" xml:space="preserve">
          <source>If the domain is empty, it will be replaced in certain contexts by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the ObjectName is used.</source>
          <target state="translated">도메인이 비어있는 경우 특정 컨텍스트 에서 ObjectName이 사용되는 MBean 서버 의 &lt;em&gt;기본 도메인&lt;/em&gt; 으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="166569c27e8b2a7656f585d48975b7df17589d30" translate="yes" xml:space="preserve">
          <source>If the encoding has an historical name then that name is returned; otherwise the encoding's canonical name is returned.</source>
          <target state="translated">인코딩에 히스토리 이름이 있으면 해당 이름이 리턴됩니다. 그렇지 않으면 인코딩의 정식 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48c3f477e37a6d7f2bde864091bbef88c4c21567" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">모든 비트를 읽기 전에 스트림의 끝에 도달하면 &lt;code&gt;java.io.EOFException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2217350c5c68b3e5ab4a98715b4b5c48f6366d39" translate="yes" xml:space="preserve">
          <source>If the entire string has been read or skipped, then this method has no effect and always returns 0.</source>
          <target state="translated">전체 문자열을 읽거나 건너 뛴 경우이 메서드는 적용되지 않으며 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ece76de2aa9cb829e9b2c9714827801ca68dc1f" translate="yes" xml:space="preserve">
          <source>If the entry being considered was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the given certificate is compared to the first element of that entry's certificate chain.</source>
          <target state="translated">항목이 호출에 의해 생성 된 것으로 간주되는 경우 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 다음 지정된 인증서는 그 엔트리의 인증서 체인의 첫 번째 요소로 비교된다.</target>
        </trans-unit>
        <trans-unit id="0a00a113b23cd107c1f980e1846beabb40469342" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">항목이 ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력되는 경우이 방법으로 설정된 마지막 수정 시간 은 zip 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되고 표준 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 인코딩 됩니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 는 MS-DOS 데이터와 시간에 신기원 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ccafee62ee3362796ffa2f54139e7599780958" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우, 이것은 ZIP 파일 항목 의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간입니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 신기원 시간에 표준 MS-DOS 형식의 날짜와 시간을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b289b42cb002e533856d62e0fbbde21b7d11a5b" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 입력 스트림에서 항목을 읽는 경우 확장 된 시간 소인 필드가있는 경우 ZIP 파일 항목의 &lt;code&gt;optional extra data&lt;/code&gt; 에서 마지막 수정 시간입니다 . 그렇지 않으면 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에서 마지막 수정 시간을 읽습니다 . &lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt; 은 표준 MS-DOS 형식의 날짜 및 시간을 에포크 시간으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44db14d1e9cdb3209ffe191f5a2a3430583832df" translate="yes" xml:space="preserve">
          <source>If the event involved an exception, this will be the exception object. Otherwise null.</source>
          <target state="translated">이벤트에 예외가 포함 된 경우 예외 개체가됩니다. 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="e0292adc0114844d25fb79e16b7258d6d3885abd" translate="yes" xml:space="preserve">
          <source>If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.</source>
          <target state="translated">확장 클래스 로더를 찾을 수 없으면 시스템 클래스 로더가 사용됩니다. 시스템 클래스 로더가없는 경우 부트 스트랩 클래스 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6968b385e002c9508a424a478292c0f3a7af81" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the range of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 범위가 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c19fc73e0fc2d097b24a11cffd6f4ae4696359b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the value of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 이면 1에서 7까지의 요일 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="30d9439a6bb009c979b0800716929ef61f2bbd69" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 인&lt;/a&gt; 경우이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="326c5765ea79518cbefcc0303c7d41108e792d2b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the range of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 범위가 반환됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="af240bad736f05e53adae955dd58de67cb50462f" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the value of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면 1에서 12까지의 월 값이 리턴됩니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4fe971066ffd7c4b8626dd60c34bb8f8261cfed9" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 이면이 메소드는 true를 리턴합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cbe7e72fb8b0010865d68d0c08c6481722f84e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the range. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 필드의 범위를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="184058e0a14902aa21c927d78bf2821afd7ffb8f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the value of the era. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 시대의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1953db0f99dd40e5aaa224b3ed2d92f821f4fad2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;ERA&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5df5ba306c3a00473938e546303760434732261a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddb65541050763763b556e80a29c16db72c7248" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3692f941d5abe057e214a3bd9f234905a09651" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 에 일치하는 방법에 따라 작동합니다 &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt; . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1d4babbf0823e08d2dba83490653149a8a5cf2ed" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 조정이 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b3a122466042d935dfadf2919be12e5c6bf577cb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2fae4d33d968604493905d86ff128c82e5db2f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 발생 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="552594823755dd323e34fbb36aa82bd02dc7ccec" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="64682870ad58c05c116e810cd345d87fe71b6bca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e53df72b9538f5704d56c85109a2837d5a0400cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 날짜를 기준으로 유효 값을 반환합니다 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="32c54db3dedc37f0421eb1580db3b740ec121cad" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 날짜를 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="11ea794a31defe3e3eefa9ea5db21eca50570400" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a90c6eb29cbac028e8449f9cf54d00261c219feb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외 일자와 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; 및 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5b5f3e15dbf7f02cadaff2b1f715b8a83fed50ca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2d7280f2ef05621f8965764c134012686323f8c9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a08bb7dfd7f2733af861740d800b7ce9f70eb5cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f2ea46b126ff3b5bdbf666ca3c46b71e50576dc7" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3f81a778997a088523214d2edc7a7aab7a300ca4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce1690eace7e2c6d89cc928ca7a7a051f9a8d0f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 달 일을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="54c277810f3ed7c547f4b1ad6fd3fb8f9a746292" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e764af5b165d57d63cb3a6753fd7d4d9d38420" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bbfa08249a8a681a77ac31ded9b0970961cb7e45" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="216d1b40d29dcd13ae455e39ff25a34173b680bc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="89af7f61649fef38a7f170c1bd0ab908cfde7464" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 를 제외하고이 시간을 기준으로 유효한 값을 반환합니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f135da292374c58a63e9a7dd6bf4f22cdbf128fc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 이 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="66a31e186370c87394aabeac098a9be857ade9fd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1a78917caede284548be462696171d8a8df88818" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해에 따라 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="638fba149e2f9605d4c8dd06cfefd8163837f176" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bc96611b6dd2d22d3132d6d3df53e51b38124d7a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 올해 개월을 기준으로 유효한 값을 반환합니다 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5f2e16d3207b8a1b377b13995b5829979baa3c06" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 올해 개월을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fda7020a7bae43a5df2b5286206bb91d72d039d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="88d03525f1042dd0011a22419c6df4c5121eba14" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 제외하고, 일자와 시간에 따라 유효한 값이 반환됩니다 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; , &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; , &lt;code&gt;EPOCH_DAY&lt;/code&gt; , &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 및 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 에 맞게 너무 커서 &lt;code&gt;int&lt;/code&gt; 와 던져 &lt;code&gt;DateTimeException&lt;/code&gt; 을 . 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a0124fd3059f644ca04188c31653732caf32a08f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 일자와 시간을 기준으로 유효한 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="0337a2eda7a472dc0aa83a7e1eef644d5a370e32" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt; 적절한 범위 인스턴스를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4046ccaca6ad2d1bf0b7e5c2e124396f1812f96d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns the value of the offset. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드 오프셋의 값을 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="09800c7a5d51ab3ac1ecbfa59a39761992b8d783" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt; 경우 여기에서 쿼리가 구현됩니다. &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 의 필드는 true를 반환합니다. 다른 모든 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdaaec98194652eaec2e755f354592d8a5f1fa2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 인&lt;/a&gt;여기에서 쿼리가 구현됩니다. 지원되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d8816d4bddc205a3c0266b4706842519edca858" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a927c94cc558aa44e673d3c09b5dede6b4bbec9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 추가는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 의해 구현됩니다. . 오프셋은 계산의 일부가 아니며 결과에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5cba436d7af3b0ad553fc0358e491b4ffeb23a3" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 날짜 단위는 &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가됩니다 . 시간 단위는 &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt; 따라 추가되며 , 일 수의 오버플로는 &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt; 사용과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87edabfd23bcd4b5580257d424970351a200d0e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The supported fields behave as follows:</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 지원되는 필드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d28f15788411edaf2c4769963134a70f9a51014" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The zone is not part of the calculation and will be unchanged in the result. The calculation for date and time units differ.</source>
          <target state="translated">필드가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에 추가가 구현됩니다. 영역은 계산의 일부가 아니며 결과에서 변경되지 않습니다. 날짜 및 시간 단위에 대한 계산이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="df5997d9cb9eb98daf0677e44c78da78084843dc" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is obtained according to the preceding rules.</source>
          <target state="translated">필드가 다음 유형으로 숨겨진 경우 &lt;code&gt;obj&lt;/code&gt; 지면 필드 값은 이전 규칙에 따라 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3cd0fa2a6c549544bf0fa17d3fe9a0bbdad3a534" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is set according to the preceding rules.</source>
          <target state="translated">필드가 &lt;code&gt;obj&lt;/code&gt; 유형에 숨겨져있는 경우 값은 이전 규칙에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f06458338d0982fde844f74e3eac7907ffd72d" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the field determines whether and how to adjust the instant.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로 . 이 경우 필드는 순간을 조정할지 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc13b792f3c5838d3770d636dc87567d506bc218" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="593408760a93df2aae450a2a246b1f8f655869de" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="84111e9c7052aea445fc84ff88640c7d9d47a3e1" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 값을 얻을 수 있는지 여부와 값이 나타내는 것은 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0976d6ec775eae314c44e1cc501085eba97650" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="8bfc158b937ea3897727206425819d75e46f302c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the field is supported is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 필드가 지원되는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7688528113c7572e4ebfde7d3d5c748187dbd155" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the range can be obtained is determined by the field.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 범위를 얻을 수 있는지 여부는 필드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9dc945edaeb99a9dd905b6958af0da2b698eb2ff" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoField&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="1bc2facd61e2bb2d253a7e2d751714a8d91fd304" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the unit determines whether and how to perform the addition.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 메소드의 결과를 호출하여 얻어진다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로. 이 경우 장치는 추가 수행 여부와 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3745b108d29fe526d4efe7b06863f59e4b41c30c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">필드가 없으면 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하여 얻어지는 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="73f48c353a2b4ef722c15d4cc5583b25df30a788" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">필드가 정적이고 리턴 된 메소드 핸들이 호출되면 필드의 클래스가 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="99de1988747f1a4d19117e077c897d899a759367" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">파일이 이미 존재하고 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우에는 길이가 0으로 잘립니다.이 옵션은 파일이 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 액세스 용으로 만 열린 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="717bfba6c0a90a03523ab0b13a3750e80f9e6288" translate="yes" xml:space="preserve">
          <source>If the file does not reside on a local device then no such guarantee is made.</source>
          <target state="translated">파일이 로컬 장치에 없으면 그러한 보증이 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c9b9ed3b31f95435fd26b9b50e781fb7b10f8ba" translate="yes" xml:space="preserve">
          <source>If the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">파일이 존재하지만 일반 파일이 아닌 디렉토리 인 경우 존재하지 않지만 작성할 수 없거나 다른 이유로 열 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f72ad9bda52a7b14dd7371372743b4037fafc486" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.</source>
          <target state="translated">파일이 디렉토리이면 디렉토리가 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c1117a6df1c8b656d3b8ee4f35129ed11c6504" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">파일이 디렉토리 인 경우 디렉토리는 비어 있어야합니다. 일부 구현에서 디렉토리에는 디렉토리 작성시 작성되는 특수 파일 또는 링크에 대한 항목이 있습니다. 이러한 구현에서 특수 항목 만 존재할 경우 디렉토리는 비어있는 것으로 간주됩니다. 이 메소드를 &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용 하여 디렉토리 및 디렉토리의 모든 항목 또는 전체를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dbd0c6e9ab04a8789ef0e83e00003ffa2ee9662" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">파일이 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 액세스를 위해 열린 경우 바이트는 시작이 아닌 파일의 끝에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d2a8154b6e04db066d371ce68d85675117b48d" translate="yes" xml:space="preserve">
          <source>If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.</source>
          <target state="translated">다른 프로그램이 쓰기 액세스를 위해 파일을 연 경우 파일 끝에 쓰는 것이 원자적인 경우 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="363aa2bf9bc4403e90b3304537b4850955de2d6f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">이 버퍼에 맵핑 된 파일이 로컬 저장 장치에 상주하는 경우이 메소드가 리턴 할 때 버퍼가 작성된 이후 또는이 메소드가 마지막으로 호출 된 이후에 버퍼에 대한 모든 변경 사항이 해당 디바이스에 기록되었음을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="5d3f80a7c47e0dee8ff25771e1984095801d55de" translate="yes" xml:space="preserve">
          <source>If the file system and files remain static, then this method implements an equivalence relation for non-null &lt;code&gt;Paths&lt;/code&gt;.</source>
          <target state="translated">파일 시스템과 파일이 정적으로 유지되면이 메소드는 널이 아닌 &lt;code&gt;Paths&lt;/code&gt; 대한 등가 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1cc09fc7cf4f903c9ad57909dbe23e700dcd6cfb" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 액세스 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; (1970-01-01T00 : 00)을 리턴합니다 . 00Z).</target>
        </trans-unit>
        <trans-unit id="fa544bd520d9dcec26b2ece7f7dc9e779d24b413" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현이 마지막 수정 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값 (일반적으로 신기원 (1970-01-01T00 : 00 : 00Z)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="823bb3918b8c7dfd2716375b3397ec3520a2d6b4" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">파일 시스템 구현에서 파일이 생성 된 시간을 나타내는 타임 스탬프를 지원하지 않는 경우이 메소드는 구현 특정 기본값, 일반적으로 &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt; 또는 신기원 (1970-01-01T00)을 나타내는 &lt;code&gt;FileTime&lt;/code&gt; 을 리턴합니다 . 00 : 00Z).</target>
        </trans-unit>
        <trans-unit id="cbaa60988de0c25a04ce29dd95934e886dae24fd" translate="yes" xml:space="preserve">
          <source>If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt; parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt;&lt;code&gt;OVERFLOW&lt;/code&gt;&lt;/a&gt; event. This event is not required to be present in the array of events.</source>
          <target state="translated">이 오브젝트에 의해 식별 된 파일 시스템 오브젝트가 현재 감시 서비스에 등록 된 경우, 이벤트 세트 또는 수정자를 &lt;code&gt;events&lt;/code&gt; 및 &lt;code&gt;modifiers&lt;/code&gt; 매개 변수에 의해 지정된 것으로 변경 한 후 해당 등록을 나타내는 감시 키가 리턴 됩니다. 이벤트 세트를 변경해도 오브젝트의 보류중인 이벤트가 삭제되지 않습니다. &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt; &lt;code&gt;OVERFLOW&lt;/code&gt; &lt;/a&gt; 이벤트에 객체가 자동으로 등록됩니다 . 이 이벤트는 이벤트 배열에 존재할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="459754495e8f2fc830a24baaf3d7fd1c98e3b5d4" translate="yes" xml:space="preserve">
          <source>If the file system supports &lt;a href=&quot;package-summary#links&quot;&gt;symbolic links&lt;/a&gt; then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned &lt;code&gt;Path&lt;/code&gt; object will be associated with the same file system as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">파일 시스템이 &lt;a href=&quot;package-summary#links&quot;&gt;기호 링크&lt;/a&gt; 를 지원하는 경우이 방법은 링크 대상을 읽는 데 사용되며 파일이 기호 링크가 아닌 경우 실패합니다. 링크의 대상이 없어도됩니다. 리턴 된 &lt;code&gt;Path&lt;/code&gt; 오브젝트는 &lt;code&gt;link&lt;/code&gt; 와 동일한 파일 시스템과 연관 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7347290370c35baf47e41039a48176f518ba6b9" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">파일 시스템이 다른 보안 관련 파일 속성 (예 : 파일 &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt; 등)을 지원 하는 경우 액세스 제어 목록을 업데이트하면 이러한 보안 관련 속성도 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f05868501904493829d0907142a7754fe1122ce" translate="yes" xml:space="preserve">
          <source>If the filter returns a value, the target must accept that value as its argument in position &lt;code&gt;pos&lt;/code&gt;, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter.</source>
          <target state="translated">필터가 값을 반환하는 경우 대상은 해당 값을 위치 &lt;code&gt;pos&lt;/code&gt; 의 인수로, 필터에 전달되지 않은 인수 앞에 와야합니다. 필터가 void를 반환하면 대상은 필터에 전달되지 않은 모든 인수를 허용해야합니다. 다시 정렬 된 인수는 없으며 필터에서 리턴 된 결과는 원래 어댑터로 전달 된 인수의 전체 서브 시퀀스를 (순서대로) 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4842b7ba908041edda9019cd8af48573f8706e76" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of bytes actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="33b359247ef4ee2d114342c7c506f4ed4d411b51" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of characters actually read.</source>
          <target state="translated">기본 스트림 의 첫 번째 &lt;code&gt;read&lt;/code&gt; 에서 파일 끝을 나타 내기 위해 &lt;code&gt;-1&lt;/code&gt; 을 반환 하면 이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 그렇지 않으면이 메소드는 실제로 읽은 문자 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ce60218f2510c7e7fddf8a7ccb70e4c23d7ed409" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN and the second argument is nonzero, then the result is NaN.</source>
          <target state="translated">첫 번째 인수가 NaN이고 두 번째 인수가 0이 아닌 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="8870d606c771442922f1503139366f1c5f6ffb42" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN, NaN is returned.</source>
          <target state="translated">첫 번째 인수가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9089269bb48d32b9328e7c9f2b5e776cab13b138" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and less than zero</source>
          <target state="translated">첫 번째 인수가 유한하고 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="40390f7aa327fdf0e7159e3c2ee52c76dda4cc5d" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.</source>
          <target state="translated">첫 번째 인수가 유한하고 두 번째 인수가 무한하면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="c79e66b15f81ddc9a951871c47a016d3318d1439" translate="yes" xml:space="preserve">
          <source>If the first argument is infinite, then an infinity of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 무한대이면 동일한 부호의 무한대가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7d4927f7484d5a09a609cfa4c9572e1d2c7f45" translate="yes" xml:space="preserve">
          <source>If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 음의 무한대이고 두 번째 인수가 유한이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8e4a59b27a1fe3d520aae3637f149a7db9573ea" translate="yes" xml:space="preserve">
          <source>If the first argument is negative infinity and the second argument is positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음의 무한대이고 두 번째 인수가 양의 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="82b10d31a7012b44b539ae72f08e4e4c13a206b9" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">첫 번째 인수가 음수이고 두 번째 인수가 음수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 -에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="8e475337333e7011c577f6dfd579b80f0f2ae245" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero.</source>
          <target state="translated">첫 번째 인수가 음수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 음수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 음의 0입니다.</target>
        </trans-unit>
        <trans-unit id="e71c64d3bcd633902a2d641246fcfc98d2800c74" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002D'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 문자 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002D'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f757bab2a5b1e8678119d7c70a633d7f48cfbb1b" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus sign &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">첫 번째 인수가 음수이면 결과의 첫 번째 요소는 ASCII 빼기 기호 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )입니다. 첫 번째 인수가 음수가 아닌 경우 결과에 부호 문자가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be73a6c34da2b109aed6beaf3902ff7b8fa1d76b" translate="yes" xml:space="preserve">
          <source>If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수이고 두 번째 인수가 양수 0 또는 음수 0이거나 첫 번째 인수가 양의 무한대이고 두 번째 인수가 유한이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="ebb6e09520d0766b54210b09e064a33ea2e4b570" translate="yes" xml:space="preserve">
          <source>If the first argument is positive infinity and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to 3*</source>
          <target state="translated">첫 번째 인수가 양의 무한대이고 두 번째 인수가 음의 무한대이면 결과는 3 *에 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="a545d4a869ce0070ee3a2c5a7bd5c19feeb5e959" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 음수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 음수 무한대이면 결과는 가장 가까운 &lt;code&gt;double&lt;/code&gt; 값입니다</target>
        </trans-unit>
        <trans-unit id="2b99cd366559b0aa882f76d5433c550ae23a29d2" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero.</source>
          <target state="translated">첫 번째 인수가 양수 0이고 두 번째 인수가 양수이거나 첫 번째 인수가 양수이고 유한하며 두 번째 인수가 양수 무한대이면 결과는 양수 0입니다.</target>
        </trans-unit>
        <trans-unit id="90dbabf1b114fed471b1a3cd65fc77c1740f1756" translate="yes" xml:space="preserve">
          <source>If the first argument is zero, then a zero of the same sign is returned.</source>
          <target state="translated">첫 번째 인수가 0이면 동일한 부호의 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1663731875dc28dccca70ad4bb3ad9c2ee28bff" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of just that byte. The byte is zero-extended to form a character.</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;0xxxxxxx&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; 는 &quot; &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 일 수 있음&quot;을 의미 함) 와 일치하면 그룹은 해당 바이트 로만 구성됩니다. 바이트는 0 확장되어 문자를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="43977f5f9b49b5f068ba277caf7c1c9b82cc82fa" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;110xxxxx&lt;/code&gt; 와 일치 하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 두 번째 바이트 &lt;code&gt;b&lt;/code&gt; 로 구성 됩니다. 더 바이트가없는 경우 &lt;code&gt;b&lt;/code&gt; 를 (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 읽을 수 바이트의 마지막), 또는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 는 비트 패턴과 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 , 다음 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e5e1a187c24e47368e1814e48c4f2e5999e848" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. If there is no byte &lt;code&gt;c&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">그룹의 첫 번째 바이트가 비트 패턴 &lt;code&gt;1110xxxx&lt;/code&gt; 와 일치하면 그룹은 해당 바이트 &lt;code&gt;a&lt;/code&gt; 와 2 개 이상의 바이트 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 로 구성 됩니다. 아무 바이트 없으면 &lt;code&gt;c&lt;/code&gt; (바이트 때문에 &lt;code&gt;a&lt;/code&gt; 판독 될 바이트의 마지막 2 중 하나), 또는 두 바이트 &lt;code&gt;b&lt;/code&gt; 또는 바이트 &lt;code&gt;c&lt;/code&gt; 비트 패턴에 일치하지 않는 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생합니다. 그렇지 않으면 그룹이 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4205a0b70ecc18a1f7d17bb4cefe1ef7847e2c" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.</source>
          <target state="translated">그룹의 선두 바이트는 패턴과 일치하는 경우 &lt;code&gt;1111xxxx&lt;/code&gt; 또는 패턴 &lt;code&gt;10xxxxxx&lt;/code&gt; 에 당시로서는, &lt;code&gt;UTFDataFormatException&lt;/code&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="fe4bd2bc924f289ce5e3e243830c506290c8bfa3" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;abstractpreferences#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 첫 번째 문자 가 &lt;code&gt;'/'&lt;/code&gt; (절대 경로 이름을 나타냄) 인 경우 &lt;code&gt;path&lt;/code&gt; 를 토큰으로 나누기 전에이 환경 설정 노드의 잠금이 삭제 되고이 메소드는 루트에서 시작하여 (이 노드에서 시작하지 않고) 경로를 재귀 적으로 탐색합니다. 통과는 상대 경로 이름에 대해 설명한 것과 동일합니다. 루트 노드에서 순회를 시작하기 전에이 노드에서 잠금을 삭제하는 것은 &lt;a href=&quot;abstractpreferences#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt; 따라 교착 상태의 가능성을 피하기 위해 필수적입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="de6a756f5a999d243dc3d549609d91cce131f2d6" translate="yes" xml:space="preserve">
          <source>If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the &lt;code&gt;CompositeData&lt;/code&gt; beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called &lt;code&gt;getNumber()&lt;/code&gt;, the handler will first look for an item called &lt;code&gt;Number&lt;/code&gt;, then for &lt;code&gt;number&lt;/code&gt;. If the getter is called &lt;code&gt;getnumber()&lt;/code&gt;, then the item must be called &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">getter에 의해 정의 된 속성의 첫 글자가 대문자 인 경우,이 핸들러는 먼저 &lt;code&gt;CompositeData&lt;/code&gt; 에서 대문자로 시작하는 항목을 찾은 다음 찾지 못하면 해당 소문자로 시작하는 항목 또는 코드 포인트. &lt;code&gt;getNumber()&lt;/code&gt; 라는 getter의 경우 핸들러는 먼저 &lt;code&gt;Number&lt;/code&gt; 라는 항목을 찾은 다음 &lt;code&gt;number&lt;/code&gt; 를 찾습니다 . getter가 &lt;code&gt;getnumber()&lt;/code&gt; 이면 항목을 &lt;code&gt;number&lt;/code&gt; 라고해야합니다. .</target>
        </trans-unit>
        <trans-unit id="c5b9fdddf990174b0c1bb31fd056338ffdb9f842" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C ++ 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b755352a37aefb0ddd22fcf4ddac56889ee380f" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments are not treated specially.</source>
          <target state="translated">플래그 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 인 경우 C 스타일 주석은 특별히 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed5b11ba23b450c90177463610accda7b5ef8311" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;sval&lt;/code&gt; field is not modified.</source>
          <target state="translated">flag 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우, &lt;code&gt;sval&lt;/code&gt; 필드는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a51b936e9c60259867a0c6a0a1415a7006e73bc6" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 구분 문자는 토큰을 분리하는 데 사용됩니다. 토큰은 분리 문자가 아닌 최대 연속 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="243de70bc00db3702139f3dd218555f6b229e223" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">플래그가 &lt;code&gt;true&lt;/code&gt; 인 경우 구분 문자 자체는 토큰으로 간주됩니다. 따라서 토큰은 하나의 분리 문자이거나 분리 문자가 아닌 연속 된 최대 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="f77a5cbbfc5e7d2a5c0ad6a18e49115f1c49efaa" translate="yes" xml:space="preserve">
          <source>If the format of an argument loses information, such as with a choice format where a large number formats to &quot;many&quot;.</source>
          <target state="translated">인수 형식이 정보를 잃는 경우 (예 : 다수가 &quot;많은&quot;형식 인 선택 형식).</target>
        </trans-unit>
        <trans-unit id="0dcd3261c6e6bc40c628cfcd3ed02c38b9a8ba09" translate="yes" xml:space="preserve">
          <source>If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a &lt;a href=&quot;illegalformatwidthexception&quot;&gt;&lt;code&gt;IllegalFormatWidthException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; respectively will be thrown.</source>
          <target state="translated">형식 지정자가 유효하지 않은 값을 가진 너비 또는 정밀도를 포함하거나 지원되지 않는 경우 &lt;a href=&quot;illegalformatwidthexception&quot;&gt; &lt;code&gt;IllegalFormatWidthException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt; 각각 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="23d86bd64d57a83827a905eb3f62752e01b0a38e" translate="yes" xml:space="preserve">
          <source>If the formatter parses the same field more than once with different values, the result will be an error.</source>
          <target state="translated">포맷터가 다른 값으로 동일한 필드를 두 번 이상 구문 분석하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db3731fc2aa4a3e087228df78b6ed03888b9aa5c" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 매핑이 기록되지 않습니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 매핑이 기록되지 않습니다. 가장 일반적인 사용법은 다음과 같이 초기 매핑 값 또는 메모 결과로 제공되는 새 객체를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="144af7e618eb46c9529d1d33c26d53810f2167da" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하는 경우 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26f473bb6caf3da04b1285866c6a28b1b984ef5f" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다 (또는 처음에없는 경우 부재 상태로 유지됨). 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91e50d7000baf56cbe84741a636dedc280c25287" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">함수가 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 매핑이 제거됩니다. 함수 자체에서 (확인되지 ​​않은) 예외가 발생하면 예외가 다시 발생하고 현재 매핑은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="926782c512e4f063b419e0421193c8c7a7433138" translate="yes" xml:space="preserve">
          <source>If the function succeeds, instrument &lt;code&gt;from&lt;/code&gt; is unloaded.</source>
          <target state="translated">기능이 성공하면 계측기 &lt;code&gt;from&lt;/code&gt; 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="32a91e07ee88bec0b9954a59c4de099b9aa8f328" translate="yes" xml:space="preserve">
          <source>If the garbage collector determines at a certain point in time that the referent of a phantom reference is &lt;a href=&quot;package-summary#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that time or at some later time it will enqueue the reference.</source>
          <target state="translated">가비지 콜렉터가 특정 시점에서 팬텀 참조의 참조가 &lt;a href=&quot;package-summary#reachability&quot;&gt;팬텀에 도달 할 수&lt;/a&gt; 있다고 판단하는 경우 해당 시간 또는 나중에 나중에 참조를 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="53adf0e26e84566de9caa7cabb62afdabd38f865" translate="yes" xml:space="preserve">
          <source>If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.</source>
          <target state="translated">게이지 차이 모드를 사용하는 경우 파생 게이지 값은 두 개의 연속 관측치에 대한 관측 게이지 값의 차이로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f36edc06d9e8ab3918e6499129015f8c141e7e54" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, an unchecked exception is thrown from &lt;code&gt;parallelSetAll&lt;/code&gt; and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 &lt;code&gt;parallelSetAll&lt;/code&gt; 에서 검사되지 않은 예외가 발생 하고 배열이 미확인 상태로 남습니다.</target>
        </trans-unit>
        <trans-unit id="9d8173ed15e9b7709fd7094f05762f38b139637d" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</source>
          <target state="translated">생성기 함수에서 예외가 발생하면 호출자에게 릴레이되고 배열은 알 수없는 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e16e73e1c388c5bcfaf11ed9189d8791a0ccfd7" translate="yes" xml:space="preserve">
          <source>If the given &lt;var&gt;inModelMBeanInfo&lt;/var&gt; does not contain any &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;GENERIC&lt;/code&gt; or &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; notifications, then the RequiredModelMBean will supply its own default &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt;s for those missing notifications.</source>
          <target state="translated">주어진 &lt;var&gt;inModelMBeanInfo&lt;/var&gt; 에 &lt;code&gt;GENERIC&lt;/code&gt; 또는 &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; 알림에 대한 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 가 포함되어 있지 않은 경우 RequiredModelMBean은 자체 기본 &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; 를 제공합니다.&lt;/a&gt; 누락 된 알림에 대해 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="871cb4309703aec2bc0023c758d9cf428cebc74f" translate="yes" xml:space="preserve">
          <source>If the given URI has an authority component then the new URI's authority and path are taken from the given URI.</source>
          <target state="translated">제공된 URI에 권한 구성 요소가 있으면 새 URI의 권한 및 경로가 지정된 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e06d94bd934ab4eadeb7ce0dca1e7e7222d58665" translate="yes" xml:space="preserve">
          <source>If the given URI is already absolute, or if this URI is opaque, then the given URI is returned.</source>
          <target state="translated">제공된 URI가 이미 절대적이거나이 URI가 불투명 한 경우 지정된 URI가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2430c525f00d8a5ecee224a7a5b81e9aae39e412" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">지정된 URI의 조각 구성 요소가 정의되고 해당 경로 구성 요소가 비어 있고 해당 구성표, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 지정된 조각이 있지만 다른 모든 구성 요소가이 URI의 구성 요소와 동일한 URI가 반환됩니다. 이를 통해 &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt; 와 같은 독립형 조각 참조를 나타내는 URI를 기본 URI에 대해 유용하게 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c849fb5cce341a58fea462c01a105441e0cc9602" translate="yes" xml:space="preserve">
          <source>If the given URI's path is absolute then the new URI's path is taken from the given URI.</source>
          <target state="translated">주어진 URI의 경로가 절대적이면 새로운 URI의 경로는 주어진 URI에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="14f7899ffb21b582de61406576d434576cfac581" translate="yes" xml:space="preserve">
          <source>If the given address includes a JNDI directory URL as specified in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;, then this &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.</source>
          <target state="translated">지정된 주소에 &lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt; 패키지 문서에 지정된 JNDI 디렉토리 URL이 포함되어있는 경우, 이 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 는 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 지정된 주소 에 바인딩하여 부트 스트랩 합니다.</target>
        </trans-unit>
        <trans-unit id="ca814afbdb188e0d8eb604c68dacd59c7bf69539" translate="yes" xml:space="preserve">
          <source>If the given alias already exists, the keystore information associated with it is overridden by the given key (and possibly certificate chain).</source>
          <target state="translated">지정된 별명이 이미 존재하면, 해당 별명과 연관된 키 저장소 정보는 제공된 키 (및 인증서 체인)에 의해 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3a595a56aadbb88b4114693edc5c1ee01ec9f96d" translate="yes" xml:space="preserve">
          <source>If the given alias identifies an existing entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, the trusted certificate in the existing entry is overridden by the given certificate.</source>
          <target state="translated">지정된 별명 식별 기존를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를 기존 항목에서 신뢰할 수있는 인증서는 지정된 증명서에 의해 오버라이드 (override)됩니다.</target>
        </trans-unit>
        <trans-unit id="5db25da879a6c8a2469a9ffa221b439cce428d7c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the trusted certificate contained in that entry is returned.</source>
          <target state="translated">지정된 별명 이름을 식별하는를 호출 해 작성된 엔트리 경우 &lt;code&gt;setCertificateEntry&lt;/code&gt; 의 호출에 의해, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A를 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 를이 다음 신뢰할 수있는 인증서가 해당 항목에 포함 된 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d4d7d88c3b4df9575339dccffaf79058f1c8930" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry (if a chain exists) is returned.</source>
          <target state="translated">경우 지정된 별명 식별하는 호출에 의해 생성 된 입력 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 엔트리의 인증서 체인의 다음의 첫 번째 요소는 (a 체인이 존재하는 경우)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="c2ed3e7db9906e449ddb9d356b3252474de4e64c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry is returned.</source>
          <target state="translated">주어진 별명 식별하는 호출에 의해 생성 된 진입하면 &lt;code&gt;setKeyEntry&lt;/code&gt; 를 호출함으로써, 또는 생성 &lt;code&gt;setEntry&lt;/code&gt; A의 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 를 , 그 항목의 인증서 체인의 첫 번째 요소가 반환된다.</target>
        </trans-unit>
        <trans-unit id="a7044af5535fc0b80bc9e6eb2af416837a93528e" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">주어진 차단 모드가 현재 차단 모드와 다른 &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt; 메소드는 모드를 변경하기 위해 적절한 잠금을 유지하면서 implConfigureBlocking 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ef47fccc5a72a56e061d58ffbc98135bb15f0e3b" translate="yes" xml:space="preserve">
          <source>If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">제공된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd6f94d655e9cba018e02791b4d2bafeaf0cd16b" translate="yes" xml:space="preserve">
          <source>If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only the base bundle as the resulting resource bundle.</source>
          <target state="translated">지정된 로케일이 동일한 경우 &lt;code&gt;Locale.ROOT&lt;/code&gt; (루트 로케일)하는 &lt;code&gt;List&lt;/code&gt; 만을 루트 포함 된 &lt;code&gt;Locale&lt;/code&gt; 반환해야합니다. 이 경우 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드는 기본 번들 만 결과 자원 번들로로드합니다.</target>
        </trans-unit>
        <trans-unit id="a722054d6a8a85985b6af9a7f074ff6c9d6c5114" translate="yes" xml:space="preserve">
          <source>If the given method to be invoked, together with the provided signature, matches one of RequiredModelMbean accessible methods, this one will be call. Otherwise the call to the given method will be tried on the managed resource.</source>
          <target state="translated">제공된 서명과 함께 제공된 메소드가 RequiredModelMbean 액세스 가능 메소드 중 하나와 일치하면이 메소드가 호출됩니다. 그렇지 않으면 지정된 메소드에 대한 호출이 관리 자원에서 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="a79eac791e4b86cfc10aabf01a42570af6907767" translate="yes" xml:space="preserve">
          <source>If the given object is not a Path, or is a Path associated with a different &lt;code&gt;FileSystem&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 Path가 아니거나 다른 &lt;code&gt;FileSystem&lt;/code&gt; 에 관련한 Path 인 경우 ,이 메소드는 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ab44b435bce5e6d0dd0d4400904c04dd1b50093c" translate="yes" xml:space="preserve">
          <source>If the given object is not a URI then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URI가 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="dab849a2dfb627f012f49b202b71d39af39c2224" translate="yes" xml:space="preserve">
          <source>If the given object is not a URL then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 URL이 아닌 경우,이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="51317f50e868ccac84e6251d8aade86da12219ac" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;AclEntry&lt;/code&gt; then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 객체가 &lt;code&gt;AclEntry&lt;/code&gt; 가 아닌 경우, 이 메소드는 즉시 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="5067d1933a7fb6de041c489427ed9f038cbf2e5d" translate="yes" xml:space="preserve">
          <source>If the given path has &lt;em&gt;N&lt;/em&gt; elements, and no root component, and this path has &lt;em&gt;N&lt;/em&gt; or more elements, then this path ends with the given path if the last &lt;em&gt;N&lt;/em&gt; elements of each path, starting at the element farthest from the root, are equal.</source>
          <target state="translated">주어진 경로에 &lt;em&gt;N 개의&lt;/em&gt; 요소가 있고 루트 구성 요소가 &lt;em&gt;없고이&lt;/em&gt; 경로에 &lt;em&gt;N&lt;/em&gt; 개 이상의 요소가있는 경우 루트에서 가장 먼 요소에서 시작하여 각 경로 의 마지막 &lt;em&gt;N 개&lt;/em&gt; 요소가 동일한 경우이 경로는 제공된 경로로 끝납니다. .</target>
        </trans-unit>
        <trans-unit id="fe7eaf75c5ca09e9dc37afa7038d8c228c398461" translate="yes" xml:space="preserve">
          <source>If the given path has a root component then this path ends with the given path if the root component of this path &lt;em&gt;ends with&lt;/em&gt; the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path.</source>
          <target state="translated">지정된 경로에 루트 구성 요소가있는 경우이 경로의 루트 구성 요소가 지정된 경로의 루트 구성 요소로 &lt;em&gt;끝나고&lt;/em&gt; 두 경로의 해당 요소가 동일한 경우이 경로 &lt;em&gt;는&lt;/em&gt; 지정된 경로 로 &lt;em&gt;끝납니다&lt;/em&gt; . 이 경로의 루트 구성 요소가 주어진 경로의 루트 구성 요소로 끝나는 지 여부는 파일 시스템에 따라 다릅니다. 이 경로에 루트 구성 요소가없고 지정된 경로에 루트 구성 요소가 있으면이 경로는 지정된 경로로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fdc1f0bd8bdd66110dc3f031d4817dcf3caed63" translate="yes" xml:space="preserve">
          <source>If the given path is associated with a different &lt;code&gt;FileSystem&lt;/code&gt; to this path then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">주어진 경로 가이 경로 와 다른 &lt;code&gt;FileSystem&lt;/code&gt; 과 연관되어 있으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2bf60e5452de4ddf9870cafed442c49431cf97" translate="yes" xml:space="preserve">
          <source>If the given provider is installed at the requested position, the provider that used to be at that position, and all providers with a position greater than &lt;code&gt;position&lt;/code&gt;, are shifted up one position (towards the end of the list of installed providers).</source>
          <target state="translated">지정된 프로 바이더가 요구 된 위치에 설치되어있는 경우, 그 위치에 있던 프로 바이더와보다 위치보다 모든 업체 &lt;code&gt;position&lt;/code&gt; , (인스톨되고있는 프로 바이더의리스트의 끝으로) 한 위치를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="be7b3561a355e78f18cdeae419abf0ee5e2ea933" translate="yes" xml:space="preserve">
          <source>If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 현재 크기보다 작 으면 엔터티가 잘리고 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 현재 크기보다 크거나 같으면 엔티티가 수정되지 않습니다. 두 경우 모두 현재 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaefbc3d9c612129c52e3733260c322198b61ac6" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.</source>
          <target state="translated">지정된 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87ded65bf156680a79571d8a9d909a68f908630c" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.</source>
          <target state="translated">주어진 크기가 파일의 현재 크기보다 작 으면 파일이 잘리고 파일의 새 끝을 넘어서는 바이트가 삭제됩니다. 주어진 크기가 파일의 현재 크기보다 크거나 같으면 파일이 수정되지 않습니다. 두 경우 모두이 채널의 파일 위치가 지정된 크기보다 큰 경우 해당 크기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b0bf2a45ec36e583f47ca33513286c575ec604" translate="yes" xml:space="preserve">
          <source>If the handler is not null and there is a security manager, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">핸들러가 널이 아니고 보안 관리자가있는 &lt;code&gt;checkPermission&lt;/code&gt; , 보안 관리자의 checkPermission 메소드는 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; 권한으로 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다. 이 생성자는 입력의 유효성 검증을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82294cea404b457d7895b5f7849b8f8cdabef00b" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">호스트 인 경우 &lt;code&gt;null&lt;/code&gt; 다음 &lt;code&gt;InetAddress&lt;/code&gt; 루프백 인터페이스의 주소를 나타내는가 반환됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; 섹션 2 및 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; 섹션 2.5.3을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c743eca5b6b4b9d617040308e1ee27a4b7c6393" translate="yes" xml:space="preserve">
          <source>If the identity is marked as &quot;trusted&quot;, this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.</source>
          <target state="translated">ID가 &quot;신뢰 됨&quot;으로 표시되면 공격자는 시스템의 ID 범위에서 신뢰하지 않는 다른 공개 키 (예 : 자체)를 도입하여 해당 공개 키 권한으로 서명 된 애플릿 또는 응용 프로그램 코드를 부여 할 수 있습니다. 그렇지 않으면 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="75b8821b16ad8c4bce7f71ae9f2499e34e968953" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default height.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4a58cc703a9db33b11b3faf9dca4d8e83b20a1f" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default width.</source>
          <target state="translated">이미지를 사용자 지정 크기로 렌더링 할 수 있으면이 메서드는 기본 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e4e52ec311e9e75dd4cc081567f1eae9e6bf20f" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values. Note that the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are not affected by this method; they will continue to return the default size for the image. Similarly, if the image is also tiled the tile width and height are given in terms of the default size.</source>
          <target state="translated">이미지를 임의의 크기로 렌더링 할 수 있으면 소스 너비와 높이를 제공된 값으로 설정하십시오. &lt;code&gt;ImageReader&lt;/code&gt; 의 &lt;code&gt;getWidth&lt;/code&gt; 및 &lt;code&gt;getHeight&lt;/code&gt; 메소드에서 리턴 된 값 은이 메소드의 영향을받지 않습니다. 이미지의 기본 크기를 계속 반환합니다. 마찬가지로 이미지가 타일링 된 경우 타일 너비와 높이는 기본 크기와 관련하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ce886e7cf517b9dd1b8e4bf3972fb87acfaf11" translate="yes" xml:space="preserve">
          <source>If the implementation can supply a value for one of the queries listed in the if statement of the default implementation, then it must do so. For example, an application-defined &lt;code&gt;HourMin&lt;/code&gt; class storing the hour and minute must override this method as follows:</source>
          <target state="translated">구현이 기본 구현의 if 문에 나열된 쿼리 중 하나에 대한 값을 제공 할 수 있으면 그렇게해야합니다. 예를 들어, 시간과 분을 저장 하는 응용 프로그램 정의 &lt;code&gt;HourMin&lt;/code&gt; 클래스는 다음과 같이이 메서드를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ab19508e52ba992a5a553d39a65472031820996" translate="yes" xml:space="preserve">
          <source>If the implementation of this class does not support persistence, an &lt;a href=&quot;../mbeanexception&quot;&gt;&lt;code&gt;MBeanException&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;../servicenotfoundexception&quot;&gt;&lt;code&gt;ServiceNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">이 클래스의 구현이 지속성을 지원하지 않는 경우 &lt;a href=&quot;../mbeanexception&quot;&gt; &lt;code&gt;MBeanException&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../servicenotfoundexception&quot;&gt; &lt;code&gt;ServiceNotFoundException&lt;/code&gt; 를&lt;/a&gt; 랩핑 MBeanException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61497ea0a67eb203673d203a0f2b5369b019bf33" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;각각 RuntimeErrorException. 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b96b5c5ec491812d30a354e2cb6f11721b2e2b1d" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외가 발생합니다. MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4535342913d52819782cb269ae901b36379460f0" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 각각 . 그러나 &lt;code&gt;postDeregister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태가 변경되지는 않습니다. MBean이 이미 등록 취소되었으며 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="76763841aca1fa1b12ea5b878cc85e9f7cde9edb" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">이 메소드의 구현이 &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 Throw하면 (자), MBean 서버는 각각 &lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt; 내부의 것을 Throw합니다 . 그러나 &lt;code&gt;postRegister&lt;/code&gt; 에서 예외를 던져도 MBean의 상태는 변경되지 않습니다. MBean이 이미 등록 된 경우 ( &lt;code&gt;registrationDone&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; ) MBean은 등록 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a527012aa1181404e26ff9eba79c5215c6617c" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the PROCESSING or PROCESSING_STOPPED job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the PROCESSING or PROCESSING_STOPPED state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the CANCELED or ABORTED job states.</source>
          <target state="translated">구현이 PROCESSING 또는 PROCESSING_STOPPED 작업 상태에서 작업을 취소하는 데 측정 가능한 시간이 필요한 경우, 프린터는이 이유를 사용하여 작업이 PROCESSING 또는 PROCESSING_STOPPED 상태에있는 동안 프린터가 여전히 작업에 대해 일부 조치를 수행하고 있음을 표시해야합니다. 모든 작업의 ​​작업 설명 속성 증가가 중지 된 후 프린터는 작업을 처리 중 상태에서 취소 또는 중단 된 작업 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="21a96789298a278046ce067991e2d31d04c7cbd4" translate="yes" xml:space="preserve">
          <source>If the implementation supports</source>
          <target state="translated">구현이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="35f873dd7c2035b38202cda19f7fef9dd8dbdb3b" translate="yes" xml:space="preserve">
          <source>If the implementing method determines that no transformations are needed, it should return &lt;code&gt;null&lt;/code&gt;. Otherwise, it should create a new &lt;code&gt;byte[]&lt;/code&gt; array, copy the input &lt;code&gt;classfileBuffer&lt;/code&gt; into it, along with all desired transformations, and return the new array. The input &lt;code&gt;classfileBuffer&lt;/code&gt; must not be modified.</source>
          <target state="translated">구현 방법이 변환이 필요하지 않다고 판단하면 &lt;code&gt;null&lt;/code&gt; 을 반환해야합니다 . 그렇지 않으면, 새로운 &lt;code&gt;byte[]&lt;/code&gt; 배열을 생성하고 , 원하는 모든 변환과 함께 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 복사 하고 새로운 배열을 반환해야합니다. 입력 &lt;code&gt;classfileBuffer&lt;/code&gt; 를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="81ca206f6782401fcc1f26d127affa8acd0e136d" translate="yes" xml:space="preserve">
          <source>If the implementing object is an instance of java.beans.beancontext.BeanContext, or a subinterface thereof, then that BeanContext should fire a PropertyChangeEvent, to its registered BeanContextMembershipListeners, with parameters:</source>
          <target state="translated">구현 객체가 java.beans.beancontext.BeanContext의 인스턴스 또는 그 하위 인터페이스 인 경우 해당 BeanContext는 매개 변수를 사용하여 등록 된 BeanContextMembershipListeners에 PropertyChangeEvent를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="36b6757dd0b7b9698143f2e5d681dfa198ff7d6d" translate="yes" xml:space="preserve">
          <source>If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard &lt;code&gt;IIOMetadata&lt;/code&gt; interfaces such as the tree view provided by &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt;. In this case, there is likely to be significant loss of information.</source>
          <target state="translated">수신 객체가 작가로 알려진 추가 인터페이스를 구현하지 않는 경우, 작가는 선택의 여지가 있지만, 표준 통한 액세스를로 &lt;code&gt;IIOMetadata&lt;/code&gt; 에서 제공하는 트리보기와 같은 인터페이스 &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt; . 이 경우 정보가 크게 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e436d84bd4232b4579b6124cd808ff4918e211d5" translate="yes" xml:space="preserve">
          <source>If the inherited channel is a datagram-oriented socket then a &lt;a href=&quot;../datagramchannel&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt; is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 데이터 그램 지향 소켓이면 &lt;a href=&quot;../datagramchannel&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 데이터 그램 채널은 적어도 초기에 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3073a336a578c76af3c2fae533b0dcd45d01e490" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented connected socket then a &lt;a href=&quot;../socketchannel&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer.</source>
          <target state="translated">상속 된 채널이 스트림 지향 연결 소켓을 나타내는 경우 &lt;a href=&quot;../socketchannel&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 소켓 채널은 적어도 초기에 블로킹 모드에 있으며 소켓 주소에 바인딩되어 있고 피어에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="875d948792bb0df4386ddee7ed26751e7f15e361" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented listening socket then a &lt;a href=&quot;../serversocketchannel&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">상속 된 채널이 스트림 지향 청취 소켓을 나타내는 경우 &lt;a href=&quot;../serversocketchannel&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 서버 소켓 채널은 적어도 초기에는 차단 모드에 있으며 소켓 주소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="046cd8116ea31a7deaa92b344ddffcaddc10e57f" translate="yes" xml:space="preserve">
          <source>If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.</source>
          <target state="translated">입력 바이트 배열이 유효한 Base64 인코딩 체계가 아닌 경우 IllegalargumentException이 발생하기 전에 일부 바이트가 출력 바이트 배열에 기록되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44c010f5bf051b0a98a728de40056665c0f4201b" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information,  Kerberos Requirements</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항</target>
        </trans-unit>
        <trans-unit id="e2258789d44cebf2e677dac1a6ecd85ab5667fdc" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see  Kerberos Requirements.</source>
          <target state="translated">입력 이름에 영역이 없으면 기본 영역이 사용됩니다. 기본 영역은 Kerberos 구성 파일 또는 java.security.krb5.realm 시스템 특성을 통해 지정할 수 있습니다. 자세한 내용은 Kerberos 요구 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72db9a55602aeaacd8d06804f6747b4e1ec98ac6" translate="yes" xml:space="preserve">
          <source>If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">입력 시퀀스가 ​​변경 가능한 경우 터미널 스트림 작업을 실행하는 동안 입력 시퀀스가 ​​일정하게 유지되어야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdcd5cc0d6714ef6dfe7ad5151f92554586e46cb" translate="yes" xml:space="preserve">
          <source>If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive.</source>
          <target state="translated">이 스트림의 의도 된 목적지가 기본 운영 체제 (예 : 파일)에 의해 제공되는 추상화 인 경우, 스트림을 비우면 이전에 스트림에 기록 된 바이트 만 운영 체제로 전달되어 기록됩니다. 디스크 드라이브와 같은 실제 장치에 실제로 기록되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="881b9ec107691ccb0574603b5fa37effa233e5be" translate="yes" xml:space="preserve">
          <source>If the invoked method completes normally, the value it returns is copied in the &lt;code&gt;value&lt;/code&gt; property. Note that the &lt;code&gt;value&lt;/code&gt; property is set to &lt;code&gt;null&lt;/code&gt;, if the return type of the underlying method is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">호출 된 메소드가 정상적으로 완료되면 리턴 된 &lt;code&gt;value&lt;/code&gt; 이 value 특성에 복사됩니다 . 점을 유의 &lt;code&gt;value&lt;/code&gt; 속성으로 설정된 &lt;code&gt;null&lt;/code&gt; 기본 메소드의 리턴 타입 인 경우, &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55fa409a4b17ed3350505c8e7edb658e38fe64b1" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a &lt;a href=&quot;filelockinterruptionexception&quot;&gt;&lt;code&gt;FileLockInterruptionException&lt;/code&gt;&lt;/a&gt; will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed.</source>
          <target state="translated">잠금 획득을 기다리는 동안 호출 스레드가 인터럽트되면 해당 인터럽트 상태가 설정되고 &lt;a href=&quot;filelockinterruptionexception&quot;&gt; &lt;code&gt;FileLockInterruptionException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 이 메소드를 호출 할 때 호출자의 인터럽트 상태가 설정되면 해당 예외가 즉시 발생합니다. 스레드의 인터럽트 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ace7c9d0c03c5a8591ce4f875b6cfb21a9fe43d8" translate="yes" xml:space="preserve">
          <source>If the jar file is on the class path, VendorJavaCompiler can be located using code like this:</source>
          <target state="translated">jar 파일이 클래스 경로에있는 경우 VendorJavaCompiler는 다음과 같은 코드를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05798c7b9d831dc45d92f33b15f7f3c7a9524b15" translate="yes" xml:space="preserve">
          <source>If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, &lt;code&gt;random&lt;/code&gt;. However, if the underlying algorithm implementation does not require any random bytes, &lt;code&gt;random&lt;/code&gt; is ignored.</source>
          <target state="translated">키 합의 알고리즘에 임의의 바이트가 필요한 경우, 임의의 지정된 &lt;code&gt;random&lt;/code&gt; 소스 random로부터 가져옵니다 . 그러나 기본 알고리즘 구현에 임의 바이트가 필요하지 않은 경우 &lt;code&gt;random&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ba2d545a01554992fedf0cb983cad56e6a2aca" translate="yes" xml:space="preserve">
          <source>If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</source>
          <target state="translated">키가 하드웨어 장치에 저장된 경우 해당 사양에는 장치의 키를 식별하는 데 도움이되는 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9af549a3a519458df47c4c31dbda4adcd0e3257" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, This method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 짧은 달 이름을 서식 형식으로 반환합니다. 예를 들어, 1 월 카탈로니아 어로 선호되는 약어는 &lt;em&gt;degen입니다. &lt;/em&gt;&lt;em&gt;gen&lt;/em&gt; 형식 인 동안 서식 형식으로 독립형으로. 이 메소드는 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 리턴합니다 . 이 경우 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93f027224547b6049ea9e0bfa7e65c576dd00372" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">언어에 다른 형식의 서식과 독립 실행 형 사용이 필요한 경우이 메서드는 서식 형식으로 월 이름을 반환합니다. 예를 들어, 체코 어로 1 월에 선호하는 월 이름 은 형식화 형식으로 &lt;em&gt;ledna&lt;/em&gt; 이고 독립형 형식으로 &lt;em&gt;leden&lt;/em&gt; 입니다. 이 경우이 메소드는 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 를 리턴합니다 . 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;LDML (Unicode Locale Data Markup Language) 사양&lt;/a&gt; 의 달력 요소 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="721e40fbee0b627fcc6ccf4dd39ef80c9c24cc65" translate="yes" xml:space="preserve">
          <source>If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 길이 가 0이면 바이트를 읽지 않고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 적어도 1 바이트를 읽으려고합니다. 스트림이 파일의 끝에 있기 때문에 사용 가능한 바이트가 없으면 값 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 적어도 하나의 바이트를 읽고 &lt;code&gt;b&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="945b37877bd5c51ba536e667136d3b4286b64c37" translate="yes" xml:space="preserve">
          <source>If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence that is the concatenation of the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object and the character sequence represented by the argument string.</source>
          <target state="translated">인수 문자열의 길이가 &lt;code&gt;0&lt;/code&gt; 이면이 &lt;code&gt;String&lt;/code&gt; 객체가 반환됩니다. 그렇지 않으면, &lt;code&gt;String&lt;/code&gt; 객체는 문자 시퀀스의 연결이로 표시되는 문자 순서 나타내 반환되는 &lt;code&gt;String&lt;/code&gt; 오브젝트 인수의 캐릭터 라인이 나타내는 문자 순서를.</target>
        </trans-unit>
        <trans-unit id="0940fb46aa425a706a545b01258cef980fd6db8a" translate="yes" xml:space="preserve">
          <source>If the length of the specified &lt;code&gt;CharSequence&lt;/code&gt; is less than or equal to zero, then an empty buffer of capacity &lt;code&gt;16&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 &lt;code&gt;CharSequence&lt;/code&gt; 의 길이 가 0보다 작거나 같은 경우 용량 &lt;code&gt;16&lt;/code&gt; 의 빈 버퍼 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="009a7b082a7f277c626ca216eb6dd0590efc9900" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">줄이 열려 있지 않고 열리지 않은 경우 기본 형식을 반환합니다. 기본 형식은 구현 별 오디오 형식이거나, 이 &lt;code&gt;DataLine&lt;/code&gt; 을 검색하는 데 사용 된 &lt;code&gt;DataLine.Info&lt;/code&gt; 객체가 하나 이상의 정규화 된 오디오 형식을 지정하는 경우 마지막 형식이 기본 형식으로 사용됩니다. 특정 오디오 형식으로 라인을 열면 (예 : &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt; ) 기본 형식을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7863f26128f8bba0e665024d8f8516c082ac4867" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 컬렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다. . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="9d2a9e6acfe01f48880cc127c76590e8af39df2a" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">목록이 여유 공간이있는 지정된 배열에 맞는 경우 (즉, 배열에 목록보다 많은 요소가있는 경우) 목록의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . (이것은 목록의 길이를 결정하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="1566f18ef0180d3aac88323daa9341914ba885e6" translate="yes" xml:space="preserve">
          <source>If the list's list-iterator does not support the &lt;code&gt;set&lt;/code&gt; operation then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown when replacing the first element.</source>
          <target state="translated">리스트의리스트 반복자가 &lt;code&gt;set&lt;/code&gt; 조작을 지원하지 않는 경우는 최초의 요소를 교체 할 때 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae175c3216a75f24ee407fdf582572db3c498ef" translate="yes" xml:space="preserve">
          <source>If the listener is registered more than once, perhaps with different filters or callbacks, this method will remove all those registrations.</source>
          <target state="translated">리스너가 다른 필터 또는 콜백으로 두 번 이상 등록 된 경우이 메소드는 모든 등록을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="54b665bbf8eb506dbbe12fdda9847f03e69a163c" translate="yes" xml:space="preserve">
          <source>If the literal is empty, nothing is added to the formatter.</source>
          <target state="translated">리터럴이 비어 있으면 포맷터에 아무것도 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5586e5fb737ecf0129eedcffc9670c2876a5d020" translate="yes" xml:space="preserve">
          <source>If the load average is not available, a negative value is returned.</source>
          <target state="translated">로드 평균을 사용할 수 없으면 음수 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="612e3af41a7467295225df330e80d3aa55f31393" translate="yes" xml:space="preserve">
          <source>If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</source>
          <target state="translated">컨텐츠 핸들러 클래스의로드가 호출자의 위임 체인 외부에있는 클래스 로더에 의해 수행되는 경우 JVM에는 RuntimePermission &quot;getClassLoader&quot;가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fb7426e4160f2b1fe5d7220ffa07b99d6ba7024b" translate="yes" xml:space="preserve">
          <source>If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is followed.</source>
          <target state="translated">로케일이 정확히 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; 인 경우 먼저 &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; 로 변환됩니다. 다음 위의 절차를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c64c3966e3d4abb3a14f499628ce198c1164f906" translate="yes" xml:space="preserve">
          <source>If the lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드에서 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="822233d82712d166731e9dcca011715ab8bbe1d8" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the lock hold count is set to one.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="243ddf2fd70f54733945fc92a2c6210895bc2219" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e267ec383786f22b490efc4cbeb5a239987b49eb" translate="yes" xml:space="preserve">
          <source>If the lock is available this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">잠금이 사용 가능한 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3629e1c7a434db3fa94e4624595c63c91c3763" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3fb57c41848bc377b297ddabc5e3ff9216fa1a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8c566c06708381b95a076b6d0a7ff9c3dd5f9a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금이 확보 될 때까지 휴면 상태가되어 잠금 보유 계수가 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d853278a5b45d2ebee3420faecb6ce65095ece12" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.</source>
          <target state="translated">잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 쓰기 잠금이 확보 될 때까지 휴면 상태가되며,이 때 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="918d784e15001f2097233989116a220695ba3605" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 thread에 의해 락이 보관 유지되고있는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="85233bd93c41bf81d5bd16d44009dd4101f01d92" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링을 위해 비활성화되며 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcde55af63c37dc1d170326de90648dbad927ec" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금을 획득 할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="a09e194cce7b274be7295eeba5f7cce4ea171773" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 스탬프가 잠금 유지를 나타내는 경우 잠금을 해제하고 관찰 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 유효성이 검증 된 경우이를 읽습니다. 이 메소드는 다른 모든 경우에 0을 리턴하므로 &quot;tryUnlock&quot;의 양식으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefa68914d354c4eea9a7f9d2e87edb5b5d3616c" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 보유를 나타내는 경우 해제하여 읽기 잠금을 얻습니다. 또는 읽기 잠금 인 경우이를 리턴합니다. 또는 낙관적 읽기 인 경우 읽기 잠금을 획득하고 즉시 사용 가능한 경우에만 읽기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fe6cd5b7f1314dfe53912057e75419a458d6c46" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 유지를 나타내는 경우 반환합니다. 또는 읽기 잠금 인 경우 쓰기 잠금이 사용 가능한 경우 읽기 잠금을 해제하고 쓰기 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 즉시 사용 가능한 경우에만 쓰기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14a53c83eff403dc5c623bd9e147872ed3ff94fc" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the corresponding mode of the lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 해당 잠금 모드를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3114f1897355cfbc96b7a2b2a9909376a9675347" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4a3ebac76180e9eaa8e069fe7a9c0cce392315b8" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the non-exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 비 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e004c7523986b5ecc4e1749a86febcd1a6784511" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 지정된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2480ae012f96dc55272b45f972094f52d29f7772" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f74f4184b1114d21694c20083bffeca6773ddbdc" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ef129fafed8fea9b1b19398062aeaf0403caccda" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5c488b5e8261b0b9f6a94d2c335e06b774d3e4c2" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="400e0c53967d73d6073541aa2955ecfaedacc619" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c08c72ddfcb02350456ab868e8db332930e255e4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="776e22483061c922dbf981169c45b199faadcb6b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3de4bfb7369cf5faf7dd1122bdabc955fddf2e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c2334c2c90239d4c59ec8c7a0e4b1e0b78f35b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7e0ed2e38d83c57cfc908b346ba953ba01ea6e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8e167659c676fd6a76d1a8ff361acf900cf2dee4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="700de6b174ae4293a822d7062908049e15243b9c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8548b61ec8126b5ee81ca57df60b3e51531c5a8a" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2998fe288d20db38f6f02724d9a3e1e03f44693c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 해당 LogRecord가 작성되어 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5672874e662c52b70bec899dedf5a6f7d4107f79" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0a20e1ab3ef4c4dda5575d5b6fbf96f00af911a8" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to &quot;THROW&quot;.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다. LogRecord의 메시지가 &quot;THROW&quot;로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="325dfec7a72934c84f66843540d89c8f3769035b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="09b15fa7220dfe741c8baffb5087e302fb89c908" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성하고 등록 된 모든 출력 핸들러 오브젝트로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="72eff8884364ee54a875323cb549fca604cb4b7b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성합니다. 그런 다음 메시지와 지정된 &lt;a href=&quot;../../lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="df68511496b32d8949f42994423a12d97c5a37a3" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail, due to the method handle type having too many parameters.</source>
          <target state="translated">조회 된 메소드의 특성이 &lt;a href=&quot;methodhandle#maxarity&quot;&gt;매우 큰&lt;/a&gt; 경우 메소드 핸들 유형에 매개 변수가 너무 많아 메소드 핸들 작성에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a1d5c49aae5cb26d9965efa2b543eb65306a01" translate="yes" xml:space="preserve">
          <source>If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character.</source>
          <target state="translated">크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e2b282ebf7062ed0ca134866fb50f5fe7dd48ced" translate="yes" xml:space="preserve">
          <source>If the main task must later await termination, it may re-register and then execute a similar loop:</source>
          <target state="translated">주 작업이 나중에 종료를 기다려야하는 경우 다시 등록한 후 비슷한 루프를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91601953e386bbcbf0a6b2f49eca2d05544c99f8" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키가 중복 된 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42bc70fbf81ca2e8ef91fd72811c9886f9c29e43" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있는 경우 대신 &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd1a935a059b20128bc5042763d4c45de22fb0b" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab1f12a020b33fa5cdaa6c8e92a327756ecc141" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 제공된 공급 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="5d55abd598d0098b46d878c1a82407a1edf09085" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;Map&lt;/code&gt; 제공된 공급 업체의 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="38fcc3a9324656c7f62d52adcd0bcdf26f23941f" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있으며 &lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 메소드 의 후속 호출은 이 일치와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45d30a935b4cf0dbcaf8698457f96e2ee71e0db" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4646f11996bf69cea5464367c1335e753c401c2e" translate="yes" xml:space="preserve">
          <source>If the match was successful but the group specified failed to match any part of the input sequence, then &lt;code&gt;null&lt;/code&gt; is returned. Note that some groups, for example &lt;code&gt;(a*)&lt;/code&gt;, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.</source>
          <target state="translated">일치는했지만 지정된 그룹이 입력 순서의 일부와 일치하지 않으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 예를 들어 &lt;code&gt;(a*)&lt;/code&gt; 와 같은 일부 그룹 은 빈 문자열과 일치합니다. 이 메소드는 해당 그룹이 입력의 빈 문자열과 성공적으로 일치하면 빈 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e27c63987af47673a3557d130f21afb577235397" translate="yes" xml:space="preserve">
          <source>If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1. The most common use of this is to generate &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</source>
          <target state="translated">최대 정수 자릿수가 최소 자릿수보다 크고 1보다 큰 경우 지수는 최대 정수 자릿수의 배수가되고 최소 정수 자릿수가 1로 해석됩니다. 이것의 사용은 &lt;em&gt;공학 표기법&lt;/em&gt; 을 생성 하는 것인데, 지수는 &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt; 과 같이 3의 배수입니다 . 이 패턴을 사용하면 숫자 12345는 &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt; 으로 , 123456은 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt; 으로 포맷됩니다 .</target>
        </trans-unit>
        <trans-unit id="838dcf4d5b32bbaaf6507ff34ec3b9a39315ea1c" translate="yes" xml:space="preserve">
          <source>If the mechanism has an initial response, the library invokes &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge and to get initial response. Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling &lt;code&gt;hasInitialResponse()&lt;/code&gt; or &lt;code&gt;evaluateChallenge()&lt;/code&gt;. When the server responds to the command, it sends an initial challenge. For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data. This will then result in a call (on the client) to &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge.</source>
          <target state="translated">메커니즘에 초기 응답이있는 경우 라이브러리는 비어있는 시도로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 호출 하고 초기 응답을받습니다. 서버에 대한 첫 번째 인증 명령으로 초기 응답을 포함하지 않는 IMAP4와 같은 프로토콜은 &lt;code&gt;hasInitialResponse()&lt;/code&gt; 또는 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 먼저 호출하지 않고 인증을 시작합니다 . 서버가 명령에 응답하면 초기 챌린지를 보냅니다. 클라이언트가 데이터를 먼저 보내는 SASL 메커니즘의 경우 서버는 데이터없이 챌린지를 발행해야합니다. 그러면 빈 챌린지 로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 평가 하기 위해 ( 클라이언트에서) 호출이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4583d5e7e45e0fa2e945cb9ac4db80337ed6eff8" translate="yes" xml:space="preserve">
          <source>If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address.</source>
          <target state="translated">멤버쉽 키가 모든 데이터 그램을 수신하는 멤버쉽을 나타내는 경우 멤버쉽이 삭제되고 채널은 더 이상 그룹으로 전송 된 데이터 그램을 수신하지 않습니다. 멤버쉽 키가 소스에 특정한 경우 채널은 더 이상 해당 소스 주소에서 그룹으로 전송 된 데이터 그램을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="578b6c8818072cd3e8eeb57e000ffbfdfb02eb42" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">메타 데이터에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 제공된 테이블 이 무시됩니다. 또한 일단 테이블 세트가 작성된 후에는 동일한 스트림이든 다른 스트림이든간에 메타 데이터의 테이블 만 후속 쓰기를 위해이를 대체 할 수 있습니다. 이 클래스를 사용하여 새 테이블을 지정 하려면 기록기 의 &lt;a href=&quot;../../imagewriter#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad0276650305bd3de8e01175bff74048c2dfe026" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;mark&lt;/code&gt; has not been called since the stream was created, or the number of bytes read from the stream since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument to &lt;code&gt;mark&lt;/code&gt; at that last call, then an &lt;code&gt;IOException&lt;/code&gt; might be thrown.</source>
          <target state="translated">스트림이 작성된 후 메소드 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않았거나 &lt;code&gt;mark&lt;/code&gt; 가 마지막으로 호출 된 이후 스트림에서 읽은 바이트 수가 해당 마지막 호출에서 &lt;code&gt;mark&lt;/code&gt; 하기위한 인수보다 큰 경우 &lt;code&gt;IOException&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd81035982e12d53ca7e2f58a6ad2d674721fd8" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;markSupported&lt;/code&gt; 메소드 가 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우 :</target>
        </trans-unit>
        <trans-unit id="864c00c6cb70175672417e9637771a48ccc4d334" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">이 방법은 경우 &lt;code&gt;markSupported&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 다음 :</target>
        </trans-unit>
        <trans-unit id="eaea82c9a23067ef7f772f7e498b434c683c927b" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않습니다. 또는 필터의 메소드 호출 그러나 &lt;code&gt;Executor.execute&lt;/code&gt; 또는 &lt;code&gt;handleNotification&lt;/code&gt; (어떤 경우 &lt;code&gt;Excecutor&lt;/code&gt; 가 지정되지 않은)이 발생 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; , 그 &lt;code&gt;Error&lt;/code&gt; 호출자에게 전달된다 &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="267719667d5da83b9f20baec6b480b3574e95dc7" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않아야합니다. 그러나 메소드 호출에서 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생하면 해당 시점에서 알림 처리를 중지하고 &lt;code&gt;Error&lt;/code&gt; 를 알림 발신자 에게 전파 할 수있는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5c827066a55f3bfdaa44e5351bcaf2001cab9a" translate="yes" xml:space="preserve">
          <source>If the method completes normally, the value it returns is returned to the caller of invoke; if the value has a primitive type, it is first appropriately wrapped in an object. However, if the value has the type of an array of a primitive type, the elements of the array are</source>
          <target state="translated">메소드가 정상적으로 완료되면 리턴하는 값이 호출자에게 리턴됩니다. 값에 프리미티브 유형이있는 경우 먼저 오브젝트에 적절하게 랩핑됩니다. 그러나 값에 기본 유형의 배열 유형이있는 경우 배열의 요소는</target>
        </trans-unit>
        <trans-unit id="16a48723a8d9e2801b89e415c711042c7335165b" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">주어진 방법 않으면 &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 메소드이다 &lt;code&gt;boolean equals(Object)&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 다음과 같은 경우 true를 반환 할 것이다 인수는 경우에만 &lt;code&gt;Proxy&lt;/code&gt; 누구 &lt;code&gt;InvocationHandler&lt;/code&gt; 도이다 &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; 및 그 백업 &lt;code&gt;CompositeData&lt;/code&gt; 동일한 (동일한 필요는 없다)된다에 이 객체. 주어진 경우에있어서 &lt;code&gt;invoke&lt;/code&gt; 메소드이다 &lt;code&gt;int hashCode()&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 그것은의 정의와 일치하는 값을 반환 &lt;code&gt;equals&lt;/code&gt; 두 개체에있어서 동일한 경우 &lt;code&gt;equals&lt;/code&gt; 그러면 동일한 &lt;code&gt;hashCode&lt;/code&gt; 를 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b6f07a7fdaf466e246e416a6d8be9d141006087" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.</source>
          <target state="translated">메소드가 확인되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리 할 수있는 EJB의 경우를 제외하고는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7f5b04deb2b9061789f4f81f1da0be43e66b30" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.</source>
          <target state="translated">메소드가 검사되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리하고 예외로부터 복구 할 수있는 EJB의 경우를 제외하고는 클래스를 서비스에 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="71fad1ecc8a08eac94d160de9bd1bcb1628402e9" translate="yes" xml:space="preserve">
          <source>If the methods that return configuration information about the annotation processor return &lt;code&gt;null&lt;/code&gt;, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.</source>
          <target state="translated">어노테이션 프로세서에 대한 구성 정보를 리턴하는 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴하거나 다른 유효하지 않은 입력을 리턴하거나 예외를 발생시키는 경우 도구 인프라는이를 오류 조건으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c345ae50909ad753edc18ff3d914c0995558637" translate="yes" xml:space="preserve">
          <source>If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown.</source>
          <target state="translated">이름 지정된 로거가 이미 존재하고 아직 현지화 자원 번들이없는 경우 제공된 자원 번들 이름이 사용됩니다. 이름이 지정된 Logger가 이미 존재하고 다른 자원 번들 이름이 있으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68506597c2f99be04b0f47ace8cfa88608b7a8be" translate="yes" xml:space="preserve">
          <source>If the named class is not a top-level class, this invocation will have no effect on the actual assertion status of any class.</source>
          <target state="translated">명명 된 클래스가 최상위 클래스가 아닌 경우이 호출은 클래스의 실제 어설 션 상태에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482df42008c5e582c9e2d80de4a8c2c7a964f035" translate="yes" xml:space="preserve">
          <source>If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">명명 된 파일이 존재하지 않거나 일반 파일이 아닌 디렉토리이거나 다른 이유로 읽을 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95905c4bd2793861fb30aaa68b18d361d2c40205" translate="yes" xml:space="preserve">
          <source>If the named object is not a DirContext, search only the object. If the named object is a DirContext, search the subtree rooted at the named object, including the named object itself.</source>
          <target state="translated">명명 된 개체가 DirContext가 아닌 경우 개체 만 검색하십시오. 명명 된 객체가 DirContext 인 경우, 명명 된 객체 자체를 포함하여 명명 된 객체를 기반으로하는 하위 트리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a797ab321ba29b078906111b6a9d36444e539b67" translate="yes" xml:space="preserve">
          <source>If the nano-of-second is zero or not available then the format is complete.</source>
          <target state="translated">나노초가 0이거나 사용할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="18bffcd626a18ef77083ada33a312e98a304ff4c" translate="yes" xml:space="preserve">
          <source>If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.</source>
          <target state="translated">새 레벨이 널인 경우,이 노드는 특정 (널이 아닌) 레벨 값으로 가장 가까운 조상으로부터 레벨을 상속해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bc536a2662e091e215ec8f641a7473d3709fe706" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 다르면 상속을 통해 보호 된 멤버에 액세스 할 수 없습니다. (패키지 공유로 인해 보호 된 구성원이 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="60f2db2d23a3b70ce0836cac49cb47c5b9f6353f" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 조회 클래스와 다른 패키지에 있으면 보호 및 기본 (패키지) 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca96aa918a0139c5241a9be60ea7a47fde358969" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.)</source>
          <target state="translated">이전 조회 클래스에서 새 조회 클래스에 액세스 할 수 없으면 공개 멤버가 아닌 멤버는 액세스 할 수 없습니다. (다른 모든 경우에도 공개 멤버는 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1a7e98a2066ab4c0cf93405953a8d0cbcca7cb64" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 동일한 패키지 멤버 내에 있지 않으면 개인 멤버는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="070950b6983687a52f5c8a4982aa2eebcfd77d61" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 매핑 하고 결과 문자열을 &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigDecimal&lt;/code&gt; 값으로 변환됩니다. (문자열) 생성자.</target>
        </trans-unit>
        <trans-unit id="e2b55b595ce54b4c7a0ff65ce30ecb0da6b4383c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;double&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 추가하고 결과 문자열을 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; 로&lt;/a&gt; 전달하십시오 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a79c16b442949a70d19c9e0f0f3c3e6d85edf9f" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;float&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에두고 결과 문자열을 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; 로&lt;/a&gt; 전달합니다 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a4727cf6304247402307e6eaca3eff6d0258644" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 맵핑 하고 결과 문자열을 &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigInteger&lt;/code&gt; 값으로 변환됩니다. 기수가 지정된 (String, int) 생성자</target>
        </trans-unit>
        <trans-unit id="12b289473a0cfbe9016bed30eea7221cdd374181" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;byte&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="b349deb1d290eaa1752d8feff84d8af8caefc093" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;long&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="cde2372e3435e6554a5b5741f761096f7eea5fcf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;short&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부와 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e2e6b9af16a7a0f10ca898c5788d2527ee4c8561" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;int&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="50647ef6cfa173ffb331678172077c93b906dc08" translate="yes" xml:space="preserve">
          <source>If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute.</source>
          <target state="translated">숫자 뒤에 콜론이 오는 경우, 시간이 이미 인식되지 않은 경우 1 시간으로 간주되며,이 경우 1 분으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2185b02dab1b8be5d039095147b6a86e141a45f4" translate="yes" xml:space="preserve">
          <source>If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt;), unless a month has already been recognized, in which case it is regarded as a day of the month.</source>
          <target state="translated">숫자 뒤에 슬래시가 있으면 , 한 달이 이미 인식되지 않은 한, 한 달로 간주됩니다 ( &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;11&lt;/code&gt; 사이 의 숫자를 생성하기 위해 1 씩 감소됨 ). 이달의.</target>
        </trans-unit>
        <trans-unit id="24c204655d0c4e49fdb27ee92ac3fcb02b0bfac3" translate="yes" xml:space="preserve">
          <source>If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.</source>
          <target state="translated">숫자 다음에 공백, 쉼표, 하이픈 또는 문자열 끝이 오는 경우 시간이 인식되었지만 1 분이 아닌 경우 1 분으로 간주됩니다. 그렇지 않으면 1 분이 인식되었지만 1 초가 인식되지 않으면 1 초로 간주됩니다. 그렇지 않으면 월의 일로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="28b1d7370c2a1b58a891d34fad7ee082b38756d3" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;. Otherwise, this method uses the superclass's definition which returns true if the classes of the two instances are equal.</source>
          <target state="translated">지정된 생성자의 인수 수가 0이 &lt;code&gt;oldInstance&lt;/code&gt; 클래스가 명시 적으로 &quot;equals&quot;메소드를 선언하면이 메소드는 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 의 값을 리턴합니다 . 그렇지 않은 경우,이 메소드는 슈퍼 클래스 정의를 사용하여 두 인스턴스의 클래스가 동일한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d4af9d2d4726a8f3ade67f849e06bc1d1ab1564a" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying constructor is 0, the supplied &lt;code&gt;initargs&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본 생성자가 요구하는 형식 매개 변수의 수가 0 인 경우 제공된 &lt;code&gt;initargs&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a45750d8cf5475f9813ae9cb718f088a466add3" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying method is 0, the supplied &lt;code&gt;args&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본이되는 메소드에 필요한 형식 매개 변수의 수가 0 인 경우, 제공된 &lt;code&gt;args&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aecea4a5924a64f71d7845e41d1c3b018c067a01" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">패턴 문자 수가 4 개 이상인 경우 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 을 구성 하거나 &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;패턴을 적용&lt;/a&gt; 할 때 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="40ebc6195d83e88d053f6b7f4d083dcca34d15e6" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts.</source>
          <target state="translated">판독기 수가 이제 0이면 쓰기 잠금 시도에 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9539dfa1e1c4ed8a395e2b48d8e6f0bcbf6c71d0" translate="yes" xml:space="preserve">
          <source>If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned.</source>
          <target state="translated">객체에 요청 된 속성이 없으면 존재하지 않는 속성은 무시됩니다. 객체가 요청한 속성이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba188f9b3d08b409858ffc14dad0538d6c066ad5" translate="yes" xml:space="preserve">
          <source>If the object does not have an attribute specified, the directory will ignore the nonexistent attribute and return those requested attributes that the object does have.</source>
          <target state="translated">객체에 속성이 지정되어 있지 않으면 디렉토리는 존재하지 않는 속성을 무시하고 해당 객체에 요청 된 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d2b3a1e7cd5b23b39d1f5133dc5c01a091b5bb9" translate="yes" xml:space="preserve">
          <source>If the object does not have the attribute specified, the directory will ignore the nonexistent attribute and return the requested attributes that the object does have.</source>
          <target state="translated">오브젝트에 속성이 지정되지 않은 경우 디렉토리는 존재하지 않는 속성을 무시하고 오브젝트에있는 요청 된 속성을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f7640b018347f47539ec443ff012615b370426e4" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;PropertyChangeListener&lt;/code&gt; and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; 메소드 가있는 경우 리턴 된 배열은 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 및 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3efaaa6db916f5e8dd0c50701e6e2af84aea78e5" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;VetoableChangeListener&lt;/code&gt; and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; 메소드 가있는 경우 반환 된 배열은 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 및 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c633f6da7ab2fee69bd882fac3b3abc472fa5a8a" translate="yes" xml:space="preserve">
          <source>If the object is a &lt;code&gt;DirContext&lt;/code&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.</source>
          <target state="translated">객체가 &lt;code&gt;DirContext&lt;/code&gt; 인 경우, 이름과 연관된 기존 속성 이 객체 의 속성으로 대체됩니다. 그렇지 않으면 이름과 연관된 기존 속성은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f5b3142d8650d58dfbe46a9e556320ac2bd2e7d" translate="yes" xml:space="preserve">
          <source>If the offset is not available then the format is complete.</source>
          <target state="translated">오프셋을 사용할 수 없으면 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2519e323e000b11bce96906bcfd196efd2dc89f9" translate="yes" xml:space="preserve">
          <source>If the offset is not available to format or parse then the format is complete.</source>
          <target state="translated">오프셋을 포맷하거나 파싱 할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c280c860cb9f7effbb5d1573c9db972ff6dade1" translate="yes" xml:space="preserve">
          <source>If the opaque representation of a key (see &lt;a href=&quot;../key&quot;&gt;&lt;code&gt;Key&lt;/code&gt;&lt;/a&gt;) can be transformed (see &lt;a href=&quot;../keyfactory&quot;&gt;&lt;code&gt;KeyFactory&lt;/code&gt;&lt;/a&gt;) into this key specification (or a subclass of it), &lt;code&gt;getFormat&lt;/code&gt; called on the opaque key returns the same value as the &lt;code&gt;getFormat&lt;/code&gt; method of this key specification.</source>
          <target state="translated">키 (볼의 불투명 표현하면 &lt;a href=&quot;../key&quot;&gt; &lt;code&gt;Key&lt;/code&gt; &lt;/a&gt; ) (참조 변형 될 수 &lt;a href=&quot;../keyfactory&quot;&gt; &lt;code&gt;KeyFactory&lt;/code&gt; 에가&lt;/a&gt; 이 키 지정 (또는 서브 클래스)으로) &lt;code&gt;getFormat&lt;/code&gt; 는 AS 동일한 값 불투명 키 복귀 호출 &lt;code&gt;getFormat&lt;/code&gt; 이 키 지정 방법.</target>
        </trans-unit>
        <trans-unit id="a3a6f1065b50c79f203f06252e6050cc498ea0ba" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">원래의 타입과 새로운 타입이 같은 경우는 &lt;code&gt;this&lt;/code&gt; 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="15d571df526b560a24fbbc6f542b12d585fc4182" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns target.</source>
          <target state="translated">원래 형식과 새 형식이 같으면 target을 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
