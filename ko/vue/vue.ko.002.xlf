<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="686299f7711a328af7f7ede481ecd878f135b9f6" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;code&gt;v-if&lt;/code&gt; has higher toggle costs while &lt;code&gt;v-show&lt;/code&gt; has higher initial render costs. So prefer &lt;code&gt;v-show&lt;/code&gt; if you need to toggle something very often, and prefer &lt;code&gt;v-if&lt;/code&gt; if the condition is unlikely to change at runtime.</source>
          <target state="translated">일반적으로 &lt;code&gt;v-if&lt;/code&gt; 는 전환 비용이 높고 &lt;code&gt;v-show&lt;/code&gt; 는 초기 렌더링 비용이 높습니다. 따라서 자주 전환해야하는 경우 &lt;code&gt;v-show&lt;/code&gt; 를 선호 하고 런타임에 조건이 변경되지 않을 경우 &lt;code&gt;v-if&lt;/code&gt; 를 선호 하십시오.</target>
        </trans-unit>
        <trans-unit id="54c5f98c2534a5664e54bdf67174809b2a27c8a3" translate="yes" xml:space="preserve">
          <source>Get Support</source>
          <target state="translated">지원을 받다</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="4687f4eea959b8d3a7678579930ba86b60298a4b" translate="yes" xml:space="preserve">
          <source>Global API</source>
          <target state="translated">글로벌 API</target>
        </trans-unit>
        <trans-unit id="d99de9060d9d291cf15a1d729547287918e216dc" translate="yes" xml:space="preserve">
          <source>Global Config</source>
          <target state="translated">글로벌 구성</target>
        </trans-unit>
        <trans-unit id="a87e1f8386cdfab8951563f9287ce245995f5751" translate="yes" xml:space="preserve">
          <source>Global Mixin</source>
          <target state="translated">글로벌 믹스 인</target>
        </trans-unit>
        <trans-unit id="12acfdfcb7281091faacdbe76162537707d677a4" translate="yes" xml:space="preserve">
          <source>Global Registration</source>
          <target state="translated">글로벌 등록</target>
        </trans-unit>
        <trans-unit id="d23476cf27dc98d9e3173cbdb68ad4566d7bbe61" translate="yes" xml:space="preserve">
          <source>Global registration often isn&amp;rsquo;t ideal. For example, if you&amp;rsquo;re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">글로벌 등록은 종종 이상적이지 않습니다. 예를 들어 Webpack과 같은 빌드 시스템을 사용하는 경우 모든 구성 요소를 전체적으로 등록하면 구성 요소 사용을 중지하더라도 최종 빌드에 해당 구성 요소가 계속 포함될 수 있습니다. 이것은 사용자가 다운로드해야하는 JavaScript의 양을 불필요하게 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e2b51a4acf3ac2ad46709058f4a65e88a724bd55" translate="yes" xml:space="preserve">
          <source>Global state management</source>
          <target state="translated">글로벌 상태 관리</target>
        </trans-unit>
        <trans-unit id="d2cdbb9287a2eee1e29278ad1a52afa18af50490" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created afterwards &amp;ndash; and even inside all subcomponents of that Vue instance&amp;rsquo;s component tree.</source>
          <target state="translated">전역 적으로 등록 된 구성 요소는 이후에 생성 된 루트 Vue 인스턴스 ( &lt;code&gt;new Vue&lt;/code&gt; ) 의 템플릿 과 해당 Vue 인스턴스 구성 요소 트리의 모든 하위 구성 요소 내 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d53a8dc9787d0f1938039b6b2df16c89e2967b1" translate="yes" xml:space="preserve">
          <source>Go ahead and enter &lt;code&gt;app3.seen = false&lt;/code&gt; in the console. You should see the message disappear.</source>
          <target state="translated">콘솔에 &lt;code&gt;app3.seen = false&lt;/code&gt; 를 입력하십시오 . 메시지가 사라지는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61dedcf053ff33692baacbf7789c5d7195d9acbe" translate="yes" xml:space="preserve">
          <source>Good</source>
          <target state="translated">Good</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="613dffa8c694c4b79227626375484864e1cbb5bc" translate="yes" xml:space="preserve">
          <source>HTML &amp;amp; CSS</source>
          <target state="translated">HTML 및 CSS</target>
        </trans-unit>
        <trans-unit id="ecb5ae374f41987062d1edb5a439c141fbcfee47" translate="yes" xml:space="preserve">
          <source>HTML Interpolation &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">HTML 보간 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="61152bedc285b45e3443132c85b9e9eab87b1c71" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">HTML 속성 이름은 대소 문자를 구분하지 않으므로 브라우저는 대문자를 소문자로 해석합니다. 즉, DOM 내 템플릿을 사용하는 경우 camelCased 소품 이름은 케밥으로 묶인 (하이픈으로 구분) 등가물을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="206317f92c61c3721e7b0ef393e74b50f2adc608" translate="yes" xml:space="preserve">
          <source>HTML elements,</source>
          <target state="translated">HTML 요소</target>
        </trans-unit>
        <trans-unit id="b7d20a95e49462d14a4c08f7dda3686750b36c96" translate="yes" xml:space="preserve">
          <source>HTML interpolation has been &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;removed in favor of &lt;code&gt;v-html&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt; 을 위해 HTML 보간이 제거 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0b1c56685d95ab775546bda4c6e1ef23eea39b81" translate="yes" xml:space="preserve">
          <source>HTML interpolations (&lt;code&gt;{{{ foo }}}&lt;/code&gt;) have been removed in favor of the &lt;a href=&quot;../api/index#v-html&quot;&gt;&lt;code&gt;v-html&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-html&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt; 지시문 을 위해 HTML 보간 ( &lt;code&gt;{{{ foo }}}&lt;/code&gt; )이 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ec5f7d68ba95b6c2f0128818861a5fb3a7ce41b3" translate="yes" xml:space="preserve">
          <source>HTML&amp;rsquo;s built-in input types won&amp;rsquo;t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">HTML의 내장 입력 유형이 항상 귀하의 요구를 충족시키는 것은 아닙니다. 다행히 Vue 구성 요소를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 입력을 작성할 수 있습니다. 이 입력은 &lt;code&gt;v-model&lt;/code&gt; 에서도 작동 합니다 ! 자세한 내용 은 구성 요소 안내서에서 &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;사용자 정의 입력&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="69b83e92529f5151314d046d862c4a9c77d93516" translate="yes" xml:space="preserve">
          <source>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue&amp;rsquo;s reactivity features.</source>
          <target state="translated">HTML 기반 템플릿을 사용하면 기존 애플리케이션을 점진적으로 마이그레이션하여 Vue의 반응성 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6fab8d8bdb45dbc0c724b264884e741a1423d5" translate="yes" xml:space="preserve">
          <source>Handling Edge Cases</source>
          <target state="translated">엣지 케이스 취급</target>
        </trans-unit>
        <trans-unit id="0c27db799f42037e36231e8871e3549a290cef26" translate="yes" xml:space="preserve">
          <source>Handling Loading State</source>
          <target state="translated">로딩 상태 처리</target>
        </trans-unit>
        <trans-unit id="f70e7e4e8994ebaac734eaf505f7cb87f5015b0f" translate="yes" xml:space="preserve">
          <source>Handling User Input</source>
          <target state="translated">사용자 입력 처리</target>
        </trans-unit>
        <trans-unit id="553c9fd444b729d939071ffd415fb951213f90a4" translate="yes" xml:space="preserve">
          <source>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</source>
          <target state="translated">해시 뱅은 더 이상 Google이 URL을 크롤링하는 데 필요하지 않으므로 더 이상 해시 전략의 기본값 (또는 옵션)이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a8d68b23680238f325efc34072a89db096cd1404" translate="yes" xml:space="preserve">
          <source>Having this validator extracted out, we&amp;rsquo;ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it&amp;rsquo;s actually impossible for users to enter anything wrong, similar to what the browser&amp;rsquo;s native number input tries to do.</source>
          <target state="translated">이 유효성 검사기를 추출한 후 더욱 안정적인 솔루션에보다 편안하게 구축했습니다. 상태 문제가 제거되었으며 실제로 브라우저의 기본 숫자 입력과 비슷한 방식으로 사용자가 잘못 입력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d3e638fd34dc7467faa0ba823b8497588b5815b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;attributeName&lt;/code&gt; 은 JavaScript 표현식으로 동적으로 평가되며 평가 된 값이 인수의 최종 값으로 사용됩니다. 예를 들어 Vue 인스턴스에 값이 &lt;code&gt;&quot;href&quot;&lt;/code&gt; 인 데이터 속성 &lt;code&gt;attributeName&lt;/code&gt; 이있는 경우이 바인딩은 &lt;code&gt;v-bind:href&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="89a97b67c98ddcf2e842f6272379190e542a3a62" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;filterA&lt;/code&gt; is defined as a function taking three arguments. The value of &lt;code&gt;message&lt;/code&gt; will be passed into the first argument. The plain string &lt;code&gt;'arg1'&lt;/code&gt; will be passed into the &lt;code&gt;filterA&lt;/code&gt; as its second argument, and the value of expression &lt;code&gt;arg2&lt;/code&gt; will be evaluated and passed in as the third argument.</source>
          <target state="translated">여기서 &lt;code&gt;filterA&lt;/code&gt; 는 세 개의 인수를 취하는 함수로 정의됩니다. &lt;code&gt;message&lt;/code&gt; 값은 첫 번째 인수로 전달됩니다. 일반 문자열 &lt;code&gt;'arg1'&lt;/code&gt; 은 두 번째 인수로 &lt;code&gt;filterA&lt;/code&gt; 에 전달되고 &lt;code&gt;arg2&lt;/code&gt; 표현식의 값은 세 번째 인수로 평가 및 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b533c1b3a997459bdeab6c6103d2b8341430c012" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">여기 &lt;code&gt;href&lt;/code&gt; 는 &lt;code&gt;v-bind&lt;/code&gt; 지시문에 요소의 &lt;code&gt;href&lt;/code&gt; 속성을 &lt;code&gt;url&lt;/code&gt; 표현식의 값에 바인딩하도록 지시 하는 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="e8a2ad49522f0c5140bd579d6e3f6cc63de82a9e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; can be omitted as it is implied:</source>
          <target state="translated">여기에서 &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; 는 암시 적으로 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a992eb5c40fb541d26012305484c0906879154" translate="yes" xml:space="preserve">
          <source>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</source>
          <target state="translated">여기서 인수는 수신 할 이벤트 이름입니다. 이벤트 처리에 대해 더 자세히 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f407b88178ffc4e03f9f78c8af7c050fb1a05bb8" translate="yes" xml:space="preserve">
          <source>Here we are encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you are seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &amp;ldquo;keep this element&amp;rsquo;s &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the Vue instance.&amp;rdquo;</source>
          <target state="translated">여기서 우리는 새로운 무언가를 만나고 있습니다. 보고있는 &lt;code&gt;v-bind&lt;/code&gt; 속성을 &lt;strong&gt;지시문&lt;/strong&gt; 이라고합니다 . 지시문 앞에 &lt;code&gt;v-&lt;/code&gt; 가 붙은 것은 Vue에서 제공하는 특수 속성임을 나타내며, 짐작할 수 있듯이 렌더링 된 DOM에 특별한 반응 동작을 적용합니다. 여기서는 기본적으로 &quot; Vue 인스턴스 의 &lt;code&gt;message&lt;/code&gt; 속성을 사용 하여이 요소의 &lt;code&gt;title&lt;/code&gt; 속성을 최신 상태로 유지하십시오&quot;라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="20439924cb310f6e6ebea9dce4e509745f1d1bb0" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;reversedMessage&lt;/code&gt;. The function we provided will be used as the getter function for the property &lt;code&gt;vm.reversedMessage&lt;/code&gt;:</source>
          <target state="translated">여기에서 계산 된 속성 &lt;code&gt;reversedMessage&lt;/code&gt; 를 선언했습니다 . 우리가 제공 한 함수는 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 속성의 getter 함수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="41a58605aec4adfd7f18a1d980084fe022c01384" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete example of a simple todo list:</source>
          <target state="translated">간단한 할 일 목록의 전체 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6deaab1ac1757bb576b7c7fb31ce01f23836233" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a &lt;code&gt;smart-list&lt;/code&gt; component that delegates to more specific components, depending on the props passed to it:</source>
          <target state="translated">다음은 전달 된 소품에 따라보다 구체적인 구성 요소를 위임 하는 &lt;code&gt;smart-list&lt;/code&gt; 구성 요소 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8edc36b060f6cabd0970dde81f8964d59b6e1225" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a Vue component:</source>
          <target state="translated">Vue 구성 요소의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b31be59658661ba4e66f41944f3554b7a0be5398" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a file we&amp;rsquo;ll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Hello.vue&lt;/code&gt; 라는 파일의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b33ffef562696923d8035d66d6b00e446f9c5cd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example using a template component:</source>
          <target state="translated">템플릿 구성 요소를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99ff339aed17c551cb54d5842ca9646f53c8ed64" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with all of these modifiers used together:</source>
          <target state="translated">다음은 이러한 수정자가 모두 함께 사용 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="18a91a386128ffc554ca249fb0825499466cf9d3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">다음은 간결성을 위해 접두사 CSS 규칙을 생략 한 예입니다.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7ffc75a586e32509010b20213e0f4e623c0e848" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s that in action:</source>
          <target state="translated">그 행동은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a829483e3b314613758a5a663c73e6905d5701b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;slot-scope&lt;/code&gt; declares the received props object as the &lt;code&gt;slotProps&lt;/code&gt; variable, and makes it available inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; scope. You can name &lt;code&gt;slotProps&lt;/code&gt; anything you like similar to naming function arguments in JavaScript.</source>
          <target state="translated">여기서 &lt;code&gt;slot-scope&lt;/code&gt; 는 수신 된 props 객체를 &lt;code&gt;slotProps&lt;/code&gt; 변수 로 선언 하고 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 범위 내에서 사용할 수 있도록합니다 . JavaScript에서 함수 인수 이름 지정과 비슷한 것을 원하는 이름으로 &lt;code&gt;slotProps&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f68e5bf516c14d7636dc7e787f07b009104eba6f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;v-if&lt;/code&gt; directive would remove/insert the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element based on the truthiness of the value of the expression &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">여기서, &lt;code&gt;v-if&lt;/code&gt; 지시자 제거 할 / 삽입 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 식의 값에 기초하여 요소 truthiness &lt;code&gt;seen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e26e3e40dfd6774d32a14ec704c7c19bb0bf799" translate="yes" xml:space="preserve">
          <source>Hook Functions</source>
          <target state="translated">후크 기능</target>
        </trans-unit>
        <trans-unit id="d2bdd950b4b524b4faf0540c42b846e440d3ebd2" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component&amp;rsquo;s own hooks.</source>
          <target state="translated">이름이 같은 후크 함수는 배열로 병합되어 모든 함수가 호출됩니다. 컴포넌트 자체 후크 &lt;strong&gt;전에&lt;/strong&gt; 믹스 인 후크가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="656dedbf5301c31ed9bdf32f2a451638643101f3" translate="yes" xml:space="preserve">
          <source>How Changes Are Tracked</source>
          <target state="translated">변경 사항을 추적하는 방법</target>
        </trans-unit>
        <trans-unit id="a056aea1f6dc2d57c44eacd2de4c8078611a80e1" translate="yes" xml:space="preserve">
          <source>How long will it take to migrate a Vue 1.x app to 2.0?</source>
          <target state="translated">Vue 1.x 앱을 2.0으로 마이그레이션하는 데 얼마나 걸립니까?</target>
        </trans-unit>
        <trans-unit id="a173386c8ab0ffd650a7e5d8b6fb73ce6260ce4e" translate="yes" xml:space="preserve">
          <source>How many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!</source>
          <target state="translated">산만하고 멋진 새 기능으로 게임을 시작하는 횟수입니다. 😉 판단하지 않고 2.0을 구축하는 동안 우리에게도 일어났습니다!</target>
        </trans-unit>
        <trans-unit id="5b51fcd95b1bb4c1d0a2feadea82b32351c13de4" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;inline-template&lt;/code&gt; makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the &lt;code&gt;template&lt;/code&gt; option or in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element in a &lt;code&gt;.vue&lt;/code&gt; file.</source>
          <target state="translated">그러나 &lt;code&gt;inline-template&lt;/code&gt; 은 템플릿 의 범위를 추론하기 어렵게 만듭니다. 모범 사례로 &lt;code&gt;template&lt;/code&gt; 옵션 또는 &lt;code&gt;.vue&lt;/code&gt; 파일 의 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 사용하여 구성 요소 내부에서 템플릿을 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="42d602a14282520e03f05621c18e657389b28401" translate="yes" xml:space="preserve">
          <source>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;, &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;, and &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;.</source>
          <target state="translated">그러나 이것조차도 범위가 지정된 슬롯이 할 수있는 표면을 거의 긁지 않습니다. 실제 유효하고 범위가 지정된 슬롯 사용의 예를 보려면 &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt; , &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt; 와 같은 라이브러리를 찾아 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e377ccc91063a19e1128087c043b05ac14bc27fd" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;Vue.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">그러나 &lt;code&gt;Vue.component&lt;/code&gt; 를 통해 전역 구성 요소 정의 &lt;strong&gt;만&lt;/strong&gt; 사용하는 응용 프로그램의 경우 대신 케밥 케이스를 권장합니다. 그 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">그러나 Webpack 또는 Browserify와 같은 &lt;strong&gt;모듈 시스템을&lt;/strong&gt; 사용하여 구성 요소를 요구하거나 가져 오는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 위의 사항을 배제하고 수동으로 강제 업데이트해야하는 매우 드문 상황에 처한 경우 &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">그러나 경우에 따라 동일한 요소 (예 : Vue에 의해 트리거 된 CSS 애니메이션 및 호버에 대한 CSS 전환 효과)를 둘 수 있습니다. 이 경우 Vue가 신경 쓰고 자하는 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;animation&lt;/code&gt; 또는 &lt;code&gt;transition&lt;/code&gt; 값으로 유형 속성 에서 명시 적으로 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">그러나 다른 지시문과 마찬가지로 속기는 인수가 제공 될 때만 사용할 수 있습니다. 이는 다음 구문이 유효하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">그러나 모든 사람이 TypeScript를 사용하려는 것은 아닙니다. 많은 소규모 사용 사례에서 유형 시스템을 도입하면 생산성 향상보다 더 많은 오버 헤드가 발생할 수 있습니다. 이러한 경우 TypeScript없이 Angular를 사용하는 것이 어려울 수 있으므로 Vue를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">그러나 의존성 주입에는 단점이 있습니다. 응용 프로그램의 구성 요소를 현재 구성되어있는 방식으로 연결하므로 리팩토링이 더 어려워집니다. 제공된 속성도 반응하지 않습니다. 중앙 데이터 저장소를 만드는 데 &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;사용 &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt; 하면 같은 목적으로 $ root 를 사용하는 것만 큼 ​​좋지 않은 확장 성을 가지기 때문에 이것은 의도적으로 설계된 것입니다. 공유하려는 속성이 일반적인 것이 아니라 앱에 고유하거나 조상 내부에서 제공된 데이터를 업데이트하려는 경우 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 와 같은 실제 상태 관리 솔루션이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">그러나 여러 개의 조건부 클래스가있는 경우이 방법이 다소 장황 할 수 있습니다. 그렇기 때문에 배열 구문 내에서 객체 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">그러나 구성 요소에는 자체 범위가 분리되어 있으므로 구성 요소에 데이터를 자동으로 전달하지 않습니다. 반복 된 데이터를 컴포넌트로 전달하려면 props도 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">그러나 먼 자손 / 조상들 사이에서 의사 소통을 할 때는 &lt;code&gt;$emit&lt;/code&gt; 이 도움이되지 않습니다. 대신 가장 간단한 업그레이드는 중앙 집중식 이벤트 허브를 사용하는 것입니다. 이것은 컴포넌트 트리의 어느 위치에 있든지, 심지어 형제 사이에서도 컴포넌트 사이에서 통신 할 수 있다는 추가 이점이 있습니다! Vue 인스턴스는 이벤트 이미 터 인터페이스를 구현하므로 실제로이 목적으로 빈 Vue 인스턴스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">그러나 명시 적으로 나타내려면 여전히 기본 슬롯 컨텐츠를 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 랩핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">현재이 문장을 원하는 언어로 읽고 있기를 바랍니다. 그렇지 않은 경우, 우리가 거기에 도착하는 데 도움을 원하십니까?</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">물어봐서 기뻐요! 대답은 '아니오. API의 약 90 %가 동일하며 핵심 개념은 변경되지 않았습니다. 우리는 매우 자세한 설명을 제공하고 많은 예제를 포함하기 때문에 오래 걸립니다. 안심하십시오, &lt;strong&gt;이것은 위에서 아래로 읽어야 할 것이 아닙니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 의 서식 않았다 &lt;strong&gt;하지&lt;/strong&gt; 포함 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소는 삭제된다 개폐 태그 사이에 제공된 콘텐츠.</target>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">경우 &lt;code&gt;elementOrSelector&lt;/code&gt; 의 인수가 제공되지 템플릿은 오프 문서 요소로 렌더링 될 것입니다, 당신은 문서에 직접 삽입하는 기본 DOM API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">경우 &lt;code&gt;isButtonDisabled&lt;/code&gt; 이 값 갖는 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 상기 &lt;code&gt;disabled&lt;/code&gt; 특성에도 표현에 포함되지 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 엘리먼트.</target>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Vue 2로 업그레이드 할 경우 Vuex 및 Vue 라우터도 업그레이드해야합니까?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Vue에이 규칙이없는 경우 하나의 버튼을 클릭하면 아래와 같이 &lt;em&gt;다른 모든 인스턴스&lt;/em&gt; 의 데이터에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Vue 인스턴스가 인스턴스화시 &lt;code&gt;el&lt;/code&gt; 옵션을받지 못한 경우 연관된 DOM 요소없이 &quot;마운트 해제&quot;상태가됩니다. &lt;code&gt;vm.$mount()&lt;/code&gt; 를 사용하여 마운트 해제 된 Vue 인스턴스 마운트를 수동으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">구성 요소가 단일 상위 구성 요소의 컨텍스트에서만 의미가있는 경우 해당 관계는 해당 이름으로 분명해야합니다. 편집기는 일반적으로 파일을 사전 순으로 구성하기 때문에 이러한 관련 파일을 서로 옆에 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">구성 요소를 렌더링하는 동안 런타임 오류가 발생하면 전역 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 구성 함수 (설정된 경우) 로 전달됩니다 . Vue &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;의 공식 통합&lt;/a&gt; 을 제공 하는 &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt; 와 같은 오류 추적 서비스와 함께이 후크를 활용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">이벤트와 콜백이 모두 제공된 경우 해당 특정 콜백에 대한 리스너 만 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">대신, 루프 실행을 조건부로 건너 뛰려는 &lt;code&gt;v-if&lt;/code&gt; 래퍼 요소 (또는 &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt; ) 에 v-if 를 배치 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">다른 이름을 가진 속성에서 주입해야하는 경우 &lt;code&gt;from&lt;/code&gt; 을 사용하여 소스 속성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">구성 요소의 상속 체인 또는 상위 체인에 여러 개의 &lt;code&gt;errorCaptured&lt;/code&gt; 후크가 존재하는 경우 모두 동일한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 함수 나 &lt;code&gt;template&lt;/code&gt; 옵션이 없으면 마운트 DOM 요소의 DOM 내 HTML이 템플릿으로 추출됩니다. 이 경우 Vue의 Runtime + Compiler 빌드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">CSS 전환 / 애니메이션이 감지되지 않고 JavaScript 후크가 제공되지 않으면 삽입 및 / 또는 제거를위한 DOM 작업이 다음 프레임에서 즉시 실행됩니다 (참고 : 이는 Vue의 &lt;code&gt;nextTick&lt;/code&gt; 개념과 다른 브라우저 애니메이션 프레임입니다 ).</target>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">인수가 제공되지 않으면 모든 이벤트 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">이벤트 만 제공되는 경우 해당 이벤트에 대한 모든 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Vue 옵션에 렌더링 기능이있는 경우 템플릿이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; 통해 &lt;code&gt;vm.$data&lt;/code&gt; 를 전달하여 원본 객체의 딥 클론을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">그렇다면 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;이 문서&lt;/a&gt; 나 공식적으로 관리되는 다른 문서에 대해 리포지토리를 포크하여 번역을 시작하십시오. 약간의 진전이 이루어지면 메인 리포지토리에서 이슈를 열거 나 풀 요청을하면 더 많은 기고자를 도와 줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;errorCaptured&lt;/code&gt; 의 후크 자체가 오류가 발생,이 오류 원래 촬영 된 오류는 모두 글로벌로 전송됩니다 &lt;code&gt;config.errorHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">구성 요소가 기능적 구성 요소 인 경우, 렌더링 함수는 추가 인수 &lt;code&gt;context&lt;/code&gt; 를 수신하여 기능적 구성 요소가 인스턴스가 없으므로 컨텍스트 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 표현식 의 초기 값이 옵션과 일치하지 않으면 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소가 &quot;선택되지 않은&quot;상태로 렌더링됩니다. iOS에서는이 경우 iOS가 변경 이벤트를 시작하지 않기 때문에 사용자가 첫 번째 항목을 선택할 수 없습니다. 따라서 위의 예에서와 같이 비활성화 된 옵션에 빈 값을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">문자열이 &lt;code&gt;#&lt;/code&gt; 으로 시작 하면 querySelector로 사용되고 선택된 요소의 innerHTML을 템플릿 문자열로 사용합니다. 이를 통해 일반적인 &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; 트릭을 사용하여 템플릿을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">전이 컴포넌트가 &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript 후크를&lt;/a&gt; 제공 한 경우 이러한 후크는 적절한 타이밍에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt; 와 같이 사용하려는 타사 라우터가있는 경우 통합도 &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;비슷&lt;/a&gt; 합니다. 다음은 Page.js &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;를&lt;/a&gt; 사용한 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">이 옵션을 인스턴스화 할 때 사용할 수있는 경우 인스턴스는 즉시 컴파일에 들어갑니다. 그렇지 않으면 사용자가 컴파일을 수동으로 시작하기 위해 &lt;code&gt;vm.$mount()&lt;/code&gt; 를 명시 적으로 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">노드의 초기 렌더링에 전환을 적용하려는 경우 &lt;code&gt;appear&lt;/code&gt; 속성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">CSS-in-JS의 팬이라면 널리 사용되는 많은 CSS-in-JS 라이브러리는 Vue (예 : &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt; )를 지원합니다. 여기서 React와 Vue의 주요 차이점은 Vue의 기본 스타일 지정 방법은 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 에서 더 친숙한 &lt;code&gt;style&lt;/code&gt; 태그를 사용 한다는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">숙련 된 프론트 엔드 개발자이고 Vue가 다른 라이브러리 / 프레임 워크와 비교하는 방법을 알고 싶다면 &lt;a href=&quot;guide/comparison&quot;&gt;다른 프레임 워크와 비교를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">대규모 프로젝트를 개발 중이거나 다른 개발자와 협력하거나 때로는 타사 HTML / CSS (예 : Auth0)를 포함하는 경우 일관된 범위 지정을 사용하면 스타일이 의도 한 구성 요소에만 스타일을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">Virtual DOM 개념에 익숙하고 JavaScript의 강력한 기능을 선호하는 경우 선택적인 JSX 지원으로 템플릿 대신 &lt;a href=&quot;render-function&quot;&gt;렌더링 함수&lt;/a&gt; 를 직접 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Webpack을 사용하고 JavaScript와 템플릿 파일을 분리하는 것을 선호하는 경우 &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader를&lt;/a&gt; 사용 하면 빌드 단계에서 템플릿 파일을 JavaScript 렌더링 함수로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">기본 ES 모듈을 사용하는 경우 ES 모듈 호환 빌드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">템플리트 기반 기능 구성 요소를 사용하는 경우 속성 및 리스너를 수동으로 추가해야합니다. 개별 컨텍스트 컨텐츠에 액세스 할 수 있으므로 &lt;code&gt;data.attrs&lt;/code&gt; 를 사용 하여 HTML 속성 및 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;( &lt;code&gt;data.on&lt;/code&gt; 의 별명 )&lt;/em&gt; 를 전달하여 이벤트 리스너를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">전체 빌드를 사용하는 경우 (예 : 빌드 도구없이 스크립트 태그를 통해 Vue를 직접 포함하는 경우 ) 프로덕션에 축소 버전 ( &lt;code&gt;vue.min.js&lt;/code&gt; ) 을 사용해야합니다 . 두 버전 모두 &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;설치 안내서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">구성 요소의 루트 요소가 속성을 상속 하지 &lt;strong&gt;않게&lt;/strong&gt; 하려면 구성 요소 옵션에서 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 를 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">data 옵션에 &lt;code&gt;message&lt;/code&gt; 를 선언하지 않으면 Vue는 렌더링 함수가 존재하지 않는 속성에 액세스하려고한다는 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">유형 유추 나 멤버 완성이 작동하지 않는 경우 특정 방법에 주석을 달면 이러한 문제를 해결하는 데 도움이 될 수 있습니다. &lt;code&gt;--noImplicitAny&lt;/code&gt; 옵션을 사용하면 주석이없는 많은 메소드를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Vue에서 99.99 %의 사례를 강제로 업데이트해야하는 경우 어딘가에 실수를 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">앱의 성능에 중요한 부분에서 부분을 사용하는 경우 &lt;a href=&quot;render-function#Functional-Components&quot;&gt;기능적 구성 요소로&lt;/a&gt; 업그레이드해야 합니다 . 파일은 &lt;code&gt;.vue&lt;/code&gt; 파일이 아닌 일반 JS / JSX 파일에 있어야하며 부분과 같이 상태 비 저장 및 인스턴스가 없어야합니다 . 렌더링 속도가 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">지역 Vue 커뮤니티에 더 많이 참여할 수있는 방법에 대한 질문이 있으면 &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt; 에 문의하십시오 !</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">테스트가있는 경우 테스트를 실행하고 여전히 실패한 것을 확인하십시오. 테스트가없는 경우 브라우저에서 앱을 열고 탐색 할 때 경고 나 오류가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">여러 개의 별칭이 필요한 경우 배열 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">라우터를 인스턴스화 한 후 새 경로를 추가해야하는 경우 라우터의 일치자를 추가하려는 경로가 포함 된 새 경로로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">클라이언트에서 템플릿을 컴파일해야하는 경우 (예 : 문자열을 &lt;code&gt;template&lt;/code&gt; 옵션에 전달하거나 DOM 내부 HTML을 템플릿으로 사용하여 요소에 마운트) 컴파일러와 전체 빌드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">앱을 시작할 때 프로그래밍 방식으로 경로를 생성해야하는 경우, 동적으로 정의를 경로 배열로 푸시하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">목록 전환을 스 태거해야하는 경우 요소 에서 &lt;code&gt;data-index&lt;/code&gt; (또는 유사한 속성)을 설정하고 액세스하여 타이밍을 제어 할 수 있습니다 . &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;여기 예를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">매우 간단한 라우팅 만 필요하고 완전한 기능을 갖춘 라우터 라이브러리를 사용하지 않으려면 다음과 같이 페이지 수준 구성 요소를 동적으로 렌더링하면됩니다.</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">JavaScript 콘솔을 다시 열고 &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; 입력 하면 바인딩 된 HTML (이 경우 &lt;code&gt;title&lt;/code&gt; 속성)이 업데이트되었음을 다시 한 번 보게 됩니다.</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">컴포넌트를 선언 할 때 클래스 기반 API를 선호하는 경우 공식적으로 유지 관리되는 &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; 데코레이터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">더 대화 형을 선호하는 경우 &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;Scrimba에서이 자습서 시리즈를&lt;/a&gt; 확인 하여 언제든지 일시 중지하고 재생할 수있는 스크린 캐스트 및 코드 놀이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">다른 &lt;code&gt;!important&lt;/code&gt; 를 재정의해야하는 경우 문자열 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">동일한 요소 / 구성 요소를 여러 번 복제하려는 경우 팩토리 기능을 사용하면됩니다. 예를 들어, 다음 렌더링 기능은 20 개의 동일한 단락을 렌더링하는 완벽하게 유효한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">콜백 내에서 감시 해제 기능을 계속 호출하려면 먼저 가용성을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">그러나 템플릿 에서이 작업을 시도하면 Vue에 &lt;strong&gt;모든 구성 요소에 단일 루트 요소가 있어야&lt;/strong&gt; 한다는 오류가 표시됩니다 . 다음과 같은 상위 요소로 템플리트를 랩핑하여이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">웹 구성 요소와 같은 템플릿에서 Vue가 아닌 사용자 정의 요소를 사용하는 경우 PascalCase는 Vue 구성 요소가 명확하게 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">소품을 강제로 사용하려면 대신 소품을 기반으로 로컬 계산 값을 설정하십시오. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">바로 들어가서 단일 파일 구성 요소로 게임을 시작하려면 CodeSandbox &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;에서이 간단한 할 일 앱&lt;/a&gt; 을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">당신이 소품 같은 객체의 속성이 모두 통과 할 경우 사용할 수있는 &lt;code&gt;v-bind&lt;/code&gt; (인수없이 &lt;code&gt;v-bind&lt;/code&gt; 대신 &lt;code&gt;v-bind:prop-name&lt;/code&gt; ). 예를 들어, &lt;code&gt;post&lt;/code&gt; 오브젝트가 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">지시문을 로컬에 대신 등록하려는 경우 구성 요소는 &lt;code&gt;directives&lt;/code&gt; 옵션 도 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">사용자 입력을 자동으로 숫자로 타입 캐스트 하려면 &lt;code&gt;v-model&lt;/code&gt; 관리 입력에 &lt;code&gt;number&lt;/code&gt; 수정자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">사용자 입력의 공백을 자동으로 트리밍하려면 &lt;code&gt;trim&lt;/code&gt; &lt;code&gt;v-model&lt;/code&gt; 수정자를 v 모델 관리 입력에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">이전에 구성 요소 업데이트 후 DOM으로 작업을 수행하기 위해 &lt;code&gt;vm.$watch&lt;/code&gt; 에 의존 한 경우 &lt;code&gt;updated&lt;/code&gt; 수명주기 후크 에서 대신 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">목록에서 클래스를 조건부로 토글하려면 3 항 표현식으로 클래스를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">다이빙하기 전에 Vue에 대해 더 자세히 알고 싶다면 핵심 원칙과 샘플 프로젝트를 안내하는 비디오를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">비동기 구성 요소를 사용하려는 &lt;strong&gt;Browserify&lt;/strong&gt; 사용자 인 경우 불행히도 작성자는 비동기로드가 &quot;브라우저 화가 지원하지 않는 것&quot;임을 &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;분명히&lt;/a&gt; 했습니다. 적어도 공식적으로는 Browserify 커뮤니티는 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;몇 가지 해결 방법&lt;/a&gt; 을 찾았 으며 이는 기존의 복잡한 응용 프로그램에 도움이 될 수 있습니다. 다른 모든 시나리오의 경우 내장 된 일류 비동기 지원을 위해 Webpack을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">React에서 온다면 vuex 가 해당 생태계에서 가장 인기있는 Flux 구현 인 &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt; 와 어떻게 비교되는지 궁금 할 것 입니다. Redux는 실제로 뷰 레이어에 구애받지 않으므로 &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;간단한 바인딩을&lt;/a&gt; 통해 Vue와 함께 쉽게 사용할 수 있습니다 . Vuex는 점에서 차이가 &lt;em&gt;알고&lt;/em&gt; 그것은 뷰 응용 프로그램에 있습니다. 이를 통해 Vue와 더 잘 통합되어보다 직관적 인 API와 개선 된 개발 경험을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">조심하지 않으면 재귀 적 구성 요소가 무한 루프로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; 모듈 시스템을 사용하지 않는 경우 ,이 섹션을 건너 뛸 수 있습니다. 당신이 있다면, 우리는 당신을 위해 몇 가지 특별한 지침과 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">아직 Vue의 구성 요소에 익숙하지 않다면 지금은 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">여전히 여기 있다면 Babel 및 Webpack과 같은 모듈 시스템을 사용하고있을 가능성이 있습니다. 이 경우 각 구성 요소를 자체 파일에 포함하여 구성 &lt;code&gt;components&lt;/code&gt; 디렉토리를 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">많은 &lt;code&gt;render&lt;/code&gt; 함수를 작성하는 경우 다음과 같이 작성하는 것이 고통 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">지시문에 여러 값이 필요한 경우 JavaScript 객체 리터럴을 전달할 수도 있습니다. 지시문은 유효한 JavaScript 식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">이것이 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 의 템플릿이라고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">암시 적 부모-자식 의사 소통</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;주의해서&lt;/sup&gt; 암시적인 부모-자식 의사 소통 &lt;sup&gt;사용&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">2.2.0+ 이상에서 &lt;code&gt;activated&lt;/code&gt; 및 &lt;code&gt;deactivated&lt;/code&gt; 는 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 트리 내부의 모든 중첩 구성 요소에 대해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">2.2.0+에서이 후크는 구성 요소 수명주기 후크의 오류도 캡처합니다. 또한이 후크가 &lt;code&gt;undefined&lt;/code&gt; 않으면 캡처 된 오류가 앱 을 &lt;code&gt;console.error&lt;/code&gt; 대신 console.error 와 함께 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">2.2.0 이상에서는 구성 요소와 함께 &lt;code&gt;v-for&lt;/code&gt; 를 사용할 때 &lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">2.4.0 이상에서이 후크는 Vue 사용자 정의 이벤트 핸들러에 발생한 오류를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">2.5.0 이상에서 주입은 기본값으로 선택적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">2.5.0 이상에서 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소를&lt;/a&gt; 사용하는 경우 다음을 사용하여 템플릿 기반 기능 구성 요소를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">2.6 이상에서 &lt;code&gt;v-for&lt;/code&gt; 는 기본 &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 을 포함 하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt; 을 구현하는 값에 대해서도 작업 할 수 있습니다 . 그러나 Vue 2.x는 현재 &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 값 에 대한 반응성을 지원하지 않으므로 변경 사항을 자동으로 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">2.6.0 이상에서이 후크는 &lt;code&gt;v-on&lt;/code&gt; DOM 리스너 에서 발생한 오류를 캡처합니다 . 또한 적용되는 후크 또는 처리기 중 하나가 Promise 체인 (예 : 비동기 함수)을 반환하면 해당 Promise 체인의 오류도 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">2.6.0에서는 명명 된 슬롯과 범위가 지정된 슬롯에 대한 새로운 통합 구문 ( &lt;code&gt;v-slot&lt;/code&gt; 지시문)이 도입되었습니다. 현재 사용되지 않지만 제거 &lt;em&gt;되지 않았&lt;/em&gt; 으며 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;여기에&lt;/a&gt; 문서화되어 있는 &lt;code&gt;slot&lt;/code&gt; 및 &lt;code&gt;slot-scope&lt;/code&gt; 속성을 대체합니다 . 새로운 구문을 도입 한 이유는이 &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC에&lt;/a&gt; 설명되어 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">에서 &lt;a href=&quot;../guide/single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; , &lt;code&gt;scoped&lt;/code&gt; 스타일 컨텐츠 내부에 적용되지 않습니다 &lt;code&gt;v-html&lt;/code&gt; 이 HTML이 뷰의 템플릿 컴파일러에 의해 처리되지 않기 때문에. 범위가 지정된 CSS로 &lt;code&gt;v-html&lt;/code&gt; 컨텐츠 를 대상으로 하려면 대신 BEM과 같은 수동 범위 지정 전략과 함께 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; 또는 추가 전역 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">JavaScript에서 PascalCase는 클래스 및 프로토 타입 생성자, 기본적으로 고유 한 인스턴스를 가질 수있는 모든 규칙입니다. Vue 구성 요소에도 인스턴스가 있으므로 PascalCase도 사용하는 것이 좋습니다. 또한 JSX (및 템플릿)에서 PascalCase를 사용하면 코드를 읽는 사람이 구성 요소와 HTML 요소를보다 쉽게 ​​구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">JavaScript에서는 여러 줄에 걸쳐 여러 속성을 가진 객체를 분할하는 것이 읽기 쉬운 규칙이기 때문에 좋은 규칙으로 널리 알려져 있습니다. 우리 템플릿과 &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX도&lt;/a&gt; 같은 고려 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">Polymer에서 팀은 성능을 보상하기 위해 데이터 바인딩 시스템을 매우 제한적으로 만들었습니다. 예를 들어, Polymer 템플리트에서 지원되는 유일한 표현식은 부울 부정 및 단일 메소드 호출입니다. 계산 된 속성 구현도 매우 유연하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">React에서 모든 컴포넌트는 JavaScript 내에서 작동하는 선언적인 XML 유사 구문 인 JSX를 사용하여 렌더링 함수 내에서 UI를 표현합니다.</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">React에서 모든 것은 JavaScript 일뿐입니다. JSX를 통해 HTML 구조가 표현 될뿐만 아니라 최근 트렌드는 CSS 관리를 JavaScript 내부에도 적용하는 경향이 있습니다. 이 접근 방식에는 고유 한 이점이 있지만 모든 개발자에게 가치가없는 것처럼 보이는 다양한 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">React에서 구성 요소의 상태가 변경되면 해당 구성 요소를 루트로 시작하여 전체 구성 요소 서브 트리의 다시 렌더링을 트리거합니다. 하위 컴포넌트를 불필요하게 다시 렌더링하지 않으려면 가능하면 &lt;code&gt;PureComponent&lt;/code&gt; 를 사용 하거나 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 구현 해야합니다 . 상태 변경을보다 최적화하기 위해 변경 불가능한 데이터 구조를 사용해야 할 수도 있습니다. 그러나 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; 는 전체 서브 트리의 렌더 출력이 현재 컴포넌트의 소품에 의해 결정된다고 가정 하기 때문에 특정 경우에는 이러한 최적화에 의존하지 않을 수 있습니다 . 그렇지 않은 경우 이러한 최적화로 인해 DOM 상태가 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">Vue 2.x에서 &lt;code&gt;Vue.observable&lt;/code&gt; 은 전달 된 객체를 직접 변경하므로 &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;여기에 설명 된&lt;/a&gt; 대로 반환 된 객체와 같습니다 . Vue 3.x에서는 리 액티브 프록시가 대신 반환되어 직접 변경되면 원래 오브젝트는 리 액티브하지 않습니다. 따라서 향후 호환성을 위해 원래 전달 된 객체가 아니라 &lt;code&gt;Vue.observable&lt;/code&gt; 에서 반환 한 객체를 항상 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">Vue에서 구성 요소는 기본적으로 미리 정의 된 옵션이있는 Vue 인스턴스입니다. Vue에 컴포넌트를 등록하는 것은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Vue에서는 렌더링 중에 구성 요소의 종속성이 자동으로 추적되므로 시스템은 상태가 변경 될 때 실제로 어떤 구성 요소를 다시 렌더링해야하는지 정확하게 알고 있습니다. 각 구성 요소는 중첩 된 구성 요소 경고없이 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 가 자동으로 구현 된 것으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Vue에는 &lt;a href=&quot;render-function&quot;&gt;렌더링 기능이&lt;/a&gt; 있으며 &lt;a href=&quot;render-function#JSX&quot;&gt;JSX&lt;/a&gt; 도 지원 하기 때문에 때로는 그 힘이 필요하기 때문입니다. 그러나 기본 경험으로 우리는 더 간단한 대안으로 템플릿을 제공합니다. 모든 유효한 HTML은 유효한 Vue 템플릿이기도하므로 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">Webpack 4+에서는 &lt;code&gt;mode&lt;/code&gt; 옵션을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">대규모 응용 프로그램에서는 개발을 관리하기 위해 전체 응용 프로그램을 구성 요소로 나눌 필요가 있습니다. &lt;a href=&quot;guide/components&quot;&gt;이 가이드의 뒷부분에서&lt;/a&gt; 구성 요소에 대해 더 많이 이야기 할 것입니다 . 그러나 다음 은 구성 요소 에서 응용 프로그램의 템플릿이 어떻게 보이는지에 대한 가상의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">그러나 일반적인 앱에서는 &lt;code&gt;data&lt;/code&gt; 여러 개의 게시물이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">Vue 인스턴스는 데이터 속성 외에도 여러 가지 유용한 인스턴스 속성 및 메서드를 제공합니다. 사용자 정의 속성 과 구별하기 위해 앞에 접두사 &lt;code&gt;$&lt;/code&gt; 가 붙습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">텍스트 보간 외에도 다음과 같은 요소 속성을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; 옵션 외에도 명령형 &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm. $ watch API를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">Vue는 기본 제공되는 지시문 ( &lt;code&gt;v-model&lt;/code&gt; 및 &lt;code&gt;v-show&lt;/code&gt; ) 외에도 고유 한 사용자 지정 지시문을 등록 할 수 있습니다. Vue 2.0에서 코드 재사용 및 추상화의 기본 형식은 구성 요소입니다. 그러나 일반 요소에 대한 저수준 DOM 액세스가 필요한 경우가있을 수 있으며이 경우 사용자 지정 지시문이 여전히 유용합니다. 예를 들어 다음과 같은 입력 요소에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">또한 &lt;code&gt;type&lt;/code&gt; 은 사용자 정의 생성자 함수일 수 있으며 어설 션은 &lt;code&gt;instanceof&lt;/code&gt; check 와 함께 이루어집니다 . 예를 들어 다음과 같은 생성자 함수가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">또한 각 인스턴스 / 컴포넌트는 여전히 자체 프라이빗 상태를 소유하고 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">또한 부모 구성 요소가 업데이트 될 때마다 자식 구성 요소의 모든 소품이 최신 값으로 새로 고쳐집니다. 즉 , 하위 구성 요소 내에서 소품을 변경하려고 시도 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 그렇게하면 Vue가 콘솔에서 경고합니다.</target>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">아직 눈치 채지 못한 경우 Vue는 DOM 업데이트를 &lt;strong&gt;비동기 적으로&lt;/strong&gt; 수행합니다 . 데이터 변경이 관찰 될 때마다 큐를 열고 동일한 이벤트 루프에서 발생하는 모든 데이터 변경을 버퍼링합니다. 동일한 감시자가 여러 번 트리거되면 대기열에 한 번만 푸시됩니다. 이 버퍼링 된 중복 제거는 불필요한 계산 및 DOM 조작을 피하는 데 중요합니다. 그런 다음 다음 이벤트 루프 &quot;틱&quot;에서 Vue는 큐를 비우고 실제 (이미 중복 제거 된) 작업을 수행합니다. 내부적으로 Vue는 비동기 대기열을 위해 기본 &lt;code&gt;Promise.then&lt;/code&gt; , &lt;code&gt;MutationObserver&lt;/code&gt; 및 &lt;code&gt;setImmediate&lt;/code&gt; 를 시도 하고 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">처음부터 자체 빌드 설정을 선호하는 경우 &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader를 사용&lt;/a&gt; 하여 웹팩을 수동으로 구성해야합니다 . 웹팩 자체에 대한 자세한 내용은 &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;공식 문서&lt;/a&gt; 및 &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">위와 같은 경우 기본 슬롯 &lt;em&gt;만&lt;/em&gt; 콘텐츠로 제공되는 경우 구성 요소의 태그를 슬롯의 템플릿으로 사용할 수 있습니다. 이를 통해 컴포넌트에서 &lt;code&gt;v-slot&lt;/code&gt; 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">이러한 경우 구성 요소를 &lt;code&gt;functional&lt;/code&gt; 표시 할 수 있습니다. 즉, 구성 요소 는 상태 비 저장 ( &lt;a href=&quot;../api/index#Options-Data&quot;&gt;반응 형 데이터&lt;/a&gt; 없음 ) 및 인스턴스 비 저장 ( &lt;code&gt;this&lt;/code&gt; 컨텍스트 없음 )을 의미합니다. &lt;strong&gt;기능 컴포넌트&lt;/strong&gt; 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">커밋 된 코드에서 prop 정의는 최소한 유형을 지정하여 항상 가능한 한 상세해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">이에 비해 &lt;code&gt;v-show&lt;/code&gt; 는 훨씬 간단합니다. CSS 기반 토글을 사용하면 요소는 항상 초기 조건에 관계없이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">반면에, 메소드 호출은 다시 렌더링 할 때마다 &lt;strong&gt;항상&lt;/strong&gt; 함수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">개발 중에 Vue는 구성 요소에 잘못된 형식의 소품이 제공되면 경고를 표시하여 잠재적 인 오류 원인을 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">&lt;code&gt;new Vue&lt;/code&gt; 인스턴스 의 모든 하위 구성 요소 에서이 루트 인스턴스는 &lt;code&gt;$root&lt;/code&gt; 속성 으로 액세스 할 수 있습니다 . 예를 들어이 루트 인스턴스에서</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">실제로 의존성 주입은 다음을 제외하고 일종의 &quot;장거리 소품&quot;으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">일반적으로 평범한 JavaScript로 무언가를 달성 할 수있을 때마다 동일한 관심사를 처리하기 위해 필터와 같은 특수 구문을 도입하지 않으려 고합니다. Vue의 내장 지시문 필터를 교체하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">큰 응용 프로그램에서는 응용 프로그램을 더 작은 청크로 나누고 필요할 때만 서버에서 구성 요소를로드해야합니다. Vue를 사용하면 구성 요소 정의를 비동기식으로 해결하는 팩토리 함수로 구성 요소를 정의 할 수 있습니다. Vue는 컴포넌트를 렌더링해야 할 때만 팩토리 기능을 트리거하고 향후 다시 렌더링을 위해 결과를 캐시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">많은 Vue 프로젝트에서 &lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 전역 구성 요소를 정의한 다음 &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; 를 사용하여 모든 페이지 본문의 컨테이너 요소를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">그러나 많은 경우 여전히 이상한 동작이 발생합니다 (예 : &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; 는 &lt;code&gt;0.04&lt;/code&gt; 로 반올림 하지만 &lt;code&gt;0.045&lt;/code&gt; 는 &lt;code&gt;0.04&lt;/code&gt; 로 반올림 ). 이러한 문제를 해결하기 위해 &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt; 라이브러리를 사용하여 통화를보다 안정적으로 형식화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;bind&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 에서 동일한 동작을 원할 수 있지만 다른 후크는 신경 쓰지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">대부분의 경우 Vue는 전환이 완료된 시점을 자동으로 파악할 수 있습니다. 기본적으로 Vue는 루트 전환 요소 에서 첫 번째 &lt;code&gt;transitionend&lt;/code&gt; 또는 &lt;code&gt;animationend&lt;/code&gt; 이벤트를 기다립니다 . 그러나 이것은 항상 바람직하지는 않을 수 있습니다. 예를 들어, 중첩 된 내부 요소 중 일부가 루트 전환 요소보다 지연된 전환 또는 더 긴 전환 지속 시간을 갖는 안무 화 된 전환 시퀀스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">대부분의 경우 다른 구성 요소 인스턴스에 도달하거나 DOM 요소를 수동으로 조작하지 않는 것이 가장 좋습니다. 그러나 적절한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">대부분의 경우 부모에 도달하면 특히 부모 데이터를 변경하는 경우 응용 프로그램을 디버깅하고 이해하기가 더 어려워집니다. 나중에 그 성분을 볼 때, 그 돌연변이가 어디서 왔는지 알아내는 것은 매우 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">자연 영어에서는 형용사 및 기타 설명자가 일반적으로 명사 앞에 표시되지만 예외에는 커넥터 단어가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 사례에서는이 메소드를 직접 호출하지 않아도됩니다. &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-for&lt;/code&gt; 를 사용하여 데이터 기반 방식으로 하위 구성 요소의 수명주기를 제어하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">우리의 경우, 그 지점을 &lt;code&gt;tree-folder&lt;/code&gt; 구성 요소로 만들어 봅시다 . 우리는 역설을 만들어 아이가 알고 &lt;code&gt;tree-folder-contents&lt;/code&gt; 때까지 우리가 기다릴거야 그래서, 구성 요소 &lt;code&gt;beforeCreate&lt;/code&gt; 의 라이프 사이클 후크를 등록 :</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">경험상 &lt;em&gt;항상&lt;/em&gt; 고유 키를 추가하는 것이 좋습니다 . 따라서 귀하와 귀하의 팀은 이러한 경우에 대해 걱정할 필요가 없습니다. 그런 다음 객체 불일치가 필요하지 않은 드문 성능 중심 시나리오에서는 의식적인 예외를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">계산 된 속성을 사용할 수없는 상황 (예 : 중첩 된 &lt;code&gt;v-for&lt;/code&gt; 루프 내부 )에서는 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">경우에 따라 소품에&amp;ldquo;양방향 바인딩&amp;rdquo;이 필요할 수 있습니다. 불행히도, 진정한 양방향 바인딩은 유지 관리 문제를 일으킬 수 있습니다. 하위 구성 요소는 부모와 자식 모두에서 그 돌연변이의 원인이 분명하지 않으면 서 부모를 돌연변이시킬 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">이러한 경우 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 구성 요소 의 &lt;code&gt;duration&lt;/code&gt; prop를 사용하여 명시적인 전환 지속 시간 (밀리 초)을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">이 경우 부모 의 &lt;code&gt;.native&lt;/code&gt; 리스너가 자동으로 중단됩니다. 오류는 없지만 예상 할 때 &lt;code&gt;onFocus&lt;/code&gt; 핸들러가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPM 패키지&lt;/a&gt; 의 &lt;code&gt;dist/&lt;/code&gt; 디렉토리 에는 Vue.js의 다양한 빌드가 있습니다. 차이점에 대한 개요는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">위 예제에서 &lt;code&gt;$event.key&lt;/code&gt; 가 &lt;code&gt;'PageDown'&lt;/code&gt; 인 경우에만 핸들러가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">그들의 단순한 존재가 의미하는 부울 속성의 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;v-bind&lt;/code&gt; 약간 다르게 작동합니다. 이 예에서 :</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">콘솔에서 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; . 목록에 새 항목이 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">위의 예에서 &lt;code&gt;currentTabComponent&lt;/code&gt; 는 다음 중 하나를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">위의 예에서 &lt;code&gt;appear&lt;/code&gt; 속성 또는 &lt;code&gt;v-on:appear&lt;/code&gt; 훅은 모양 전환을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">앞으로 인스턴스 속성 및 메서드의 전체 목록을 보려면 &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API 참조&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">부모에서 &lt;code&gt;postFontSize&lt;/code&gt; 데이터 속성 을 추가하여이 기능을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">위의 두 예제에서 문자열 값을 전달하지만 실제로는 &lt;em&gt;모든&lt;/em&gt; 유형의 값을 소품에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">이 경우 &lt;code&gt;key&lt;/code&gt; 속성을 사용 하여 동일한 요소의 여러 상태 간을 전환 할 수도 있습니다 . &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-else&lt;/code&gt; 를 사용하는 대신 위 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">이 경우 구성 요소를 일반 JavaScript 객체로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">이 경우, &lt;code&gt;filterA&lt;/code&gt; 하나의 인자로 정의 된, 값 수신처 &lt;code&gt;message&lt;/code&gt; 하고 &lt;code&gt;filterB&lt;/code&gt; 된 함수의 결과를 호출한다 &lt;code&gt;filterA&lt;/code&gt; 로 전달 &lt;code&gt;filterB&lt;/code&gt; 의 단일 인자.</target>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">이 경우 &lt;code&gt;class&lt;/code&gt; 에 대해 서로 다른 두 가지 값 이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">이 경우 &lt;code&gt;watch&lt;/code&gt; 옵션을 사용하면 비동기 작업 (API에 액세스)을 수행하고 해당 작업을 수행하는 빈도를 제한하며 최종 답변을 얻을 때까지 중개 상태를 설정할 수 있습니다. 그 중 어느 것도 계산 된 속성으로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소에서 상호 작용할지도를 알기 위해 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 의 모든 자손이 &lt;code&gt;getMap&lt;/code&gt; 메소드에 액세스해야했습니다 . 불행히도 &lt;code&gt;$parent&lt;/code&gt; 속성을 사용하면 더 깊이 중첩 된 구성 요소로 확장되지 않았습니다. 여기에서 두 가지 새로운 인스턴스 옵션 인 &lt;code&gt;provide&lt;/code&gt; 및 &lt;code&gt;inject&lt;/code&gt; 를 사용하여 종속성 주입이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">이 예에서는 모든 슬롯 소품 &lt;code&gt;slotProps&lt;/code&gt; 가 포함 된 객체의 이름을 지정 했지만 원하는 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;eventName&lt;/code&gt; 값이 &lt;code&gt;&quot;focus&quot;&lt;/code&gt; 인 경우 &lt;code&gt;v-on:[eventName]&lt;/code&gt; 은 &lt;code&gt;v-on:focus&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">템플릿 내 표현은 매우 편리하지만 간단한 작업을위한 것입니다. 템플릿에 너무 많은 논리를 넣으면 부풀어지고 유지하기가 어려울 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">개별 노드</target>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">반응 개발자를위한 정보</target>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">인라인 템플릿</target>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 블록 내부에서는 부모 범위 속성에 대한 모든 액세스 권한이 있습니다. &lt;code&gt;v-for&lt;/code&gt; 는 현재 항목의 인덱스에 대한 선택적 두 번째 인수도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Vue.js 플러그인을 설치하십시오. 플러그인이 Object 인 경우 &lt;code&gt;install&lt;/code&gt; 방법을 공개해야합니다 . 함수 자체 인 경우 설치 방법으로 처리됩니다. 설치 방법은 Vue를 인수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">인스턴스 DOM 옵션</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">인스턴스 수명주기 후크</target>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">인스턴스 메소드 / 데이터</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">인스턴스 메소드 / 이벤트</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">인스턴스 메소드 / 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">계산 된 속성 대신 메서드와 동일한 기능을 정의 할 수 있습니다. 결과적으로 두 가지 접근 방식은 실제로 동일합니다. 그러나 차이점은 &lt;strong&gt;계산 된 속성이 반응성 종속성에 따라 캐시&lt;/strong&gt; 된다는 것 &lt;strong&gt;입니다. &lt;/strong&gt;계산 된 속성은 일부 반응성 종속성이 변경된 경우에만 다시 평가됩니다. 이는 &lt;code&gt;message&lt;/code&gt; 가 변경되지 않는 한 &lt;code&gt;reversedMessage&lt;/code&gt; 계산 속성에 여러 번 액세스 하면 함수를 다시 실행할 필요없이 이전에 계산 된 결과를 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">메소드 이름에 직접 바인딩하는 대신 인라인 JavaScript 명령문에서 메소드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">각 할 일에 대한 내용을 하드 코딩하는 대신 모든 할 일을 슬롯으로 만든 다음 할 &lt;code&gt;todo&lt;/code&gt; 을 슬롯 소품으로 바인딩하여 부모 구성 요소가 제어하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">이 인터페이스를 사용하여 상점 자체에서 생성 된 이벤트 (예 : &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; )를 보는 대신 새로운 메소드 &lt;code&gt;store.subscribe&lt;/code&gt; 가 도입되었습니다. 플러그인 내부의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">대신, 각 인스턴스가 반환 된 데이터 객체의 독립적 인 복사본을 유지할 수 있도록 &lt;strong&gt;구성 요소의 &lt;code&gt;data&lt;/code&gt; 옵션은 function이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">대신, 반응성 데이터를 직접 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">대신 Vue와의 충돌을 보장하지 않는 사용자 정의 개인 속성의 규칙 으로 두 개의 접두사를 &lt;code&gt;$_&lt;/code&gt; 로 결합하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">대신 각 구성 요소 인스턴스가 자체 데이터 만 관리하기를 원합니다. 이를 위해서는 각 인스턴스가 고유 한 데이터 객체를 생성해야합니다. JavaScript에서 이것은 객체를 함수로 반환하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">대신 속기를 사용하려면 항상 슬롯 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">대신 &lt;code&gt;v-model&lt;/code&gt; 이 객체의 필드를 업데이트 할 수 있도록 &lt;strong&gt;객체&lt;/strong&gt; 배열을 사용해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">타사 라우터 통합</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">흥미롭게도 Angular와 Vue가 이러한 AngularJS 문제를 해결하는 방법에는 몇 가지 유사점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">내부적으로 범위가 지정된 슬롯은 슬롯 내용을 단일 인수로 전달 된 함수로 래핑하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">텍스트 영역 ( &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; )의 보간 이 작동하지 않습니다. 대신 &lt;code&gt;v-model&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">속성 내 보간 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">속성 내 보간이 더 이상 유효하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">또한 디자이너와 경험이 부족한 개발자가 코드베이스를 구문 분석하고 기여하는 것이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">또한 요소 / 구성 요소를 재사용하는 대신 강제로 교체하는 데 사용할 수도 있습니다. 다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">사용자가 만든 &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;사전 설정&lt;/a&gt; 에서 프로젝트를 생성 할 수 없으며 이는 사전 설정된 규칙이있는 엔터프라이즈 환경에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">몇 가지 요인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Vue CLI는 &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;플러그인을&lt;/a&gt; 통해 확장 할 수있는 업그레이드 가능한 런타임 종속성 위에서 실행되는 동안 프로젝트 생성 중에 구성을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">일반적으로 단일 &lt;code&gt;components&lt;/code&gt; 디렉토리를 스크롤하는 것보다 중첩 된 하위 디렉토리를 탐색하는 데 시간이 더 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">이벤트 핸들러 내에서 &lt;code&gt;event.preventDefault()&lt;/code&gt; 또는 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 을 호출하는 것이 매우 일반적 입니다. 비록 우리가 메소드 내에서 이것을 쉽게 할 수 있지만, 메소드가 DOM 이벤트 세부 사항을 다루지 않고 데이터 로직에 관한 것일 수 있다면 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; 와 함께 &quot;else 블록&quot;을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">같은 템플릿에 같은 이름 을 가진 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 이 더 이상 지원되지 않습니다 . 슬롯이 렌더링되면 &quot;사용&quot;되고 동일한 렌더링 트리의 다른 곳에서는 렌더링 할 수 없습니다. 동일한 컨텐츠를 여러 위치에 렌더링해야하는 경우 해당 컨텐츠를 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">이제 구성 요소 인스턴스의 루트 $ data를 교체 할 수 없습니다. 이것은 반응성 시스템에서 일부 경우를 방지하고 구성 요소 상태를보다 예측 가능하게 만듭니다 (특히 유형 점검 시스템에서).</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">템플릿이 더 깔끔해 지도록 스타일 객체에 직접 바인딩하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Vue 응용 프로그램에서 진실의 원천은 원시 &lt;code&gt;data&lt;/code&gt; 객체 라는 것을 간과하는 경우가 많습니다 . Vue 인스턴스는 액세스 권한 만 프록시입니다. 따라서 여러 인스턴스가 공유해야하는 상태가있는 경우 ID로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">반복 된 DOM 컨텐츠가 단순하지 않거나 성능 향상을 위해 기본 동작에 의도적으로 의존하지 않는 한 가능하면 &lt;code&gt;v-for&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 속성 을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">대부분 잘 작동하지만 지연된 상태 업데이트로 인해 이상한 동작이 발생할 수 있습니다. 예를 들어 &lt;code&gt;Result&lt;/code&gt; 탭을 클릭하고 해당 입력 중 하나에 &lt;code&gt;9.999&lt;/code&gt; 를 입력하십시오. 입력에 포커스가 없으면 값이 &lt;code&gt;$10.00&lt;/code&gt; 업데이트됩니다 . 그러나 계산 된 총계를 보면 &lt;code&gt;9.999&lt;/code&gt; 가 데이터에 저장되어 있음을 알 수 있습니다. 사용자가 보는 현실의 버전이 동기화되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">Vue는 다양한 목적과 빌드 시스템을위한 광범위한 기본 옵션을 제공하는 반면, 단일 페이지 애플리케이션을 구축한다고 가정하는 단일 템플릿 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">수명주기 후크에만 액세스 할 수있는 경우 &lt;code&gt;picker&lt;/code&gt; 를 컴포넌트 인스턴스에 저장 해야합니다. 이것은 끔찍하지는 않지만 혼란으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;다음 소스 중 하나에서 문자열 템플리트를 사용&lt;/strong&gt; 하는 &lt;strong&gt;경우이 제한 사항이 적용 되지 &lt;em&gt;않습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">렌더링됩니다 :</target>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">실제로 여러 &lt;code&gt;v-if&lt;/code&gt; 를 사용 하거나 단일 요소를 동적 속성에 바인딩 하여 여러 요소 간을 전환 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">Vue가 CSS 감지를 건너 뛸 수 있도록 JavaScript 전용 전환 에 &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; 를 명시 적으로 추가하는 것도 좋습니다 . 또한 CSS 규칙이 실수로 전환을 방해하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">앱이 중첩 된 구성 요소 트리로 구성되는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">HTML 템플릿을 스키밍하여 JS 코드 내에서 핸들러 함수 구현을보다 쉽게 ​​찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">요소의 존재를 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항 중 상당수는 create-react-app 팀이 의도적으로 디자인 한 결정이며 이점이 있다는 점에 유의해야합니다. 예를 들어, 프로젝트의 요구가 매우 단순하고 빌드 프로세스를 사용자 정의하기 위해 &quot;배출&quot;할 필요가 없다면 프로젝트를 종속성으로 업데이트 할 수 있습니다. &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;다른 철학&lt;/a&gt; 에 대한 자세한 내용은 여기를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">액션에서 원래 상태 객체를 절대 바꾸지 말아야한다는 점에 유의해야합니다. 구성 요소와 상점은 돌연변이를 관찰하기 위해 동일한 객체에 대한 참조를 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">전역 구성 요소가 JavaScript에서 참조되는 경우는 거의 없으므로 JavaScript 규칙을 따르는 것이 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">다음과 같이 전체 내용을 새 요소로 감싸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">이벤트와 함께 특정 값을 생성하는 것이 유용한 경우가 있습니다. 예를 들어, &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소가 텍스트를 얼마나 크게 확대 할 것인지를 담당 할 수 있습니다. 이 경우 &lt;code&gt;$emit&lt;/code&gt; 의 두 번째 매개 변수를 사용하여이 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX 대 템플릿</target>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">자바 스크립트 훅</target>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">계산 된 속성 내에서 JavaScript의 모든 기능에 액세스 할 수 있으므로 JavaScript의 기본 &lt;code&gt;.filter&lt;/code&gt; 는 훨씬 더 복잡한 필터링 작업을 관리 할 수도 있습니다. 예를 들어, 모든 활성 사용자를 찾으려고 대소 문자를 구분하여 이름과 이메일을 모두 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Vue.js 커뮤니티에 가입하십시오!</target>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">HTML 요소와 마찬가지로 다음과 같이 콘텐츠를 구성 요소에 전달할 수있는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">템플릿에서 상대적으로 적은 마크 업을 지원하려면 :</target>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">그러나이 패턴으로 제작 된 구성 요소는 여전히 취약합니다. 예를 들어 새로운 &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; 구성 요소를 추가하고 그 안에 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 가 표시되면 해당 지역 내에있는 마커 만 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">키 코드</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">키 수정 자</target>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">키 입력 &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">키형 v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">녹아웃은 MVVM 및 종속성 추적 공간의 선구자였으며 반응성 시스템은 Vue와 매우 유사합니다. 자사의 &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;브라우저 지원은&lt;/a&gt; IE6에 대한 지원 다시와는 않습니다 모든 것을 고려도 매우 인상적입니다! 반면 Vue는 IE9 + 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">많은 응용 프로그램에 분산 된 여러 상태 조각과 그 사이의 상호 작용으로 인해 대규모 응용 프로그램이 복잡해질 수 있습니다. 이 문제를 해결하기 위해 Vue는 자체 Elm에서 영감을받은 상태 관리 라이브러리 인 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex를&lt;/a&gt; 제공합니다 . 또한 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools에&lt;/a&gt; 통합되어 &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;시간 이동 디버깅에&lt;/a&gt; 대한 제로 설정 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">마지막으로 Vue의 단일 파일 구성 요소의 스타일은 매우 유연합니다. &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader를&lt;/a&gt; 통해 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 요소 내에서 모든 전 처리기, 후 처리기 및 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; 과의 긴밀한 통합을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">최신 안정 버전 : 2.6.10</target>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/index#provide-inject&quot;&gt;API doc&lt;/a&gt; 에서 의존성 주입에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">학습 곡선</target>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 기능이 유용한 간단한 예를 들어 보겠습니다 . 고정 된 표제를 생성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">할 일 목록이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">고정 위치를 사용하여 페이지에 요소를 고정 할 수있는 사용자 지정 지시문을 만들고 싶다고 가정 해 보겠습니다. 값이 다음과 같이 수직 위치를 픽셀 단위로 업데이트하는 사용자 지정 지시문을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Finder 또는 File Explorer와 같은 파일 디렉토리 트리를 작성한다고 가정 해 봅시다. 이 템플릿이 있는 &lt;code&gt;tree-folder&lt;/code&gt; 구성 요소 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">라이프 사이클 다이어그램</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">수명주기 이벤트 (호출 된 순서대로)</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">수명주기 후크</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">진입 / 출발 전환 목록</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">목록 이동 전환</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">리스트 렌더링</target>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">전환 목록</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">현재 VM에서 사용자 지정 이벤트를 수신합니다. &lt;code&gt;vm.$emit&lt;/code&gt; 이벤트를 트리거 할 수 있습니다 . 콜백은 이러한 이벤트 트리거링 메소드에 전달 된 모든 추가 인수를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">맞춤 이벤트를 수신하지만 한 번만 들어보세요. 리스너는 처음 트리거되면 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; 번만 이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; 이벤트 수신</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 이&lt;sup&gt;변경된&lt;/sup&gt; 구성 요소에서 기본 이벤트 수신&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">자식 구성 요소 이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">자식 구성 요소에서 사용자 지정 이벤트 듣기 (핸들러에서 &quot;my-event&quot;가 생성되면 핸들러가 호출 됨) :</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">케밥 케이스 버전을 듣는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">지역 등록</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">모듈 시스템에서 로컬 등록</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">로직은 이제 프리젠 테이션 레이어와 분리되어 유지 보수 (논리의 변경 / 확장)가 훨씬 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">유지 상태</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Vue가 Vue 외부에 정의 된 사용자 정의 요소를 무시하도록하십시오 (예 : 웹 컴포넌트 API 사용). 그렇지 않으면 전역 구성 요소 등록을 잊었거나 구성 요소 이름의 철자가 틀렸다는 가정하에 &lt;code&gt;Unknown custom element&lt;/code&gt; 에 대한 경고가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">반응 형 객체를 만듭니다. 내부적으로 Vue는 &lt;code&gt;data&lt;/code&gt; 함수가 반환 한 객체에서 이것을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;다양한 Vue 빌드에&lt;/a&gt; 대해 읽고 &lt;code&gt;vue.js&lt;/code&gt; 를 &lt;code&gt;vue.min.js&lt;/code&gt; 로 바꾸어 게시 된 사이트에서 &lt;strong&gt;프로덕션 &lt;br/&gt;버전&lt;/strong&gt; 을 사용하십시오 . 개발 경험 대신 속도에 최적화 된 더 작은 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">많은 상태 전환을 관리하면 Vue 인스턴스 또는 구성 요소의 복잡성이 빠르게 증가 할 수 있습니다. 다행히 많은 애니메이션을 전용 하위 구성 요소로 추출 할 수 있습니다. 이전 예제의 애니메이션 정수를 사용하여이 작업을 수행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">&lt;code&gt;this.$root&lt;/code&gt; 및 / 또는 &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;전역 이벤트 버스를&lt;/a&gt; 사용하여 상태를 관리 하는 것은 매우 간단한 경우에 편리 할 수 ​​있지만 대부분의 응용 프로그램에는 적합하지 않습니다. Vuex는 상태를 관리하기위한 중앙 위치뿐만 아니라 상태 변경을 구성, 추적 및 디버깅하기위한 도구도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">자식, 소품 또는 데이터를 자식 구성 요소로 전달하기 전에 조작</target>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">이름이 비슷한 파일이 많기 때문에 코드 편집기에서 파일을 빠르게 전환하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">중첩 된 하위 디렉토리가 많으므로 편집기의 사이드 바에서 구성 요소를 찾아 보는 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">대부분의 구성 요소는 비교적 일반적이며 입력 또는 단추와 같은 요소 만 래핑 할 수 있습니다. 때때로 이러한 &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;구성 요소&lt;/a&gt; 를 기본 구성 요소라고 하며 구성 요소 전체에서 매우 자주 사용되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 를 사용하여 배열을 요소에 매핑</target>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">메타 인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">메소드 이벤트 핸들러</target>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">인라인 핸들러의 메소드</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Vue 인스턴스에 혼합 할 메소드입니다. VM 인스턴스에서 이러한 메소드에 직접 액세스하거나 지시문 표현식에 사용할 수 있습니다. 모든 메소드는 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 Vue 인스턴스에 자동으로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">미들웨어 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">미들웨어는 플러그인으로 대체됩니다. 플러그인은 상점을 유일한 인수로 수신하고 상점에서 돌연변이 이벤트를 청취 할 수있는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Vue 1.x에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Vue Router 0.7.x에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Vuex 0.6.x에서 1.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">믹스 인 후크는 제공된 순서대로 호출되며 구성 요소 자체 후크보다 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Mixin은 Vue 구성 요소에 재사용 가능한 기능을 배포하는 유연한 방법입니다. mixin 객체는 모든 컴포넌트 옵션을 포함 할 수 있습니다. 컴포넌트가 믹스 인을 사용하면 믹스 인의 모든 옵션이 컴포넌트 자체 옵션에 &quot;혼합&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX는 React 커뮤니티에서 인기를 얻었으며 실제로 Vue와 거의 동일한 반응성 시스템을 사용합니다. 제한된 범위에서 React + MobX 워크 플로는 더 장황한 Vue로 생각할 수 있으므로 해당 조합을 사용하고 즐기고 있다면 Vue로 점프하는 것이 다음 논리적 단계 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">수정 자 키 :</target>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">수정자는 점으로 표시된 특수한 접미사로, 지시문이 특별한 방식으로 바인딩되어야 함을 나타냅니다. 예를 들어, &lt;code&gt;.prevent&lt;/code&gt; 수정자는 &lt;code&gt;v-on&lt;/code&gt; 지시문에 트리거 된 이벤트에서 &lt;code&gt;event.preventDefault()&lt;/code&gt; 를 호출 하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">모듈 시스템</target>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">보다 성숙한 툴링 지원. Vue는 &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify에&lt;/a&gt; 대한 공식 지원을 제공 하는 반면 Riot은 빌드 시스템 통합에 대한 커뮤니티 지원에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI를&lt;/a&gt; 사용하는 경우 아래 팁 대부분이 기본적으로 활성화되어 있습니다 . 이 섹션은 사용자 정의 빌드 설정을 사용하는 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">소품을 변경하는 대부분의 사용 사례는 다음 옵션 중 하나로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">마우스 버튼 수정 자</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">훨씬 낫지 않습니까?</target>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">훨씬 간단합니다! 일종의. 코드는 짧지 만 Vue 인스턴스 속성에 대해 더 잘 알고 있어야합니다. 이 경우 &lt;code&gt;v-slot&lt;/code&gt; 지시문이 없는 자식을 &lt;code&gt;Hello world!&lt;/code&gt; 와 같은 구성 요소로 전달할 때 알아야합니다 ! &lt;code&gt;anchored-heading&lt;/code&gt; 내부 에서 해당 하위 항목은 구성 요소 인스턴스의 &lt;code&gt;$slots.default&lt;/code&gt; 에 저장됩니다 . 아직 작성하지 않은 경우 &lt;strong&gt;렌더 함수에 들어가기 전에 &lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;인스턴스 특성 API&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 를 읽는 것이 좋습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">다중 속성 요소</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">다중 속성 요소를 &lt;sup&gt;적극 권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">여러 단어로 된 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">여러 단어로 구성 요소 이름 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">여러 줄 문자</target>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">여러 값</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">동일한 배열에 바인딩 된 여러 확인란 :</target>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">한 번에 1 만 렌더링되는 여러 노드</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">다중 선택 (배열에 바인딩) :</target>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">HTML 속성 내에서 콧수염을 사용할 수 없습니다. 대신 &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind 지시문을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">소품을 로컬로 변경하는 것은 이제 반 패턴으로 간주됩니다. 예를 들어 소품을 선언 한 다음 컴포넌트에서 &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 를 설정 하십시오. 새로운 렌더링 메커니즘으로 인해 상위 컴포넌트가 다시 렌더링 될 때마다 하위 컴포넌트의 로컬 변경 사항을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">돌연변이 방법</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">이름에서 알 수 있듯이 변경 방법은 호출 된 원래 배열을 변경합니다. 이에 비해 원래 배열을 변경하지 않고 &lt;strong&gt;항상 새 배열을 반환하는&lt;/strong&gt; 변경되지 않는 메소드 (예 : &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;concat()&lt;/code&gt; 및 &lt;code&gt;slice()&lt;/code&gt; 있습니다. 비 돌연변이 분석법으로 작업 할 때 기존 배열을 새로운 배열로 교체 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">Vue로 대규모 응용 프로그램을 구축 할 때 NPM이 권장되는 설치 방법입니다. &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; 또는 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 모듈 번 들러 와 잘 어울립니다 . Vue는 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 를 작성하기위한 도구도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">이름 케이싱</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">이름 충돌 (예 : 여러 &lt;code&gt;ButtonDelete.vue&lt;/code&gt; 구성 요소)을 사용하면 코드 편집기에서 특정 구성 요소를 빠르게 탐색하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">명명 된 슬롯</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">명명 된 슬롯 속기</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; 속성 이있는 명명 된 슬롯</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">기본 렌더링</target>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0 이상의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0+의 새로운 기능 : 콜백이 제공되지 않고 Promise가 실행 환경에서 지원되는 경우 Promise를 반환합니다. Vue에는 Promise polyfill이 제공되지 않으므로 Promises를 기본적으로 지원하지 않는 브라우저를 대상으로하는 경우 (IE를 보면) polyfill을 직접 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0 이상의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">경고는 현재 기본적으로 스택 추적과 함께 제공되므로 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">실제 사용하지 않습니다. 어떻게 든이 기능에 의존하고 해결 방법을 잘 모를 경우 &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;포럼&lt;/a&gt; 에서 아이디어를 게시 하십시오 .</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">노드, 트리 및 가상 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">비영리 속성</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">비 플럭스 상태 관리</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">비유동 상태 관리 &lt;sup&gt;사용에주의&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">애니메이션이 제대로 작동하려면 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 의 모든 자식에 &lt;strong&gt;고유 한 키가&lt;/strong&gt; 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">참고 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 구성 요소를 필요는 사용하거나, 이름 모두 사이가 전환되는 &lt;code&gt;name&lt;/code&gt; 구성 요소에 대한 옵션을, 또는 로컬 / 글로벌 등록을 통해.</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">참고 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 옵션은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 영향 &lt;code&gt;style&lt;/code&gt; 과 &lt;code&gt;class&lt;/code&gt; 바인딩.</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;mounted&lt;/code&gt; 않습니다 &lt;strong&gt;되지&lt;/strong&gt; 도 있었다 모든 하위 구성 요소가 장착 된 것을 보장합니다. 당신이 전체 뷰가 렌더링 될 때까지 대기 할 경우 사용할 수있는 &lt;a href=&quot;#vm-nextTick&quot;&gt;VM을 $ nextTick의.&lt;/a&gt; 의 내부 &lt;code&gt;mounted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; 이 지원되지 않습니다 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; , 그래서 당신은 새 탭에서 링크를 열 필요가 있다면, 당신은 사용할 필요가 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;updated&lt;/code&gt; 않습니다 &lt;strong&gt;없습니다&lt;/strong&gt; 모든 하위 구성 요소는 재 렌더링 된 것을 보장합니다. 전체보기가 다시 렌더링 될 때까지 기다리려면 &lt;code&gt;updated&lt;/code&gt; 내부에서 &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ nextTick을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">하는 것으로 &lt;code&gt;v-bind&lt;/code&gt; 와 &lt;code&gt;.sync&lt;/code&gt; 인 수정이 수행 &lt;strong&gt;되지&lt;/strong&gt; 표정으로 작업 (예 : &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 무효). 대신 &lt;code&gt;v-model&lt;/code&gt; 과 유사하게 바인딩하려는 속성의 이름 만 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;v-show&lt;/code&gt; 지원하지 않는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 않으며이 함께 작동합니까 &lt;code&gt;v-else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; 만을 추가 할 수있는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt; (함께 &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;하나 개의 예외&lt;/a&gt; ), 중단 된 달리 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">참고 &lt;strong&gt;로컬로 등록 된 구성 요소가 &lt;em&gt;되지&lt;/em&gt; 도 하위 구성 요소에서 사용할 수&lt;/strong&gt; . 예를 들어, &lt;code&gt;ComponentA&lt;/code&gt; 에서 &lt;code&gt;ComponentB&lt;/code&gt; 를 사용할 수있게하려면 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">참고 &lt;strong&gt;이 방법을 정의하는 화살표 기능을 사용하지 말아야합니다&lt;/strong&gt; (예 : &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같이 뷰 인스턴스를하지 않습니다 &lt;code&gt;this.a&lt;/code&gt; 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">참고 &lt;strong&gt;당신이 감시자 정의 화살표 기능을 사용하지 말아야합니다&lt;/strong&gt; (예 &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같이 뷰 인스턴스를하지 않습니다 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Vue의 이벤트 시스템은 브라우저의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt; 와 다릅니다 . 비슷하게 작동하지만 &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; 및 &lt;code&gt;$off&lt;/code&gt; 는 &lt;code&gt;dispatchEvent&lt;/code&gt; , &lt;code&gt;addEventListener&lt;/code&gt; 및 &lt;code&gt;removeEventListener&lt;/code&gt; 의 별명 이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">다른 지시어 (예 : &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-show&lt;/code&gt; )의 경우 JavaScript의 일반적인 정확성이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">계산 된 속성과 함께 화살표 함수를 사용하는 경우 &lt;code&gt;this&lt;/code&gt; 구성 요소의 인스턴스가 아니지만 함수의 첫 번째 인수로 인스턴스에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 속성에 화살표 함수를 사용하는 경우 &lt;code&gt;this&lt;/code&gt; 컴포넌트의 인스턴스가 아니지만 함수의 첫 번째 인수로 인스턴스에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">ES2015 +에서 &lt;code&gt;ComponentA&lt;/code&gt; 와 같은 변수 이름을 객체 안에 배치하는 것은 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 축약 형입니다 . 즉, 변수 이름은 둘 다입니다.</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">이 방법에서는 DOM을 건드리지 않고 앱 상태를 업데이트합니다. 모든 DOM 조작은 Vue에 의해 처리되며 작성하는 코드는 기본 논리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">그것의 것을 참고 &lt;strong&gt;하지&lt;/strong&gt; 사용하는 것이 좋습니다 &lt;code&gt;v-if&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 함께. 자세한 내용은 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;스타일 가이드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">수정 자 키는 일반 키와 다르며 &lt;code&gt;keyup&lt;/code&gt; 이벤트 와 함께 사용 하면 이벤트가 생성 될 때 눌러야합니다. 즉, &lt;code&gt;keyup.ctrl&lt;/code&gt; 은 &lt;code&gt;ctrl&lt;/code&gt; 키를 누른 상태에서 키를 놓은 경우에만 트리거됩니다 . &lt;code&gt;ctrl&lt;/code&gt; 키를 단독으로 놓으면 트리거되지 않습니다 . 이러한 동작을 원하면 &lt;code&gt;ctrl&lt;/code&gt; 대신 &lt;code&gt;keyup.17&lt;/code&gt; 키 &lt;code&gt;keyCode&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">자바 스크립트의 객체와 배열이 소품은 아이 컴퍼넌트 내부의 객체 또는 배열 자체를 돌연변이 배열이나 객체, 그래서 경우, 참조에 의해 전달되는 것을 참고 &lt;strong&gt;한다&lt;/strong&gt; 부모의 상태에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">소품은 컴포넌트 인스턴스가 생성 &lt;strong&gt;되기 전에&lt;/strong&gt; 확인 되므로 인스턴스 속성 (예 : &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; 등)은 &lt;code&gt;default&lt;/code&gt; 또는 &lt;code&gt;validator&lt;/code&gt; 함수 내에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">있습니다 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 가 없기 때문에 요소를 효율적으로 여전히이-재사용 &lt;code&gt;key&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">기본 슬롯에 대한 약식 구문은 범위 모호성을 초래할 &lt;strong&gt;수&lt;/strong&gt; 있으므로 명명 된 슬롯과 혼합 될 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vue.extend()&lt;/code&gt; 에서 동일한 병합 전략이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">함께합니다 &lt;code&gt;immediate&lt;/code&gt; 옵션 첫 번째 콜백 호출에 지정된 속성을 주시 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">참고 포함해야한다는 &lt;code&gt;strict: true&lt;/code&gt; (또는 적어도 &lt;code&gt;noImplicitThis: true&lt;/code&gt; 의 일부 &lt;code&gt;strict&lt;/code&gt; 플래그)의 활용 유형 검사에 &lt;code&gt;this&lt;/code&gt; 그렇지 않으면 항상로 처리됩니다 컴포넌트 메소드에서 &lt;code&gt;any&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">라우트 구성 요소에 위의 구문을 사용 하려면 &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0 이상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">구성 요소의 &lt;code&gt;props&lt;/code&gt; 옵션 에서 &lt;code&gt;checked&lt;/code&gt; prop 을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 속성에 유의하십시오 . &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 내에서는 &amp;lt; &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 만 유효 하므로 이는 DOM 템플리트에서 필요 합니다 . 이 같은 일을 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 하지만, 잠재적 브라우저 구문 분석 오류 주위에 작동합니다. 자세한 내용은 &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM 템플릿 구문 분석을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">참고, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 이 전환되고 하나 직접 아이 컴퍼넌트가있는 경우를 위해 설계되었습니다. 내부에 &lt;code&gt;v-for&lt;/code&gt; 가 있으면 작동하지 않습니다 . 위와 같이 여러 조건부 자식이있는 경우 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 에서는 한 번에 하나의 자식 만 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">참고 : Macintosh 키보드에서 meta는 명령 키 (⌘)입니다. Windows 키보드에서 meta는 Windows 키 (⊞)입니다. Sun Microsystems 키보드에서 메타는 솔리드 다이아몬드 (◆)로 표시됩니다. 특정 키보드, 특히 Knight 키보드, 우주 생도 키보드와 같은 MIT 및 Lisp 머신 키보드 및 후속 키보드에서 메타는 &quot;META&quot;로 표시됩니다. Symbolics 키보드에서 메타는 &quot;META&quot;또는 &quot;Meta&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">참고 : 2.3.0 이전 버전 에서는 기능 구성 요소에서 소품을 허용 하려면 &lt;code&gt;props&lt;/code&gt; 옵션이 필요합니다. 2.3.0 이상에서는 &lt;code&gt;props&lt;/code&gt; 옵션을 생략 할 수 있으며 컴포넌트 노드에있는 모든 속성은 암시 적으로 props로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">참고 : &lt;code&gt;provide&lt;/code&gt; 및 &lt;code&gt;inject&lt;/code&gt; 바인딩은 반응하지 않습니다. 이것은 의도적 인 것입니다. 그러나 관찰 된 객체를 전달하면 해당 객체의 속성이 계속 반응합니다.</target>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">참고 :이 옵션은 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 바인딩에 영향을 미치지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">참고 : Object 또는 Array를 교체하지 않고 변경할 때 이전 값은 동일한 Object / Array를 참조하므로 새 값과 동일합니다. Vue는 사전 돌연변이 값의 사본을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">상점의 상태를 변경하는 모든 조치는 상점 자체에 있습니다. 이러한 유형의 중앙 집중식 상태 관리를 통해 어떤 유형의 돌연변이가 발생하고 어떻게 발생하는지 쉽게 이해할 수 있습니다. 이제 무언가 잘못되면 버그로 이어진 일에 대한 로그도 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">버튼을 클릭 할 때 각 버튼은 자체의 개별 &lt;code&gt;count&lt;/code&gt; 유지합니다 . 구성 요소를 사용할 때마다 새 구성 요소 &lt;strong&gt;인스턴스&lt;/strong&gt; 가 생성되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">이제 &lt;code&gt;v-model&lt;/code&gt; 은이 구성 요소와 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">이제 모두 &lt;code&gt;ComponentA&lt;/code&gt; 및 &lt;code&gt;ComponentC&lt;/code&gt; 은 내부에 사용할 수 있습니다 &lt;code&gt;ComponentB&lt;/code&gt; 의 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소 내부의 모든 것이 해당 슬롯으로 전달됩니다. &lt;code&gt;v-slot&lt;/code&gt; 사용하여 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 래핑되지 않은 내용 은 기본 슬롯에 대한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">이제이 &lt;code&gt;ref&lt;/code&gt; 를 정의한 컴포넌트에서 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">이제 깊은 다이빙을 할 시간입니다! Vue의 가장 두드러진 특징 중 하나는 눈에 거슬리지 않는 반응성 시스템입니다. 모델은 단순한 JavaScript 객체입니다. 수정하면보기가 업데이트됩니다. 상태 관리는 간단하고 직관적이지만 일반적인 문제를 피하기 위해 어떻게 작동하는지 이해하는 것도 중요합니다. 이 섹션에서는 Vue의 반응성 시스템에 대한 하위 수준의 세부 사항을 파고들 것입니다.</target>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">이제 모든 게시물의 내용 바로 앞에 텍스트를 확대하는 버튼을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">이제 예제와 함께 이전에 사용한 것과 동일한 CSS 클래스를 사용하여 들어오고 나가는 과정을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">이제 예를 들어 보자. Velocity.js를 사용한 JavaScript 전환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">이제 on / off 버튼의 전환을 &lt;code&gt;out-in&lt;/code&gt; 으로 업데이트합시다 :</target>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 컴포넌트는 &lt;strong&gt;완전히 투명한 래퍼입니다&lt;/strong&gt; . 즉, 일반 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 와 똑같이 사용할 수 있습니다 . &lt;code&gt;.native&lt;/code&gt; 수정 자 없이 동일한 속성과 리스너가 모두 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">이제 &lt;em&gt;게시물&lt;/em&gt; 탭은 렌더링되지 않더라도 상태 (선택한 게시물)를 유지합니다. 전체 코드는 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;이 바이올린&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">이제 토글 할 때마다 해당 입력이 처음부터 렌더링됩니다. 직접 참조하십시오 :</target>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하여 할 일을 반복되는 각 구성 요소에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">이제 우리는 :</target>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">이제 우리는 커뮤니티가 당신을 위해 할 수있는 것과 커뮤니티를 위해 할 수있는 것에 대해 대답 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">이제이 컴포넌트에서 &lt;code&gt;v-model&lt;/code&gt; 을 사용할 때 :</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">이제 상위 컴포넌트에서 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 을 사용하여 슬롯에 대한 컨텐츠를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 컴포넌트를 사용할 때 선택적 으로 todo 항목에 대한 대체 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 을 정의 할 수 있지만 자식의 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">이제 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; 를 실행 하면 setter가 호출되고 &lt;code&gt;vm.firstName&lt;/code&gt; 및 &lt;code&gt;vm.lastName&lt;/code&gt; 이 그에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">때마다 이제 &lt;code&gt;sourceOfTruth&lt;/code&gt; 가 변이되어, 모두 &lt;code&gt;vmA&lt;/code&gt; 및 &lt;code&gt;vmB&lt;/code&gt; 자동으로 자신의 견해를 업데이트합니다. 이러한 각 인스턴스 내의 하위 구성 요소도 &lt;code&gt;this.$root.$data&lt;/code&gt; 를 통해 액세스 할 수 있습니다 . 우리에게는 지금 진실의 단일 소스가 있지만 디버깅은 악몽이 될 것입니다. 추적없이 데이터의 일부를 앱의 어느 부분에서나 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">이제 다른 구성 요소의 템플리트에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 새 객체 가 &lt;code&gt;post&lt;/code&gt; 객체에 추가 될 때마다 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 내에서 자동으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">객체 변경 감지주의 사항</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">객체 리터럴</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">객체 구문</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">NPM 패키지의 공식 선언</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">공식 플럭스 유사 구현</target>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">공식 라우터</target>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">에 &lt;code&gt;input&lt;/code&gt; , 자신의 사용자 정의 방출 &lt;code&gt;input&lt;/code&gt; 새 값으로 이벤트를</target>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">더 높은 수준에서 컴포넌트를 프리젠 테이션 카테고리와 논리 카테고리로 분류 할 수 있습니다. 프리젠 테이션 컴포넌트에 템플리트를 사용하고 논리 컴포넌트에 렌더링 함수 / JSX를 사용하는 것이 좋습니다. 이러한 구성 요소의 비율은 작성하는 앱 유형에 따라 다르지만 일반적으로 프레젠테이션 구성 요소가 훨씬 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">일반 컴포넌트에서 props로 정의되지 않은 속성은 컴포넌트의 루트 요소에 자동으로 추가되어 동일한 이름의 기존 속성 &lt;a href=&quot;class-and-style&quot;&gt;과&lt;/a&gt; 대체되거나 지능적으로 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">루트 Vue 인스턴스 (예 : &lt;code&gt;new Vue({ ... })&lt;/code&gt; 만든 인스턴스 )에서는 &lt;code&gt;props&lt;/code&gt; 대신 &lt;code&gt;propsData&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">반면 &lt;code&gt;$refs&lt;/code&gt; 는 주로 JavaScript에서 프로그래밍 방식으로 액세스하도록 설계되었습니다. 템플릿 자체에 의존하지 않는 것이 좋습니다. 즉, 인스턴스 자체에 속하지 않는 상태를 의미하기 때문입니다. 이것은 Vue의 데이터 중심 뷰 모델을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">반면에 런타임 전용 빌드는 CSP와 완전히 호환됩니다. &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt; 와 함께 런타임 전용 빌드를 사용하는 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 &lt;code&gt;render&lt;/code&gt; 함수 로 사전 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">이 페이지에서는 전환 입력, 탈퇴 및 목록 만 다루지 만 &lt;a href=&quot;transitioning-state&quot;&gt;상태 전환 관리를&lt;/a&gt; 위한 다음 섹션을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">소품이 등록되면 다음과 같이 사용자 정의 속성으로 데이터를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">다시이 패턴을 과도하게 사용하지 마십시오. 정적 콘텐츠를 많이 렌더링해야하는 드문 경우에는 편리하지만 실제로 렌더링 속도가 느려지지 않는 한 필요하지 않습니다. 또한 나중에 많은 혼란을 야기 할 수 있습니다. 예를 들어, &lt;code&gt;v-once&lt;/code&gt; 에 익숙하지 않거나 템플릿에서 간단하게 놓친 다른 개발자를 상상해보십시오 . 템플릿이 올바르게 업데이트되지 않는 이유를 파악하는 데 몇 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">일단 관찰되면 더 이상 루트 데이터 객체에 반응 속성을 추가 할 수 없습니다. 따라서 인스턴스를 만들기 전에 모든 루트 수준 반응 속성을 미리 선언하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">방금 요약 한 지식에 익숙해지면 &lt;a href=&quot;components-dynamic-async&quot;&gt;동적 및 비동기 구성 요소&lt;/a&gt; 에 대한 전체 가이드와 사이드 바의 심층 구성 요소 섹션에있는 다른 페이지를 다시 읽어 보시기 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">한 가지 중요한 참고 사항은 이러한 FLIP 전환이 &lt;code&gt;display: inline&lt;/code&gt; 설정된 요소에서 작동하지 않는다는 것입니다 . 대안으로 &lt;code&gt;display: inline-block&lt;/code&gt; 하거나 플렉스 컨텍스트에 요소를 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">주의해야 할 중요한 사항은 &lt;strong&gt;우려 분리가 파일 유형 분리와 같지 않다는 것입니다. &lt;/strong&gt;현대의 UI 개발에서 우리는 코드베이스를 서로 얽히는 3 개의 거대한 레이어로 나누는 대신 느슨하게 결합 된 컴포넌트로 나누고 구성하는 것이 훨씬 더 합리적이라는 것을 알았습니다. 구성 요소 내에서 템플릿, 논리 및 스타일이 본질적으로 결합되어 있으며이를 배치하면 실제로 구성 요소를보다 응집력 있고 유지 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">가장 일반적인 전환 유형 중 하나는 CSS 전환을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">이러한 방법의 가장 일반적인 용도 중 하나는 부모와 직계 자녀 사이의 의사 소통입니다. 이 경우 실제로 &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt; &lt;code&gt;v-on&lt;/code&gt; 을&lt;/a&gt; 가진 자식 의 &lt;code&gt;$emit&lt;/code&gt; 을 들을 수 있습니다 . 이를 통해 명시 성이 추가 된 이벤트의 편의를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">하나 이상의 명명 된 매개 변수가 &lt;sup&gt;변경됨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">한 가지 주목할 점 : &lt;code&gt;v-bind:class&lt;/code&gt; 및 &lt;code&gt;v-bind:style&lt;/code&gt; 이 템플릿에서 특별한 처리 를하는 방식과 유사하게 VNode 데이터 객체에 자체 최상위 필드가 있습니다. 이 객체를 사용하면 &lt;code&gt;innerHTML&lt;/code&gt; 과 같은 DOM 속성뿐만 아니라 일반 HTML 속성도 바인딩 할 수 있습니다 ( &lt;code&gt;v-html&lt;/code&gt; 지시문을 대체 함 ).</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">한 번의 바인딩 ( &lt;code&gt;{{* foo }}&lt;/code&gt; )이 새로운 &lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; 지시문&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">일회성 바인딩 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">단방향 데이터 흐름</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">Bower는 UMD 빌드 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Vue Router 2 만 Vue 2와 호환되므로 Vue를 업데이트하는 경우 Vue Router도 업데이트해야합니다. 이것이 주요 문서에서 마이그레이션 경로에 대한 세부 정보를 여기에 포함시킨 이유입니다. 새로운 Vue 라우터 사용에 대한 전체 안내서는 &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue 라우터 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Vue Router 2 만 Vue 2와 호환되므로 &lt;a href=&quot;migration-vue-router&quot;&gt;Vue Router&lt;/a&gt; 의 마이그레이션 경로 를 따라야합니다 . 다행히도 대부분의 응용 프로그램에는 많은 라우터 코드가 없으므로 1 시간 이상 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">2.2.0+에서만 : Array + index 와도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">최적화 노력</target>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">옵션 병합</target>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">옵션 / 자산</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">옵션 / 구성</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">옵션 / DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">옵션 / 데이터</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">옵션 / 라이프 사이클 후크</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">옵션 / 기타</target>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;acceptStatement&lt;/code&gt; , &lt;code&gt;deep&lt;/code&gt; , &lt;code&gt;priority&lt;/code&gt; 등과 같은 옵션 이 모두 제거되었습니다. &lt;code&gt;twoWay&lt;/code&gt; 지시문 을 바꾸려면 &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;이 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; , &lt;code&gt;components&lt;/code&gt; 및 &lt;code&gt;directives&lt;/code&gt; 과 같은 오브젝트 값을 예상하는 옵션 은 동일한 오브젝트로 병합됩니다. 이러한 객체에 충돌하는 키가 있으면 구성 요소 옵션이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">또는 데이터 / 계산 속성 :</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">또는 렌더링 기능 :</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">또는 구성 요소를 로컬로 등록 할 때 Webpack의 비동기 &lt;code&gt;import&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">또는 더 나은 방법으로 인덱스를 제거 방법에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">또는 다른 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">또는 &lt;code&gt;myElement&lt;/code&gt; 가 마지막 자식 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">또는 Babel 및 Webpack과 같은 ES2015 모듈을 사용하는 경우 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">또는 렌더링 함수를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">또는 구성 요소 방법으로 :</target>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">또는 이벤트 핸들러가 메소드 인 경우 :</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">또는 런타임 전용 Vue 빌드를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">또는 &lt;code&gt;slot&lt;/code&gt; 속성을 일반 요소에서 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">또는 Grunt 및 &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt- &lt;/a&gt;&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;browserify&lt;/a&gt; 와 함께 envify 사용 :</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">또는 Gulp와 함께 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">관련 코드가 동일한 순서로 생성되므로 수정자를 사용할 때 순서가 중요합니다. 따라서 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; 를 사용하면 &lt;strong&gt;모든 클릭&lt;/strong&gt; 이 차단 되고 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; 는 요소 자체의 클릭 만 방지합니다.</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">구성 요소 이름의 단어 순서</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">구성 요소 이름의 단어 순서를 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">구성 요소 구성</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">구성 요소로 전환 구성</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">다른 예</target>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">우리 &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;의 행동 강령&lt;/a&gt; 은 우리 모두와 우리가 참여하는 기술 커뮤니티를 더욱 풍요롭게하기위한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">우리의 맞춤형 지시문은 이제 몇 가지 다른 사용 사례를 지원할 수있을 정도로 유연합니다.</target>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">설정 코드는 정리 코드와 별도로 유지되므로 설정 한 내용을 프로그래밍 방식으로 정리하기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">그러나 시간이 지남에 따라 녹아웃 개발 속도가 느려지고 나이가 조금 들기 시작했습니다. 예를 들어, 구성 요소 시스템에는 전체 수명주기 후크 세트가 없으며 매우 일반적인 사용 사례이지만 구성 요소에 자식을 전달하기위한 인터페이스는 &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt; 와 비교할 때 약간 복잡 합니다.</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">전반적으로 이것은 개발자의 판에서 전체 성능 최적화 클래스의 필요성을 제거하고 앱이 확장 될 때 앱 자체를 빌드하는 데 더 집중할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">소품을 사용하여 구성 요소 간의보다 명확한 데이터 흐름을 위해 부분이 제거되었습니다. 성능이 중요한 영역에서 부분을 사용하지 않는 한 &lt;a href=&quot;components&quot;&gt;일반 구성 요소를&lt;/a&gt; 대신 사용하는 것이 좋습니다 . 부분 의 &lt;code&gt;name&lt;/code&gt; 을 동적으로 바인딩하는 경우 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;동적 구성 요소를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCase는 케밥 케이스에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase는 가능한 경우 JS (X) 및 템플릿의 구성 요소를 참조하는 방식과 일치하므로 코드 편집기의 자동 완성과 함께 가장 잘 작동합니다. 그러나 대소 문자를 구분하는 파일 이름은 대소 문자를 구분하지 않는 파일 시스템에서 문제를 일으킬 수 있으므로 kebab-case도 완벽하게 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">소품을 만드는 동안 소품을 전달하십시오. 이는 단위 테스트를보다 쉽게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">자식 요소 / 구성 요소에 특성 및 이벤트 전달</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">소품을 사용하여 자식 구성 요소에 데이터 전달</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">정적 또는 동적 소품 전달</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">부울 전달</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">숫자 전달</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">배열 전달</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">객체 전달</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">&lt;code&gt;immediate: true&lt;/code&gt; 전달 : 옵션에서 true 는 표현식의 현재 값으로 즉시 콜백을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">객체의 속성 전달</target>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">성능 현명한, 뷰 성능이 뛰어 엠버 &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;공정의 차이로&lt;/a&gt; 도 엠버 3.x에서의 최신 희미한 빛의 엔진 업데이트 후, Vue는 자동으로 업데이트를 일괄 처리하지만 Ember에서는 성능이 중요한 상황에서 런 루프를 수동으로 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode 클래스 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer 패키지 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">플러그인은 Vue의 글로벌 / 인스턴스 속성 및 컴포넌트 옵션에 추가 될 수 있습니다. 이 경우 TypeScript에서 플러그인을 컴파일하려면 형식 선언이 필요합니다. 다행히 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;모듈 확대 기능&lt;/a&gt; 이라는 기존 유형을 보강하는 TypeScript 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">플러그인은 일반적으로 Vue에 글로벌 수준의 기능을 추가합니다. 플러그인에 대해 엄격하게 정의 된 범위는 없습니다. 일반적으로 여러 유형의 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer는 Google이 후원하는 또 다른 프로젝트이며 실제로 Vue의 영감의 원천이었습니다. Vue의 컴포넌트는 Polymer의 커스텀 엘리먼트와 느슨하게 비교 될 수 있으며 둘 다 매우 유사한 개발 스타일을 제공합니다. 가장 큰 차이점은 Polymer가 최신 웹 구성 요소 기능을 기반으로하며 기본적으로 해당 기능을 지원하지 않는 브라우저에서 성능이 저하되지 않는 사소한 폴리 필이 필요하다는 것입니다. 대조적으로 Vue는 IE9까지의 종속성이나 폴리 필없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">사전 컴파일 템플릿</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">사전 및 기타 반응 형 라이브러리</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">많은 수의 요소 선택기가 느리기 때문에 &lt;code&gt;scoped&lt;/code&gt; 스타일의 요소 선택자보다 클래스 선택자를 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">멋지다?</target>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">이전에는 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 를 결합 하면 각 항목에 고유 한 이름을 지정할 수있는 방법이 없었기 때문에 요소 / 구성 요소 배열이 생성되었습니다. 각 항목에 동일한 &lt;code&gt;ref&lt;/code&gt; 하여이 동작을 계속 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">이전 &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; 것이다 &lt;code&gt;number&lt;/code&gt; 0에서 시작하여 9에서 끝나는 지금은 1에서 시작하고 끝나는 10시.</target>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">주로 구성 요소 상태를 유지하거나 다시 렌더링하지 않도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">우선 순위 A 규칙 : 필수 (오류 방지)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">우선 순위 A : 필수</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">우선 순위 B 규칙 : 강력 추천 (가독성 향상)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">우선 순위 B : 강력 추천</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">우선 순위 C 규칙 : 권장 (임의 선택 및 최소화 오버 헤드 최소화)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">우선 순위 C : 권장</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">우선 순위 D 규칙 :주의해서 사용 (잠재적으로 위험한 패턴)</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">우선 순위 D :주의해서 사용</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">개인 재산 이름</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">개인 재산 이름 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">문제 해결됨!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">생산 배포</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">프로그래밍 방식 이벤트 리스너</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">프로그래밍 방식 탐색</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">프로그래밍 할 다른 여러 구성 요소 중 하나를 프로그래밍 방식으로 선택</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">프로젝트 생성</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">프롭 케이싱 (낙타 케이스 대 케밥 케이스)</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">Prop Mutation &lt;sup&gt;지원 중단&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="23ca9a44a1ade4d87027ae10b8309bece2e74a54" translate="yes" xml:space="preserve">
          <source>Prop Types</source>
          <target state="translated">소품 종류</target>
        </trans-unit>
        <trans-unit id="0d718a828e84189a6c1ea77a0099a78e06d7d7c9" translate="yes" xml:space="preserve">
          <source>Prop Validation</source>
          <target state="translated">소품 검증</target>
        </trans-unit>
        <trans-unit id="3ad34219a208945c8ea06d8eb918df83f7e61456" translate="yes" xml:space="preserve">
          <source>Prop definitions</source>
          <target state="translated">소품 정의</target>
        </trans-unit>
        <trans-unit id="e2f4b4fdf875186ea4cf16dbb812dbea30216d87" translate="yes" xml:space="preserve">
          <source>Prop definitions &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">소품 정의 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="895e352dc19c97709d5567c55fe72b1a6d482c35" translate="yes" xml:space="preserve">
          <source>Prop name casing</source>
          <target state="translated">프롭 이름 케이스</target>
        </trans-unit>
        <trans-unit id="b90f11ae0da8cbfe0b2f736a16886c055d6bffd1" translate="yes" xml:space="preserve">
          <source>Prop name casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">소품 이름 케이스를 &lt;sup&gt;적극 권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="66e61e4c98d3b3a635091c842dada04fef1b9143" translate="yes" xml:space="preserve">
          <source>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt;. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.</source>
          <target state="translated">프로덕션 용 서버 렌더링 앱의 모든 논의 된 측면을 올바르게 구성하는 것은 어려운 작업이 될 수 있습니다. 운 좋게도 &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js라는&lt;/a&gt; 모든 것을 쉽게 만드는 것을 목표로 한 훌륭한 커뮤니티 프로젝트가 있습니다. Nuxt.js는 Vue 에코 시스템을 기반으로 구축 된 고급 프레임 워크로 범용 Vue 응용 프로그램 작성을위한 능률화 된 개발 경험을 제공합니다. 또한 정적 사이트 생성기 (단일 파일 Vue 구성 요소로 작성된 페이지 포함)로 사용할 수도 있습니다! 시도해 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc7c765b5dbb95f7134159f12c7f78946b944760" translate="yes" xml:space="preserve">
          <source>Properly trigger lifecycle hooks of a component</source>
          <target state="translated">구성 요소의 수명주기 후크를 올바르게 트리거</target>
        </trans-unit>
        <trans-unit id="e9f3056a7ba256cf707e7dce02bf806a8e3e1baf" translate="yes" xml:space="preserve">
          <source>Properties that start with &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; be proxied on the Vue instance because they may conflict with Vue&amp;rsquo;s internal properties and API methods. You will have to access them as &lt;code&gt;vm.$data._property&lt;/code&gt;.</source>
          <target state="translated">로 시작하는 속성 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 가 됩니다 &lt;strong&gt;하지&lt;/strong&gt; 그들이 뷰의 내부 속성과 API 방식과 충돌 할 수 있기 때문에 뷰 인스턴스 프록시 될 수있다. &lt;code&gt;vm.$data._property&lt;/code&gt; 로 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="824b655ece5f935a9f95c151296cb1d2ff2e73ec" translate="yes" xml:space="preserve">
          <source>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a &lt;code&gt;props&lt;/code&gt; option:</source>
          <target state="translated">소품은 구성 요소에 등록 할 수있는 사용자 정의 속성입니다. 값이 prop 속성에 전달되면 해당 구성 요소 인스턴스의 특성이됩니다. 블로그 게시물 컴포넌트에 제목을 전달하기 위해 &lt;code&gt;props&lt;/code&gt; 옵션을 사용하여이 컴포넌트가 수락하는 props 목록에 제목을 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02635ba77eef9661786c01a78d90b7501db1be4e" translate="yes" xml:space="preserve">
          <source>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</source>
          <target state="translated">소품은 이제 항상 단방향입니다. 부모 범위에서 부작용을 발생 시키려면 구성 요소가 암시 적 바인딩에 의존하는 대신 명시 적으로 이벤트를 생성해야합니다. 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6122d047108de3e0837cf3e23276a8775fc2406" translate="yes" xml:space="preserve">
          <source>Props on a Root Instance &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">루트 인스턴스의 소품 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="877adb56a197e1259015de3210d87c2e790b7975" translate="yes" xml:space="preserve">
          <source>Provide an alternative render output when the default &lt;code&gt;render&lt;/code&gt; function encounters an error. The error will be passed to &lt;code&gt;renderError&lt;/code&gt; as the second argument. This is particularly useful when used together with hot-reload.</source>
          <target state="translated">기본 &lt;code&gt;render&lt;/code&gt; 기능에 오류가 발생 하면 대체 렌더 출력을 제공하십시오 . 오류는 두 번째 인수 로 &lt;code&gt;renderError&lt;/code&gt; 에 전달됩니다 . 이것은 특히 핫 리로드와 함께 사용할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="02efa133aeef7a133aefd2f252af936a5cccad26" translate="yes" xml:space="preserve">
          <source>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</source>
          <target state="translated">Vue 인스턴스에 마운트 할 기존 DOM 요소를 제공하십시오. CSS 선택기 문자열이거나 실제 HTMLElement 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf49ab626c30fff5ed5ee4dbe07721b4605c56b" translate="yes" xml:space="preserve">
          <source>Quasar Framework SSR + PWA</source>
          <target state="translated">퀘이사 프레임 워크 SSR + PWA</target>
        </trans-unit>
        <trans-unit id="282e30765bd347047d1a351ac3b6f1cf18becd81" translate="yes" xml:space="preserve">
          <source>Quoted attribute values</source>
          <target state="translated">인용 된 속성 값</target>
        </trans-unit>
        <trans-unit id="683b9e103293a057ef4362aa5bc974a4f8bd8131" translate="yes" xml:space="preserve">
          <source>Quoted attribute values &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">인용 된 속성 값을 &lt;sup&gt;적극 권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ed1e44a4093ca562205b72061c34f1507e70c015" translate="yes" xml:space="preserve">
          <source>RFC-0001</source>
          <target state="translated">RFC-0001</target>
        </trans-unit>
        <trans-unit id="b11bf19e3f65b4a1ada383e41f26dab5c503940e" translate="yes" xml:space="preserve">
          <source>Radio</source>
          <target state="translated">Radio</target>
        </trans-unit>
        <trans-unit id="76550ff95e4521edf8dc9e8329b78993dc047414" translate="yes" xml:space="preserve">
          <source>Raw HTML</source>
          <target state="translated">원시 HTML</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b183e9aafa930f129da2c452cc641903b8199bea" translate="yes" xml:space="preserve">
          <source>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!</source>
          <target state="translated">React Native를 사용하면 동일한 React 컴포넌트 모델을 사용하여 iOS 및 Android 용으로 렌더링 된 기본 앱을 작성할 수 있습니다. 이는 개발자로서 여러 플랫폼에서 프레임 워크에 대한 지식을 적용 할 수 있다는 점에서 훌륭합니다. 이러한 측면에서 Vue는 Alibaba Group에서 개발하고 Apache Software Foundation (ASF)에서 인큐베이션 한 크로스 플랫폼 UI 프레임 워크 인 &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt; 와의 공식 협력 관계를 맺고 있습니다. Weex를 사용하면 브라우저에서 렌더링 할 수있을뿐만 아니라 기본적으로 iOS 및 Android에서도 렌더링 할 수있는 동일한 Vue 구성 요소 구문을 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="ee4366331847de86650378c9e4041dac06218df0" translate="yes" xml:space="preserve">
          <source>React and Vue share many similarities. They both:</source>
          <target state="translated">React와 Vue는 많은 유사점을 공유합니다. 그들은 둘 다 :</target>
        </trans-unit>
        <trans-unit id="bb65ef679dc307f628a20a0b729cd808d18c5ac0" translate="yes" xml:space="preserve">
          <source>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React&amp;rsquo;s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it&amp;rsquo;s absolutely not suitable for production.</source>
          <target state="translated">React는 가파른 학습 곡선으로 유명합니다. 많은 예제가 React의 클래스 구문을 사용하므로 실제로 시작하기 전에 JSX 및 아마도 ES2015 +에 대해 알아야합니다. 브라우저에서 코드를 라이브 컴파일하기 위해 기술적으로 Babel Standalone을 사용할 수 있지만 프로덕션에는 적합하지 않기 때문에 빌드 시스템에 대해서도 배워야합니다.</target>
        </trans-unit>
        <trans-unit id="bb1b40c27f9e4939cf3ff484fca2a9371f8d3b42" translate="yes" xml:space="preserve">
          <source>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.</source>
          <target state="translated">React와 유사한 라이브러리는 일반적으로 가능한 한 많은 API 및 에코 시스템을 React와 공유하려고합니다. 이러한 이유로 위의 대부분의 비교도 여기에 적용됩니다. 주요 차이점은 일반적으로 React에 비해 감소 된 생태계입니다. 이러한 라이브러리는 React 에코 시스템의 모든 것과 100 % 호환 될 수 없으므로 일부 툴링 및 컴패니언 라이브러리를 사용하지 못할 수 있습니다. 또는 작동하는 것처럼 보이더라도 특정 React와 유사한 라이브러리가 React와 공식적으로 지원되지 않는 한 언제든지 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96578d9c2e6eaee240051ff91e83f741cc87e93b" translate="yes" xml:space="preserve">
          <source>Reactivity</source>
          <target state="translated">Reactivity</target>
        </trans-unit>
        <trans-unit id="38be1878e88addc141471e2ac5be059c49256537" translate="yes" xml:space="preserve">
          <source>Reactivity in Depth</source>
          <target state="translated">깊이의 반응성</target>
        </trans-unit>
        <trans-unit id="446d7c237336d575135ddcd7063341761426b025" translate="yes" xml:space="preserve">
          <source>Ready for More?</source>
          <target state="translated">더 준비가 되셨습니까?</target>
        </trans-unit>
        <trans-unit id="40fe62216df511ee5c87bc8e026789c819f7b21e" translate="yes" xml:space="preserve">
          <source>Really though, any transition attribute can be dynamically bound. And it&amp;rsquo;s not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.</source>
          <target state="translated">실제로 모든 전환 속성은 동적으로 바인딩 될 수 있습니다. 그리고 그것은 속성이 아닙니다. 이벤트 후크는 메소드이므로 컨텍스트의 모든 데이터에 액세스 할 수 있습니다. 즉, 구성 요소의 상태에 따라 JavaScript 전환이 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb5994a5662a9b7831e2e56b44ea27b6edb5bab" translate="yes" xml:space="preserve">
          <source>Recent versions of Angular, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT compilation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;tree-shaking&lt;/a&gt;, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by &lt;code&gt;angular-cli&lt;/code&gt; (~65KB gzipped).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT 컴파일&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;트리 쉐이킹 기능&lt;/a&gt; 이있는 최신 버전의 Angular 는 크기를 상당히 줄일 수있었습니다. 그러나 Vuex + Vue Router (~ 30KB gzipped)가 포함 된 모든 기능을 갖춘 Vue 2 프로젝트는 &lt;code&gt;angular-cli&lt;/code&gt; (~ 65KB gzipped)에서 생성 한 즉시 사용 가능한 AOT 컴파일 응용 프로그램보다 훨씬 가볍습니다 .</target>
        </trans-unit>
        <trans-unit id="3f99a56b4630f2ac18091fad78531d1626d4dac4" translate="yes" xml:space="preserve">
          <source>Recommended Configuration</source>
          <target state="translated">권장 구성</target>
        </trans-unit>
        <trans-unit id="f9d18b779732cc0ea4b60f929feea8a7c40df5fc" translate="yes" xml:space="preserve">
          <source>Recreating dynamic components is normally useful behavior, but in this case, we&amp;rsquo;d really like those tab component instances to be cached once they&amp;rsquo;re created for the first time. To solve this problem, we can wrap our dynamic component with a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">동적 구성 요소를 다시 만드는 것이 일반적으로 유용한 동작이지만이 경우 처음으로 만든 탭 구성 요소 인스턴스를 캐시하는 것이 좋습니다. 이 문제를 해결하기 위해 동적 구성 요소를 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 요소로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c0556aa6352203342eea1a65c58a623378dbcc" translate="yes" xml:space="preserve">
          <source>Recursive Components</source>
          <target state="translated">재귀 구성 요소</target>
        </trans-unit>
        <trans-unit id="46819d95829c2f8ee915e7d271f512463387fc11" translate="yes" xml:space="preserve">
          <source>Refactoring becomes more difficult, because find-and-replace often isn&amp;rsquo;t sufficient to update relative references to a moved component.</source>
          <target state="translated">찾기 및 바꾸기는 종종 이동 된 구성 요소에 대한 상대 참조를 업데이트하기에 충분하지 않기 때문에 리팩토링이 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="f4234eefb475a2340f218d9e7a7e6c874a82a6fa" translate="yes" xml:space="preserve">
          <source>Refer to the respective build tool documentations to see how it&amp;rsquo;s done:</source>
          <target state="translated">각 빌드 도구 설명서를 참조하여 수행 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d8b1f50199fd6cb6ab6141f41a87fd8dae1f00d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global component. Registration also automatically sets the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; with the given &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">글로벌 구성 요소를 등록하거나 검색하십시오. 등록은 또한 주어진 &lt;code&gt;id&lt;/code&gt; 로 구성 요소 &lt;code&gt;name&lt;/code&gt; 을 자동으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0168019975e7b996b73bc3be3562ac476872545c" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global directive.</source>
          <target state="translated">글로벌 지시문을 등록하거나 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="13bd6c258247a18188a7e24270fbc9f007d7c82d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global filter.</source>
          <target state="translated">글로벌 필터를 등록하거나 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="76de89743a325c94ab024ae33f08812f80d685bb" translate="yes" xml:space="preserve">
          <source>Relation to Custom Elements</source>
          <target state="translated">사용자 정의 요소와의 관계</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">릴리즈 노트</target>
        </trans-unit>
        <trans-unit id="d92abdf653f23351eb7a0ab4d23290ee1313902d" translate="yes" xml:space="preserve">
          <source>Remember that &lt;strong&gt;global registration must take place before the root Vue instance is created (with &lt;code&gt;new Vue&lt;/code&gt;)&lt;/strong&gt;. &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;Here&amp;rsquo;s an example&lt;/a&gt; of this pattern in a real project context.</source>
          <target state="translated">기억 &lt;strong&gt;글로벌 등록 (와 뷰의 인스턴스가 만들어 루트 전에 이루어져야 &lt;code&gt;new Vue&lt;/code&gt; )&lt;/strong&gt; . &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;다음&lt;/a&gt; 은 실제 프로젝트 컨텍스트에서이 패턴 의 예 입니다.</target>
        </trans-unit>
        <trans-unit id="73942b04c7d6e9cc0cafd922223a9eab5438c235" translate="yes" xml:space="preserve">
          <source>Remove custom event listener(s).</source>
          <target state="translated">사용자 정의 이벤트 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="25c548f4a7b9b6ef1cfbffbca926739476b1c4e2" translate="yes" xml:space="preserve">
          <source>Removed due to hooks simplification. If you really must suppress transition errors, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt;&lt;code&gt;try&lt;/code&gt;&amp;hellip;&lt;code&gt;catch&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">후크 단순화로 인해 제거되었습니다. 전환 오류를 실제로 억제해야하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt; &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;catch&lt;/code&gt; 를&lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7f3ed71f5d7421b91e0c25cc42984adb65b4fdd" translate="yes" xml:space="preserve">
          <source>Renamed to &lt;code&gt;base&lt;/code&gt; for consistency with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;the HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;HTML &lt;/a&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 요소 와 의 일관성을 위해 &lt;code&gt;base&lt;/code&gt; 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3aa893c2a6ebe75166762d5109366b728fa5dc54" translate="yes" xml:space="preserve">
          <source>Render Functions &amp;amp; JSX</source>
          <target state="translated">렌더 함수 및 JSX</target>
        </trans-unit>
        <trans-unit id="f54e5429aec68f05a2b3b43a85ee9662c29159d7" translate="yes" xml:space="preserve">
          <source>Render Functions - Slots</source>
          <target state="translated">렌더 함수-슬롯</target>
        </trans-unit>
        <trans-unit id="aeac0239d7806a13c73e4eacbb8e89032112b08f" translate="yes" xml:space="preserve">
          <source>Render functions with JSX have a few advantages:</source>
          <target state="translated">JSX를 사용한 렌더 함수에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f479c7d13498bbd2aa42eae8f88242964120b5" translate="yes" xml:space="preserve">
          <source>Render the element and component &lt;strong&gt;once&lt;/strong&gt; only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</source>
          <target state="translated">요소와 컴포넌트를 &lt;strong&gt;한 번만&lt;/strong&gt; 렌더링하십시오 . 이후에 다시 렌더링 할 때 요소 / 구성 요소 및 모든 하위 요소는 정적 컨텐츠로 처리되어 건너 뜁니다. 업데이트 성능을 최적화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c510f643528b3292df74bbcf70195487418102f" translate="yes" xml:space="preserve">
          <source>Render the element or template block multiple times based on the source data. The directive&amp;rsquo;s value must use the special syntax &lt;code&gt;alias in expression&lt;/code&gt; to provide an alias for the current element being iterated on:</source>
          <target state="translated">소스 데이터를 기반으로 요소 또는 템플릿 블록을 여러 번 렌더링합니다. 지시문의 값은 &lt;code&gt;alias in expression&lt;/code&gt; 특수 구문 별명을 사용하여 반복되는 현재 요소의 별명을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9647e21c53c63f65c167aa12298837e080c17cb0" translate="yes" xml:space="preserve">
          <source>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains &lt;strong&gt;a lot&lt;/strong&gt; of static content. In these cases, you can ensure that it&amp;rsquo;s only evaluated once and then cached by adding the &lt;code&gt;v-once&lt;/code&gt; directive to the root element, like this:</source>
          <target state="translated">Vue에서 일반 HTML 요소를 렌더링하는 것은 매우 빠르지 만 때로는 &lt;strong&gt;많은&lt;/strong&gt; 정적 콘텐츠 가 포함 &lt;strong&gt;된&lt;/strong&gt; 구성 요소가있을 수 있습니다 . 이 경우 다음 과 같이 루트 요소에 &lt;code&gt;v-once&lt;/code&gt; 지시문을 추가하여 한 번만 평가 한 다음 캐시되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a09ee1cf84326d5d5b1fbbb8dcaca046fb652f2" translate="yes" xml:space="preserve">
          <source>Replacing &lt;code&gt;vm.$data&lt;/code&gt;&lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;vm.$data&lt;/code&gt; 교체가 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6336d2b4c545bfdb0a2c2e6130a2fe522bc117ed" translate="yes" xml:space="preserve">
          <source>Replacing Template Features with Plain JavaScript</source>
          <target state="translated">일반 JavaScript로 템플릿 기능 교체</target>
        </trans-unit>
        <trans-unit id="3694e119ff9868c46a5da68ac50107adb0cd0254" translate="yes" xml:space="preserve">
          <source>Replacing an Array</source>
          <target state="translated">어레이 교체</target>
        </trans-unit>
        <trans-unit id="448ceec811e5cd1612b41b145f75a74425a6d60a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;capitalize&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;capitalize&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="8ebc9242fd66a164fb0466c94c267b085022f523" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;currency&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;currency&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="6e8e54f171683ed43699d784bb3a20daa786f68a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;debounce&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="bc05ccbf460e1bee1b220a363cd9b366122fc62c" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;filterBy&lt;/code&gt; Filter</source>
          <target state="translated">일 교체 &lt;code&gt;filterBy&lt;/code&gt; 의 필터</target>
        </trans-unit>
        <trans-unit id="5aadbac5cc6d5572fbf9f02300727b922b52477f" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;json&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="5af22200afbbae6350485e71f8a0930a62620a3b" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;limitBy&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;limitBy&lt;/code&gt; 필터로 교체</target>
        </trans-unit>
        <trans-unit id="63239b2dfa73a07907b85e48d0e4e3d07aa51efd" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;lowercase&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;lowercase&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="307535ec9952915e10873762b9b0a59ea99d17d1" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;orderBy&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;orderBy&lt;/code&gt; 필터로 교체</target>
        </trans-unit>
        <trans-unit id="5a0b57fe75978a4fde52508fa6b11e6a9fcbade8" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;pluralize&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;pluralize&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="5895ba028c303252e37b6295f10778b7ca351267" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;uppercase&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;uppercase&lt;/code&gt; 필터 교체</target>
        </trans-unit>
        <trans-unit id="c183ebe6cda4d505c2e49d3160c8367d36be5b90" translate="yes" xml:space="preserve">
          <source>Replacing/Merging with Existing Attributes</source>
          <target state="translated">기존 속성으로 교체 / 병합</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="1f5b54bbca313ab53947ed8a4f97b16e01f729d9" translate="yes" xml:space="preserve">
          <source>Reusable Transitions</source>
          <target state="translated">재사용 가능한 전환</target>
        </trans-unit>
        <trans-unit id="a48bbafb258bfc790b66aec7d45e0a6a8fa1cd83" translate="yes" xml:space="preserve">
          <source>Reusing Components</source>
          <target state="translated">컴포넌트 재사용</target>
        </trans-unit>
        <trans-unit id="b836c4c63ed0b1bed339e82e9c78c2b817e6736c" translate="yes" xml:space="preserve">
          <source>Riot</source>
          <target state="translated">Riot</target>
        </trans-unit>
        <trans-unit id="6e85617241bed85b4dcd2ae064b3025078b134e9" translate="yes" xml:space="preserve">
          <source>Riot 3.0 provides a similar component-based development model (which is called a &amp;ldquo;tag&amp;rdquo; in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:</source>
          <target state="translated">Riot 3.0은 최소한의 아름답게 디자인 된 API를 사용하여 유사한 컴포넌트 기반 개발 모델 (Riot에서 &quot;태그&quot;라고 함)을 제공합니다. Riot와 Vue는 아마도 디자인 철학에서 많은 것을 공유 할 것입니다. 그러나 Riot보다 약간 무겁지만 Vue는 몇 가지 중요한 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="8e4ecad6a05d926091d335638bbc9859c1de1f8b" translate="yes" xml:space="preserve">
          <source>Rollup + rollup-plugin-vue</source>
          <target state="translated">롤업 + 롤업 플러그인-뷰</target>
        </trans-unit>
        <trans-unit id="42ec7ccbef29d0422b242b5178f06191bc8484d0" translate="yes" xml:space="preserve">
          <source>Route Definitions</source>
          <target state="translated">경로 정의</target>
        </trans-unit>
        <trans-unit id="6e3b967c60ba49b0f518c43998cb2dc91dd2134c" translate="yes" xml:space="preserve">
          <source>Route Hooks</source>
          <target state="translated">라우트 후크</target>
        </trans-unit>
        <trans-unit id="2b73a7098cbf7da1b1613b48acc5eb7c6f35331c" translate="yes" xml:space="preserve">
          <source>Route Matching</source>
          <target state="translated">경로 매칭</target>
        </trans-unit>
        <trans-unit id="18febd25894978ca61139fd68c461cb521819d89" translate="yes" xml:space="preserve">
          <source>Route Options: Misc</source>
          <target state="translated">경로 옵션 : 기타</target>
        </trans-unit>
        <trans-unit id="f0865cca790a39153b3f106f9c19244b4f157bd4" translate="yes" xml:space="preserve">
          <source>Route matching now uses &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; under the hood, making it much more flexible than previously.</source>
          <target state="translated">경로 일치는 이제 후드 아래에서 &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;정규 경로를&lt;/a&gt; 사용하므로 이전보다 훨씬 유연합니다.</target>
        </trans-unit>
        <trans-unit id="32027b0a6491682801317490f82d9b553e764f1b" translate="yes" xml:space="preserve">
          <source>Router Initialization</source>
          <target state="translated">라우터 초기화</target>
        </trans-unit>
        <trans-unit id="1b4778ead27c045154fa8a8032dcbf9b6b10e64f" translate="yes" xml:space="preserve">
          <source>Router Options: Modes</source>
          <target state="translated">라우터 옵션 : 모드</target>
        </trans-unit>
        <trans-unit id="9add2b84e8289fb0ea9dcb2637e5d5907ca4d748" translate="yes" xml:space="preserve">
          <source>Routes are now defined as an array on a &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt;&lt;code&gt;routes&lt;/code&gt; option&lt;/a&gt; at router instantiation. So these routes for example:</source>
          <target state="translated">라우터 인스턴스화시 경로는 이제 &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt; &lt;code&gt;routes&lt;/code&gt; 옵션&lt;/a&gt; 의 배열로 정의됩니다 . 예를 들어이 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="d670f1115ef0c3c29b2d47e241e7dd62eafb1e11" translate="yes" xml:space="preserve">
          <source>Rule Categories</source>
          <target state="translated">규칙 카테고리</target>
        </trans-unit>
        <trans-unit id="91ba54d8bd5025bb2cb3e7a4cd0c0785af90a756" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find &lt;code&gt;keep-alive&lt;/code&gt; attributes.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 연결 &lt;code&gt;keep-alive&lt;/code&gt; 속성 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="6d2ac67778b450ed0b9659002961f8409d707930" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find CSS selectors targeting named slots (e.g. &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt;).</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 이름이 지정된 슬롯을 대상으로하는 CSS 선택기를 찾으십시오 (예 : &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb8ef12ba88bdd9ea8d64f474b58bd5f002af15c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find HTML interpolations.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 HTML 보간을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e29967481758c6af408495a286989e2f4b3a4403" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find all examples of this hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행 하여이 후크의 모든 예를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="131ad91eddecfe4bcd3aa1d2c3dae1e7c9a6d28b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;$dispatch&lt;/code&gt; 및 &lt;code&gt;$broadcast&lt;/code&gt; 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="b5547bdef16b43ebf6aa5572275c3effebf29215" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$remove&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 배열에서 &lt;code&gt;.$remove&lt;/code&gt; 예를 찾으십시오 . 누락 된 것이 있으면 누락 된 방법으로 인한 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 가 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4d1a3ee9aa64afee960f48bf970646ff2ca1516a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$set&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 배열에서 &lt;code&gt;.$set&lt;/code&gt; 예를 찾으십시오 . 누락 된 것이 있으면 누락 된 방법으로 인한 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 가 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f7cf2f519c21c26383d689b999383e7f48c8daeb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.async&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.config.async&lt;/code&gt; 의 예를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="adba4cc2d78c532c252af8489b44bb0c82a60071" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.debug&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.config.debug&lt;/code&gt; 의 예제를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="842114654af7636636f5d0ca2790f492b054f6ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.delimiters&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.config.delimiters&lt;/code&gt; 의 예제를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="56d3c94b1fca7d1fecbd0be685fc6a65bfb4e3ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt;. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt; 의 예제를 찾으 십시오 . 그런 다음 도우미는 HTML 보간 인스턴스를 찾아서 'v-html'로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7abfe983d07d10f68fd1a923086c66cfb28e6a0a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.elementDirective&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.elementDirective&lt;/code&gt; 의 예제를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="0cbd833dba88270b867f404265f89cd61957dd9e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.partial&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.partial&lt;/code&gt; 의 예를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="2be876bb1c3f71e3306a218289a786bebe66e6ac" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.set&lt;/code&gt; or &lt;code&gt;Vue.delete&lt;/code&gt; on a Vue instance. If you miss any, they'll trigger &lt;strong&gt;console warnings&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 Vue 인스턴스에서 &lt;code&gt;Vue.set&lt;/code&gt; 또는 &lt;code&gt;Vue.delete&lt;/code&gt; 의 예제를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 경고가&lt;/strong&gt; 트리거 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c98c79eef3d7a23f61df5ef62ac7e471ae74fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.transition&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;Vue.transition&lt;/code&gt; 의 예제를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="3cd48bf0c847ee511a1c8d066fdfbdc6f4f6ffc4" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;replace: false&lt;/code&gt;.</source>
          <target state="translated">실행 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 의 예를 찾기 위해 코드베이스에 &lt;code&gt;replace: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc77c164d9ea83ca27d60242ad248d1e7b987f0e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.alias&lt;/code&gt; being called.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;router.alias&lt;/code&gt; 호출 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf69302085bdd68f35cf86d99ec675583acea23" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.go&lt;/code&gt; being used where &lt;code&gt;router.push&lt;/code&gt; should be used instead.</source>
          <target state="translated">실행 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 의 예를 찾기 위해 코드베이스에 &lt;code&gt;router.go&lt;/code&gt; 어디에 사용되는 &lt;code&gt;router.push&lt;/code&gt; 이 대신 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="e39b23f840933b639f0659fde34e12f635127e7f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.map&lt;/code&gt; being called.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;router.map&lt;/code&gt; 의 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="b828dfd9e2d7bcae2364000145b56e764e6ebe03" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.on&lt;/code&gt; being called.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;router.on&lt;/code&gt; 호출 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="f9a6975194aa0ce1b5cad1c6626af7c35453fcd0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.redirect&lt;/code&gt; being called.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;router.redirect&lt;/code&gt; 호출 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="cc5f2a33706f0e2d3f4cdbd090a5e649c5b6ae0f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.start&lt;/code&gt; being called.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;router.start&lt;/code&gt; 가 호출되는 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="f5f2fbe802e2c06eba8dee0a46275f8ee4460bc0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.on&lt;/code&gt;, &lt;code&gt;store.off&lt;/code&gt;, and &lt;code&gt;store.emit&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;store.on&lt;/code&gt; , &lt;code&gt;store.off&lt;/code&gt; 및 &lt;code&gt;store.emit&lt;/code&gt; 의 예제를 찾으 십시오 .</target>
        </trans-unit>
        <trans-unit id="00ad6c9fe856a5b4567b7a4dab60a0fe45a37f40" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.watch&lt;/code&gt; with a string as the first argument.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 문자열을 첫 번째 인수로 사용하여 &lt;code&gt;store.watch&lt;/code&gt; 의 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="4f47a47355d74434a753364a679e2f4c9a402ae5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;track-by&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;track-by&lt;/code&gt; 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="da0f85cb5aa67bdac2ea466f36918db2fcd36b05" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;v-el&lt;/code&gt; and &lt;code&gt;v-ref&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;v-el&lt;/code&gt; 및 &lt;code&gt;v-ref&lt;/code&gt; 의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="7aa5783c6df3a82bb69131d32c3850e7f84cfda7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$after&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$after&lt;/code&gt; 예제를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="09e7d78d817c1fd2a45c3cf9b9c21a2069c4fd37" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$appendTo&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$appendTo&lt;/code&gt; 예제를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d7350cc4e203e91682eee37d60894b3e1314af48" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$before&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$before&lt;/code&gt; 예제를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c4f878eaed231fe0dbb2225df03cd65dc84e13" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$eval&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$eval&lt;/code&gt; 예를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3f8e856f05355ed8982ce86f4336ff6eacabf3e2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$get&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$get&lt;/code&gt; 예제를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0dd654ce3404b139a97c6070c1ea80255ce0fd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$interpolate&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$interpolate&lt;/code&gt; 예를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="81bbbda8f1ba1322792aa46e4294439738bc392f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$log&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$log&lt;/code&gt; 예를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="381f44de62059e317b1f31d7ce9b3541555d602b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$remove&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$remove&lt;/code&gt; 예를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b874a37ca4886af9d3b7780e6010cf89d9c7f988" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of arbitrary route properties not scoped under meta.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 메타 범위가 아닌 임의의 경로 속성의 예를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1fa158cea69bdd4c40bd2a48988a099538d4dc5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component.</source>
          <target state="translated">정의 된 지시문의 예제를 찾으려면 코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하십시오 . 대부분의 경우 구성 요소로 리팩토링하려는 경우 도우미가 모든 플래그를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="979e6458f784d896c90752c57e560652f6c8525d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters being used inside directives. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 지시문 내에서 사용되는 필터의 예를 찾으십시오. 누락 된 부분이 있으면 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 도 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="801a0e4488b5e174aaaa485bb9fbdd0fb7f5b389" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters used in directives like &lt;code&gt;v-model&lt;/code&gt;. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;v-model&lt;/code&gt; 과 같은 지시문에 사용되는 필터의 예를 찾으십시오 . 누락 된 부분이 있으면 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 도 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83b833ef69efe1e17f7ef29c061f04dea5876bad" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of interpolation used within attributes.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 속성 내에서 사용되는 보간 예제를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9bb76b174b8438ba3c0f4ba54b4026ce44dd98ca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of overwriting &lt;code&gt;vm.$data&lt;/code&gt;. If you miss any, &lt;strong&gt;console warnings&lt;/strong&gt; will be emitted.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;vm.$data&lt;/code&gt; 덮어 쓰기 예를 찾으십시오 . 누락 된 경우 &lt;strong&gt;콘솔 경고&lt;/strong&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8dbff7c8c83dec265171807e5ec5ea40ea988ad1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of style bindings with &lt;code&gt;!important&lt;/code&gt; in objects.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 객체에서 &lt;code&gt;!important&lt;/code&gt; 를 사용 하여 스타일 바인딩 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="93ebbb2019ca1300c683d3ae1afb72a96650f915" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;$loadingRouteData&lt;/code&gt; meta property.</source>
          <target state="translated">코드로드 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;$loadingRouteData&lt;/code&gt; 메타 특성의 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="52407d926e2b5716bf90f4cb35758896e87892ed" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;.once&lt;/code&gt; and &lt;code&gt;.sync&lt;/code&gt; modifiers.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;.once&lt;/code&gt; 및 &lt;code&gt;.sync&lt;/code&gt; 수정 자의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="2c8ce2853d843c2c72201a428aaae4467ceec09d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;abstract: true&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;abstract: true&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="2258f58c39858d2874ac267df312bf5774d76c18" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;activate&lt;/code&gt; hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;activate&lt;/code&gt; 후크의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="0d2dd196d33a6838401706a980c174ba91eb1c6e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;cache: false&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;cache: false&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="635b9a1176068b8a0020a01c4f47cb421d064226" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canActivate&lt;/code&gt; hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;canActivate&lt;/code&gt; 후크의 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="1ef7f740384cd3cfdf159ef6085f2faaac1ec88f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canDeactivate&lt;/code&gt; hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;canDeactivate&lt;/code&gt; 후크의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="416c87ed212eefdaa2ddbf02f6a0ba2e74d86959" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canReuse: false&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;canReuse: false&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="ce44d3b81054ffa59cb49fd62f006c1d791e2ab0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;coerce&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;coerce&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="61fdd38d446cfe928998b1181aa744e45596c1c5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;data&lt;/code&gt; hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;data&lt;/code&gt; 후크의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="eeb9b18e06a447d16bfa196a854b2eb06f05360a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;deactivate&lt;/code&gt; hook.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;deactivate&lt;/code&gt; 훅의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="f483517518991a282467c00ae1cad300e136b269" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;debounce&lt;/code&gt; attribute.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;debounce&lt;/code&gt; 속성의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="b65067f3a77b357e086f22629678c364185b2ab2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;hashbang: false&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;hashbang: false&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="8a2e5b8abfbc6295fa11dd1caccde1ae7c3d69af" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;history: true&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;history: true&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="452c89b5559555a477ca0eb92f956476ce00d5cd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;middlewares&lt;/code&gt; option on a store.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 상점 에서 &lt;code&gt;middlewares&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="6faa58ba44b5eb605740b8397f8693bbaaa6f840" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;root&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;root&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="ab45ded99a30a006bddeceb3fd6aa38bb6c3d9c6" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;saveScrollPosition: true&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;saveScrollPosition: true&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="6ec2df901f80374c6ff66f398825204e5f18d423" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;subRoutes&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;subRoutes&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="7178b2cc5e9e2a36383d9e60b9eea90fb3bcb121" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;suppressTransitionError: true&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;suppressTransitionError: true&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="4e988285e061dd6f2c40c32cddfbc676c1aab12a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;transition&lt;/code&gt; 속성의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="c5f2b82da8cac7dc4262de8c7c93d4a46587dbca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;transition&lt;/code&gt; 속성의 예를 찾으십시오 . 업데이트하는 동안 새로운 스 태거 전략으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34922f45eeac604f53b4193f84913c2beb89b350" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transitionOnLoad: true&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 &lt;code&gt;transitionOnLoad: true&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="c9c97a1b14162dd07775888af56118c3a3370301" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;twoWay&lt;/code&gt; option.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;twoWay&lt;/code&gt; 옵션의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="cb3445799897bdc7ce3106b11c9b2c1f1d554568" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-else&lt;/code&gt; with &lt;code&gt;v-show&lt;/code&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;v-show&lt;/code&gt; 를 사용 하여 &lt;code&gt;v-else&lt;/code&gt; 의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="bccc02e6c6793423ef659db42169cb5afa5716d0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link-active&lt;/code&gt; directive.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;v-link-active&lt;/code&gt; 지시문의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="ea921119a7e1635ac4e5a00b3d8a84491101f3fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link&lt;/code&gt; directive.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 &lt;code&gt;v-link&lt;/code&gt; 지시문의 예를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="a825bdc145076ec6a6e4b0c215f030aa3ba79b85" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the `.literal` modifier on a directive.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 지시문에서`.literal` 수정 자의 예를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="733bb79e129d2dca49869269db0a3698c6f65fa8" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like &lt;code&gt;position&lt;/code&gt; or &lt;code&gt;num&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 더 이상 사용되지 않는 인수 순서의 예를 찾으십시오. 인덱스 인수의 이름을 &lt;code&gt;position&lt;/code&gt; 또는 &lt;code&gt;num&lt;/code&gt; 과 같은 특이한 이름으로 지정 하면 도우미가 해당 인수를 플래그하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da725380e126a62727af458ad28bac7c6524d798" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;property&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 더 이상 사용되지 않는 인수 순서의 예를 찾으십시오. 키 인수의 &lt;code&gt;name&lt;/code&gt; 또는 &lt;code&gt;property&lt;/code&gt; 와 같은 이름으로 지정 하면 도우미가 해당 인수에 플래그를 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e1035d99ed76f7515df578e692ff719107895a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete route syntax.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 더 이상 사용되지 않는 경로 구문의 예를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="142bb71333ac86e488c9aacc373010de66e961e1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete text filters. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 더 이상 사용되지 않는 텍스트 필터의 예를 찾으십시오. 누락 된 부분이 있으면 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 도 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="397d5ab0302428112127147010f4482ef9051b5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete usage.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 더 이상 사용되지 않는 예제를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c1aa36c4bb555ce2607bb2d08c4631182d133d50" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the old filter syntax. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 이전 필터 구문의 예를 찾으십시오. 누락 된 부분이 있으면 &lt;strong&gt;콘솔 오류&lt;/strong&gt; 도 표시 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="20564b7f4450c4fa59c4a3ba6fa87121c27fe89f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the the old &lt;code&gt;keyCode&lt;/code&gt; configuration syntax.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 이전 &lt;code&gt;keyCode&lt;/code&gt; 구성 구문 의 예제를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="cc0976e79e68e3874825b8d9309f7bc3cf13503f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the these param attributes.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 도우미&lt;/a&gt; 를 실행하여 이러한 param 속성의 예를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4a53e2c9b9e1ccea5753bf6c5b26aa93f8d31041" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of these removed variables. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt; such as: &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 제거 된 변수의 예를 찾으십시오. 누락 된 부분이 있으면 다음 과 같은 &lt;strong&gt;콘솔 오류가&lt;/strong&gt; 표시 됩니다. &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0ae781de5086e5c0e4123dc4514d344522a5237" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find one-time bindings.</source>
          <target state="translated">코드베이스 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 일회성 바인딩을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2c800955474c5ae66271d1f51e3a706afff6e929" translate="yes" xml:space="preserve">
          <source>Run your bundling command with the actual &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable set to &lt;code&gt;&quot;production&quot;&lt;/code&gt;. This tells &lt;code&gt;vueify&lt;/code&gt; to avoid including hot-reload and development related code.</source>
          <target state="translated">실제 &lt;code&gt;NODE_ENV&lt;/code&gt; 환경 변수를 &lt;code&gt;&quot;production&quot;&lt;/code&gt; 으로 설정 하여 번들링 명령을 실행하십시오 . 이것은 &lt;code&gt;vueify&lt;/code&gt; 가 핫 리로드 및 개발 관련 코드를 포함하지 않도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="65124f23df07644ee66ed5e04606bd6c7b54318b" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about duplicate slots &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행 하고 중복 슬롯 &lt;code&gt;v-model&lt;/code&gt; 에 대한 &lt;strong&gt;콘솔 경고&lt;/strong&gt; 를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="0276baa533bc89d334fafab4aee362813fb56fba" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about inline value attributes with &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행 하고 &lt;code&gt;v-model&lt;/code&gt; 을 사용한 인라인 값 속성에 대한 &lt;strong&gt;콘솔 경고를&lt;/strong&gt; 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="b9168febc3cd9fb510564d5d619d53cfceebc829" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about multiple root elements in a template.</source>
          <target state="translated">업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행 하고 템플릿의 여러 루트 요소에 대한 &lt;strong&gt;콘솔 경고&lt;/strong&gt; 를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="6cd905d20455b18138224bc59c413711a6de22a2" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about prop mutations.</source>
          <target state="translated">업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행 하고 소품 돌연변이에 대한 &lt;strong&gt;콘솔 경고&lt;/strong&gt; 를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="7da416f4436591687e3ea5cf9d579fb6711b7dbd" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about the &lt;code&gt;el&lt;/code&gt; option with &lt;code&gt;Vue.extend&lt;/code&gt;.</source>
          <target state="translated">업그레이드 후 엔드 투 엔드 테스트 스위트 또는 앱을 실행하고 &lt;code&gt;Vue.extend&lt;/code&gt; 로 &lt;code&gt;el&lt;/code&gt; 옵션 에 대한 &lt;strong&gt;콘솔 경고&lt;/strong&gt; 를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="de5aa3b1e8bcd9a2e9b6648cc6da29ebd7c682fa" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">엔드 투 엔드 테스트 스위트가있는 경우이를 실행하십시오. &lt;strong&gt;실패한 테스트는&lt;/strong&gt; 이 변화에 의해 영향을받을 수있는 앱 어떤 부분에 당신에게 경고한다.</target>
        </trans-unit>
        <trans-unit id="25b0475e8303e55dc27cdda9bbd8ef8c1c492011" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that a watcher was relying on the old behavior.</source>
          <target state="translated">엔드 투 엔드 테스트 스위트가있는 경우이를 실행하십시오. &lt;strong&gt;실패한 테스트는&lt;/strong&gt; 감시자가 이전 동작에 의존하고 있다는 사실을 당신에게 경고한다.</target>
        </trans-unit>
        <trans-unit id="3925b4e9140324a46bda954fa3ba6a11551d44d8" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that props passed to root instances are no longer working.</source>
          <target state="translated">엔드 투 엔드 테스트 스위트가있는 경우이를 실행하십시오. &lt;strong&gt;실패한 테스트는&lt;/strong&gt; 루트 인스턴스에 전달 소품이 더 이상 작동되지 않는 사실을 당신에게 경고한다.</target>
        </trans-unit>
        <trans-unit id="c7a107bdb49919e8c77ec76a87618731104be368" translate="yes" xml:space="preserve">
          <source>Run your test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">테스트 스위트 (있는 경우)를 실행하십시오. &lt;strong&gt;실패한 테스트는&lt;/strong&gt; 이 변화에 의해 영향을받을 수있는 앱 어떤 부분에 당신에게 경고한다.</target>
        </trans-unit>
        <trans-unit id="13285023695c206297d4666f3184c48b775d9ec3" translate="yes" xml:space="preserve">
          <source>Runtime + Compiler vs. Runtime-only</source>
          <target state="translated">런타임 + 컴파일러 및 런타임 전용</target>
        </trans-unit>
        <trans-unit id="ce3caf82d6dc4282305777c04d22cb7e32e8739f" translate="yes" xml:space="preserve">
          <source>Runtime Performance</source>
          <target state="translated">런타임 성능</target>
        </trans-unit>
        <trans-unit id="0ab3eee80056a96ec147159fe704ef0b8dcd1e74" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#slot-scope&quot;&gt;&lt;code&gt;slot-scope&lt;/code&gt;&lt;/a&gt; except that &lt;code&gt;scope&lt;/code&gt; can only be used on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소 에서만 사용할 수 있다는 점을 제외하면 &lt;a href=&quot;#slot-scope&quot;&gt; &lt;code&gt;slot-scope&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c41f297530a1a4027d4fe5146dc89421c3603b93" translate="yes" xml:space="preserve">
          <source>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:</source>
          <target state="translated">Sarah Drasner는 아래의 데모에서 시간 및 상호 작용 방식의 상태 변화를 조합하여이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a29f0256272e79ca91a1c4e608f09a6264397d12" translate="yes" xml:space="preserve">
          <source>Scale</source>
          <target state="translated">Scale</target>
        </trans-unit>
        <trans-unit id="88011a37856972ada6fede54fa2220927bfb5ac0" translate="yes" xml:space="preserve">
          <source>Scaling Down</source>
          <target state="translated">축소</target>
        </trans-unit>
        <trans-unit id="2d20a53538fb773c0616dc1ef8c4f21c2ceb637d" translate="yes" xml:space="preserve">
          <source>Scaling Up</source>
          <target state="translated">스케일링</target>
        </trans-unit>
        <trans-unit id="bf1e630e7268556a0635e37341aa31c69f284094" translate="yes" xml:space="preserve">
          <source>Scoped Slots</source>
          <target state="translated">범위가 지정된 슬롯</target>
        </trans-unit>
        <trans-unit id="c891d436871bb971da8c2ff8081958bff3ddb19a" translate="yes" xml:space="preserve">
          <source>Scoped Slots with the &lt;code&gt;slot-scope&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; 속성 이있는 범위가 지정된 슬롯</target>
        </trans-unit>
        <trans-unit id="6aa971b69d2fe9a8fec7d58fa039f9aafe0f8da1" translate="yes" xml:space="preserve">
          <source>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">범위가 지정된 슬롯 함수는 반환 값이 유효하지 않은 경우 VNode 배열을 반환하도록 보장됩니다.이 경우 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dfa277d957af13fbcf610edac48d6ff9d1d53991" translate="yes" xml:space="preserve">
          <source>Search your codebase for the regex &lt;code&gt;/\w+ in \d+/&lt;/code&gt;. Wherever it appears in a &lt;code&gt;v-for&lt;/code&gt;, check to see if you may be affected.</source>
          <target state="translated">&lt;code&gt;/\w+ in \d+/&lt;/code&gt; 정규식 / \ w +에 대한 코드베이스를 검색하십시오 . &lt;code&gt;v-for&lt;/code&gt; 에 나타나는 곳마다 영향을 받는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0d4f1b3e1926d0de28455af2f7b050061aa08a61" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;this fiddle&lt;/a&gt; for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we&amp;rsquo;d recommend creating a reusable &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">전체 코드는 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;이 바이올린&lt;/a&gt; 을 참조하십시오 . 그러나 단일 구성 요소 내에서 많은 설정 및 정리를 수행해야하는 경우 일반적으로 더 많은 모듈 구성 요소를 만드는 것이 가장 좋습니다. 이 경우 재사용 가능한 &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; 구성 요소를 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="04b10db48b879dd4894715118934c8f16e790244" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;this fiddle&lt;/a&gt; for the complete code behind the above demo.</source>
          <target state="translated">위 데모의 전체 코드는 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;이 바이올린&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="030b52b1aecbbfd160c5986ee59275d22c9f7672" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;this fiddle&lt;/a&gt; to experiment with the full code, or &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;this version&lt;/a&gt; for an example binding to a component&amp;rsquo;s options object, instead of its registered name.</source>
          <target state="translated">등록 된 이름 대신 구성 요소의 옵션 객체에 바인딩하는 예제 는 전체 코드 또는 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;이 버전&lt;/a&gt; 을 시험해 보려면 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;이 바이올린&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc6fd808ffb90ac93f1cb9d312e01c08b9a59bf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript compiler options docs&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript 컴파일러 옵션 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f4b188488a5cff189e4cfc9d54ff0931435281a" translate="yes" xml:space="preserve">
          <source>See example &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;the plugins docs&lt;/a&gt; for more info.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;은 플러그인 문서&lt;/a&gt; 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7cdc723bd45704f63d3132765b8411da257e1bf" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue-controlled Wall-E&lt;/a&gt; by Sarah Drasner (&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">CodePen의 Sarah Drasner ( &lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt; )가 &lt;a href=&quot;https://codepen.io&quot;&gt;작성한&lt;/a&gt; 펜 &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;부 제어 월 -E&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="d84be9de2f9e35e379e0e4f6e0bb2340cf1b2d0b" translate="yes" xml:space="preserve">
          <source>Select Options</source>
          <target state="translated">옵션 선택</target>
        </trans-unit>
        <trans-unit id="33e3b8ff7914aff97145e0add0103e5154bdde21" translate="yes" xml:space="preserve">
          <source>Self-closing components</source>
          <target state="translated">자체 결산 부품</target>
        </trans-unit>
        <trans-unit id="8aa1710830cfa45dfe404022342d5aade64a9767" translate="yes" xml:space="preserve">
          <source>Self-closing components &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">자체 폐쇄 구성 요소 &lt;sup&gt;권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">서버 측 렌더링</target>
        </trans-unit>
        <trans-unit id="d986e7075907e08286bd92c14ff694e5215b1ede" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;false&lt;/code&gt; to prevent the production tip on Vue startup.</source>
          <target state="translated">Vue 시작시 프로덕션 팁을 방지하려면 이 값을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0322b76a288cd27bf5d650f3c073fe32426bc786" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API.</source>
          <target state="translated">브라우저 devtool 성능 / 타임 라인 패널에서 구성 요소 초기화, 컴파일, 렌더링 및 패치 성능 추적을 사용 가능하게 하려면 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API 를 지원하는 개발 모드 및 브라우저에서만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="97f2f59947f62c014c5d7c2a4de9191db27303ae" translate="yes" xml:space="preserve">
          <source>Share (and Build) Your Experience</source>
          <target state="translated">경험 공유 및 구축</target>
        </trans-unit>
        <trans-unit id="89dd25c3e7bb9f776951ef9ad74e60a7d6dd05bb" translate="yes" xml:space="preserve">
          <source>Shorthands</source>
          <target state="translated">Shorthands</target>
        </trans-unit>
        <trans-unit id="1ae7276e79db945fd551dc9db134399c32bb6984" translate="yes" xml:space="preserve">
          <source>Should either be updated to use an inline expression:</source>
          <target state="translated">인라인 표현식을 사용하도록 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0a3536bb7788ee14bd41892adba577744a1012d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;$root&lt;/code&gt;, the &lt;code&gt;$parent&lt;/code&gt; property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</source>
          <target state="translated">&lt;code&gt;$root&lt;/code&gt; 와 유사하게 $ &lt;code&gt;$parent&lt;/code&gt; 속성을 사용하여 자식에서 부모 인스턴스에 액세스 할 수 있습니다. 소품으로 데이터를 전달하는 게으른 대안으로 도달하려는 유혹을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dadac4906f4bc6e4a81d9058bdcbf1bbcb397f71" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-else&lt;/code&gt;, a &lt;code&gt;v-else-if&lt;/code&gt; element must immediately follow a &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-else-if&lt;/code&gt; element.</source>
          <target state="translated">유사 &lt;code&gt;v-else&lt;/code&gt; 하는 &lt;code&gt;v-else-if&lt;/code&gt; 요소가 즉시 따라야 &lt;code&gt;v-if&lt;/code&gt; 또는 &lt;code&gt;v-else-if&lt;/code&gt; 요소를.</target>
        </trans-unit>
        <trans-unit id="af9b7b6d2657eb7de92b424e723e1ce34e27dd45" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-on&lt;/code&gt; and &lt;code&gt;v-bind&lt;/code&gt;, &lt;code&gt;v-slot&lt;/code&gt; also has a shorthand, replacing everything before the argument (&lt;code&gt;v-slot:&lt;/code&gt;) with the special symbol &lt;code&gt;#&lt;/code&gt;. For example, &lt;code&gt;v-slot:header&lt;/code&gt; can be rewritten as &lt;code&gt;#header&lt;/code&gt;:</source>
          <target state="translated">유사 &lt;code&gt;v-on&lt;/code&gt; 및 &lt;code&gt;v-bind&lt;/code&gt; , &lt;code&gt;v-slot&lt;/code&gt; (도 인수하기 전에 모든 것을 대체 속기를 가지고 &lt;code&gt;v-slot:&lt;/code&gt; ) 특수 기호와 &lt;code&gt;#&lt;/code&gt; . 예를 들어, &lt;code&gt;v-slot:header&lt;/code&gt; 는 &lt;code&gt;#header&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="110921f9f16f79ec9020d42a774f85de76c9358e" translate="yes" xml:space="preserve">
          <source>Similar to prop defaults, you need to use a factory function for non primitive values:</source>
          <target state="translated">prop 기본값과 유사하게, 기본이 아닌 값에 팩토리 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3115d0b13d887f54dba012634384e7c25cfdf659" translate="yes" xml:space="preserve">
          <source>Similar to template &lt;code&gt;v-if&lt;/code&gt;, you can also use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag with &lt;code&gt;v-for&lt;/code&gt; to render a block of multiple elements. For example:</source>
          <target state="translated">템플릿 &lt;code&gt;v-if&lt;/code&gt; 와 유사하게 &lt;code&gt;v-for&lt;/code&gt; 와 함께 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 태그를 사용하여 여러 요소의 블록을 렌더링 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9032b6dd131e5bdf77e7f1e8c9ad6ef9e98b4db4" translate="yes" xml:space="preserve">
          <source>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</source>
          <target state="translated">마찬가지로 동적 인수를 사용하여 처리기를 동적 ​​이벤트 이름에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e756f11c70f78a0ba1866d4795579c59fa6d1833" translate="yes" xml:space="preserve">
          <source>Simple Assertions</source>
          <target state="translated">간단한 어설 션</target>
        </trans-unit>
        <trans-unit id="bbba1d068bf49ca0e64f1e344f51043367c2266d" translate="yes" xml:space="preserve">
          <source>Simple Routing From Scratch</source>
          <target state="translated">스크래치에서 간단한 라우팅</target>
        </trans-unit>
        <trans-unit id="4e794aae53f27e868a697d7573dd5ec04e937e2a" translate="yes" xml:space="preserve">
          <source>Simple State Management from Scratch</source>
          <target state="translated">스크래치에서 간단한 상태 관리</target>
        </trans-unit>
        <trans-unit id="7a423acd4331de7d207764fc94ba09543c17ef88" translate="yes" xml:space="preserve">
          <source>Simple computed properties</source>
          <target state="translated">간단한 계산 속성</target>
        </trans-unit>
        <trans-unit id="28fbbfbd1e3c5e7641094f470de044776bb5ad02" translate="yes" xml:space="preserve">
          <source>Simple computed properties &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">간단한 계산 속성을 &lt;sup&gt;적극 권장합니다&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="37761f78a8d655b3953b071e198e22dcd5a02587" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates</source>
          <target state="translated">템플릿의 간단한 표현</target>
        </trans-unit>
        <trans-unit id="fcf7b67ac329ddfb22fdf3fbec785727bf9bf466" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">템플릿의 간단한 표현을 &lt;sup&gt;적극 권장합니다&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="211d49f995dbe282f57faa15874e031ac53eeff7" translate="yes" xml:space="preserve">
          <source>Simpler, well-named computed properties are:</source>
          <target state="translated">더 간단하고 잘 알려진 계산 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63a2bccabf19824dace120aef2460e5986003d8a" translate="yes" xml:space="preserve">
          <source>Simplifying computed properties forces you to give each value a descriptive name, even if it&amp;rsquo;s not reused. This makes it much easier for other developers (and future you) to focus in on the code they care about and figure out what&amp;rsquo;s going on.</source>
          <target state="translated">계산 된 속성을 단순화하면 재사용하지 않더라도 각 값에 설명적인 이름을 지정해야합니다. 이를 통해 다른 개발자 (및 미래의 사용자)가 관심있는 코드에 집중하고 진행 상황을 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd1e98b263d4df6091312537a5b1fb83da16e24" translate="yes" xml:space="preserve">
          <source>Simply download and include with a script tag. &lt;code&gt;Vue&lt;/code&gt; will be registered as a global variable.</source>
          <target state="translated">스크립트 태그를 다운로드하여 포함시키기 만하면됩니다. &lt;code&gt;Vue&lt;/code&gt; 는 전역 변수로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="d5938f34f8624b63802c3118f180d5e293766247" translate="yes" xml:space="preserve">
          <source>Simultaneous entering and leaving transitions aren&amp;rsquo;t always desirable though, so Vue offers some alternative &lt;strong&gt;transition modes&lt;/strong&gt;:</source>
          <target state="translated">동시 입력 및 종료 전환이 항상 바람직하지는 않으므로 Vue는 몇 가지 대체 &lt;strong&gt;전환 모드를&lt;/strong&gt; 제공 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6a69d78f54bcf8ac6e1f4a3963e04cee33a026d0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;$nextTick()&lt;/code&gt; returns a promise, you can achieve the same as the above using the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 async/await&lt;/a&gt; syntax:</source>
          <target state="translated">이후 &lt;code&gt;$nextTick()&lt;/code&gt; 약속을 반환, 당신은 새로운 사용하여 위의와 동일하게 달성 할 수 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 비동기 / await를&lt;/a&gt; 구문 :</target>
        </trans-unit>
        <trans-unit id="10a777de149e5a77b75501c009eb466a9bc93514" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v-ref&lt;/code&gt; is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with &lt;code&gt;v-for&lt;/code&gt;. For example:</source>
          <target state="translated">때문에 &lt;code&gt;v-ref&lt;/code&gt; 더 이상 지시하지만, 특별한 속성입니다, 그것은 또한 동적으로 정의 할 수 없습니다. 이것은 &lt;code&gt;v-for&lt;/code&gt; 와 함께 사용하면 특히 유용 합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9de3c1e0a71e1edcdc7ffbc2b45060ebfe43b095" translate="yes" xml:space="preserve">
          <source>Since Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;performs DOM updates asynchronously&lt;/a&gt;, assertions on DOM updates resulting from state change will have to be made in a &lt;code&gt;Vue.nextTick&lt;/code&gt; callback:</source>
          <target state="translated">Vue는 &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;DOM 업데이트를 비동기 적으로 수행&lt;/a&gt; 하므로 상태 변경으로 인한 DOM 업데이트에 대한 어설 션은 &lt;code&gt;Vue.nextTick&lt;/code&gt; 콜백 에서 이루어져야합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f5eaf2601394efec9f1b3f5eff696573b84807" translate="yes" xml:space="preserve">
          <source>Since Vue doesn&amp;rsquo;t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</source>
          <target state="translated">Vue는 루트 수준 반응 속성을 동적으로 추가 할 수 없으므로 비어있는 값으로도 모든 루트 수준 반응 데이터 속성을 미리 선언하여 Vue 인스턴스를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="17a485dec90726f134aafab30671454807556666" translate="yes" xml:space="preserve">
          <source>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. &lt;code&gt;MyButton&lt;/code&gt;, &lt;code&gt;VueButton&lt;/code&gt;).</source>
          <target state="translated">컴포넌트 이름은 항상 여러 단어 &lt;code&gt;VueButton&lt;/code&gt; 규칙을 사용하면 간단한 컴포넌트 래퍼 (예 : &lt;code&gt;MyButton&lt;/code&gt; , VueButton )에 대해 임의의 접두사를 선택하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba2168060abb1674449c97121137c7602377ef42" translate="yes" xml:space="preserve">
          <source>Since components are reusable Vue instances, they accept the same options as &lt;code&gt;new Vue&lt;/code&gt;, such as &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, and lifecycle hooks. The only exceptions are a few root-specific options like &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">컴포넌트는 재사용 가능한 Vue 인스턴스이므로 &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; , &lt;code&gt;watch&lt;/code&gt; , &lt;code&gt;methods&lt;/code&gt; 및 lifecycle hooks와 같은 &lt;code&gt;new Vue&lt;/code&gt; 와 동일한 옵션을 허용합니다 . 유일한 예외는 &lt;code&gt;el&lt;/code&gt; 과 같은 몇 가지 루트 별 옵션 입니다.</target>
        </trans-unit>
        <trans-unit id="2b68173db2c99b86c3a75462f226a7b75ff0f1d5" translate="yes" xml:space="preserve">
          <source>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</source>
          <target state="translated">편집기는 일반적으로 파일을 사전 순으로 구성하므로 구성 요소 간의 모든 중요한 관계가 한눈에 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef79f75d79e817472bd0ed5aad52845e59dbf2e4" translate="yes" xml:space="preserve">
          <source>Since functional components are just functions, they&amp;rsquo;re much cheaper to render.</source>
          <target state="translated">기능적 구성 요소는 단지 기능이기 때문에 렌더링 비용이 훨씬 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="5ca066badcd55a6324af0033eddd42706cb8d9c3" translate="yes" xml:space="preserve">
          <source>Since it&amp;rsquo;s a generic mechanism for Vue to identify nodes, the &lt;code&gt;key&lt;/code&gt; also has other uses that are not specifically tied to &lt;code&gt;v-for&lt;/code&gt;, as we will see later in the guide.</source>
          <target state="translated">Vue가 노드를 식별하는 일반적인 메커니즘이므로이 &lt;code&gt;key&lt;/code&gt; 에는 &lt;code&gt;v-for&lt;/code&gt; 에 특별히 연결되지 않은 다른 용도도 있습니다 .이 가이드의 뒷부분에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c460325ca52e3630249720f5552ae7b020e4765a" translate="yes" xml:space="preserve">
          <source>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</source>
          <target state="translated">런타임 전용 빌드는 전체 빌드에 비해 약 30 % 가벼우므로 가능할 때마다 사용해야합니다. 여전히 전체 빌드를 사용하려면 번 들러에서 별명을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e62e1d6e39e14f551529b609a48c6fb619bb1df6" translate="yes" xml:space="preserve">
          <source>Since these are &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;published on NPM&lt;/a&gt;, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don&amp;rsquo;t need any additional tooling to use TypeScript with Vue.</source>
          <target state="translated">이것들은 &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;NPM&lt;/a&gt; 에 게시되어 있으며 최신 TypeScript는 NPM 패키지에서 형식 선언을 해결하는 방법을 알고 있으므로 NPM을 통해 설치할 때 Vue와 함께 TypeScript를 사용하기 위해 추가 도구가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ea3d2ff946bc5b79835d964012d367a993b9ca6" translate="yes" xml:space="preserve">
          <source>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</source>
          <target state="translated">이러한 구성 요소는 자주 사용되므로 어디서나 가져 오기 대신 전체 구성 요소로 만들 수 있습니다. 접두사는 Webpack에서이를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="796906cd98540356e295c43d625d24ed68862aac" translate="yes" xml:space="preserve">
          <source>Since we&amp;rsquo;re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</source>
          <target state="translated">더 이상 값을 반환해야하는 필터 옵션을 사용하지 않기 때문에 실제로 통화 작업은 비동기 적으로 수행 될 수 있습니다. 즉, 통화와 관련된 많은 앱이있는 경우이 논리를 공유 마이크로 서비스로 쉽게 리팩터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a31aa77b805847e93b5d67d3ae054b43de8ddfb3" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</source>
          <target state="translated">JS에서 이벤트 리스너를 수동으로 연결할 필요가 없으므로 ViewModel 코드는 순수 논리 및 DOM이 될 수 있습니다. 테스트하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="59debd2931aa770a2b0975329d41213dcd9c5d88" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; to learn enough to build non-trivial applications.</source>
          <target state="translated">Vue를 시작하기 위해 JSX, ES2015 또는 빌드 시스템에 대해 알 필요가 없기 때문에 일반적으로 개발자 가 사소한 응용 프로그램을 작성하기에 충분히 배우기 &lt;a href=&quot;../index&quot;&gt;위해 가이드&lt;/a&gt; 를 읽는 데 하루도 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a6e205b866dd29d282ce270191d3645216b482d" translate="yes" xml:space="preserve">
          <source>Single File Components</source>
          <target state="translated">단일 파일 구성 요소</target>
        </trans-unit>
        <trans-unit id="5e7f1d7d63552994a465b38c32202f3620abe335" translate="yes" xml:space="preserve">
          <source>Single checkbox, boolean value:</source>
          <target state="translated">단일 확인란, 부울 값 :</target>
        </trans-unit>
        <trans-unit id="040f06c8b02b9ecd8ce3bcc463d52f44ab71de30" translate="yes" xml:space="preserve">
          <source>Single select:</source>
          <target state="translated">단일 선택 :</target>
        </trans-unit>
        <trans-unit id="95ef58f9b3d77202b180ce829f19b7953db91e4d" translate="yes" xml:space="preserve">
          <source>Single-file (&lt;code&gt;.vue&lt;/code&gt;) components</source>
          <target state="translated">단일 파일 ( &lt;code&gt;.vue&lt;/code&gt; ) 구성 요소</target>
        </trans-unit>
        <trans-unit id="a0fcc7019dc5bbeb59c13b0247440b91dff10e8e" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing</source>
          <target state="translated">단일 파일 구성 요소 파일 이름 케이스</target>
        </trans-unit>
        <trans-unit id="093c716d53dd968ee64e9ba688e8285861d21500" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">단일 파일 구성 요소 파일 이름 케이스를 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="aad2c1946beed7073bd3f80b10b836af1bd801c0" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order</source>
          <target state="translated">단일 파일 구성 요소 최상위 요소 순서</target>
        </trans-unit>
        <trans-unit id="369e619c0ac6b0e41c0c5e5672725a1dad22811c" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">단일 파일 구성 요소 최상위 요소 순서 &lt;sup&gt;권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e5ab16f7ba44150cac61508afe92cbd1d1dd294b" translate="yes" xml:space="preserve">
          <source>Single-instance component names</source>
          <target state="translated">단일 인스턴스 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="801a9b431b0affdfa69d3dd93084d1b29dae9cb0" translate="yes" xml:space="preserve">
          <source>Single-instance component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">단일 인스턴스 구성 요소 이름을 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="896ccfe8515d070b5a15610d907daecc5196a888" translate="yes" xml:space="preserve">
          <source>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</source>
          <target state="translated">이 요소와 모든 하위 요소에 대한 컴파일을 건너 뜁니다. 원시 콧수염 태그를 표시하는 데 사용할 수 있습니다. 지시어가없는 많은 수의 노드를 건너 뛰면 컴파일 속도가 빨라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083d20797ac518ecfd2d5802f11e56f053d9b2a3" translate="yes" xml:space="preserve">
          <source>Slot Content</source>
          <target state="translated">슬롯 내용</target>
        </trans-unit>
        <trans-unit id="0c1a16e17517d5db584e59f03e5701a1df0aec29" translate="yes" xml:space="preserve">
          <source>Slots</source>
          <target state="translated">Slots</target>
        </trans-unit>
        <trans-unit id="0c05d5215c9958f423cfa89492ade3561c496be1" translate="yes" xml:space="preserve">
          <source>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</source>
          <target state="translated">작고 집중적 인 계산 된 속성은 정보 사용 방법에 대한 가정을 적게 사용하므로 요구 사항이 변경 될 때 리팩토링이 덜 필요합니다.</target>
        </trans-unit>
        <trans-unit id="270782c16d7dfcd9bacc30c93f3205da13a192a6" translate="yes" xml:space="preserve">
          <source>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</source>
          <target state="translated">따라서 일부 사용자에 대해서만 요소를 렌더링하더라도 다시 렌더링 할 때마다 활성 사용자 집합의 변경 여부에 관계없이 전체 목록을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="9efa5f0263f4584699ee25a6ef7cd96b38af2cbd" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</source>
          <target state="translated">지금까지 템플릿의 간단한 속성 키에만 바인딩했습니다. 그러나 Vue.js는 실제로 모든 데이터 바인딩 내에서 JavaScript 표현식의 모든 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fc43cc8fe805d607917adfb57b267a4c1e366e21" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve managed transitions for:</source>
          <target state="translated">지금까지 다음에 대한 전환을 관리했습니다.</target>
        </trans-unit>
        <trans-unit id="9990ce27d68bc258ecfe618b1e117aba2e010d2d" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only created components using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">지금까지 &lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 구성 요소 만 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="67796fb098e807812b451996ffa7c37901a92525" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only seen props listed as an array of strings:</source>
          <target state="translated">지금까지 소품 배열로 나열된 소품 만 보았습니다.</target>
        </trans-unit>
        <trans-unit id="bcb7e6dc22797e50c31c81c6ca57f0d64cd4b40a" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen props passed a static value, like in:</source>
          <target state="translated">지금까지 소품이 정적 값을 전달하는 것을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="bf5ea7f867584dc6f766ba242591c6f576f49d80" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen uses of &lt;code&gt;$emit&lt;/code&gt;, listened to with &lt;code&gt;v-on&lt;/code&gt;, but Vue instances also offer other methods in its events interface. We can:</source>
          <target state="translated">지금까지 &lt;code&gt;$emit&lt;/code&gt; 사용을 보았고 &lt;code&gt;v-on&lt;/code&gt; 으로 청취 했지만 Vue 인스턴스는 이벤트 인터페이스에서 다른 메소드도 제공합니다. 우리는 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8d84a44b86d81a516326f9813e2b3977e997a457" translate="yes" xml:space="preserve">
          <source>So this might be a good time to refactor the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to accept a single &lt;code&gt;post&lt;/code&gt; prop instead:</source>
          <target state="translated">따라서 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소를 리팩터링하여 단일 &lt;code&gt;post&lt;/code&gt; 소품을 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d6aa2762b60d0919d3cc5d125c99532a28d73b78" translate="yes" xml:space="preserve">
          <source>So what about for when we have a whole list of items we want to render simultaneously, for example with &lt;code&gt;v-for&lt;/code&gt;? In this case, we&amp;rsquo;ll use the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component. Before we dive into an example though, there are a few things that are important to know about this component:</source>
          <target state="translated">따라서 &lt;code&gt;v-for&lt;/code&gt; 와 같이 동시에 렌더링하려는 전체 항목 목록이 있으면 어떨까요? 이 경우 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 구성 요소를 사용합니다. 예제를 살펴보기 전에이 구성 요소에 대해 알아야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="147f6354f521a67959c12f2f8261d77ce2bb9c39" translate="yes" xml:space="preserve">
          <source>Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &amp;gt; 와 같은 일부 HTML 요소에는 내부에 표시 할 수있는 요소에 대한 제한이 있으며 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 과 같은 일부 요소 만 다른 특정 요소 안에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9c0790e8dcd7f3a0c69aa32f511de55c1f1ea0e6" translate="yes" xml:space="preserve">
          <source>Some advantages of this convention:</source>
          <target state="translated">이 컨벤션의 장점 :</target>
        </trans-unit>
        <trans-unit id="2108424fbba417074fadf0d75a3e1edc693ebce6" translate="yes" xml:space="preserve">
          <source>Some argue that you&amp;rsquo;d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn&amp;rsquo;t mean the user doesn&amp;rsquo;t need to learn anything - it&amp;rsquo;s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it&amp;rsquo;s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. &lt;code&gt;v-on&lt;/code&gt; modifiers). The same task can involve a lot more code when using plain JSX or render functions.</source>
          <target state="translated">일부는 템플릿을 작성하려면 추가 DSL (Domain-Specific Language)을 배워야한다고 주장합니다.이 차이는 가장 피상적이라고 생각합니다. 첫째, JSX는 사용자가 아무것도 배울 필요가 없다는 것을 의미하지는 않습니다. 일반 JavaScript 위에 추가 구문이 있으므로 JavaScript에 익숙한 사람이 쉽게 배울 수 있지만 본질적으로 무료라고 말하는 것은 오해의 소지가 있습니다. 마찬가지로 템플릿은 일반 HTML 위에 추가 구문 일 뿐이므로 이미 HTML에 익숙한 사용자에게는 학습 비용이 매우 낮습니다. DSL을 통해 사용자는 적은 코드 (예 : &lt;code&gt;v-on&lt;/code&gt; 수정 자)로 더 많은 작업을 수행 할 수 있습니다 . 동일한 작업에는 일반 JSX 또는 렌더링 함수를 사용할 때 훨씬 더 많은 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ef7770ac385e4eae53d066a2f3c10a8b6c4ab6" translate="yes" xml:space="preserve">
          <source>Some directives can take an &amp;ldquo;argument&amp;rdquo;, denoted by a colon after the directive name. For example, the &lt;code&gt;v-bind&lt;/code&gt; directive is used to reactively update an HTML attribute:</source>
          <target state="translated">일부 지시문은 지시문 이름 뒤에 콜론으로 표시되는 &quot;인수&quot;를 취할 수 있습니다. 예를 들어, &lt;code&gt;v-bind&lt;/code&gt; 지시문은 HTML 속성을 반응 적으로 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09428a807ec781f76bc254d725a9a4e0a2df7f8b" translate="yes" xml:space="preserve">
          <source>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of &lt;code&gt;new Function()&lt;/code&gt; for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</source>
          <target state="translated">Chrome 앱과 같은 일부 환경에서는 콘텐츠 보안 정책 (CSP)이 적용되어 식 평가 에 &lt;code&gt;new Function()&lt;/code&gt; 을 사용할 수 없습니다 . 전체 빌드는이 기능에 따라 템플릿을 컴파일하므로 이러한 환경에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a2e23d7e711dac515b3913d004594ddb71e0888" translate="yes" xml:space="preserve">
          <source>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</source>
          <target state="translated">Vue의 일부 기능은 레거시 코드 기반에서 드문 경우 나 원활한 마이그레이션을 수용하기 위해 존재합니다. 그러나 너무 많이 사용하면 코드를 유지하기가 더 어려워 지거나 버그의 원인이 될 수 있습니다. 이러한 규칙은 피해야 할시기와 이유를 설명하는 잠재적으로 위험한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d10fd1239637017ec222f508352aa84bee00680a" translate="yes" xml:space="preserve">
          <source>Some of Vue&amp;rsquo;s syntax will look very similar to AngularJS (e.g. &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt;). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.</source>
          <target state="translated">Vue의 구문 중 일부는 AngularJS와 매우 유사하게 보입니다 (예 : &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt; ). 이것은 AngularJS가 옳은 것들이 많았고 Vue가 개발 초기에 영감을 주었기 때문입니다. 그러나 Vue가 크게 개선하려고 시도한 AngularJS에는 많은 고통이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba632b521cfadde631ed92ffd03194fe0b0a9806" translate="yes" xml:space="preserve">
          <source>Some of the current hooks have different behavior and there are also a couple new hooks.</source>
          <target state="translated">현재 후크 중 일부는 동작이 다르며 몇 가지 새로운 후크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="823d42c9ef6472009b44bd254d2588f2ed0ae4c8" translate="yes" xml:space="preserve">
          <source>Some of the most notable differences include:</source>
          <target state="translated">가장 주목할만한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85976567c84aab5c4b5906f9117b4275cd11d741" translate="yes" xml:space="preserve">
          <source>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.</source>
          <target state="translated">아래 섹션 중 일부는 React 16+의 최근 업데이트로 인해 약간 오래된 것일 수도 있으며 가까운 시일 내에 React 커뮤니티와 협력하여이 섹션을 개정 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="e66b9d4602dcda92a8811e8379102ad854fa4037" translate="yes" xml:space="preserve">
          <source>Some plugins provided by Vue.js official plugins such as &lt;code&gt;vue-router&lt;/code&gt; automatically calls &lt;code&gt;Vue.use()&lt;/code&gt; if &lt;code&gt;Vue&lt;/code&gt; is available as a global variable. However in a module environment such as CommonJS, you always need to call &lt;code&gt;Vue.use()&lt;/code&gt; explicitly:</source>
          <target state="translated">&lt;code&gt;Vue&lt;/code&gt; &lt;code&gt;vue-router&lt;/code&gt; 와 같은 Vue.js 공식 플러그인에서 제공하는 일부 플러그인 은 Vue를 전역 변수로 사용할 수있는 경우 &lt;code&gt;Vue.use()&lt;/code&gt; 자동으로 호출 합니다. 그러나 CommonJS와 같은 모듈 환경에서는 항상 &lt;code&gt;Vue.use()&lt;/code&gt; 명시 적으로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9fe62eac7aa92f9e248fd4f6cf8a8c9817319b5d" translate="yes" xml:space="preserve">
          <source>Some users have enjoyed using two-way filters with &lt;code&gt;v-model&lt;/code&gt; to create interesting inputs with very little code. While &lt;em&gt;seemingly&lt;/em&gt; simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</source>
          <target state="translated">일부 사용자는 &lt;code&gt;v-model&lt;/code&gt; 과 함께 양방향 필터를 사용하여 코드가 거의없는 흥미로운 입력을 만들었습니다. 그러나 단순 해 &lt;em&gt;보이지만&lt;/em&gt; 양방향 필터는 많은 복잡성을 숨길 수 있으며 상태 업데이트를 지연시켜 열악한 UX를 장려 할 수도 있습니다. 대신, 입력을 래핑하는 컴포넌트는 사용자 정의 입력을 작성하는보다 명시적이고 기능이 풍부한 방법으로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="a20659b05e332a0ae32621debfebacc5d1ababa5" translate="yes" xml:space="preserve">
          <source>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</source>
          <target state="translated">전환 항목이 서로의 상단에 절대적으로 위치 할 때와 같이 때때로 이것은 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="f26fd8bf6b50010b5da928fa27ec1a70c263cd9c" translate="yes" xml:space="preserve">
          <source>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special &lt;code&gt;$event&lt;/code&gt; variable:</source>
          <target state="translated">때로는 인라인 명령문 핸들러에서 원래 DOM 이벤트에 액세스해야 할 수도 있습니다. 특수 &lt;code&gt;$event&lt;/code&gt; 변수를 사용하여 메소드에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a58007ff3d542a5e64e8ab0473747490736edba5" translate="yes" xml:space="preserve">
          <source>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</source>
          <target state="translated">때로는 원래 데이터를 실제로 변경하거나 재설정하지 않고 필터링되거나 정렬 된 버전의 배열을 표시하려고 할 때가 있습니다. 이 경우 필터링되거나 정렬 된 배열을 반환하는 계산 된 속성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4776e0f84b8cab0978edcc2a16ccf37eb32d43" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of new properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. In such cases, you should create a fresh object with properties from both objects. So instead of:</source>
          <target state="translated">때로는 &lt;code&gt;Object.assign()&lt;/code&gt; 또는 &lt;code&gt;_.extend()&lt;/code&gt; 를 사용하여 기존 객체에 여러 가지 새로운 속성을 할당 할 수 있습니다 . 이 경우 두 객체의 속성을 사용하여 새로운 객체를 만들어야합니다. 따라서 대신 :</target>
        </trans-unit>
        <trans-unit id="4216179a7f142347ead5e8b4c8a44ddd1938267a" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</source>
          <target state="translated">때로는 &lt;code&gt;Object.assign()&lt;/code&gt; 또는 &lt;code&gt;_.extend()&lt;/code&gt; 를 사용하여 기존 객체에 여러 속성을 할당 할 수 있습니다 . 그러나 객체에 추가 된 새로운 속성은 변경 사항을 트리거하지 않습니다. 이러한 경우 원래 객체와 mixin 객체의 속성을 사용하여 새로운 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a3e5c479936fa0c0c3ae63c92af5bdeccbe0976" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful for slot content to have access to data only available in the child component. For example, imagine a &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">때때로 슬롯 컨텐츠가 하위 구성 요소에서만 사용 가능한 데이터에 액세스하는 것이 유용 할 수 있습니다. 예를 들어 다음 템플릿이 있는 &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; 구성 요소를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="d2dd5e9a7fd5d98bf25e0a4d4fb18f9f4c3db2f1" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to dynamically switch between components, like in a tabbed interface:</source>
          <target state="translated">때로는 탭 인터페이스와 같이 구성 요소간에 동적으로 전환하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="878866be830f3d4c0492c7b15ce7d3313f921fc8" translate="yes" xml:space="preserve">
          <source>Soup &lt;em&gt;of the&lt;/em&gt; day</source>
          <target state="translated">수프 &lt;em&gt;의&lt;/em&gt; 하루</target>
        </trans-unit>
        <trans-unit id="9898b37c34a88e00f23e82b5e3dc9a1701903a0c" translate="yes" xml:space="preserve">
          <source>Special Attributes</source>
          <target state="translated">특수 속성</target>
        </trans-unit>
        <trans-unit id="c1844df643c3c6b29d9ebd395e5456144c913b68" translate="yes" xml:space="preserve">
          <source>Special Attributes - ref</source>
          <target state="translated">특수 속성-심판</target>
        </trans-unit>
        <trans-unit id="7f375124a7e84608fdea56b183bf085ef84dd0dd" translate="yes" xml:space="preserve">
          <source>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</source>
          <target state="translated">소품의 기본값을 지정합니다. prop이 전달되지 않으면이 값이 대신 사용됩니다. 객체 또는 배열 기본값은 팩토리 함수에서 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d419b352796d39146919ef5966306201da0baac" translate="yes" xml:space="preserve">
          <source>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as &lt;code&gt;this.$parent&lt;/code&gt; for the child, and the child will be pushed into the parent&amp;rsquo;s &lt;code&gt;$children&lt;/code&gt; array.</source>
          <target state="translated">작성할 인스턴스의 상위 인스턴스를 지정하십시오. 둘 사이의 부모-자식 관계를 설정합니다. 부모는 &lt;code&gt;this.$parent&lt;/code&gt; 접근 할 수 있습니다 . 자식의 부모 는 $ parent 이고 자식은 부모의 &lt;code&gt;$children&lt;/code&gt; 배열로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="e4de7be6dcaca74a1df3b6f74eed72c7caf49130" translate="yes" xml:space="preserve">
          <source>Staggering List Transitions</source>
          <target state="translated">엇갈린 목록 전환</target>
        </trans-unit>
        <trans-unit id="5ba91e4b27bd154b6feecd545db4023c8e7c12d0" translate="yes" xml:space="preserve">
          <source>Start by running the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on a current project. We&amp;rsquo;ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they&amp;rsquo;ll let you know, offer suggestions, and provide links to more info.</source>
          <target state="translated">현재 프로젝트 에서 &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;마이그레이션 헬퍼&lt;/a&gt; 를 실행하여 시작하십시오 . 우리는 선임 Vue dev를 간단한 명령 행 인터페이스로 신중하게 축소하고 압축했습니다. 구식 기능을 인식 할 때마다 알려주고 제안을 제공하며 자세한 정보에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5fcf8af955dfbcfec984375c6e8f6a528e65233d" translate="yes" xml:space="preserve">
          <source>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="translated">2.3.0 이상부터는 스타일 속성에 여러 (접두사) 값의 배열을 제공 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ba53e05f135de31a97be4f79621e7c2bfae116b" translate="yes" xml:space="preserve">
          <source>Starting in 2.4.0+, &lt;code&gt;v-on&lt;/code&gt; also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 은 2.4.0 이상부터 인수없이 이벤트 / 리스너 쌍의 객체에 대한 바인딩도 지원합니다. 객체 구문을 사용할 때는 수정자를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b9230ebf8a27183774b5eb88b79650092ee23d2" translate="yes" xml:space="preserve">
          <source>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="translated">버전 2.6.0부터는 대괄호로 묶어 지시문 인수에 JavaScript 표현식을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa146787ba4b5ec0af7e28c9b9db98dcdf2cd1c" translate="yes" xml:space="preserve">
          <source>State Management</source>
          <target state="translated">상태 관리</target>
        </trans-unit>
        <trans-unit id="d5d64221ddf91f88df67cce91813f4262eb7edaf" translate="yes" xml:space="preserve">
          <source>State Transitions</source>
          <target state="translated">상태 전환</target>
        </trans-unit>
        <trans-unit id="a872ca8fe22c7e62b5337472cd220dc9385362c8" translate="yes" xml:space="preserve">
          <source>Stop listening for an event with &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt; 로 이벤트 수신 중지</target>
        </trans-unit>
        <trans-unit id="a59e5fba28ea5c4503821b338479233b19afe716" translate="yes" xml:space="preserve">
          <source>Store&amp;rsquo;s Event Emitter &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">상점의 이벤트 이미 터가 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="91315c1968e95b4caef2bb0299209f84b45e1fa3" translate="yes" xml:space="preserve">
          <source>String templates (e.g. &lt;code&gt;template: '...'&lt;/code&gt;)</source>
          <target state="translated">문자열 템플릿 (예 : &lt;code&gt;template: '...'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74b4f2ed89813f9a73f7270d61c097ff9c059dd6" translate="yes" xml:space="preserve">
          <source>Style Guide</source>
          <target state="translated">스타일 가이드</target>
        </trans-unit>
        <trans-unit id="93b9066aa73ddae63c26874719afa6da8fe21b7f" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority A: Essential</source>
          <target state="translated">스타일 가이드 : 우선 순위 A : 필수</target>
        </trans-unit>
        <trans-unit id="43212530e7b38b61ce475ee08dd6944866d5239c" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority B: Strongly Recommended</source>
          <target state="translated">스타일 가이드 : 우선 순위 B : 강력 추천</target>
        </trans-unit>
        <trans-unit id="dc97fc3044903277305bdcda1967fb4d1dab822e" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority C: Recommended</source>
          <target state="translated">스타일 가이드 : 우선 순위 C : 권장</target>
        </trans-unit>
        <trans-unit id="b9a479a71d55ce0478bf03634c2c6dce93bce7d7" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority D: Use with Caution</source>
          <target state="translated">스타일 가이드 : 우선 순위 D :주의해서 사용</target>
        </trans-unit>
        <trans-unit id="d999535d9e96f490d6db66310b5ab700b8118ee7" translate="yes" xml:space="preserve">
          <source>Style Guide: Rule Categories</source>
          <target state="translated">스타일 안내서 : 규칙 범주</target>
        </trans-unit>
        <trans-unit id="fbbf610d0cedad761fd69b3fc9625e259e3102c5" translate="yes" xml:space="preserve">
          <source>Suppress all Vue logs and warnings.</source>
          <target state="translated">모든 Vue 로그 및 경고를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ed4b8354b13fc6485ba3014a73af2e474df2ab5c" translate="yes" xml:space="preserve">
          <source>System Modifier Keys</source>
          <target state="translated">시스템 수정 자 키</target>
        </trans-unit>
        <trans-unit id="d3c9825399d84e5c262586eb382db07595391d25" translate="yes" xml:space="preserve">
          <source>Template Compilation</source>
          <target state="translated">템플릿 편집</target>
        </trans-unit>
        <trans-unit id="efb3147068725b40c3436e7283942bba6c112bbf" translate="yes" xml:space="preserve">
          <source>Template Syntax</source>
          <target state="translated">템플릿 구문</target>
        </trans-unit>
        <trans-unit id="a60e21f3a907038b2e4d24850447a7990f71ed0d" translate="yes" xml:space="preserve">
          <source>Template expressions are sandboxed and only have access to a &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;whitelist of globals&lt;/a&gt; such as &lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;Date&lt;/code&gt;. You should not attempt to access user defined globals in template expressions.</source>
          <target state="translated">템플릿 표현식은 샌드 박스 처리 되며 &lt;code&gt;Math&lt;/code&gt; 및 &lt;code&gt;Date&lt;/code&gt; 와 같은 &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;글로벌 목록&lt;/a&gt; 에만 액세스 할 수 있습니다 . 템플릿 표현식에서 사용자 정의 전역에 액세스하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="03aaa3887a5a2deee792941da96ae7dda7d74089" translate="yes" xml:space="preserve">
          <source>Thanks to Vue&amp;rsquo;s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</source>
          <target state="translated">Vue의 Reactivity 시스템 덕분에 항상 업데이트시기를 알 수 있습니다 (올바르게 사용하는 경우). 그러나 반응 데이터가 변경되지 않았음에도 불구하고 업데이트를 강제로 수행해야 할 경우가 있습니다. 그런 다음 불필요한 업데이트를 방지하려는 다른 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5627556ef42d923efe566603e16cd6d339c54b6" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; listener, the parent will receive the event and update &lt;code&gt;postFontSize&lt;/code&gt; value.</source>
          <target state="translated">받는 사람 덕분에 &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; 청취자는, 부모는 이벤트 및 업데이트받을 수 &lt;code&gt;postFontSize&lt;/code&gt; 의 값입니다.</target>
        </trans-unit>
        <trans-unit id="36e5dbb5155a7f2f18ff2f7f92eeacd1bc83b650" translate="yes" xml:space="preserve">
          <source>That means the value of &lt;code&gt;v-slot&lt;/code&gt; can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;), you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; to pull out specific slot props, like so:</source>
          <target state="translated">이는 &lt;code&gt;v-slot&lt;/code&gt; 의 값이 실제로 함수 정의의 인수 위치에 나타날 수있는 유효한 JavaScript 표현식을 허용 할 수 있음을 의미합니다 . 따라서 지원되는 환경 ( &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;최신 브라우저&lt;/a&gt; )에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 소멸&lt;/a&gt; 을 사용 하여 다음과 같이 특정 슬롯 소품을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcb7688f15ef595e1970dc731883ce107eed33d5" translate="yes" xml:space="preserve">
          <source>That means this element:</source>
          <target state="translated">이것은이 요소를 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="e26ac9d99d2de3a31a44d33d135f52e40dec965b" translate="yes" xml:space="preserve">
          <source>That said, it would probably make a better comparison between Vue core and Ember&amp;rsquo;s &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;templating&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;object model&lt;/a&gt; layers:</source>
          <target state="translated">즉, Vue 코어와 Ember의 &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;템플릿&lt;/a&gt; 및 &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;객체 모델&lt;/a&gt; 레이어를 더 잘 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd91ee6e59ac928406a857815fec4a8fd6adac41" translate="yes" xml:space="preserve">
          <source>That slot has access to the same instance properties (i.e. the same &amp;ldquo;scope&amp;rdquo;) as the rest of the template. The slot does &lt;strong&gt;not&lt;/strong&gt; have access to &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s scope. For example, trying to access &lt;code&gt;url&lt;/code&gt; would not work:</source>
          <target state="translated">해당 슬롯은 나머지 템플릿과 동일한 인스턴스 속성 (예 : 동일한 &quot;범위&quot;)에 액세스 할 수 있습니다. 슬롯은 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 의 범위에 액세스 할 수 &lt;strong&gt;없습니다&lt;/strong&gt; . 예를 들어 &lt;code&gt;url&lt;/code&gt; 에 액세스하려고하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="459dd83f2362d8a07c853704c9fdaa721e9d7d51" translate="yes" xml:space="preserve">
          <source>That template doesn&amp;rsquo;t feel great. It&amp;rsquo;s not only verbose, but we&amp;rsquo;re duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level and will have to do the same when we add the anchor element.</source>
          <target state="translated">그 템플릿은 기분이 좋지 않습니다. 그것은 장황 할뿐만 아니라 모든 제목 수준에 대해 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; 을 복제 하므로 앵커 요소를 추가 할 때도 동일하게 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0e76918c986bcb84adf08fee89b468d3a1fda00" translate="yes" xml:space="preserve">
          <source>That won&amp;rsquo;t work, however, because only the &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component has access to the &lt;code&gt;user&lt;/code&gt; and the content we&amp;rsquo;re providing is rendered in the parent.</source>
          <target state="translated">그것은하지 않습니다 일, 그러나 단지 때문에 &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; 구성 요소는 액세스가 &lt;code&gt;user&lt;/code&gt; 와 우리가 부모에 렌더링 제공하고있는 컨텐츠를.</target>
        </trans-unit>
        <trans-unit id="f7e6eaf815a0b389b506fd9203ee98688ac385cc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about DOM template parsing caveats for now &amp;ndash; and actually, the end of Vue&amp;rsquo;s &lt;em&gt;Essentials&lt;/em&gt;. Congratulations! There&amp;rsquo;s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</source>
          <target state="translated">이것으로 DOM 템플릿 파싱에 대해 알아야 할 모든 것, 그리고 실제로 Vue 's &lt;em&gt;Essentials&lt;/em&gt; 의 끝입니다 . 축하합니다! 아직 배울 것이 많지만, 먼저 Vue를 가지고 놀고 재미있는 것을 만들어 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e65f913a2b8930db25e11b615901938e35677612" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about custom component events for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-custom-events&quot;&gt;Custom Events&lt;/a&gt;.</source>
          <target state="translated">지금까지 사용자 정의 구성 요소 이벤트에 대해 알아야 할 모든 것이지만,이 페이지를 다 읽은 후 내용에 익숙해지면 나중에 다시 &lt;a href=&quot;components-custom-events&quot;&gt;사용자 정의 이벤트&lt;/a&gt; 에 대한 전체 안내서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="814dc84544fcf8f9ba3af47bc369c70717b8fdfa" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about dynamic components for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;.</source>
          <target state="translated">지금까지 동적 구성 요소에 대해 알아야 할 모든 것이지만,이 페이지를 다 읽은 후 내용에 익숙해지면 나중에 &lt;a href=&quot;components-dynamic-async&quot;&gt;동적 및 비동기 구성 요소&lt;/a&gt; 에 대한 전체 안내서를 읽어 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1370785d9557daacd2793450c22d6061fa0adbc6" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about props for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-props&quot;&gt;Props&lt;/a&gt;.</source>
          <target state="translated">지금까지 소품에 대해 알아야 할 모든 것이지만,이 페이지를 다 읽은 후 내용에 익숙해지면 나중에 다시 &lt;a href=&quot;components-props&quot;&gt;소품&lt;/a&gt; 에 대한 전체 안내서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="1e701db7e6d05f9288626f8d97a85fc554f9593e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about registration for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-registration&quot;&gt;Component Registration&lt;/a&gt;.</source>
          <target state="translated">지금까지 등록에 대해 알아야 할 모든 것이지만,이 페이지를 다 읽은 후 내용에 익숙해지면 나중에 다시 &lt;a href=&quot;components-registration&quot;&gt;구성 요소 등록&lt;/a&gt; 에 대한 전체 안내서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="8e7ac0de9bc7b2393fad83ed8e57aa35094e7cc2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about slots for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-slots&quot;&gt;Slots&lt;/a&gt;.</source>
          <target state="translated">지금까지 슬롯에 대해 알아야 할 모든 것이지만,이 페이지를 다 읽고 내용에 익숙해지면 나중에 돌아와서 &lt;a href=&quot;components-slots&quot;&gt;슬롯&lt;/a&gt; 에 대한 전체 안내서를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6f39b1bdd26be7312e776a774c103e8b83e7cb1a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why for any complex logic, you should use a &lt;strong&gt;computed property&lt;/strong&gt;.</source>
          <target state="translated">그렇기 때문에 복잡한 논리에는 &lt;strong&gt;계산 된 속성을&lt;/strong&gt; 사용해야 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b16487797e90834fa5c92964e14dabbe10606c8" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why instead, we recommend emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, in a hypothetical component with a &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="translated">따라서 &lt;code&gt;update:myPropName&lt;/code&gt; 패턴으로 이벤트를 내보내는 것이 좋습니다 . 예를 들어, &lt;code&gt;title&lt;/code&gt; 소품이 있는 가상의 구성 요소에서 다음과 같이 새 값을 할당하려는 의사를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996c0c7a918cb9833eb237973fce54baee6b3199" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why there&amp;rsquo;s a &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel plugin&lt;/a&gt; to use JSX with Vue, getting us back to a syntax that&amp;rsquo;s closer to templates:</source>
          <target state="translated">그렇기 때문에 Vue와 함께 JSX를 사용 하는 &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel 플러그인&lt;/a&gt; 이있어 템플릿에 더 가까운 구문으로 되돌아 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7c55b719b44c49b49edeaa4e2789ec22bd2ca2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why we offer a full system for rapid Vue.js development. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.</source>
          <target state="translated">우리는 빠른 Vue.js 개발을위한 완전한 시스템을 제공하는 이유입니다. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; 는 Vue 에코 시스템의 표준 툴링 기준이되는 것을 목표로합니다. 다양한 빌드 도구가 합리적인 기본값과 원활하게 작동하도록하여 구성에 시간을 소비하는 대신 앱 작성에 집중할 수 있습니다. 동시에 각 도구의 구성을 특정 요구에 맞게 조정할 수있는 유연성을 여전히 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e8054cccceec827f8cba34b7a1b6bd02a65cd67d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;guide/installation&quot;&gt;Installation&lt;/a&gt; page provides more options of installing Vue. Note: We &lt;strong&gt;do not&lt;/strong&gt; recommend that beginners start with &lt;code&gt;vue-cli&lt;/code&gt;, especially if you are not yet familiar with Node.js-based build tools.</source>
          <target state="translated">&lt;a href=&quot;guide/installation&quot;&gt;설치&lt;/a&gt; 페이지 뷰를 설치하는 더 많은 옵션을 제공합니다. 참고 : 특히 Node.js 기반 빌드 도구에 익숙하지 않은 경우 초보자가 &lt;code&gt;vue-cli&lt;/code&gt; 로 시작 &lt;strong&gt;하지 않는&lt;/strong&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a5ab4cb7708169e37819b6bac8b1dd32c12097a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;pluralize&lt;/a&gt; package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like &lt;code&gt;0&lt;/code&gt;, then you can also easily define your own pluralize functions. For example:</source>
          <target state="translated">NPM 의 &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;복수형&lt;/a&gt; 패키지는이 목적을 훌륭하게 제공하지만 특정 단어 만 복수하거나 &lt;code&gt;0&lt;/code&gt; 과 같은 경우에 대한 특수 출력을 원할 경우 고유 한 복수형 함수를 쉽게 정의 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05878157178d05a4e01a1c89173d306a9458b9ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$route&lt;/code&gt; property is now reactive, so you can use a watcher to react to route changes, like this:</source>
          <target state="translated">&lt;code&gt;$route&lt;/code&gt; 이 같은 경로 변화에 반응하는 감시자을 사용할 수 있도록 속성은, 지금 반응이다 :</target>
        </trans-unit>
        <trans-unit id="26e5d2730ae73e0e0de2df953cf2ee3a5fad3d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; will be the actual link (and will get the correct href), but the active class will be applied to the outer &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 실제 링크 될 것이다 (올바른 HREF를 얻을 것이다), 그러나 액티브 클래스는 외부에 적용될 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c768384d9ec752c708894881ada4881202a8fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will not be visible until the compilation is done.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 컴파일이 완료 될 때까지 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6726c886cd7d1313872ea34b72b56e9373d396cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; component might define a &lt;code&gt;map&lt;/code&gt; property that all subcomponents need access to. In this case &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; might want to access that map with something like &lt;code&gt;this.$parent.getMap&lt;/code&gt;, in order to add a set of markers to it. You can see this pattern &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;in action here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 구성 요소는 정의 할 수 있습니다 &lt;code&gt;map&lt;/code&gt; 모든 하위 구성 요소에 액세스해야한다는 속성을. 이 경우 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 는 마커 세트를 추가하기 위해 &lt;code&gt;this.$parent.getMap&lt;/code&gt; 과 같은 것으로 해당 맵에 액세스하려고 할 수 있습니다. 이 패턴 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;이 실제로 작동하는&lt;/a&gt; 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="780604d1e5198fdcc94939f3a317c58b142346c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of &lt;strong&gt;the &lt;code&gt;v-move&lt;/code&gt; class&lt;/strong&gt;, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided &lt;code&gt;name&lt;/code&gt; attribute and you can also manually specify a class with the &lt;code&gt;move-class&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 요소는 슬리브까지 다른 트릭있다. 그것은 출입을 애니메이션 할 수있을뿐만 아니라 위치가 변경됩니다. 이 기능을 사용하기 위해 알아야 할 유일한 새로운 개념의 추가이다 &lt;strong&gt; &lt;code&gt;v-move&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 클래스&lt;/strong&gt; 항목의 위치를 변경하는 경우에 추가됩니다. 다른 클래스와 마찬가지로 접두어는 제공된 &lt;code&gt;name&lt;/code&gt; 속성 의 값과 일치 하며 &lt;code&gt;move-class&lt;/code&gt; 속성을 사용하여 클래스를 수동으로 지정할 수도 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="606648505385790cf915adeb72e619634753fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.camel&lt;/code&gt; modifier allows camelizing a &lt;code&gt;v-bind&lt;/code&gt; attribute name when using in-DOM templates, e.g. the SVG &lt;code&gt;viewBox&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;.camel&lt;/code&gt; 의 수정은 camelizing 수 있습니다 &lt;code&gt;v-bind&lt;/code&gt; 예 SVG에서-DOM 템플릿을 사용하는 경우 속성 이름을 &lt;code&gt;viewBox&lt;/code&gt; 속성 :</target>
        </trans-unit>
        <trans-unit id="b9f947cb89a1b3d04c28ecc1fa1b5146bc308109" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.exact&lt;/code&gt; modifier allows control of the exact combination of system modifiers needed to trigger an event.</source>
          <target state="translated">&lt;code&gt;.exact&lt;/code&gt; 개질제 이벤트를 트리거하기 위해 필요한 시스템 개질제의 정확한 조합의 제어를 허용한다.</target>
        </trans-unit>
        <trans-unit id="71dc161e02d764cb61bccce7f7216e558eea41ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.literal&lt;/code&gt; modifier has been removed, as the same can be easily achieved by providing a string literal as the value.</source>
          <target state="translated">&lt;code&gt;.literal&lt;/code&gt; 동일한 용이 값 문자열 리터럴을 제공함으로써 달성 될 수있는 개질제가 제거되었다.</target>
        </trans-unit>
        <trans-unit id="447f18c9c1ff6544a5bf8da7ab660de9c45d00c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.passive&lt;/code&gt; modifier is especially useful for improving performance on mobile devices.</source>
          <target state="translated">&lt;code&gt;.passive&lt;/code&gt; 수정은 모바일 기기의 성능을 향상에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="21fd043aec56c5be7446f861bc772ebd8e753810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sync&lt;/code&gt; modifier can also be used with &lt;code&gt;v-bind&lt;/code&gt; when using an object to set multiple props at once:</source>
          <target state="translated">&lt;code&gt;.sync&lt;/code&gt; 를 수정도 함께 사용할 수있는 &lt;code&gt;v-bind&lt;/code&gt; 한번에 여러 소품을 설정하는 것을 목적으로 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="c3321d11e9ef44eba8d358a3614e37323b934b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;events&lt;/code&gt; option has been removed. Event handlers should now be registered in the &lt;code&gt;created&lt;/code&gt; hook instead. Check out the &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt;&lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; migration guide&lt;/a&gt; for a detailed example.</source>
          <target state="translated">&lt;code&gt;events&lt;/code&gt; 옵션이 제거되었습니다. 이벤트 핸들러는 이제 &lt;code&gt;created&lt;/code&gt; 후크에 등록되어야 합니다. 자세한 예 는 &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt; &lt;code&gt;$dispatch&lt;/code&gt; 및 &lt;code&gt;$broadcast&lt;/code&gt; 마이그레이션 안내서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b7c4b5febaa054c2d70f2972911d81840dc234e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-out&lt;/code&gt; mode isn&amp;rsquo;t used as often, but can sometimes be useful for a slightly different transition effect. Let&amp;rsquo;s try combining it with the slide-fade transition we worked on earlier:</source>
          <target state="translated">인 &lt;code&gt;in-out&lt;/code&gt; 모드는 자주 사용되지 않지만 때때로 약간 다른 전환 효과에 유용 할 수 있습니다. 이전에 작업 한 슬라이드 페이드 전환과 결합 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7bb2562df8be00932287fedd76a233d44e708651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</source>
          <target state="translated">은 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 소품 구성 요소 조건부 캐시 할 수 있습니다. 두 소품은 쉼표로 구분 된 문자열, RegExp 또는 배열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd088c8b9dd70d20f540d863e4827655ef4afc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; option should be either:</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt; 옵션 중 하나를해야한다 :</target>
        </trans-unit>
        <trans-unit id="582a8cbd2aa999f85f97f4835ddb07fec729cd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; special attribute is primarily used as a hint for Vue&amp;rsquo;s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 특별한 속성은 주로 기존의 목록에 대해 노드의 새 목록을 diffing의 경우 v- 노드를 식별하기 위해 뷰의 가상 DOM 알고리즘에 대한 힌트로 사용됩니다. 키가 없으면 Vue는 요소 이동을 최소화하고 동일한 유형의 요소를 가능한 한 적절하게 패치 / 재사용하려고하는 알고리즘을 사용합니다. 키를 사용하면 키의 순서 변경에 따라 요소의 순서가 변경되며 더 이상 존재하지 않는 키가있는 요소는 항상 제거 / 파기됩니다.</target>
        </trans-unit>
        <trans-unit id="dc118214d9d96bdcdab86a3dcf6dbc36ea6680a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt; param attributes are now modifiers, to make it more clear what That means instead of:</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; 및 &lt;code&gt;number&lt;/code&gt; PARAM 속성이 더 무엇을 명확하게하기 위해, 지금 수정하는 것을 의미 대신 :</target>
        </trans-unit>
        <trans-unit id="cb26d534e1e0fd7dab034b343fe732f25ec4cdc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mixins&lt;/code&gt; option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in &lt;code&gt;Vue.extend()&lt;/code&gt;. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</source>
          <target state="translated">&lt;code&gt;mixins&lt;/code&gt; 옵션은 믹스 인 객체의 배열을 받아들입니다. 이 믹스 인 객체는 일반 인스턴스 객체와 같은 인스턴스 옵션을 포함 할 수 있으며 &lt;code&gt;Vue.extend()&lt;/code&gt; 에서 동일한 옵션 병합 로직을 사용하여 최종 옵션과 병합 됩니다. 예를 들어 믹스 인에 생성 된 후크가 있고 구성 요소 자체에도 후크가 있으면 두 함수가 모두 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a26f8d5002e995f88abd483d65f2b8981c550aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Reflect.ownKeys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; 옵션은 객체 또는 함수가 반환하는 객체이어야한다. 이 개체에는 하위 항목에 주입 할 수있는 속성이 포함되어 있습니다. ES2015 Symbols를이 객체의 키로 사용할 수 있지만 &lt;code&gt;Symbol&lt;/code&gt; 및 &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 를 기본적으로 지원하는 환경에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1df98a28e225ea8d4b071027515cc8bf9c095a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; options allows us to specify the data/methods we want to &lt;strong&gt;provide&lt;/strong&gt; to descendent components. In this case, that&amp;rsquo;s the &lt;code&gt;getMap&lt;/code&gt; method inside &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">가 &lt;code&gt;provide&lt;/code&gt; 우리가 할 데이터 / 방법을 지정할 수 있도록 옵션을 &lt;strong&gt;제공하는&lt;/strong&gt; 하위 구성 요소를. 이 경우 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 내의 &lt;code&gt;getMap&lt;/code&gt; 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="e89e752e4e0ad59fc71d8c42dbb8b140ac0a0a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; function has priority over the render function compiled from &lt;code&gt;template&lt;/code&gt; option or in-DOM HTML template of the mounting element which is specified by the &lt;code&gt;el&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 기능에서 컴파일 된 렌더링 기능을 통해 우선 순위가 &lt;code&gt;template&lt;/code&gt; 옵션 또는에서-DOM HTML 템플릿에 의해 지정된 장착 요소의 &lt;code&gt;el&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2f312c98cab71695e7dd222c575b78b0d13a0c64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;slot-scope&lt;/code&gt; attribute can also be used directly on a non-&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element (including components):</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; 특성도 비에 직접적으로 사용될 수 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (성분 포함) 소자 :</target>
        </trans-unit>
        <trans-unit id="955152ea21b24fdf404e6e6a60a1465f0de55be9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;true-value&lt;/code&gt; and &lt;code&gt;false-value&lt;/code&gt; attributes don&amp;rsquo;t affect the input&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; attribute, because browsers don&amp;rsquo;t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. &amp;ldquo;yes&amp;rdquo; or &amp;ldquo;no&amp;rdquo;), use radio inputs instead.</source>
          <target state="translated">&lt;code&gt;true-value&lt;/code&gt; 과 &lt;code&gt;false-value&lt;/code&gt; 속성은 입력의 영향을주지 않습니다 &lt;code&gt;value&lt;/code&gt; 브라우저 양식 제출의 검사되지 않은 상자를 포함하지 않기 때문에, 속성을. 두 값 중 하나가 형식 (예 : &quot;예&quot;또는 &quot;아니오&quot;)으로 제출되도록하려면 대신 라디오 입력을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e182f837614c4a38080aad510dbbf2060bfc370d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; can be one of the following native constructors:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 다음과 같은 기본 생성자 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e190ce9f5befbb3426f06af3ed96f5a8aa0969e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-&lt;/code&gt; prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the &lt;code&gt;v-&lt;/code&gt; prefix becomes less important when you are building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, &lt;code&gt;v-bind&lt;/code&gt; and &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-&lt;/code&gt; 접두사는 템플릿에서 뷰 고유의 속성을 식별하는 시각적 역할을합니다. 이는 Vue.js를 사용하여 기존 마크 업에 동적 동작을 적용 할 때 유용하지만 자주 사용되는 지시문에 대해서는 자세하게 느낄 수 있습니다. 동시에 Vue가 모든 템플릿을 관리 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA를&lt;/a&gt; 구축 할 때 &lt;code&gt;v-&lt;/code&gt; 접두사 의 필요성 이 덜 중요해집니다 . 따라서 Vue는 가장 자주 사용되는 지시문 &lt;code&gt;v-bind&lt;/code&gt; 및 &lt;code&gt;v-on&lt;/code&gt; 에 대한 속기입니다 .</target>
        </trans-unit>
        <trans-unit id="cd8461a9f091788550d2bcfcb0e99f3643c233d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-else-if&lt;/code&gt;, as the name suggests, serves as an &amp;ldquo;else if block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;. It can also be chained multiple times:</source>
          <target state="translated">&lt;code&gt;v-else-if&lt;/code&gt; 이름에서 알 수 있듯이,위한 &quot;다른 경우 블록&quot;역할을 &lt;code&gt;v-if&lt;/code&gt; . 여러 번 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6244029a3dc18b6cba09b3e6e0a940180e13b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link-active&lt;/code&gt; directive has also been replaced by the &lt;code&gt;tag&lt;/code&gt; attribute on &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;the &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;. So for example, you&amp;rsquo;ll update this:</source>
          <target state="translated">&lt;code&gt;v-link-active&lt;/code&gt; 지시자는 또한 대체 된 &lt;code&gt;tag&lt;/code&gt; 의 속성 &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 . 예를 들어 다음을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="83d24c44d5fff24f0114d4c306087248f718b001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link&lt;/code&gt; directive has been replaced with a new &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:</source>
          <target state="translated">&lt;code&gt;v-link&lt;/code&gt; 지시어는 새로운 대체되었습니다 &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 구성 요소&lt;/a&gt; 작업의 이런 종류의 지금 뷰 2에서 구성 요소의 단독 책임으로, 당신이 이런 링크가 어디 때마다 수단 :</target>
        </trans-unit>
        <trans-unit id="913c16238f6be321d10c7aa5ede9be4e8848de68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-slot&lt;/code&gt; directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes. The full rationale for introducing &lt;code&gt;v-slot&lt;/code&gt; is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;. The &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</source>
          <target state="translated">&lt;code&gt;v-slot&lt;/code&gt; 지시어는 여전히 지원을 개선, 대체 API를 제공하고, 뷰 2.6.0에 도입 된 &lt;code&gt;slot&lt;/code&gt; 과 &lt;code&gt;slot-scope&lt;/code&gt; 속성. &lt;code&gt;v-slot&lt;/code&gt; 을 도입하기위한 전체 이론적 근거 는이 &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;slot&lt;/code&gt; 과 &lt;code&gt;slot-scope&lt;/code&gt; 속성은 향후 모든 2.x에서의 릴리스에서 계속 지원되지만, 공식적으로 사용되지 않으며 결국 뷰 3에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f371f3394ccbbd9c9c7339bc5a079bc98cf103c4" translate="yes" xml:space="preserve">
          <source>The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; without any build tools before using the CLI.</source>
          <target state="translated">CLI는 Node.js 및 관련 빌드 도구에 대한 사전 지식이 있다고 가정합니다. Vue 또는 프런트 엔드 빌드 도구를 처음 사용하는 경우 CLI를 사용하기 전에 빌드 도구없이 &lt;a href=&quot;../index&quot;&gt;가이드&lt;/a&gt; 를 진행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="431e39681a2982cceb38425ec480f7e168f10ba0" translate="yes" xml:space="preserve">
          <source>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;config options&lt;/a&gt;.</source>
          <target state="translated">CLI는 대부분의 툴링 구성을 관리하지만 자체 &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;구성 옵션을&lt;/a&gt; 통해 세밀한 사용자 정의를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="37e9961ffd2140433ee6300b4c25596bb92249ae" translate="yes" xml:space="preserve">
          <source>The Complete SSR Guide</source>
          <target state="translated">완전한 SSR 가이드</target>
        </trans-unit>
        <trans-unit id="eb35b5bf284498fbba8e557432a08e707e7edef3" translate="yes" xml:space="preserve">
          <source>The Data Object In-Depth</source>
          <target state="translated">심층적 인 데이터 객체</target>
        </trans-unit>
        <trans-unit id="3c531607ce360cbb5aec13ac8c3438a41dc5f330" translate="yes" xml:space="preserve">
          <source>The Virtual DOM</source>
          <target state="translated">가상 DOM</target>
        </trans-unit>
        <trans-unit id="babecbcffc795b2e20d9189e575e0bb731f8cd62" translate="yes" xml:space="preserve">
          <source>The Vue Instance</source>
          <target state="translated">Vue 인스턴스</target>
        </trans-unit>
        <trans-unit id="be83ced5c720e31f43242c0f5e365ad3f2da0751" translate="yes" xml:space="preserve">
          <source>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don&amp;rsquo;t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</source>
          <target state="translated">웹 구성 요소 사양이 완성되었지만 모든 브라우저에서 기본적으로 구현되는 것은 아닙니다. Safari 10.1 이상, Chrome 54 이상 및 Firefox 63 이상은 기본적으로 웹 구성 요소를 지원합니다. 이에 비해 Vue 구성 요소는 폴리 필을 필요로하지 않으며 지원되는 모든 브라우저 (IE9 이상)에서 일관되게 작동합니다. 필요한 경우 Vue 구성 요소를 기본 사용자 정의 요소 안에 감쌀 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a28d4802ae8f29af4f28a606d7b55fd498ccb1b" translate="yes" xml:space="preserve">
          <source>The above code is imperative and repetitive. Compare it with a computed property version:</source>
          <target state="translated">위의 코드는 필수적이고 반복적입니다. 계산 된 속성 버전과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="bb879e483c23bffcd30b4eb818c6b264dd8b31d3" translate="yes" xml:space="preserve">
          <source>The above declarations allow the following code to be compiled:</source>
          <target state="translated">위의 선언을 통해 다음 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57aa3ad596a32aa0ee96ea34ada406c21b66366" translate="yes" xml:space="preserve">
          <source>The above example and some future ones use JavaScript&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template literal&lt;/a&gt; to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;newline escapes&lt;/a&gt; instead.</source>
          <target state="translated">위의 예와 일부 미래의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;예제&lt;/a&gt; 에서는 JavaScript의 템플릿 리터럴 을 사용하여 여러 줄 템플릿을 더 읽기 쉽게 만듭니다. IE (Internet Explorer)에서는 지원되지 않으므로 IE를 지원해야하고 변환하지 않는 경우 (예 : Babel 또는 TypeScript) &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;줄 바꿈 이스케이프를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99a5b0f10fab94bdbe6947c371a61fc4c4300760" translate="yes" xml:space="preserve">
          <source>The above is made possible by Vue&amp;rsquo;s &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; element with the &lt;code&gt;is&lt;/code&gt; special attribute:</source>
          <target state="translated">위는 &lt;code&gt;is&lt;/code&gt; 특수 속성을 가진 Vue의 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 요소에 의해 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="b7374ad3f755708e5dc13a8b4b98839ff8d234e1" translate="yes" xml:space="preserve">
          <source>The above only renders the todos that are not complete.</source>
          <target state="translated">위는 완료되지 않은 할 일만 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="4af7e3e4b79fac718e6fd64e5702254c69dcf11f" translate="yes" xml:space="preserve">
          <source>The above syntax means the presence of the &lt;code&gt;active&lt;/code&gt; class will be determined by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthiness&lt;/a&gt; of the data property &lt;code&gt;isActive&lt;/code&gt;.</source>
          <target state="translated">위의 구문은 &lt;code&gt;active&lt;/code&gt; 클래스 의 존재가 데이터 속성 &lt;code&gt;isActive&lt;/code&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;진실성&lt;/a&gt; 에 의해 결정됨 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="aeec69d6935039bffd444e21fbd1ed7763a7edf9" translate="yes" xml:space="preserve">
          <source>The above will be equivalent to:</source>
          <target state="translated">위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc22dad858f565e9beeefc992c5465134124606c" translate="yes" xml:space="preserve">
          <source>The anchored heading component we created earlier is relatively simple. It doesn&amp;rsquo;t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it&amp;rsquo;s only a function with some props.</source>
          <target state="translated">앞에서 만든 앵커 된 제목 구성 요소는 비교적 간단합니다. 상태를 관리하지 않고 전달 된 상태를 감시하며 수명주기 방법이 없습니다. 실제로는 소품이있는 기능 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="87b9709d9cefabc9cccc6ad0b23e243c50a3cb35" translate="yes" xml:space="preserve">
          <source>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.</source>
          <target state="translated">배열 구문은 객체를 반복 할 때 브라우저에서 동일한 속성 순서를 사용하도록 보장되지 않으므로보다 예측 가능한 경로 일치를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="da3ddd2386065d734a4382298ee4c3e11da253a3" translate="yes" xml:space="preserve">
          <source>The array syntax for &lt;code&gt;v-bind:style&lt;/code&gt; allows you to apply multiple style objects to the same element:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 의 배열 구문을 사용하면 여러 스타일 객체를 동일한 요소에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e823b9beb8c48498f2cf709b4d0756d4d1fc6465" translate="yes" xml:space="preserve">
          <source>The async component factory can also return an object of the following format:</source>
          <target state="translated">비동기 컴포넌트 팩토리는 다음 형식의 오브젝트를 리턴 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba11fc067d05679fdd5921eda5ec20ebd31b1c5d" translate="yes" xml:space="preserve">
          <source>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</source>
          <target state="translated">편집기에서 자동 완성 기능을 사용하면 긴 이름을 쓰는 데 드는 비용이 매우 낮아 지지만 제공하는 명확성은 매우 중요합니다. 특히 드문 약어는 항상 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c22ef1ce4c22f9fdb3192ace8ea666bf31d6a91" translate="yes" xml:space="preserve">
          <source>The bound object doesn&amp;rsquo;t have to be inline:</source>
          <target state="translated">바운드 객체는 인라인 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c473e09bb4188e420d79ebd60ee46d8c65246cf3" translate="yes" xml:space="preserve">
          <source>The component system is another important concept in Vue, because it&amp;rsquo;s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</source>
          <target state="translated">구성 요소 시스템은 Vue에서 또 하나의 중요한 개념으로, 작고 독립적이며 종종 재사용 가능한 구성 요소로 구성된 대규모 응용 프로그램을 구축 할 수있는 추상화이기 때문입니다. 우리가 생각하면 거의 모든 유형의 응용 프로그램 인터페이스를 구성 요소 트리로 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2a227479dfaa2ebe9e09278b1482fab712cafda" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it&amp;rsquo;s usually better to use a &lt;a href=&quot;#computed&quot;&gt;computed property&lt;/a&gt; or &lt;a href=&quot;#watch&quot;&gt;watcher&lt;/a&gt; instead.</source>
          <target state="translated">이 후크가 호출 될 때 구성 요소의 DOM이 업데이트되므로 여기에서 DOM 종속 조작을 수행 할 수 있습니다. 그러나 대부분의 경우 후크 내부의 상태를 변경하지 않아야합니다. 상태 변경에 반응하려면 일반적으로 &lt;a href=&quot;#computed&quot;&gt;계산 된 속성&lt;/a&gt; 이나 &lt;a href=&quot;#watch&quot;&gt;감시자&lt;/a&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="33a9c37f2f9908b2ff6754fe4ced3a3b882e927a" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s name is the first argument of &lt;code&gt;Vue.component&lt;/code&gt;.</source>
          <target state="translated">컴포넌트 이름은 &lt;code&gt;Vue.component&lt;/code&gt; 의 첫 번째 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="6c50d6a412a378e537c001610ef774aa9ae31afc" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;span&lt;/code&gt; will be replaced with the value of the &lt;code&gt;rawHtml&lt;/code&gt; property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use &lt;code&gt;v-html&lt;/code&gt; to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</source>
          <target state="translated">&lt;code&gt;span&lt;/code&gt; 의 내용은 &lt;code&gt;rawHtml&lt;/code&gt; 속성 값으로 대체 되며 일반 HTML로 해석됩니다. 데이터 바인딩은 무시됩니다. Vue는 문자열 기반 템플릿 엔진이 아니기 때문에 &lt;code&gt;v-html&lt;/code&gt; 을 사용 하여 템플릿 부분을 작성할 수 없습니다 . 대신, UI 재사용 및 구성의 기본 단위로 컴포넌트가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="0aabf5563ee74ceaaa562a702ba84f4906e6efaf" translate="yes" xml:space="preserve">
          <source>The custom component &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the &lt;code&gt;is&lt;/code&gt; special attribute offers a workaround:</source>
          <target state="translated">사용자 정의 구성 요소 &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; 가 유효하지 않은 컨텐츠로 표시되어 최종 렌더링 출력에 오류가 발생합니다. 다행히 &lt;code&gt;is&lt;/code&gt; 특수 속성은 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="773dcdb0e4554ae71591d98763ca297e3e508d9e" translate="yes" xml:space="preserve">
          <source>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it &amp;ldquo;reactive&amp;rdquo;. &lt;strong&gt;The object must be plain&lt;/strong&gt;: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</source>
          <target state="translated">Vue 인스턴스의 데이터 객체입니다. Vue는 속성을 getter / setter로 재귀 적으로 변환하여&amp;ldquo;반응 형&amp;rdquo;으로 만듭니다. &lt;strong&gt;객체는 평범해야합니다&lt;/strong&gt; . 브라우저 API 객체 및 프로토 타입 속성과 같은 기본 객체는 무시됩니다. 경험상 데이터는 데이터 일 뿐이라는 점이 있습니다. 자체 상태 저장 방식으로 객체를 관찰하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f249c1e096e4760333b8a1a164e494b46a537f23" translate="yes" xml:space="preserve">
          <source>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</source>
          <target state="translated">Vue 인스턴스가 관찰하는 데이터 객체입니다. Vue 인스턴스는 해당 데이터 객체의 속성에 대한 액세스를 프록시합니다.</target>
        </trans-unit>
        <trans-unit id="536204b9289a091fc1bfb216ea4a0b6805215f8d" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;v-for&lt;/code&gt; will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the &lt;code&gt;key&lt;/code&gt; special attribute:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 의 기본 동작은 요소를 이동하지 않고 제자리에 패치하려고합니다. 요소의 순서를 다시 지정하려면 &lt;code&gt;key&lt;/code&gt; 특수 속성이 포함 된 순서 힌트를 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d129c09e272230c72d4816c9cf37d602f78c6b98" translate="yes" xml:space="preserve">
          <source>The detailed usage for &lt;code&gt;v-for&lt;/code&gt; is explained in the guide section linked below.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 의 자세한 사용법은 아래 링크 된 가이드 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb2400b62e62455e5be23679bc16dcd684f0e97" translate="yes" xml:space="preserve">
          <source>The difference is that an element with &lt;code&gt;v-show&lt;/code&gt; will always be rendered and remain in the DOM; &lt;code&gt;v-show&lt;/code&gt; only toggles the &lt;code&gt;display&lt;/code&gt; CSS property of the element.</source>
          <target state="translated">차이점은 &lt;code&gt;v-show&lt;/code&gt; 를 가진 요소 는 항상 렌더링되고 DOM에 남아 있다는 것입니다. &lt;code&gt;v-show&lt;/code&gt; 는 요소 의 &lt;code&gt;display&lt;/code&gt; CSS 속성 만 토글합니다 .</target>
        </trans-unit>
        <trans-unit id="9beac5c57d068b893c427afee540acec4a448457" translate="yes" xml:space="preserve">
          <source>The direct child components of the current instance. &lt;strong&gt;Note there&amp;rsquo;s no order guarantee for &lt;code&gt;$children&lt;/code&gt;, and it is not reactive.&lt;/strong&gt; If you find yourself trying to use &lt;code&gt;$children&lt;/code&gt; for data binding, consider using an Array and &lt;code&gt;v-for&lt;/code&gt; to generate child components, and use the Array as the source of truth.</source>
          <target state="translated">현재 인스턴스의 직접 하위 구성 요소 &lt;strong&gt; &lt;code&gt;$children&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 대한 주문 보증 은 없으며 반응하지 않습니다. &lt;/strong&gt;데이터 바인딩에 &lt;code&gt;$children&lt;/code&gt; 을 사용하려는 경우 Array 및 &lt;code&gt;v-for&lt;/code&gt; 를 사용하여 자식 구성 요소를 생성하고 Array를 진리의 소스로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8966ad2384af724eb5afaebd84955178e2bef331" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;v-if&lt;/code&gt; is used to conditionally render a block. The block will only be rendered if the directive&amp;rsquo;s expression returns a truthy value.</source>
          <target state="translated">지시문 &lt;code&gt;v-if&lt;/code&gt; 는 조건부로 블록을 렌더링하는 데 사용됩니다. 지시문의 표현식이 정확한 값을 반환하는 경우에만 블록이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a9e1b62f46f6347c3255105bf2f7f7bb4beb980e" translate="yes" xml:space="preserve">
          <source>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the &lt;code&gt;v-html&lt;/code&gt; directive:</source>
          <target state="translated">이중 콧수염은 데이터를 HTML이 아닌 일반 텍스트로 해석합니다. 실제 HTML을 출력하려면 &lt;code&gt;v-html&lt;/code&gt; 지시문 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf9489100840a3b7f6fc331943b5d3351ce62f0" translate="yes" xml:space="preserve">
          <source>The easiest way to pre-compile templates is using &lt;a href=&quot;single-file-components&quot;&gt;Single-File Components&lt;/a&gt; - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</source>
          <target state="translated">템플릿을 사전 컴파일하는 가장 쉬운 방법은 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소를&lt;/a&gt; 사용 하는 것입니다. 관련 빌드 설정이 자동으로 사전 컴파일을 수행하므로 빌드 된 코드에는 원시 템플릿 문자열 대신 이미 컴파일 된 렌더 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="75f9865708d8a06fa846e682702658bdabd9c8e0" translate="yes" xml:space="preserve">
          <source>The easiest way to try out Vue.js is using the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World example&lt;/a&gt;. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;create an &lt;code&gt;index.html&lt;/code&gt; file&lt;/a&gt; and include Vue with:</source>
          <target state="translated">Vue.js를 사용하는 가장 쉬운 방법은 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World 예제를&lt;/a&gt; 사용하는 것 입니다. 다른 탭에서 자유롭게 열고 기본 예제를 진행하면서 따라하십시오. 또는 &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt; &lt;code&gt;index.html&lt;/code&gt; &lt;/a&gt; 파일을 만들고 Vue를 다음과 함께 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="847757f66edc351ea14e3e7f70aa130ed1b67ad7" translate="yes" xml:space="preserve">
          <source>The el option can no longer be used in &lt;code&gt;Vue.extend&lt;/code&gt;. It&amp;rsquo;s only valid as an instance creation option.</source>
          <target state="translated">el 옵션은 더 이상 &lt;code&gt;Vue.extend&lt;/code&gt; 에서 사용할 수 없습니다 . 인스턴스 생성 옵션으로 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="14ff2ebab179926c1bba713b3418f8fa507384ca" translate="yes" xml:space="preserve">
          <source>The filter&amp;rsquo;s function always receives the expression&amp;rsquo;s value (the result of the former chain) as its first argument. In the above example, the &lt;code&gt;capitalize&lt;/code&gt; filter function will receive the value of &lt;code&gt;message&lt;/code&gt; as its argument.</source>
          <target state="translated">필터의 함수는 항상 첫 번째 인수로 표현식 값 (이전 체인의 결과)을받습니다. 위의 예에서 &lt;code&gt;capitalize&lt;/code&gt; 필터 기능은 &lt;code&gt;message&lt;/code&gt; 값을 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="25978631002a6e912099e352f219ba34c4dc10cb" translate="yes" xml:space="preserve">
          <source>The filtered list will &lt;em&gt;only&lt;/em&gt; be re-evaluated if there are relevant changes to the &lt;code&gt;users&lt;/code&gt; array, making filtering much more efficient.</source>
          <target state="translated">필터링 된 목록은 &lt;code&gt;users&lt;/code&gt; 배열에 관련 변경이있는 경우 &lt;em&gt;에만&lt;/em&gt; 다시 평가 되므로 필터링이 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b5951356bec324133fa39def8def2ef7e47b05c1" translate="yes" xml:space="preserve">
          <source>The following template:</source>
          <target state="translated">다음 템플릿 :</target>
        </trans-unit>
        <trans-unit id="6e4a514c82bb3b7baff7919684302ede3370a422" translate="yes" xml:space="preserve">
          <source>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; for a more inspection-friendly interface.</source>
          <target state="translated">게터 / 세터는 사용자에게 보이지 않지만 Vue는 속성에 액세스하거나 수정할 때 Vue가 종속성 추적 및 변경 알림을 수행 할 수 있습니다. 한 가지주의 할 점은 변환 된 데이터 객체가 기록 될 때 브라우저 콘솔이 게터 / 세터를 다르게 포맷한다는 점입니다. 따라서 보다 편리한 인터페이스를 위해 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; 를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd9d811837e0eecf0a4df368877b6262fe04425" translate="yes" xml:space="preserve">
          <source>The implicitly assigned &lt;code&gt;$index&lt;/code&gt; and &lt;code&gt;$key&lt;/code&gt; variables have been removed in favor of explicitly defining them in &lt;code&gt;v-for&lt;/code&gt;. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.</source>
          <target state="translated">암시 적으로 할당 된 &lt;code&gt;$index&lt;/code&gt; 및 &lt;code&gt;$key&lt;/code&gt; 변수는 &lt;code&gt;v-for&lt;/code&gt; 에서 명시 적으로 정의하기 위해 제거되었습니다 . 이를 통해 Vue에 익숙하지 않은 개발자가 코드를보다 쉽게 ​​읽을 수 있으며 중첩 루프를 처리 할 때보다 명확한 동작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd591127230d8deaf3a79ff7072473dcdfb326ef" translate="yes" xml:space="preserve">
          <source>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</source>
          <target state="translated">현재 Vue 인스턴스에 사용 된 인스턴스화 옵션입니다. 옵션에 사용자 정의 속성을 포함하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6507e95ac3123f38dc39170ae522dfbce1786b53" translate="yes" xml:space="preserve">
          <source>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the &lt;code&gt;v-on&lt;/code&gt; attribute isn&amp;rsquo;t feasible. That&amp;rsquo;s why &lt;code&gt;v-on&lt;/code&gt; can also accept the name of a method you&amp;rsquo;d like to call.</source>
          <target state="translated">많은 이벤트 처리기의 논리는 더 복잡하므로 JavaScript를 &lt;code&gt;v-on&lt;/code&gt; 속성 값으로 유지하는 것은 불가능합니다. 따라서 &lt;code&gt;v-on&lt;/code&gt; 은 호출하려는 메소드의 이름을 수락 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7dfd0134284048bc632e36141f4ea3e7333c213" translate="yes" xml:space="preserve">
          <source>The match is first checked on the component&amp;rsquo;s own &lt;code&gt;name&lt;/code&gt; option, then its local registration name (the key in the parent&amp;rsquo;s &lt;code&gt;components&lt;/code&gt; option) if the &lt;code&gt;name&lt;/code&gt; option is not available. Anonymous components cannot be matched against.</source>
          <target state="translated">일치 여부는 먼저 구성 요소 자체 &lt;code&gt;name&lt;/code&gt; 옵션에서 확인한 다음 &lt;code&gt;name&lt;/code&gt; 옵션을 사용할 수없는 경우 로컬 등록 이름 (부모 &lt;code&gt;components&lt;/code&gt; 옵션 의 키 )을 확인하십시오 . 익명 구성 요소는 일치시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6157926048113f46fe23ee578e48fe424291d8e" translate="yes" xml:space="preserve">
          <source>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</source>
          <target state="translated">캐시 할 최대 구성 요소 인스턴스 수입니다. 이 수에 도달하면 가장 최근에 액세스 한 캐시 된 구성 요소 인스턴스는 새 인스턴스를 작성하기 전에 파기됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf10a52fb597971ee2811a4b6daca68eb87e10e" translate="yes" xml:space="preserve">
          <source>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</source>
          <target state="translated">병합 전략은 상위 및 하위 인스턴스에 정의 된 해당 옵션의 값을 각각 첫 번째 및 두 번째 인수로받습니다. 컨텍스트 Vue 인스턴스는 세 번째 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5a003cef802af9e91a6f9747fac2e515359d41" translate="yes" xml:space="preserve">
          <source>The method returns the instance itself so you can chain other instance methods after it.</source>
          <target state="translated">이 메소드는 인스턴스 자체를 리턴하므로 이후에 다른 인스턴스 메소드를 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eb4e33843509639b8c44662beadd21ed8310ed" translate="yes" xml:space="preserve">
          <source>The most basic form of data binding is text interpolation using the &amp;ldquo;Mustache&amp;rdquo; syntax (double curly braces):</source>
          <target state="translated">데이터 바인딩의 가장 기본적인 형태는 &quot;Mustache&quot;구문 (이중 중괄호)을 사용한 텍스트 보간입니다.</target>
        </trans-unit>
        <trans-unit id="bd564c73b6d49eec1b2c8919fa49f3bc33098a11" translate="yes" xml:space="preserve">
          <source>The most common use case is combined with &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">가장 일반적인 사용 사례는 &lt;code&gt;v-for&lt;/code&gt; 와 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="c379b64d918d58c59f406c013a50f15fd94aaa4c" translate="yes" xml:space="preserve">
          <source>The mustache tag will be replaced with the value of the &lt;code&gt;msg&lt;/code&gt; property on the corresponding data object. It will also be updated whenever the data object&amp;rsquo;s &lt;code&gt;msg&lt;/code&gt; property changes.</source>
          <target state="translated">콧수염 태그는 해당 데이터 객체 의 &lt;code&gt;msg&lt;/code&gt; 속성 값으로 대체됩니다 . 또한 데이터 객체의 &lt;code&gt;msg&lt;/code&gt; 속성이 변경 될 때마다 업데이트 됩니다.</target>
        </trans-unit>
        <trans-unit id="37afbe4bcd06f0f0be230e6d8e06d5f57d026a3e" translate="yes" xml:space="preserve">
          <source>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or &lt;a href=&quot;single-file-components&quot;&gt;single-file component&lt;/a&gt;), we strongly recommend following the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C rules&lt;/a&gt; for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</source>
          <target state="translated">구성 요소 이름은 사용하려는 위치에 따라 다를 수 있습니다. 문자열 템플릿 또는 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 와 달리 DOM에서 구성 요소를 직접 사용하는 경우 사용자 정의 태그 이름 (모두 소문자, 하이픈을 포함해야 함)에 대해 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C 규칙&lt;/a&gt; 을 따르는 것이 좋습니다 . 이를 통해 현재 및 미래의 HTML 요소와의 충돌을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49544b57b4faf031cbd490df14c62342f8913c7c" translate="yes" xml:space="preserve">
          <source>The new, more concise way to configure &lt;code&gt;keyCodes&lt;/code&gt; is through &lt;code&gt;Vue.config.keyCodes&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;keyCodes&lt;/code&gt; 를 구성하는 새롭고 간결한 방법 은 &lt;code&gt;Vue.config.keyCodes&lt;/code&gt; 를 사용하는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ba4a8191026a27a782703cf2cb8992c45a25eab" translate="yes" xml:space="preserve">
          <source>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the &lt;code&gt;props&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt; initialization.</source>
          <target state="translated">다음 2 개의 예제는 Vue 2.2.1+에서 작동합니다. 해당 버전 아래에서 &lt;code&gt;props&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 초기화 후에 주입 된 값이 해결되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c4e0ddfdd8217a03837dee9d518c520c1cff551b" translate="yes" xml:space="preserve">
          <source>The next thing you&amp;rsquo;ll have to become familiar with is how to use template features in the &lt;code&gt;createElement&lt;/code&gt; function. Here are the arguments that &lt;code&gt;createElement&lt;/code&gt; accepts:</source>
          <target state="translated">다음으로 익숙해 져야 할 것은 &lt;code&gt;createElement&lt;/code&gt; 함수 에서 템플릿 기능을 사용하는 방법 입니다. &lt;code&gt;createElement&lt;/code&gt; 가 허용 하는 인수는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a93809e131de1acb92c27480b98ade7c8b177368" translate="yes" xml:space="preserve">
          <source>The object syntax for &lt;code&gt;v-bind:style&lt;/code&gt; is pretty straightforward - it looks almost like CSS, except it&amp;rsquo;s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 의 객체 구문 은 매우 간단합니다. JavaScript 객체 인 경우를 제외하고는 CSS와 거의 같습니다. CSS 속성 이름에 camelCase 또는 kebab-case (케밥 케이스와 함께 따옴표 사용)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f804d7c199bb60087ee99a4d2ed2841ff111fad8" translate="yes" xml:space="preserve">
          <source>The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</source>
          <target state="translated">공식 안내서는 HTML, CSS 및 JavaScript에 대한 중간 수준의 지식을 전제로합니다. 프론트 엔드 개발에 완전히 익숙하지 않다면 첫 번째 단계로 프레임 워크로 바로 들어가는 것이 가장 좋은 아이디어는 아닙니다. 기본 사항을 파악한 다음 다시 방문하십시오! 다른 프레임 워크에 대한 사전 경험이 도움이되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cdcd3cc5d3cb2f01160d1290fc4a6159e0dddd79" translate="yes" xml:space="preserve">
          <source>The only exception to this being the use of &lt;code&gt;Object.freeze()&lt;/code&gt;, which prevents existing properties from being changed, which also means the reactivity system can&amp;rsquo;t &lt;em&gt;track&lt;/em&gt; changes.</source>
          <target state="translated">이것에 대한 유일한 예외는 &lt;code&gt;Object.freeze()&lt;/code&gt; 의 사용으로 기존 속성이 변경되는 것을 방지하며 반응성 시스템이 변경 사항을 &lt;em&gt;추적&lt;/em&gt; 할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="8eb7f5feed0a750d304ea8614d2edca774bd3f41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;scoped&lt;/code&gt; attribute automatically scopes this CSS to your component by adding a unique attribute (such as &lt;code&gt;data-v-21e5b78&lt;/code&gt;) to elements and compiling &lt;code&gt;.list-container:hover&lt;/code&gt; to something like &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;scoped&lt;/code&gt; 속성은 요소에 고유 한 속성 (예 : &lt;code&gt;data-v-21e5b78&lt;/code&gt; )을 추가하고 &lt;code&gt;.list-container:hover&lt;/code&gt; 를 &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt; 와 같은 것으로 컴파일 하여이 CSS를 구성 요소에 자동으로 적용 합니다 . 호버 .</target>
        </trans-unit>
        <trans-unit id="8f86e91201591c3c1631acf2b2475e6e451afce5" translate="yes" xml:space="preserve">
          <source>The parent instance, if the current instance has one.</source>
          <target state="translated">현재 인스턴스에 상위 인스턴스가있는 경우 상위 인스턴스</target>
        </trans-unit>
        <trans-unit id="a213359cc7f926ecae5256c14d1f382a33b06e44" translate="yes" xml:space="preserve">
          <source>The problem is event flows that depend on a component&amp;rsquo;s tree structure can be hard to reason about and are very brittle when the tree becomes large. They don&amp;rsquo;t scale well and only set you up for pain later. &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; also do not solve communication between sibling components.</source>
          <target state="translated">문제는 구성 요소의 트리 구조에 의존하는 이벤트 흐름으로 인해 추론하기가 어려울 수 있으며 트리가 커지면 취하기가 매우 어렵다는 것입니다. 그들은 잘 확장되지 않으며 나중에 고통을 위해 당신을 설정합니다. &lt;code&gt;$dispatch&lt;/code&gt; 및 &lt;code&gt;$broadcast&lt;/code&gt; 도 형제 구성 요소 간의 통신을 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98399a72800d5002678971cac53da1533e26a6d2" translate="yes" xml:space="preserve">
          <source>The problem is that large numbers of &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;element-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;) will be considerably slower than &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;class-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt;), so class selectors should be preferred whenever possible.</source>
          <target state="translated">문제는 많은 수의 &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;요소 속성 선택기&lt;/a&gt; (예 : &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; )가 &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;클래스 속성 선택기&lt;/a&gt; (예 : &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt; ) 보다 상당히 느리기 때문에 클래스 선택기는 가능할 때마다 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="3bc4b51815e1ca75817d438f9a75b79de4143526" translate="yes" xml:space="preserve">
          <source>The problem is, there are also many &lt;em&gt;simple&lt;/em&gt; cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</source>
          <target state="translated">문제는 이러한 패턴이 편의를 제공 할 수있는 &lt;em&gt;간단한&lt;/em&gt; 경우 도 많다는 것 입니다. 주의 : 단기적인 편의 (코드를 적게 작성)를 위해 거래의 단순성 (국가의 흐름을 이해할 수 있음)에 빠지지 마십시오.</target>
        </trans-unit>
        <trans-unit id="690eaa8b769a27585770a32b044820cae46112dd" translate="yes" xml:space="preserve">
          <source>The problem is, there are cases where it&amp;rsquo;s important not to delete elements that will remain in the DOM. For example, you may want to use &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; to animate list sorting, or maintain focus if the rendered element is an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In these cases, adding a unique key for each item (e.g. &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt;) will tell Vue how to behave more predictably.</source>
          <target state="translated">문제는 DOM에 남아있는 요소를 삭제하지 않는 것이 중요한 경우입니다. 예를 들어 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 을 사용하여 목록 정렬에 애니메이션을 적용하거나 렌더링 된 요소가 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 인 경우 포커스를 유지 하려고 할 수 있습니다 . 이 경우 각 항목에 고유 한 키를 추가하면 (예 &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt; ) Vue 에보다 예측 가능한 동작 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="35549fb2854bdbc4b65652d62df1f1ddfa7a99ea" translate="yes" xml:space="preserve">
          <source>The problem is, this button doesn&amp;rsquo;t do anything:</source>
          <target state="translated">문제는이 버튼이 아무것도하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="361cd98689630fb5a124f5e83b5f388af1b8a1f3" translate="yes" xml:space="preserve">
          <source>The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 요소는 단순히 장착 지점 역할을합니다. Vue 1.x와 달리 마운트 된 요소는 모든 경우에 Vue 생성 DOM으로 대체됩니다. 따라서 루트 인스턴스를 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 에 마운트하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="34592f5fd4a2054ce0011f9d4e26a9c654b6f7b5" translate="yes" xml:space="preserve">
          <source>The reason for not automatically injecting &lt;code&gt;item&lt;/code&gt; into the component is because that makes the component tightly coupled to how &lt;code&gt;v-for&lt;/code&gt; works. Being explicit about where its data comes from makes the component reusable in other situations.</source>
          <target state="translated">구성 요소에 &lt;code&gt;item&lt;/code&gt; 을 자동으로 주입하지 않는 이유 는 구성 요소가 &lt;code&gt;v-for&lt;/code&gt; 작동 방식과 밀접하게 연결되기 때문입니다 . 데이터의 출처를 명시 적으로 지정하면 다른 상황에서 컴포넌트를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532c908704eacdd705ddb6c7847a0bd40253f67" translate="yes" xml:space="preserve">
          <source>The reason is this is the equivalent JavaScript that the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; would compile to:</source>
          <target state="translated">그 이유는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 이 다음과 같이 컴파일 하는 JavaScript와 동일 하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="78702fdec5c6b73fa78a98283262c3e3a610ea89" translate="yes" xml:space="preserve">
          <source>The reference will be HTMLElement when used with functional components because they&amp;rsquo;re stateless and instanceless.</source>
          <target state="translated">함수형 구성 요소와 함께 사용하면 상태가없고 인스턴스가 없으므로 HTMLElement가 참조가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c42bbffd6116ac9f9aa2c29f718360da13a0c7" translate="yes" xml:space="preserve">
          <source>The rendered HTML will be:</source>
          <target state="translated">렌더링 된 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a426ede2112c009fbf616db449e0c6e3bc884e8e" translate="yes" xml:space="preserve">
          <source>The result is that many components may include long lists of base components:</source>
          <target state="translated">결과적으로 많은 구성 요소가 기본 구성 요소의 긴 목록을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0894c1243efd2b6757cc56c901b4af230a9aac04" translate="yes" xml:space="preserve">
          <source>The returned object can be used directly inside &lt;a href=&quot;../guide/render-function&quot;&gt;render functions&lt;/a&gt; and &lt;a href=&quot;../guide/computed&quot;&gt;computed properties&lt;/a&gt;, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;../guide/render-function&quot;&gt;렌더 함수&lt;/a&gt; 및 &lt;a href=&quot;../guide/computed&quot;&gt;계산 된 속성&lt;/a&gt; 내에서 직접 사용할 수 있으며 변경시 적절한 업데이트를 트리거합니다. 간단한 시나리오를 위해 최소한의 컴포넌트 간 상태 저장소로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5f2182d5b9e1141097f081f69203ed474e7f51a" translate="yes" xml:space="preserve">
          <source>The root DOM element that the Vue instance is managing.</source>
          <target state="translated">Vue 인스턴스가 관리하는 루트 DOM 요소입니다.</target>
        </trans-unit>
        <trans-unit id="1fb1fe84422a22a87a20ac9a9db7f5aca1ce36fc" translate="yes" xml:space="preserve">
          <source>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</source>
          <target state="translated">현재 컴포넌트 트리의 루트 Vue 인스턴스. 현재 인스턴스에 부모가 없으면이 값 자체가됩니다.</target>
        </trans-unit>
        <trans-unit id="7b232ff8c5c18691a5df8efcbaf774a1cbaab836" translate="yes" xml:space="preserve">
          <source>The same is true for class bindings:</source>
          <target state="translated">클래스 바인딩의 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="dd2c503caba50c997d7446df74ac0da742e9b8eb" translate="yes" xml:space="preserve">
          <source>The size of your app (small to medium-sized apps will probably be less than a day)</source>
          <target state="translated">앱의 크기 (중소형 앱은 하루 미만일 수 있음)</target>
        </trans-unit>
        <trans-unit id="71c2733bfb43f78b87500262cd44c42870815508" translate="yes" xml:space="preserve">
          <source>The special case to note here is the &lt;code&gt;data&lt;/code&gt; option - it must be a function when used with &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">여기서 주목할 특별한 경우는 &lt;code&gt;data&lt;/code&gt; 옵션 입니다. &lt;code&gt;Vue.extend()&lt;/code&gt; 와 함께 사용할 때 함수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="572f57cb3c88ad0c0b5d74b281c1e800b18bf5b8" translate="yes" xml:space="preserve">
          <source>The store instance no longer exposes the event emitter interface (&lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;emit&lt;/code&gt;). If you were previously using the store as a global event bus, &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;see this section&lt;/a&gt; for migration instructions.</source>
          <target state="translated">상점 인스턴스는 더 이상 이벤트 이미 터 인터페이스를 노출하지 않습니다 ( &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;emit&lt;/code&gt; ). 이전에 상점을 글로벌 이벤트 버스로 사용한 경우 이주 지시 사항에 &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;대해서는이 섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77d67a6f8225d0df00a5fc5a901f8f424ef25e4a" translate="yes" xml:space="preserve">
          <source>The syntax has changed slightly, so &lt;code&gt;/category/*tags&lt;/code&gt; for example, should be updated to &lt;code&gt;/category/:tags+&lt;/code&gt;.</source>
          <target state="translated">구문이 약간 변경되었으므로 예를 들어 &lt;code&gt;/category/*tags&lt;/code&gt; 는 &lt;code&gt;/category/:tags+&lt;/code&gt; 로 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="908884184f3cb4e8612386879bc128af52d0df9c" translate="yes" xml:space="preserve">
          <source>The target object cannot be a Vue instance, or the root data object of a Vue instance.</source>
          <target state="translated">대상 객체는 Vue 인스턴스이거나 Vue 인스턴스의 루트 데이터 객체 일 수 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
