<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3b52d24461e93aad361aa8a10329f3c23cc49031" translate="yes" xml:space="preserve">
          <source>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what&amp;rsquo;s currently available for Vue templates.</source>
          <target state="translated">JSX에 대한 툴링 지원 (예 : 보푸라기, 형식 확인, 편집기 자동 완성)은 현재 Vue 템플릿에서 사용할 수있는 것보다 훨씬 고급입니다.</target>
        </trans-unit>
        <trans-unit id="da2a622928cb7fb2119351d71d4d29385b2f0b02" translate="yes" xml:space="preserve">
          <source>The tree of DOM nodes for the HTML above looks like this:</source>
          <target state="translated">위의 HTML에 대한 DOM 노드 트리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e0938b17616f7c664547dd22e0644ffdf02a08b" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;keyCode&lt;/code&gt; events &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;is deprecated&lt;/a&gt; and may not be supported in new browsers.</source>
          <target state="translated">의 사용 &lt;code&gt;keyCode&lt;/code&gt; 이벤트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;사용되지 않으며&lt;/a&gt; 새로운 브라우저에서 지원되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c973f4080ca50bd81b6cff2d0a6ded9905288da4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;slot-scope&lt;/code&gt; can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;) you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; in the expression, like so:</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; 의 값은 함수 정의의 인수 위치에 나타날 수있는 유효한 JavaScript 표현식을 허용 할 수 있습니다. 이는 지원되는 환경 ( &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;최신 브라우저&lt;/a&gt; ) 에서 다음과 같이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 구조화를&lt;/a&gt; 표현식에서 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="44c95331b851049a94d5aa5d023b6e2ddaca60d8" translate="yes" xml:space="preserve">
          <source>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</source>
          <target state="translated">해결 방법은 공백이나 따옴표없이 표현식을 사용하거나 복잡한 표현식을 계산 된 속성으로 바꾸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d02680275f323eda2de9d2d7078001372e594964" translate="yes" xml:space="preserve">
          <source>Their names often include the name of an element they wrap (e.g. &lt;code&gt;BaseButton&lt;/code&gt;, &lt;code&gt;BaseTable&lt;/code&gt;), unless no element exists for their specific purpose (e.g. &lt;code&gt;BaseIcon&lt;/code&gt;). If you build similar components for a more specific context, they will almost always consume these components (e.g. &lt;code&gt;BaseButton&lt;/code&gt; may be used in &lt;code&gt;ButtonSubmit&lt;/code&gt;).</source>
          <target state="translated">특정 목적을위한 요소가없는 경우 (예 : &lt;code&gt;BaseIcon&lt;/code&gt; ) 가 아닌 한 , 이름에는 줄 바꿈하는 요소의 이름 (예 : &lt;code&gt;BaseButton&lt;/code&gt; , &lt;code&gt;BaseTable&lt;/code&gt; )이 포함됩니다 . 보다 구체적인 컨텍스트를 위해 유사한 구성 요소를 작성하면 거의 항상 이러한 구성 요소를 사용합니다 (예 : &lt;code&gt;ButtonSubmit&lt;/code&gt; 에서 &lt;code&gt;BaseButton&lt;/code&gt; 이 사용될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="cac8885ec5589429c1668b6076e0b655b65a0072" translate="yes" xml:space="preserve">
          <source>Then a &lt;code&gt;tree-folder-contents&lt;/code&gt; component with this template:</source>
          <target state="translated">그런 다음 이 템플릿이 포함 된 &lt;code&gt;tree-folder-contents&lt;/code&gt; 컴포넌트 :</target>
        </trans-unit>
        <trans-unit id="12ff53d6c9683fe8bc4c3c3ebe06eaf2daa8b2b3" translate="yes" xml:space="preserve">
          <source>Then add some classes when using it:</source>
          <target state="translated">그런 다음 사용할 때 몇 가지 클래스를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="bdb3d0b6c8743a01fad092b8628997433e226d02" translate="yes" xml:space="preserve">
          <source>Then changes to &lt;code&gt;b&lt;/code&gt; will not trigger any view updates. If you know you&amp;rsquo;ll need a property later, but it starts out empty or non-existent, you&amp;rsquo;ll need to set some initial value. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;b&lt;/code&gt; 로 변경 하면 뷰 업데이트가 트리거되지 않습니다. 나중에 속성이 필요하지만 비어 있거나 존재하지 않는 속성으로 시작하는 경우 초기 값을 설정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d716ba19ef13983399aba7a4f9b4f99bdb1a5cc3" translate="yes" xml:space="preserve">
          <source>Then define the components you&amp;rsquo;d like to use in a &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="translated">그런 다음 &lt;code&gt;components&lt;/code&gt; 옵션 에 사용하려는 구성 요소를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="89b993f413d7a3516733e84da6538330a9b561e6" translate="yes" xml:space="preserve">
          <source>Then import the component options along with Vue, and you can make many common assertions (here we are using Jasmine/Jest style &lt;code&gt;expect&lt;/code&gt; assertions just as an example):</source>
          <target state="translated">그런 다음 뷰와 함께 구성 요소 옵션을 가져, 당신은 (우리는 재스민 / 농담 스타일을 사용하여 여기에 많은 일반적인 주장을 할 수 있습니다 &lt;code&gt;expect&lt;/code&gt; 단지 예를 들어 주장) :</target>
        </trans-unit>
        <trans-unit id="742a07eca2247a701f3fe69d736358f9945a7047" translate="yes" xml:space="preserve">
          <source>Then in a template, you can use the new &lt;code&gt;v-focus&lt;/code&gt; attribute on any element, like this:</source>
          <target state="translated">그런 다음 템플릿에서 다음 과 같이 모든 요소에 새로운 &lt;code&gt;v-focus&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d651621f023beec6364c642e7684b35f30f1b1df" translate="yes" xml:space="preserve">
          <source>Then in any descendants, we can use the &lt;code&gt;inject&lt;/code&gt; option to receive specific properties we&amp;rsquo;d like to add to that instance:</source>
          <target state="translated">그런 다음 모든 하위 항목에서 &lt;code&gt;inject&lt;/code&gt; 옵션을 사용하여 해당 인스턴스에 추가하려는 특정 속성을 수신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07a1a769eabe4ce95fd548704bfe1a9036dff3fe" translate="yes" xml:space="preserve">
          <source>Then in our components, we can use &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; to emit events, listen for events, and clean up event listeners, respectively:</source>
          <target state="translated">그런 다음 컴포넌트에서 &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; , &lt;code&gt;$off&lt;/code&gt; 를 사용하여 이벤트를 생성하고 이벤트를 청취하고 이벤트 리스너를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a24c495cff3ba785929f2d1f1232971575aecc" translate="yes" xml:space="preserve">
          <source>Then in the template for &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;, you might have:</source>
          <target state="translated">그런 다음 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 의 템플리트에 다음 이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c17e2b180b30e57b025d1baba4010bf150e5ff" translate="yes" xml:space="preserve">
          <source>Then inside &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; you might find yourself reaching for a hack like this:</source>
          <target state="translated">그런 다음 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 에서 다음과 같이 해킹에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb73bd95447c7f774f020d38dc4e977b5d7f966" translate="yes" xml:space="preserve">
          <source>Then switching the &lt;code&gt;loginType&lt;/code&gt; in the code above will not erase what the user has already entered. Since both templates use the same elements, the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; is not replaced - just its &lt;code&gt;placeholder&lt;/code&gt;.</source>
          <target state="translated">그런 다음 위 코드 에서 &lt;code&gt;loginType&lt;/code&gt; 을 전환 해도 사용자가 이미 입력 한 내용은 지워지지 않습니다. 두 템플릿 모두 동일한 요소를 사용하므로 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 은 &lt;code&gt;placeholder&lt;/code&gt; 대신 대체되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6afded1525a7e22ff2f90a6400204ea03039f331" translate="yes" xml:space="preserve">
          <source>Then the child component can emit an event on itself by calling the built-in &lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; method&lt;/a&gt;, passing the name of the event:</source>
          <target state="translated">그런 다음 자식 구성 요소는 내장 된 &lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt; &lt;code&gt;$emit&lt;/code&gt; &lt;/strong&gt; 메서드&lt;/a&gt; 를 호출 하고 이벤트 이름을 전달하여 자체적으로 이벤트를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa6a05a02bb2743e63986fe5978b02e07581ae91" translate="yes" xml:space="preserve">
          <source>Then the parent can listen to that event and update a local data property, if it wants to. For example:</source>
          <target state="translated">그런 다음 부모는 해당 이벤트를 수신하고 원하는 경우 로컬 데이터 속성을 업데이트 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a4b4fbfbeb2382afaa428f3aa7171b1ee657214" translate="yes" xml:space="preserve">
          <source>Then the provided content will be rendered instead:</source>
          <target state="translated">제공된 컨텐츠가 대신 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="894b33adf4423b8e17178e298c582eff7b692b2f" translate="yes" xml:space="preserve">
          <source>Then the value will be passed as the first parameter of that method:</source>
          <target state="translated">그런 다음 해당 메소드의 첫 번째 매개 변수로 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e40f0a46552f37df14dd5aec3ff5064babdeaea5" translate="yes" xml:space="preserve">
          <source>Then want to render a component for each one:</source>
          <target state="translated">그런 다음 각 구성 요소에 대한 구성 요소를 렌더링하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e77b5195b094315391d1471e49e775352de3ff46" translate="yes" xml:space="preserve">
          <source>Then when later accessing this property on a route, you will still go through meta. For example:</source>
          <target state="translated">그런 다음 나중에 경로에서이 속성에 액세스 할 때 여전히 메타를 거치게됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db6fb96dd889a51b383d80ca6045c8aa43c69291" translate="yes" xml:space="preserve">
          <source>Then when we listen to the event in the parent, we can access the emitted event&amp;rsquo;s value with &lt;code&gt;$event&lt;/code&gt;:</source>
          <target state="translated">그런 다음 부모의 이벤트를들을 때 &lt;code&gt;$event&lt;/code&gt; 된 이벤트 값에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb930daa712d8e2eb8fe97e59c6f27531e9b1c3e" translate="yes" xml:space="preserve">
          <source>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.</source>
          <target state="translated">그런 다음 Vue 코드 작성을 시작하고 죄책감을 느끼거나 성능 문제에 대해 걱정할 필요없이 축소 된 버전을 프로덕션에 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebf3c9e7f553f2151cca31494ec2e2f25d6a17ab" translate="yes" xml:space="preserve">
          <source>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</source>
          <target state="translated">그런 다음 알파벳순으로 정렬합니다. DOM을 업데이트 할 때 Vue는 렌더링을 최적화하여 가능한 가장 저렴한 DOM 변이를 수행합니다. 이는 첫 번째 todo 요소를 삭제 한 다음 목록 끝에 다시 추가하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="60891cf748e8a5cfa058d96629753adac1a276a6" translate="yes" xml:space="preserve">
          <source>Then you would now update it to:</source>
          <target state="translated">그런 다음 이제 다음과 같이 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="29dfab044dfc1294ff91b939dd91ab9260db5d9f" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll need to import each component you&amp;rsquo;d like to use, before you locally register it. For example, in a hypothetical &lt;code&gt;ComponentB.js&lt;/code&gt; or &lt;code&gt;ComponentB.vue&lt;/code&gt; file:</source>
          <target state="translated">그런 다음 로컬에 등록하기 전에 사용하려는 각 구성 요소를 가져와야합니다. 예를 들어, 가상의 &lt;code&gt;ComponentB.js&lt;/code&gt; 또는 &lt;code&gt;ComponentB.vue&lt;/code&gt; 파일에서 :</target>
        </trans-unit>
        <trans-unit id="4a02df39977359aa3a054dc03aa4a5ab9829f85e" translate="yes" xml:space="preserve">
          <source>There also seem to be philosophical differences in the API design which if you&amp;rsquo;re curious, can be demonstrated by how each handles the creation of a &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;simple todo list&lt;/a&gt;. It&amp;rsquo;s definitely somewhat subjective, but many consider Vue&amp;rsquo;s API to be less complex and better structured.</source>
          <target state="translated">API 디자인에는 철학적 차이가있는 것 같습니다. 궁금한 점이 있다면 각각이 &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;간단한 할 일 목록&lt;/a&gt; 의 생성을 처리하는 방법으로 설명 할 수 있습니다 . 분명히 다소 주관적이지만 많은 사람들이 Vue의 API가 덜 복잡하고 구조화되어 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="00ee1410ff14873dae0595e837c501a60becd79c" translate="yes" xml:space="preserve">
          <source>There are a few advantages:</source>
          <target state="translated">몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a278039d12ee8bace65331079237ab972774e0f6" translate="yes" xml:space="preserve">
          <source>There are also a few array-related caveats, which were discussed earlier in the &lt;a href=&quot;list#Caveats&quot;&gt;list rendering section&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;list#Caveats&quot;&gt;리스트 렌더링 섹션&lt;/a&gt; 에서 앞서 논의한 몇 가지 배열 관련주의 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8355a914d86b23056657ff75f59f4f4811dbbe1e" translate="yes" xml:space="preserve">
          <source>There are also other hooks which will be called at different stages of the instance&amp;rsquo;s lifecycle, such as &lt;a href=&quot;../api/index#mounted&quot;&gt;&lt;code&gt;mounted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#updated&quot;&gt;&lt;code&gt;updated&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt;. All lifecycle hooks are called with their &lt;code&gt;this&lt;/code&gt; context pointing to the Vue instance invoking it.</source>
          <target state="translated">또한 &lt;a href=&quot;../api/index#mounted&quot;&gt; &lt;code&gt;mounted&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#updated&quot;&gt; &lt;code&gt;updated&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; 과 같이 인스턴스 수명주기의 여러 단계에서 호출 될 다른 후크도 있습니다 . 모든 수명주기 후크는 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 호출하는 Vue 인스턴스를 가리키는 상태로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="595e87e7a707cb9f54dea4bd06abe43f491c5b96" translate="yes" xml:space="preserve">
          <source>There are cases however, particularly shared component libraries, when this &lt;em&gt;might&lt;/em&gt; be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</source>
          <target state="translated">그러나 이것이 적절할 경우 특히 공유 구성 요소 라이브러리 &lt;em&gt;가&lt;/em&gt; 있는 경우 &lt;em&gt;가&lt;/em&gt; 있습니다. 예를 들어, 가상 Google지도 구성 요소와 같이 HTML을 렌더링하는 대신 JavaScript API와 상호 작용하는 추상 구성 요소에서 :</target>
        </trans-unit>
        <trans-unit id="3876196be292a6f75aaef350c2cf3fa6064ad6ee" translate="yes" xml:space="preserve">
          <source>There are cases when it&amp;rsquo;s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">슬롯에 폴백 (즉, 기본) 컨텐츠를 지정하는 것이 유용한 경우에는 컨텐츠가 제공되지 않을 때만 렌더링됩니다. 예를 들어 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 구성 요소에서</target>
        </trans-unit>
        <trans-unit id="b097d3f1a1272b7a886d701f8e65981ad1d92968" translate="yes" xml:space="preserve">
          <source>There are quite a few other directives, each with its own special functionality. For example, the &lt;code&gt;v-for&lt;/code&gt; directive can be used for displaying a list of items using the data from an Array:</source>
          <target state="translated">각각 고유 한 기능을 가진 다른 지시어도 있습니다. 예를 들어, &lt;code&gt;v-for&lt;/code&gt; 지시문은 Array의 데이터를 사용하여 항목 목록을 표시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="301d312bbcc93ad24cc77d82516195cad4b40d9a" translate="yes" xml:space="preserve">
          <source>There are six classes applied for enter/leave transitions.</source>
          <target state="translated">진입 / 이탈 전환에는 6 가지 클래스가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="68ec2c8ded7b22cd2bc4c88259f22e650546ce9b" translate="yes" xml:space="preserve">
          <source>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the &lt;code&gt;data&lt;/code&gt; object is like the schema for your component&amp;rsquo;s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</source>
          <target state="translated">이 제한에는 기술적 인 이유가 있습니다. 이는 종속성 추적 시스템에서 엣지 케이스를 제거하고 Vue 인스턴스를 유형 검사 시스템에서 더 잘 재생하도록합니다. 그러나 코드 유지 관리 측면에서 중요한 고려 사항이 있습니다. &lt;code&gt;data&lt;/code&gt; 개체는 구성 요소의 상태에 대한 스키마와 같습니다. 모든 반응 속성을 미리 선언하면 나중에 다시 방문하거나 다른 개발자가 읽을 때 구성 요소 코드를 더 쉽게 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db30e092cad90bed9c249d97be67dad62ff063c2" translate="yes" xml:space="preserve">
          <source>There are times when it&amp;rsquo;s useful to have multiple slots. For example, in a &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">여러 개의 슬롯을 갖는 것이 유용한 경우가 있습니다. 예를 들어 다음 템플릿이 있는 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 구성 요소에서</target>
        </trans-unit>
        <trans-unit id="d66a662b2b692933bc8923306e3e5688421626cb" translate="yes" xml:space="preserve">
          <source>There are two common cases where this can be tempting:</source>
          <target state="translated">이것이 유혹 될 수있는 두 가지 일반적인 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be534cacf73464a26b8c69ecc68abf4cebc095f" translate="yes" xml:space="preserve">
          <source>There are usually two cases where it&amp;rsquo;s tempting to mutate a prop:</source>
          <target state="translated">소품을 변경하려는 유혹이있는 경우는 보통 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a46df346eecefc8c5696a405d0623a7868c6f68" translate="yes" xml:space="preserve">
          <source>There can still be one unnamed slot, which is the &lt;strong&gt;default slot&lt;/strong&gt; that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</source>
          <target state="translated">이름이 지정되지 않은 슬롯이 여전히 존재할 수 있는데, 이는 일치하지 않는 컨텐츠에 대한 포괄 역할을하는 &lt;strong&gt;기본 슬롯&lt;/strong&gt; 입니다. 위의 두 예제에서 렌더링 된 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="892e9605b3eb99a1e8758152c0f0d14bd50018ba" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;vm.$nextTick()&lt;/code&gt; instance method, which is especially handy inside components, because it doesn&amp;rsquo;t need global &lt;code&gt;Vue&lt;/code&gt; and its callback&amp;rsquo;s &lt;code&gt;this&lt;/code&gt; context will be automatically bound to the current Vue instance:</source>
          <target state="translated">도있다 &lt;code&gt;vm.$nextTick()&lt;/code&gt; 특히 편리한 내부의 구성 요소 인 인스턴스 메소드, 그것은 글로벌 필요가 없기 때문에 &lt;code&gt;Vue&lt;/code&gt; 하고 콜백의 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 자동으로 현재 뷰 인스턴스에 바인딩됩니다</target>
        </trans-unit>
        <trans-unit id="e795677faa92646e68896f4fa2d153d1c6b3dad9" translate="yes" xml:space="preserve">
          <source>There is no direct &lt;code&gt;v-model&lt;/code&gt; counterpart in render functions - you will have to implement the logic yourself:</source>
          <target state="translated">렌더 함수 에는 직접적인 &lt;code&gt;v-model&lt;/code&gt; 대응 물 이 없으므로 직접 로직을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3dc3c28e5738e838da6dece3bd69b468532f5bd" translate="yes" xml:space="preserve">
          <source>There is no longer a special API to initialize an app with Vue Router. That means instead of:</source>
          <target state="translated">Vue Router로 앱을 초기화하는 특수 API가 더 이상 없습니다. 그 대신에 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e786ab8525d61c08d5edd49d36eaafa66121f1c6" translate="yes" xml:space="preserve">
          <source>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the &lt;code&gt;.native&lt;/code&gt; modifier for &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">구성 요소의 루트 요소에서 기본 이벤트를 직접 청취하려는 경우가 있습니다. 이 경우 &lt;code&gt;v-on&lt;/code&gt; 에 &lt;code&gt;.native&lt;/code&gt; 한정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e13a2b6d1fa69f970582ef7c30a8696baaa1caf0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot you can do to help Vue grow in your community:</source>
          <target state="translated">Vue가 커뮤니티에서 성장하도록 돕기 위해 할 수있는 일이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c70dcc11c00ce0163cd6cf08b8dae423423a248d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no longer a use case for this in the new Vue Router.</source>
          <target state="translated">새로운 Vue 라우터에는 더 이상 유스 케이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="163f368f2bf083cc1079a14cd05b50989be0cc02" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We&amp;rsquo;ll fix that later.</source>
          <target state="translated">이 예제에는 한 가지 문제가 있습니다. 항목을 추가하거나 제거하면 주변 항목이 부드럽게 전환되지 않고 새 위치로 즉시 스냅됩니다. 나중에 수정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="5d85fbe7675b4e4ec3b50bf7054fe53d2209ebb4" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still one problem though. Try clicking the button below:</source>
          <target state="translated">그래도 여전히 하나의 문제가 있습니다. 아래 버튼을 클릭하십시오 :</target>
        </trans-unit>
        <trans-unit id="e6396f41a177bd681652c0e5df217826f32aabe7" translate="yes" xml:space="preserve">
          <source>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;transitioned too&lt;/a&gt;:</source>
          <target state="translated">이러한 FLIP 애니메이션도 단일 축으로 제한되지 않습니다. 다차원 그리드의 항목도 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;전환&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="101fa3129d0c59027806566e19bcb27a91fd6013" translate="yes" xml:space="preserve">
          <source>These applications always include many in-DOM templates, where &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;kebab-case &lt;strong&gt;must&lt;/strong&gt; be used&lt;/a&gt;.</source>
          <target state="translated">이러한 응용 프로그램에는 항상 &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;케밥 케이스를 &lt;strong&gt;사용해야&lt;/strong&gt;&lt;/a&gt; 하는 많은 DOM 템플릿 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="79c4f8a294a999f0a432548c8b4a47252ba3a153" translate="yes" xml:space="preserve">
          <source>These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</source>
          <target state="translated">이것들은 큰 템플릿을 가진 데모 나 매우 작은 어플리케이션에서 유용 할 수 있지만, 템플릿을 나머지 컴포넌트 정의와 분리하기 때문에 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="4eda46855e3962039e549f3d03f1e9beb23fa48b" translate="yes" xml:space="preserve">
          <source>These components are &lt;strong&gt;globally registered&lt;/strong&gt;. That means they can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created after registration. For example:</source>
          <target state="translated">이러한 구성 요소는 &lt;strong&gt;전체적으로 등록되어&lt;/strong&gt; 있습니다. 이는 등록 후 생성 된 모든 루트 Vue 인스턴스 ( &lt;code&gt;new Vue&lt;/code&gt; ) 의 템플릿에서 사용할 수 있음을 의미 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c11fba5bbbf86f45897e779c4584d6721b0b2522" translate="yes" xml:space="preserve">
          <source>These components lay the foundation for consistent styling and behavior in your application. They may &lt;strong&gt;only&lt;/strong&gt; contain:</source>
          <target state="translated">이러한 구성 요소는 응용 프로그램에서 일관된 스타일과 동작을위한 기반을 마련합니다. 그들은 다음을 포함 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c208483eb8caab5ce32ce55aa9ca8d4751b6d7ab" translate="yes" xml:space="preserve">
          <source>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain &lt;strong&gt;one single expression&lt;/strong&gt;, so the following will &lt;strong&gt;NOT&lt;/strong&gt; work:</source>
          <target state="translated">이 표현식은 소유자 Vue 인스턴스의 데이터 범위에서 JavaScript로 평가됩니다. 한 가지 제한 사항은 각 바인딩에 &lt;strong&gt;하나의 단일 표현식&lt;/strong&gt; 만 포함 할 수 있으므로 다음은 작동 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="894c317239a0c7a65a9e88455fd9ec3ef7ebc237" translate="yes" xml:space="preserve">
          <source>These hooks can be used in combination with CSS transitions/animations or on their own.</source>
          <target state="translated">이 후크는 CSS 전환 / 애니메이션과 함께 사용하거나 자체적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18eb93efc44d56c2080356f2acd2adc1588f6912" translate="yes" xml:space="preserve">
          <source>These limitations become apparent when designing a search indicator, like this one for example:</source>
          <target state="translated">이러한 제한은 예를 들어 다음과 같이 검색 표시기를 설계 할 때 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="44f058292bf91d7fdc0c19b30d4f231d10c8ffce" translate="yes" xml:space="preserve">
          <source>These modifiers restrict the handler to events triggered by a specific mouse button.</source>
          <target state="translated">이러한 수정자는 핸들러를 특정 마우스 버튼으로 트리거되는 이벤트로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="d2b0e629392045530844771affeff7b43f8ec099" translate="yes" xml:space="preserve">
          <source>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</source>
          <target state="translated">이러한 규칙은 대부분의 프로젝트에서 가독성 및 / 또는 개발자 경험을 향상시키는 것으로 밝혀졌습니다. 위반할 경우 코드는 계속 실행되지만 위반은 드물고 정당화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="91af92ef53fdf34200de7e0b28db35745ed2a1ae" translate="yes" xml:space="preserve">
          <source>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</source>
          <target state="translated">이 규칙은 오류를 방지하는 데 도움이되므로 모든 비용으로 오류를 학습하고 준수하십시오. 예외는있을 수 있지만 매우 드 물어야하며 JavaScript와 Vue에 대한 전문 지식이있는 사람 만 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e30564da6ab88875780c5728faa3632ae18dc83a" translate="yes" xml:space="preserve">
          <source>These specific languages are only examples. You could as easily use Bubl&amp;eacute;, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with &lt;code&gt;vue-loader&lt;/code&gt;, it also has first-class support for CSS Modules.</source>
          <target state="translated">이러한 특정 언어는 단지 예일뿐입니다. Bubl&amp;eacute;, TypeScript, SCSS, PostCSS 또는 생산성 향상에 도움이되는 다른 전처리기를 쉽게 사용할 수 있습니다. &lt;code&gt;vue-loader&lt;/code&gt; 와 함께 Webpack을 사용하는 경우 CSS 모듈에 대한 일급 지원도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd9827028ef750f7255fe5fc506af18a8fb1368" translate="yes" xml:space="preserve">
          <source>These will override the conventional class names. This is especially useful when you want to combine Vue&amp;rsquo;s transition system with an existing CSS animation library, such as &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;.</source>
          <target state="translated">기존 클래스 이름보다 우선합니다. 이것은 Vue의 전환 시스템을 &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt; 와 같은 기존 CSS 애니메이션 라이브러리와 결합하려는 경우에 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a8d1026e768f545462812038bf11ac5597aa461a" translate="yes" xml:space="preserve">
          <source>They document the API of the component, so that it&amp;rsquo;s easy to see how the component is meant to be used.</source>
          <target state="translated">구성 요소의 API를 문서화하므로 구성 요소의 사용법을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9fb3a66c9bf09491269055d05e63e8daff7baf" translate="yes" xml:space="preserve">
          <source>They have slightly different target users however.</source>
          <target state="translated">그러나 대상 사용자가 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dddb496772a8230c124e4f06a214f032833805d2" translate="yes" xml:space="preserve">
          <source>They may look a bit different from normal HTML, but &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</source>
          <target state="translated">그들은 일반적인 HTML과 약간 다르게 보일 수 있지만 &lt;code&gt;:&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 는 속성 이름에 유효한 문자이며 모든 Vue 지원 브라우저는 올바르게 구문 분석 할 수 있습니다. 또한 최종 렌더링 된 마크 업에는 나타나지 않습니다. 속기 구문은 전적으로 선택 사항이지만 나중에 사용법에 대해 자세히 알아볼 때 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a9f42e561d875ba212a21ce976d18f88707fb7e" translate="yes" xml:space="preserve">
          <source>They&amp;rsquo;re also very useful as wrapper components. For example, when you need to:</source>
          <target state="translated">또한 래퍼 구성 요소로 매우 유용합니다. 예를 들어, 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="36292b3c039d104e965d98c8c9a093ed70eee710" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;prevents conflicts&lt;/a&gt; with existing and future HTML elements, since all HTML elements are a single word.</source>
          <target state="translated">이 &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;방지 충돌&lt;/a&gt; 모든 HTML 요소 이후 기존 및 향후의 HTML 요소는 하나의 단어입니다.</target>
        </trans-unit>
        <trans-unit id="1ece11c20b0e27793001fdeec7df491259c0b914" translate="yes" xml:space="preserve">
          <source>This allows us add behavior that a filter alone couldn&amp;rsquo;t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;&lt;code&gt;currencyValidator&lt;/code&gt; object&lt;/a&gt;:</source>
          <target state="translated">이를 통해 초점에 대한 입력 내용 선택과 같이 필터만으로는 캡슐화 할 수없는 동작을 추가 할 수 있습니다. 다음 단계는 필터에서 비즈니스 로직을 추출하는 것입니다. 아래에서 모든 것을 외부 &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt; &lt;code&gt;currencyValidator&lt;/code&gt; 객체&lt;/a&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="74e149b933b7f933e9d6e2560dceac8830da4733" translate="yes" xml:space="preserve">
          <source>This allows you to compose components like this:</source>
          <target state="translated">이를 통해 다음과 같은 구성 요소를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b017e21cf180432f227f352528adf7beedafa7a" translate="yes" xml:space="preserve">
          <source>This also means the following computed property will never update, because &lt;code&gt;Date.now()&lt;/code&gt; is not a reactive dependency:</source>
          <target state="translated">이는 또한 &lt;code&gt;Date.now()&lt;/code&gt; 가 반응 적 종속성이 아니기 때문에 다음과 같은 계산 된 속성이 업데이트되지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d966b066638dcbfbeb5f7c1fa054b2b9f4ac88e1" translate="yes" xml:space="preserve">
          <source>This attribute does not support dynamic binding.</source>
          <target state="translated">이 속성은 동적 바인딩을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85db9f37abb47bdae5f9736eb1fa18d771e503d8" translate="yes" xml:space="preserve">
          <source>This brings us full circle back to &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;, so if you&amp;rsquo;ve read this far it&amp;rsquo;s probably time to try it out!</source>
          <target state="translated">이것은 우리에게 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex에&lt;/a&gt; 완전한 원을 가져옵니다. 이 글을 읽었다면 시도해 볼 시간입니다!</target>
        </trans-unit>
        <trans-unit id="e208871e834d455a504dbc7b4789f62b8d51dbdf" translate="yes" xml:space="preserve">
          <source>This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; to manage state in most cases.</source>
          <target state="translated">이 기능은 소수의 구성 요소가있는 데모 또는 매우 작은 앱에 편리 할 수 ​​있습니다. 그러나이 패턴은 중간 규모 또는 대규모 애플리케이션에 적합하지 않으므로 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 를 사용하여 대부분의 경우 상태를 관리 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ae7f80927899cd62140ba3ac91c1a272907e8a" translate="yes" xml:space="preserve">
          <source>This can be especially useful in combination with the &lt;code&gt;$attrs&lt;/code&gt; instance property, which contains the attribute names and values passed to a component, such as:</source>
          <target state="translated">이는 다음 과 같이 구성 요소에 전달 된 속성 이름 및 값을 포함하는 &lt;code&gt;$attrs&lt;/code&gt; 인스턴스 특성 과 함께 사용하면 특히 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc35e91b7f0ddcd858a9ed54df8c331d12068bc2" translate="yes" xml:space="preserve">
          <source>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, &lt;code&gt;v-slot&lt;/code&gt; without an argument is assumed to refer to the default slot:</source>
          <target state="translated">이것은 더 짧아 질 수 있습니다. 지정되지 않은 내용이 기본 슬롯에 대한 것으로 가정되는 것처럼 인수가없는 &lt;code&gt;v-slot&lt;/code&gt; 슬롯은 기본 슬롯 을 참조하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e890dd0b9a03e7b18eb3ea7a9ab2b112967c585d" translate="yes" xml:space="preserve">
          <source>This can be useful sometimes, but it&amp;rsquo;s not a good idea when you&amp;rsquo;re trying to listen on a very specific element, like an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. For example, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component above might refactor so that the root element is actually a &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">이것은 때때로 유용 할 수 있지만 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 과 같은 매우 특정한 요소를 듣려고 할 때는 좋지 않습니다 . 예를 들어, 루트 요소가 실제로 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 요소 가되도록 위 의 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 컴포넌트가 리팩터링 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef2288cfa9c5bb1049786a028d410bf6a81d1c49" translate="yes" xml:space="preserve">
          <source>This can be useful when you&amp;rsquo;ve defined CSS transitions/animations using Vue&amp;rsquo;s transition class conventions and want to switch between them.</source>
          <target state="translated">이는 Vue의 전환 클래스 규칙을 사용하여 CSS 전환 / 애니메이션을 정의하고 전환간에 유용 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22ed18f22c3147e4d4b605b99a8c886bf36867ed" translate="yes" xml:space="preserve">
          <source>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. &lt;code&gt;user&lt;/code&gt; to &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">이는 특히 슬롯에 소품이 많은 경우 템플릿을 훨씬 깨끗하게 만들 수 있습니다. 그것은 또한 예, 소품 이름을 변경하는 등의 가능성이 열리고 &lt;code&gt;user&lt;/code&gt; 에게 &lt;code&gt;person&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91d37bc2f925538550750ba2e9fce0b6e7858848" translate="yes" xml:space="preserve">
          <source>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</source>
          <target state="translated">JavaScript는 특정보기를 향상시키는 데만 사용되는 중소 규모 프로젝트에 매우 효과적입니다. 그러나보다 복잡한 프로젝트에서 또는 프론트 엔드가 완전히 JavaScript로 구동되는 경우 이러한 단점이 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="552c6085e6177cea581b90083d77773efb3e8be2" translate="yes" xml:space="preserve">
          <source>This class is mostly useful for specifying the transition timing and easing curve, as you&amp;rsquo;ll see below:</source>
          <target state="translated">이 클래스는 아래에서 볼 수 있듯이 전환 타이밍과 여유 곡선을 지정하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a64fb541d6cf03a309471b66f62b3cc4e9df105f" translate="yes" xml:space="preserve">
          <source>This could be rewritten with JavaScript&amp;rsquo;s &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; in a render function:</source>
          <target state="translated">이 자바 스크립트의로 다시 작성할 수 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 과 &lt;code&gt;map&lt;/code&gt; 렌더링 함수 :</target>
        </trans-unit>
        <trans-unit id="dc281e6afa265cb93fadcfb1141b35d1dc6b8178" translate="yes" xml:space="preserve">
          <source>This default mode is efficient, but &lt;strong&gt;only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)&lt;/strong&gt;.</source>
          <target state="translated">이 기본 모드는 효율적이지만 &lt;strong&gt;목록 렌더링 출력이 하위 구성 요소 상태 또는 임시 DOM 상태 (예 : 양식 입력 값)에 의존하지 않는 경우에만 적합합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83c6bcc5ab3c17077a142a2b9547158e591eb788" translate="yes" xml:space="preserve">
          <source>This directive triggers transitions when its condition changes.</source>
          <target state="translated">이 지시문은 조건이 변경 될 때 전환을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="bcf9f3835622e83dc060967041ab679cca48d307" translate="yes" xml:space="preserve">
          <source>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt;, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</source>
          <target state="translated">이 지시문은 관련 Vue 인스턴스가 컴파일을 완료 할 때까지 요소에 남아 있습니다. &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt; 과 같은 CSS 규칙과 함께이 지시문은 Vue 인스턴스가 준비 될 때까지 컴파일되지 않은 콧수염 바인딩을 숨기는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e343af564058d721599d1f9e8b019d300435ac7" translate="yes" xml:space="preserve">
          <source>This does not mean the component is only used in a single page, but it will only be used once &lt;em&gt;per page&lt;/em&gt;. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it&amp;rsquo;s a good indication that this is actually a reusable component that is only used once per page &lt;em&gt;for now&lt;/em&gt;.</source>
          <target state="translated">콤포넌트가 단일 페이지에서만 사용되는 것은 아니며 페이지 &lt;em&gt;당&lt;/em&gt; 한 번만 사용 &lt;em&gt;됩니다&lt;/em&gt; . 이러한 구성 요소는 앱 내에서 컨텍스트가 아니라 앱에만 적용되므로 소품을 허용하지 않습니다. 당신이 소품을 추가 할 필요를 발견하면,이는 페이지 당 한 번만 사용되는 재사용 가능한 구성 요소 실제로있는 좋은 지표입니다 &lt;em&gt;지금은&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="045411f2b2e7825926721bc11467177b95eff687" translate="yes" xml:space="preserve">
          <source>This even applies to all subcomponents, meaning all three of these components will also be available &lt;em&gt;inside each other&lt;/em&gt;.</source>
          <target state="translated">이것은 모든 하위 구성 요소에도 적용됩니다. 즉,이 세 구성 요소 모두 &lt;em&gt;서로 내부에서&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82b2832a220d04d77924bc1b878abfa24eacde86" translate="yes" xml:space="preserve">
          <source>This example demonstrates that we can bind data to not only text and attributes, but also the &lt;strong&gt;structure&lt;/strong&gt; of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply &lt;a href=&quot;guide/transitions&quot;&gt;transition effects&lt;/a&gt; when elements are inserted/updated/removed by Vue.</source>
          <target state="translated">이 예제는 텍스트와 속성뿐만 아니라 DOM &lt;strong&gt;구조&lt;/strong&gt; 에도 데이터를 바인딩 할 수 있음을 보여줍니다 . 또한 Vue는 Vue에서 요소를 삽입 / 업데이트 / 제거 할 때 자동으로 &lt;a href=&quot;guide/transitions&quot;&gt;전환 효과를&lt;/a&gt; 적용 할 수있는 강력한 전환 효과 시스템을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="28f4e1203d764412549f6b1974ffcd1631f009dd" translate="yes" xml:space="preserve">
          <source>This gives you more complete control over the reactive properties you&amp;rsquo;d like to watch.</source>
          <target state="translated">이를 통해보고자하는 반응 특성을보다 완벽하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">이 기능은 함수를 허용 하는 &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; 옵션&lt;/a&gt; 으로 대체 되었으므로 경로마다 스크롤 동작을 완전히 사용자 정의 할 수 있습니다. 이것은 많은 새로운 가능성을 열어 주지만 다음과 같은 오래된 행동을 재현합니다.</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">이것은 &lt;a href=&quot;../api/index#delimiters&quot;&gt;컴포넌트 레벨 옵션&lt;/a&gt; 으로 재 작업되었습니다 . 이를 통해 타사 구성 요소를 손상시키지 않고 앱 내에서 대체 구분 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">이것은 빨리 손을 go습니다. 따라서 하위 구성 요소에 컨텍스트 정보를 임의로 제공하는 대신 &lt;a href=&quot;#Dependency-Injection&quot;&gt;종속성 주입을&lt;/a&gt; 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">여기에는 두 가지 잠재적 인 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">이를 통해 구성 요소를 편집하거나 사용 방법을 검토해야 할 때 구성 요소를 더 빨리 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">이렇게 모듈화 된 기능이 향상되어 Vue 2로 쉽게 마이그레이션 할 수있을뿐만 아니라 통화 구문 분석 및 서식을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">이것은 고안된 예이지만 우리는 앱을 두 개의 작은 단위로 분리했으며 자식은 props 인터페이스를 통해 부모와 상당히 분리되어 있습니다. 이제 상위 앱에 영향을주지 않고보다 복잡한 템플릿과 로직으로 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 구성 요소를 더욱 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">이 안내서는 작성하기에 가장 어려운 페이지이지만 확실히 중요하다고 생각합니다. 문제는 해결하려고했던 문제가 있고 다른 라이브러리를 사용하여 해결 한 것입니다. Vue가 특정 문제를 더 잘 해결할 수 있는지 알고 싶기 때문에 여기에 있습니다. 그것이 우리가 당신을 위해 대답하고자하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">이것은 이제 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;경로 정의에&lt;/a&gt; 대한 옵션입니다 . 예를 들어 다음을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">이것은 이제 별칭을 지정할 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;경로의 정의에 대한 옵션입니다&lt;/a&gt; . 예를 들어 다음을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 인 경우에도 HTML 입력 요소의 값은 항상 문자열을 반환 하므로 유용 합니다. &lt;code&gt;parseFloat()&lt;/code&gt; 값을 구문 분석 할 수없는 경우 원래 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">이것은 &lt;a href=&quot;../guide/single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 에만 관련이 있습니다. &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;/a&gt; 속성 을 사용할 필요 는 &lt;em&gt;없습니다&lt;/em&gt; . 범위 지정은 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; , &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt; 과 같은 클래스 기반 전략 또는 다른 라이브러리 / 컨벤션을 통해 이루어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;mixins&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">이것은 글로벌 &lt;code&gt;Vue.delete&lt;/code&gt; 의 &lt;strong&gt;별명&lt;/strong&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">이것은 글로벌 &lt;code&gt;Vue.set&lt;/code&gt; 의 &lt;strong&gt;별명&lt;/strong&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">이는 더 낮은 수준의 비용이지만 &lt;code&gt;v-model&lt;/code&gt; 과 비교하여 상호 작용 세부 정보를 훨씬 더 많이 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">구성 요소 옵션에 권장되는 기본 순서입니다. 그것들은 카테고리로 나뉘어 있으므로 사용자 정의 속성과 지시문을 추가 할 위치를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">구성 요소 옵션에 권장되는 기본 순서입니다. 그것들은 카테고리로 나뉘어 있으므로 플러그인에서 새 속성을 추가 할 위치를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">Vue 특정 코드의 공식 스타일 가이드입니다. 프로젝트에서 Vue를 사용하는 경우 오류, 자전거 타기 및 안티 패턴을 피하기위한 훌륭한 참고 자료입니다. 그러나 우리는 어떤 스타일 가이드가 모든 팀이나 프로젝트에 이상적이라고 생각하지 않으므로 과거 경험, 주변 기술 스택 및 개인 가치에 따라 신중한 편차가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">다음은 실제로 사용되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">그러나 이것이 항상 바람직한 것은 아니므로 Vue는&amp;ldquo;이 두 요소는 완전히 분리되어 재사용하지 마십시오&amp;rdquo;라고 말할 수있는 방법을 제공합니다. 고유 한 값 으로 &lt;code&gt;key&lt;/code&gt; 속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">다음과 같은 결과로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">이를 통해 여러 조건부 하위에서 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">이렇게하면 사람이 읽을 수있는 클래스 이름을 사용하여 내부 스타일을 재정의하는 것이 더 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new Vue()&lt;/code&gt; 호출하기 전에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">이것은 마술처럼 보이지만 Vue는 &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; 라는 애니메이션 기법을 사용하여 변환을 사용하여 요소를 이전 위치에서 새 위치로 부드럽게 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">이것은 구성 요소를 문서화 할뿐만 아니라 잘못된 유형을 전달하면 브라우저의 JavaScript 콘솔에서 사용자에게 경고합니다. 이 페이지 아래에서 &lt;a href=&quot;#Prop-Validation&quot;&gt;유형 확인 및 기타 소품 검증&lt;/a&gt; 에 대해 더 자세히 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 뷰의 전환 시스템이 명시가 가지고있는 지금은 더 이상 필요하지 않습니다 &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; 전환 제어&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">이 페이지에서는 &lt;a href=&quot;components&quot;&gt;구성 요소 기본 사항을&lt;/a&gt; 이미 읽었다 고 가정합니다 . 구성 요소를 처음 사용하는 경우 먼저 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">이 옵션 쌍은 함께 사용되어 동일한 상위 체인에있는 한 상위 계층 구성 요소가 구성 요소 계층 구조의 깊이에 관계없이 모든 하위 항목에 대한 종속성 인젝터 역할을 할 수 있습니다. React에 익숙하다면 이는 React의 컨텍스트 기능과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">이는 &lt;code&gt;doc&lt;/code&gt; 객체의 각 속성 (예 : &lt;code&gt;title&lt;/code&gt; )을 개별 소품으로 전달한 다음 각각에 대한 &lt;code&gt;v-on&lt;/code&gt; 업데이트 리스너를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">이 패턴을 사용하면 실제로 루트에있는 요소를 신경 쓰지 않고도 원시 HTML 요소와 같은 기본 구성 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 간단한 시나리오에서 &lt;code&gt;$dispatch&lt;/code&gt; 및 &lt;code&gt;$broadcast&lt;/code&gt; 를 대체 할 수 있지만보다 복잡한 경우 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 와 같은 전용 상태 관리 계층을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;components&quot;&gt;구성 요소에&lt;/a&gt; 대한 지식이 있다고 가정합니다 . 건너 뛰고 나중에 다시 오십시오.</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;components&quot;&gt;Vue 구성 요소에&lt;/a&gt; 대한 지식이 있다고 가정합니다 . 건너 뛰고 나중에 다시 오십시오.</target>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">이것은 항상 &lt;code&gt;errorClass&lt;/code&gt; 를 적용 하지만 &lt;code&gt;isActive&lt;/code&gt; 가 true 인 경우 에만 &lt;code&gt;activeClass&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">이러한 제한이있는 요소가있는 구성 요소를 사용할 때 문제가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">브라우저가 지원하는 배열의 마지막 값만 렌더링합니다. 이 예제에서는 접두사가없는 버전의 flexbox를 지원하는 브라우저의 경우 &lt;code&gt;display: flex&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">동일한 결과가 렌더링됩니다. 객체를 반환하는 &lt;a href=&quot;computed&quot;&gt;계산 된 속성에&lt;/a&gt; 바인딩 할 수도 있습니다 . 이것은 일반적이고 강력한 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">이것은 잘 작동하지만, 알아야 할 한 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">이것은 페이지 상단에서 200px 요소를 고정시킵니다. 그러나 맨 위 대신 왼쪽에서 요소를 고정해야 할 때 시나리오가 발생하면 어떻게됩니까? 구성 요소 인스턴스별로 업데이트 할 수있는 동적 인수가 매우 유용한 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">따라서 상위 컴포넌트가 다음을 사용하여 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 내부의 입력에 초점을 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">단단히 결합 된 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">밀접하게 결합 된 구성 요소 이름을 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">이 문제를 해결하기 위해 Vue는 &lt;code&gt;v-on&lt;/code&gt; 에 대한 &lt;strong&gt;이벤트 수정자를&lt;/strong&gt; 제공합니다 . 수정자는 점으로 표시되는 지시문 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">Objects 내에서 중첩 된 값 변경을 감지하려면 options 인수 에서 &lt;code&gt;deep: true&lt;/code&gt; 를 전달해야합니다 . Array 돌연변이를 청취하기 위해 그렇게 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">하나의 정의로 애니메이션을 적용한다는 것은 생명을 얻는 것입니다. 불행하게도, 디자이너가 아이콘, 로고 및 마스코트를 만들 때 일반적으로 이미지 또는 정적 SVG로 제공됩니다. 따라서 GitHub의 octocat, Twitter의 새 및 기타 많은 로고가 살아있는 생물과 비슷하지만 실제로 살아있는 것처럼 보이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">목록을 숨겨야하는 경우 목록을 렌더링하지 않으려면 (예 : &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ) 이 경우 &lt;code&gt;v-if&lt;/code&gt; 를 컨테이너 요소 (예 : &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;ol&lt;/code&gt; )로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">경고 2를 처리하기 위해 &lt;code&gt;splice&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">무슨 일이 일어나고 있는지 설명하기 위해 컴포넌트 A와 B를 호출 해 봅시다. 모듈 시스템은 A가 필요하지만 먼저 A는 B가 필요하지만 B는 A가 필요하지만 A는 B가 필요하다는 것을 알 수 있습니다. 먼저 다른 구성 요소를 해결하지 않고 구성 요소를 완전히 해결하십시오. 이 문제를 해결하려면 모듈 시스템에 &quot;A는 &lt;em&gt;결국&lt;/em&gt; B 가 필요하지만 B를 먼저 해결할 필요는 없습니다.&quot; 라고 말할 수있는 지점을 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">목록에서 항목을 필터링합니다 (예 : &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ). 이 경우 필터링 된 목록을 반환하는 새로운 계산 된 속성 (예 : &lt;code&gt;activeUsers&lt;/code&gt; )으로 &lt;code&gt;users&lt;/code&gt; 를 교체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Vue를 시작하려면 HTML 및 ES5 JavaScript (일반 JavaScript)에 익숙하면됩니다. 이 기본 기술을 사용 &lt;a href=&quot;../index&quot;&gt;하면 가이드&lt;/a&gt; 를 읽고 하루 만에 사소한 응용 프로그램을 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vue가 각 노드의 ID를 추적하여 기존 요소를 재사용하고 재정렬 할 수 있도록 힌트를 제공하려면 각 항목에 고유 한 &lt;code&gt;key&lt;/code&gt; 속성 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;strong&gt;상점 패턴을&lt;/strong&gt; 채택 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">프로그래밍 방식 리스너에 대한 자세한 내용은 API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">TypeScript가 Vue 구성 요소 옵션 내에서 유형을 올바르게 유추하도록하려면 &lt;code&gt;Vue.component&lt;/code&gt; 또는 &lt;code&gt;Vue.extend&lt;/code&gt; 로 구성 요소를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">사용자가 앱과 상호 작용할 수 있도록 &lt;code&gt;v-on&lt;/code&gt; 지시문을 사용하여 Vue 인스턴스에서 메서드를 호출하는 이벤트 리스너를 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">하려면 &lt;code&gt;user&lt;/code&gt; 부모의 슬롯 콘텐츠에 사용할 수를, 우리는 결합 할 수있는 &lt;code&gt;user&lt;/code&gt; 받는 속성으로 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소 :</target>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">경고 1을 극복하기 위해 다음 두 가지 모두 &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 와 동일하지만 반응성 시스템에서 상태 업데이트를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">부모에서 이름이 지정된 슬롯으로 컨텐츠를 전달하려면 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 의 특수 &lt;code&gt;slot&lt;/code&gt; 속성을 사용하십시오 ( &lt;a href=&quot;#Named-Slots&quot;&gt;여기&lt;/a&gt; 에서 설명 된 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 구성 요소 사용 ).</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">렌더링 기능을 사용하여 범위가 지정된 슬롯을 하위 구성 요소로 전달하려면 VNode 데이터 의 &lt;code&gt;scopedSlots&lt;/code&gt; 필드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">명명 된 슬롯에 컨텐츠를 제공하기 위해 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;v-slot&lt;/code&gt; 지시문을 사용하여 슬롯 이름을 &lt;code&gt;v-slot&lt;/code&gt; 의 인수로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">슬롯에 전달 소품을 수신하기 위해, 부모 구성 요소를 사용할 수 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 와 &lt;code&gt;slot-scope&lt;/code&gt; 속성 (은 USING &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; 설명 &lt;a href=&quot;#Scoped-Slots&quot;&gt;여기&lt;/a&gt; 예로)</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">스타일 범위를 지정하기 위해 Vue는 &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; 와 같은 구성 요소에 고유 한 속성을 추가합니다 . 그런 다음이 속성과 일치하는 요소 만 선택되도록 선택기를 수정합니다 (예 : &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">이 문제를 해결하기 위해 Vue는 구성 요소에서 사용되는 리스너 객체를 포함하는 &lt;code&gt;$listeners&lt;/code&gt; 속성을 제공합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">날짜 선택기 플러그인의 테마를 지정하려면 다음과 같이 특정 클래스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">prop 유효성 검사를 지정하기 위해 문자열 배열 대신 &lt;code&gt;props&lt;/code&gt; 값에 유효성 검사 요구 사항이있는 객체를 제공 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Vue 2.0을 사용하여보다 강력한 솔루션으로 전환을 시작하려면 먼저이 필터를 새로운 &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; 구성 요소로 감싸겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">템플릿에서 이러한 구성 요소를 사용하려면 Vue가이를 알 수 있도록 등록해야합니다. 구성 요소 등록에는 &lt;strong&gt;global&lt;/strong&gt; 및 &lt;strong&gt;local&lt;/strong&gt; 의 두 가지 유형이 있습니다 . 지금까지 &lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 전 세계적으로 구성 요소를 등록 했습니다 .</target>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">표현식 값의 진실성을 기반으로 요소의 &lt;code&gt;display&lt;/code&gt; CSS 속성을 전환합니다 .</target>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">런타임 오류 추적</target>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">전환 스 &lt;code&gt;stagger&lt;/code&gt; 속성이 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">전환 수업</target>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">전환 모드</target>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">구성 요소 간 전환</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">요소 간 전환</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">단일 요소 / 컴포넌트 전환</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">구성 요소 간 전환이 훨씬 간단 합니다. &lt;code&gt;key&lt;/code&gt; 속성이 필요하지 않습니다 . 대신 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;동적 구성 요소를&lt;/a&gt; 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">Vue의 컴포넌트 시스템을 통해 전환을 재사용 할 수 있습니다. 재사용 가능한 전환을 만들려면 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 구성 요소를 루트에 배치 한 다음 모든 하위 항목을 전환 구성 요소에 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">초기 렌더링시 전환</target>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">문서 번역</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">현재 인스턴스에서 이벤트를 트리거합니다. 추가 인수는 리스너의 콜백 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">트리거 전환</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; 및 &lt;code&gt;destroyed&lt;/code&gt; 훅을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 진실 / 거짓이 &lt;sup&gt;변경됨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimba에서이 강의를 시도해보십시오</target>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">생산 모드 켜기</target>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">양방향 필터 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">타입 확인</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">TypeScript 지원</target>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">Vue는 템플릿을 Virtual DOM 렌더링 함수로 컴파일합니다. 반응성 시스템과 결합 된 Vue는 앱 상태가 변경 될 때 최소한의 컴포넌트를 지능적으로 파악하여 최소한의 DOM 조작을 다시 렌더링하고 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">불행히도 HTML은 사용자 정의 요소가 자체 폐쇄 전용 &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;공식 &quot;void&quot;요소&lt;/a&gt; 가되도록 허용하지 않습니다 . 그렇기 때문에 Vue의 템플릿 컴파일러가 DOM보다 먼저 템플릿에 도달 한 다음 DOM 사양 호환 HTML을 제공 할 수있는 경우에만 전략이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">불행히도 HTML의 대소 문자 구분이 없기 때문에 DOM 템플릿은 여전히 ​​케밥 케이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">컴포넌트를 여러 파일에 분산시키지 않는 한 (예 : &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS 모듈 사용&lt;/a&gt; ) React에서 CSS 범위 지정은 CSS-in-JS 솔루션 (예 : &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;스타일 컴포넌트&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;화려 함&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;감정&lt;/a&gt; )을 통해 수행됩니다. 이것은 일반적인 CSS 저작 프로세스와는 다른 새로운 컴포넌트 지향 스타일링 패러다임을 소개합니다. 또한 빌드시 CSS를 단일 스타일 시트로 추출하는 기능이 지원되지만 스타일링이 제대로 작동하려면 번들을 런타임에 포함시켜야하는 것이 일반적입니다. 스타일을 구성하는 동안 JavaScript의 역동성에 액세스 할 수 있지만 번들 크기와 런타임 비용이 증가하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 달리 실제 요소 인 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 을 기본적으로 렌더링합니다 . &lt;code&gt;tag&lt;/code&gt; 속성으로 렌더링되는 요소를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">컴포넌트 및 소품과 달리 이벤트 이름은 자동 대소 문자 변환을 제공하지 않습니다. 대신, 생성 된 이벤트의 이름은 해당 이벤트를 청취하는 데 사용 된 이름과 정확히 일치해야합니다. 예를 들어, camelCased 이벤트 이름을 내보내는 경우 :</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">컴포넌트 및 소품과 달리 이벤트 이름은 JavaScript에서 변수 또는 속성 이름으로 사용되지 않으므로 camelCase 또는 PascalCase를 사용할 이유가 없습니다. 또한 DOM 템플릿 내의 &lt;code&gt;v-on&lt;/code&gt; 이벤트 리스너는 HTML의 대소 문자를 구분하지 않기 때문에 자동으로 소문자로 변환되므로 &lt;code&gt;v-on:myEvent&lt;/code&gt; 는 &lt;code&gt;v-on:myevent&lt;/code&gt; 가 되어 &lt;code&gt;myEvent&lt;/code&gt; 를들을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">1.x와 달리이 &lt;code&gt;$refs&lt;/code&gt; 는 렌더링 프로세스 자체에서 등록 / 업데이트되기 때문에 반응하지 않습니다. 그것들을 반응 적으로 만들려면 모든 변경에 대해 중복 렌더링이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">네이티브 DOM 이벤트에만 적용되는 다른 수정 자와 달리 &lt;code&gt;.once&lt;/code&gt; 수정자는 &lt;a href=&quot;components-custom-events&quot;&gt;구성 요소 이벤트&lt;/a&gt; 에도 사용할 수 있습니다 . 아직 구성 요소에 대해 읽지 않았다면 지금 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0 이상에서 업데이트되었습니다. &lt;code&gt;slot-scope&lt;/code&gt; 속성을 사용하는 더 이상 사용되지 않는 구문 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;은 여기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0 이상에서 업데이트되었습니다. &lt;code&gt;slot&lt;/code&gt; 속성을 사용하는 더 이상 사용되지 않는 구문 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;은 여기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">요소의 &lt;code&gt;innerHTML&lt;/code&gt; 을 업데이트합니다 . &lt;strong&gt;내용은 일반 HTML로 삽입되므로 Vue 템플릿으로 컴파일되지 않습니다&lt;/strong&gt; . &lt;code&gt;v-html&lt;/code&gt; 을 사용하여 템플릿을 작성하려는 경우 구성 요소를 대신 사용하여 솔루션을 다시 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">요소의 &lt;code&gt;textContent&lt;/code&gt; 를 업데이트합니다 . &lt;code&gt;textContent&lt;/code&gt; 의 일부를 업데이트 해야하는 경우 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 보간 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">이러한 모든 노드를 효율적으로 업데이트하는 것은 어려울 수 있지만 다행히도 수동으로 수행 할 필요는 없습니다. 대신, Vue에게 페이지에서 원하는 HTML을 템플릿으로 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">업그레이드 경로</target>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;롤업 - 플러그인 - 교체&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">사용 &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash의 &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; (또는 아마도 &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ) 직접 비용이 메소드를 호출 제한합니다. 다음과 같이 위와 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">계산 된 속성에서 &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash의 &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">대신 컴포넌트에서 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">대신 구성 요소에서 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">대신 경로에 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">사용 &lt;code&gt;$parent&lt;/code&gt; 와 &lt;code&gt;$children&lt;/code&gt; 아껴서를 - 그들은 대부분 탈출 해치 역할을합니다. 부모-자식 의사 소통을 위해 소품과 이벤트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">대신 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 를 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;Vue.set&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">계산 된 속성 에서 JavaScript의 기본 제공 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; 메서드&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">계산 된 속성 에서 JavaScript의 기본 제공 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; 메서드&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">다른 후크에서 사용자 정의 DOM 점검을 사용하십시오. 예를 들어 다음을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">대신 구성 요소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">글로벌 믹스 인은 타사 구성 요소를 포함하여 생성 된 모든 단일 Vue 인스턴스에 영향을주기 때문에 드물고 신중하게 사용하십시오. 대부분의 경우 위의 예에서 설명한 것처럼 사용자 지정 옵션 처리에만 사용해야합니다. 중복 응용 프로그램을 피하기 위해 &lt;a href=&quot;plugins&quot;&gt;플러그인&lt;/a&gt; 으로 제공 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Vue.use()&lt;/code&gt; 전역 메소드 를 호출하여 플러그인을 사용하십시오 . &lt;code&gt;new Vue()&lt;/code&gt; 호출하여 앱을 시작하기 전에이 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">최적의 디버깅 경험을 위해서는 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">대신 &lt;code&gt;created&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">대신 구성 요소의 &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; 훅을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">기본 DOM API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">대신 새로운 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 사용하십시오. 이는 본질적으로 동일합니다. 다른 수명주기 방법과의 일관성을 위해 이름이 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">대신 새 &lt;code&gt;mounted&lt;/code&gt; 고리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">대신 새 &lt;code&gt;mounted&lt;/code&gt; 고리를 사용하십시오. 하지만 &lt;code&gt;mounted&lt;/code&gt; 하면 문서 내를 보장 할 수 없습니다. 이를 위해 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; 도 포함 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;동적 구성 요소에&lt;/a&gt; 사용되며 &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;DOM 내 템플리트의 한계&lt;/a&gt; 를 해결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">하위 컴포넌트에 삽입 된 컨텐츠에서 컨텐츠가 속하는 명명 된 슬롯을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 범위가 지정된 슬롯으로 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">요소 또는 구성 요소를 범위가 지정된 슬롯으로 표시하는 데 사용됩니다. 속성 값은 함수 시그니처의 인수 위치에 나타날 수있는 유효한 JavaScript 표현식이어야합니다. 이는 지원되는 환경에서 표현식에서 ES2015 파괴를 사용할 수도 있음을 의미합니다. 2.5.0 이상에서 &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;범위가 지정된 슬롯&lt;/a&gt; 에 프로그래밍 방식으로 액세스하는 데 사용됩니다 . &lt;code&gt;default&lt;/code&gt; 슬롯을 포함하여 각 슬롯에 대해 객체는 VNode를 반환하는 해당 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;슬롯별로 배포 된&lt;/a&gt; 콘텐츠에 프로그래밍 방식으로 액세스하는 데 사용됩니다 . 각각의 &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;이름이 슬롯은&lt;/a&gt; 자신의 상응하는 특성이있다 (예 : 내용 &lt;code&gt;v-slot:foo&lt;/code&gt; 에서 찾을 수 &lt;code&gt;vm.$slots.foo&lt;/code&gt; ). &lt;code&gt;default&lt;/code&gt; 속성 중 하나라는 슬롯 또는 내용에 포함되지 않은 노드들이 포함 &lt;code&gt;v-slot:default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">추가 인수와 함께 &lt;code&gt;$emit&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">이벤트 이름으로 &lt;code&gt;$emit&lt;/code&gt; 사용하기 :</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; 속성 사용 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">&lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; 과 같이 리터럴 객체와 함께 &lt;code&gt;v-bind.sync&lt;/code&gt; 를 사용 하면 복잡한 표현식을 구문 분석 할 때 고려해야 할 에지 케이스가 너무 많으므로 작동하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">사용 &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; , 우리 &lt;em&gt;만&lt;/em&gt; 렌더링하는 동안 반복 처리를 통해 활성 사용자를 훨씬 더 효율적으로 렌더링하기.</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">사용 &lt;code&gt;v-if&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 함께하는 것이됩니다 &lt;strong&gt;하지 않는 것이 좋습니다&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;스타일 가이드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">컴포넌트에서 &lt;code&gt;v-model&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">JavaScript 표현식 사용</target>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">전환과 애니메이션을 함께 사용</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">플러그인 사용</target>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">주입 된 값을 데이터 입력으로 사용 :</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">prop의 기본값으로 주입 된 값 사용 :</target>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">&lt;code&gt;$listeners&lt;/code&gt; 속성을 사용하면 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; 를 사용하여 구성 요소의 모든 이벤트 리스너를 특정 자식 요소로 전달할 수 있습니다. &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 과 같은 요소 에서 &lt;code&gt;v-model&lt;/code&gt; 을 사용 &lt;code&gt;inputListeners&lt;/code&gt; 아래 inputListeners 와 같이 리스너에 대해 새로운 계산 속성을 만드는 것이 종종 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">은 Using &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 설명 &lt;a href=&quot;#Other-Examples&quot;&gt;여기&lt;/a&gt; 여기하여 등가의 사용, 예를 들어 &lt;code&gt;slot-scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 속성을 사용하면 입력의 실시간 상태에 액세스 할 수 없기 때문에 &quot;타이핑&quot;상태를 감지 할 방법이 없습니다. 그러나 Vue에서 디 바운스 기능을 분리하여 제한하려는 작업 만 디 바운싱 할 수 있으므로 개발할 수있는 기능에 대한 제한이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">이 전략을 사용하면 여러 입력 요소와 함께 Pikaday를 사용할 수 있으며 각각의 새 인스턴스가 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">그러나 일반적으로 모든 소품이 특정 유형의 가치가되기를 원할 것입니다. 이 경우 소품을 객체로 나열 할 수 있습니다. 속성의 이름과 값에 각각 소품 이름과 유형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">VNode 인터페이스</target>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNode는 고유해야합니다</target>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">가치 바인딩</target>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery의&lt;/a&gt; 비디오 . Vue Mastery의 무료 &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Vue 소개 과정을&lt;/a&gt; 시청하십시오 .</target>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">방문자 &lt;em&gt;받는&lt;/em&gt; 박물관</target>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue ( &lt;strong&gt;view&lt;/strong&gt; 와 같이 / vjuː /로 발음 됨 )는 사용자 인터페이스를 구축하기위한 &lt;strong&gt;점진적인 프레임 워크&lt;/strong&gt; 입니다. 다른 모 놀리 식 프레임 워크와 달리 Vue는 처음부터 점차적으로 채택 할 수 있도록 설계되었습니다. 핵심 라이브러리는보기 계층에만 초점을 맞추고 다른 라이브러리 나 기존 프로젝트와 쉽게 통합하여 통합 할 수 있습니다. 반면에 Vue는 &lt;a href=&quot;guide/single-file-components&quot;&gt;최신 툴링&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;지원 라이브러리&lt;/a&gt; 와 함께 사용될 때 정교한 단일 페이지 애플리케이션에 전력을 공급할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">부 데브 툴</target>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue 는 실제 DOM에 필요한 변경 사항을 추적하기 위해 &lt;strong&gt;가상 DOM&lt;/strong&gt; 을 구축하여이를 달성합니다 . 이 라인을 자세히 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vue는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;passive&lt;/code&gt; 옵션에 해당하는 &lt;code&gt;.passive&lt;/code&gt; 수정자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vue는 또한 양식 입력과 앱 상태 사이를 양방향 바인딩 하는 &lt;code&gt;v-model&lt;/code&gt; 지시문을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vue가 도울 수 있습니다. SVG는 데이터 일 뿐이므로 흥분하거나 생각하거나 놀라 울 때이 생물이 어떻게 보이는지에 대한 예만 있으면됩니다. 그러면 Vue는 이러한 상태 간 전환을 도와 주어 환영 페이지,로드 표시기 및 알림을보다 정서적으로 매력적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vue 구성 요소는 일반 사용자 지정 요소, 특히 교차 구성 요소 데이터 흐름, 사용자 지정 이벤트 통신 및 빌드 도구 통합에서는 사용할 수없는 중요한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vue는 IE8에서 지원 되지 &lt;strong&gt;않는&lt;/strong&gt; ECMAScript 5 기능을 사용하므로 IE8 이하를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 그러나 모든 &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 호환 브라우저를 지원합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vue에서는 이미 생성 된 인스턴스에 새로운 루트 수준 반응 속성을 동적으로 추가 할 수 없습니다. 그러나 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 메서드를 사용하여 중첩 속성에 반응 속성을 추가 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vue에서는 이미 생성 된 인스턴스에 새로운 루트 수준 반응 속성을 동적으로 추가 할 수 없습니다. 그러나 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 메소드를 사용하여 중첩 된 오브젝트에 반응 특성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vue는 Vue 인스턴스의 데이터 변경 사항을 관찰하고 이에 대응하는보다 일반적인 방법 인 &lt;strong&gt;watch properties를 제공&lt;/strong&gt; 합니다. 다른 데이터를 기반으로 변경해야하는 데이터가있는 경우 특히 AngularJS 배경에서 오는 경우 &lt;code&gt;watch&lt;/code&gt; 를 과도하게 사용 하려고합니다. 그러나 명령형 &lt;code&gt;watch&lt;/code&gt; 콜백 보다는 계산 된 속성을 사용하는 것이 좋습니다 . 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vue는 비동기 대기열과 함께 투명한 의존성 추적 관찰 시스템을 사용하기 때문에 전혀 고통받지 않습니다. 명백한 의존성 관계가 없으면 모든 변경 사항이 독립적으로 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vue는 고전적인 웹 기술을 수용하고 그 위에 구축합니다. 그 의미를 보여주기 위해 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue는 지시문과 구성 요소를 명확하게 구분합니다. 지시문은 DOM 조작 만 캡슐화하기위한 것이며 구성 요소는 자체보기 및 데이터 논리가있는 독립적 인 단위입니다. AngularJS에서 지시문은 모든 것을 수행하고 구성 요소는 특정 유형의 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vue는 이미 전 세계에 퍼져 있으며 핵심 팀조차도 최소 6 개 이상의 시간대로 있습니다. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;포럼&lt;/a&gt; 에는 7 개 언어와 계산이 포함되어 있으며 많은 문서가 &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;활발하게 유지 관리되는 번역이&lt;/a&gt; 있습니다. 우리는 Vue의 국제적인 접근을 매우 자랑스럽게 생각하지만 더 잘할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vue는 성능이 더 좋고 더티 검사를 사용하지 않기 때문에 최적화하기가 훨씬 쉽습니다. 범위에있는 항목이 변경 될 때마다 이러한 모든 감시자를 다시 평가해야하기 때문에 감시자가 많은 경우 AngularJS가 느려집니다. 또한 일부 감시자가 다른 업데이트를 트리거하는 경우 다이제스트주기를 여러 번 실행하여 &quot;안정화&quot;해야 할 수도 있습니다. AngularJS 사용자는 종종 다이제스트주기를 극복하기 위해 난해한 기술에 의존해야하며 경우에 따라 많은 감시자와 함께 범위를 최적화 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue 는 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소를 사용하여 컨텐츠의 배포 아울렛 역할을 하는 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components 스펙 초안&lt;/a&gt; 에서 영감을 얻은 컨텐츠 분배 API를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vue는 &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; 및 &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnj&lt;/a&gt; 에서도 사용할 수 있습니다 (cdnj는 동기화하는 데 시간이 걸리므로 최신 릴리스를 아직 사용할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue는 Angular보다 의견이 많지 않으므로 응용 프로그램을 구성하는 방법에 대한 제한없이 다양한 빌드 시스템에 대한 공식 지원을 제공합니다. 많은 개발자들이 이러한 자유를 누리고 있지만, 어떤 개발자는 단 하나의 올바른 방법으로 응용 프로그램을 빌드하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vue는 API 및 디자인 측면에서 AngularJS보다 훨씬 간단합니다. 사소한 응용 프로그램을 작성하기에 충분한 학습은 일반적으로 하루 미만이 소요되며 AngularJS에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vue는 전환이 언제 종료되었는지 알기 위해 이벤트 리스너를 연결해야합니다. 적용된 CSS 규칙의 유형에 따라 &lt;code&gt;transitionend&lt;/code&gt; 또는 &lt;code&gt;animationend&lt;/code&gt; 일 수 있습니다 . 둘 중 하나만 사용하는 경우 Vue는 자동으로 올바른 유형을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vue는 다음 컨텍스트에서 요소 또는 구성 요소에 대한 입력 / 이동 전환을 추가 할 수 있는 &lt;code&gt;transition&lt;/code&gt; 래퍼 구성 요소를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue는 항목이 DOM에서 삽입, 업데이트 또는 제거 될 때 전환 효과를 적용하는 다양한 방법을 제공합니다. 여기에는 다음과 같은 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue는 레거시 브라우저 지원에 필요할 때 가장 일반적으로 사용되는 키 코드에 대한 별칭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vue는 야심 찬 단일 페이지 응용 프로그램을 빠르게 비계하기위한 &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;공식 CLI&lt;/a&gt; 를 제공합니다 . 최신 프론트 엔드 워크 플로우를 위해 배터리가 포함 된 빌드 설정을 제공합니다. 핫 리로드, 린트 온 저장 및 프로덕션 준비 빌드로 시작하고 실행하는 데 몇 분 밖에 걸리지 않습니다. 자세한 내용 &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;은 Vue CLI 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue는 일반 JavaScript 객체 및 완전 자동 계산 속성에 대한 눈에 띄지 않는 반응성을 제공합니다. Ember에서는 Ember Objects의 모든 것을 감싸고 계산 된 속성에 대한 종속성을 수동으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vue는 템플릿을 사용하여 대부분의 경우 HTML을 빌드 할 것을 권장합니다. 그러나 JavaScript의 전체 프로그래밍 기능이 실제로 필요한 상황이 있습니다. 여기서는 템플릿 대신 컴파일러에 더 가까운 &lt;strong&gt;render 함수&lt;/strong&gt; 인 &lt;strong&gt;render 함수를&lt;/strong&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue는 가능한 한 효율적으로 요소를 렌더링하려고 시도하며 종종 처음부터 렌더링하는 대신 요소를 재사용합니다. Vue를 매우 빠르게 만드는 것 외에도 유용한 이점이 있습니다. 예를 들어, 사용자가 여러 로그인 유형간에 전환 할 수 있도록 허용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vue는 &lt;code&gt;_&lt;/code&gt; 접두사를 사용하여 자체 개인 속성을 정의하므로 동일한 접두사 (예 : &lt;code&gt;_update&lt;/code&gt; )를 사용하면 인스턴스 속성을 덮어 쓸 위험이 있습니다. Vue가 현재 특정 속성 이름을 사용하고 있지 않은지 확인하더라도 이후 버전에서는 충돌이 발생하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue는 대상 요소에 CSS 전환 또는 애니메이션이 적용되었는지 여부를 자동으로 스니핑합니다. 그렇다면 CSS 전환 클래스가 적절한 타이밍에 추가 / 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue는 관찰 된 배열의 돌연변이 방법을 래핑하여 뷰 업데이트도 트리거합니다. 랩핑 된 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vue의 커뮤니티는 엄청나게 빠르게 성장하고 있습니다.이 글을 읽고 있다면 참여할 준비가 된 것입니다. 환영합니다!</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vue의 템플릿 구문은 JavaScript 표현식의 모든 기능을 활용하는 반면, Handlebars의 표현식 및 도우미 구문은 의도적으로 상당히 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vue의 전이 시스템은 상당히 크게 바뀌 었으며 현재는 &lt;code&gt;transition&lt;/code&gt; 속성 대신 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 래퍼 요소를 사용 합니다. 자세한 내용 은 새로운 &lt;a href=&quot;transitions&quot;&gt;전환 가이드&lt;/a&gt; 를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vue의 전환 시스템은 입력, 출발 및 목록에 애니메이션을 적용하는 여러 가지 간단한 방법을 제공하지만 데이터 자체에 애니메이션을 적용하는 방법은 무엇입니까? 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile (템플릿)</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component (id, [definition])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete (target, propertyName / index)</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive (id, [definition])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extend (옵션)</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter (id, [definition])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.js를 사용하면 일반적인 텍스트 형식을 적용하는 데 사용할 수있는 필터를 정의 할 수 있습니다. 필터는 &lt;strong&gt;콧수염 보간과 &lt;code&gt;v-bind&lt;/code&gt; 식&lt;/strong&gt; (후자는 2.1.0 이상에서 지원됨)의 두 위치에서 사용할 수 있습니다. &quot;파이프&quot;기호로 표시되는 JavaScript 표현식 끝에 필터를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js는 렌더링 된 DOM을 기본 Vue 인스턴스의 데이터에 선언적으로 바인딩 할 수있는 HTML 기반 템플릿 구문을 사용합니다. 모든 Vue.js 템플릿은 사양을 준수하는 브라우저와 HTML 파서로 파싱 할 수있는 유효한 HTML입니다.</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin (믹스 인)</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick ([콜백, 컨텍스트])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable (객체)</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set (target, propertyName / 인덱스, 값)</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">Vue.use (플러그인)</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0이 출시되었지만이 안내서는 1.0으로의 마이그레이션에만 적용됩니다. 오타입니까? 또한 Vuex 1.0과 2.0이 동시에 출시 된 것 같습니다. 무슨 일이야? 어떤 것을 사용해야하고 Vue 2.0과 호환되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Vue School에서 무료 강의를 시청하십시오</target>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Vue Mastery에서 무료 비디오 코스 시청</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Vue School에서 무료 비디오 코스 시청</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Vue School에서 무료 비디오 강의 시청</target>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Vue Mastery에 대한 비디오 설명보기</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Vue 인스턴스에서 표현식 또는 계산 된 함수가 변경되는지 확인하십시오. 콜백은 새 값과 이전 값으로 호출됩니다. 이 식은 점으로 구분 된 경로 만 허용합니다. 더 복잡한 표현식의 경우 함수를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">감시자는 수치 속성의 변경 사항을 다른 속성으로 애니메이션 할 수 있습니다. 초록에서는 복잡하게 들릴 수 있으므로 &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock을&lt;/a&gt; 사용하여 예제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">&lt;code&gt;vm.$watch&lt;/code&gt; 를 통해 생성 된 감시자 는 이제 관련 구성 요소를 다시 렌더링하기 전에 시작됩니다. 이를 통해 구성 요소를 다시 렌더링하기 전에 상태를 추가로 업데이트 할 수 있으므로 불필요한 업데이트를 피할 수 있습니다. 예를 들어 구성 요소 소품을보고 소품이 변경 될 때 구성 요소 자체의 데이터를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">우리는 또한 편견을 피하기 위해 매우 열심히 노력합니다. 핵심 팀으로서 Vue를 좋아합니다. 우리가 다른 어떤 것보다 더 잘 해결한다고 생각하는 몇 가지 문제가 있습니다. 우리가 그것을 믿지 않는다면, 우리는 그것에 노력하지 않을 것입니다. 우리는 공정하고 정확하기를 원합니다. React의 방대한 대체 렌더러 에코 시스템이나 Knockout의 브라우저 지원과 같은 다른 라이브러리가 IE6로 다시 지원되는 등 우리는 이러한 라이브러리도 나열하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">이 기술을 이전 구현과 결합하여 가능한 모든 변경 사항을 애니메이션으로 만들 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">이제 사용자 정의 입력에서 직접 &lt;code&gt;v-model&lt;/code&gt; 사용할 수 있습니다 . 이는 일반 입력과보다 일관성이있을뿐만 아니라 Vuex 친화적 인 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; 에 배열을 전달하여 클래스 목록을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; 에 객체를 전달하여 클래스 를 동적으로 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 지시문을 사용하여 배열을 기반으로 항목 목록을 렌더링 할 수 있습니다 . &lt;code&gt;v-for&lt;/code&gt; 지시자의 형태로 특수 구문 요구 &lt;code&gt;item in items&lt;/code&gt; , &lt;code&gt;items&lt;/code&gt; 소스 데이터 배열 및 &lt;code&gt;item&lt;/code&gt; 인 &lt;strong&gt;별명&lt;/strong&gt; 에 반복되는 배열 요소를 :</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 지시문을 사용하여 DOM 이벤트를 수신하고 트리거 될 때 일부 JavaScript를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">이 단일 이벤트 허브를 사용하여 구성 요소 간의 통신을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">우리 토론 &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;구성 요소 사이의 전환&lt;/a&gt; 이후,하지만 당신은 원시 요소들 사이의 전환은 사용 할 수 있습니다 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; . 가장 일반적인 두 요소 전환 중 하나는 목록 컨테이너와 빈 목록을 설명하는 메시지 사이입니다.</target>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">업데이트를 통해 유사한 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">새로운 Angular는 AngularJS와 완전히 다른 프레임 워크이므로 별도의 섹션이 있습니다. 예를 들어, 그것은 일급 컴포넌트 시스템을 특징으로하며 많은 구현 세부 사항이 완전히 재 작성되었으며 API도 상당히 크게 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">우리는 이미 첫 Vue 앱을 만들었습니다! 이것은 문자열 템플릿을 렌더링하는 것과 매우 비슷하지만 Vue는 많은 작업을 수행했습니다. 이제 데이터와 DOM이 연결되었으며 모든 것이 &lt;strong&gt;반응 형&lt;/strong&gt; 입니다. 우리가 어떻게 알아? 브라우저의 JavaScript 콘솔 ( &lt;code&gt;app.message&lt;/code&gt; 페이지에서)을 열고 app.message 를 다른 값으로 설정하십시오 . 위의 렌더링 된 예제는 이에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">서버 렌더링 Vue 응용 프로그램을 만들기위한 독립형 가이드를 만들었습니다. 이것은 클라이언트 측 Vue 개발, 서버 측 Node.js 개발 및 웹팩에 이미 익숙한 사용자를위한 매우 심층적 인 안내서입니다. &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt; 에서 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">&amp;ldquo;제출&amp;rdquo;텍스트가 대부분 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 안에 렌더링되기를 원할 수 있습니다 . 대체 콘텐츠를 &quot;제출&quot;하기 위해 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 태그 사이에 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">다음과 같이이 대체 콘텐츠를 대체하여 사용자 대신 이름을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">이 구성 요소를 재사용하여 사용자가 여러 목록 (예 : 쇼핑, 위시리스트, 일일 집안일 등)을 유지할 수 있도록 할 수 있습니다. 그래도 문제가 있습니다. 컴포넌트의 모든 인스턴스가 동일한 데이터 오브젝트를 참조하므로 한 목록의 제목을 변경하면 다른 모든 목록의 제목도 변경됩니다. 할 일을 추가 / 편집 / 삭제할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">인수를 괄호로 묶고 인수를 쉼표로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">JavaScript 세계가 빠르게 움직이기 때문에이 문서를 최신 상태로 유지하는 데 도움 을 드리고자 &lt;strong&gt;합니다&lt;/strong&gt; . 정확하지 않은 것 또는 부정확 한 것이 발견 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;되면 문제&lt;/a&gt; 를 열어 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">우리는 &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;나중에 &lt;/a&gt;&lt;a href=&quot;render-function&quot;&gt;렌더링 함수에&lt;/a&gt; 대해 논의 할 때 VNode를 더 자세히 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">다음 섹션에서 이러한 후크에 전달 된 인수 (예 : &lt;code&gt;el&lt;/code&gt; , &lt;code&gt;binding&lt;/code&gt; , &lt;code&gt;vnode&lt;/code&gt; 및 &lt;code&gt;oldVnode&lt;/code&gt; )를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">&lt;a href=&quot;components&quot;&gt;구성 요소 시스템&lt;/a&gt; 에 대해서는 나중에 자세히 설명 하겠습니다 . 지금은 모든 Vue 구성 요소도 Vue 인스턴스라는 것을 알고 있으므로 동일한 옵션 개체를 수락하십시오 (몇 가지 루트 별 옵션 제외).</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">우리는 단순히 각 언어의 규칙을 따르고 있습니다. JavaScript 내에서 camelCase가 더 자연 스럽습니다. HTML 내에서 케밥 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">그러나 여전히 필터와 Vue 1.0에 의해 여전히 제한되어 있으므로 Vue 2.0으로의 업그레이드를 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">우리는 Vue.js 코어의 가장 기본적인 기능을 간략하게 소개했습니다.이 가이드의 나머지 부분에서는 그 기능 및 기타 고급 기능에 대해 훨씬 더 자세한 내용을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">우려의 분리는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">할 수있는 일</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; 가 실제로 반환하는 것은 무엇입니까 ? 그것은 아니다 &lt;em&gt;정확히&lt;/em&gt; 진짜 DOM 요소. 자식 노드에 대한 설명을 포함하여 페이지에서 렌더링해야하는 노드 종류를 설명하는 정보가 포함되어 있으므로 더 정확하게 &lt;code&gt;createNodeDescription&lt;/code&gt; 으로 이름을 지정할 수 있습니다 . 이 노드 설명을 &quot;가상 노드&quot;라고하며 일반적으로 &lt;strong&gt;VNode로&lt;/strong&gt; 약칭합니다 . &quot;가상 DOM&quot;은 Vue 구성 요소 트리에 의해 구축 된 전체 VNode 트리라고합니다.</target>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Vue.js은 (는) 무엇 이죠?</target>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 가 여러 아이들, 그들은 결국 하나의 아이를 평가해야합니다. 첫 번째 아이 이외의 아이는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">때 &lt;code&gt;isActive&lt;/code&gt; truthy이며, 렌더링 된 HTML은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;isActive&lt;/code&gt; 또는 &lt;code&gt;hasError&lt;/code&gt; 이 변경 클래스 목록이 그에 따라 업데이트됩니다. 예를 들어 &lt;code&gt;hasError&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 클래스 목록은 &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">때 &lt;code&gt;ref&lt;/code&gt; 함께 사용되는 &lt;code&gt;v-for&lt;/code&gt; , 당신이 얻을 심판은 데이터 소스를 미러링 하위 구성 요소를 포함하는 배열 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 변경의 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 항상 교체 대신 패치됩니다 전환이 발생됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Vue가 &lt;code&gt;v-for&lt;/code&gt; 로 렌더링 된 요소 목록을 업데이트 할 때 기본적으로 &quot;in-place patch&quot;전략을 사용합니다. 데이터 항목의 순서가 변경된 경우, 항목의 순서와 일치하도록 DOM 요소를 이동하는 대신 Vue는 각 요소를 제자리에 패치하여 해당 특정 인덱스에서 렌더링해야하는 요소를 반영합니다. 이는 Vue 1.x 의 &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; 동작과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Vue가 지시문을 처리 할 때 &lt;code&gt;v-for&lt;/code&gt; 가 &lt;code&gt;v-if&lt;/code&gt; 보다 우선 순위가 높으므로이 템플리트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModel이 파괴되면 모든 이벤트 리스너가 자동으로 제거됩니다. 스스로 청소하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Vue 인스턴스가 작성되면 &lt;code&gt;data&lt;/code&gt; 오브젝트 에서 찾은 모든 특성 이 Vue의 &lt;strong&gt;반응성 시스템에 추가&lt;/strong&gt; 됩니다. 해당 속성 값이 변경되면보기가 &quot;반응&quot;하여 새 값과 일치하도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">브라우저는이 코드를 읽을 때 확장 된 패밀리를 추적하기 위해 가계도를 작성할 수있는 것처럼 모든 것을 추적 할 수 있도록 &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;&quot;DOM 노드&quot;&lt;/a&gt; 트리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 내부에서 구성 요소를 토글하면 구성 요소 에 따라 &lt;code&gt;activated&lt;/code&gt; 및 &lt;code&gt;deactivated&lt;/code&gt; 라이프 사이클 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">믹스 인과 컴포넌트 자체에 겹치는 옵션이 포함 된 경우 적절한 전략을 사용하여 &quot;병합&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">&lt;code&gt;transition&lt;/code&gt; 구성 요소에 싸인 요소를 삽입하거나 제거하면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">밖으로 만들 때 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소, 템플릿은 결국 더 단지 제목보다는이 포함됩니다 :</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">구성 요소가 비좁거나 읽기 어려운 느낌이 들기 시작하면 여러 줄 속성 사이에 공백을 추가하면 다시 쉽게 감을 수 있습니다. Vim과 같은 일부 편집기에서는 이와 같은 서식 옵션을 사용하면 키보드를 사용하여 쉽게 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">사용자 지정 옵션을 병합하면 기존 값을 덮어 쓰는 기본 전략을 사용합니다. 사용자 정의 로직을 사용하여 사용자 정의 옵션을 병합하려면 &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; 에 함수를 첨부해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">결정적인 때 &lt;strong&gt;구성 요소를&lt;/strong&gt; , &lt;code&gt;data&lt;/code&gt; 함수로 선언해야 그 반환 초기 데이터 객체, 동일한 정의를 사용하여 만든 많은 경우가있을 것입니다 때문입니다. &lt;code&gt;data&lt;/code&gt; 에 일반 객체를 사용하면 생성 된 모든 인스턴스에서 동일한 객체가 &lt;strong&gt;참조&lt;/strong&gt; 로 &lt;strong&gt;공유됩니다&lt;/strong&gt; ! &lt;code&gt;data&lt;/code&gt; 함수 를 제공함으로써 , 새로운 인스턴스가 생성 될 때마다 호출하여 초기 데이터의 새로운 사본을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">PascalCase로 구성 요소를 정의 할 때 해당 사용자 정의 요소를 참조 할 때 두 경우 모두를 사용할 수 있습니다. 즉 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; 이 모두 허용됩니다. 그러나 케밥 케이스 이름 만 DOM에서 직접 유효합니다 (즉, 문자열이 아닌 템플릿).</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">kebab-case로 컴포넌트를 정의 할 때 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 과 같이 해당 사용자 정의 요소를 참조 할 때 kebab-case도 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">계산 된 각 속성에 종속성이 거의없는 매우 간단한 식만 포함 된 경우 제대로 작동하는지 확인하는 테스트를 작성하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">속성 이름 / 키를 포함 할 때 객체의 인수 순서는 &lt;code&gt;(name, value)&lt;/code&gt; 입니다. lodash와 같은 일반적인 객체 반복자와보다 일관성을 유지하는 것이 이제는 &lt;code&gt;(value, name)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 를 포함 할 때 배열의 인수 순서는 &lt;code&gt;(index, value)&lt;/code&gt; 입니다. &lt;code&gt;forEach&lt;/code&gt; 및 &lt;code&gt;map&lt;/code&gt; 과 같은 JavaScript의 기본 배열 메소드와보다 일관성을 유지하는 것이 이제 &lt;code&gt;(value, index)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">반복하는이 객체 위로, 순서는의 열거 순서를 기준으로 할 때 &lt;code&gt;Object.keys()&lt;/code&gt; 한다, &lt;strong&gt;하지&lt;/strong&gt; 자바 스크립트 엔진 구현에 걸쳐 일관성을 보장.</target>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">키보드 이벤트를들을 때 종종 특정 키를 확인해야합니다. Vue를 사용하면 주요 이벤트를 수신 할 때 &lt;code&gt;v-on&lt;/code&gt; 용 키 수정자를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">기본 DOM 이벤트를 청취 할 때 메소드는 기본 이벤트를 유일한 인수로받습니다. 인라인 명령문을 사용하는 경우 명령문은 특수 &lt;code&gt;$event&lt;/code&gt; 특성에 액세스 할 수 있습니다. &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">편집기에서 사전 순으로 구성하면 앱의 기본 구성 요소가 모두 함께 나열되어 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">쿼리 매개 변수에 배열을 전달할 때 QueryString 구문은 더 이상 &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; 가 아니며 대신 새 구문은 &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; 입니다. 내부적으로 &lt;code&gt;$route.query.users&lt;/code&gt; 는 여전히 배열이지만 쿼리에 매개 변수가 하나만 있으면 &lt;code&gt;/foo?users=Tom&lt;/code&gt; 이 경로에 직접 액세스 할 때 라우터가 &lt;code&gt;users&lt;/code&gt; 를 기대하는지 알 수있는 방법이 없습니다 배열입니다. 이 때문에 계산 된 속성을 추가하고 &lt;code&gt;$route.query.users&lt;/code&gt; 의 모든 참조를이를 대체하는 것을 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">prop 유효성 검사가 실패하면 Vue는 콘솔 경고를 생성합니다 (개발 빌드를 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">컴포넌트를 등록 할 때 항상 이름이 부여됩니다. 예를 들어, 글로벌 등록에서 지금까지 본 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정하면 템플릿에서 찾은 HTML 주석이 유지되고 렌더링됩니다. 기본 동작은 버리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">그러나 이러한 구성 요소 간을 전환 할 때 성능상의 이유로 상태를 유지하거나 다시 렌더링하지 않는 것이 좋습니다. 예를 들어 탭 인터페이스를 약간 확장 할 때 :</target>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">때 &lt;code&gt;inline-template&lt;/code&gt; 특별한 속성은 하위 구성 요소에 존재하는 구성 요소는 오히려 분산 컨텐츠로 치료하는 것보다, 자신의 템플릿의 내부 콘텐츠를 사용합니다. 이를 통해보다 유연한 템플릿 작성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">구성 요소가 렌더링되면 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; 이&amp;ldquo;Your Profile&amp;rdquo;로 바뀝니다. 슬롯에는 HTML을 포함한 모든 템플릿 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">글로벌 필터의 이름이 로컬 필터와 동일한 경우 로컬 필터가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">페이지가로드되면 해당 요소에 초점이 맞춰집니다 (참고 : 모바일 Safari에서는 &lt;code&gt;autofocus&lt;/code&gt; 이 작동하지 않습니다). 실제로이 페이지를 방문한 후 다른 항목을 클릭하지 않은 경우 위의 입력에 초점이 맞춰져야합니다. 이제 이것을 달성하는 지시어를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 값이 객체 인 경우 구성 요소의 모든 인스턴스에서 공유됩니다. 예를 &lt;code&gt;TodoList&lt;/code&gt; 데이터가 있는 TodoList 컴포넌트를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">동일한 노드에 존재하는 경우 &lt;code&gt;v-for&lt;/code&gt; 가 &lt;code&gt;v-if&lt;/code&gt; 보다 우선 순위가 높습니다 . 즉 , 루프의 각 반복 에서 &lt;code&gt;v-if&lt;/code&gt; 가 개별적으로 실행됩니다. 아래와 같이 &lt;em&gt;일부&lt;/em&gt; 항목 에 대해서만 노드를 렌더링하려고 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">이 데이터가 변경되면보기가 다시 렌더링됩니다. &lt;code&gt;data&lt;/code&gt; 속성 은 인스턴스가 생성 될 때 존재 &lt;strong&gt;하는&lt;/strong&gt; 경우 에만 &lt;strong&gt;반응&lt;/strong&gt; 한다는 점에 유의해야합니다 . 즉, 다음과 같은 새 속성을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">이 메소드가 동일한 플러그인에서 여러 번 호출되면 플러그인은 한 번만 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;태그 이름이 동일한&lt;/strong&gt; 요소간에 전환 할 때 Vue에 고유 한 &lt;code&gt;key&lt;/code&gt; 속성 을 부여하여 고유 한 요소임을 Vue에 알려야 합니다. 그렇지 않으면 Vue의 컴파일러는 효율성을 위해 요소의 내용 만 바꿉니다. 기술적으로 불필요 할 때에도 &lt;strong&gt;항상 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 구성 요소 내에 여러 항목을 입력하는 것이 좋습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">소품 바인딩에 사용될 때는 소품이 하위 구성 요소에 올바르게 선언되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">구성 요소에서 사용될 때 &lt;code&gt;v-model&lt;/code&gt; 은 대신 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">구성 요소에 사용하는 경우, &lt;code&gt;v-on&lt;/code&gt; 이제 사용자 정의 이벤트를 수신 &lt;code&gt;$emit&lt;/code&gt; 해당 구성 요소에 의해 테드. 루트 요소에서 기본 DOM 이벤트를 수신하려면 &lt;code&gt;.native&lt;/code&gt; 수정자를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">일반 요소에서 사용될 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;원시 DOM 이벤트&lt;/strong&gt;&lt;/a&gt; 만 청취합니다 . 사용자 정의 요소 구성 요소에서 사용될 때 해당 하위 구성 요소에서 생성 된 &lt;strong&gt;사용자 정의 이벤트를&lt;/strong&gt; 청취합니다 .</target>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 가있는 요소 / 컴포넌트에서 사용될 경우 등록 된 참조는 DOM 노드 또는 컴포넌트 인스턴스를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;style&lt;/code&gt; 속성 을 바인딩하는 데 사용되는 경우 배열 또는 객체와 같은 추가 값 유형을 지원합니다. 자세한 내용은 아래 링크 된 가이드 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 함께 사용하는 경우 다음과 같이 중첩하십시오.</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">함께 사용될 때, &lt;code&gt;v-if&lt;/code&gt; , &lt;code&gt;v-for&lt;/code&gt; 보다 높은 우선 순위 갖는 &lt;code&gt;v-if&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;목록 렌더링 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">v-if와 함께 사용하면 v-for가 v-if보다 우선 순위가 높습니다. 자세한 내용은 &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;목록 렌더링 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 와 함께 사용하면 이제 잘못된 값은 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 입니다. 이것은 &lt;code&gt;0&lt;/code&gt; 을 의미 하며 빈 문자열은 진실로 렌더링됩니다. 예를 들어, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; 은 &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">인수없이 사용하면 속성 이름-값 쌍을 포함하는 객체를 바인딩하는 데 사용할 수 있습니다. 이 모드에서 &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;style&lt;/code&gt; 은 배열 또는 객체를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;로컬 등록을&lt;/a&gt; 사용할 때 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 함수를 직접 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; 또는 &lt;code&gt;vueify&lt;/code&gt; 를 사용할 때 &lt;code&gt;*.vue&lt;/code&gt; 파일 내의 템플릿 은 빌드시 JavaScript로 사전 컴파일됩니다. 최종 번들에 컴파일러가 실제로 필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">JavaScript 전용 전환을 사용 &lt;strong&gt;하는 경우 &lt;code&gt;done&lt;/code&gt; 콜백이 &lt;code&gt;enter&lt;/code&gt; 및 &lt;code&gt;leave&lt;/code&gt; 훅에 필요합니다&lt;/strong&gt; . 그렇지 않으면 후크가 동기식으로 호출되고 전환이 즉시 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">단일 파일 구성 요소를 사용하는 경우 구성 요소 내부의 CSS는 JavaScript를 통해 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그 로 동적으로 주입됩니다 . 이는 런타임 비용이 적으며 서버 측 렌더링을 사용하는 경우 &quot;스타일이 지정되지 않은 컨텐츠의 플래시&quot;가 발생합니다. 모든 구성 요소에서 CSS를 동일한 파일로 추출하면 이러한 문제를 피할 수 있으며 CSS 축소 및 캐싱 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vue를 사용하는 경우 &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; 를 브라우저에 설치하여 보다 사용자 친화적 인 인터페이스에서 Vue 응용 프로그램을 검사하고 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">Webpack 또는 Browserify와 같은 빌드 도구를 사용하는 경우 프로덕션 모드는 Vue의 소스 코드 내 에서 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 에 의해 결정 되며 기본적으로 개발 모드에 있습니다. 두 빌드 도구 모두 Vue의 프로덕션 모드를 활성화하기 위해이 변수를 덮어 쓰는 방법을 제공하며 빌드 중에 축소 기에서 경고가 제거됩니다. 모든 &lt;code&gt;vue-cli&lt;/code&gt; 템플릿에는 미리 구성되어 있지만 어떻게 수행되는지 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">DOM 내 템플릿 (HTML 파일로 직접 작성된 템플릿)을 사용하는 경우 브라우저가 속성 이름을 소문자로 강제 변환하므로 대문자로 키 이름을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">DOM 내 템플릿 또는 JavaScript 템플릿 문자열을 사용하는 경우 템플릿 간 렌더링 기능 컴파일이 즉시 수행됩니다. 대개 대부분의 경우 빠르지 만 응용 프로그램이 성능에 민감한 경우에는 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">컴포넌트 에서 &lt;code&gt;data&lt;/code&gt; 속성을 사용할 때 (예 : &lt;code&gt;new Vue&lt;/code&gt; 제외 ) 값은 객체를 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">버튼을 클릭하면 모든 게시물의 텍스트를 확대해야한다는 부모와 통신해야합니다. 다행히 Vue 인스턴스는이 문제를 해결하기 위해 사용자 지정 이벤트 시스템을 제공합니다. 부모는 네이티브 DOM 이벤트와 마찬가지로 &lt;code&gt;v-on&lt;/code&gt; 을 사용하여 자식 구성 요소 인스턴스의 모든 이벤트를 수신하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; 구성 요소를 정의 할 때 다음과 같이 &lt;code&gt;data&lt;/code&gt; 가 오브젝트를 직접 제공하지 않은 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">동적 구성 요소를 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 는 비활성 구성 요소 인스턴스를 손상시키지 않고 캐시합니다. &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 마찬가지로 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 는 추상 구성 요소입니다. DOM 요소 자체를 렌더링하지 않으며 구성 요소 상위 체인에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Vue 인스턴스를 만들 때 &lt;strong&gt;옵션 객체&lt;/strong&gt; 를 전달 &lt;strong&gt;합니다&lt;/strong&gt; . 이 안내서의 대부분은 이러한 옵션을 사용하여 원하는 동작을 만드는 방법을 설명합니다. 참조를 위해 &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API 참조 서&lt;/a&gt; 에서 전체 옵션 목록을 찾아 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">색인을 사용하여 항목을 직접 설정하는 경우 (예 : &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 소품을 기준으로 제목 만 생성하는 구성 요소를 시작하면 다음과 같이 빠르게 도달합니다.</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">자세히 살펴보면 이러한 구성 요소가 실제로 렌더링 트리에서 서로의 후손 &lt;em&gt;이자&lt;/em&gt; 조상이 될 것입니다 . &lt;code&gt;Vue.component&lt;/code&gt; 를 사용 하여 컴포넌트를 전역으로 등록하면 이 역설이 자동으로 해결됩니다. 그게 너라면, 여기에서 독서를 멈출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">배열의 길이를 수정하면 (예 : &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">일반 JavaScript 객체를 &lt;code&gt;data&lt;/code&gt; 옵션 으로 Vue 인스턴스에 전달하면 Vue는 모든 속성 을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter / setter&lt;/a&gt; 로 변환합니다 . 이것은 ES5 전용이며 shimable 기능이 아니기 때문에 Vue는 IE8 이하를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 컴포넌트를 글로벌로 등록 하면 글로벌 ID가 컴포넌트의 &lt;code&gt;name&lt;/code&gt; 옵션 으로 자동 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">숫자를 업데이트하면 입력 아래에 변경 내용이 표시됩니다. 이것은 좋은 데모를 만들지 만 유효한 CSS 색상과 같이 숫자로 직접 저장되지 않은 것은 어떻습니까? &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js &lt;/a&gt;로이를 달성하는 방법은 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;공급 업체 접두사&lt;/a&gt; 가 필요한 CSS 속성 ( 예 : &lt;code&gt;transform&lt;/code&gt; )을 사용 하면 Vue가 자동으로 적용된 스타일에 적절한 접두사를 감지하고 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">사용자 컴포넌트 에서 &lt;code&gt;class&lt;/code&gt; 속성 을 사용하면 해당 클래스가 컴포넌트의 루트 요소에 추가됩니다. 이 요소의 기존 클래스는 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">다음과 같이 슬롯 내부의 데이터를 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">슬롯이 여러 개인 경우 &lt;em&gt;모든&lt;/em&gt; 슬롯에 대해 전체 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 기반 구문을 사용 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">동일하고 좋은 옵션이 여러 개있는 경우 일관성을 유지하기 위해 임의의 선택을 할 수 있습니다. 이 규칙에서는 허용 가능한 각 옵션을 설명하고 기본 선택을 제안합니다. 이는 일관성 있고 합당한 이유가있는 한 자신의 코드베이스에서 다른 선택을 자유롭게 할 수 있음을 의미합니다. 그래도 좋은 이유가 있으십시오! 커뮤니티 표준에 적응하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">마이그레이션은 어디에서 시작해야합니까?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">일반 JavaScript로 쉽게 수행 할 수있는 곳이라면 Vue 렌더 함수는 독점적 인 대안을 제공하지 않습니다. 예를 들어, &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-for&lt;/code&gt; 를 사용하는 템플릿 에서 :</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">현재 Vue 인스턴스가 서버에서 실행 중인지 여부</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">템플릿에서 모든 블로그 게시물의 글꼴 크기를 제어하는 ​​데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">다음과 같이 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">사용중인 더 이상 사용되지 않는 기능 대부분은 찾기 및 바꾸기로 업그레이드 할 수 있지만 몇 분 정도 걸릴 수 있습니다. 현재 모범 사례를 따르지 않는 경우 Vue 2.0은 강제로 더 열심히 노력할 것입니다. 이것은 장기적으로는 좋은 일이지만 중요한 리팩토링을 의미 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">렌더링됩니다 :</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">Vue는 React와 마찬가지로 확장되지만 jQuery와 마찬가지로 축소됩니다. 맞습니다. 시작하려면 단일 스크립트 태그를 페이지에 놓기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">공백이없는 속성 값은 HTML에 따옴표가 필요하지 않지만,이 방법은 종종 공백 을 &lt;em&gt;피하여&lt;/em&gt; 속성 값을 읽기 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">대부분의 경우 계산 된 속성이 더 적합하지만 사용자 지정 감시자가 필요한 경우가 있습니다. 그렇기 때문에 Vue가 &lt;code&gt;watch&lt;/code&gt; 옵션을 통해 데이터 변경에 반응하는보다 일반적인 방법을 제공합니다 . 데이터 변경에 대한 응답으로 비동기식 또는 값 비싼 작업을 수행하려는 경우 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">명시 적으로 정의 된 소품이 정보를 하위 구성 요소로 전달하는 데 선호되지만 구성 요소 라이브러리 작성자는 해당 구성 요소가 사용될 수있는 컨텍스트를 항상 예측할 수는 없습니다. 그렇기 때문에 컴포넌트가 컴포넌트의 루트 요소에 추가되는 임의의 속성을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">템플릿은 대부분의 구성 요소에 적합하지만이 중 하나가 아님은 분명합니다. &lt;code&gt;render&lt;/code&gt; 함수로 다시 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">왜 리스너는 HTML입니까?</target>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">캐싱이 필요한 이유는 무엇입니까? 고가의 계산 속성 &lt;strong&gt;A&lt;/strong&gt; 가 있다고 가정 해보십시오 . 거대한 배열을 반복하고 많은 계산을 수행해야합니다. 그런 다음 &lt;strong&gt;A에&lt;/strong&gt; 의존하는 다른 계산 된 속성을 가질 수 있습니다 . 캐싱을하지 않으면 필요 이상으로 &lt;strong&gt;A&lt;/strong&gt; 's getter를 여러 번 실행할 수 있습니다 ! 캐싱을 원하지 않는 경우 방법을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">다음과 유사하게 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">대신 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; 구성 요소를 사용 하여 고급 JavaScript 응용 프로그램 영역에 들어갑니다. 즉, 아직 추가하지 않은 경우 몇 가지 추가 도구를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">함께 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 과 &lt;code&gt;$attrs&lt;/code&gt; 수동 종종 바람직하다에 당신이 속성을 전달하고자하는 요소를 결정할 수 있습니다 &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;기본 구성 요소&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">빌드 도구</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">구성 요소 포함</target>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">ES2015 기호를 사용하면 기능이 &lt;code&gt;provide&lt;/code&gt; 되고 객체가 &lt;code&gt;inject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">MobX로</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">객체 기반 구문을 사용하면 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">PascalCase로</target>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">케밥 케이스</target>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">하나의 속성 추가로 특별한 스타일을 추가하지 않고도 원래 전환을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">그렇게 말하면, 탐구 된 많은 주제가 어느 정도 주관적이므로 비교는 일부 React 사용자에게 Vue를 향한 편향으로 보일 것입니다. 우리는 다양한 기술적 취향의 존재를 인정하며,이 비교는 주로 Vue가 선호 사항과 일치 할 때 Vue가 더 적합 할 수있는 이유를 간략하게 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">새로운 전이 시스템을 통해 이제 &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;재사용 가능한 전이에 컴포넌트를 사용할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">이 지식으로 이제 시작한 구성 요소를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">하위 구성 요소 내에서이 페이지에서 다루는 전환 전략과 Vue의 &lt;a href=&quot;transitions&quot;&gt;내장 전환 시스템에서&lt;/a&gt; 제공하는 모든 조합을 사용할 수 있습니다 . 함께 수행 할 수있는 작업에는 제한이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">빌드 도구없이</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">우와-이것은 매우 긴 페이지입니다! 2.0이 완전히 다르다는 것을 의미합니까? 다시 기본을 배워야하며 마이그레이션이 실제로 불가능할까요?</target>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">테스트 가능한 구성 요소 작성</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">플러그인 작성</target>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">예, Vue의 전환조차도 데이터 중심입니다! 동적 전이의 가장 기본적인 예는 &lt;code&gt;name&lt;/code&gt; 속성을 동적 속성에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">Vue는 문자열, 숫자, 배열 또는 일반 객체인지 여부에 따라 자동으로 출력 형식을 지정하므로 더 이상 디버깅 할 필요가 없습니다. JavaScript의 &lt;code&gt;JSON.stringify&lt;/code&gt; 와 동일한 기능을 원한다면 메소드 또는 계산 된 속성에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">당신은 강요된 가치를 그 가치관에 전달 된 가치와 구별하는 이름을 부여함으로써보다 명백해야합니다.</target>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정적 슬롯 내용은 &lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt; 에서 VNode 배열로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">전역 &lt;code&gt;config.keyCodes&lt;/code&gt; 객체 를 통해 &lt;a href=&quot;../api/index#keyCodes&quot;&gt;사용자 정의 키 수정 자 별명&lt;/a&gt; 을 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">믹스 인을 전체적으로 적용 할 수도 있습니다. 주의해서 사용하십시오! 믹스 인을 전체적으로 적용하면 나중에 생성 된 &lt;strong&gt;모든&lt;/strong&gt; Vue 인스턴스에 영향을줍니다 . 올바르게 사용하면 사용자 지정 옵션에 대한 처리 논리를 주입하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">추가 전역 속성 및 구성 요소 옵션을 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">속성에서 JavaScript 후크를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-once&quot;&gt;v-once 지시문&lt;/a&gt; 을 사용하여 데이터 변경시 업데이트되지 않는 일회성 보간을 수행 할 수도 있지만 동일한 노드의 다른 바인딩에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">속성 이름 (일명 키)에 대한 두 번째 인수를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">팩토리 함수에서 &lt;code&gt;Promise&lt;/code&gt; 를 반환 할 수 있으므로 Webpack 2 및 ES2015 구문을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">다음 속성을 제공하여 사용자 정의 전환 클래스를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">입력 및 종료 기간에 대해 별도의 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">당신은 또한 사용할 수 &lt;code&gt;of&lt;/code&gt; 구분 기호로 대신 &lt;code&gt;in&lt;/code&gt; 이 반복자에 대한 자바 스크립트의 구문에 가까운 그래서, :</target>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 를 사용하여 객체의 속성을 반복 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;code&gt;vm.$set&lt;/code&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;code&gt;vm.$set&lt;/code&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;propsData&lt;/code&gt; 옵션을 사용하여 다른 props로 렌더 출력을 어설 션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt; 에서 NPM 패키지의 소스를 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">일반 속성과 마찬가지로 템플릿에서 계산 된 속성에 데이터 바인딩 할 수 있습니다. 뷰는 것을 알고 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 가 에 따라 달라 &lt;code&gt;vm.message&lt;/code&gt; 가 종속 된 바인딩 업데이트 있도록, &lt;code&gt;vm.reversedMessage&lt;/code&gt; 때 &lt;code&gt;vm.message&lt;/code&gt; 가 변경합니다. 그리고 가장 중요한 부분은이 의존성 관계를 선언적으로 생성했다는 것입니다. 계산 된 getter 함수에는 부작용이 없으므로 테스트하고 이해하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">구성 요소 옵션에서 로컬 필터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">원하는 경우 이러한 커넥터 단어를 구성 요소 이름에 포함시킬 수 있지만 순서는 여전히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">일반 요소와 같이 사용자 컴포넌트에서 &lt;code&gt;v-for&lt;/code&gt; 를 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt; 를 통해 노출 된 유효한 키 이름 을 kebab-case로 변환하여 수정 자로 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">슬롯 소품이 정의되지 않은 경우 사용할 폴백을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">여러 열로 주문할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Pug (이전의 Jade)와 같은 전처리기를 사용하여 Vue 템플릿을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">객체에 더 많은 필드를 두어 여러 클래스를 토글 할 수 있습니다. 또한 &lt;code&gt;v-bind:class&lt;/code&gt; 지시문은 일반 &lt;code&gt;class&lt;/code&gt; 속성 과 공존 할 수도 있습니다 . 따라서 다음 템플릿이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">완전한 프로그래밍 언어 (JavaScript)의 강력한 기능을 활용하여보기를 구축 할 수 있습니다. 여기에는 임시 변수, 흐름 제어 및 범위 내에서 JavaScript 값을 직접 참조하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">이 후크에서 구성 요소 상태를 수정할 수 있습니다. 그러나 오류가 발생했을 때 다른 컨텐츠를 단락시키는 템플릿 또는 렌더 기능에 조건을 설정하는 것이 중요합니다. 그렇지 않으면, 컴포넌트는 무한의 렌더 루프에 던져 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">콘솔을 열고 예제 vm을 직접 재생할 수 있습니다. 의 값 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 은 항상의 값에 따라 달라집니다 &lt;code&gt;vm.message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">콘솔을 열고 돌연변이 메소드를 호출 하여 이전 예제의 &lt;code&gt;items&lt;/code&gt; 배열로 재생할 수 있습니다 . 예를 들면 다음과 같습니다. &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">선택적으로 일부 옵션을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;스타일 안내서&lt;/a&gt; 에서 구성 요소 이름에 대한 다른 권장 사항을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;여기&lt;/a&gt; 에서 전체 예제를 볼 수 있습니다 . &lt;code&gt;$parent&lt;/code&gt; 를 사용 하는 &lt;code&gt;getMap&lt;/code&gt; 장점 은 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 의 전체 인스턴스를 노출시키지 않고 &lt;em&gt;모든&lt;/em&gt; 하위 구성 요소 에서 getMap 에 액세스 할 수 있다는 것 입니다. 이를 통해 하위 구성 요소가 의존하는 것을 변경 / 제거 할 염려없이 해당 구성 요소를보다 안전하게 개발할 수 있습니다. &lt;code&gt;props&lt;/code&gt; 와 마찬가지로 이러한 구성 요소 간의 인터페이스는 명확하게 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">당신은 사용할 수있는 &lt;code&gt;v-else&lt;/code&gt; 에 대한 &quot;다른 블록&quot;표시하기 위해 지침을 &lt;code&gt;v-if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 지시문을 사용하여 양식 입력, 텍스트 영역 및 선택 요소에 양방향 데이터 바인딩을 작성할 수 있습니다 . 입력 유형에 따라 요소를 업데이트하는 올바른 방법을 자동으로 선택합니다. 약간 마술 적이지만, &lt;code&gt;v-model&lt;/code&gt; 은 본질적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하는 구문 설탕이며 일부 경우에 특별한주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">다음 수정자를 사용하여 해당 수정 자 키를 누를 때만 마우스 또는 키보드 이벤트 리스너를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">다음 을 사용하여 중첩 된 &lt;code&gt;userProfile&lt;/code&gt; 오브젝트에 새 &lt;code&gt;age&lt;/code&gt; 특성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">프로그래밍 방식의 리스너로 두 가지 문제를 모두 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">당신은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">당신은 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">테스트 할 수 있도록 구성 요소에서 특별한 작업을 수행하지 않아도됩니다. 원시 옵션을 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">구성 요소 이름을 정의 할 때 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vue의 템플릿이 실제로 함수를 렌더링하기 위해 컴파일된다는 것을 알고 싶을 것입니다. 이것은 일반적으로 알 필요가없는 구현 세부 사항이지만 특정 템플릿 기능이 어떻게 컴파일되는지 알고 싶다면 흥미로울 것입니다. 다음은 &lt;code&gt;Vue.compile&lt;/code&gt; 을 사용하여 템플릿 문자열을 라이브 컴파일하는 데모입니다 .</target>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">궁금 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vue 구성 요소는 &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;웹 구성 요소 사양의&lt;/a&gt; 일부인 &lt;strong&gt;사용자 지정 요소&lt;/strong&gt; 와 매우 유사합니다 . Vue의 구성 요소 구문이 사양에 따라 느슨하게 모델링 되었기 때문입니다. 예를 들어 Vue 구성 요소는 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API를&lt;/a&gt; 구현 하며 &lt;code&gt;is&lt;/code&gt; 특수 속성입니다. 그러나 몇 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">표현식에서 메소드를 호출하여 동일한 결과를 얻을 수 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;list#Caveats&quot;&gt;배열&lt;/a&gt; 이나 &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;객체의&lt;/a&gt; 변경 감지주의 사항 을 설명하지 않았 거나 Vue의 반응성 시스템 (예 : &lt;code&gt;data&lt;/code&gt; ) 에서 추적하지 않는 상태에 의존하고있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">다음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">왜 &lt;code&gt;slots()&lt;/code&gt; 와 &lt;code&gt;children&lt;/code&gt; 이 필요한지 궁금 할 것 입니다. 하지 않을까요 &lt;code&gt;slots().default&lt;/code&gt; 과 동일 &lt;code&gt;children&lt;/code&gt; ? 어떤 경우에는 그렇습니다. 그러나 다음과 같은 하위 요소를 가진 기능적 구성 요소가 있다면 어떨까요?</target>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">이 전체 이벤트 청취 방식이&amp;ldquo;문제의 분리&amp;rdquo;에 관한 오래된 규칙을 위반하는 것에 대해 우려 할 수도 있습니다. 안심하십시오-모든 Vue 핸들러 함수와 표현식은 현재 뷰를 처리하는 ViewModel에 엄격하게 바인딩되어 있기 때문에 유지 관리에 어려움이 없습니다. 실제로 &lt;code&gt;v-on&lt;/code&gt; 을 사용하면 몇 가지 이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">부모의 이름을 딴 디렉토리에 자식 구성 요소를 중첩하여이 문제를 해결하려고 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">모든 검색 구성 요소를 &quot;search&quot;디렉토리 아래에 중첩 한 다음 모든 설정 구성 요소를 &quot;settings&quot;디렉토리 아래에 중첩 시키면이 문제를 다르게 해결하려는 유혹을받을 수 있습니다. 다음과 같은 이유로 매우 큰 앱 (예 : 100 개 이상의 구성 요소)에서만이 방법을 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">이것이 Vue가 기존 DOM을 버리고 전체 목록을 다시 렌더링하게 할 것이라고 생각할 수도 있습니다. 운 좋게도 그렇지 않습니다. Vue는 DOM 요소 재사용을 극대화하기 위해 일부 스마트 휴리스틱을 구현하므로 겹치는 객체를 포함하는 다른 어레이로 배열을 바꾸는 것이 매우 효율적인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">일반적으로이를 사용할 필요는 없지만 구성 요소 인스턴스에서 이벤트를 수동으로 수신해야하는 경우에 사용할 수 있습니다. 또한 코드 구성 도구로 유용 할 수 있습니다. 예를 들어, 타사 라이브러리를 통합 할 때이 패턴이 자주 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">라우터 속성을 Vue 인스턴스에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 의 초기 값 이 &quot;hello world&quot; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">여전히 소품의 원래 가치에 접근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">다음을 사용하여 새로운 반응 형 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">이제 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">당신은 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">다음과 같이 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">게시물을 선택하고 &lt;em&gt;보관&lt;/em&gt; 탭으로 전환 한 다음 다시 &lt;em&gt;게시물&lt;/em&gt; 로 전환 하면 선택한 게시물이 더 이상 표시되지 않습니다. 새 탭으로 전환 할 때마다 Vue는 &lt;code&gt;currentTabComponent&lt;/code&gt; 의 새 인스턴스를 생성하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">당신은 나중에 수정의 다른 예를 볼 수 있습니다 &lt;a href=&quot;events#Event-Modifiers&quot;&gt;위한 &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;forms#Modifiers&quot;&gt;대한 &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt; 우리가 그 기능을 탐색 할 때.</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 와 함께 동적으로 할당 된 소품도 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">Vue가 연결된 DOM 요소 내에 인라인 템플릿을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">V- 템플릿은 Vue가 연결된 DOM 요소 외부에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[] 쿼리의 배열 구문이 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">컴포넌트의 옵션 객체</target>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">계산 된 재산</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">소품이 기본값을 설정하는 데 사용되는 데이터 속성</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">문자열 배열 또는</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">키가 로컬 바인딩 이름이고 값이 다음과 같은 객체 :</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">다음과 같은 객체 :</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">조상 구성 요소는 제공하는 속성을 사용하는 자손을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">사용자 정의 JavaScript 후크 :</target>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">CSS 전환 및 애니메이션에 클래스를 자동으로 적용</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">이 데이터를 바탕으로 :</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">대부분의 커뮤니티 코드 예제를 수정하지 않고 복사하여 붙여 넣기 가능</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">확인란과 라디오 버튼은 &lt;code&gt;checked&lt;/code&gt; 속성 및 &lt;code&gt;change&lt;/code&gt; 이벤트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">표시되는 색상</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">하위 컴포넌트는 주입 된 속성이 어디에서 오는지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">다음과 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 동일한 이벤트를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 를 제외하고 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 동일한 소품을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">Vue 1.0과 2.0을 완벽하게 지원</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0 이상에서. 새로운 권장 구문 은 &lt;a href=&quot;#Named-Slots&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0 이상에서. 새로운 권장 구문 은 &lt;a href=&quot;#Scoped-Slots&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">Animate.css와 같은 타사 CSS 애니메이션 라이브러리 통합</target>
        </trans-unit>
        <trans-unit id="640a88fb22096bdf6bd9b9dad17ad19528e33c74" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</source>
          <target state="translated">Velocity.js와 같은 타사 JavaScript 애니메이션 라이브러리 통합</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="6ac4338bb79ac3c4906ce72bafa4a59d6e305be8" translate="yes" xml:space="preserve">
          <source>keep-alive</source>
          <target state="translated">keep-alive</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="1a12478dec83ed6e780245cdd0f96617dd7741bb" translate="yes" xml:space="preserve">
          <source>keyCodes</source>
          <target state="translated">keyCodes</target>
        </trans-unit>
        <trans-unit id="d1f56baedcca5a5064e2a4af53cc11a0ed1c0853" translate="yes" xml:space="preserve">
          <source>maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries</source>
          <target state="translated">컴패니언 라이브러리가 처리하는 라우팅 및 글로벌 상태 관리와 같은 문제로 핵심 라이브러리에 집중</target>
        </trans-unit>
        <trans-unit id="b85dac7f646475d4018a5c35390352f94773c821" translate="yes" xml:space="preserve">
          <source>methods</source>
          <target state="translated">methods</target>
        </trans-unit>
        <trans-unit id="759733aacfdf4712b7e0071157fe636694093bf6" translate="yes" xml:space="preserve">
          <source>mixins</source>
          <target state="translated">mixins</target>
        </trans-unit>
        <trans-unit id="1d06a0d76f000e6edd18de492383983feefced4e" translate="yes" xml:space="preserve">
          <source>model</source>
          <target state="translated">model</target>
        </trans-unit>
        <trans-unit id="ce7af53b728aacb666b36f215a21ab0dd6a5bce4" translate="yes" xml:space="preserve">
          <source>mounted</source>
          <target state="translated">mounted</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="efa63f31b95d88d80597fd77df60f57d92b5656c" translate="yes" xml:space="preserve">
          <source>numbers and calculations</source>
          <target state="translated">숫자와 계산</target>
        </trans-unit>
        <trans-unit id="c4f9f9085b98cae6ac4e1ed2d080effcc14c1a1b" translate="yes" xml:space="preserve">
          <source>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</source>
          <target state="translated">종종 Vue와 관련하여 새로운 채용이 선호하는 코딩 스타일에 이미 익숙하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06dc8f8ac9432bbb240e210daed5bff3b05abccb" translate="yes" xml:space="preserve">
          <source>optionMergeStrategies</source>
          <target state="translated">optionMergeStrategies</target>
        </trans-unit>
        <trans-unit id="5460c4665adcba7eae90a69c7fa5c8c721706518" translate="yes" xml:space="preserve">
          <source>or define a filter globally before creating the Vue instance:</source>
          <target state="translated">Vue 인스턴스를 만들기 전에 필터를 전역 적으로 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="274a7e4ebee8f7f6dc6992677f3c27d94a3001cb" translate="yes" xml:space="preserve">
          <source>other base components, and</source>
          <target state="translated">다른 기본 구성 요소</target>
        </trans-unit>
        <trans-unit id="d8fd39d0bbdd2dcf322d8b11390a4c5825b11495" translate="yes" xml:space="preserve">
          <source>parent</source>
          <target state="translated">parent</target>
        </trans-unit>
        <trans-unit id="476ee0f6af1d78aa2a3d9a587e8d5ee7e31229f6" translate="yes" xml:space="preserve">
          <source>performance</source>
          <target state="translated">performance</target>
        </trans-unit>
        <trans-unit id="901b0f26761a219ec847f2e563ee7d645ffb0fe8" translate="yes" xml:space="preserve">
          <source>productionTip</source>
          <target state="translated">productionTip</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="9b653d2097967639889ca93223335f45baa750ff" translate="yes" xml:space="preserve">
          <source>propsData</source>
          <target state="translated">propsData</target>
        </trans-unit>
        <trans-unit id="009ec702007827315f19dc796c2a231a2e05c4dc" translate="yes" xml:space="preserve">
          <source>provide / inject</source>
          <target state="translated">제공 / 주입</target>
        </trans-unit>
        <trans-unit id="559d8d669c33e3c83eb857ddab7a7179a755573e" translate="yes" xml:space="preserve">
          <source>provide reactive and composable view components</source>
          <target state="translated">반응 형 및 컴포저 블 뷰 구성 요소 제공</target>
        </trans-unit>
        <trans-unit id="69449f994d55805535b9e8fab16f6c39934e9ba4" translate="yes" xml:space="preserve">
          <source>ref</source>
          <target state="translated">ref</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="a0a5278a6cefc309b63b0c4c5fd7593743828a31" translate="yes" xml:space="preserve">
          <source>renderError</source>
          <target state="translated">renderError</target>
        </trans-unit>
        <trans-unit id="ceb562ce431745788c5bafaa3720a09b81bd457a" translate="yes" xml:space="preserve">
          <source>scope &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">범위가 &lt;sup&gt;제거되었습니다&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0e973bd3838898bd325ed8ba837f26d730a7ed56" translate="yes" xml:space="preserve">
          <source>scope removed</source>
          <target state="translated">범위가 제거되었습니다</target>
        </trans-unit>
        <trans-unit id="2a788a1972f648a6486eea37112a19c4fd342950" translate="yes" xml:space="preserve">
          <source>select fields use &lt;code&gt;value&lt;/code&gt; as a prop and &lt;code&gt;change&lt;/code&gt; as an event.</source>
          <target state="translated">선택 필드는 &lt;code&gt;value&lt;/code&gt; 을 소품 으로 사용하고 이벤트로 &lt;code&gt;change&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b32285bf14101379e596fd61f24637951f17e78f" translate="yes" xml:space="preserve">
          <source>silent</source>
          <target state="translated">silent</target>
        </trans-unit>
        <trans-unit id="462854f9c73adf5f5d5c411adb6b929ecc19693a" translate="yes" xml:space="preserve">
          <source>slot</source>
          <target state="translated">slot</target>
        </trans-unit>
        <trans-unit id="d3ccd068b20d8bc8c899d2419acc4756a32eabf3" translate="yes" xml:space="preserve">
          <source>slot &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;더 이상 사용되지 않는&lt;/sup&gt; 슬롯&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ac938ccaaee0471d9ba1ad826420fb07fe19599" translate="yes" xml:space="preserve">
          <source>slot deprecated</source>
          <target state="translated">더 이상 사용되지 않는 슬롯</target>
        </trans-unit>
        <trans-unit id="9705201399b16c1d9892866519b1fde59ee14c4d" translate="yes" xml:space="preserve">
          <source>slot-scope &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;더 이상 사용되지 않는&lt;/sup&gt; 슬롯 범위&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="70251443cfbe27230429f393dbeeabf3a5a1141c" translate="yes" xml:space="preserve">
          <source>slot-scope deprecated</source>
          <target state="translated">더 이상 사용되지 않는 슬롯 범위</target>
        </trans-unit>
        <trans-unit id="3226ecbe650213a49cd03ae67140750e4f340083" translate="yes" xml:space="preserve">
          <source>template</source>
          <target state="translated">template</target>
        </trans-unit>
        <trans-unit id="77bc0357bd1e93d68d50895d6a8281eb11026db0" translate="yes" xml:space="preserve">
          <source>text and textarea elements use &lt;code&gt;value&lt;/code&gt; property and &lt;code&gt;input&lt;/code&gt; event;</source>
          <target state="translated">text 및 textarea 요소는 &lt;code&gt;value&lt;/code&gt; 속성 및 &lt;code&gt;input&lt;/code&gt; 이벤트를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="26d762e47535d9d6a0e3b1ec719e818e5029f523" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;default&lt;/code&gt; property is used as fallback value</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 속성은 대체 값으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="025b0f9e93dda2558b27a2297f4ef94cbbc066a0" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;from&lt;/code&gt; property is the key (string or Symbol) to search for in available injections, and</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 속성을 사용할 수 주사에서 검색 할 수있는 키 (문자열 또는 기호)이며,</target>
        </trans-unit>
        <trans-unit id="cad1b9675290b91d92988abdefef24cfeea2451c" translate="yes" xml:space="preserve">
          <source>the custom element name to use in the template, and</source>
          <target state="translated">템플릿에서 사용할 사용자 정의 요소 이름</target>
        </trans-unit>
        <trans-unit id="b70d4d793e7c9fcdde8b56387ec8f9f5324536a6" translate="yes" xml:space="preserve">
          <source>the key (string or Symbol) to search for in available injections, or</source>
          <target state="translated">사용 가능한 주사에서 검색 할 키 (문자열 또는 기호) 또는</target>
        </trans-unit>
        <trans-unit id="771279a0962f67af2fa5fac029cdf6d9cedebe88" translate="yes" xml:space="preserve">
          <source>the name of a registered component, or</source>
          <target state="translated">등록 된 구성 요소의 이름 또는</target>
        </trans-unit>
        <trans-unit id="ab4b389f6b8b2c135e895d4f7ee4d31afb1a7b7b" translate="yes" xml:space="preserve">
          <source>the name of the variable containing the component options</source>
          <target state="translated">구성 요소 옵션을 포함하는 변수의 이름</target>
        </trans-unit>
        <trans-unit id="cb42e295aed62d3d9b5bec47d01a8b0244b984bf" translate="yes" xml:space="preserve">
          <source>the positions of SVG nodes</source>
          <target state="translated">SVG 노드의 위치</target>
        </trans-unit>
        <trans-unit id="412017c454240f4269a3e3d69329a8001d1bc3a8" translate="yes" xml:space="preserve">
          <source>the sizes and other properties of elements</source>
          <target state="translated">요소의 크기 및 기타 속성</target>
        </trans-unit>
        <trans-unit id="bb128da92e34868c02da7d99c67f861bac948e2f" translate="yes" xml:space="preserve">
          <source>the value of &lt;code&gt;lovingVue&lt;/code&gt; will be passed to the &lt;code&gt;checked&lt;/code&gt; prop. The &lt;code&gt;lovingVue&lt;/code&gt; property will then be updated when &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; emits a &lt;code&gt;change&lt;/code&gt; event with a new value.</source>
          <target state="translated">&lt;code&gt;lovingVue&lt;/code&gt; 의 가치 는 &lt;code&gt;checked&lt;/code&gt; 소품 으로 전달됩니다 . &lt;code&gt;lovingVue&lt;/code&gt; 의 경우 등록 다음 업데이트한다 &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; 방출 &lt;code&gt;change&lt;/code&gt; 새로운 값 이벤트.</target>
        </trans-unit>
        <trans-unit id="7a5ae87823ef730b40c73e6882ce9d81869d692b" translate="yes" xml:space="preserve">
          <source>to a definition like below in your &lt;code&gt;routes&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;routes&lt;/code&gt; 구성 에서 아래와 같이 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a356bc545ab21a71c127b739b139dcbccc68d5e" translate="yes" xml:space="preserve">
          <source>to access the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component may similarly use a &lt;code&gt;ref&lt;/code&gt; to provide access to specific elements inside it, such as:</source>
          <target state="translated">&lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 인스턴스 에 액세스합니다 . 예를 들어 부모로부터이 입력을 프로그래밍 방식으로 초점을 맞추려는 경우에 유용 할 수 있습니다. 이 경우 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 구성 요소는 다음과 같이 &lt;code&gt;ref&lt;/code&gt; 를 사용하여 내부의 특정 요소에 대한 액세스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b44c248ec32b071a1a7aafa16b55a17a8feb834" translate="yes" xml:space="preserve">
          <source>to this:</source>
          <target state="translated">이에:</target>
        </trans-unit>
        <trans-unit id="b624aaa273eeda72c40e568d21fcbbeb5497dae7" translate="yes" xml:space="preserve">
          <source>to validate that the value of the &lt;code&gt;author&lt;/code&gt; prop was created with &lt;code&gt;new Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; prop 의 값이 &lt;code&gt;new Person&lt;/code&gt; 으로 생성되었는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="4652e1358ea64fd28779917099faee9815f39f5a" translate="yes" xml:space="preserve">
          <source>train your brain to more easily parse most of the community code you encounter</source>
          <target state="translated">발생하는 대부분의 커뮤니티 코드를보다 쉽게 ​​파싱하도록 뇌를 훈련 시키십시오</target>
        </trans-unit>
        <trans-unit id="56bf8ae82a107d348a5ad5b650394e3f79340670" translate="yes" xml:space="preserve">
          <source>transition</source>
          <target state="translated">transition</target>
        </trans-unit>
        <trans-unit id="0346b11d87b24e82ab5c649ad2ca732f998681d6" translate="yes" xml:space="preserve">
          <source>transition-group</source>
          <target state="translated">transition-group</target>
        </trans-unit>
        <trans-unit id="2439417750083132eec5533d66db361a6f33c86c" translate="yes" xml:space="preserve">
          <source>unit tested in isolation from your Vue code</source>
          <target state="translated">Vue 코드와 별도로 테스트 한 유닛</target>
        </trans-unit>
        <trans-unit id="13a1891af75c642306a6b695377d16e4a91f0e1b" translate="yes" xml:space="preserve">
          <source>updated</source>
          <target state="translated">updated</target>
        </trans-unit>
        <trans-unit id="47c1dcbefaa84b21d8f1b4cacb6d96a2389f8d6c" translate="yes" xml:space="preserve">
          <source>use JavaScript to directly manipulate the DOM during transition hooks</source>
          <target state="translated">전환 후크 동안 JavaScript를 사용하여 DOM을 직접 조작</target>
        </trans-unit>
        <trans-unit id="2ffb3e7b8b54e93fa9c9e2c85136cd36872ebac8" translate="yes" xml:space="preserve">
          <source>used by other parts of your application, such as to validate the payload to an API endpoint</source>
          <target state="translated">API 엔드 포인트에 대한 페이로드의 유효성을 검증하는 등 애플리케이션의 다른 부분에서 사용</target>
        </trans-unit>
        <trans-unit id="71e87a583e04a8c8e91247ed090ea050ff05d929" translate="yes" xml:space="preserve">
          <source>utilize a virtual DOM</source>
          <target state="translated">가상 DOM 활용</target>
        </trans-unit>
        <trans-unit id="121c33ea7d2fbab17fddc40d29520aa060292a3f" translate="yes" xml:space="preserve">
          <source>v-bind</source>
          <target state="translated">v-bind</target>
        </trans-unit>
        <trans-unit id="61446caf9cec66418312b8afce77b95f760c1542" translate="yes" xml:space="preserve">
          <source>v-cloak</source>
          <target state="translated">v-cloak</target>
        </trans-unit>
        <trans-unit id="9211fc21d367807ce01b01aeaa155eceb994ff10" translate="yes" xml:space="preserve">
          <source>v-else</source>
          <target state="translated">v-else</target>
        </trans-unit>
        <trans-unit id="aad798ca5693051aa59b6d5515d414fb382e1b9d" translate="yes" xml:space="preserve">
          <source>v-else-if</source>
          <target state="translated">v-else-if</target>
        </trans-unit>
        <trans-unit id="d8d5f6f2691961dbe62b3963ea44db6840a098b2" translate="yes" xml:space="preserve">
          <source>v-for</source>
          <target state="translated">v-for</target>
        </trans-unit>
        <trans-unit id="1c21399d4bae3d211e796bf024c68edbb55e3bc3" translate="yes" xml:space="preserve">
          <source>v-html</source>
          <target state="translated">v-html</target>
        </trans-unit>
        <trans-unit id="da1ef073ed7cfaabd197c053859f5aa2996547bc" translate="yes" xml:space="preserve">
          <source>v-if</source>
          <target state="translated">v-if</target>
        </trans-unit>
        <trans-unit id="5c02585ece6d24ec42b855e409120cc1caeae510" translate="yes" xml:space="preserve">
          <source>v-if/v-else-if/v-else without key</source>
          <target state="translated">키가없는 v-if / v-else-if / v-else</target>
        </trans-unit>
        <trans-unit id="e6aa5be18818de68afb647ef7683640c0ccc6f9b" translate="yes" xml:space="preserve">
          <source>v-model</source>
          <target state="translated">v-model</target>
        </trans-unit>
        <trans-unit id="465db0034f4a4aa82a200f7a5acabc5c6dad8449" translate="yes" xml:space="preserve">
          <source>v-on</source>
          <target state="translated">v-on</target>
        </trans-unit>
        <trans-unit id="fb93d4822889186d62901f1d0c2937ba09afb073" translate="yes" xml:space="preserve">
          <source>v-once</source>
          <target state="translated">v-once</target>
        </trans-unit>
        <trans-unit id="8723014a826e07ee1d36588c6cd2790ee471ba3c" translate="yes" xml:space="preserve">
          <source>v-pre</source>
          <target state="translated">v-pre</target>
        </trans-unit>
        <trans-unit id="54272dd05aa79ca6da35bbefacf8c3d5701dea3b" translate="yes" xml:space="preserve">
          <source>v-show</source>
          <target state="translated">v-show</target>
        </trans-unit>
        <trans-unit id="285a211f0f9d5799f4ec4b2694fc5040a7a120fc" translate="yes" xml:space="preserve">
          <source>v-slot</source>
          <target state="translated">v-slot</target>
        </trans-unit>
        <trans-unit id="a3f5fd55c07ee5fe5da9b61ede51058b6932a8ba" translate="yes" xml:space="preserve">
          <source>v-text</source>
          <target state="translated">v-text</target>
        </trans-unit>
        <trans-unit id="9e8c4326a3e5802b6bd32bdeb38f5ea9b5029432" translate="yes" xml:space="preserve">
          <source>vm.$attrs</source>
          <target state="translated">vm.$attrs</target>
        </trans-unit>
        <trans-unit id="af70cd66d8f463ff0c1b87333de9f7abb083bbcb" translate="yes" xml:space="preserve">
          <source>vm.$children</source>
          <target state="translated">vm.$children</target>
        </trans-unit>
        <trans-unit id="92036bba3d6520305ca4419e64187c8bacb4d53b" translate="yes" xml:space="preserve">
          <source>vm.$data</source>
          <target state="translated">vm.$data</target>
        </trans-unit>
        <trans-unit id="0c6c5f8f8645a9e8953886d60d3d38fc9d7e3813" translate="yes" xml:space="preserve">
          <source>vm.$delete( target, propertyName/index )</source>
          <target state="translated">vm. $ delete (대상, propertyName / index)</target>
        </trans-unit>
        <trans-unit id="85945dbc9f317e87e1ebe95aacd2d097e0aadd5e" translate="yes" xml:space="preserve">
          <source>vm.$delete()</source>
          <target state="translated">vm.$delete()</target>
        </trans-unit>
        <trans-unit id="494349fee667e22074020faf32a0d4824e463b58" translate="yes" xml:space="preserve">
          <source>vm.$destroy()</source>
          <target state="translated">vm.$destroy()</target>
        </trans-unit>
        <trans-unit id="eb3d8ad0a5a691e540f0cae8b5f4c35c39bed85b" translate="yes" xml:space="preserve">
          <source>vm.$el</source>
          <target state="translated">vm.$el</target>
        </trans-unit>
        <trans-unit id="01e0f31da340e252fe35bb687b3a8604096a8617" translate="yes" xml:space="preserve">
          <source>vm.$emit( eventName, [&amp;hellip;args] )</source>
          <target state="translated">vm. $ emit (eventName, [&amp;hellip; args])</target>
        </trans-unit>
        <trans-unit id="f7a594be4c584e06c7738c18556378cc4dca84e2" translate="yes" xml:space="preserve">
          <source>vm.$emit()</source>
          <target state="translated">vm.$emit()</target>
        </trans-unit>
        <trans-unit id="86a5433d32c4d79baf0873f0e23a3bf1d6a26d26" translate="yes" xml:space="preserve">
          <source>vm.$forceUpdate()</source>
          <target state="translated">vm.$forceUpdate()</target>
        </trans-unit>
        <trans-unit id="0cedbd040ea3774df4b69fa4ae663ee646bab0f3" translate="yes" xml:space="preserve">
          <source>vm.$isServer</source>
          <target state="translated">vm.$isServer</target>
        </trans-unit>
        <trans-unit id="05326313026d4f80968b293f9a29cb767e2674ca" translate="yes" xml:space="preserve">
          <source>vm.$listeners</source>
          <target state="translated">vm.$listeners</target>
        </trans-unit>
        <trans-unit id="baab4fd1f32671646717fa9dc37e706a4aa9fc7d" translate="yes" xml:space="preserve">
          <source>vm.$mount( [elementOrSelector] )</source>
          <target state="translated">vm. $ mount ([elementOrSelector])</target>
        </trans-unit>
        <trans-unit id="57b0780f274178234dca2bf0f994ee7dfc389a4e" translate="yes" xml:space="preserve">
          <source>vm.$mount()</source>
          <target state="translated">vm.$mount()</target>
        </trans-unit>
        <trans-unit id="5c40836793cc9b36ae1e44c2bf0c9d0973b1cb62" translate="yes" xml:space="preserve">
          <source>vm.$nextTick( [callback] )</source>
          <target state="translated">vm. $ nextTick ([콜백])</target>
        </trans-unit>
        <trans-unit id="3f2f493de9594ab85ab997f6f445b21f8bf32608" translate="yes" xml:space="preserve">
          <source>vm.$nextTick()</source>
          <target state="translated">vm.$nextTick()</target>
        </trans-unit>
        <trans-unit id="c4320c5ab4595a1512d09e454b2afc1e30f53f99" translate="yes" xml:space="preserve">
          <source>vm.$off( [event, callback] )</source>
          <target state="translated">vm. $ off ([이벤트, 콜백])</target>
        </trans-unit>
        <trans-unit id="8659b7c176051de19b834751c71d64c023e531f8" translate="yes" xml:space="preserve">
          <source>vm.$off()</source>
          <target state="translated">vm.$off()</target>
        </trans-unit>
        <trans-unit id="faeea08725a5801e45b45e8d9044c3d2edda645d" translate="yes" xml:space="preserve">
          <source>vm.$on( event, callback )</source>
          <target state="translated">vm. $ on (이벤트, 콜백)</target>
        </trans-unit>
        <trans-unit id="47dd05c213dfee7e3bf78c8e68b730713e6c7872" translate="yes" xml:space="preserve">
          <source>vm.$on()</source>
          <target state="translated">vm.$on()</target>
        </trans-unit>
        <trans-unit id="5ddf55fd8c65e0c64370564ac67c71a598011755" translate="yes" xml:space="preserve">
          <source>vm.$once( event, callback )</source>
          <target state="translated">vm. $ once (이벤트, 콜백)</target>
        </trans-unit>
        <trans-unit id="95a71f9912a16c82dc4a770971c999acc1c481a4" translate="yes" xml:space="preserve">
          <source>vm.$once()</source>
          <target state="translated">vm.$once()</target>
        </trans-unit>
        <trans-unit id="0413cd705f160430c6855f79f80a44ed08a489dc" translate="yes" xml:space="preserve">
          <source>vm.$options</source>
          <target state="translated">vm.$options</target>
        </trans-unit>
        <trans-unit id="513e55e5a687797c62836b5b87c3bc78152500fe" translate="yes" xml:space="preserve">
          <source>vm.$parent</source>
          <target state="translated">vm.$parent</target>
        </trans-unit>
        <trans-unit id="96a7cb38d4e51f5a9a8a6369eb2854d54f31fd3a" translate="yes" xml:space="preserve">
          <source>vm.$props</source>
          <target state="translated">vm.$props</target>
        </trans-unit>
        <trans-unit id="d07c6d69732e9d49ba257f3637d225a5aed4c96d" translate="yes" xml:space="preserve">
          <source>vm.$refs</source>
          <target state="translated">vm.$refs</target>
        </trans-unit>
        <trans-unit id="ddead883ad1628e96ca570e4221dfc38903f3db2" translate="yes" xml:space="preserve">
          <source>vm.$root</source>
          <target state="translated">vm.$root</target>
        </trans-unit>
        <trans-unit id="77be545f1df363cacfd93eb0c9831ef3c95102f4" translate="yes" xml:space="preserve">
          <source>vm.$scopedSlots</source>
          <target state="translated">vm.$scopedSlots</target>
        </trans-unit>
        <trans-unit id="445f58422508541995e32fe0dceb823dcbaaf2f3" translate="yes" xml:space="preserve">
          <source>vm.$set( target, propertyName/index, value )</source>
          <target state="translated">vm. $ set (대상, propertyName / 인덱스, 값)</target>
        </trans-unit>
        <trans-unit id="12697644997ccacfcfb893110ee18b99abc39f50" translate="yes" xml:space="preserve">
          <source>vm.$set()</source>
          <target state="translated">vm.$set()</target>
        </trans-unit>
        <trans-unit id="3e09115bb4ccfaa59031cd594a8725f9ddff4efe" translate="yes" xml:space="preserve">
          <source>vm.$slots</source>
          <target state="translated">vm.$slots</target>
        </trans-unit>
        <trans-unit id="0b7eb695b0a861c10e273101dd3381aea047bf00" translate="yes" xml:space="preserve">
          <source>vm.$watch( expOrFn, callback, [options] )</source>
          <target state="translated">vm. $ watch (expOrFn, 콜백, [옵션])</target>
        </trans-unit>
        <trans-unit id="fe0401584870a2346a744fe847cf8a6bd902dfbe" translate="yes" xml:space="preserve">
          <source>vm.$watch()</source>
          <target state="translated">vm.$watch()</target>
        </trans-unit>
        <trans-unit id="abc4eb915d83966c3c028e2808e22bda2146ff20" translate="yes" xml:space="preserve">
          <source>vue.common.js</source>
          <target state="translated">vue.common.js</target>
        </trans-unit>
        <trans-unit id="8bc5b029cab40d453cf86de8c720dd795e2a79c0" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.js</source>
          <target state="translated">vue.esm.browser.js</target>
        </trans-unit>
        <trans-unit id="d3ffd20876becca44053e10a61c39d904267ac9f" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.min.js</source>
          <target state="translated">vue.esm.browser.min.js</target>
        </trans-unit>
        <trans-unit id="c117006aa30745b1641f5393741c01bb708cc6db" translate="yes" xml:space="preserve">
          <source>vue.esm.js</source>
          <target state="translated">vue.esm.js</target>
        </trans-unit>
        <trans-unit id="3f7227146eb759f801a054462cc6de123c9a354c" translate="yes" xml:space="preserve">
          <source>vue.js</source>
          <target state="translated">vue.js</target>
        </trans-unit>
        <trans-unit id="99a1d389faffdd980b71470664af47bc6458b2b3" translate="yes" xml:space="preserve">
          <source>vue.min.js</source>
          <target state="translated">vue.min.js</target>
        </trans-unit>
        <trans-unit id="293bf1049872f5a192d03a09bffe06f69b51091d" translate="yes" xml:space="preserve">
          <source>vue.runtime.common.js</source>
          <target state="translated">vue.runtime.common.js</target>
        </trans-unit>
        <trans-unit id="4e9d385e35e8eca60fb7e6083bf2726bc638f977" translate="yes" xml:space="preserve">
          <source>vue.runtime.esm.js</source>
          <target state="translated">vue.runtime.esm.js</target>
        </trans-unit>
        <trans-unit id="2b84e57a624eece08bd137eb6a2c3e4c53c4e1a1" translate="yes" xml:space="preserve">
          <source>vue.runtime.js</source>
          <target state="translated">vue.runtime.js</target>
        </trans-unit>
        <trans-unit id="f4c3c79918026bc22af5b5db5c14b417b1839be0" translate="yes" xml:space="preserve">
          <source>vue.runtime.min.js</source>
          <target state="translated">vue.runtime.min.js</target>
        </trans-unit>
        <trans-unit id="bcbb79f097d6df57f152dc61e8151e0a00cefb2d" translate="yes" xml:space="preserve">
          <source>warnHandler</source>
          <target state="translated">warnHandler</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
        <trans-unit id="b84bfe360a66993ae5d35ff845e9df46ef696052" translate="yes" xml:space="preserve">
          <source>will be maintained for the foreseeable future</source>
          <target state="translated">가까운 장래에 유지 될 것입니다</target>
        </trans-unit>
        <trans-unit id="9d57f6d32929205f7b53a7328ce8817af26246a6" translate="yes" xml:space="preserve">
          <source>will render the fallback content, &amp;ldquo;Submit&amp;rdquo;:</source>
          <target state="translated">대체 콘텐츠 인 &quot;제출&quot;을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="032b3d049c6766e15673ecd6348f41e6baaa865b" translate="yes" xml:space="preserve">
          <source>will render with a value of &amp;ldquo;bar&amp;rdquo; instead of &amp;ldquo;foo&amp;rdquo;. The same goes for a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; with existing content. Instead of:</source>
          <target state="translated">&quot;foo&quot;대신 &quot;bar&quot;값으로 렌더링됩니다. 기존 내용이 있는 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 도 마찬가지 입니다. 대신에:</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
