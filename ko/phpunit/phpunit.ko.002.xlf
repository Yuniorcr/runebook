<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phpunit">
    <body>
      <group id="phpunit">
        <trans-unit id="c16d5f07f74e355b21d87741daea434449781182" translate="yes" xml:space="preserve">
          <source>Unit Tests are primarily written as a good practice to help developers identify and fix bugs, to refactor code and to serve as documentation for a unit of software under test. To achieve these benefits, unit tests ideally should cover all the possible paths in a program. One unit test usually covers one specific path in one function or method. However a test method is not necessarily an encapsulated, independent entity. Often there are implicit dependencies between test methods, hidden in the implementation scenario of a test.</source>
          <target state="translated">단위 테스트는 주로 개발자가 버그를 식별 및 수정하고, 코드를 리팩터링하고, 테스트중인 소프트웨어 단위에 대한 문서로 사용하는 데 유용한 모범 사례로 작성되었습니다. 이러한 이점을 달성하려면 단위 테스트는 프로그램의 모든 가능한 경로를 이상적으로 다루어야합니다. 하나의 단위 테스트는 일반적으로 하나의 기능 또는 방법으로 하나의 특정 경로를 포함합니다. 그러나 테스트 방법이 반드시 캡슐화 된 독립 엔티티 일 필요는 없습니다. 종종 테스트의 구현 시나리오에 숨겨진 테스트 방법 사이에 암시 적 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fa47641d8db125127eb4e59fac4adb4c27367ef" translate="yes" xml:space="preserve">
          <source>Unit testing offers many advantages:</source>
          <target state="translated">단위 테스트는 많은 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="445aba2719a870b6e92645a8ccd5a419539809d0" translate="yes" xml:space="preserve">
          <source>Unit tests provide working examples for how to use an API and can significantly aid documentation efforts.</source>
          <target state="translated">단위 테스트는 API 사용 방법에 대한 실제 예제를 제공하며 문서 작업에 큰 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e78d1e8d58204a4228725045ba5ff0aba05d455b" translate="yes" xml:space="preserve">
          <source>Use colors in output. On Windows, use &lt;a href=&quot;https://github.com/adoxa/ansicon&quot;&gt;ANSICON&lt;/a&gt; or &lt;a href=&quot;https://github.com/Maximus5/ConEmu&quot;&gt;ConEmu&lt;/a&gt;.</source>
          <target state="translated">출력에 색상을 사용하십시오. Windows에서는 &lt;a href=&quot;https://github.com/adoxa/ansicon&quot;&gt;ANSICON&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/Maximus5/ConEmu&quot;&gt;ConEmu를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3573b4a4a51e4a7fdce706f212629595077148d5" translate="yes" xml:space="preserve">
          <source>Useless Tests</source>
          <target state="translated">쓸모없는 테스트</target>
        </trans-unit>
        <trans-unit id="927f9977ea2ebafd827eafa66188862aacda3031" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;phpVersion&lt;/code&gt; and &lt;code&gt;phpVersionOperator&lt;/code&gt; attributes, a required PHP version can be specified. The example below will only add the &lt;code&gt;/path/to/*Test.php&lt;/code&gt; files and &lt;code&gt;/path/to/MyTest.php&lt;/code&gt; file if the PHP version is at least 5.3.0.</source>
          <target state="translated">은 Using &lt;code&gt;phpVersion&lt;/code&gt; 을 하고 &lt;code&gt;phpVersionOperator&lt;/code&gt; 이 속성 필요한 PHP 버전을 지정할 수 있습니다. 아래 예제 는 PHP 버전이 5.3.0 이상인 경우 &lt;code&gt;/path/to/*Test.php&lt;/code&gt; 파일과 &lt;code&gt;/path/to/MyTest.php&lt;/code&gt; 파일 만 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d3f6b359741e89cdab7e53453eda4e764da26b20" translate="yes" xml:space="preserve">
          <source>Using the Composite DataSet we can aggregate both fixture files:</source>
          <target state="translated">Composite DataSet을 사용하여 두 조명기 파일을 집계 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7a4b7a6f06e90f419c8119bdaffc00c67e2166ae" translate="yes" xml:space="preserve">
          <source>Usually when using PHPUnit your testcases would extend the &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; class in the following way:</source>
          <target state="translated">일반적으로 PHPUnit을 사용할 때 테스트 케이스는 다음과 같은 방법으로 &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; 클래스를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="4fba657a2566a29bb2eae7ad600ea97c18865719" translate="yes" xml:space="preserve">
          <source>Variations</source>
          <target state="translated">Variations</target>
        </trans-unit>
        <trans-unit id="a5d747bbb33afd9305aaffa5bfd0514ceefd9a15" translate="yes" xml:space="preserve">
          <source>Various software metrics exist to measure code coverage:</source>
          <target state="translated">코드 범위를 측정하기위한 다양한 소프트웨어 메트릭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8089893a67ec03da73e4b81bfbe04d0d61b65c" translate="yes" xml:space="preserve">
          <source>Verify outcome</source>
          <target state="translated">결과 확인</target>
        </trans-unit>
        <trans-unit id="968a2dc859429ff332a18fe4f68d1bc3f083b912" translate="yes" xml:space="preserve">
          <source>Verify that you can reproduce the defect.</source>
          <target state="translated">결함을 재현 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="515bca6bd8d57e897b38ffb481f512e10f333f1b" translate="yes" xml:space="preserve">
          <source>Verifying PHPUnit PHAR Releases</source>
          <target state="translated">PHPUnit PHAR 릴리즈 확인</target>
        </trans-unit>
        <trans-unit id="87f6c76b8a2c217f0b522b06bb568e49150522f6" translate="yes" xml:space="preserve">
          <source>Verifying the state of the database after your test has run</source>
          <target state="translated">테스트 실행 후 데이터베이스 상태 확인</target>
        </trans-unit>
        <trans-unit id="4226ba146a6442cd5b7bc379dce83e15dc118e1f" translate="yes" xml:space="preserve">
          <source>We can now modify our test-case to look like:</source>
          <target state="translated">이제 테스트 케이스를 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c74a1403765c15c77c1fa571bc693a220acc9037" translate="yes" xml:space="preserve">
          <source>We can now run the database test suite using different configurations from the command-line interface:</source>
          <target state="translated">이제 명령 행 인터페이스와 다른 구성을 사용하여 데이터베이스 테스트 스위트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bc92c8ed3137ce5da83bf715f291250acbaa082" translate="yes" xml:space="preserve">
          <source>We don't have the release manager's public key (&lt;code&gt;6372C20A&lt;/code&gt;) in our local system. In order to proceed with the verification we need to retrieve the release manager's public key from a key server. One such server is &lt;code&gt;pgp.uni-mainz.de&lt;/code&gt;. The public key servers are linked together, so you should be able to connect to any key server.</source>
          <target state="translated">로컬 시스템에 릴리스 관리자의 공개 키 ( &lt;code&gt;6372C20A&lt;/code&gt; ) 가 없습니다 . 확인을 진행하려면 키 서버에서 릴리스 관리자의 공개 키를 검색해야합니다. 그러한 서버 중 하나는 &lt;code&gt;pgp.uni-mainz.de&lt;/code&gt; 입니다. 공개 키 서버는 서로 연결되어 있으므로 모든 키 서버에 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d95e979c279f198d114fc1ef2d6062fa2c6b5d1c" translate="yes" xml:space="preserve">
          <source>We first use the &lt;code&gt;getMockBuilder()&lt;/code&gt; method that is provided by the &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; class to set up a mock object for the &lt;code&gt;Observer&lt;/code&gt;. Since we give an array as the second (optional) parameter for the &lt;code&gt;getMock()&lt;/code&gt; method, only the &lt;code&gt;update()&lt;/code&gt; method of the &lt;code&gt;Observer&lt;/code&gt; class is replaced by a mock implementation.</source>
          <target state="translated">먼저 &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; 클래스에서 제공 하는 &lt;code&gt;getMockBuilder()&lt;/code&gt; 메소드 를 사용하여 &lt;code&gt;Observer&lt;/code&gt; 의 모의 객체를 설정합니다 . &lt;code&gt;getMock()&lt;/code&gt; 메소드 의 두 번째 (선택적) 매개 변수로 배열을 제공하므로 &lt;code&gt;Observer&lt;/code&gt; 클래스 의 &lt;code&gt;update()&lt;/code&gt; 메소드 만 모의 구현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fe05c08006ff0a8ce21d34d52ae92caedbb9b25e" translate="yes" xml:space="preserve">
          <source>We have to fix up the Query Table call:</source>
          <target state="translated">쿼리 테이블 호출을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b17a72d479f56ce5347129ab513ff650e8232b2" translate="yes" xml:space="preserve">
          <source>We then wrap the Flat XML DataSet into a Replacement DataSet:</source>
          <target state="translated">그런 다음 Flat XML DataSet을 대체 DataSet으로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="6521e2d9cf4c4b8c30cee3301b63ec6b1f151d3e" translate="yes" xml:space="preserve">
          <source>We want to verify PHPUnit's PHP Archive (&lt;code&gt;phpunit.phar&lt;/code&gt;) against its detached signature (&lt;code&gt;phpunit.phar.asc&lt;/code&gt;):</source>
          <target state="translated">분리 된 서명 ( &lt;code&gt;phpunit.phar.asc&lt;/code&gt; ) 에 대해 PHPUnit의 PHP 아카이브 ( &lt;code&gt;phpunit.phar&lt;/code&gt; ) 를 확인하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7912e65563f990d380c3a7b1fe9013f351937498" translate="yes" xml:space="preserve">
          <source>What PHPUnit cannot help you with is the fact that database tests are very slow compared to tests not using the database. Depending on how large the interactions with your database are your tests could run a considerable amount of time. However, if you keep the amount of data used for each test small and try to test as much code using non-database tests you can easily get away in under a minute even for large test suites.</source>
          <target state="translated">PHPUnit이 도울 수없는 것은 데이터베이스를 사용하지 않는 테스트에 비해 데이터베이스 테스트가 매우 느리다는 것입니다. 데이터베이스와의 상호 작용이 얼마나 큰지에 따라 테스트가 상당한 시간 동안 실행될 수 있습니다. 그러나 각 테스트에 사용되는 데이터 양을 작게 유지하고 비 데이터베이스 테스트를 사용하여 많은 코드를 테스트하려고하면 대규모 테스트 스위트에서도 1 분 안에 쉽게 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad378f1367aa73f06a572f140feae837a7657f59" translate="yes" xml:space="preserve">
          <source>What about the Database Schema (DDL)?</source>
          <target state="translated">데이터베이스 스키마 (DDL)는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="115684ae5a4f0ea9d4f32a8dae7dc26e1ca72887" translate="yes" xml:space="preserve">
          <source>What can I do, when I get a &amp;ldquo;Too much Connections&amp;rdquo; Error?</source>
          <target state="translated">&quot;너무 많은 연결&quot;오류가 발생하면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="5c83e4a9267735ea2a8a452869dd4e283f9096fa" translate="yes" xml:space="preserve">
          <source>What happens when you have two tests with slightly different setups? There are two possibilities:</source>
          <target state="translated">약간 다른 설정으로 두 가지 테스트를 수행하면 어떻게됩니까? 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93725b738940b2c0445b887a973d77f12a3a4b3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--colors&lt;/code&gt; is used without any value, &lt;code&gt;auto&lt;/code&gt; is the chosen value.</source>
          <target state="translated">값없이 &lt;code&gt;--colors&lt;/code&gt; 를 사용 하면 &lt;code&gt;auto&lt;/code&gt; 가 선택된 값입니다.</target>
        </trans-unit>
        <trans-unit id="24c52d1e14412e2cdd24581efb9b8f0c8a891a49" translate="yes" xml:space="preserve">
          <source>When a comparison fails PHPUnit creates textual representations of the input values and compares those. Due to that implementation a diff might show more problems than actually exist.</source>
          <target state="translated">비교가 실패하면 PHPUnit은 입력 값의 텍스트 표현을 작성하고이를 비교합니다. 그 구현으로 인해 diff는 실제로 존재하는 것보다 더 많은 문제를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7b2b56c3bb7baccf57768f31f22cba6408cce1" translate="yes" xml:space="preserve">
          <source>When a test depends on a test that uses data providers, the depending test will be executed when the test it depends upon is successful for at least one data set. The result of a test that uses data providers cannot be injected into a depending test.</source>
          <target state="translated">테스트가 데이터 공급자를 사용하는 테스트에 의존하는 경우 종속 테스트는 하나 이상의 데이터 세트에 대한 테스트가 성공할 때 실행됩니다. 데이터 공급자를 사용하는 테스트 결과는 종속 테스트에 주입 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b83186dd5b2868bce96efb067330d4ec7fd33e75" translate="yes" xml:space="preserve">
          <source>When a test has a data provider that uses named sets, each iteration of the data gets the current name appended to the end of the default test name. See &lt;a href=&quot;textui#textui.examples.TestCaseClass.php&quot;&gt;Example 3.1&lt;/a&gt; for an example of named data sets.</source>
          <target state="translated">테스트에 명명 된 집합을 사용하는 데이터 공급자가있는 경우 데이터를 반복 할 때마다 기본 테스트 이름 끝에 현재 이름이 추가됩니다. 명명 된 데이터 세트의 예는 &lt;a href=&quot;textui#textui.examples.TestCaseClass.php&quot;&gt;Example 3.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a8d2ea27a9b8d141da38c928ee1911dac9633b2" translate="yes" xml:space="preserve">
          <source>When a test has a data provider, each iteration of the data gets the current index appended to the end of the default test name.</source>
          <target state="translated">테스트에 데이터 공급자가 있으면 각 데이터 반복마다 기본 테스트 이름 끝에 현재 색인이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="928de2897eb690b5e2463dfe5714db6ab366857d" translate="yes" xml:space="preserve">
          <source>When a test is run in a separate process, PHPUnit will attempt to preserve the global state from the parent process by serializing all globals in the parent process and unserializing them in the child process. This can cause problems if the parent process contains globals that are not serializable. To fix this, you can prevent PHPUnit from preserving global state with the &lt;code&gt;@preserveGlobalState&lt;/code&gt; annotation.</source>
          <target state="translated">테스트가 별도의 프로세스에서 실행될 때, PHPUnit은 상위 프로세스의 모든 글로벌을 직렬화하고 하위 프로세스에서 직렬화를 해제함으로써 상위 프로세스에서 글로벌 상태를 보존하려고 시도합니다. 부모 프로세스에 직렬화 할 수없는 전역이 포함 된 경우 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해 &lt;code&gt;@preserveGlobalState&lt;/code&gt; 주석을 사용하여 PHPUnit이 전역 상태를 유지하지 못하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5087899f9ddca43147b61cf42ce219f784ed6d6" translate="yes" xml:space="preserve">
          <source>When a test receives input from both a &lt;code&gt;@dataProvider&lt;/code&gt; method and from one or more tests it &lt;code&gt;@depends&lt;/code&gt; on, the arguments from the data provider will come before the ones from depended-upon tests. The arguments from depended-upon tests will be the same for each data set. See &lt;a href=&quot;writing-tests-for-phpunit#writing-tests-for-phpunit.data-providers.examples.DependencyAndDataProviderCombo.php&quot;&gt;Example 2.9&lt;/a&gt;</source>
          <target state="translated">테스트가 &lt;code&gt;@dataProvider&lt;/code&gt; 메서드와 @ 의존 하는 하나 이상의 테스트에서 입력을 받으면 데이터 공급자의 인수가 &lt;code&gt;@depends&lt;/code&gt; 테스트 의 인수보다 우선합니다. 의존 테스트의 인수는 각 데이터 세트마다 동일합니다. &lt;a href=&quot;writing-tests-for-phpunit#writing-tests-for-phpunit.data-providers.examples.DependencyAndDataProviderCombo.php&quot;&gt;예 2.9&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="1f39ec370243fced00c1b53d74960cd74dab84f5" translate="yes" xml:space="preserve">
          <source>When invoked as shown above, the PHPUnit command-line test runner will look for a &lt;code&gt;ArrayTest.php&lt;/code&gt; sourcefile in the current working directory, load it, and expect to find a &lt;code&gt;ArrayTest&lt;/code&gt; test case class. It will then execute the tests of that class.</source>
          <target state="translated">위에 표시된대로 PHPUnit 명령 행 테스트 실행기는 현재 작업 디렉토리에서 &lt;code&gt;ArrayTest.php&lt;/code&gt; 소스 파일을 찾아서로드하고 &lt;code&gt;ArrayTest&lt;/code&gt; 테스트 케이스 클래스 를 찾을 것으로 예상합니다 . 그런 다음 해당 클래스의 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c257df4624e54c7d61c98bf07c4bfb68faef2" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, the error handler installed by &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; will not convert &lt;code&gt;E_NOTICE&lt;/code&gt;, &lt;code&gt;E_USER_NOTICE&lt;/code&gt;, or &lt;code&gt;E_STRICT&lt;/code&gt; errors to exceptions.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정되면 &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; 에 의해 설치된 오류 핸들러 는 &lt;code&gt;E_NOTICE&lt;/code&gt; , &lt;code&gt;E_USER_NOTICE&lt;/code&gt; 또는 &lt;code&gt;E_STRICT&lt;/code&gt; 오류를 예외 로 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="002a6f78e7e4d71c9647e3e9d3f68886ae01fde9" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, the error handler installed by &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; will not convert &lt;code&gt;E_WARNING&lt;/code&gt; or &lt;code&gt;E_USER_WARNING&lt;/code&gt; errors to exceptions.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정되면 &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; 에 의해 설치된 오류 핸들러 는 &lt;code&gt;E_WARNING&lt;/code&gt; 또는 &lt;code&gt;E_USER_WARNING&lt;/code&gt; 오류를 예외 로 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2924e217edcd774dc23569abb58a9b2d78ee16dc" translate="yes" xml:space="preserve">
          <source>When testing a fluent interface, it is sometimes useful to have a stubbed method return a reference to the stubbed object. &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest4.php&quot;&gt;Example 9.5&lt;/a&gt; shows how you can use &lt;code&gt;returnSelf()&lt;/code&gt; to achieve this.</source>
          <target state="translated">유창한 인터페이스를 테스트 할 때 스텁 된 메소드가 스텁 된 오브젝트에 대한 참조를 리턴하도록하는 것이 유용한 경우가 있습니다. &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest4.php&quot;&gt;Example 9.5&lt;/a&gt; 에서는 &lt;code&gt;returnSelf()&lt;/code&gt; 를 사용하여 이를 수행 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e2ea43a722b4accbde6ee894dec3f96eb881f12e" translate="yes" xml:space="preserve">
          <source>When testing that relies on php functions that trigger errors like &lt;code&gt;fopen&lt;/code&gt; it can sometimes be useful to use error suppression while testing. This allows you to check the return values by suppressing notices that would lead to a phpunit &lt;code&gt;PHPUnit\Framework\Error\Notice&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fopen&lt;/code&gt; 과 같은 오류를 유발하는 PHP 함수 를 사용하는 테스트는 테스트 중에 오류 억제를 사용하는 것이 유용 할 수 있습니다. 이를 통해 phpunit &lt;code&gt;PHPUnit\Framework\Error\Notice&lt;/code&gt; 이어질 수있는 알림을 억제하여 반환 값을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="990bfb73867024d395d16a9cdf248f1795bbe0cb" translate="yes" xml:space="preserve">
          <source>When the first guestbook entry is deleted from the dataset only &amp;ldquo;id&amp;rdquo;, &amp;ldquo;content&amp;rdquo; and &amp;ldquo;created&amp;rdquo; would be columns of the guestbook table, since &amp;ldquo;user&amp;rdquo; is not specified.</source>
          <target state="translated">첫 번째 방명록 항목이 데이터 세트에서 &quot;id&quot;만 삭제되면 &quot;user&quot;가 지정되지 않으므로 &quot;content&quot;및 &quot;created&quot;는 방명록 테이블의 열이됩니다.</target>
        </trans-unit>
        <trans-unit id="fc33515038d480815dce350ef54023bb52c7fc20" translate="yes" xml:space="preserve">
          <source>When the generated output would be long to read PHPUnit will split it up and provide a few lines of context around every difference.</source>
          <target state="translated">생성 된 출력을 읽는 데 시간이 오래 걸리면 PHPUnit은이를 분할하여 모든 차이에 대해 몇 줄의 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea4f1e8bf1982f3bb75b49b47e526b8b0d793935" translate="yes" xml:space="preserve">
          <source>When the stubbed method call should return a calculated value instead of a fixed one (see &lt;code&gt;returnValue()&lt;/code&gt;) or an (unchanged) argument (see &lt;code&gt;returnArgument()&lt;/code&gt;), you can use &lt;code&gt;returnCallback()&lt;/code&gt; to have the stubbed method return the result of a callback function or method. See &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest6.php&quot;&gt;Example 9.7&lt;/a&gt; for an example.</source>
          <target state="translated">스텁 된 메소드 호출이 고정 된 값 ( &lt;code&gt;returnValue()&lt;/code&gt; 참조 ) 또는 (변경되지 않은) 인수 ( &lt;code&gt;returnArgument()&lt;/code&gt; 참조) 대신 계산 된 값을 리턴해야하는 경우 &lt;code&gt;returnCallback()&lt;/code&gt; 을 사용하여 스텁 된 메소드가 결과를 리턴하도록 할 수 있습니다. 콜백 함수 또는 메소드. &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest6.php&quot;&gt;예는 예 9.7&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49f8f19211f4e2927067d73b212aa0ebae6a020c" translate="yes" xml:space="preserve">
          <source>When the test execution terminates before the &lt;code&gt;tearDown()&lt;/code&gt; method is invoked the directory will stay in the filesystem.</source>
          <target state="translated">&lt;code&gt;tearDown()&lt;/code&gt; 메소드가 호출 되기 전에 테스트 실행이 종료 되면 디렉토리는 파일 시스템에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be8b46c5b8942250c3eba0b21ebd928f347b844" translate="yes" xml:space="preserve">
          <source>When using a large number of datasets it's useful to name each one with string key instead of default numeric. Output will be more verbose as it'll contain that name of a dataset that breaks a test.</source>
          <target state="translated">많은 수의 데이터 세트를 사용하는 경우 기본 숫자 대신 문자열 키를 사용하여 각 데이터 세트의 이름을 지정하는 것이 좋습니다. 테스트를 중단하는 데이터 세트의 이름을 포함하므로 출력이 더 자세합니다.</target>
        </trans-unit>
        <trans-unit id="50169aa0190de9a1300c679d3bcfb09f2855798b" translate="yes" xml:space="preserve">
          <source>When we are writing a test in which we cannot (or chose not to) use a real depended-on component (DOC), we can replace it with a Test Double. The Test Double doesn't have to behave exactly like the real DOC; it merely has to provide the same API as the real one so that the SUT thinks it is the real one!</source>
          <target state="translated">실제 의존 컴포넌트 (DOC)를 사용할 수없는 (또는 사용하지 않는) 테스트를 작성할 때 테스트 더블로 대체 할 수 있습니다. Test Double은 실제 DOC와 똑같이 동작하지 않아도됩니다. SUT가 실제 API라고 생각할 수 있도록 실제 API와 동일한 API 만 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="95e98073b7e27b0f4684172a48b1494f7ed971bf" translate="yes" xml:space="preserve">
          <source>When writing custom assertions it is the best practice to follow how PHPUnit's own assertions are implemented. As you can see in &lt;a href=&quot;extending-phpunit#extending-phpunit.examples.Assert.php&quot;&gt;Example 14.1&lt;/a&gt;, the &lt;code&gt;assertTrue()&lt;/code&gt; method is just a wrapper around the &lt;code&gt;isTrue()&lt;/code&gt; and &lt;code&gt;assertThat()&lt;/code&gt; methods: &lt;code&gt;isTrue()&lt;/code&gt; creates a matcher object that is passed on to &lt;code&gt;assertThat()&lt;/code&gt; for evaluation.</source>
          <target state="translated">커스텀 어설 션을 작성할 때 PHPUnit의 어설 션이 어떻게 구현되는지 따르는 것이 가장 좋습니다. 당신이 볼 수 있듯이 &lt;a href=&quot;extending-phpunit#extending-phpunit.examples.Assert.php&quot;&gt;예 14.1&lt;/a&gt; 의 &lt;code&gt;assertTrue()&lt;/code&gt; 메소드는 a를 주위에 래퍼 &lt;code&gt;isTrue()&lt;/code&gt; 및 &lt;code&gt;assertThat()&lt;/code&gt; : 방법 &lt;code&gt;isTrue()&lt;/code&gt; 에 전달되는 정규 객체 생성 &lt;code&gt;assertThat()&lt;/code&gt; 평가를.</target>
        </trans-unit>
        <trans-unit id="b59585f24f15b219823e254de9f0db222aea80f8" translate="yes" xml:space="preserve">
          <source>When you agree on coordinating your activities with the supplier of a package, you can write the tests together. Do this in such a way that the tests reveal as many assumptions as possible. Hidden assumptions are the death of cooperation. With the tests, you document exactly what you expect from the supplied package. The supplier will know the package is complete when all the tests run.</source>
          <target state="translated">패키지 공급 업체와의 활동 조정에 동의하면 테스트를 함께 작성할 수 있습니다. 테스트에서 가능한 많은 가정이 드러나도록이를 수행하십시오. 숨겨진 가정은 협력의 죽음입니다. 테스트를 통해 제공된 패키지에서 원하는 것을 정확하게 문서화합니다. 공급 업체는 모든 테스트가 실행될 때 패키지가 완료되었음을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="52e12d1d42441315a63147ea08d4f830cf12dc03" translate="yes" xml:space="preserve">
          <source>When you are working on a new test case class, you might want to begin by writing empty test methods such as:</source>
          <target state="translated">새로운 테스트 케이스 클래스에서 작업 할 때 다음과 같은 빈 테스트 메소드를 작성하여 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc1c81606a083020d621842df8391fd0f600c77" translate="yes" xml:space="preserve">
          <source>When you document assumptions with tests, you own the tests. The supplier of the package -- who you make assumptions about -- knows nothing about your tests. If you want to have a closer relationship with the supplier of a package, you can use the tests to communicate and coordinate your activities.</source>
          <target state="translated">테스트를 통해 가정을 문서화하면 테스트를 소유하게됩니다. 패키지 공급 업체 (귀하의 가정)는 테스트에 대해 아무것도 모릅니다. 패키지 공급 업체와 더 긴밀한 관계를 유지하려는 경우 테스트를 사용하여 활동을 전달하고 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b227323596cb1d49d216c73d52a59fbd5c9c6c81" translate="yes" xml:space="preserve">
          <source>When you get a defect report, your impulse might be to fix the defect as quickly as possible. Experience shows that this impulse will not serve you well; it is likely that the fix for the defect causes another defect.</source>
          <target state="translated">결함 보고서를 받으면 가능한 빨리 결함을 수정해야합니다. 경험에 의하면이 충동이 당신에게 잘 맞지 않을 것입니다. 결함에 대한 수정으로 인해 다른 결함이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80af9e23609590d6899ef8d3901fc68097d07e39" translate="yes" xml:space="preserve">
          <source>When you need to add new functionality to the system, write the tests first. Then, you will be done developing when the test runs. This practice will be discussed in detail in the next chapter.</source>
          <target state="translated">시스템에 새로운 기능을 추가해야 할 경우 먼저 테스트를 작성하십시오. 그런 다음 테스트가 실행될 때 개발이 완료됩니다. 이 연습은 다음 장에서 자세히 논의 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2a06ba48d153db1ee538c313ddd441fa8fc16ee" translate="yes" xml:space="preserve">
          <source>When you need to make a change to the internal structure of the software you are working on to make it easier to understand and cheaper to modify without changing its observable behavior, a test suite is invaluable in applying these so called &lt;a href=&quot;http://martinfowler.com/bliki/DefinitionOfRefactoring.html&quot;&gt;refactorings&lt;/a&gt; safely. Otherwise, you might not notice the system breaking while you are carrying out the restructuring.</source>
          <target state="translated">관찰 가능한 동작을 변경하지 않고 이해하기 쉽고 저렴하게 수정하기 위해 작업중인 소프트웨어의 내부 구조를 변경해야하는 경우 테스트 스위트는 소위 &lt;a href=&quot;http://martinfowler.com/bliki/DefinitionOfRefactoring.html&quot;&gt;리팩토링을&lt;/a&gt; 안전하게 적용하는 데 매우 중요 합니다. 그렇지 않으면 구조 조정을 수행하는 동안 시스템이 손상되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee25f858f8dc07f3b69a592734c66c2c0832323" translate="yes" xml:space="preserve">
          <source>When your application interacts with a web service you want to test it without actually interacting with the web service. To make the stubbing and mocking of web services easy, the &lt;code&gt;getMockFromWsdl()&lt;/code&gt; can be used just like &lt;code&gt;getMock()&lt;/code&gt; (see above). The only difference is that &lt;code&gt;getMockFromWsdl()&lt;/code&gt; returns a stub or mock based on a web service description in WSDL and &lt;code&gt;getMock()&lt;/code&gt; returns a stub or mock based on a PHP class or interface.</source>
          <target state="translated">응용 프로그램이 웹 서비스와 상호 작용할 때 실제로 웹 서비스와 상호 작용하지 않고 테스트하려고합니다. 스터 빙을 쉽게 웹 서비스를 조롱하기 위해, &lt;code&gt;getMockFromWsdl()&lt;/code&gt; 처럼 사용할 수 있습니다 &lt;code&gt;getMock()&lt;/code&gt; (위 참조). 유일한 차이점은 &lt;code&gt;getMockFromWsdl()&lt;/code&gt; 이 WSDL의 웹 서비스 설명을 기반으로 스텁 또는 모의를 리턴 하고 &lt;code&gt;getMock()&lt;/code&gt; 은 PHP 클래스 또는 인터페이스를 기반으로 스텁 또는 모의를 리턴한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7903c1b33bff5cb437ad68da9b2ea5f628df7f7e" translate="yes" xml:space="preserve">
          <source>Whenever a test fails PHPUnit tries its best to provide you with as much context as possible that can help to identify the problem.</source>
          <target state="translated">테스트가 실패 할 때마다 PHPUnit은 문제를 식별하는 데 도움이되는 가능한 많은 컨텍스트를 제공하기 위해 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="0709917e388ac8733124d676879302ae3b1a068d" translate="yes" xml:space="preserve">
          <source>Whenever you are tempted to type something into a &lt;code&gt;print&lt;/code&gt; statement or a debugger expression, write it as a test instead.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 문이나 디버거 식에 무언가를 입력하려고 할 때마다 대신 테스트로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e937368555fce02eeb1adfa4f2e97ac617a86c71" translate="yes" xml:space="preserve">
          <source>While this is very convenient for editing with Excel or OpenOffice, you cannot specify NULL values with the CSV dataset. An empty column will lead to the database default empty value being inserted into the column.</source>
          <target state="translated">이는 Excel 또는 OpenOffice로 편집하는 데 매우 편리하지만 CSV 데이터 세트로 NULL 값을 지정할 수 없습니다. 빈 열은 데이터베이스 기본 빈 값이 열에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bf6edecb4d699b5c1f0cd67b77dbc2e51f71ef" translate="yes" xml:space="preserve">
          <source>Whitelisting Files</source>
          <target state="translated">화이트리스트 파일</target>
        </trans-unit>
        <trans-unit id="184f652d531056bd963c11d37ccd5526523caa00" translate="yes" xml:space="preserve">
          <source>Whitelisting Files for Code Coverage</source>
          <target state="translated">코드 적용을위한 파일 허용</target>
        </trans-unit>
        <trans-unit id="86c7429c642e4aea1befd537be31240728fcb172" translate="yes" xml:space="preserve">
          <source>Will PHPUnit (re-)create the database schema for each test?</source>
          <target state="translated">PHPUnit은 각 테스트에 대한 데이터베이스 스키마를 (재) 생성합니까?</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="b2d890362b7721a4a0b744a62a04801a95ca52ea" translate="yes" xml:space="preserve">
          <source>Without a virtual filesystem such as vfsStream we cannot test the &lt;code&gt;setDirectory()&lt;/code&gt; method in isolation from external influence (see &lt;a href=&quot;test-doubles#test-doubles.mocking-the-filesystem.examples.ExampleTest.php&quot;&gt;Example 9.22&lt;/a&gt;).</source>
          <target state="translated">vfsStream과 같은 가상 파일 시스템이 없으면 외부 영향과 별도로 &lt;code&gt;setDirectory()&lt;/code&gt; 메소드를 테스트 할 수 없습니다 ( &lt;a href=&quot;test-doubles#test-doubles.mocking-the-filesystem.examples.ExampleTest.php&quot;&gt;예 9.22&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f71680b834fbbe95782fba63d95147a749c8be11" translate="yes" xml:space="preserve">
          <source>Without the error suppression the test would fail reporting &lt;code&gt;fopen(/is-not-writeable/file): failed to open stream:
    No such file or directory&lt;/code&gt;.</source>
          <target state="translated">오류 억제가 없으면 테스트에서 &lt;code&gt;fopen(/is-not-writeable/file): failed to open stream: No such file or directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedccc4867405a3471be8233f4ebe9a6a2bb2de6" translate="yes" xml:space="preserve">
          <source>Write all the rows in the data-tables into the database.</source>
          <target state="translated">데이터 테이블의 모든 행을 데이터베이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="8bbbfaf5377d2e03efa933060317a93421ed5861" translate="yes" xml:space="preserve">
          <source>Write an automated test that fails now but will succeed when the defect is fixed.</source>
          <target state="translated">지금은 실패하지만 결함이 수정되면 성공할 자동화 테스트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="aa0c42ef3cef9d392f3dcac3d09402d1957f6344" translate="yes" xml:space="preserve">
          <source>Write custom assertions</source>
          <target state="translated">사용자 지정 어설 ​​션 작성</target>
        </trans-unit>
        <trans-unit id="f709732b2211c2a981b1be285ece585e168e3822" translate="yes" xml:space="preserve">
          <source>Write custom assertions and utility methods in an abstract subclass of &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; and derive your test case classes from that class. This is one of the easiest ways to extend PHPUnit.</source>
          <target state="translated">&lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; 의 추상 서브 클래스에 사용자 정의 어설 션 및 유틸리티 메소드를 작성 하고 해당 클래스에서 테스트 케이스 클래스를 파생하십시오. 이것은 PHPUnit을 확장하는 가장 쉬운 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="35a3852a23915596995ef8635dc6fbd161c3dfce" translate="yes" xml:space="preserve">
          <source>Writing Tests for PHPUnit</source>
          <target state="translated">PHPUnit 쓰기 시험</target>
        </trans-unit>
        <trans-unit id="f063b9902b860031f4c625394b61325a4440e2df" translate="yes" xml:space="preserve">
          <source>XML DataSet</source>
          <target state="translated">XML 데이터 셋</target>
        </trans-unit>
        <trans-unit id="1a211ee8d43cfaa8129da355009a4dfe2c9d149d" translate="yes" xml:space="preserve">
          <source>Xdebug is not distributed as part of PHPUnit. If you receive a notice while running tests that the Xdebug extension is not loaded, it means that Xdebug is either not installed or not configured properly. Before you can use the code coverage analysis features in PHPUnit, you should read &lt;a href=&quot;http://xdebug.org/docs/install&quot;&gt;the Xdebug installation guide&lt;/a&gt;.</source>
          <target state="translated">Xdebug는 PHPUnit의 일부로 배포되지 않습니다. 테스트를 실행하는 동안 Xdebug 확장 프로그램이로드되지 않았다는 알림을 받으면 Xdebug가 설치되지 않았거나 올바르게 구성되지 않았 음을 의미합니다. PHPUnit에서 코드 적용 범위 분석 기능을 사용하기 전에 &lt;a href=&quot;http://xdebug.org/docs/install&quot;&gt;Xdebug 설치 안내서를&lt;/a&gt; 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="9ab582c7e8e9b5fe420c617b0de1cf591044edbc" translate="yes" xml:space="preserve">
          <source>YAML DataSet</source>
          <target state="translated">YAML 데이터 세트</target>
        </trans-unit>
        <trans-unit id="92116dc581c2238ebeff646dd12b48fd3c73d53c" translate="yes" xml:space="preserve">
          <source>You can also assert the result of complex queries with the Query Table approach, just specify a result name with a query and compare it to a dataset:</source>
          <target state="translated">쿼리 테이블 접근 방식을 사용하여 복잡한 쿼리 결과를 어설 션하고 쿼리로 결과 이름을 지정하고 데이터 세트와 비교하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc5fa00c7042ab0755b71b736e98f12f97c3cb3" translate="yes" xml:space="preserve">
          <source>You can always write more tests. However, you will quickly find that only a fraction of the tests you can imagine are actually useful. What you want is to write tests that fail even though you think they should work, or tests that succeed even though you think they should fail. Another way to think of it is in cost/benefit terms. You want to write tests that will pay you back with information.</source>
          <target state="translated">언제든지 더 많은 테스트를 작성할 수 있습니다. 그러나 상상할 수있는 일부 테스트 만 실제로 유용하다는 것을 금방 알 수 있습니다. 원하는 것은 작동한다고 생각하더라도 실패하는 테스트 또는 실패한다고 생각하더라도 성공하는 테스트를 작성하는 것입니다. 그것을 생각하는 또 다른 방법은 비용 / 혜택 용어입니다. 정보를 갚을 테스트를 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a078cfc20a1095c008a47b877929c52dcf17f7ba" translate="yes" xml:space="preserve">
          <source>You can construct the DataSet on your own:</source>
          <target state="translated">자체적으로 DataSet을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0ece83c2819ca556ba1bbe02db176b21c66ad6" translate="yes" xml:space="preserve">
          <source>You can create a CSV DataSet by calling:</source>
          <target state="translated">다음을 호출하여 CSV DataSet을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faaae67de0688c386d3951e4268fbd9886d58198" translate="yes" xml:space="preserve">
          <source>You can create a flat xml dataset instance from within your Database TestCase by calling the &lt;code&gt;createFlatXmlDataSet($filename)&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;createFlatXmlDataSet($filename)&lt;/code&gt; 메소드 를 호출하여 Database TestCase에서 플랫 XML 데이터 세트 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd55e47e6f5448be88daf55231adfb811342e4b6" translate="yes" xml:space="preserve">
          <source>You can create a xml dataset instance from within your Database TestCase by calling the &lt;code&gt;createXmlDataSet($filename)&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;createXmlDataSet($filename)&lt;/code&gt; 메소드 를 호출하여 Database TestCase 내에서 xml 데이터 세트 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef1fd4cb18bb341f1f611051d4eb5390bf51f2e1" translate="yes" xml:space="preserve">
          <source>You can either create a dataset for the complete database as shown in &lt;code&gt;testGuestbook()&lt;/code&gt;, or restrict it to a set of specified table names with a whitelist as shown in &lt;code&gt;testFilteredGuestbook()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;testGuestbook()&lt;/code&gt; 표시된대로 전체 데이터베이스에 대한 데이터 세트를 작성 하거나 &lt;code&gt;testFilteredGuestbook()&lt;/code&gt; 메소드에 표시된대로 화이트리스트를 사용하여 지정된 테이블 이름 세트로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f7cc1a377c1b4d060eaa2721f4972418ff9fe7b" translate="yes" xml:space="preserve">
          <source>You can hold your impulse in check by doing the following:</source>
          <target state="translated">다음을 수행하여 충동을 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="439557ef6ce462ccc9abe19f1c0c6834640046d2" translate="yes" xml:space="preserve">
          <source>You can make use of this by specifying arbitrary queries for your tables, for example restricting rows, column or adding &lt;code&gt;ORDER BY&lt;/code&gt; clauses:</source>
          <target state="translated">테이블에 대해 임의의 쿼리를 지정하여 (예 : 행, 열 제한 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 절 추가)이 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59729c99eefa0308f0c82103df85c243c42ab048" translate="yes" xml:space="preserve">
          <source>You can provide a blacklist of static attributes that are to be excluded from the backup and restore operations:</source>
          <target state="translated">백업 및 복원 조작에서 제외 될 정적 속성의 블랙리스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="237329f4706c8047eb918f75173ecc73be0f89a9" translate="yes" xml:space="preserve">
          <source>You can use a &lt;em&gt;mock object&lt;/em&gt; &quot;as an observation point that is used to verify the indirect outputs of the SUT as it is exercised. Typically, the mock object also includes the functionality of a test stub in that it must return values to the SUT if it hasn't already failed the tests but the emphasis is on the verification of the indirect outputs. Therefore, a mock object is a lot more than just a test stub plus assertions; it is used in a fundamentally different way&quot; (Gerard Meszaros).</source>
          <target state="translated">&lt;em&gt;모의 객체를&lt;/em&gt; &quot;SUT가 실행되는 SUT의 간접 출력을 확인하는 데 사용되는 관찰 지점으로 사용할 수 있습니다 . 일반적으로 모의 객체에는 테스트 스텁의 기능도 포함되어 있습니다.이 경우 SUT에 값을 반환해야합니다. 아직 테스트에 실패하지는 않았지만 간접 출력의 검증에 중점을두고 있습니다. 따라서 모의 객체는 테스트 스텁과 어설 션 이상의 의미를 갖습니다. 근본적으로 다른 방식으로 사용됩니다 &quot;(Gerard Meszaros) .</target>
        </trans-unit>
        <trans-unit id="83a9f9b403d591a5b39991a8cb2753b779d55e93" translate="yes" xml:space="preserve">
          <source>You can use the Database (DB) DataSet from the Connection and compare it to a File-Based DataSet.</source>
          <target state="translated">연결에서 데이터베이스 (DB) 데이터 세트를 사용하여 파일 기반 데이터 세트와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6ad16fdeaf557b757b56ce17b64851641f61d7" translate="yes" xml:space="preserve">
          <source>You can wrap test cases or test suites in a subclass of &lt;code&gt;PHPUnit_Extensions_TestDecorator&lt;/code&gt; and use the Decorator design pattern to perform some actions before and after the test runs.</source>
          <target state="translated">&lt;code&gt;PHPUnit_Extensions_TestDecorator&lt;/code&gt; 의 서브 클래스에서 테스트 케이스 또는 테스트 스위트를 랩핑 하고 Decorator 디자인 패턴을 사용하여 테스트 실행 전후에 일부 조치를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b411f985dfd24d4d5a43b3e5fafa146531086a" translate="yes" xml:space="preserve">
          <source>You do not want to modify considerable amount of test code for little changes in your production code.</source>
          <target state="translated">프로덕션 코드에서 약간의 변경을 위해 상당한 양의 테스트 코드를 수정하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1166c18cc123a82d7f724936aa93187490a0ef4" translate="yes" xml:space="preserve">
          <source>You may also use the downloaded PHAR file directly:</source>
          <target state="translated">다운로드 한 PHAR 파일을 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ee9de3287ccffd61d361237d08e22eb63cecfc" translate="yes" xml:space="preserve">
          <source>You need to setup test data in (possibly much) more than two tables to get reasonable initial data for the methods you want to test.</source>
          <target state="translated">테스트하려는 메소드에 대한 합리적인 초기 데이터를 얻으려면 테스트 데이터를 두 개 이상의 테이블에 설정해야합니다 (아마도).</target>
        </trans-unit>
        <trans-unit id="605def75161cce7a74547ef770e763d8f697e38f" translate="yes" xml:space="preserve">
          <source>You probably know this scenario from your daily work and projects, where you want to put your fresh or experienced PHPUnit skills to work and get stuck by one of the following problems:</source>
          <target state="translated">신선하거나 경험이 풍부한 PHPUnit 기술을 사용하고 다음 문제 중 하나에 걸리고 싶은 일상적인 작업 및 프로젝트에서이 시나리오를 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f371634166190eaf82bc041670a87fc6a2dcb00a" translate="yes" xml:space="preserve">
          <source>You should be as specific as possible when testing exceptions. Testing for classes that are too generic might lead to undesirable side-effects. Accordingly, testing for the &lt;code&gt;Exception&lt;/code&gt; class with &lt;code&gt;@expectedException&lt;/code&gt; or &lt;code&gt;setExpectedException()&lt;/code&gt; is no longer permitted.</source>
          <target state="translated">예외를 테스트 할 때는 가능한 구체적이어야합니다. 너무 일반적인 클래스를 테스트하면 바람직하지 않은 부작용이 발생할 수 있습니다. 따라서 &lt;code&gt;@expectedException&lt;/code&gt; 또는 &lt;code&gt;setExpectedException()&lt;/code&gt; 을 사용하여 &lt;code&gt;Exception&lt;/code&gt; 클래스에 대한 테스트 는 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2b376e5a6c1ec649252349f9914ce87243a3529" translate="yes" xml:space="preserve">
          <source>You want to be able to read and understand the test code easily, even months after writing it.</source>
          <target state="translated">테스트 코드를 작성한 후 몇 개월이 지나도 쉽게 테스트 코드를 읽고 이해할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="f1b013c701ed496ba56f01c975e4081827666f70" translate="yes" xml:space="preserve">
          <source>You won't need additional files for assertions and can specify them directly in the TestCase.</source>
          <target state="translated">어설 션을위한 추가 파일이 필요하지 않으며 TestCase에서 직접 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ede8d917a46c3eb5e5fb6e455b4243b4b94f73d" translate="yes" xml:space="preserve">
          <source>Your business logic performs a mix of SELECT, INSERT, UPDATE and DELETE statements.</source>
          <target state="translated">비즈니스 로직은 SELECT, INSERT, UPDATE 및 DELETE 문을 혼합하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e408787b79a3308258aca3560fbc83d290773a29" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;fixture2.xml&lt;/em&gt;:</source>
          <target state="translated">및 &lt;em&gt;fixture2.xml&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a78da1b13adfdedef3f1bdb6aaf4c3e389aad03b" translate="yes" xml:space="preserve">
          <source>assertArrayHasKey()</source>
          <target state="translated">assertArrayHasKey()</target>
        </trans-unit>
        <trans-unit id="2953b43f13241d2e3cd276715de3bff946c20d30" translate="yes" xml:space="preserve">
          <source>assertArraySubset()</source>
          <target state="translated">assertArraySubset()</target>
        </trans-unit>
        <trans-unit id="a0c879edb53ee997bd7d82bd1fbc196e632b95d9" translate="yes" xml:space="preserve">
          <source>assertClassHasAttribute()</source>
          <target state="translated">assertClassHasAttribute()</target>
        </trans-unit>
        <trans-unit id="3c2ab1335fd5a18000ffe25079ed36c51847dd61" translate="yes" xml:space="preserve">
          <source>assertClassHasStaticAttribute()</source>
          <target state="translated">assertClassHasStaticAttribute()</target>
        </trans-unit>
        <trans-unit id="d4d83fecf7ab236a0a17aac75ff7f4dd28930221" translate="yes" xml:space="preserve">
          <source>assertContains()</source>
          <target state="translated">assertContains()</target>
        </trans-unit>
        <trans-unit id="688e3b55f1e31b0801c63033e34994afe7d59380" translate="yes" xml:space="preserve">
          <source>assertContainsOnly()</source>
          <target state="translated">assertContainsOnly()</target>
        </trans-unit>
        <trans-unit id="0c8af844c8fccefb6537fe00845eeea118bbd356" translate="yes" xml:space="preserve">
          <source>assertContainsOnlyInstancesOf()</source>
          <target state="translated">assertContainsOnlyInstancesOf()</target>
        </trans-unit>
        <trans-unit id="961c3e8662def888f4511a97c4f41e3757d19e7f" translate="yes" xml:space="preserve">
          <source>assertCount()</source>
          <target state="translated">assertCount()</target>
        </trans-unit>
        <trans-unit id="96ceb5ab03b2a734958bb1dd795383194a3d95c2" translate="yes" xml:space="preserve">
          <source>assertDirectoryExists()</source>
          <target state="translated">assertDirectoryExists()</target>
        </trans-unit>
        <trans-unit id="4544c145eddcc1b4575bb4cdd70a13848be84f70" translate="yes" xml:space="preserve">
          <source>assertDirectoryIsReadable()</source>
          <target state="translated">assertDirectoryIsReadable()</target>
        </trans-unit>
        <trans-unit id="34a0a31ad30c150a9e5247abc4fb085d7367d1ca" translate="yes" xml:space="preserve">
          <source>assertDirectoryIsWritable()</source>
          <target state="translated">assertDirectoryIsWritable()</target>
        </trans-unit>
        <trans-unit id="174d89589791a9491723378104e29bf46c03dbf6" translate="yes" xml:space="preserve">
          <source>assertEmpty()</source>
          <target state="translated">assertEmpty()</target>
        </trans-unit>
        <trans-unit id="9a5438a52e50bca545784cf7955c28bb2d98442c" translate="yes" xml:space="preserve">
          <source>assertEqualXMLStructure()</source>
          <target state="translated">assertEqualXMLStructure()</target>
        </trans-unit>
        <trans-unit id="23ccb551a3cdb1d2bd5c433b6c1d201359698e8e" translate="yes" xml:space="preserve">
          <source>assertEquals()</source>
          <target state="translated">assertEquals()</target>
        </trans-unit>
        <trans-unit id="6d46d5b6994420e250f3385039725d27ac3ecb42" translate="yes" xml:space="preserve">
          <source>assertFalse()</source>
          <target state="translated">assertFalse()</target>
        </trans-unit>
        <trans-unit id="c20b9f1a89ade2bfc6804ff44de2b0c75c7bda92" translate="yes" xml:space="preserve">
          <source>assertFileEquals()</source>
          <target state="translated">assertFileEquals()</target>
        </trans-unit>
        <trans-unit id="654f4244568f9ec544b303f3e1ed51205d669205" translate="yes" xml:space="preserve">
          <source>assertFileExists()</source>
          <target state="translated">assertFileExists()</target>
        </trans-unit>
        <trans-unit id="58bde623ebc5a2b744a207aa641050ab3fd58f8b" translate="yes" xml:space="preserve">
          <source>assertFileIsReadable()</source>
          <target state="translated">assertFileIsReadable()</target>
        </trans-unit>
        <trans-unit id="c68fa67118b75c3d4a1f0efd62378313d3113816" translate="yes" xml:space="preserve">
          <source>assertFileIsWritable()</source>
          <target state="translated">assertFileIsWritable()</target>
        </trans-unit>
        <trans-unit id="d79190d5b985d820ee4285db5373b9f6e44e3624" translate="yes" xml:space="preserve">
          <source>assertGreaterThan()</source>
          <target state="translated">assertGreaterThan()</target>
        </trans-unit>
        <trans-unit id="d30c28860338bc110c65a0e74fbe208c835a5543" translate="yes" xml:space="preserve">
          <source>assertGreaterThanOrEqual()</source>
          <target state="translated">assertGreaterThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="bcafb217fb4f91be35bb7855a99c304df46f0415" translate="yes" xml:space="preserve">
          <source>assertInfinite()</source>
          <target state="translated">assertInfinite()</target>
        </trans-unit>
        <trans-unit id="f29777c90474ee551ac8002f589576c2d13ed4ff" translate="yes" xml:space="preserve">
          <source>assertInstanceOf()</source>
          <target state="translated">assertInstanceOf()</target>
        </trans-unit>
        <trans-unit id="a14e8e87a44fab357571956b107842d15cc9cd43" translate="yes" xml:space="preserve">
          <source>assertInternalType()</source>
          <target state="translated">assertInternalType()</target>
        </trans-unit>
        <trans-unit id="ed60d782ca77fcdf5ecb50a50a6b12b4aa21c26b" translate="yes" xml:space="preserve">
          <source>assertIsReadable()</source>
          <target state="translated">assertIsReadable()</target>
        </trans-unit>
        <trans-unit id="7c70571c21b9c255b3b874ab2c70cb977bcc167c" translate="yes" xml:space="preserve">
          <source>assertIsWritable()</source>
          <target state="translated">assertIsWritable()</target>
        </trans-unit>
        <trans-unit id="fbe7df4f678c83d5efbdf61919cd943803f139f8" translate="yes" xml:space="preserve">
          <source>assertJsonFileEqualsJsonFile()</source>
          <target state="translated">assertJsonFileEqualsJsonFile()</target>
        </trans-unit>
        <trans-unit id="28dbfdff7f46a430978277b473d19ebc0ab18a8a" translate="yes" xml:space="preserve">
          <source>assertJsonStringEqualsJsonFile()</source>
          <target state="translated">assertJsonStringEqualsJsonFile()</target>
        </trans-unit>
        <trans-unit id="b0bf6fda1b66a2c05bd5b4a85fae7a0da44ceef6" translate="yes" xml:space="preserve">
          <source>assertJsonStringEqualsJsonString()</source>
          <target state="translated">assertJsonStringEqualsJsonString()</target>
        </trans-unit>
        <trans-unit id="5ed936b15a579166dd241321758f48de026405b8" translate="yes" xml:space="preserve">
          <source>assertLessThan()</source>
          <target state="translated">assertLessThan()</target>
        </trans-unit>
        <trans-unit id="2ff7c6828a81e20d73b86a95f2bfad68c64eb0b9" translate="yes" xml:space="preserve">
          <source>assertLessThanOrEqual()</source>
          <target state="translated">assertLessThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="cb8ff9ef384b09e12546f6577d926fbe708457a9" translate="yes" xml:space="preserve">
          <source>assertNan()</source>
          <target state="translated">assertNan()</target>
        </trans-unit>
        <trans-unit id="e7bcdbce6f11f87ce1c9b5e0f80ae2686479b45b" translate="yes" xml:space="preserve">
          <source>assertNull()</source>
          <target state="translated">assertNull()</target>
        </trans-unit>
        <trans-unit id="daa66dd44d78be88c535a424c886e05f83dfe921" translate="yes" xml:space="preserve">
          <source>assertObjectHasAttribute()</source>
          <target state="translated">assertObjectHasAttribute()</target>
        </trans-unit>
        <trans-unit id="49b69a515c563526ed56083eeaa0b3f5a35dd459" translate="yes" xml:space="preserve">
          <source>assertRegExp()</source>
          <target state="translated">assertRegExp()</target>
        </trans-unit>
        <trans-unit id="df4b41e034cb3fb9cbfb8c7d0282908291bb7729" translate="yes" xml:space="preserve">
          <source>assertSame()</source>
          <target state="translated">assertSame()</target>
        </trans-unit>
        <trans-unit id="5ab4e871ad3cb768ca57420fcff36afc7846db53" translate="yes" xml:space="preserve">
          <source>assertStringEndsWith()</source>
          <target state="translated">assertStringEndsWith()</target>
        </trans-unit>
        <trans-unit id="722ed30f2b6991c0dde3b61a96aaf9a77a963f4b" translate="yes" xml:space="preserve">
          <source>assertStringEqualsFile()</source>
          <target state="translated">assertStringEqualsFile()</target>
        </trans-unit>
        <trans-unit id="d4d11de435f688fc4a15c4086b65541c8ff9576d" translate="yes" xml:space="preserve">
          <source>assertStringMatchesFormat()</source>
          <target state="translated">assertStringMatchesFormat()</target>
        </trans-unit>
        <trans-unit id="ed2b8fe213436da04bb2ec4123a90169f1cb278f" translate="yes" xml:space="preserve">
          <source>assertStringMatchesFormatFile()</source>
          <target state="translated">assertStringMatchesFormatFile()</target>
        </trans-unit>
        <trans-unit id="1cb66de67f876bdbe76e70cce0c9221219d00043" translate="yes" xml:space="preserve">
          <source>assertStringStartsWith()</source>
          <target state="translated">assertStringStartsWith()</target>
        </trans-unit>
        <trans-unit id="040de4ae88cba81c3d3a61b56e2d5a8a6cd4214b" translate="yes" xml:space="preserve">
          <source>assertThat()</source>
          <target state="translated">assertThat()</target>
        </trans-unit>
        <trans-unit id="a1fe128ba75fa817bbdd95449b30363cc8d8e330" translate="yes" xml:space="preserve">
          <source>assertTrue()</source>
          <target state="translated">assertTrue()</target>
        </trans-unit>
        <trans-unit id="16e7c06470e678ce6643bcc65a4a7f292000a02e" translate="yes" xml:space="preserve">
          <source>assertXmlFileEqualsXmlFile()</source>
          <target state="translated">assertXmlFileEqualsXmlFile()</target>
        </trans-unit>
        <trans-unit id="26d75addf4ae3317e3f0ab65664753edab70a8a1" translate="yes" xml:space="preserve">
          <source>assertXmlStringEqualsXmlFile()</source>
          <target state="translated">assertXmlStringEqualsXmlFile()</target>
        </trans-unit>
        <trans-unit id="145b4f7f69ec5df4adba1328742fb5f422e41906" translate="yes" xml:space="preserve">
          <source>assertXmlStringEqualsXmlString()</source>
          <target state="translated">assertXmlStringEqualsXmlString()</target>
        </trans-unit>
        <trans-unit id="978d00dde011c95df5d89a506062e2a7562fb626" translate="yes" xml:space="preserve">
          <source>convertErrorsToExceptions</source>
          <target state="translated">convertErrorsToExceptions</target>
        </trans-unit>
        <trans-unit id="af6864cd9015ff0e9aacd657c2fa2eb4827b59d3" translate="yes" xml:space="preserve">
          <source>convertNoticesToExceptions</source>
          <target state="translated">convertNoticesToExceptions</target>
        </trans-unit>
        <trans-unit id="2429b52a4818bb6fa6ba35442ed1d755d37476b0" translate="yes" xml:space="preserve">
          <source>convertWarningsToExceptions</source>
          <target state="translated">convertWarningsToExceptions</target>
        </trans-unit>
        <trans-unit id="5c1fbc1be607e4191f388fde6043defa3dd9c4db" translate="yes" xml:space="preserve">
          <source>forceCoversAnnotation</source>
          <target state="translated">forceCoversAnnotation</target>
        </trans-unit>
        <trans-unit id="3c1c518262f2ecc3844375807272f6051c4e067a" translate="yes" xml:space="preserve">
          <source>phpunit UnitTest</source>
          <target state="translated">phpunit 단위 테스트</target>
        </trans-unit>
        <trans-unit id="b6dbd075e0264852bf66054810ba76350adbae6f" translate="yes" xml:space="preserve">
          <source>phpunit UnitTest UnitTest.php</source>
          <target state="translated">phpunit UnitTest UnitTest.php</target>
        </trans-unit>
        <trans-unit id="3594ac45a6f4809d908a03c0802a9806d1fc1c36" translate="yes" xml:space="preserve">
          <source>timeoutForLargeTests</source>
          <target state="translated">timeoutForLargeTests</target>
        </trans-unit>
        <trans-unit id="bdc16f7d773e4b7fc038cce005d41d6c52b2345d" translate="yes" xml:space="preserve">
          <source>timeoutForMediumTests</source>
          <target state="translated">timeoutForMediumTests</target>
        </trans-unit>
        <trans-unit id="a6dca61e251aea5eb30244ab82d118c907482e6f" translate="yes" xml:space="preserve">
          <source>timeoutForSmallTests</source>
          <target state="translated">timeoutForSmallTests</target>
        </trans-unit>
        <trans-unit id="4ccfdd2606dd6d436bdbce99e9f436a8561c098a" translate="yes" xml:space="preserve">
          <source>to keep track of the tests that you have to write. The problem with empty test methods is that they are interpreted as a success by the PHPUnit framework. This misinterpretation leads to the test reports being useless -- you cannot see whether a test is actually successful or just not yet implemented. Calling &lt;code&gt;$this-&amp;gt;fail()&lt;/code&gt; in the unimplemented test method does not help either, since then the test will be interpreted as a failure. This would be just as wrong as interpreting an unimplemented test as a success.</source>
          <target state="translated">작성해야 할 테스트를 추적합니다. 빈 테스트 메소드의 문제점은 PHPUnit 프레임 워크에서 성공한 것으로 해석된다는 것입니다. 이 잘못된 해석으로 인해 테스트 보고서가 쓸모 없게됩니다. 테스트가 실제로 성공했는지 아니면 아직 구현되지 않았는지 알 수 없습니다. 구현되지 않은 테스트 메소드에서 &lt;code&gt;$this-&amp;gt;fail()&lt;/code&gt; 을 호출 해도 도움이되지 않습니다. 테스트가 실패로 해석되기 때문입니다. 이것은 구현되지 않은 테스트를 성공으로 해석하는 것만큼이나 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6ee72296d42470b3297273534b56130c2b1b8c8" translate="yes" xml:space="preserve">
          <source>vfsStream gives the test developer full control over what the filesystem environment looks like to the tested code.</source>
          <target state="translated">vfsStream은 테스트 개발자가 테스트 한 코드에 대해 파일 시스템 환경의 모양을 완전히 제어 할 수 있도록합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
