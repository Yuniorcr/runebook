<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
