<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rxjs">
    <body>
      <group id="rxjs">
        <trans-unit id="2f4c93f0d3ec8302bf0b200dd6c3aad56672bfa9" translate="yes" xml:space="preserve">
          <source>Lets values pass until a second Observable, &lt;code&gt;notifier&lt;/code&gt;, emits a value. Then, it completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd6438c656604bb57a5d06906bc6b777c9d6f12" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;debouncetime&quot;&gt;&lt;code&gt;debounceTime&lt;/code&gt;&lt;/a&gt;, this is a rate-limiting operator, and also a delay-like operator since output emissions do not necessarily occur at the same time as they did on the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1affe0b85072e0a70b5ddc1cdb5148ac709bec9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, but emit with error notification if there is more than one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6027fb0cebc4a4a731ee9e86317539317da788" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;Array.prototype.filter()&lt;/a&gt;, it only emits a value from the source if it passes a criterion function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87a9a9dd0a5b89ede6c0afe2fc2f5e49078c40b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;Array.prototype.map()&lt;/a&gt;, it passes each source value through a transformation function to get corresponding output values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67caf41bbd96dfec9c50e5c0a18a696f783d3ff2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;Array.prototype.reduce()&lt;/a&gt;, &lt;code&gt;reduce&lt;/code&gt; applies an &lt;code&gt;accumulator&lt;/code&gt; function against an accumulation and each value of the source Observable (from the past) to reduce it to a single value, emitted on the output Observable. Note that &lt;code&gt;reduce&lt;/code&gt; will only emit one value, only when the source Observable completes. It is equivalent to applying operator &lt;a href=&quot;scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; followed by operator &lt;a href=&quot;last&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8676a28f75765f67eacf9e003d098d9e7e2d40d0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but it maps every source value to the same output value every time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0787c33143d8c23a40b4a0795fc6b9713add45c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but meant only for picking one of the nested properties of every emitted object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77459219eef548fe8bae583a6b4b009fd0f26e8a" translate="yes" xml:space="preserve">
          <source>Likewise, unspecified errors will just default to the string &lt;code&gt;&quot;error&quot;&lt;/code&gt;, so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f780ac75b9d7308a66b754ca521f205933c0a50" translate="yes" xml:space="preserve">
          <source>Limit click rate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c262a6bebd9712fef67d3f0dc060dc767e6c402" translate="yes" xml:space="preserve">
          <source>List of DOM Nodes, returned for example by &lt;code&gt;document.querySelectorAll&lt;/code&gt; or &lt;code&gt;Node.childNodes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0df665d645edaa8c6051a873a9b18cf3d884e34" translate="yes" xml:space="preserve">
          <source>Listening for messages from the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77db58fafd4e5e8dbf436714e9738cc9aeee81fe" translate="yes" xml:space="preserve">
          <source>Make a &lt;a href=&quot;../index/class/connectableobservable&quot;&gt;&lt;code&gt;ConnectableObservable&lt;/code&gt;&lt;/a&gt; behave like a ordinary observable and automates the way you can connect to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c0d7d762cc65626984714e3d2f157f2e06558d" translate="yes" xml:space="preserve">
          <source>Make source$ hot by applying publish operator, then merge each inner observable into a single one and subscribe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf6fbf320d6be731c30c46263fffd5a11db52b3" translate="yes" xml:space="preserve">
          <source>Make the result values as obvious as possible as to what they represent, these are &lt;em&gt;tests&lt;/em&gt; afterall, we want clarity more than efficiency, so &lt;code&gt;x: 1 + 3, // a + c&lt;/code&gt; is better than just &lt;code&gt;x: 4&lt;/code&gt;. The former conveys &lt;em&gt;why&lt;/em&gt; it's 4, the latter does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beec6e17037381a74db913b3553fa4383f4a15ea" translate="yes" xml:space="preserve">
          <source>Makes a cold Observable hot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2102d2edb1284e9da444a32dcc6e577189eaae" translate="yes" xml:space="preserve">
          <source>Manually unsubscribe from a source that will never complete:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2397752cbaf071d895293805670cba8b6f653e0d" translate="yes" xml:space="preserve">
          <source>Map and flatten each letter to an Observable ticking every 1 second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fd25a315c3692fbbd44605785e312521c81e65" translate="yes" xml:space="preserve">
          <source>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8f99c60056fe6da67912b65c9274a4a92d5470" translate="yes" xml:space="preserve">
          <source>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b6deda0e5414681d613113b2660b4099b8491b" translate="yes" xml:space="preserve">
          <source>Map every click to the clientX position of that click</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07089b4ce36a1733082eccac7e58148fa346a0b7" translate="yes" xml:space="preserve">
          <source>Map every click to the clientX position of that click, while also logging the click event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7223c1a5d7ab58e091355da65ccd8de94737e82a" translate="yes" xml:space="preserve">
          <source>Map every click to the string 'Hi'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ef2ceade0b135c41c349bc5168ed83cda4ad63" translate="yes" xml:space="preserve">
          <source>Map every click to the tagName of the clicked target element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1291662e52cf0ad77d4766eef37234205722bb" translate="yes" xml:space="preserve">
          <source>Map two click events to a finite interval Observable, then apply &lt;code&gt;combineAll&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb285704e3aec97ef76bd7a37ad60dfb4b89fe" translate="yes" xml:space="preserve">
          <source>Maps each source value (an object) to its specified nested property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0825adbcfaf475d2e7d75fc0daae57c748d65b64" translate="yes" xml:space="preserve">
          <source>Maps each source value to the given Observable &lt;code&gt;innerObservable&lt;/code&gt; regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable. Each new &lt;code&gt;innerObservable&lt;/code&gt; instance emitted on the output Observable is concatenated with the previous &lt;code&gt;innerObservable&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0935a7a469bffaf82a6878abfb460e3bfcb27be" translate="yes" xml:space="preserve">
          <source>Maps each source value to the given Observable &lt;code&gt;innerObservable&lt;/code&gt; regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable. The output Observables emits values only from the most recently emitted instance of &lt;code&gt;innerObservable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43ac90fcdd1156c25c2183b3b08a818e9a9c193" translate="yes" xml:space="preserve">
          <source>Maps each source value to the given Observable &lt;code&gt;innerObservable&lt;/code&gt; regardless of the source value, and then merges those resulting Observables into one single Observable, which is the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9a1e7669d8bc9023b017db084e2bd6c1faf29d" translate="yes" xml:space="preserve">
          <source>Maps each value to an Observable, then flattens all of these inner Observables using &lt;a href=&quot;concatall&quot;&gt;&lt;code&gt;concatAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110846260602e16691bc3be69810496e28479150" translate="yes" xml:space="preserve">
          <source>Maps each value to an Observable, then flattens all of these inner Observables using &lt;a href=&quot;exhaust&quot;&gt;&lt;code&gt;exhaust&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31d7e171ead37fa4b4ee5cb8bb48070ec2aa03c" translate="yes" xml:space="preserve">
          <source>Maps each value to an Observable, then flattens all of these inner Observables using &lt;a href=&quot;mergeall&quot;&gt;&lt;code&gt;mergeAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b1e17de22888e6a33e2eb42490284bd12f742c" translate="yes" xml:space="preserve">
          <source>Maps each value to an Observable, then flattens all of these inner Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e822bb5a7ecefff0aba3e426957f13b3782f52bd" translate="yes" xml:space="preserve">
          <source>Marble Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52cbe7a572015ed7fe6a3f8ea7498bff128d075" translate="yes" xml:space="preserve">
          <source>Marble diagrams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7c3ec7af1e73c9dd1286e25a74e3baea5ad543" translate="yes" xml:space="preserve">
          <source>Marble syntax is a string which represents events happening over &quot;time&quot;. The first character of any marble string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ad7305b4c7c55d47850eb79c3ee937127a37dc" translate="yes" xml:space="preserve">
          <source>Mathematical and Aggregate Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c7c1ad54df2376a7a81cfb4e13e83bc11b6df2" translate="yes" xml:space="preserve">
          <source>Maximum number of inner Observables being subscribed to concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0198a0fd5375d27ba55dfad299bf9afe21fca8ad" translate="yes" xml:space="preserve">
          <source>Maximum number of input Observables being subscribed to concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8922a4c4227d6a1af701f08f2bc4bd2e05533e5" translate="yes" xml:space="preserve">
          <source>Merge together 3 Observables, but only 2 run concurrently</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069502395b05f7558f46246e8118ef2d22dabe20" translate="yes" xml:space="preserve">
          <source>Merge together two Observables: 1s interval and clicks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d630693dad9c41a87468263e8c8fe806efabcc5" translate="yes" xml:space="preserve">
          <source>Method accepts three parameters. First two are functions returning subscription and unsubscription messages respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier, gateway server can decide that it should connect to real sport news service and start forwarding messages from it. Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just as messages pushed via &lt;code&gt;next&lt;/code&gt;. Also bear in mind that these messages will be sent on &lt;em&gt;every&lt;/em&gt; subscription and unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server might stop sending messages, since it got unsubscription message. This needs to be handled on the server or using &lt;a href=&quot;../operators/publish&quot;&gt;&lt;code&gt;publish&lt;/code&gt;&lt;/a&gt; on a Observable returned from 'multiplex'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949a428633fdb1e019edc0e1a17b23aac6c830fe" translate="yes" xml:space="preserve">
          <source>MonoTypeOperatorFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb2c95558cc839ec14e15ee6fefef522bf890d3" translate="yes" xml:space="preserve">
          <source>More complete configuration (closer to a real-world scenario):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f1547dd96e768619c1120b3289cc4e015f2592" translate="yes" xml:space="preserve">
          <source>Multicasted Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47cab713c0895df2ba2dd9a543a7d442b8b4374" translate="yes" xml:space="preserve">
          <source>Multicasting Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740922ac20ba9136af0a0a62b3c2c734d9f20fc6" translate="yes" xml:space="preserve">
          <source>Multiple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c217daafbb9dd1a730c238c8b2fd7140ee21c232" translate="yes" xml:space="preserve">
          <source>Multiplexing WebSocket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ed30c20085e53b01d19e6c5ae1110c9e587a4c" translate="yes" xml:space="preserve">
          <source>NEVER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185beefc99f76a0e5cf83c382aa2146245d61e2d" translate="yes" xml:space="preserve">
          <source>NEVER (constant)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1992d5e8d57e780981c364d844480c004ead1bc2" translate="yes" xml:space="preserve">
          <source>NEXT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7164d668f4b63ca9e5a4a07769284627cfc03f2f" translate="yes" xml:space="preserve">
          <source>NeverObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf8b4b856be1dd9ad316cd5d45c68ae5ab48f49" translate="yes" xml:space="preserve">
          <source>NextObserver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17057c892a64b009aabd4fee14871ac058d1f11" translate="yes" xml:space="preserve">
          <source>Normally you register event listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de06666bb6907f0315f01ccae4ed575bb4e2431" translate="yes" xml:space="preserve">
          <source>Normally you would create an impure function, where other pieces of your code can mess up your state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398fe3cfcfcb49501848d8172b0226d5f69f32bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;bindNodeCallback&lt;/code&gt; can be used in non-Node.js environments as well. &quot;Node.js-style&quot; callbacks are just a convention, so if you write for browsers or any other environment and API you use implements that callback style, &lt;code&gt;bindNodeCallback&lt;/code&gt; can be safely used on that API functions as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a2a7123b705a662c717bbb28b725b8d5340625" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;func&lt;/code&gt; will not be called at the same time output function is, but rather whenever resulting Observable is subscribed. By default call to &lt;code&gt;func&lt;/code&gt; will happen synchronously after subscription, but that can be changed with proper &lt;code&gt;scheduler&lt;/code&gt; provided as optional third parameter. &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; can also control when values from callback will be emitted by Observable. To find out more, check out documentation for &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, where &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; works exactly the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eccb2f0e4909b945ca1bdb60e9805c3645cd94b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;map&lt;/code&gt; logically must be constructed on the fly, since it must be given the mapping function to. By contrast, &lt;code&gt;first&lt;/code&gt; could be a constant, but is nonetheless constructed on the fly. As a general practice, all operators are constructed, whether they need arguments or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785af8137adffc8dc35790a72560c4cf9e4fd52c" translate="yes" xml:space="preserve">
          <source>Note that Observables for both cases (true and false) are optional. If condition points to an Observable that was left undefined, resulting stream will simply complete immediately. That allows you to, rather than controlling which Observable will be subscribed, decide at runtime if consumer should have access to given Observable or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2531da4b349a4b1cdeb6562718fc4ede044dcc78" translate="yes" xml:space="preserve">
          <source>Note that even if error parameter is technically present in callback, but its value is falsy, it still won't appear in array emitted by Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6d917605f46eaded7072d258a65bee3bf35044" translate="yes" xml:space="preserve">
          <source>Note that if event target calls registered function with more than one argument, second and following arguments will not appear in resulting stream. In order to get access to them, you can pass to &lt;code&gt;fromEvent&lt;/code&gt; optional project function, which will be called with all arguments passed to event handler. Output Observable will then emit value returned by project function, instead of the usual value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be17fc7037aa86406feb42ef4d452646ac675e20" translate="yes" xml:space="preserve">
          <source>Note that if some input Observable never completes, &lt;code&gt;concat&lt;/code&gt; will also never complete and Observables following the one that did not complete will never be subscribed. On the other hand, if some Observable simply completes immediately after it is subscribed, it will be invisible for &lt;code&gt;concat&lt;/code&gt;, which will just move on to the next Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51410d674e35853975e3a9419e401137b1ba9765" translate="yes" xml:space="preserve">
          <source>Note that the Observable created by the output function will always emit a single value and then complete immediately. If &lt;code&gt;func&lt;/code&gt; calls the callback multiple times, values from subsequent calls will not appear in the stream. If you need to listen for multiple calls, you probably want to use &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f851276726df5e95ef797c63b539bfd4533dff3b" translate="yes" xml:space="preserve">
          <source>Note that there is no way to handle any errors thrown by sources via the result of &lt;code&gt;onErrorResumeNext&lt;/code&gt;. If you want to handle errors thrown in any given source, you can always use the &lt;a href=&quot;../../operators/catcherror&quot;&gt;&lt;code&gt;catchError&lt;/code&gt;&lt;/a&gt; operator on them before passing them into &lt;code&gt;onErrorResumeNext&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cccf4927251a649eeecffc9191d11f601fdbd9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;asap&lt;/code&gt; scheduler does not necessarily mean that your task will be first to process after currently executing code. In particular, if some task was also scheduled with &lt;code&gt;asap&lt;/code&gt; before, that task will execute first. That being said, if you need to schedule task asynchronously, but as soon as possible, &lt;code&gt;asap&lt;/code&gt; scheduler is your best bet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e084fda71e4798aecef27263782fa9aa8d182557" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;a href=&quot;share&quot;&gt;&lt;code&gt;share&lt;/code&gt;&lt;/a&gt; operator is exactly the same as using the &lt;em&gt;publish&lt;/em&gt; operator (making the observable hot) and the &lt;em&gt;refCount&lt;/em&gt; operator in a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77ad70f2090424e77be304b2f7e7b7529d07b67" translate="yes" xml:space="preserve">
          <source>Note that you do not get any access to errors emitted by the Observables. In particular do not expect these errors to appear in error callback passed to &lt;a href=&quot;../index/class/observable#subscribe&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;. If you want to take specific actions based on what error was emitted by an Observable, you should try out &lt;a href=&quot;catcherror&quot;&gt;&lt;code&gt;catchError&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4313916358f7a166f628c517737a14562bd25113" translate="yes" xml:space="preserve">
          <source>Note that you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661812b325a99de7805e0a5682cdf974c4ea49f5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;concatAll&lt;/code&gt; is equivalent to &lt;code&gt;mergeAll&lt;/code&gt; with concurrency parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61923be5214e61d5e6ee56b26f5717e95b4e192" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;concatMap&lt;/code&gt; is equivalent to &lt;code&gt;mergeMap&lt;/code&gt; with concurrency parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794bbde0125c0195146926fef8ac9f852f7719a0" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;concatMapTo&lt;/code&gt; is equivalent to &lt;code&gt;mergeMapTo&lt;/code&gt; with concurrency parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ade8500967a6c13223f9addb1b8ac6851055eb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;repeat(0)&lt;/code&gt; returns an empty observable and &lt;code&gt;repeat()&lt;/code&gt; will repeat forever</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef6ca60b9b28cdc2e670b53b9e213bd08dbce57" translate="yes" xml:space="preserve">
          <source>Note: the extra arrow function wrapper is to make testing by overriding Date.now easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b40a15ad8f53f938a359f486c07b61a52b31f94" translate="yes" xml:space="preserve">
          <source>Note: this is different to a &lt;code&gt;subscribe&lt;/code&gt; on the Observable. If the Observable returned by &lt;code&gt;tap&lt;/code&gt; is not subscribed, the side effects specified by the Observer will never happen. &lt;code&gt;tap&lt;/code&gt; therefore simply spies on existing execution, it does not trigger an execution to happen like &lt;code&gt;subscribe&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f85e8d40593a671552143c485eb2766930a8c7" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;x&lt;/code&gt; cold observable is unsubscribed at the same time &lt;code&gt;e1&lt;/code&gt; emits &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929263a415784026ab1b159197f06ac6d94b461a" translate="yes" xml:space="preserve">
          <source>Notice how the notifications &lt;code&gt;got value...&lt;/code&gt; were delivered after &lt;code&gt;just after subscribe&lt;/code&gt;, which is different to the default behavior we have seen so far. This is because &lt;code&gt;observeOn(asyncScheduler)&lt;/code&gt; introduces a proxy Observer between &lt;code&gt;new Observable&lt;/code&gt; and the final Observer. Let's rename some identifiers to make that distinction obvious in the example code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92f809565dd8b9fd8f4d0809e096d14b96a2975" translate="yes" xml:space="preserve">
          <source>Notice that both &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;publishReplay&lt;/code&gt; accept a Scheduler because they utilize a ReplaySubject. The constructor of a ReplaySubjects takes an optional Scheduler as the last argument because ReplaySubject may deal with time, which only makes sense in the context of a Scheduler. By default, a ReplaySubject uses the &lt;code&gt;queue&lt;/code&gt; Scheduler to provide a clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb1cd8f59afff8c5aa1189c07cc0d903eb06015" translate="yes" xml:space="preserve">
          <source>Notification.accept()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe2406af15854f577bdc82ae42cf85bc22add2b" translate="yes" xml:space="preserve">
          <source>Notification.do()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf9843ae2682c1071c887f2bca969db94662bc1" translate="yes" xml:space="preserve">
          <source>Notification.observe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df092f8bdc75ab83a14bd0a6c11d9749269bc067" translate="yes" xml:space="preserve">
          <source>Notification.toObservable()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea44c2618d2d416eca6adc1f4d7e3d85e9ab6f40" translate="yes" xml:space="preserve">
          <source>NotificationKind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5f02fae72d03c575e44d90b39e3072cbc88527" translate="yes" xml:space="preserve">
          <source>NotificationKind is deprecated as const enums are not compatible with isolated modules. Use a string literal instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330be7ebd9c63a75e2c6dc8096d6f91edf5cb167" translate="yes" xml:space="preserve">
          <source>Number of elements to skip from the end of the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a723ea339dd6befcb5ae8c2346f01c7df3a4a93f" translate="yes" xml:space="preserve">
          <source>Number of milliseconds that states with what delay every notification should be rescheduled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c0e59c0d705cc3aceff4767aee1f2afa0c2af4" translate="yes" xml:space="preserve">
          <source>Number of retry attempts before failing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a1c0fb34b5a240a47d1735cd5f45c84320e3e7" translate="yes" xml:space="preserve">
          <source>Number specifying period within which Observable must emit values or Date specifying before when Observable should complete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb29c2f4d6a4bfc1b710abfdeadc5152f23cdf3f" translate="yes" xml:space="preserve">
          <source>OBSERVABLE INTERFACES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad2b42ddbdfffe7b81f06c3979641f8c6f09fc9" translate="yes" xml:space="preserve">
          <source>OBSERVER INTERFACES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347a1739c40e56b84e890d514c994d9be1ad77f4" translate="yes" xml:space="preserve">
          <source>OPERATOR INTERFACES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dae8ae1dd082fc9ad4c18baa82ef94258414042" translate="yes" xml:space="preserve">
          <source>Object that must contain initialState, iterate and might contain condition and scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b6c0bed61cc50b9d14e794e9a72b45b46928f7" translate="yes" xml:space="preserve">
          <source>Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6719db7fa73ce25e4c50c8891146b4a84e731e60" translate="yes" xml:space="preserve">
          <source>ObjectUnsubscribedError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b9214e6cd17e55f583eb8217f5a6e2a83de7c8" translate="yes" xml:space="preserve">
          <source>Observable classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a8c0a726fc723cf10adba95195db5d23f44de7" translate="yes" xml:space="preserve">
          <source>Observable which will be subscribed if source fails timeout check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90817df58302936f4b38a8d417d4a86d033fdca6" translate="yes" xml:space="preserve">
          <source>Observable._trySubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d49864908b7f6f95b35363a4bb88362e608b65" translate="yes" xml:space="preserve">
          <source>Observable.forEach()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3371837980458ee8c9ee790d9e265597716fb39" translate="yes" xml:space="preserve">
          <source>Observable.lift()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c279a71eb4f2a653e414eecc71f2ef362edcc60a" translate="yes" xml:space="preserve">
          <source>Observable.pipe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ba04fd071b745475bed8650ce1e2303d65b478" translate="yes" xml:space="preserve">
          <source>Observable.subscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9811e0dec09039f8bd5c694f4e55594e69defad" translate="yes" xml:space="preserve">
          <source>Observable.toPromise()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38be6a67cc1d11b18374d0a80e1ad6112b6db0ae" translate="yes" xml:space="preserve">
          <source>ObservableInput</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd1393bcb0110bd60c126a5d30f4a333c7bc501" translate="yes" xml:space="preserve">
          <source>ObservableLike</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd75342ce8babbf69168a16ede6501ad27792816" translate="yes" xml:space="preserve">
          <source>Observables (or anything that &lt;em&gt;is&lt;/em&gt; observable) passed either directly or as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d26525a6c83ac2ad6cfcb16e532510177f43c01" translate="yes" xml:space="preserve">
          <source>Observables are &lt;strong&gt;created&lt;/strong&gt; using &lt;code&gt;new Observable&lt;/code&gt; or a creation operator, are &lt;strong&gt;subscribed&lt;/strong&gt; to with an Observer, &lt;strong&gt;execute&lt;/strong&gt; to deliver &lt;code&gt;next&lt;/code&gt; / &lt;code&gt;error&lt;/code&gt; / &lt;code&gt;complete&lt;/code&gt; notifications to the Observer, and their execution may be &lt;strong&gt;disposed&lt;/strong&gt;. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f70373f486da6abbb213e390f5f7aaa9b26ab4" translate="yes" xml:space="preserve">
          <source>Observables are able to deliver values either synchronously or asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046eb222bdd0eb9d353654010fcd31fa5d4b8263" translate="yes" xml:space="preserve">
          <source>Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd6d43c13d11dc743e67caf6c6fd6a666671224" translate="yes" xml:space="preserve">
          <source>Observables are like functions with zero arguments, but generalize those to allow multiple values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441df6eae4fd7c6e1499d19fc5608cfef9537583" translate="yes" xml:space="preserve">
          <source>Observables as generalizations of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240213c7811f10c9cf6e7d926883e09a199bd588" translate="yes" xml:space="preserve">
          <source>Observables can be created with &lt;code&gt;new Observable&lt;/code&gt;. Most commonly, observables are created using creation functions, like &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4bf281db82a39594293d1c8c0e382653eb7b58" translate="yes" xml:space="preserve">
          <source>Observables most commonly emit ordinary values like strings and numbers, but surprisingly often, it is necessary to handle Observables &lt;em&gt;of&lt;/em&gt; Observables, so-called higher-order Observables. For example, imagine you had an Observable emitting strings that were the URLs of files you wanted to see. The code might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196054f0a1e1782ddb2fb51069c846f44fe3c89c" translate="yes" xml:space="preserve">
          <source>Observables strictly adhere to the Observable Contract, so the following code would not deliver the Next notification &lt;code&gt;4&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb7968b4905798c2f706d355d0b5a68de6de75f" translate="yes" xml:space="preserve">
          <source>ObservedValueOf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b991fa2342e5bfde327b3b57a16d8ebe6016d4" translate="yes" xml:space="preserve">
          <source>ObservedValuesFromArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36f25180e6bbc8a8544edf29bbc2b8cad98dca2" translate="yes" xml:space="preserve">
          <source>Of course, this is only an example; the &lt;code&gt;delay()&lt;/code&gt; operator &lt;a href=&quot;../api/operators/delay&quot;&gt;already exists&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a813b83c565af10f97e03cfa05adec566cb8f512" translate="yes" xml:space="preserve">
          <source>On a related note, you also can't currently assert delays of zero, even with AsyncScheduler, e.g. &lt;code&gt;delay(0)&lt;/code&gt; is like saying &lt;code&gt;setTimeout(work, 0)&lt;/code&gt;. This schedules a new &lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;&quot;task&quot; aka &quot;macrotask&quot;&lt;/a&gt;, so it's async, but without an explicit passage of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f977c95299de36908784e1c0037d582a96f683a7" translate="yes" xml:space="preserve">
          <source>On every click (starting from the second), emit the relative distance to the previous click</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c69102918f06bc05e227e2bbebecedc61bce46" translate="yes" xml:space="preserve">
          <source>On every click event, emit an array with the latest timer event plus the click event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284b3a1e5a78d6cad16a9c7afff88532d7e1af68" translate="yes" xml:space="preserve">
          <source>On every click, emit array of most recent interval events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738fbb373e8b534b796fafe0d814a1e11a6944f0" translate="yes" xml:space="preserve">
          <source>On every click, emit the last two click events as an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ee7ea00537b277ccc18f636eefa9a84a27583a" translate="yes" xml:space="preserve">
          <source>On every click, sample the most recent &quot;seconds&quot; timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eabdf5e3c98f1fd95c263fb8eff7526ed7b7e9a" translate="yes" xml:space="preserve">
          <source>Once connection is made, whenever a new message comes from the server, &lt;code&gt;WebSocketSubject&lt;/code&gt; will emit that message as a value in the stream. By default, a message from the socket is parsed via &lt;code&gt;JSON.parse&lt;/code&gt;. If you want to customize how deserialization is handled (if at all), you can provide custom &lt;code&gt;resultSelector&lt;/code&gt; function in &lt;a href=&quot;websocketsubject&quot;&gt;&lt;code&gt;WebSocketSubject&lt;/code&gt;&lt;/a&gt;. When connection closes, stream will complete, provided it happened without any errors. If at any point (starting, maintaining or closing a connection) there is an error, stream will also error with whatever WebSocket API has thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8b7e25a8030d3a5fd155cb1476c4dba6c04089" translate="yes" xml:space="preserve">
          <source>One of the variants of Subjects is the &lt;code&gt;BehaviorSubject&lt;/code&gt;, which has a notion of &quot;the current value&quot;. It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the &quot;current value&quot; from the &lt;code&gt;BehaviorSubject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49959c3a4b5f58bbfed0d5549c6b351ae1fe81d" translate="yes" xml:space="preserve">
          <source>Opens a buffer immediately, then closes the buffer when the observable returned by calling &lt;code&gt;closingSelector&lt;/code&gt; function emits a value. When it closes the buffer, it immediately opens a new buffer and repeats the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae54195bcdd92e46702923049db4881db198f1a" translate="yes" xml:space="preserve">
          <source>Operator pipe syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0c27f30f60a6364aead599d43148dca1bed7a0" translate="yes" xml:space="preserve">
          <source>Operator syntax has changed to use piping instead of chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9140e6b5a6f63cf130558c9498f6cb4eadba8003" translate="yes" xml:space="preserve">
          <source>Operator.call()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6d62d82a7c72e23b52339f18c1030c282a8307" translate="yes" xml:space="preserve">
          <source>OperatorFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b0b3fdea69e27f0b919dc3904d5683787bb8ea" translate="yes" xml:space="preserve">
          <source>Operators are &lt;strong&gt;functions&lt;/strong&gt;. There are two kinds of operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549a87099517bf0ada6b91a9f2fd2c616b1d9802" translate="yes" xml:space="preserve">
          <source>Operators patched directly onto the prototype are not &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking&quot;&gt;&quot;tree-shakeable&quot;&lt;/a&gt; by tools like rollup or webpack. Pipeable operators will be as they are just functions pulled in from modules directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0b19be8db5cebc20635e1a3ac9bcc8162b953d" translate="yes" xml:space="preserve">
          <source>Optional Observable for flushing the internal HashSet of the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f748e08780e4127a095cd6a976e25b47f18193f" translate="yes" xml:space="preserve">
          <source>Optional comparer function that it will use instead of its default to compare the value of two items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca4f6115de77713b3a062adcafc9179ceaed121" translate="yes" xml:space="preserve">
          <source>Optional comparison function called to test if an item is distinct from the previous item in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2e4a06c1c5bec3de4e5d2b9b2a46131510b934" translate="yes" xml:space="preserve">
          <source>Optional function to select which value you want to check as distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad86c53a6d4e29a34d2dfe2786af4eaeae2b5b0e" translate="yes" xml:space="preserve">
          <source>Optional object to use for &lt;code&gt;this&lt;/code&gt; in the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c205c911e518fbb44dc88f99a20d719cd210440" translate="yes" xml:space="preserve">
          <source>Optional selector function that can use the multicasted source stream as many times as needed, without causing multiple subscriptions to the source stream. Subscribers to the given source will receive all notifications of the source from the time of the subscription forward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9584dd46f909ff63289cf52a31871b1c915866" translate="yes" xml:space="preserve">
          <source>Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66473ee536730636cf7b57d635b3aec60e97a1e5" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fb4c3880567dd79f680c0df074813a3f8092e6" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484ab3d5605a8e421914163b2483d5922bfc8b7b" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;EMPTY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2470505a0e93a4efc570dc70daaad8c1ce2f61" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94317c464666f3bcaddffcc1dc4e6e7a852b32a2" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;Scheduler.now&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3009b1302152e9387b7be07d13141f833422008" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;VirtualAction as any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984514d25a7e26611647ebc74a5b53679382b904" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f4b7aecade7e4c4c56b231bba81ee91cb7f28f" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;defaultErrorFactory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebb07e67562a782c710753404f2b1fe631188e2" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;defaultThrottleConfig&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9145bb534991daf57f7701301bbf91899e9dd502" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0055788f2ca22e20c975392f22c77a2081447880" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bbe710af81960b2e485bb4d19548f797e8de4a" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a12bfb5b16b05b68509fbbe232b34a47379494" translate="yes" xml:space="preserve">
          <source>Optionally &lt;code&gt;forkJoin&lt;/code&gt; accepts project function, that will be called with values which normally would land in emitted array. Whatever is returned by project function, will appear in output observable instead. This means that default project can be thought of as a function that takes all its arguments and puts them into an array. Note that project function will be called only when output observable is supposed to emit a result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8881ccad6db3c7e0f10eafbbea77a1603fce627" translate="yes" xml:space="preserve">
          <source>Optionally you can pass fourth parameter to &lt;code&gt;generate&lt;/code&gt; - a result selector function which allows you to immediately map value that would normally be emitted by an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba94c9426dbfad143f0a7e7b9b2948ec8bf4effb" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;delayWhen&lt;/code&gt; takes a second argument, &lt;code&gt;subscriptionDelay&lt;/code&gt;, which is an Observable. When &lt;code&gt;subscriptionDelay&lt;/code&gt; emits its first value or completes, the source Observable is subscribed to and starts behaving like described in the previous paragraph. If &lt;code&gt;subscriptionDelay&lt;/code&gt; is not provided, &lt;code&gt;delayWhen&lt;/code&gt; will subscribe to the source Observable as soon as the output Observable is subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745565bbd74601f21fedda7923e61962d00bc097" translate="yes" xml:space="preserve">
          <source>Options to pass through to addEventListener</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a079ee4d16c11fa095bb00faead29b5a215e1976" translate="yes" xml:space="preserve">
          <source>Other flow control operators are &lt;a href=&quot;api/operators/filter&quot;&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/delay&quot;&gt;&lt;strong&gt;delay&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/debouncetime&quot;&gt;&lt;strong&gt;debounceTime&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/take&quot;&gt;&lt;strong&gt;take&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/takeuntil&quot;&gt;&lt;strong&gt;takeUntil&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/distinct&quot;&gt;&lt;strong&gt;distinct&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/distinctuntilchanged&quot;&gt;&lt;strong&gt;distinctUntilChanged&lt;/strong&gt;&lt;/a&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee2b9e23822e07cc034614dfebec540918ad4ea" translate="yes" xml:space="preserve">
          <source>Other instance operators that take a Scheduler as argument: &lt;code&gt;cache&lt;/code&gt;, &lt;code&gt;combineLatest&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;publishReplay&lt;/code&gt;, &lt;code&gt;startWith&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961fdc4bb5354f785b5b8a95a8d3c862d1ce308d" translate="yes" xml:space="preserve">
          <source>Other value producing operators are &lt;a href=&quot;api/operators/pluck&quot;&gt;&lt;strong&gt;pluck&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/pairwise&quot;&gt;&lt;strong&gt;pairwise&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;api/operators/sample&quot;&gt;&lt;strong&gt;sample&lt;/strong&gt;&lt;/a&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569c81604e11670fa75d7429be7086a2f8df3428" translate="yes" xml:space="preserve">
          <source>PairsObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be65e8e0e42108c62d023b562e0e7ce35a528cb" translate="yes" xml:space="preserve">
          <source>PartialObserver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17403964831a93acdc5410870f5373c6fc475fd" translate="yes" xml:space="preserve">
          <source>Partition a set of numbers into odds and evens observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5d4378f3c764d573ba6ab28beb30b5be1395f7" translate="yes" xml:space="preserve">
          <source>Partition click events into those on DIV elements and those elsewhere</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f8fc3509a58ee0b0a1c4adfa1fe7a46aa2d488" translate="yes" xml:space="preserve">
          <source>Perform a side effect for every emission on the source Observable, but return an Observable that is identical to the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2e1f23af306f33c8ddb37d34ad8362e8277a3f" translate="yes" xml:space="preserve">
          <source>Perform task as fast as it can be performed asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3525978b183e2caddfbcd17962183ed377c7a3f4" translate="yes" xml:space="preserve">
          <source>Perform task when &lt;code&gt;window.requestAnimationFrame&lt;/code&gt; would fire</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5079b59a6d41184ea3fd37ef55523da852b9c7" translate="yes" xml:space="preserve">
          <source>Pipeable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58476bae0e3901887cb77b584fc3ee1a7c224cfd" translate="yes" xml:space="preserve">
          <source>Pipeable operators are functions, so they &lt;em&gt;could&lt;/em&gt; be used like ordinary functions: &lt;code&gt;op()(obs)&lt;/code&gt; &amp;mdash; but in practice, there tend to be many of them convolved together, and quickly become unreadable: &lt;code&gt;op4()(op3()(op2()(op1()(obs))))&lt;/code&gt;. For that reason, Observables have a method called &lt;code&gt;.pipe()&lt;/code&gt; that accomplishes the same thing while being much easier to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3247b493bc40b8745523a27d8c525cd0dc056fd5" translate="yes" xml:space="preserve">
          <source>Piping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfe7ac52ba395e797e0e54c16b749d7d2aa3746" translate="yes" xml:space="preserve">
          <source>Pivot data on the id field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3f11289c481d501c95e7d6b7c2d5b088a7df42" translate="yes" xml:space="preserve">
          <source>Problems with the patched operators for dot-chaining are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7194967fd8d62aaf2d5f4d2364b080ecfdb949" translate="yes" xml:space="preserve">
          <source>Producer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273fc0117d2895579abfb345fb7d3a7db5fc4e64" translate="yes" xml:space="preserve">
          <source>Projects each source value to an Observable which is merged in the output Observable only if the previous projected Observable has completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efe7cfff35eceb83cb4d6680e62b293cf742def" translate="yes" xml:space="preserve">
          <source>Projects each source value to an Observable which is merged in the output Observable, emitting values only from the most recently projected Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bf8c06ab1caf35a1ed975dcea24771dc2c776b" translate="yes" xml:space="preserve">
          <source>Projects each source value to an Observable which is merged in the output Observable, in a serialized fashion waiting for each one to complete before merging the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc018f5466083a0d21e8bc7a77820f9074d5450" translate="yes" xml:space="preserve">
          <source>Projects each source value to an Observable which is merged in the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f5ce960ce005cf73f2923f987c818067a0f8dd" translate="yes" xml:space="preserve">
          <source>Projects each source value to the same Observable which is flattened multiple times with &lt;a href=&quot;switchmap&quot;&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/a&gt; in the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0105f6bdc2ac614021ac4cab67f5507f7e9c482" translate="yes" xml:space="preserve">
          <source>Projects each source value to the same Observable which is merged multiple times in a serialized fashion on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9807275d6843236a811df3e2c3b747a207ded0c" translate="yes" xml:space="preserve">
          <source>Projects each source value to the same Observable which is merged multiple times in the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cce33f3a0b90d4c75484761de4b5492b948a16d" translate="yes" xml:space="preserve">
          <source>PromiseCtor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5ba1538386d51d94149f1353e016c72bb892a1" translate="yes" xml:space="preserve">
          <source>PromiseObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfdfd6ce8eb06dc995c9e91f1da055eb68fc25a" translate="yes" xml:space="preserve">
          <source>Promises are the most common type of Push system in JavaScript today. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers), but unlike functions, it is the Promise which is in charge of determining precisely when that value is &quot;pushed&quot; to the callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633acaf1ba37cc2f341d9219012d8326bc2a85ef" translate="yes" xml:space="preserve">
          <source>Prompt the Scheduler to execute all of its queued actions, therefore clearing its queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae33a7d0ecb82cae8f04aafab20bf90425b7b8c" translate="yes" xml:space="preserve">
          <source>Property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcfafc27d17b2480128657236cfca2cecf71226" translate="yes" xml:space="preserve">
          <source>Provides flexibility to &lt;a href=&quot;websocket&quot;&gt;&lt;code&gt;webSocket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fb8518ee5e3f6fc3ef3bbd1be11fbf449ffea2" translate="yes" xml:space="preserve">
          <source>Published along with rxjs 5.5 is builds of rxjs in ECMAScript Module format (imports and exports) with both ES5 and ES2015 language level. You can find these distributions in &lt;code&gt;node_modules/rxjs/_esm5&lt;/code&gt; and &lt;code&gt;node_modules/rxjs/_esm2015&lt;/code&gt; (&quot;esm&quot; stands for ECMAScript Modules and the number &quot;5&quot; or &quot;2015&quot; is for the ES language level). In your application source code, you should import from &lt;code&gt;rxjs/operators&lt;/code&gt;, but in your Webpack configuration file you will need to re-map imports to the ESM5 (or ESM2015) version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68cec803c100a2501eb96aa1bed7f5eea2006d37" translate="yes" xml:space="preserve">
          <source>Pull versus Push</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b611b1b174cd71f53f8fab72d5be8b17f1336a4" translate="yes" xml:space="preserve">
          <source>Purity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f65c6e16361ed2d291a519c777122b903b5a91" translate="yes" xml:space="preserve">
          <source>Pushing messages to the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d55d09688227c084a57a8bc6b2fdaf457c41be" translate="yes" xml:space="preserve">
          <source>Put every next task on a queue, instead of executing it immediately</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d87eebe45bfd1b1cd00d020dd72214dca33ec6" translate="yes" xml:space="preserve">
          <source>Puts the current value and previous value together as an array, and emits that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0514c71ba6d64cf6ff9e9281158b88c9f73138" translate="yes" xml:space="preserve">
          <source>Queue Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4e39f3eff15edd5cdaea9cb00e023ed193c646" translate="yes" xml:space="preserve">
          <source>RangeObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38e88ad9981946ee7809c1a88cd658dae07aa07" translate="yes" xml:space="preserve">
          <source>Re-emits all notifications from source Observable with specified scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e595b2551cfd4bb73af5c725da7bad9d7ef8ff2b" translate="yes" xml:space="preserve">
          <source>ReactiveX combines the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer pattern&lt;/a&gt; with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern&quot;&gt;Iterator pattern&lt;/a&gt; and &lt;a href=&quot;http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions&quot;&gt;functional programming with collections&lt;/a&gt; to fill the need for an ideal way of managing sequences of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3a91b1b0e6440fcf6ce16ed5431a872446e5ec" translate="yes" xml:space="preserve">
          <source>Read a file from the filesystem and get the data as an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65834d39c25553d999be0e64fb8eacebfad56291" translate="yes" xml:space="preserve">
          <source>Read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979bec8a5130f11f20e9b20b7b6cd242fda82e19" translate="yes" xml:space="preserve">
          <source>Receive an array of arguments passed to a callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e82eefdd703e3d71d36f81d623d24f31e48864" translate="yes" xml:space="preserve">
          <source>Receives an Observable of notifications with which a user can &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, aborting the repetition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ac518373b2247398d077f15b4639cd13b31a0b" translate="yes" xml:space="preserve">
          <source>Receives an Observable of notifications with which a user can &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, aborting the retry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2c94acd117ef1a520de5154b1f0a57049b0581" translate="yes" xml:space="preserve">
          <source>Recursively projects each source value to an Observable which is merged in the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5eb23bd9deb27b65779b8daef8f7784ba1c9f27" translate="yes" xml:space="preserve">
          <source>Reference counting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2a06e9cb65f117f0522df27af2c1f1fb2c0ea1" translate="yes" xml:space="preserve">
          <source>Remember that Error object passed to callback does not have to be an instance of JavaScript built-in &lt;code&gt;Error&lt;/code&gt; object. In fact, it does not even have to an object. Error parameter of callback function is interpreted as &quot;present&quot;, when value of that parameter is truthy. It could be, for example, non-zero number, non-empty string or boolean &lt;code&gt;true&lt;/code&gt;. In all of these cases resulting Observable would error with that value. This means usually regular style callbacks will fail very often when &lt;code&gt;bindNodeCallback&lt;/code&gt; is used. If your Observable errors much more often then you would expect, check if callback really is called in Node.js-style and, if not, switch to &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aab475cb6fe668657b3675b974e438ae1e0d49" translate="yes" xml:space="preserve">
          <source>Remember that callbacks provided to &lt;code&gt;subscribe&lt;/code&gt; are not guaranteed to be called asynchronously. It is an Observable itself that decides when these functions will be called. For example &lt;a href=&quot;../function/of&quot;&gt;&lt;code&gt;of&lt;/code&gt;&lt;/a&gt; by default emits all its values synchronously. Always check documentation for how given Observable will behave when subscribed and if its default behavior can be modified with a &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5237aeb2243b5ba530cd160d643d7f92386497d9" translate="yes" xml:space="preserve">
          <source>Remember that event targets listed below are checked via duck typing. It means that no matter what kind of object you have and no matter what environment you work in, you can safely use &lt;code&gt;fromEvent&lt;/code&gt; on that object if it exposes described methods (provided of course they behave as was described above). So for example if Node.js library exposes event target which has the same method names as DOM EventTarget, &lt;code&gt;fromEvent&lt;/code&gt; is still a good choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aba15b18165af8b7034aca05e268e3de9f85a6b" translate="yes" xml:space="preserve">
          <source>Remembers the latest &lt;code&gt;count&lt;/code&gt; values, then emits those only when the source completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfeea6f533df21940fdd66b3452fbdd8495721b" translate="yes" xml:space="preserve">
          <source>Removes a Subscription from the internal list of subscriptions that will unsubscribe during the unsubscribe process of this Subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685971e837024feba6bef16940db5bf6f7395f4f" translate="yes" xml:space="preserve">
          <source>Repeat 3 values, 2 times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e63b6e3fc993534aa2873cc0e2b22bbe33b2e67" translate="yes" xml:space="preserve">
          <source>Repeat a message stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea2d916085f831152f45421e22fa58bc679fcf6" translate="yes" xml:space="preserve">
          <source>Repeat a message stream on click</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99030fdd907524be5d7147237e91d7620c02857" translate="yes" xml:space="preserve">
          <source>Repeats all values emitted on the source. It's like &lt;a href=&quot;retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt;, but for non error cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b015fbcad7d2684fdfcb7dedc9d6d94c863e77be" translate="yes" xml:space="preserve">
          <source>ReplaySubject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9327301ce3385a92f7c27f8eb800303d86d43c" translate="yes" xml:space="preserve">
          <source>ReplaySubject._getNow()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ca2c2ad457175c9a08ffeb773355123dfab91d" translate="yes" xml:space="preserve">
          <source>ReplaySubject._subscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1507e2429c3270c3fcfb2f25130078f3e21851" translate="yes" xml:space="preserve">
          <source>Represents a disposable resource, such as the execution of an Observable. A Subscription has one important method, &lt;code&gt;unsubscribe&lt;/code&gt;, that takes no argument and just disposes the resource held by the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc993acd9bfda6a789b3a36c8a75d0e42c17b002" translate="yes" xml:space="preserve">
          <source>Represents a push-based event or value that an &lt;a href=&quot;observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; can emit. This class is particularly useful for operators that manage notifications, like &lt;a href=&quot;../../operators/materialize&quot;&gt;&lt;code&gt;materialize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../operators/dematerialize&quot;&gt;&lt;code&gt;dematerialize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../operators/observeon&quot;&gt;&lt;code&gt;observeOn&lt;/code&gt;&lt;/a&gt;, and others. Besides wrapping the actual delivered value, it also annotates it with metadata of, for instance, what type of push message it is (&lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;complete&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc50a97c3b89dd873ea4b0d4e4883aa8c5d4a0" translate="yes" xml:space="preserve">
          <source>Represents all of the notifications from the source Observable as &lt;code&gt;next&lt;/code&gt; emissions marked with their original types within &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19827f21902efbdb9a8acc6f3654c02453b7f09" translate="yes" xml:space="preserve">
          <source>Rerun an interval Observable on every click event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76bd1ad44ff7bb1e5d92ffa1a7f8aaca89b279d" translate="yes" xml:space="preserve">
          <source>Reschedule itself recursively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a675a9e60148016d95586ead119e288a55936da" translate="yes" xml:space="preserve">
          <source>Result selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a94d9ad970553326d39b1a3bd8aba4f9849acec" translate="yes" xml:space="preserve">
          <source>Result selectors are a feature not many people use (in many cases they weren't documented), but were adding significant bloat to the codebase. If you use them, you will need to replace the discontinued &lt;code&gt;resultSelector&lt;/code&gt; parameter with external result-selection code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230d29d1314f6de8196f2a9cfc05f179cf054a7" translate="yes" xml:space="preserve">
          <source>Result selectors removed or deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2977939008b8c2b40e3564d254f93efaae1139" translate="yes" xml:space="preserve">
          <source>Retries the caught source Observable again in case of error, similar to retry() operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a30547f2c1550a2a8d780ecf8728d782106b22b" translate="yes" xml:space="preserve">
          <source>Return value of &lt;code&gt;multiplex&lt;/code&gt; is an Observable with messages incoming from emulated socket connection. Note that this is not a &lt;code&gt;WebSocketSubject&lt;/code&gt;, so calling &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;multiplex&lt;/code&gt; again will fail. For pushing values to the server, use root &lt;code&gt;WebSocketSubject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863dc4702383bfb2bb43903d73440638849bcfa0" translate="yes" xml:space="preserve">
          <source>Return value of a &lt;code&gt;generate&lt;/code&gt; operator is an Observable that on each loop iteration emits a value. First, condition function is ran. If it returned true, Observable emits currently stored value (initial value at the first iteration) and then updates that value with iterate function. If at some point condition returned false, Observable completes at that moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d1eab1e1d9b53d836f02441762a7353ed45025" translate="yes" xml:space="preserve">
          <source>Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable, but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits notification, it will be immediately scheduled again - this time with scheduler passed to &lt;code&gt;observeOn&lt;/code&gt;. An anti-pattern would be calling &lt;code&gt;observeOn&lt;/code&gt; on Observable that emits lots of values synchronously, to split that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source Observable directly (usually into the operator that creates it). &lt;code&gt;observeOn&lt;/code&gt; simply delays notifications a little bit more, to ensure that they are emitted at expected moments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9f6a583020e8f56bfc3c01b3ab2675da597f47" translate="yes" xml:space="preserve">
          <source>Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called before it begins emitting items to those Observers that have subscribed to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a5fe7e4a8df9ac1cb50095f11bd1b1405f75cc" translate="yes" xml:space="preserve">
          <source>Returns a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4135c8d57b99c8f17f55c5ca0978f8285495c2f" translate="yes" xml:space="preserve">
          <source>Returns a mirrored Observable of the source Observable, but modified so that the provided Observer is called to perform a side effect for every value, error, and completion emitted by the source. Any errors that are thrown in the aforementioned Observer or handlers are safely sent down the error path of the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2954d125a2d45c8c637489b27247a4ced48da766" translate="yes" xml:space="preserve">
          <source>Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream &lt;code&gt;hot&lt;/code&gt;. This is an alias for &lt;code&gt;multicast(() =&amp;gt; new Subject()), refCount()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1007eedf65cc9f1fd1c0731de943a9f45a7d614f" translate="yes" xml:space="preserve">
          <source>Returns a simple Observable that just delivers the notification represented by this Notification instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b613c9a4a2272b2f171ae981b37df407fc264bb" translate="yes" xml:space="preserve">
          <source>Returns an Observable that applies a specified &lt;code&gt;accumulator&lt;/code&gt; function to each item emitted by the source Observable. If a &lt;code&gt;seed&lt;/code&gt; value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb8997a01ce78872faa9e67b1e17748350922cd" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe090d76e6e8b3b2b6ae8bb9858a17df146ab2e7" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item, using a property accessed by using the key provided to check if the two items are distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277f97c4e000c94b0e675311b91622eb250ba514" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5959a0eb64906e69288e68276be24db7357f8b4" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an (so-called &quot;inner&quot;) Observable. Each new inner Observable is concatenated with the previous inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9f1ed734fbdedfa7589354fb91c4bc05f55005" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an (so-called &quot;inner&quot;) Observable. Each time it observes one of these inner Observables, the output Observable begins emitting the items emitted by that inner Observable. When a new inner Observable is emitted, &lt;code&gt;switchMap&lt;/code&gt; stops emitting items from the earlier-emitted inner Observable and begins emitting items from the new one. It continues to behave like this for subsequent inner Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="576b2f04ebc5b65d90c41760edb46e655bf7369d" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an (so-called &quot;inner&quot;) Observable. When it projects a source value to an Observable, the output Observable begins emitting the items emitted by that projected Observable. However, &lt;code&gt;exhaustMap&lt;/code&gt; ignores every new projected Observable if the previous projected Observable has not yet completed. Once that one completes, it will accept and flatten the next projected Observable and repeat this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0286a396bcb14bedbed1576382bfc16ba7dd72f" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an Observable, and then merging those resulting Observables and emitting the results of this merger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4ef19a1dae20284d1c3fe62cbc5710328aea34" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an Observable, and then merging those resulting Observables and emitting the results of this merger. &lt;em&gt;Expand&lt;/em&gt; will re-emit on the output Observable every source value. Then, each output value is given to the &lt;code&gt;project&lt;/code&gt; function which returns an inner Observable to be merged on the output Observable. Those output values resulting from the projection are also given to the &lt;code&gt;project&lt;/code&gt; function to produce new output values. This is how &lt;em&gt;expand&lt;/em&gt; behaves recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ffa85f802fbba66e126e16e4c383d879793901" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits only the last item emitted by the source Observable. It optionally takes a predicate function as a parameter, in which case, rather than emitting the last item from the source Observable, the resulting Observable will emit the last item from the source Observable that satisfies the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a0eedc2a284fc3e14966daf4c37e331d8eb68" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits the items you specify as arguments after it finishes emitting items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bee36b5171ea5a82854b43b6199d7d30c75d71e" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits the items you specify as arguments before it begins to emit items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c57c9e4702efdc8ce027dc67e940e215c546298" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits the results of invoking a specified selector on items emitted by a ConnectableObservable that shares a single subscription to the underlying stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69bbb49b1dad29fe9520fb7ea4f1c176bc58f1b" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits the single item emitted by the source Observable that matches a specified predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable emits items but none match the specified predicate then &lt;code&gt;undefined&lt;/code&gt; is emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d63cfc3a13f666a9deac30122498eb884c8105" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits whether or not every item of the source satisfies the condition specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b725354f847eeb13fb919712e0031e60a9905b9" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits windows of items it collects from the source Observable. The output Observable emits connected, non-overlapping windows. It emits the current window and opens a new one whenever the Observable &lt;code&gt;windowBoundaries&lt;/code&gt; emits an item. Because each window is an Observable, the output is a higher-order Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fb41f10f34eae390729558d74d13ab1225c77d" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits windows of items it collects from the source Observable. The output Observable emits connected, non-overlapping windows. It emits the current window and opens a new one whenever the Observable produced by the specified &lt;code&gt;closingSelector&lt;/code&gt; function emits an item. The first window is opened immediately when subscribing to the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3659cfaaad6e18abac1f1a8057cca541d46109d0" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits windows of items it collects from the source Observable. The output Observable emits windows every &lt;code&gt;startWindowEvery&lt;/code&gt; items, each containing no more than &lt;code&gt;windowSize&lt;/code&gt; items. When the source Observable completes or encounters an error, the output Observable emits the current window and propagates the notification from the source Observable. If &lt;code&gt;startWindowEvery&lt;/code&gt; is not provided, then new windows are started immediately at the start of the source and when each window completes with size &lt;code&gt;windowSize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fe1346e9b4b5fff2b1a092dfb5cbdad5d416c9" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits windows of items it collects from the source Observable. The output Observable emits windows that contain those items emitted by the source Observable between the time when the &lt;code&gt;openings&lt;/code&gt; Observable emits an item and when the Observable returned by &lt;code&gt;closingSelector&lt;/code&gt; emits an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c086c1e2ca9f7242ee99b6671594ec3193cdf19b" translate="yes" xml:space="preserve">
          <source>Returns an Observable that emits windows of items it collects from the source Observable. The output Observable starts a new window periodically, as determined by the &lt;code&gt;windowCreationInterval&lt;/code&gt; argument. It emits each window after a fixed timespan, specified by the &lt;code&gt;windowTimeSpan&lt;/code&gt; argument. When the source Observable completes or encounters an error, the output Observable emits the current window and propagates the notification from the source Observable. If &lt;code&gt;windowCreationInterval&lt;/code&gt; is not provided, the output Observable starts a new window when the previous window of duration &lt;code&gt;windowTimeSpan&lt;/code&gt; completes. If &lt;code&gt;maxWindowCount&lt;/code&gt; is provided, each window will emit at most fixed number of values. Window will complete immediately after emitting last value and next one still will open as specified by &lt;code&gt;windowTimeSpan&lt;/code&gt; and &lt;code&gt;windowCreationInterval&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273753ddceb212c48d8e3eecd3ecb0db9fc5db7c" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the first source Observable to emit a next, error or complete notification from the combination of this Observable and supplied Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4160a268c2e88e132747acdf704594a07fbab68f" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the first source Observable to emit an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a491d2d24a12f9bdf2d5e12a6382b4482a667bc6" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the source Observable with the exception of a &lt;code&gt;complete&lt;/code&gt;. If the source Observable calls &lt;code&gt;complete&lt;/code&gt;, this method will emit to the Observable returned from &lt;code&gt;notifier&lt;/code&gt;. If that Observable calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, then this method will call &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; on the child subscription. Otherwise this method will resubscribe to the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914e51a8681975e02e407be23059a18ce6b906cd" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the source Observable with the exception of an &lt;code&gt;error&lt;/code&gt;. If the source Observable calls &lt;code&gt;error&lt;/code&gt;, this method will emit the Throwable that caused the error to the Observable returned from &lt;code&gt;notifier&lt;/code&gt;. If that Observable calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; then this method will call &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; on the child subscription. Otherwise this method will resubscribe to the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ba124a58b9fbd6ef41b3638a99598079b50269" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the source Observable with the exception of an &lt;code&gt;error&lt;/code&gt;. If the source Observable calls &lt;code&gt;error&lt;/code&gt;, this method will resubscribe to the source Observable for a maximum of &lt;code&gt;count&lt;/code&gt; resubscriptions (given as a number parameter) rather than propagating the &lt;code&gt;error&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256992a661be80d72ef7bf57603a8696f45be329" translate="yes" xml:space="preserve">
          <source>Returns an Observable that mirrors the source Observable, but will call a specified function when the source terminates on complete or error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f0319085f2ee15883944498e7eec9dd4b6b6a7" translate="yes" xml:space="preserve">
          <source>Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds true, but emits all further source items as soon as the condition becomes false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77c52be7bf3e9fba827767c90f5dad781a9d2f1" translate="yes" xml:space="preserve">
          <source>Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9b7cf8cda5c3ff95b9e500518c5f022fac8933" translate="yes" xml:space="preserve">
          <source>Returns an Observable that skips the first &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af3b13576366edc8ce233e709a5e0fb4c083033" translate="yes" xml:space="preserve">
          <source>Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2652023d350f034c4659a5b472db319fe7ef31" translate="yes" xml:space="preserve">
          <source>Run a finite timer for each click, only if there is no currently active timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96a416116b7c2f810e19de25d348e53cd2ac46b" translate="yes" xml:space="preserve">
          <source>RxJS Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72c446f42a55844bee085c7106c37d8dda8b0be" translate="yes" xml:space="preserve">
          <source>RxJS has a whole range of operators that helps you control how the events flow through your observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1222202798df52c0c9462e0d0f1d611c6b2d5fd0" translate="yes" xml:space="preserve">
          <source>RxJS introduces Observables, a new Push system for JavaScript. An Observable is a Producer of multiple values, &quot;pushing&quot; them to Observers (Consumers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76027f194dd8d211d21fe532e849aa27b2025b05" translate="yes" xml:space="preserve">
          <source>RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the &lt;a href=&quot;guide/observable&quot;&gt;Observable&lt;/a&gt;, satellite types (Observer, Schedulers, Subjects) and operators inspired by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.6&quot;&gt;Array#extras&lt;/a&gt; (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa9fe1b604dc9f5181e59afe13209a3fdfe9f1e" translate="yes" xml:space="preserve">
          <source>RxJS is mostly useful for its &lt;em&gt;operators&lt;/em&gt;, even though the Observable is the foundation. Operators are the essential pieces that allow complex asynchronous code to be easily composed in a declarative manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbf23ae74d09213d155f3ca93c3cc2fe3928435" translate="yes" xml:space="preserve">
          <source>RxJS v5.x to v6 Update Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49148fe70473360df2153a798077e9c790ce230a" translate="yes" xml:space="preserve">
          <source>RxJS v6 has arrived! While this is a major version change (from 5.x to 6.x), we've put in a lot of work to keep the hard breaking changes to a minimum. In most cases, this allows application and library developers to update incrementally and use RxJS v6 without any modifications to their code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b487c32f26e8bf63be42ea63e263cb411e66a92" translate="yes" xml:space="preserve">
          <source>SCHEDULER INTERFACES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cb5c24681d1a3359c66b1f31ee4be84ddfd76f" translate="yes" xml:space="preserve">
          <source>SUBSCRIPTION INTERFACES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02bb36424dda997b833de20bacaa4ae4abdfe78" translate="yes" xml:space="preserve">
          <source>Same as example above but with maxWindowCount instead of take</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71ddd54ba144fbef266f896debc28c4684b9323" translate="yes" xml:space="preserve">
          <source>Samples the source Observable at periodic time intervals, emitting what it samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c6c263748d24390b417ac8869056f79a3f5b58" translate="yes" xml:space="preserve">
          <source>ScalarObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21dc0252b59a13c7ff651b88d30153fe03cce42" translate="yes" xml:space="preserve">
          <source>Schedule div height animation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b60abf98d5aaf41040f32eeee7c226eef24257a" translate="yes" xml:space="preserve">
          <source>Schedule recursively first, then do something</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8c7df8a1c8baa58337da5fb5bb76cbcdeebd18" translate="yes" xml:space="preserve">
          <source>Schedule task as if you used setTimeout(task, duration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcb4d8493703e86ddd0f22eb1ff805a9c89e0d9" translate="yes" xml:space="preserve">
          <source>Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4e7fdf49702cbd55848f88fb21e5bd0090911e" translate="yes" xml:space="preserve">
          <source>Scheduler Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5035edc74c0f2ebda1ef941e0628ebad1f5d3b89" translate="yes" xml:space="preserve">
          <source>Scheduler controlling when timeout checks occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a8d7daab5401a385d803c6b224179c5dcba2f5" translate="yes" xml:space="preserve">
          <source>Scheduler is an internal implementation detail of RxJS, and should not be used directly. Rather, create your own class and implement &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b6df6c6b72fcbee69813062aaf9884ce1ddcb8" translate="yes" xml:space="preserve">
          <source>Scheduler that will be used to reschedule notifications from source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c42785478f2d0322d1e62b6310a90a9a6cff5e9" translate="yes" xml:space="preserve">
          <source>Scheduler used to get the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88110a12edc81ba12a8b10f7a769d22f2e33f5d" translate="yes" xml:space="preserve">
          <source>Scheduler, which in case of &lt;code&gt;timeout&lt;/code&gt; is provided as as second argument, can be still provided here - as a third, optional parameter. It still is used to schedule timeout checks and - as a consequence - when second Observable will be subscribed, since subscription happens immediately after failing check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8811666b35c14c8738e3f8f3eb87e346675d7a78" translate="yes" xml:space="preserve">
          <source>Scheduler.schedule()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9c0ae9671b7c61ac34951c1c377a27c04d8fd7" translate="yes" xml:space="preserve">
          <source>SchedulerAction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af8d3dce57759ea86bf540c408759e50a547209" translate="yes" xml:space="preserve">
          <source>SchedulerAction.schedule()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79e246e997e069b015d1577be93472fef7c4b17" translate="yes" xml:space="preserve">
          <source>SchedulerLike</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e02e79542325a3b37b249aa1f5272d8040d2a9" translate="yes" xml:space="preserve">
          <source>SchedulerLike.now()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246aa3d03d2c126c9245cd59f16af38b40f79f67" translate="yes" xml:space="preserve">
          <source>SchedulerLike.schedule()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0909356aa53022b0078d9c1143ee10039946268" translate="yes" xml:space="preserve">
          <source>Schedulers control the speed and order of emissions to observers from an Observable stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da980e95f75afdf74582357235c3821b3433724e" translate="yes" xml:space="preserve">
          <source>Schedules a function, &lt;code&gt;work&lt;/code&gt;, for execution. May happen at some point in the future, according to the &lt;code&gt;delay&lt;/code&gt; parameter, if specified. May be passed some context object, &lt;code&gt;state&lt;/code&gt;, which will be passed to the &lt;code&gt;work&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673c78762b92faf8c0f711ae8c27b09fd7adf696" translate="yes" xml:space="preserve">
          <source>Schedules on a queue in the current event frame (trampoline scheduler). Use this for iteration operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307c3d4ad5ad2007d0c4fd27c8b6dc8472efbde7" translate="yes" xml:space="preserve">
          <source>Schedules on the micro task queue, which is the same queue used for promises. Basically after the current job, but before the next job. Use this for asynchronous conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46db6d3e62af2b535ae941204cbf23becb8bf40" translate="yes" xml:space="preserve">
          <source>Schedules task that will happen just before next browser content repaint. Can be used to create smooth browser animations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acdff3eb9d9cdfba31eea32e36e86bfe7b790dd" translate="yes" xml:space="preserve">
          <source>Schedules work with &lt;code&gt;setInterval&lt;/code&gt; . Use this for time-based operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce91accab9d87d4543987a7616f361ca2ee69e09" translate="yes" xml:space="preserve">
          <source>Second Observer subscribes to the multicasted Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a231eb8ca71a34a4b8a7fd63f8b35534d74f9844" translate="yes" xml:space="preserve">
          <source>Second Observer unsubscribes from the multicasted Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2211f79abc75813901ecbe13d6013af70d4b2695" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;pipeable-operators#build-your-own-operators-easily&quot;&gt;Build Your Own Operators&lt;/a&gt;&quot; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e6d58ed22bcebe4e5d1455cb1f6614be2549de" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/91088dae1df097be2370c73300ffa11b27fd0100/doc/pipeable-operators.md&quot;&gt;Pipeable Operator Documentation&lt;/a&gt; for more information about pipeable operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa361e26dff73f6d13082032f134cf2d8ca734ed" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;migration#dep-methods&quot;&gt;Convert deprecated methods&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a5d018bf77ba25d9ae411b1a9cf8397c47f0fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;migration#pipe-syntax&quot;&gt;Operator Pipe Syntax&lt;/a&gt; for details of how to refactor using &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7898f4af0dbbb91be2c6f8eba8ca4ff35a4e7eca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;migration#result-selectors&quot;&gt;Result Selector Migration&lt;/a&gt; for details of which operators are affected and how to move the result-selection functions out of the operator call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31fba1436c933645e7506da07902cadaaba6e31" translate="yes" xml:space="preserve">
          <source>See the list of &lt;a href=&quot;operators#creation-operators&quot;&gt;all static creation operators here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7478de43072818f11d6178c269b8f31a3404f08b" translate="yes" xml:space="preserve">
          <source>Selector function for results produced in the sequence. (deprecated)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37013a70e844c58bbab5d5525f410ca73fae2fd9" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;binaryType&lt;/code&gt; property of the underlying WebSocket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e430b2ed9df11b12d77dfa7a8fcaa261fb47fe5" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;publish&quot;&gt;&lt;code&gt;publish&lt;/code&gt;&lt;/a&gt;, but it waits until the source observable completes and stores the last emitted value. Similarly to &lt;a href=&quot;publishreplay&quot;&gt;&lt;code&gt;publishReplay&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;publishbehavior&quot;&gt;&lt;code&gt;publishBehavior&lt;/code&gt;&lt;/a&gt;, this keeps storing the last value even if it has no more subscribers. If subsequent subscriptions happen, they will immediately get that last stored value and complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b543e1a7104c2c1070419c5cdb08c750a3f9564f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt;, this operator repeats the stream of items emitted by the source for non error cases. Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05ce98143ff1dea1f44d48657a30e2539a1498a" translate="yes" xml:space="preserve">
          <source>Similar to the well known &lt;code&gt;Array.prototype.map&lt;/code&gt; function, this operator applies a projection to each value and emits that projection in the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74afc0044be954d513659e637a2abb3bc713ed7d" translate="yes" xml:space="preserve">
          <source>Similar to the well-known &lt;code&gt;Array.prototype.filter&lt;/code&gt; method, this operator takes values from the source Observable, passes them through a &lt;code&gt;predicate&lt;/code&gt; function and only emits those values that yielded &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdb9c100c616284a2a5cb4950401eddc993767b" translate="yes" xml:space="preserve">
          <source>Simple configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89449b0cb51102484f069c0d7826492d94a7c95" translate="yes" xml:space="preserve">
          <source>Since a Subject is an Observer, this also means you may provide a Subject as the argument to the &lt;code&gt;subscribe&lt;/code&gt; of any Observable, like the example below shows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1186892a2f5c2bd17cd7d41f90482e39bd02c5" translate="yes" xml:space="preserve">
          <source>Single</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48be63572dede2c5e587060360592e079d609d23" translate="yes" xml:space="preserve">
          <source>Skip the last 2 values of an Observable with many values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d139f86c3c3edaad93f5ed24fc5e3716a01b08" translate="yes" xml:space="preserve">
          <source>Skip the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f39dd825c9999bb9154e8342644bd8649ea40" translate="yes" xml:space="preserve">
          <source>Some contextual data that the &lt;code&gt;work&lt;/code&gt; function uses when called by the Scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68833037145847bb239c9c0d7954832a980718ba" translate="yes" xml:space="preserve">
          <source>Some people claim that Observables are asynchronous. That is not true. If you surround a function call with logs, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e457754baa9b39f89ddffacf51116e4c87d616cd" translate="yes" xml:space="preserve">
          <source>Sometimes, we need to assert changes in state &lt;em&gt;after&lt;/em&gt; an observable stream has completed - such as when a side effect like &lt;code&gt;tap&lt;/code&gt; updates a variable. Outside of Marbles testing with TestScheduler, we might think of this as creating a delay or waiting before making our assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa8c10c18c7a89cff2fb7d569ca8b8e16944ae" translate="yes" xml:space="preserve">
          <source>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83de9d7eba491bef935446200063dc82beda12d6" translate="yes" xml:space="preserve">
          <source>Spawn a new interval observable for each click event, but for every new click, cancel the previous interval and subscribe to the new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f222ec9c4386e16b3c3afb1c56f71156de7c6fd" translate="yes" xml:space="preserve">
          <source>Splits the source Observable into two, one with values that satisfy a predicate, and another with values that don't satisfy the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473ef7550247da5a91a77ab1e6b6ae0ced9ecf45" translate="yes" xml:space="preserve">
          <source>Start emitting the powers of two on every click, at most 10 of them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca890ac76cc523b5b451bd1e50d70188d3df24a" translate="yes" xml:space="preserve">
          <source>Start the chain of emissions with &lt;code&gt;&quot;first&quot;&lt;/code&gt;, &lt;code&gt;&quot;second&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e4c97f5285093afe2e51810483a57a44918a20" translate="yes" xml:space="preserve">
          <source>Starting in version 5.5 we have shipped &quot;pipeable operators&quot;, which can be accessed in &lt;code&gt;rxjs/operators&lt;/code&gt; (notice the pluralized &quot;operators&quot;). These are meant to be a better approach for pulling in just the operators you need than the &quot;patch&quot; operators found in &lt;code&gt;rxjs-compat&lt;/code&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5586262f2a19474f6427268539657e802eb9fedc" translate="yes" xml:space="preserve">
          <source>Static version of &lt;code&gt;combineLatest&lt;/code&gt; accepts either an array of Observables or each Observable can be put directly as an argument. Note that array of Observables is good choice, if you don't know beforehand how many Observables you will combine. Passing empty array will result in Observable that completes immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503b46dc38ee1e74e2e39f9f2cfd348c6e63791f" translate="yes" xml:space="preserve">
          <source>String key for object property lookup on each item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1cd724f97ed48d626d171bc1b8f9491fcd67e0" translate="yes" xml:space="preserve">
          <source>Subclasses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d183dbdcea3b29906090bd83fa6fa37923cc8ec" translate="yes" xml:space="preserve">
          <source>Subject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96aa22877cd96a7b35772698ac27a0a724ea1df" translate="yes" xml:space="preserve">
          <source>Subject._subscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071205c2dde294ca49d8e05c0695e54865872611" translate="yes" xml:space="preserve">
          <source>Subject._trySubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160589a52dcbec13463265c453b8a9ca8be4370a" translate="yes" xml:space="preserve">
          <source>Subject.asObservable()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975086ec0b19b714c1549506157605f8b45d15b8" translate="yes" xml:space="preserve">
          <source>Subject.complete()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca406d36c2ee813cb21e8588c8de1288afcf054d" translate="yes" xml:space="preserve">
          <source>Subject.error()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f7e424cc5d45f264cc1fb329434ef6a7d07720" translate="yes" xml:space="preserve">
          <source>Subject.lift()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372ffa8e7eba87b15c9f92aa34c625b95be206d4" translate="yes" xml:space="preserve">
          <source>Subject.next()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371adb95cc03dbc773f764627feec95b995210f4" translate="yes" xml:space="preserve">
          <source>Subject.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7e820ab708c9ca03058c3aeebe215013d0cbd4" translate="yes" xml:space="preserve">
          <source>SubjectFactory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa370bed5c22d9112aea9aa2610c89c1eac8ba62" translate="yes" xml:space="preserve">
          <source>Subscribable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d4d4c36ad0cdfc02349a0eb2c849c54acdfa33" translate="yes" xml:space="preserve">
          <source>Subscribable.subscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc68071fc311d889de8210bb2293b3d44a1e533" translate="yes" xml:space="preserve">
          <source>SubscribableOrPromise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a3399bf2aea458ce41df56a4b0242a5c94277b" translate="yes" xml:space="preserve">
          <source>Subscribe to either an Observable of clicks or an Observable of interval, at random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3452b8a082cc6d6da8a139ab3989503c18e529bd" translate="yes" xml:space="preserve">
          <source>Subscribe to the next Observable after map fails</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af85fcff6b749207cd304e07cc9af68e4352a647" translate="yes" xml:space="preserve">
          <source>Subscribe with an Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d973b64e36127ec068c18860c9be62d9e24baa" translate="yes" xml:space="preserve">
          <source>Subscribe with functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b20e68bb281a3bd7e3649e8fa90b958868b4f8" translate="yes" xml:space="preserve">
          <source>Subscriber</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9d5d306399fa76b1042f18dc4fcc4344416342" translate="yes" xml:space="preserve">
          <source>Subscriber._complete()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9452851cd0c53b2b1b9070ff731e4e6afde1368" translate="yes" xml:space="preserve">
          <source>Subscriber._error()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a97be7c56119350b65a45a2a2909c0a3889c85" translate="yes" xml:space="preserve">
          <source>Subscriber._next()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3177c3f5c74d6c452937ff0847420aa13a07c8f5" translate="yes" xml:space="preserve">
          <source>Subscriber._unsubscribeAndRecycle()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c3a9cb0f5c603b9e2cf8652007627305ea9ad9" translate="yes" xml:space="preserve">
          <source>Subscriber.complete()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce91a8580bdfa46b0e60ad27e35a80be1d5c9750" translate="yes" xml:space="preserve">
          <source>Subscriber.error()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a658014d253a43549f917e8e59ab6d2fffdfcd0d" translate="yes" xml:space="preserve">
          <source>Subscriber.next()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daffdb2a99749aa77e0f08717dfe47b794588c7e" translate="yes" xml:space="preserve">
          <source>Subscriber.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aad00bda70554e70b1354f0664c0ecb46a51284" translate="yes" xml:space="preserve">
          <source>Subscribes to the observable that was the first to start emitting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db06be4396c3af15a5d67a20d0195647fad6908" translate="yes" xml:space="preserve">
          <source>Subscribing to Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051bff4a97ea7b888ae22463573aff05d05a733" translate="yes" xml:space="preserve">
          <source>Subscribing to an Observable is analogous to calling a Function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be62b9c6463ed87b893b1d664b1b23f30e05becc" translate="yes" xml:space="preserve">
          <source>Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fde48f31aff21f9652066ed6732f7e7dbae712e" translate="yes" xml:space="preserve">
          <source>Subscription</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19b422625716e3b3bfd8c75722d76f0419a4a2c" translate="yes" xml:space="preserve">
          <source>Subscription Marble Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7146aaa7add68ef323a7d01605de38fb88f6231b" translate="yes" xml:space="preserve">
          <source>Subscription Marbles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaf52184537a5135846f1098e7eb56b3fa6c233" translate="yes" xml:space="preserve">
          <source>Subscription.add()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfa5efb434ec519cfd4bdf935cf54c43ce60795" translate="yes" xml:space="preserve">
          <source>Subscription.remove()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56134c69ec893cfcb54e67481d9ad55a97279640" translate="yes" xml:space="preserve">
          <source>Subscription.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d443e927956a41afc5121ef89799c56076740968" translate="yes" xml:space="preserve">
          <source>SubscriptionLike</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489299c3d90fe79af5f3a66a55fcf15bbb2f2589" translate="yes" xml:space="preserve">
          <source>SubscriptionLike.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348c3252944efc29eaeb98181c5249d17ab470c4" translate="yes" xml:space="preserve">
          <source>Subscriptions also have a &lt;code&gt;remove(otherSubscription)&lt;/code&gt; method, in order to undo the addition of a child Subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa30d59200819cf74c8ab4f60213e4e57e21b21" translate="yes" xml:space="preserve">
          <source>Subscriptions can also be put together, so that a call to an &lt;code&gt;unsubscribe()&lt;/code&gt; of one Subscription may unsubscribe multiple Subscriptions. You can do this by &quot;adding&quot; one subscription into another:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ce68bba7f5740864c68b490804965090827109" translate="yes" xml:space="preserve">
          <source>Symbol.observable or a string &quot;@@observable&quot;. Used for interop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31e7e653fc6977e3c1b8f91a3cb6c313b84edf4" translate="yes" xml:space="preserve">
          <source>Synchronous Assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238297c13119150602e609edb96036edb4866e22" translate="yes" xml:space="preserve">
          <source>Synchronous error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf9ed1d5288a0365deb7a5de7ee4c30bced0b88" translate="yes" xml:space="preserve">
          <source>Synchronous error handling (placing a call to the &lt;code&gt;Observable.subscribe()&lt;/code&gt; method within a &lt;code&gt;try/catch&lt;/code&gt; block) is no longer supported. If it is used, it must be replaced with asynchronous error handling, using the &lt;code&gt;error&lt;/code&gt; callback in the &lt;code&gt;Observable.subscribe()&lt;/code&gt; method. See &lt;a href=&quot;migration#ex-1&quot;&gt;examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa1da477909c7ae3ba95e7b8916bd81f868e454" translate="yes" xml:space="preserve">
          <source>Take the first 5 seconds of an infinite 1-second interval Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e876c12d6589cb82f4d20acdebf178c1ac90dc2b" translate="yes" xml:space="preserve">
          <source>Take the last 3 values of an Observable with many values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c183ba0a42c60444d16a75d38d0d923748a6f3" translate="yes" xml:space="preserve">
          <source>Takes a constant &lt;code&gt;value&lt;/code&gt; as argument, and emits that whenever the source Observable emits a value. In other words, ignores the actual source value, and simply uses the emission moment to know when to emit the given &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7302b30eeb948f24d7143e47d552c191f05755a2" translate="yes" xml:space="preserve">
          <source>Takes an Observer or its individual callback functions, and calls &lt;code&gt;observe&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; methods accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6581999f57cb87b5350dba9a34ded6db81db76f0" translate="yes" xml:space="preserve">
          <source>Takes the first &lt;code&gt;count&lt;/code&gt; values from the source, then completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca912824fb81ad0e362ea606111da77b305c2c8d" translate="yes" xml:space="preserve">
          <source>Takes values from the source only while they pass the condition given. When the first value does not satisfy, it completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ccaea23a5e2b0b35ac243595e713c94232639c3" translate="yes" xml:space="preserve">
          <source>TeardownLogic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7c04460f478ae4c6dc608822750989329367fd" translate="yes" xml:space="preserve">
          <source>Tells how many values were emitted, when the source completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438ba35ac49fe62bb7316f17b6ff5e4e69619f5" translate="yes" xml:space="preserve">
          <source>Tells whether any values are emitted by an observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f882607c620ab2ac7db012e22f8e08de70799ac" translate="yes" xml:space="preserve">
          <source>TestScheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2815cd21b147f4f094c001e08cb2eeedcbe77885" translate="yes" xml:space="preserve">
          <source>TestScheduler helper methods have more verbose names, like &lt;code&gt;testScheduler.createColdObservable()&lt;/code&gt; instead of &lt;code&gt;cold()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662cd7828273448c4fbe6d65641778d838d741fe" translate="yes" xml:space="preserve">
          <source>TestScheduler.createColdObservable()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3a502e5e19c3511edc6fcf1eef8c72f27d48fc" translate="yes" xml:space="preserve">
          <source>TestScheduler.createHotObservable()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad3241cca63f2784e169cb2c24f0a0bebe01e3b" translate="yes" xml:space="preserve">
          <source>TestScheduler.createTime()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52477eccddef39f83f1ac44642b984e73621a51" translate="yes" xml:space="preserve">
          <source>TestScheduler.expectObservable()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdccebb48a255cbcd978b72e2fd359e48cdf91d" translate="yes" xml:space="preserve">
          <source>TestScheduler.expectSubscriptions()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a873e9be3486e7914b2839d5271d803c8b9e29f" translate="yes" xml:space="preserve">
          <source>TestScheduler.flush()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa1fcbbb4f4cae5016209b725526cf2b6fbef67" translate="yes" xml:space="preserve">
          <source>TestScheduler.run()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033ba94b328f6025c011cb17ae653b988075d315" translate="yes" xml:space="preserve">
          <source>Testing RxJS Code with Marble Diagrams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f26334e9ad4be53c8fdaf7ae744db4058dcd7f" translate="yes" xml:space="preserve">
          <source>Tests to see if the object is an RxJS &lt;a href=&quot;../class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a7e9e1b12e945491dcb57999047383d9556928" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;forkJoin&lt;/code&gt; will not emit more than once and it will complete after that. If you need to emit combined values not only at the end of lifecycle of passed observables, but also throughout it, try out &lt;a href=&quot;combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6127fbf2e94b35fbcee15d98e484d34698c8ad73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/operators/concatall&quot;&gt;&lt;code&gt;concatAll()&lt;/code&gt;&lt;/a&gt; operator subscribes to each &quot;inner&quot; Observable that comes out of the &quot;outer&quot; Observable, and copies all the emitted values until that Observable completes, and goes on to the next one. All of the values are in that way concatenated. Other useful flattening operators (called &lt;a href=&quot;operators#join-operators&quot;&gt;&lt;em&gt;join operators&lt;/em&gt;&lt;/a&gt;) are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2453b014bad2aca2cde6d64e400fe178ff3b9398" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to perform subscription actions on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297c695a08d3004f45e0d5f4faa77c125b875fd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for managing the timers that handle the rate-limiting behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb4a57b6826813f9824ff617413ea2e0eb47f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for managing the timers that handle the sampling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d7edb787bf2b0a718b71e09aa7d2b215497a53" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for managing the timers that handle the throttling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2849a51594dafb7cb1a99646dbf4f1d58dd504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for managing the timers that handle the time-shift for each item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c54c994cbc43e1d269f274e0696f23e3c93df7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for managing the timers that handle the timeout for each value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d672ef7661c99d974fe6e2a705c328fab227c5ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for subscribing to each projected inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575281374a14e691645ea110401bfc21d391baf5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callback to receive a valueless notification of type &lt;code&gt;complete&lt;/code&gt; from the Observable. Notifies the Observer that the Observable has finished sending push-based notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050f9d7404b5848e0bddeebcc4711175eb33bb75" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callback to receive notifications of type &lt;code&gt;error&lt;/code&gt; from the Observable, with an attached &lt;code&gt;Error&lt;/code&gt;. Notifies the Observer that the Observable has experienced an error condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b252debc9601073ff1d740c248330c580cef35a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callback to receive notifications of type &lt;code&gt;next&lt;/code&gt; from the Observable, with a value. The Observable may call this method 0 or more times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69022467d7c9a5862047788e44e947b88955d12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of values, and providing a notion of &quot;time&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9dbb26d65a7b0948ee621f04714df8af9ca27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Observable&lt;/code&gt; constructor takes one argument: the &lt;code&gt;subscribe&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168d0dff0b9f569b53e1ee0ebb71c6c6a2887ad4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^&lt;/code&gt; characters of &lt;code&gt;hot&lt;/code&gt; observables should &lt;strong&gt;always&lt;/strong&gt; be aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6bd534007210a8e903d111d55dc14f9206d91b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; Scheduler is one of the built-in schedulers provided by RxJS. Each of these can be created and returned by using static properties of the &lt;code&gt;Scheduler&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81f4d26ea048ce68216678f486398df3adcf0ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; Scheduler operates with a &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;setInterval&lt;/code&gt;, even if the given &lt;code&gt;delay&lt;/code&gt; was zero. As usual, in JavaScript, &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; is known to run the function &lt;code&gt;fn&lt;/code&gt; earliest on the next event loop iteration. This explains why &lt;code&gt;got value 1&lt;/code&gt; is delivered to the &lt;code&gt;finalObserver&lt;/code&gt; after &lt;code&gt;just after subscribe&lt;/code&gt; happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c541f5dbe18cd7638317f074cfea74b2e3588a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complete&lt;/code&gt; callback of an Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b8a54cc8926197968d6f0423c4a4fd101a68ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; method is important to determine exactly when the shared Observable execution will start. Because &lt;code&gt;connect()&lt;/code&gt; does &lt;code&gt;source.subscribe(subject)&lt;/code&gt; under the hood, &lt;code&gt;connect()&lt;/code&gt; returns a Subscription, which you can unsubscribe from in order to cancel the shared Observable execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1e6e438f129bed4e78349242bd62f58717ffea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; callback of an Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce276dffd7807684ed1c8f12625d5c184c7c1e0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b4617f9fc6f4da07734c23774fbea39f392c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0279c412e9bcb082bfc3f314a0be224eb23c5132" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expectSubscriptions&lt;/code&gt; helper allows you to assert that a &lt;code&gt;cold()&lt;/code&gt; or &lt;code&gt;hot()&lt;/code&gt; Observable you created was subscribed/unsubscribed to at the correct point in time. The &lt;code&gt;subscriptionMarbles&lt;/code&gt; parameter to &lt;code&gt;expectObservable&lt;/code&gt; allows your test to defer subscription to a later virtual time, and/or unsubscribe even if the observable being tested has not yet completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bac2fbdafb1e4b4af6e614a9f9f53cb4684e9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; operator is now part of &lt;code&gt;Observable&lt;/code&gt; as &lt;code&gt;pipe&lt;/code&gt; and cannot be imported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e38c642902caca559dc60fdcd284db1493b9ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; callback of an Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b17b9ac6cfbd57c638b50eb54c95773f5616e9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value &lt;code&gt;0&lt;/code&gt; is delivered to the first Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6198cafcaa90d3b9c0c7d1c66887e6700412db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; is delivered to the first Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abd7f5801f963f9ebbf2c1675e50b6dcd3e0c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; is delivered to the second Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a88680783ad43b246d9bdcc7ac31000574fe4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value &lt;code&gt;2&lt;/code&gt; is delivered to the second Observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad3f6fb8c20e979d4241fea562a0aaba8334dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b7f0e6b2b8408befc67ac45ea0c3bbbf90a21a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proxyObserver&lt;/code&gt; is created in &lt;code&gt;observeOn(asyncScheduler)&lt;/code&gt;, and its &lt;code&gt;next(val)&lt;/code&gt; function is approximately the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb5ab5e24c1a3cf193228ae59b2c2504e594cf2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refCount()&lt;/code&gt; method only exists on ConnectableObservable, and it returns an &lt;code&gt;Observable&lt;/code&gt;, not another ConnectableObservable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31218beba1fbf557e3b8a1340d4bcbedb526c02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resultSelector&lt;/code&gt; parameter available for many mapping operators has been &lt;em&gt;deprecated&lt;/em&gt; for v6 and the implementation re-written to be much smaller. They will continue to work without the compatibility package, but must be replaced before the v7 release. See &lt;a href=&quot;migration#deprecations&quot;&gt;Deprecations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb2a0b6d06f0ce1060f9e4b4a5879aaeb3cf348" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resultSelector&lt;/code&gt; parameter for &lt;code&gt;first()&lt;/code&gt; and &lt;code&gt;last()&lt;/code&gt; are &lt;em&gt;removed&lt;/em&gt; in v6. If these are used, the code must be updated to run without the &lt;code&gt;rxjs-compat&lt;/code&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34dd87f68003fddbe3483a8c2730afad4875fda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule()&lt;/code&gt; method of a Scheduler takes a &lt;code&gt;delay&lt;/code&gt; argument, which refers to a quantity of time relative to the Scheduler's own internal clock. A Scheduler's clock need not have any relation to the actual wall-clock time. This is how temporal operators like &lt;code&gt;delay&lt;/code&gt; operate not on actual time, but on time dictated by the Scheduler's clock. This is specially useful in testing, where a &lt;em&gt;virtual time Scheduler&lt;/em&gt; may be used to fake wall-clock time while in reality executing scheduled tasks synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21dc570876708684aee7799da8347f66ad42770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipUntil&lt;/code&gt; operator causes the observable stream to skip the emission of values ​​until the passed in observable emits the first value. This can be particularly useful in combination with user interactions, responses of http requests or waiting for specific times to pass by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba2c7bd6ea63ea35c3ec1ec6faf98992ca8e05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; operator maps the &lt;em&gt;source&lt;/em&gt; observable stream to an object of type &lt;code&gt;{value: T, timestamp: R}&lt;/code&gt;. The properties are generically typed. The &lt;code&gt;value&lt;/code&gt; property contains the value and type of the &lt;em&gt;source&lt;/em&gt; observable. The &lt;code&gt;timestamp&lt;/code&gt; is generated by the schedulers &lt;code&gt;now&lt;/code&gt; function. By default it uses the &lt;em&gt;async&lt;/em&gt; scheduler which simply returns &lt;code&gt;Date.now()&lt;/code&gt; (milliseconds since 1970/01/01 00:00:00:000) and therefore is of type &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2f80727ca4de160d036931c9f6c3ad68365c35" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;first character&lt;/strong&gt; of &lt;code&gt;cold&lt;/code&gt; observables or expected observables should &lt;strong&gt;always&lt;/strong&gt; be aligned with each other, and with the &lt;code&gt;^&lt;/code&gt; of hot observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b6f4ba6198d4cbf054f1bad21d9b86e24ba9b6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;scan&lt;/strong&gt; operator works just like &lt;strong&gt;reduce&lt;/strong&gt; for arrays. It takes a value which is exposed to a callback. The returned value of the callback will then become the next value exposed the next time the callback runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608ffeec97525a6c15fb992788fce7b5b29028aa" translate="yes" xml:space="preserve">
          <source>The AsyncSubject is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5d84b4880fd29ca5bc07154776cd43f018f74" translate="yes" xml:space="preserve">
          <source>The AsyncSubject is similar to the &lt;a href=&quot;../api/operators/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt; operator, in that it waits for the &lt;code&gt;complete&lt;/code&gt; notification in order to deliver a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83741777beb228e001710fc5948964bb13e249c" translate="yes" xml:space="preserve">
          <source>The DOM EventTarget, Node.js EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9d8a557d7ed1fa00dacdbfa129a1153519bb3f" translate="yes" xml:space="preserve">
          <source>The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function), and when source Observable completes it emits a single item: the item with the largest value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454e18f3af1566d35b392753f951a4b42ba61a3e" translate="yes" xml:space="preserve">
          <source>The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function), and when source Observable completes it emits a single item: the item with the smallest value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cdd59b24cc1ecd69806dfa02be66002e61fb00" translate="yes" xml:space="preserve">
          <source>The Nth emission from the source Observable will cause the output Observable to emit an array [(N-1)th, Nth] of the previous and the current value, as a pair. For this reason, &lt;code&gt;pairwise&lt;/code&gt; emits on the second and subsequent emissions from the source Observable, but not on the first emission, because there is no previous value in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e4db7d861578d6ad60e8af71665864f81af898" translate="yes" xml:space="preserve">
          <source>The Observable &lt;code&gt;observable&lt;/code&gt; in the example can be &lt;em&gt;subscribed&lt;/em&gt; to, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56351ea738687608eab54f07538002ba6113eb09" translate="yes" xml:space="preserve">
          <source>The Observable factory function to invoke for each Observer that subscribes to the output Observable. May also return a Promise, which will be converted on the fly to an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246084eead33f5f1c47321f83d3de45306dd63aa" translate="yes" xml:space="preserve">
          <source>The Observable to use for sampling the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904efd5cd0394aa326abd177143cf1eba7fb6ddc" translate="yes" xml:space="preserve">
          <source>The Observable whose first emitted value will cause the output Observable of &lt;code&gt;takeUntil&lt;/code&gt; to stop emitting values from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7a35cb468ff7334184f4ab335af57d5ea85fec" translate="yes" xml:space="preserve">
          <source>The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution. Read more about the &lt;a href=&quot;subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt; type here&lt;/a&gt;. With &lt;code&gt;subscription.unsubscribe()&lt;/code&gt; you can cancel the ongoing execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4aee4691bb51e8ec2b83e4e60bc969997794b7" translate="yes" xml:space="preserve">
          <source>The TestScheduler has been around since v5, but was actually intended for testing RxJS itself by the maintainers, rather than for use in regular user apps. Because of this, some of the default behaviors and features of the TestScheduler didn't work well (or at all) for users. In v6 we introduced the &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; method which allowed us to provide new defaults and features in a non-breaking way, but it's still possible to &lt;a href=&quot;internal-marble-tests&quot;&gt;use the TestScheduler outside&lt;/a&gt; of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;. It's important to note that if you do so, there are some major differences in how it will behave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fa0d776ffcf8b97db8264887c02993f3f9b866" translate="yes" xml:space="preserve">
          <source>The WebSocket endpoint as an url or an object with configuration and additional Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd762b0012eb1313516ea31aad9f541d4fb0440" translate="yes" xml:space="preserve">
          <source>The accumulator function called on each source value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b1835a9598f791baf5187d335473bbeffd6c62" translate="yes" xml:space="preserve">
          <source>The additional logic to execute on teardown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4da59988abfcdceb497d42ce93d0753ac582183" translate="yes" xml:space="preserve">
          <source>The amount of time to fill each buffer array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522665302e28a22a5197238af3e476a17b997f7f" translate="yes" xml:space="preserve">
          <source>The amount of time to fill each window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a912bb068dbb68b9ae5789e92c680df2399381ae" translate="yes" xml:space="preserve">
          <source>The callback function you provide to &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; is called with &lt;code&gt;helpers&lt;/code&gt; object that contains functions you'll use to write your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2860e442632f6f6f5523cf277a767bc6535caa57" translate="yes" xml:space="preserve">
          <source>The code inside &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; represents an &quot;Observable execution&quot;, a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d659b37bce020b5c7c840b095c681122925b95d" translate="yes" xml:space="preserve">
          <source>The compatibility package increases the bundle size of your application, which is why we recommend removing it as soon as your application and dependencies have been updated. This size increase is exacerbated if you are using a version of Webpack before 4.0.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab62ff2ac5fd726d6c0b9a6685d2fc8bea79a0bc" translate="yes" xml:space="preserve">
          <source>The condition any source emitted item has to satisfy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb32affd647c0e608dd58579f0db5b2ddfde101a" translate="yes" xml:space="preserve">
          <source>The default value emitted in case no valid value was found on the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f30f2a8877ddc0631f3112e0ace3fa80bd01035" translate="yes" xml:space="preserve">
          <source>The default value returned for missing indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594665e75fae8ce3da56753de4fb2cd6529bcec" translate="yes" xml:space="preserve">
          <source>The default value used if the source Observable is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3863f685d58272b87f8e94a10e6b7eb30fb4e28a" translate="yes" xml:space="preserve">
          <source>The delay duration in milliseconds (a &lt;code&gt;number&lt;/code&gt;) or a &lt;code&gt;Date&lt;/code&gt; until which the emission of the source items is delayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e411a94b66e44ecd454cdb97f4d966f75e38dce" translate="yes" xml:space="preserve">
          <source>The elements emitted by &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt;s are by default the items emitted by the Observable, or elements returned by the elementSelector function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5138481b6d7a9f801f339111fb8cdfd9eed56809" translate="yes" xml:space="preserve">
          <source>The error to use for the &lt;code&gt;#&lt;/code&gt; marble (if present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095c912066a1e9749b3a6afeef9c58da8ab87067" translate="yes" xml:space="preserve">
          <source>The essential concepts in RxJS which solve async event management are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeeb83fb34d9d0df000435ba309cf825247bc1ea" translate="yes" xml:space="preserve">
          <source>The event name of interest, being emitted by the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d358e341a09b5f697f66bd185bb79f08e30a91" translate="yes" xml:space="preserve">
          <source>The first way is creating an object that implements &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; interface. It should have methods defined by that interface, but note that it should be just a regular JavaScript object, which you can create yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also that your object does not have to implement all methods. If you find yourself creating a method that doesn't do anything, you can simply omit it. Note however, if the &lt;code&gt;error&lt;/code&gt; method is not provided, all errors will be left uncaught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81a20ddd6b1db8f689bf6a3b445a959cfcdb7f8" translate="yes" xml:space="preserve">
          <source>The following code shows how to correct the test to use asynchronous error handling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce9aafae9ce6fd2d714bc48e5dd9756098901bb" translate="yes" xml:space="preserve">
          <source>The following code updates this to handle errors asynchronously by defining an error callback for &lt;code&gt;Observable.subscribe()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55c53a2ad8fefd776708f32d09ab1adc3a86baf" translate="yes" xml:space="preserve">
          <source>The following example creates an Observable to emit the string &lt;code&gt;'hi'&lt;/code&gt; every second to a subscriber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1a1ed0063b9be484443f9ccc6d808635ba6ba3" translate="yes" xml:space="preserve">
          <source>The following example only emits clicks which happen within a subsequent delay of 400ms of the previous click. This for example can emulate a double click. It makes use of the &lt;code&gt;trailing&lt;/code&gt; parameter of the throttle configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af8daf68a8da9aa34e4154889c3412c08731d2" translate="yes" xml:space="preserve">
          <source>The following example shows the kind of changes you will need to make in user-defined prototype operators, in order for the TypeScript to compile correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd2610d7767b7747454eab96c7b9e3a6e3282db" translate="yes" xml:space="preserve">
          <source>The following is an example of an Observable execution that delivers three Next notifications, then completes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01548d05f222bfa1b8dfcad883f65670ab0a9456" translate="yes" xml:space="preserve">
          <source>The following operator names were changed because their dot-chained names are reserved words in JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d366a738de884aed0ede40c486c5eb4e38bd9d3" translate="yes" xml:space="preserve">
          <source>The former &lt;code&gt;toPromise()&lt;/code&gt; &quot;operator&quot; has been removed because an operator returns an &lt;code&gt;Observable&lt;/code&gt;, not a &lt;code&gt;Promise&lt;/code&gt;. There is now an &lt;code&gt;Observable.toPromise()&lt;/code&gt;instance method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d5089f363e342bb0ebd993df6b9f7e70d38425" translate="yes" xml:space="preserve">
          <source>The function to apply to each &lt;code&gt;value&lt;/code&gt; emitted by the source Observable. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366d7677590b854a4291fa0c045d9aa3f530aa4c" translate="yes" xml:space="preserve">
          <source>The given arguments will be processed an stored as an Action object in a queue of actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4de96da12afb11b79995d66d48ee9928c233379" translate="yes" xml:space="preserve">
          <source>The global configuration object for RxJS, used to configure things like what Promise contructor should used to create Promises</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5000716a3e6d1c55a2a64b32daff236e504f293" translate="yes" xml:space="preserve">
          <source>The initial accumulation value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77a7ec566320e0bf494ddede2e88c719a27abea" translate="yes" xml:space="preserve">
          <source>The initial delay time specified as a Date object or as an integer denoting milliseconds to wait before emitting the first value of 0`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbce2dcfd8d24b72551d207895a6a631a7f304a" translate="yes" xml:space="preserve">
          <source>The interval size in milliseconds (by default) or the time unit determined by the scheduler's clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda08d86f5bdb3275f553bbafffdfece00f5309b" translate="yes" xml:space="preserve">
          <source>The last optional parameter - &lt;code&gt;scheduler&lt;/code&gt; - can be used to control when the call to &lt;code&gt;func&lt;/code&gt; happens after someone subscribes to Observable, as well as when results passed to callback will be emitted. By default, the subscription to an Observable calls &lt;code&gt;func&lt;/code&gt; synchronously, but using &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; as the last parameter will defer the call to &lt;code&gt;func&lt;/code&gt;, just like wrapping the call in &lt;code&gt;setTimeout&lt;/code&gt; with a timeout of &lt;code&gt;0&lt;/code&gt; would. If you were to use the async Scheduler and call &lt;code&gt;subscribe&lt;/code&gt; on the output Observable, all function calls that are currently executing will end before &lt;code&gt;func&lt;/code&gt; is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655767945dd5cd5d9d851ccf6a6ccc9fb886fd4a" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;next&lt;/code&gt; values to emit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8dd5547b91a2b4ac746e1928cbcc754674f38d9" translate="yes" xml:space="preserve">
          <source>The maximum number of values emitted by each window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3e272a390afbce141df3c36e752f8d49c0601b" translate="yes" xml:space="preserve">
          <source>The maximum number of values to emit from the end of the sequence of values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb0d9fd9b8c46d088fbadd154f2f5d9e43cd975" translate="yes" xml:space="preserve">
          <source>The maximum size of the buffer emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463aa022530b11884b3405ccf6e7aec844f66d70" translate="yes" xml:space="preserve">
          <source>The nested properties to pluck from each source value (an object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e1e843bc04ebb505cf3fee471cae781961341c" translate="yes" xml:space="preserve">
          <source>The new time progression syntax takes inspiration from the CSS duration syntax. It's a number (int or float) immediately followed by a unit; ms (milliseconds), s (seconds), m (minutes). e.g. &lt;code&gt;100ms&lt;/code&gt;, &lt;code&gt;1.4s&lt;/code&gt;, &lt;code&gt;5.25m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874bb2ecc796c3e0585a78974af87e5da80e53aa" translate="yes" xml:space="preserve">
          <source>The next example shows a test that relies on synchronous error handling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506256f0ad440c028b32fe5b6d2b52ca552bf49f" translate="yes" xml:space="preserve">
          <source>The number of sequential integers to generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72eddcdb9765b1729ed01756eecf04edaafdfa70" translate="yes" xml:space="preserve">
          <source>The number of times the source Observable items are repeated, a count of 0 will yield an empty Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33610b43ea0ee4852787c4fbbf13298ef613a101" translate="yes" xml:space="preserve">
          <source>The number of times, items emitted by source Observable should be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2a2baae3f8fe90290cb97a2e1f6076ddccc6ec" translate="yes" xml:space="preserve">
          <source>The observable sequence to compare the source sequence to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73e37ce3b4901c98351bd65282e80f252c648ef" translate="yes" xml:space="preserve">
          <source>The observable, array, promise, iterable, etc you would like to schedule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312bba969d17ba1d81ed7c1f8e07d2d0e41675d3" translate="yes" xml:space="preserve">
          <source>The only difference is that it accepts a second, required parameter. This parameter should be an Observable which will be subscribed when source Observable fails any timeout check. So whenever regular &lt;code&gt;timeout&lt;/code&gt; would emit an error, &lt;code&gt;timeoutWith&lt;/code&gt; will instead start re-emitting values from second Observable. Note that this fallback Observable is not checked for timeouts itself, so it can emit values and complete at arbitrary points in time. From the moment of a second subscription, Observable returned from &lt;code&gt;timeoutWith&lt;/code&gt; simply mirrors fallback stream. When that stream completes, it completes as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0601b59be6919653c6a40acf2e508c396e72ff8" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;bindCallback&lt;/code&gt; is a function that takes the same parameters as &lt;code&gt;func&lt;/code&gt;, except the last one (the callback). When the output function is called with arguments it will return an Observable. If function &lt;code&gt;func&lt;/code&gt; calls its callback with one argument, the Observable will emit that value. If on the other hand the callback is called with multiple values the resulting Observable will emit an array with said values as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becef8a2b7b1c59e8a6a18ea58a2da926727ec20" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;bindNodeCallback&lt;/code&gt; is a function that takes the same parameters as &lt;code&gt;func&lt;/code&gt;, except the last one (the callback). When the output function is called with arguments, it will return an Observable. If &lt;code&gt;func&lt;/code&gt; calls its callback with error parameter present, Observable will error with that value as well. If error parameter is not passed, Observable will emit second parameter. If there are more parameters (third and so on), Observable will emit an array with all arguments, except first error argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05251780d118043428a927e75d9501f4baf06bd" translate="yes" xml:space="preserve">
          <source>The output will instead be &lt;code&gt;5 6 7 8 9 1 2 3 4&lt;/code&gt;. The reason for this is that Observable &lt;code&gt;b&lt;/code&gt; emits its values directly and synchronously like before but the emissions from &lt;code&gt;a&lt;/code&gt; are scheduled on the event loop because we are now using the &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; for that specific Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a943b2ba73aa4faafb22621e795f259d61b1ed" translate="yes" xml:space="preserve">
          <source>The parameter has been &lt;em&gt;removed &lt;/em&gt;from the first() and last() operators in v6, but is supported by the rxjs-compat package. You must update your code in order to drop the compatibility package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1b09ef73a8eecb562c6d9468a98f3366525484" translate="yes" xml:space="preserve">
          <source>The parameter is &lt;em&gt;deprecated &lt;/em&gt;in the following operators, and will be removed in v7. You must update your code before moving to the v7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff47373410a71f0a6a7a57567d14a06931976656" translate="yes" xml:space="preserve">
          <source>The particular Error to pass to the error notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d0a0371797057afb25d99e94b05dabed30211f" translate="yes" xml:space="preserve">
          <source>The period of time between emissions of the subsequent numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8999cd12032fc464b15ef33257700758295faf" translate="yes" xml:space="preserve">
          <source>The previous coding style of chaining operators has been replaced by piping the result of one operator to another. Pipeable operators were added in version 5.5. For a full discussion of the reasoning and changes required for pipeable operators, see &lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/91088dae1df097be2370c73300ffa11b27fd0100/doc/pipeable-operators.md&quot;&gt;RxJS documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8db7d98a5ee9541dd5d8c0695f36e957287b2b" translate="yes" xml:space="preserve">
          <source>The protocol to use to connect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f12a96165f73217a871800cb40fd624b675eb00" translate="yes" xml:space="preserve">
          <source>The reason why we use Rx types like Observable, Observer, and Subscription is to get safety (such as the Observable Contract) and composability with Operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4e9d6c2cb60488e74f37c45a865ed4258f6ca1" translate="yes" xml:space="preserve">
          <source>The resource you would like to fetch. Can be a url or a request object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979f6f390916b7c52133e59499bc8ca9bc2a9a91" translate="yes" xml:space="preserve">
          <source>The same Observable instance returned by any call to &lt;a href=&quot;../function/empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; without a &lt;code&gt;scheduler&lt;/code&gt;. It is preferrable to use this over &lt;code&gt;empty()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93a4f3766624ddc65774735e912b6fe611a7670" translate="yes" xml:space="preserve">
          <source>The sampling period expressed in milliseconds or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46278554b8f173551edc050fc4294025b18ef12" translate="yes" xml:space="preserve">
          <source>The scheduler on which to schedule the callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc43240760020684cac692c8a3b1cd530fd52fdf" translate="yes" xml:space="preserve">
          <source>The scheduler on which to schedule the intervals that determine window boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbb315e66cb686ac546bdad99791fe7e7d438f7" translate="yes" xml:space="preserve">
          <source>The scheduler to use to schedule the subscription and emissions from the returned observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96a30d563360aad1b61befd53a8ba47b7b335c0" translate="yes" xml:space="preserve">
          <source>The second Observable that has to emit an item before the source Observable's elements begin to be mirrored by the resulting Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b354513b46f042e589aaa6dd7644398d850ff07b" translate="yes" xml:space="preserve">
          <source>The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods. This means you can provide three functions as arguments to &lt;code&gt;subscribe&lt;/code&gt;, where the first function is equivalent of a &lt;code&gt;next&lt;/code&gt; method, the second of an &lt;code&gt;error&lt;/code&gt; method and the third of a &lt;code&gt;complete&lt;/code&gt; method. Just as in case of Observer, if you do not need to listen for something, you can omit a function, preferably by passing &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, since &lt;code&gt;subscribe&lt;/code&gt; recognizes these functions by where they were placed in function call. When it comes to &lt;code&gt;error&lt;/code&gt; function, just as before, if not provided, errors emitted by an Observable will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0056d005a56c380c9df55b2648de409cd8d12e99" translate="yes" xml:space="preserve">
          <source>The solution is to test that code in isolation, with the traditional async testing methods of your testing framework. The specifics depend on your testing framework of choice, but here's a pseudo-code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7255ea6f9da5cc93279cd088ec500e4e0bed23" translate="yes" xml:space="preserve">
          <source>The subscription marble syntax is slightly different to conventional marble syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bf1d53dded06f01b5b8b2bd2f0b2bbe2f301e4" translate="yes" xml:space="preserve">
          <source>The subscription marble syntax is slightly different to conventional marble syntax. It represents the &lt;strong&gt;subscription&lt;/strong&gt; and an &lt;strong&gt;unsubscription&lt;/strong&gt; points happening over time. There should be no other type of event represented in such diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e64a62464083870602d6c2e374dc0f7cd2183ff" translate="yes" xml:space="preserve">
          <source>The subscription to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669660785471a0a5b8757f8cd891b847849540a5" translate="yes" xml:space="preserve">
          <source>The testScheduler instance is NOT automatically be used by operators that uses AsyncScheduler, e.g. delay, debounceTime, etc so you have to explicitly pass it to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb34df74e574af3652305a9d74c73558db072dd" translate="yes" xml:space="preserve">
          <source>The timeout duration in milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) for the window of time required to wait for emission silence before emitting the most recent source value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbc2bb2a4d715e391b92f5f5fb17c1ee81b1d74" translate="yes" xml:space="preserve">
          <source>The unit tests have helper methods that have been added to make creating tests easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0a024fd20095bf7e3cc28a7b899bdff7411d3d" translate="yes" xml:space="preserve">
          <source>The url of the socket server to connect to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e47142bdeb3a45e26f2a81d895bed837c3be23" translate="yes" xml:space="preserve">
          <source>The value of the first integer in the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f24355c54e52c0310088b000f4af2b1ef273bac" translate="yes" xml:space="preserve">
          <source>The value to map each source value to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20af90d2170ab3c204935ee522c70c8c1db66dd9" translate="yes" xml:space="preserve">
          <source>Then, when running &lt;code&gt;npm run tests2png&lt;/code&gt;, this test case will be parsed and a PNG file &lt;code&gt;zip.png&lt;/code&gt; (filename determined by &lt;code&gt;${operatorLabel}.png&lt;/code&gt;) will be created in the &lt;code&gt;img/&lt;/code&gt; folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1f205084e47d9e3d59fbafe62ce17bd4d9b560" translate="yes" xml:space="preserve">
          <source>There are also a few specializations of the &lt;code&gt;Subject&lt;/code&gt; type: &lt;code&gt;BehaviorSubject&lt;/code&gt;, &lt;code&gt;ReplaySubject&lt;/code&gt;, and &lt;code&gt;AsyncSubject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf8d135851b80ffbe87dcd35d86d4ad22ed02e6" translate="yes" xml:space="preserve">
          <source>There are no parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c6397789e74d75d50fd77e83efbbc6d6727879" translate="yes" xml:space="preserve">
          <source>There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f522a39d782069197ac932ff30262a5da4f586" translate="yes" xml:space="preserve">
          <source>There are three types of values an Observable Execution can deliver:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06d1e1fad1eee24685c2f5f79530aa7db04c3bf" translate="yes" xml:space="preserve">
          <source>There is NO support for time progression syntax e.g. &lt;code&gt;-a 100ms b-|&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627666bb7c20fabbe003b02b2b12af67e1abca83" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;pipe&lt;/code&gt; method built into &lt;code&gt;Observable&lt;/code&gt; now at &lt;code&gt;Observable.prototype.pipe&lt;/code&gt; that сan be used to compose the operators in similar manner to what you're used to with dot-chaining (shown below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44d94d82a052bf94d6014021ce33ebfb2167e14" translate="yes" xml:space="preserve">
          <source>There is a hard maximum number of frames set at 750 i.e. &lt;code&gt;maxFrames = 750&lt;/code&gt;. After 750 they are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d70bbbf2e7dbec5bf7e4a9a741eed13e1acce32" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;pipe&lt;/code&gt; utility function that can be imported from &lt;code&gt;import { pipe } from 'rxjs';&lt;/code&gt;. The &lt;code&gt;pipe&lt;/code&gt; function can be used to build reusable pipeable operators from other pipeable operators. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091eea7115421139aced6b7d552c819444e8ed97" translate="yes" xml:space="preserve">
          <source>There is an ajax operator on the Rx object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b810e823c4c6adcbbba7b7b48a63e25561ee248" translate="yes" xml:space="preserve">
          <source>There should be &lt;strong&gt;at most one&lt;/strong&gt;&lt;code&gt;^&lt;/code&gt; point in a subscription marble diagram, and &lt;strong&gt;at most one&lt;/strong&gt;&lt;code&gt;!&lt;/code&gt; point. Other than that, the &lt;code&gt;-&lt;/code&gt; character is the only one allowed in a subscription marble diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324f588a0a5a7a007b703f1d4c468c5529adf2d8" translate="yes" xml:space="preserve">
          <source>These are Observable creation operators that also have join functionality -- emitting values of multiple source Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7112614bdf35622ec4d75d53c09ed1157801a9" translate="yes" xml:space="preserve">
          <source>These constraints are expressed best in the so-called &lt;em&gt;Observable Grammar&lt;/em&gt; or &lt;em&gt;Contract&lt;/em&gt;, written as a regular expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e710aca17fdb6fd74f6e506e92cf5454701211" translate="yes" xml:space="preserve">
          <source>Think of RxJS as Lodash for events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18641d0826bb19078ecedf6dd54aaa675c2f41b" translate="yes" xml:space="preserve">
          <source>This document refers to the writing marble tests for the &lt;b&gt;RxJS repo internals&lt;/b&gt; and is intended for anyone wishing to help maintain the RxJS repo. &lt;b&gt;Users of RxJS&lt;/b&gt; should instead view the &lt;a href=&quot;marble-testing&quot;&gt;guide for writing marbles tests for applications&lt;/a&gt;. The major difference is that the behavior of the TestScheduler differs between manual usage and using the `testScheduler.run(callback)` helper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9f25ea67fc1f3bfbd03477ae04eb31bcd6138d" translate="yes" xml:space="preserve">
          <source>This guide refers to usage of marble diagrams when using the new `testScheduler.run(callback)`. Some details here do not apply to using the TestScheduler manually, without using the `run()` helper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02dd9a4c0b8c2125da67481a3bbcc1fdb18494d5" translate="yes" xml:space="preserve">
          <source>This happens because both functions and Observables are lazy computations. If you don't call the function, the &lt;code&gt;console.log('Hello')&lt;/code&gt; won't happen. Also with Observables, if you don't &quot;call&quot; it (with &lt;code&gt;subscribe&lt;/code&gt;), the &lt;code&gt;console.log('Hello')&lt;/code&gt; won't happen. Plus, &quot;calling&quot; or &quot;subscribing&quot; is an isolated operation: two function calls trigger two separate side effects, and two Observable subscribes trigger two separate side effects. As opposed to EventEmitters which share the side effects and have eager execution regardless of the existence of subscribers, Observables have no shared execution and are lazy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e38bbe0483eb4c12351ffe7a11e89060d9759d8" translate="yes" xml:space="preserve">
          <source>This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration &lt;code&gt;dueTime&lt;/code&gt;, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25d4c707b362b0c8890394f1f7a5550f1fb8659" translate="yes" xml:space="preserve">
          <source>This is an object with &lt;code&gt;addEventListener&lt;/code&gt; and &lt;code&gt;removeEventListener&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d590f77caba6b82686e4b5f8f0635836ace95560" translate="yes" xml:space="preserve">
          <source>This is drastically different to event handler APIs like &lt;code&gt;addEventListener&lt;/code&gt; / &lt;code&gt;removeEventListener&lt;/code&gt;. With &lt;code&gt;observable.subscribe&lt;/code&gt;, the given Observer is not registered as a listener in the Observable. The Observable does not even maintain a list of attached Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030d3a10d44115be8775ed698ea4f84c7b90aeb2" translate="yes" xml:space="preserve">
          <source>This is how you would allow at most one click per second, with plain JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a224df74fb24181a188a5d7caeb4f3b4f3d785f0" translate="yes" xml:space="preserve">
          <source>This means that when you execute task with &lt;code&gt;queue&lt;/code&gt; scheduler, you are sure it will end before any other task scheduled with that scheduler will start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16b94ba0c34b7e861f02ee29ab06baa415737ae" translate="yes" xml:space="preserve">
          <source>This operator accepts as a first argument an &lt;code&gt;addHandler&lt;/code&gt; function, which will be injected with handler parameter. That handler is actually an event handler function that you now can pass to API expecting it. &lt;code&gt;addHandler&lt;/code&gt; will be called whenever Observable returned by the operator is subscribed, so registering handler in API will not necessarily happen when &lt;code&gt;fromEventPattern&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f8f4239fe49e42bba359cc2394316bb3130564" translate="yes" xml:space="preserve">
          <source>This operator is useful for debugging your Observables for the correct values or performing other side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c14a1de51ed5b860c27d7888569463beb7474e" translate="yes" xml:space="preserve">
          <source>This operator is useful for producing metadata of the source Observable, to be consumed as &lt;code&gt;next&lt;/code&gt; emissions. Use it in conjunction with &lt;a href=&quot;dematerialize&quot;&gt;&lt;code&gt;dematerialize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918bfab61b812467a9671d8fa3ca44d8805b0589" translate="yes" xml:space="preserve">
          <source>This shows how &lt;code&gt;subscribe&lt;/code&gt; calls are not shared among multiple Observers of the same Observable. When calling &lt;code&gt;observable.subscribe&lt;/code&gt; with an Observer, the function &lt;code&gt;subscribe&lt;/code&gt; in &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; is run for that given subscriber. Each call to &lt;code&gt;observable.subscribe&lt;/code&gt; triggers its own independent setup for that given subscriber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6991a31ea4e6bd844a325e6adadee3151a2091" translate="yes" xml:space="preserve">
          <source>This static operator is useful for creating a simple Observable that only emits the complete notification. It can be used for composing with other Observables, such as in a &lt;a href=&quot;../../operators/mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f303d736244a165a83de51d21b4d8d4d81c5cf1e" translate="yes" xml:space="preserve">
          <source>This static operator is useful for creating a simple Observable that only emits the error notification. It can be used for composing with other Observables, such as in a &lt;a href=&quot;../../operators/mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39136469fce5251c86f465e0a749b1fdbbf5a1eb" translate="yes" xml:space="preserve">
          <source>Throughout this documentation site, we extensively use marble diagrams to explain how operators work. They may be really useful in other contexts too, like on a whiteboard or even in our unit tests (as ASCII diagrams).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51bc0ab9f659af095ff71c4da71d334ed4d4c5c" translate="yes" xml:space="preserve">
          <source>Throws a new error when the source Observable throws an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a173fe022f51ae291bc7b4e793931e3bfb80fa91" translate="yes" xml:space="preserve">
          <source>Tick every second until the first click happens</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c1c0fa4a0a55878610fedd4c6634bcaf029c63" translate="yes" xml:space="preserve">
          <source>Time progression syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c3cb9c388d5810075fc5c64581298e7abb0e95" translate="yes" xml:space="preserve">
          <source>Time shifts each item by some specified amount of milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3a19f5a718d79c179b2ff64325a333d76c93b8" translate="yes" xml:space="preserve">
          <source>Time to wait before emitting another value after emitting the last value, measured in milliseconds or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0a3cc6bd15f6fde6a50e1f351ac9545af1d12d" translate="yes" xml:space="preserve">
          <source>Time to wait before emitting the most recent source value, measured in milliseconds or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5725fa2802b4e7f913b9ce051c145a75f0ecb9" translate="yes" xml:space="preserve">
          <source>Time to wait before executing the work, where the time unit is implicit and defined by the Scheduler itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206e4887a5e816497dc7ddb9e052b318abb84fdd" translate="yes" xml:space="preserve">
          <source>Time-related operators like &lt;code&gt;bufferTime&lt;/code&gt;, &lt;code&gt;debounceTime&lt;/code&gt;, &lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;auditTime&lt;/code&gt;, &lt;code&gt;sampleTime&lt;/code&gt;, &lt;code&gt;throttleTime&lt;/code&gt;, &lt;code&gt;timeInterval&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;timeoutWith&lt;/code&gt;, &lt;code&gt;windowTime&lt;/code&gt; all take a Scheduler as the last argument, and otherwise operate by default on the &lt;code&gt;asyncScheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba258f4df0ea47c10e5c4377fcfdbc6f0344c95" translate="yes" xml:space="preserve">
          <source>Timeouts on Observable that doesn't emit values fast enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a6102b279449297697f90d7d4fb99ca28735dd" translate="yes" xml:space="preserve">
          <source>TimerObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5704beecd95b4312a2fab9e1415f6214167728a" translate="yes" xml:space="preserve">
          <source>To achieve that with explicit calls to &lt;code&gt;connect()&lt;/code&gt;, we write the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6a4e27f1e3ef2405a9e7484e69bb4e5712208e" translate="yes" xml:space="preserve">
          <source>To convert dot-chained operators to pipeable operators, wrap all operators in the &lt;code&gt;pipe()&lt;/code&gt; method from the source observable, remove the dots, and add commas to pass each operation to &lt;code&gt;pipe()&lt;/code&gt; as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfca27576349a3df0b49ea565c6c5ecedcbb750" translate="yes" xml:space="preserve">
          <source>To convert to piping:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872efabf30aebfd1cf21ad3261bb46155480316c" translate="yes" xml:space="preserve">
          <source>To ensure output array has always the same length, &lt;code&gt;combineLatest&lt;/code&gt; will actually wait for all input Observables to emit at least once, before it starts emitting results. This means if some Observable emits values before other Observables started emitting, all these values but the last will be lost. On the other hand, if some Observable does not emit a value but completes, resulting Observable will complete at the same moment without emitting anything, since it will be now impossible to include value from completed Observable in resulting array. Also, if some input Observable does not emit any value and never completes, &lt;code&gt;combineLatest&lt;/code&gt; will also never emit and never complete, since, again, it will wait for all streams to emit some value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6854bc239f83599f0dbf1696b87dcdccc866358" translate="yes" xml:space="preserve">
          <source>To explain how operators work, textual descriptions are often not enough. Many operators are related to time, they may for instance delay, sample, throttle, or debounce value emissions in different ways. Diagrams are often a better tool for that. &lt;em&gt;Marble Diagrams&lt;/em&gt; are visual representations of how operators work, and include the input Observable(s), the operator and its parameters, and the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbea4ee5eb72b192707a5e482a80eacd44437eb" translate="yes" xml:space="preserve">
          <source>To import only what you need using pipeable operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ef1a083aa723b0019576fb8cd584c58e10e8eb" translate="yes" xml:space="preserve">
          <source>To import the entire core set of functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b762531ed7b43d8cf53abaf2d5ce024fc5e21" translate="yes" xml:space="preserve">
          <source>To install this library via npm version 3, use the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75f247a51afe84f46d08cf6c7b1c9cab2802e4f" translate="yes" xml:space="preserve">
          <source>To invoke the Observable and see these values, we need to &lt;em&gt;subscribe&lt;/em&gt; to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e700a89c1c5b96268bd013ae75cf6f424ec6478" translate="yes" xml:space="preserve">
          <source>To make this code compile correctly in v6, change it as shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47acd7d06eae9e5d17c19d3d1f7737b81e97a5c0" translate="yes" xml:space="preserve">
          <source>To refactor TypeScript code so that it doesn't depend on rxjs-compat, you can use &lt;code&gt;rxjs-tslint&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2250d65b72501a49025ea5c144ae09244d675a8" translate="yes" xml:space="preserve">
          <source>To use with globally imported bundle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d831f2ee7b39a8530e9865325eec401ccc16eb" translate="yes" xml:space="preserve">
          <source>Transformation Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df871e95bce7fed9bec53d428cc693f19a66dd44" translate="yes" xml:space="preserve">
          <source>Turn entries of an object into a stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1ef9be41040e1923600ae1c206879cbf9dca0b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;'N' | 'E' | 'C'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213e01b9c200c49c18258b88d7791627878972f5" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;((...args: any[]) =&amp;gt; T)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18e8715422c933bc0d44e093bd5397ee12d9ddb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;((outerValue: T, innerValue: ObservedValueOf&lt;o&gt;, outerIndex: number, innerIndex: number) =&amp;gt; R) | number&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e11e7152d48b6998b2089f4994c57e8ddfe7c75" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;() =&amp;gt; Subject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f6e6d7dc3d706859efbb1c864cc3ab228ac985" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;() =&amp;gt; number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5290ffc017b6e8444f479961994c8f6fe12d27" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;() =&amp;gt; void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d71381cc2f6daafb554abc748bf41287747305" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...args: Array&lt;a&gt; any)&amp;gt;) =&amp;gt; any&lt;/a&gt;&lt;/code&gt;&lt;a&gt;.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715edcc74894965fa8641afbe57cf1694fab4960" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...args: ObservedValueOf&lt;o&gt;[]) =&amp;gt; R&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f445601ace639ff758e864f2be20cbb6e1711093" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...args: any[]) =&amp;gt; T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8d50e5704bc52d08c8515647e96f526e3ee486" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...values: Array&lt;any&gt;) =&amp;gt; R&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42d464ceeee1dbcc3ae26025a06734f1b1ab28d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...values: ObservedValueOf&lt;o&gt;[]) =&amp;gt; R&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115a45dfa4b84d67fe93a0f8e6293228496b47ec" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...values: T[]) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9584dfc4ab476a6e67d8445b84599ebf5a51c144" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(...values: any[]) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8423202bc5860b6167e16977df8751902c0aa15" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(O | ((...values: ObservedValueOf&lt;o&gt;[]) =&amp;gt; R) | SchedulerLike)[]&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bb16ee2bd3e740e0e24f30f4ab030e6051643a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(O | SchedulerLike)[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb60654060001b0bb4dc87dbfaf98d05d1882c2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(Observable&lt;t&gt; | Observable&lt;t&gt;[])[]&lt;/t&gt;&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548516799f03dc1507efde79c6b3f8df0d1df3df" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ObservableInput&lt;any&gt; | SchedulerLike | number)[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56817bcc8dc851988869c22a62165b95d7bf60bc" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ObservableInput&lt;any&gt; | SchedulerLike)[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b020a654e56cb552feac3ff729d8dbe04d4867" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ObservableInput&lt;any&gt; | number)[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f219c8370821ea4743e13cac66ea6852df5d4e10" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ObservableInput&lt;t&gt; | SchedulerLike | number)[]&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529dd9acf8fe6ebba7efb38512e1195b5b196eeb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ObservableInput&lt;t&gt; | number)[]&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131c1a849e0b99d99eb17650cfb2507581896034" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(ResultFunc&lt;s&gt;) | SchedulerLike&lt;/s&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf62e50855080f2a62d30c6fddcf53b42195c5b7" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(T | SchedulerLike)[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5750710a87b6422da1e2fe82f494a0977f8438ca" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(acc: R, value: T, index: number) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef126c50ea9b421522e1816478ff4ce72f3e898" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(acc: T, value: T, index: number) =&amp;gt; T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3842fcb335560ee907b2c71962c65c3c4353c924" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(actual: any, expected: any) =&amp;gt; boolean | void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1c404ee8f49db9dc12f78b2b0bb5815d8a3580" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890dc9b243d981dcbed78745948855150a3d5130" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c49fdc783ef2057c6a56998650eae9f9e168ee6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b31ef3d668d9852d0b45580a0cef5e1d54701d5" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6ad57245462f4910512ce820a350761ae5e086" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81ca0db127bcce9d74060dc88560183d45fb746" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbb369862c7a3384d2d5f4aaa5ccc91b726f74f" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9a8dad89be16a8ffcbb914861140148c326c37" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3060abdd5cfc402e9f261d806f9e12f2952757c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d12c53b1416c16e6a3e9e23fe56c11f9de76679" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babb427d420c07d7654be3965c1fc81b5062d499" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca63d0bf845b3c99a86723e1a00d24fd22ffc47" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a65eec0fc0fed81dd66324e345e8544af66feb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd59aa9684d1095cf12a12a7e413507db703ed1d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06dcbbf4fb75eac996564912121e8c4fb83d7c4" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c7d600f8db1e25aaf46cdb367ab54ea8609cab" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1877f225ee920f421ae27555595ed26820bdd26e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cdf4d5f809c57e005c834b5ca60b4682ec2d452" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b814913ad149f5e3f02e1878361d9e4965c6d96c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a11ca325fedfd4a0b09529fc5fb2fd54ac2eeb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc87711524924cad6badf7fb7637d64b7b12725" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5238a4026587f114d534ba0aea68f7339f448fcf" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f7dd1e5c06ea34463bc4df273684a9e7c075f2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c29c9e973bc4a98175ebb864db90273150a19dc" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6292c579e16d9f0ae7a87c8c96ebdbb6b06b1b85" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d5bc340fcf377c8299123549f5498a8129e2f1" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4150c4a475816525a9e46989424161ccc9d95c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d466eb5d4325de83cfb8d496ac9bbccf1d255514" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f6491203053e28b0deb3dd80105f7e6c00228c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d587fd207a32a3ea6c831c4fb47026cb73be2865" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c5bf9215e41847dfd7e7dd372a2b628a1a7828" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207b86c3edec163dd2ebea2510b4feee45a4291c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1062eaf8a1992aa57462b7faac45cafe4eac49" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b171b200ae223f8e4b468effa8bc47e5905e167" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e184db0b2a8e1915822f0260f485a047aa8e1664" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6aa60244b6bd28dfbdbb43e485192cdfb2e8307" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf6cca62521c6eadadd61afda9ebe1305ab17a9" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a102d013157c35e40f1c6404898bc2c214bc94e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b49e661ced440e9b0fb3cebfe3f9d9010ba7109" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3009025592971e5e05f1b144b51ce2ad79462a17" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07912677e224a7a7087ae2f9cda317ae377997a0" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8999ec7c3727303eefc2d8b4aa62e9174d8d283a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f06dac8f0c7aeff5c1887ed5d82398fe3ea9f14" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f26e50df1131de8c35fe5130a0f85bb75f65b6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cce96a7752667fc150c2f6ecaf82de6c11c8afe" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e616dfb256f8e97a3c01f09c9efc9c89927cf7d2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9073812b7d4c663e139c19b7f25ac7b33f52ae74" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4883c84be4ca02635c664c19997fadd5941bfcc3" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09550dd4715588f3cf78bf9d8485c6e77fc101e6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2e48a5e8e330e519788582b9de12aed78b3b7e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a723773c30ad1938783aac42e0256eacf5733b75" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: () =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f1e776d1c5a90316c6db61d499d46dcbf15d1c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (err: any) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb656091a6448a1704eab0d7644973b2c4778a8b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (err: any, res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaf7906a7fc5abf2fa018d0ca0a00c077f93662" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (err: any, res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28effb524d8b68469665b5dcfadbc248f8aebef" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (err: any, res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b4d1f911fb40f200ff9658b589275e4cc0d020" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421147492daff147ce6109a625adbcfccd28209f" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (res1: R1) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbd3ab927148fc4b8fbb12c5da01e693b909e89" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (res1: R1, res2: R2) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6ad034a15d610fa20d123f59b811736ff3768d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (res1: R1, res2: R2, res3: R3) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea32fd0fcaeb3897c825573c094a47144826c424" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) =&amp;gt; any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4da635267a67753642fcf2c11fc2a0f6165215e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(e: any) =&amp;gt; void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee859d563b554f151961e86b6de2a933b73ffe0d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(error: any) =&amp;gt; void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361338e1c9f2a087c349adec7676e0fb3214e956" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(grouped: GroupedObservable&lt;k&gt;) =&amp;gt; Observable&lt;/k&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe81a3f8204ab3631aa0fc9df6c247a3c659c341" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(helpers: RunHelpers) =&amp;gt; T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362c072735081af10972ee71ab32b4b3649d0af1" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22969b90655fe3e215442b8db1cd895a3d7189d5" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(outerValue: T, innerValue: ObservedValueOf&lt;o&gt;, outerIndex: number, innerIndex: number) =&amp;gt; R&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0b88e51d4d59e3983c7e7464dfad98738237f7" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(shared: Observable&lt;t&gt;) =&amp;gt; O&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb19c873d4430956f9fe77aabe64a3c12427b87c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(this: Observable&lt;t&gt;) =&amp;gt; Subject&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d0a746fcd8291758a16c52b800ac7f25d2bd49" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(this: SchedulerAction&lt;t&gt;, state?: T) =&amp;gt; void&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8758c43fb1b5afffec1c19ba62a3f934acbcc378" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;) =&amp;gt; R&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9aa370c014ca531d4c2703a7d061370a10b7e3" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;, v2: ObservedValueOf&lt;o2&gt;) =&amp;gt; R&lt;/o2&gt;&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cf094de4b037a7a6304aff3fc8ccab22b0f9f5" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;) =&amp;gt; R&lt;/o3&gt;&lt;/o2&gt;&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f1ca4be5d6d43276421fa223c5719c2d0289c2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;) =&amp;gt; R&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9153915af3b4c2bb22ead41d38fd3a1cb03742" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;, v5: ObservedValueOf&lt;o5&gt;) =&amp;gt; R&lt;/o5&gt;&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f689369a0e4ee46c3fe1c5a57b6b2b207c8adfe" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: ObservedValueOf&lt;o1&gt;, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;, v5: ObservedValueOf&lt;o5&gt;, v6: ObservedValueOf&lt;o6&gt;) =&amp;gt; R&lt;/o6&gt;&lt;/o5&gt;&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/o1&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5f7908493a4673aa270ee767ce4202f747ca3" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72daa40c8563ca1fac2587765db78b4c75229d9" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, ...values: Array&lt;tother&gt;) =&amp;gt; R&lt;/tother&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03c837391dff55fa7b401d633843f029c89672f" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: ObservedValueOf&lt;o2&gt;) =&amp;gt; R&lt;/o2&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da19fb0f7bb737688e13f3ffecd307b01241c2cf" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;) =&amp;gt; R&lt;/o3&gt;&lt;/o2&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf207057ae30c5c5a96bcfc7fbe705b19e43a9a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;) =&amp;gt; R&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507debb93d933f179b518594f161bcf841d3cbd1" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;, v5: ObservedValueOf&lt;o5&gt;) =&amp;gt; R&lt;/o5&gt;&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dceab0ce7d9e3b53b71639b601fd7db05279af46" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: ObservedValueOf&lt;o2&gt;, v3: ObservedValueOf&lt;o3&gt;, v4: ObservedValueOf&lt;o4&gt;, v5: ObservedValueOf&lt;o5&gt;, v6: ObservedValueOf&lt;o6&gt;) =&amp;gt; R&lt;/o6&gt;&lt;/o5&gt;&lt;/o4&gt;&lt;/o3&gt;&lt;/o2&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fb649063afbaf31b7be0d2406bd4c466e5486c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: T2) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5981afe7a927fe5642c27e1039b843c0715da52e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: T2, v3: T3) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bdb8f1c906b9f43b7bde3f11180203d266fa3d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: T2, v3: T3, v4: T4) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1811e9f6e78e0ae922fcb7901626fbd9a3ee0066" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: T2, v3: T3, v4: T4, v5: T5) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1043b6849aaa1b97864cf34d641e636407794d4" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80b2c916400b54d99f0b5a88799c40939296315" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T) =&amp;gt; K&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1851949fb40ca6d042e8ee55dd70a194cac2cd45" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T) =&amp;gt; R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1f060a82457fd8f532fc0b3a7aa20a4acb43e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T) =&amp;gt; void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7540a83e6226008f181b2f355dfdec104f34861" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number) =&amp;gt; O&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e032da5722b2ae71aa20268b66cbe9d743edbd4a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number) =&amp;gt; ObservableInput&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63d8b636b7631cf792437490e89009c81010751" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number) =&amp;gt; boolean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297bd6768908e50af6894d479dd84d6dd2c18e8d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number) =&amp;gt; value is S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20bd0442066caa591934b56bd765a167e9fb847" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number, source: Observable&lt;t&gt;) =&amp;gt; boolean&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8e6272035f2aed59d444198631eac2d9f0df87" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(value: T, index: number, source: Observable&lt;t&gt;) =&amp;gt; value is S&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa2c18caf1656b35a1cb5fac68b519a2bf20532" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(x: T) =&amp;gt; K&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4ac1d05ba7af7abd653bd6ea9186e99f1f11c6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3d86384fd965d55c60a8b8eb2da46a244c5c15" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0796fef095c8385063f00f221d734f07da80c6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;AjaxRequest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186300cb716262328ba542656827d616bf60ef27" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da1a7a40b78d18a2cb5e51e26becf7e59236621" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;o&gt;[]) =&amp;gt; R) | SchedulerLike&amp;gt;&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e22e02d711afb45c58bde774c18393bd44a7cfe" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;o&gt;[]) =&amp;gt; R)&amp;gt;&lt;/o&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e262ed05b24b1b3fe2e55fe9e403ec1010b3e96" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observable&gt; | Array&lt;observable&gt;&amp;gt;&amp;gt;&lt;/observable&gt;&lt;/observable&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d6a3e8fa760ea0e4051644d7acf005dd0a83ff" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observable&gt;&amp;gt;&lt;/observable&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99d5ec8523afaeb5d23bddde6af1b21f94d69ae" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | ((...values: Array&lt;any&gt;) =&amp;gt; R) | SchedulerLike&amp;gt;&lt;/any&gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a5f2076b884af775e3acc607128372db980542" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | ((...values: Array&lt;any&gt;) =&amp;gt; R)&amp;gt;&lt;/any&gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f61c74c4d2689b8b295b3bc3fad29f0a2829963" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | ((...values: Array&lt;t&gt;) =&amp;gt; R)&amp;gt;&lt;/t&gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ec48412c7172f223b0d57f53d2c4c2a7883c07" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | Array&lt;observableinput&gt;&amp;gt; | ((...values: Array&lt;any&gt;) =&amp;gt; R)&amp;gt;&lt;/any&gt;&lt;/observableinput&gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23e8045d06ac91209bb21c5d61c0e608551edab" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | Array&lt;observableinput&gt;&amp;gt;&amp;gt;&lt;/observableinput&gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f470438dec389126bb88d921d5bf03623a274d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | Function&amp;gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffd0a5fa452e71a657ba6abe14b4b5221c728d7" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | SchedulerLike | number&amp;gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022ded283b466f3e35bcbf8fb60d2a82a83b9cf8" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt; | SchedulerLike&amp;gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe608eb39372c0df5e34104b42032296c2e3e28" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;observableinput&gt;&amp;gt;&lt;/observableinput&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774ce7099ec6269870132dfc3f0f80d51aac65e6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Array&lt;unaryfunction&gt;&amp;gt;&lt;/unaryfunction&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf47f84a0002a623cacf5ed1fc7a34b3e58e9b1d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a726c313b2148736aea260576008e4ffe91a49" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754e84ae83a995dd143d04051e4ff24ccd568aff" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ConditionFunc&lt;/code&gt;&lt;s&gt;.&lt;/s&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551759f5b485dd7d536d56bd5bcf98a981053b24" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11dda241ed5a846e5a77b882e5af4f980e3e6b38" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;D[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732caacf3ac3c6023211e817e39d27c4a993336c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32240394db3b4d0050961619bf058229541e936a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda36058131be1fff0a3a659698941a6feebe065" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;EventListenerOptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f06fb1dabba3df50efde367ec9a487d5e0213de" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a609384ecc48abbd9d1800e801027e04c961d55" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;FromEventTarget&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ca1efa3b1e0700a30136e013bf2a513aa23cf3" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Function | SchedulerLike&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d06856689a83fed254e3ff1394cd796ce29573" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1333de17b8e4258e2494323a237a15a2bbd44a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;G&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4ab2c3d491f5d5505734f82a1d71cb7a12eb87" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d116a2901c6b033b239cf9447ef83f3443aa9b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6433f3f5af256c6f177a286d6b0b4c16f357c084" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;IterateFunc&lt;/code&gt;&lt;s&gt;.&lt;/s&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59d0082bcdca76fd5077eefbdeefba303facc12" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3065f7c9413938461de7ce736562288c5529566" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e5d87ae772fac236dab2816e93da98daca598d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a76d374b96bab9a021466acda1427f115f3d77a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6caa3694a3b283b811b2d4cce955bbb883c0d3a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c31d6aa3a6756db0691f1a06a24170cb79b2737" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca493e8558c03897a1e255c3d449c32c45baa92" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5ead58b00135cd678c72a1e4d6c2b9a4b1f9b4" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;MonoTypeOperatorFunction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d7822500f9958fb785fd08c3f12562aaefb756" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4f600f3db9766a38eab8b045334b7e0ffa0a35" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2db2f7f6163cbdc49f96709fb620e539fae838d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c8a70cd92ba9a10cb67e8a0fe6585eeaedd672" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07db633b749eaafe60fad50613fb361b5462128" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a0ad72e70248bb7727938c2d277e884a8fcb39" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4063bed8f10f1c01b326def0a45a7ec886db38fa" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac7f2d90440b966aede73c79bd872b289c85232" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;O[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126f4352b7d82c982411ab307d90a1a2fd164026" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ab5434acf3147c678d6f41da19986136d7f849" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d16ce002fabcb4debea0fc3cd5a200ed96e083" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc81c408d84707f2e1231e92845315e91d9081d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00609df3b8dc752961af4f2720b7f87c48a2150d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;/code&gt;&lt;a&gt;.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f271a73e18fd54341ed425443168734039693952" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;/code&gt;&lt;b&gt;.&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5816b492c0a2c54204a7feec8d320c3fdb8881b2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;any&gt;[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898d367af02d5b612d4722726575a6bd0a159dfb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;t&gt;[]&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1497a14567e54d052969c98590e198f74be40029" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ObservableInput&lt;tother&gt;[]&lt;/tother&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22ae435fb7a75dc21020275a5c8ff2e1988e30b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Observer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a19c623678c2588a24a3989ca61fc01d213c2b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Operator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5d3964673acc77cd83d10aa73cf2be26fdffc" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;OperatorFunction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a0dac7d47b3353631c6b67099256dbb6d40d23" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;OperatorFunction&lt;any&gt;[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d45e5cbf630365825d41d1ce644739ab5eb06" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;PartialObserver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1913d5f668336716bbcac7fa488c69b4f4f4b8" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;PromiseConstructorLike&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609d95b5ef57f3e76a8fc256ebec7e22330f9c59" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4ffe87c6666e2707ed5ee385ae4da8d1ffead4" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;RefCountSubscription&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41072159a1296bd52593415f6d78fdac321ee8fb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;S | GenerateOptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147a0c3f26bc3a4b7e779d142c78c4dbfed99db8" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc700f551ded815b51800d7128a77d9bbb8ea31" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;SchedulerLike | OperatorFunction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b0b618075021ab78c9fd79615f7608ce3a1059" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;SchedulerLike&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db71b762202b66504bdc3eeaf731ccc677a6f43e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;ShareReplayConfig | number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c0081b8397ad79afa7c3dd38c51924974e65a4" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdfff315ae7cbd7062263471109107a3b23665e2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;SubscribableOrPromise&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a36a93a3001e89d474ea41ed060c5be9c531fb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Subscriber&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd83b90c41209cf719c36bf6e73e434163689a4b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;SubscriptionLog[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d584da4705bb1e2e02de5d937622f5391802ec" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76663aea7dcdd1108151b349e005693fdd1ef0e" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9131d7d10125a1ba344829c6571ab5bba447f176" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeebceadaaae61e2f73fdb354cc29f939502c949" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e973f71ff439805103e4bccc82b2612785b619" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47e2d9ffd39b79dae86752a0d372040ff59c608" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb51c9257cd241185060f084fe42795e2a0062a8" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e21583d61b6b3c5b7aa80787145adc47cad928" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T9&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1772f5e9d7faa0eacaf5fbd97c549c304182e2e0" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb86c213fc61cefb101404aa56052371dff317f0" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;T[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e68cd7cd7331e7f9c8a294da91c1fe69127701" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;UnaryFunction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704c31fc48b6ff2e464c82b6d94701b5b70c443a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;UnaryFunction&lt;any&gt;[]&lt;/any&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721d02167072c753b2a3df347191b66f3d60d5e9" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d64923b3e10bdb4a4381570615d28ab8ba14ad" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;Z[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c2b5f345726bdbc85567e2565474899977f0ae" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1, O2, O3, O4, O5, O6]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b87eb4222c20654a927e0d00243b9f859c2b5e2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1, O2, O3, O4, O5]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58e2919b00a8cef5566c5f27b38ce4880bc7082" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1, O2, O3, O4]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9880bb20fd0ee5b872900f9c9f7326f5cf763b9b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1, O2, O3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5355414d14f60803572610ed6934ef80247859" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1, O2]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1a1d772b19e4d3c988c32da96d158964d2a05b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[O1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bab2335ad2f8c5c42fdf1db73e4a02942d265a" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;, ObservableInput&lt;b&gt;, ObservableInput&lt;c&gt;, ObservableInput&lt;d&gt;, ObservableInput&lt;e&gt;, ObservableInput&lt;f&gt;]&lt;/f&gt;&lt;/e&gt;&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&lt;/code&gt;&lt;a&gt;&lt;b&gt;.&lt;/b&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222be3ba9f18e45403a6e6223f5b2e77d44e5fea" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;, ObservableInput&lt;b&gt;, ObservableInput&lt;c&gt;, ObservableInput&lt;d&gt;, ObservableInput&lt;e&gt;]&lt;/e&gt;&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&lt;/code&gt;&lt;a&gt;&lt;b&gt;.&lt;/b&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93a82a2b5de5ebd61a2addbc3dd9d7e797c2adf" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;, ObservableInput&lt;b&gt;, ObservableInput&lt;c&gt;, ObservableInput&lt;d&gt;]&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&lt;/code&gt;&lt;a&gt;&lt;b&gt;.&lt;/b&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89879f1fa7124bb8a17ea95dcd9fd6dcb38e14b7" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;, ObservableInput&lt;b&gt;, ObservableInput&lt;c&gt;]&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&lt;/code&gt;&lt;a&gt;&lt;b&gt;.&lt;/b&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c4af8dd40e4a6690f14bd13d845c1ffa03ece1" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;, ObservableInput&lt;b&gt;]&lt;/b&gt;&lt;/a&gt;&lt;/code&gt;&lt;a&gt;&lt;b&gt;.&lt;/b&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f7f339496c375791d2ff5b7294522eae4149cf" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;[ObservableInput&lt;a&gt;]&lt;/a&gt;&lt;/code&gt;&lt;a&gt;.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236b2fae7a464d4959da1cc706c7525c357f8df2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233da83cf5dbe0e4dbb4a4c8279131fd77d0b9c2" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416567cc0a04b62b8fa1e200a25508c666e19b7d" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ccb89b23071925e7bebe704236251a31f49a71" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;null | undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffac20a2aa487965e7281d59251d2ab396509b01" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829fa850cc0b22a21c2a5c90d8c5dc5009d34d17" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;number | null | undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dde804ab75466ad80ea667ad2c89afdf6926ab6" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96285554977b0ec8c2a3b9c0537bbb374af86597" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;string | WebSocketSubjectConfig&lt;t&gt; | Observable&lt;/t&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5379dd26062f539531699754e083561fb51162" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318e715dbf2391e1da4ed74291fe9cb0da1e8a60" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;string[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561b4d3677c583b11d84a2e3f730354491d41ceb" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;typeof Action&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb921f63b092f102d58146e7169110799c81084" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;typeof AsyncAction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ca2cb8379aacf73ed52f86049f1eb082b698b" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;typeof Promise&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802851a0bdff5b2290947dd51d4f2bf99652cd4c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c9693d96f0e3e8d7c78d5d839ac05bbc71de2c" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375b902f5d6e9e9a6e8f37596e91be38abaa4c16" translate="yes" xml:space="preserve">
          <source>Type: &lt;code&gt;{
}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccd1de192a933a28d87979fdd3ac960f4e4724e" translate="yes" xml:space="preserve">
          <source>TypeScript &amp;lt; 2.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944b1f907cf5180f62a994f006361602f71b8277" translate="yes" xml:space="preserve">
          <source>TypeScript prototype operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b40c6881264d83b31646c44b61e9a1341bea63c" translate="yes" xml:space="preserve">
          <source>Typically, each test case in Jasmine is written as &lt;code&gt;it('should do something', function () { /* ... */ })&lt;/code&gt;. To mark a test case for PNG diagram generation, you must use the &lt;code&gt;asDiagram(label)&lt;/code&gt; function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608980408bb863782ac4aed671479da80121853a" translate="yes" xml:space="preserve">
          <source>UMD module name change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb55d82fe2e37aa0735d3aed1b75154358abceed" translate="yes" xml:space="preserve">
          <source>UnaryFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcea43f318be996276929510e43d8fcf5155c3bf" translate="yes" xml:space="preserve">
          <source>Under the hood, this is how the &lt;code&gt;multicast&lt;/code&gt; operator works: Observers subscribe to an underlying Subject, and the Subject subscribes to the source Observable. The following example is similar to the previous example which used &lt;code&gt;observable.subscribe(subject)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1be69a29568d0c68573d9b8a3d377b69fca8f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt;, it does not do any flattening and emits each argument in whole as a separate &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0dc8dcca3a93bc24a8ae6bf595b234b8bf270e9" translate="yes" xml:space="preserve">
          <source>Unsubscribable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dda394551611fd3edbee64fe05d66882f5bdd5" translate="yes" xml:space="preserve">
          <source>Unsubscribable.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b223a27ff25de50c11e736b98087856629b1ee8" translate="yes" xml:space="preserve">
          <source>UnsubscriptionError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb3b8dabbb4b54549efa9390b991b4a6e74f466" translate="yes" xml:space="preserve">
          <source>Unused operators that are being imported in apps cannot be detected reliably by any sort of build tool or lint rule. That means that you might import &lt;code&gt;scan&lt;/code&gt;, but stop using it, and it's still being added to your output bundle. With pipeable operators, if you're not using it, a lint rule can pick it up for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48de142b80593ae36789af5ae3185c245d7de92b" translate="yes" xml:space="preserve">
          <source>Unwraps &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects as actual &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; emissions. The opposite of &lt;a href=&quot;materialize&quot;&gt;&lt;code&gt;materialize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b97e9150ec08ec90f9acb2ce3d1683675ab251" translate="yes" xml:space="preserve">
          <source>Update to the latest version of RxJS 5.5 and ensure that you've fixed any issues caused by bug fixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56c3aec3b7b9be1c4f46e4e3a2171bda6b7e49f" translate="yes" xml:space="preserve">
          <source>Use Date to check if Observable completed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e96cf0562f5316bf991d232be9abbb3a0972e" translate="yes" xml:space="preserve">
          <source>Use a comparer function to get the maximal item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0941c6ab701a988e75a3b42244a108ccc55b7b1e" translate="yes" xml:space="preserve">
          <source>Use a comparer function to get the minimal item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adf588c366bb81ab24a6d9d84769d5a7d84ecf5" translate="yes" xml:space="preserve">
          <source>Use addEventListener with capture option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d64b3c47e2e663d8d15ac09b131241fcc383fc8" translate="yes" xml:space="preserve">
          <source>Use async scheduler to delay task</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74a60be7e9df79323b8bf70d19525f915e66ea4" translate="yes" xml:space="preserve">
          <source>Use async scheduler to repeat task in intervals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d8d88c8a484430dfa89edfd19f3b8a829f00c8" translate="yes" xml:space="preserve">
          <source>Use bindCallback on an object method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a587ab3db170f1143340d27d2d00f563c6af5c" translate="yes" xml:space="preserve">
          <source>Use default emission values when you can. Specify &lt;code&gt;values&lt;/code&gt; when you have to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a5270910265cf079b5a95c169c8229434e4280" translate="yes" xml:space="preserve">
          <source>Use forkJoin with a dictionary of observable inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97454377d529afdf254d63b94d6ae4d79c618614" translate="yes" xml:space="preserve">
          <source>Use forkJoin with an array of observable inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a81b87605dbb1a7b77568988fdb261cbe8dc087" translate="yes" xml:space="preserve">
          <source>Use it instead of nexting values in a for loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9743d4b304ad998820f20fa0064538f1b7c5a724" translate="yes" xml:space="preserve">
          <source>Use it when you catch yourself cleaning up after an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75433d0586a4591c287bac433c8e311521ce9f6" translate="yes" xml:space="preserve">
          <source>Use it when you have all these Observables, but still nothing is happening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa03d305a5460de185ee146ca97f3cfa13dadbd" translate="yes" xml:space="preserve">
          <source>Use on function calling callback in regular style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06623d950d89c86c8ed9f8bc96678a472e2a5fa7" translate="yes" xml:space="preserve">
          <source>Use on function calling callback with multiple arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7d56f509de61ed81dede7cd24d145bab36ec1e" translate="yes" xml:space="preserve">
          <source>Use options object without condition function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f94be00122613e4f3bdd867dacc3ed3bbddc370" translate="yes" xml:space="preserve">
          <source>Use project function to dynamically calculate the Body-Mass Index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39fa8518afb57e3bb5df6b079967f1f52d84314" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;pipe()&lt;/code&gt; function to make new operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ca036e2880be81fe3dfc1af381fa49c6f85cd4" translate="yes" xml:space="preserve">
          <source>Use the same hash to look up all values, this ensures that multiple uses of the same character have the same value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e45a45f387a769b5f7b152331ba5cd89d61d83" translate="yes" xml:space="preserve">
          <source>Use this operator in conjunction with &lt;a href=&quot;materialize&quot;&gt;&lt;code&gt;materialize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d47378aaf591a81e92223fe93c028e54f1490e" translate="yes" xml:space="preserve">
          <source>Use with API that returns cancellation token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1159aff12327dacc90d0f8c9e3af7649cd6e7ed" translate="yes" xml:space="preserve">
          <source>Use with condition and iterate functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd25d8dc10cb0dc785ed30971b7124f681d6d432" translate="yes" xml:space="preserve">
          <source>Use with condition, iterate and resultSelector functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16cdcf778bedaaa4499a11207e74e9af5f8ec4f8" translate="yes" xml:space="preserve">
          <source>Use with options object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e3d9778ce27eb3a7a391bcfb4958e002b5d687" translate="yes" xml:space="preserve">
          <source>Use with project function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83e5709178481f4f9d49bcb13ee0fd18b72dc28" translate="yes" xml:space="preserve">
          <source>Used to stitch together functional operators into a chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510dbef7a450b204144f38c1e44d2f2bd81dcf7e" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;the Fetch API&lt;/a&gt; to make an HTTP request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d48997132a4276632c12c350d421ecfed171bc" translate="yes" xml:space="preserve">
          <source>Using RxJS you create an observable instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31cb59637a1ddfe31c85b864bc1ec6b859826e8" translate="yes" xml:space="preserve">
          <source>Using RxJS you isolate the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09635283d6617f91ae3f074496d5e16cd86942ea" translate="yes" xml:space="preserve">
          <source>Using Schedulers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecd9934a8ea821894b0297d40eac0da3aaae0d3" translate="yes" xml:space="preserve">
          <source>Using ajax() to fetch the response object that is being returned from API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b3a5925e14348119350ba761fe14a00b104cda" translate="yes" xml:space="preserve">
          <source>Using ajax() to fetch. An error object that is being returned from the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2896898b4b5e192a5ce3cdbc158beea89dd1339" translate="yes" xml:space="preserve">
          <source>Using ajax() with object as argument and method POST with a two seconds delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfc2baafe693974712a6cc4aaf2dd3d298d7bc0" translate="yes" xml:space="preserve">
          <source>Using ajax.getJSON() to fetch data from API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c0892ac58319271a442aeffe6269e018719e3b" translate="yes" xml:space="preserve">
          <source>UsingObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe106a343476b132e8645607f1656889a1e921e3" translate="yes" xml:space="preserve">
          <source>Utility Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da7f673f7e69ae924fe907748d6f3cb5df6743e" translate="yes" xml:space="preserve">
          <source>Values to use for the letters in &lt;code&gt;marbles&lt;/code&gt;. If ommitted, the letters themselves are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b7bff9276756a788ccec17703060b77e201e22" translate="yes" xml:space="preserve">
          <source>View on Stackblitz</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034fe9d0b5c12bc4be722f6c506e251b9291f0ed" translate="yes" xml:space="preserve">
          <source>VirtualTimeScheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a5d2379330ae26984e929504e68314dec62dd1" translate="yes" xml:space="preserve">
          <source>VirtualTimeScheduler.flush()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b53656f2a7609d3c1cefcb7a7eebf56e2aa5323" translate="yes" xml:space="preserve">
          <source>Wait for Observables to complete and then combine last values they emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66127b0c09f4354615721c912264cbc5a47740c4" translate="yes" xml:space="preserve">
          <source>We can test our &lt;em&gt;asynchronous&lt;/em&gt; RxJS code &lt;em&gt;synchronously&lt;/em&gt; and deterministically by virtualizing time using the TestScheduler. ASCII &lt;strong&gt;marble diagrams&lt;/strong&gt; provide a visual way for us to represent the behavior of an Observable. We can use them to assert that a particular Observable behaves as expected, as well as to create &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;hot and cold Observables&lt;/a&gt; we can use as mocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2ca8f242ba7d7fe34a8c90aa1e0d56436c6563" translate="yes" xml:space="preserve">
          <source>We expect to see as output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b046d406d3081f74ca378cfc005893dfb7bca0" translate="yes" xml:space="preserve">
          <source>WebSocketCtor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628e9509fda98270e3455d22d600cedd1afffd9d" translate="yes" xml:space="preserve">
          <source>WebSocketSubject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0720fde99e4d6d81af0e858588dedfede21002fa" translate="yes" xml:space="preserve">
          <source>WebSocketSubject._subscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b88b9b5d4cc848b8acee01a6edbaab965a65c32" translate="yes" xml:space="preserve">
          <source>WebSocketSubject.lift()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad6c565dadb54f1ceba1453bdd6f0b33124be29" translate="yes" xml:space="preserve">
          <source>WebSocketSubject.multiplex()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b51b652f00c2988c76245827f4e44328bf9bcb" translate="yes" xml:space="preserve">
          <source>WebSocketSubject.unsubscribe()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbee7f5d17ef3a51038abca6a254f0545524917" translate="yes" xml:space="preserve">
          <source>WebSocketSubjectConfig</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b226d228170522ef73939374e23c07dca4c9c9" translate="yes" xml:space="preserve">
          <source>WebSocketSubjectConfig is a plain Object that allows us to make our webSocket configurable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720aecd142e5a04c28c6effc630df66378673063" translate="yes" xml:space="preserve">
          <source>What are operators?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5bd76136b6eb50e95aece3019303bd871b876d" translate="yes" xml:space="preserve">
          <source>What is a pipeable operator? Simply put, a function that can be used with the current &lt;code&gt;let&lt;/code&gt; operator. It used to be the origin of the name (&quot;lettable&quot;), but that was confusing so we now call them &quot;pipeable&quot; because they're intended to be used with the &lt;code&gt;pipe&lt;/code&gt; utility. A pipeable operator is basically any function that returns a function with the signature: &lt;code&gt;&amp;lt;T, R&amp;gt;(source: Observable&amp;lt;T&amp;gt;) =&amp;gt; Observable&amp;lt;R&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac356ffbdeb3a4607ae1603392cdf68edc86a39d" translate="yes" xml:space="preserve">
          <source>What is the difference between an Observable and a function? &lt;strong&gt;Observables can &quot;return&quot; multiple values over time&lt;/strong&gt;, something which functions cannot. You can't do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fdc8fc662e83956af76008d688d0dbd6e09d62" translate="yes" xml:space="preserve">
          <source>What makes RxJS powerful is its ability to produce values using pure functions. That means your code is less prone to errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be65b9e347375f6ab4dbf58f66fa0a0b73735783" translate="yes" xml:space="preserve">
          <source>What?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be56b67b42993d7ba451bc20857d796aa87097dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;WebSocketSubject&lt;/code&gt; is subscribed, it attempts to make a socket connection, unless there is one made already. This means that many subscribers will always listen on the same socket, thus saving resources. If however, two instances are made of &lt;code&gt;WebSocketSubject&lt;/code&gt;, even if these two were provided with the same url, they will attempt to make separate connections. When consumer of a &lt;code&gt;WebSocketSubject&lt;/code&gt; unsubscribes, socket connection is closed, only if there are no more subscribers still listening. If after some time a consumer starts subscribing again, connection is reestablished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a1a22df3e5800c9dec046adcefa7afdda31539" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;animationFrame&lt;/code&gt; scheduler is used with delay, it will fall back to &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6532e1d9c990b72d858ebf5186ddba72134e8839" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;observable.subscribe&lt;/code&gt; is called, the Observer gets attached to the newly created Observable execution. This call also returns an object, the &lt;code&gt;Subscription&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80e0bff51580c2b56076b5d173917b10aaae05a" translate="yes" xml:space="preserve">
          <source>When Observable returned by &lt;code&gt;using&lt;/code&gt; is subscribed, Observable returned from the second function will be subscribed as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself, the &lt;code&gt;unsubscribe&lt;/code&gt; method on resource object will be called. This can be used to do any necessary clean up, which otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone cancels subscription to an Observable via &lt;code&gt;unsubscribe&lt;/code&gt;, so &lt;code&gt;using&lt;/code&gt; can be used as a hook, allowing you to make sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1a377aa3e1d036262bb508a1780ffa6e071566" translate="yes" xml:space="preserve">
          <source>When a parent subscription is unsubscribed, any child subscriptions that were added to it are also unsubscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6eb75a66dbd2ec6c6b8e2424fd11ec96a29694" translate="yes" xml:space="preserve">
          <source>When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one that was passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9c1019d04a3ca50d8efff0548142e338842b80" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;ReplaySubject&lt;/code&gt;, you can specify how many values to replay:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44603e7ed5fa39806bd180d35b3264c9200fcad7" translate="yes" xml:space="preserve">
          <source>When executed, we see in the console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bde86dcfdbfcdd17f6dd590452a6c041f8c2e63" translate="yes" xml:space="preserve">
          <source>When importing from a manifest (or re-export) file, an application bundle can sometimes grow. Pipeable operators can now be imported from &lt;code&gt;rxjs/operators&lt;/code&gt;, but doing so without changing your build process will often result in a larger application bundle. This is because by default &lt;code&gt;rxjs/operators&lt;/code&gt; will resolve to the CommonJS output of rxjs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2907d017d4f383a85c8521c2f0cad224359b9697" translate="yes" xml:space="preserve">
          <source>When it sees a source value, it ignores that plus the next ones for &lt;code&gt;duration&lt;/code&gt; milliseconds, and then it emits the most recent value from the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7423f7722e2a5a68bfcb2036afff6f8485cd16b" translate="yes" xml:space="preserve">
          <source>When it's not the first character of the diagram it must be padded a space before/after to disambiguate it from a series of marbles. e.g. &lt;code&gt;a 1ms b&lt;/code&gt; needs the spaces because &lt;code&gt;a1msb&lt;/code&gt; will be interpreted as &lt;code&gt;['a', '1', 'm', 's', 'b']&lt;/code&gt; where each of these characters is a value that will be next()'d as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27dc579d7324ed932aa3947f9cf9d1be2fe9d555" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt; the value that caused &lt;code&gt;predicate&lt;/code&gt; to return &lt;code&gt;false&lt;/code&gt; will also be emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7983dcec577e1baa35257f29356d0c3f81d15f" translate="yes" xml:space="preserve">
          <source>When that method for adding event handler was something &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; was not prepared for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24be15cd0cb13e5d9fe6e6035ade97a9d2db7409" translate="yes" xml:space="preserve">
          <source>When the Observable emits an item, a key is computed for this item with the keySelector function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75108cc44e767ea6ded5754e2dc47169471f0514" translate="yes" xml:space="preserve">
          <source>When the code inside this callback is being executed, any operator that uses timers/AsyncScheduler (like delay, debounceTime, etc) will **automatically** use the TestScheduler instead, so that we have &quot;virtual time&quot;. You do not need to pass the TestScheduler to them, like in the past.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842a30b04dd4c4b8bf036128eaad9ba7d62fb5c0" translate="yes" xml:space="preserve">
          <source>When the returned observable emits, it emits all of the latest values by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f978e5cf289a92dd3f412998694b49b0deb511" translate="yes" xml:space="preserve">
          <source>When used without delay, it schedules given task synchronously - executes it right when it is scheduled. However when called recursively, that is when inside the scheduled task, another task is scheduled with queue scheduler, instead of executing immediately as well, that task will be put on a queue and wait for current one to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f8b8e187cb508f7e3004410295b59ebff84029" translate="yes" xml:space="preserve">
          <source>When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call &lt;code&gt;unsubscribe()&lt;/code&gt; to cancel the execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ad681af32e9f3b8eb172262895ed29a1b760df" translate="yes" xml:space="preserve">
          <source>Whenever any input Observable emits a value, it computes a formula using the latest values from all the inputs, then emits the output of that formula.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ddb61d420b9c8888737f9ec4f437115a5bae65" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;notifier&lt;/code&gt; Observable emits a value or completes, &lt;code&gt;sample&lt;/code&gt; looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling. The &lt;code&gt;notifier&lt;/code&gt; is subscribed to as soon as the output Observable is subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1aca4fa7b3a1e8c4186cf34fe3df8be417040ea" translate="yes" xml:space="preserve">
          <source>Whenever the source Observable emits a value, it computes a formula using that value plus the latest values from other input Observables, then emits the output of that formula.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0848b754969c9eb8beee3c221d27a22f55f1545" translate="yes" xml:space="preserve">
          <source>Which executes as such on the console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d31fa77b3c3bc3b3bdf57d3506566e5183c194" translate="yes" xml:space="preserve">
          <source>Which executes with the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dba49a6b58390c5cb8485ef8d6b878539f035bc" translate="yes" xml:space="preserve">
          <source>Which proves the subscription of &lt;code&gt;foo&lt;/code&gt; was entirely synchronous, just like a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05681bc2b543fe03c41fad83d8f9efcaf1b262a3" translate="yes" xml:space="preserve">
          <source>Whichever style of calling &lt;code&gt;subscribe&lt;/code&gt; you use, in both cases it returns a Subscription object. This object allows you to call &lt;code&gt;unsubscribe&lt;/code&gt; on it, which in turn will stop the work that an Observable does and will clean up all resources that an Observable used. Note that cancelling a subscription will not call &lt;code&gt;complete&lt;/code&gt; callback provided to &lt;code&gt;subscribe&lt;/code&gt; function, which is reserved for a regular completion signal that comes from an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b512e614de49fbdf054152663e5c843a54b3064e" translate="yes" xml:space="preserve">
          <source>While at this time usage of the TestScheduler outside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; has not been officially deprecated, it is discouraged because it is likely to cause confusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe37200f458db9e3405cf5077dfb9ee9da61a3ea" translate="yes" xml:space="preserve">
          <source>Will automatically set up an internal &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AbortController&quot;&gt;AbortController&lt;/a&gt; in order to teardown the internal &lt;code&gt;fetch&lt;/code&gt; when the subscription tears down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36367eb3345d52bc4911693bd8c260ec23c698eb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;subscribeOn&lt;/code&gt; you can decide what type of scheduler a specific Observable will be using when it is subscribed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3829985354965f33dd9558b555acdc428dfcd50b" translate="yes" xml:space="preserve">
          <source>With RxJS:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cd2ec555fa44ad16780ee0286035ea081dc773" translate="yes" xml:space="preserve">
          <source>With async scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6b3f0ec4ad5ac95e95493352b3e15afb0db9f7" translate="yes" xml:space="preserve">
          <source>With output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1e7407330e0e9c590d9edfed48b01cf85e06d2" translate="yes" xml:space="preserve">
          <source>With synchronous output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5278c2fe6de96fbc50b77c245b8cf7896d323093" translate="yes" xml:space="preserve">
          <source>With the approach above, we essentially just converted a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects are the only way of making any Observable execution be shared to multiple Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4756a8be31dec315ef4085ee3fa27bbc27de57" translate="yes" xml:space="preserve">
          <source>Without delay, &lt;code&gt;animationFrame&lt;/code&gt; scheduler can be used to create smooth browser animations. It makes sure scheduled task will happen just before next browser content repaint, thus performing animations as efficiently as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eb78fb5522f3dd74590487dc2e9be59b59b61b" translate="yes" xml:space="preserve">
          <source>Wrapper around the w3c-compatible WebSocket object provided by the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfe137ad404dc4094734aeee45bef858d84d61b" translate="yes" xml:space="preserve">
          <source>Wraps &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; emissions in &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects, emitted as &lt;code&gt;next&lt;/code&gt; on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69df896b034e4287dd27d4475e66711e367df15e" translate="yes" xml:space="preserve">
          <source>Writing Marble Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a30a0606a5445087bf0d5d1104ced79f667447" translate="yes" xml:space="preserve">
          <source>You can also specify a &lt;em&gt;window time&lt;/em&gt; in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of &lt;code&gt;100&lt;/code&gt;, but a window time parameter of just &lt;code&gt;500&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb8378082add3771b4115129f2a658cd97781e8" translate="yes" xml:space="preserve">
          <source>You can transform the values passed through your observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d06d498cb9b65990a214843328303f80403dc44" translate="yes" xml:space="preserve">
          <source>You can write the same behavior above, but with Observables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd4ecf9f486f5022bd9649cc3cbfc29b6f5cbc0" translate="yes" xml:space="preserve">
          <source>You can't directly test RxJS code that consumes Promises or uses any of the other schedulers (e.g. AsapScheduler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776953f398d370b37132c2e4494b310869dd154d" translate="yes" xml:space="preserve">
          <source>You may have already used schedulers in your RxJS code without explicitly stating the type of schedulers to be used. This is because all Observable operators that deal with concurrency have optional schedulers. If you do not provide the scheduler, RxJS will pick a default scheduler by using the principle of least concurrency. This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen. For example, for operators returning an observable with a finite and small number of messages, RxJS uses no Scheduler, i.e. &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. For operators returning a potentially large or infinite number of messages, &lt;code&gt;queue&lt;/code&gt; Scheduler is used. For operators which use timers, &lt;code&gt;async&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa13b25ca9429f98d8a2610041e18213004177e7" translate="yes" xml:space="preserve">
          <source>You must explicitly flush the scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c89342b75e2650d07fa178fd0cccf8a6a3d4eb" translate="yes" xml:space="preserve">
          <source>You pull in any operator you need from one spot, under &lt;code&gt;'rxjs/operators'&lt;/code&gt; (&lt;strong&gt;plural!&lt;/strong&gt;). It's also recommended to pull in the Observable creation methods you need directly as shown below with &lt;code&gt;range&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8d3a8b3190ce3bbc5edb1fc9bd8ea6f34bf5b0" translate="yes" xml:space="preserve">
          <source>You will see the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6f46b85fe7cf60fe42637bfb5a9edf71c06be5" translate="yes" xml:space="preserve">
          <source>You, in fact, could &lt;em&gt;always&lt;/em&gt; do this with &lt;code&gt;let&lt;/code&gt;... but building your own operator is now as simple as writing a function. Notice, that you can compose your custom operator in with other rxjs operators seamlessly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e80d5bfae24861611db7385f7013928e5d6e0d" translate="yes" xml:space="preserve">
          <source>_connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f866c13fe92f33a1055491bd563b0ecc6c9c93b" translate="yes" xml:space="preserve">
          <source>_isScalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cea44b653f4d57a6f636a53dfbbe8e70ab7019f" translate="yes" xml:space="preserve">
          <source>_output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f0ce0e9d0dcf1b8c81eb8fe523abdeab0ff479" translate="yes" xml:space="preserve">
          <source>_refCount</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3f6f640b6a47034faf251068bc033692680736" translate="yes" xml:space="preserve">
          <source>_subject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fab5fa97ae3521ef5fab878ac897c1c9dd10da9" translate="yes" xml:space="preserve">
          <source>_value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ecfdc60513c50b42578b17668c0160509ae156" translate="yes" xml:space="preserve">
          <source>a configuration object to define &lt;code&gt;leading&lt;/code&gt; and &lt;code&gt;trailing&lt;/code&gt; behavior. Defaults to &lt;code&gt;{ leading: true, trailing: false }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a8069528079297eabb97925b30b7534cc2cdf0" translate="yes" xml:space="preserve">
          <source>a constructor function used to instantiate the Promise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef061e6a9fbda8f2c67e76226baf2da15ddbaf1" translate="yes" xml:space="preserve">
          <source>a function that takes as arguments &lt;code&gt;err&lt;/code&gt;, which is the error, and &lt;code&gt;caught&lt;/code&gt;, which is the source observable, in case you'd like to &quot;retry&quot; that observable by returning it again. Whatever observable is returned by the &lt;code&gt;selector&lt;/code&gt; will be used to continue the observable chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc8704b1d05f45cd4ba57c9f57cf17125534f43" translate="yes" xml:space="preserve">
          <source>a handler for each value emitted by the observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae2b5e3f9d5e45de91d7387d4720b58811cc835" translate="yes" xml:space="preserve">
          <source>accumulator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b9ad2839b9b094a3db44c766d4997dfd193f2a" translate="yes" xml:space="preserve">
          <source>actualSubscriptionLogs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfa080e1811dfc82c65b261c496b09a633792e6" translate="yes" xml:space="preserve">
          <source>addHandler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4482611cc290c2ce1399431891dcb9221c95f994" translate="yes" xml:space="preserve">
          <source>ajax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62c7da3e0daced7d0999312a0195b9f13c91c22" translate="yes" xml:space="preserve">
          <source>always represents the &quot;zero frame&quot;. A &quot;frame&quot; is somewhat analogous to a virtual millisecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89f5c7f9475e43680cdc1c440396e4ff39e30c1" translate="yes" xml:space="preserve">
          <source>animationFrame</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3030e728f154bf51419109efb93b6b8aeec9a976" translate="yes" xml:space="preserve">
          <source>args</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261e4be27e3c714008c2ea33cd6a7cd65e312c66" translate="yes" xml:space="preserve">
          <source>asap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29d717bfdf0ded65af10aea36f99d22ea1f80b3" translate="yes" xml:space="preserve">
          <source>assertDeepEqual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e04b33fdd186ab6bd2deace04ea6b551b9bd4a" translate="yes" xml:space="preserve">
          <source>async</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7876153ada8274a24c48647e87674701755f9d09" translate="yes" xml:space="preserve">
          <source>audit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361d69fdf047121a3aa5cc25bdb099565a189be" translate="yes" xml:space="preserve">
          <source>audit()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9b91978f5f518d48d66a8cc96735d733d61828" translate="yes" xml:space="preserve">
          <source>auditTime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bc44ef2ea8297ac57c2703766deef4d4ac21b2" translate="yes" xml:space="preserve">
          <source>auditTime()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce406bbd7e1522b099ba4ce1172223002344be5" translate="yes" xml:space="preserve">
          <source>binaryType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40ddc3143db2be3a2ed8b654b9458485718946b" translate="yes" xml:space="preserve">
          <source>bindCallback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0262e453184f3ce37094c9ff37d7f99450a3894" translate="yes" xml:space="preserve">
          <source>bindCallback()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478b36b7448c5ea972d2e2a329da66cd2ae12ca7" translate="yes" xml:space="preserve">
          <source>bindNodeCallback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d2eeff6ef22fb8232334138efe3ac3d6e6ba91" translate="yes" xml:space="preserve">
          <source>bindNodeCallback()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53c2ea1fe4bd2b78bf4723c7c155a578e020a25" translate="yes" xml:space="preserve">
          <source>buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ffee333f7f965aab66fd71d8c6f75c598a526c" translate="yes" xml:space="preserve">
          <source>buffer()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f1c899c152cba9625fba62cc214dd47a564464" translate="yes" xml:space="preserve">
          <source>bufferCount</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8cb7a884cc96272d45f4ae39c1e1dcd102aed0" translate="yes" xml:space="preserve">
          <source>bufferCount()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c841349ab28c663026a1195960956aa0eefb9d9" translate="yes" xml:space="preserve">
          <source>bufferCreationInterval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75e94dcc92ecc309ef861e9a10fffb6b1a383af" translate="yes" xml:space="preserve">
          <source>bufferSize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d35857902537709bff052b2f21392b13e0b6dc1" translate="yes" xml:space="preserve">
          <source>bufferTime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1daf22e903ccd9765a488b19925eaddd48fca4f" translate="yes" xml:space="preserve">
          <source>bufferTime()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec1fb7a0ae3fca8923b9aae22470614c8efe216" translate="yes" xml:space="preserve">
          <source>bufferTimeSpan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71623ea4ea52e9677ad81d26c2212c8685a79f8" translate="yes" xml:space="preserve">
          <source>bufferToggle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9d11af4ac1aeed683c90fa9658ddd8a63dbc03" translate="yes" xml:space="preserve">
          <source>bufferToggle()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828701529c76a975c11af01d68895c37aee7735f" translate="yes" xml:space="preserve">
          <source>bufferWhen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4370f40bae73f5ecc13e64495c7f6a49178cda84" translate="yes" xml:space="preserve">
          <source>bufferWhen()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2988744f196a8865ef2214c32d811a896ed34c8d" translate="yes" xml:space="preserve">
          <source>callbackFunc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41239a847f735d90e21de0a16de5e513804da53d" translate="yes" xml:space="preserve">
          <source>catchError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e7992204ba769e12b24dd83173171dfcbcb346" translate="yes" xml:space="preserve">
          <source>catchError()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5ad06381d4e28e4ea884f3727a9527a2198dcb" translate="yes" xml:space="preserve">
          <source>closeObserver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea88fbaa99b73225752e2ef67593f775848160ad" translate="yes" xml:space="preserve">
          <source>closed</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
