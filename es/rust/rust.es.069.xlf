<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="630dd1955f1b733df02d2f1446cd6b9ba9cd293b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::from</source>
          <target state="translated">TryFromSliceError::from</target>
        </trans-unit>
        <trans-unit id="2a5519380aabe238e175f9b6849d0a2d7f53c5a8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::into</source>
          <target state="translated">TryFromSliceError::into</target>
        </trans-unit>
        <trans-unit id="b1ef9a7f4941a7c7fc1ee4d269c0be752b4049c1" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::source</source>
          <target state="translated">TryFromSliceError::source</target>
        </trans-unit>
        <trans-unit id="46b791fdfec792bbb13fbb3115a245caecffc0d8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_owned</source>
          <target state="translated">TryFromSliceError::to_owned</target>
        </trans-unit>
        <trans-unit id="04f8529255b3a3ba17e31837ca350fb03a1837a0" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_string</source>
          <target state="translated">TryFromSliceError::to_string</target>
        </trans-unit>
        <trans-unit id="d39f8030ca01a81b1eedd289678e98a9a8c6374d" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_from</source>
          <target state="translated">TryFromSliceError::try_from</target>
        </trans-unit>
        <trans-unit id="87b56d5270282ca8cea8f2ae22fb393b6ef2e185" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_into</source>
          <target state="translated">TryFromSliceError::try_into</target>
        </trans-unit>
        <trans-unit id="273ef45502220a3e82cc6cd2ff47d1b967ced192" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::type_id</source>
          <target state="translated">TryFromSliceError::type_id</target>
        </trans-unit>
        <trans-unit id="eb91bb9edb358310d1de44ff46dcb50ed3d4dbf6" translate="yes" xml:space="preserve">
          <source>TryInto</source>
          <target state="translated">TryInto</target>
        </trans-unit>
        <trans-unit id="d4782bb6e82830853df5d390b765742f2ed433ce" translate="yes" xml:space="preserve">
          <source>TryInto::try_into</source>
          <target state="translated">TryInto::try_into</target>
        </trans-unit>
        <trans-unit id="d550a8f93a6fe62cffc66481db4e53166b4de9e5" translate="yes" xml:space="preserve">
          <source>TryIter</source>
          <target state="translated">TryIter</target>
        </trans-unit>
        <trans-unit id="b4f81b18947056193693e5cce08cae5bcc996cf1" translate="yes" xml:space="preserve">
          <source>TryLockError</source>
          <target state="translated">TryLockError</target>
        </trans-unit>
        <trans-unit id="6408d526dcb04978c761f176b4b48253f6e2b3a3" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow</source>
          <target state="translated">TryLockError::borrow</target>
        </trans-unit>
        <trans-unit id="c1162b670a7e56c24667fd355cb74c01579b66f6" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow_mut</source>
          <target state="translated">TryLockError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="645caaf83340c9e36066d5283df40d2289f0c56a" translate="yes" xml:space="preserve">
          <source>TryLockError::cause</source>
          <target state="translated">TryLockError::cause</target>
        </trans-unit>
        <trans-unit id="edc35be2771c53d502f5e8aaee878dd2e15d3b5a" translate="yes" xml:space="preserve">
          <source>TryLockError::description</source>
          <target state="translated">TryLockError::description</target>
        </trans-unit>
        <trans-unit id="c6f2c000c844249e646527b009bb44e488eef5e5" translate="yes" xml:space="preserve">
          <source>TryLockError::fmt</source>
          <target state="translated">TryLockError::fmt</target>
        </trans-unit>
        <trans-unit id="9001bf82d878e70373f04e6654b0f776179b2f53" translate="yes" xml:space="preserve">
          <source>TryLockError::from</source>
          <target state="translated">TryLockError::from</target>
        </trans-unit>
        <trans-unit id="655a2e7bdf752d14f5354358dacab8b46b5c1b0d" translate="yes" xml:space="preserve">
          <source>TryLockError::into</source>
          <target state="translated">TryLockError::into</target>
        </trans-unit>
        <trans-unit id="e4ccb09bacf6984439f523c7aecac39df9844058" translate="yes" xml:space="preserve">
          <source>TryLockError::source</source>
          <target state="translated">TryLockError::source</target>
        </trans-unit>
        <trans-unit id="c61e09fc91fbcfa81bcf718beb714ea63719b4eb" translate="yes" xml:space="preserve">
          <source>TryLockError::to_string</source>
          <target state="translated">TryLockError::to_string</target>
        </trans-unit>
        <trans-unit id="ebcde8097671e82bd0e812397421ce3e5f83aa6a" translate="yes" xml:space="preserve">
          <source>TryLockError::try_from</source>
          <target state="translated">TryLockError::try_from</target>
        </trans-unit>
        <trans-unit id="7b92cc07d0ee9b28099cb947d6053805d66baac1" translate="yes" xml:space="preserve">
          <source>TryLockError::try_into</source>
          <target state="translated">TryLockError::try_into</target>
        </trans-unit>
        <trans-unit id="904eaeeceb270dd726f594af3ac7324866060774" translate="yes" xml:space="preserve">
          <source>TryLockError::type_id</source>
          <target state="translated">TryLockError::type_id</target>
        </trans-unit>
        <trans-unit id="7d779fd6e34ddc3c9ecd145e12eaab2707fb88f2" translate="yes" xml:space="preserve">
          <source>TryLockResult</source>
          <target state="translated">TryLockResult</target>
        </trans-unit>
        <trans-unit id="b00cb1382a524b91c7b6f872f909018a2ba2fcdb" translate="yes" xml:space="preserve">
          <source>TryRecvError</source>
          <target state="translated">TryRecvError</target>
        </trans-unit>
        <trans-unit id="7b782adc98cd68cba60f49733fd7fc4e8ce78c2c" translate="yes" xml:space="preserve">
          <source>TrySendError</source>
          <target state="translated">TrySendError</target>
        </trans-unit>
        <trans-unit id="bb111acc067364e9c3571b77d0ce5c4a9c6b3124" translate="yes" xml:space="preserve">
          <source>Trying to implement this scenario using our definition of &lt;code&gt;List&lt;/code&gt; with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; won&amp;rsquo;t work, as shown in Listing 15-17:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="5518f0873d902287241e5e83188a303861d5a9e6" translate="yes" xml:space="preserve">
          <source>Tuple Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11dd41e6851bdf449646a773272c37c50a284fc9" translate="yes" xml:space="preserve">
          <source>Tuple and tuple indexing expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdf2a89da03771b9bc590f650c8c5b6c77c5197" translate="yes" xml:space="preserve">
          <source>Tuple expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63a11d9cdfd9d84d9c0b5569d554b9e83dcf1cc" translate="yes" xml:space="preserve">
          <source>Tuple expression attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e822aa7ad790f9164d76dd24bd82039b2ac65758" translate="yes" xml:space="preserve">
          <source>Tuple expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6c1f43b44b32fa35dca7937a6775d19792506c" translate="yes" xml:space="preserve">
          <source>Tuple indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dc4b3b01b16ad2661df0966d7c7a1cf905b8b9" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28c59e960977888e94a3c34b0278e6e00c6936d" translate="yes" xml:space="preserve">
          <source>Tuple patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60a4a77a7ad9b86665dc5ec42ea14f2698ee75" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4691e7b0b597791c415f166cd1397c0daec1163" translate="yes" xml:space="preserve">
          <source>Tuple struct expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9f0838dcbcc88a01e222d90f53e8f39880136f" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce23bf97599891184ee6af65a034650dc03427a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd28158a620f360ba4aa0c759eb104e4dede6329" translate="yes" xml:space="preserve">
          <source>Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985c4283e220405d4d0ac504a38671b8b680d3c5" translate="yes" xml:space="preserve">
          <source>Tuple structs are similar to regular structs, but its fields have no names. They are used like tuples, with deconstruction possible via &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; syntax. For accessing individual variables, the same syntax is used as with regular tuples, namely &lt;code&gt;foo.0&lt;/code&gt;, &lt;code&gt;foo.1&lt;/code&gt;, etc, starting at zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405d7b4bc4604c6657b54f4846e0560006e9fc0e" translate="yes" xml:space="preserve">
          <source>Tuple type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e273646744d8620cb13d8fba10b333bc84bed1e" translate="yes" xml:space="preserve">
          <source>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbd57dd63bac7c82834159ddc9ea56e1515ece9" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd89c408cfdec88fd6d8e898f3566b701ea35d3a" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d624bd930abb83c2a720d48bf858a7d49eb690" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;finite&lt;/em&gt;. In other words, a tuple has a length. Here's a tuple of length &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da05b6b2dc1fb19e334d246d97430b523feb378" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;heterogeneous&lt;/em&gt;. This means that each element of the tuple can have a different type. In that tuple above, it has the type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567f8079007690271f5a29cda47d067992841b99" translate="yes" xml:space="preserve">
          <source>Tuples are a &lt;em&gt;sequence&lt;/em&gt;. This means that they can be accessed by position; this is called 'tuple indexing', and it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91ee0fad8731c0386a059fa3bf0652dd08c64d3" translate="yes" xml:space="preserve">
          <source>Tuples are often used as a return type when you want to return more than one value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ee3ba750e08e0013c45b2b001ce78e8459fa90" translate="yes" xml:space="preserve">
          <source>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create &lt;a href=&quot;../types/tuple&quot;&gt;tuple-typed&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb8ee22cf29120bf8f87bd0e3ee7ebd9949b96b" translate="yes" xml:space="preserve">
          <source>Tuples do not have any guarantees about their layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3ce6296bd35ecede807c2ca855fee144afacb9" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that are also &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c67af2890eabc2460069a200a1d4229437528f" translate="yes" xml:space="preserve">
          <source>Tuples, where a tuple is a coercion site to type &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt;. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type &lt;code&gt;U_0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54437abef1f3840afb67899d2d515749e44d9fef" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b58be63cc031a2c0fb9a41ef4a5c4c544f30d9" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fccb5986b95d1769fe3ac2f5db1e4528fbe17a" translate="yes" xml:space="preserve">
          <source>Turning Our Single-Threaded Server into a Multithreaded Server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b859b7ff96007e824952102a2b6cf7f2532bb6f5" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;*mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f32c54d91cd32dab86c92433ff5bf59fbe670a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddddd1c6a422bfc2e73b1e1e06d4513f4b671ef3" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfcb75a89ff8f3d42e0969a81b68c58ff41ffed" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a function pointer. This is &lt;em&gt;not&lt;/em&gt; portable to machines where function pointers and data pointers have different sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406e60e2392b6e162c75155bdd0eec0802166101" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut U&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7709a825d906324651f42904d312bfc3d9cfdce" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;str&lt;/code&gt; into an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4a5ffe0d58bc942e71a31a403ac137dbf193dd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0340dc9882895d2ed9f18ec41d4ee9ceaf4e0c" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2d18514777aaae37a7ce067b908310bbd6b4b" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa5c112e4e91cdb91570c34d930cf27ff1cdefa" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026acb3ca4aa61acf271a2918c10ebc97e741248" translate="yes" xml:space="preserve">
          <source>Two examples of simple paths consisting of only identifier segments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd83d672a615733082e8ee7f56c39b0af561a3e" translate="yes" xml:space="preserve">
          <source>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c944c513e67b8c4ff5047db8e7ab8f3c379bad" translate="yes" xml:space="preserve">
          <source>Two or more pointers access the same data at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea818e0ad4fe2dcf3d6dd4c02bacf808745d38d6" translate="yes" xml:space="preserve">
          <source>Two possibilities are available to solve this issue:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e61db6f0549ccd99ae56429864c2f4cbe98bb50" translate="yes" xml:space="preserve">
          <source>Two such examples are macros and &lt;code&gt;#[cfg]&lt;/code&gt; environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8a406e3a91b6f18f7fee9fffccd411cd7bea0e" translate="yes" xml:space="preserve">
          <source>Two tests that pass! Now let&amp;rsquo;s see what happens to our test results when we introduce a bug in our code. Let&amp;rsquo;s change the implementation of the &lt;code&gt;can_hold&lt;/code&gt; method by replacing the greater than sign with a less than sign when it compares the widths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6831c93d3c0041ecff78583892f51cefdc18f74a" translate="yes" xml:space="preserve">
          <source>Two things are important to note about this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73651bf2df8af467f41b29a872952ef24a40245" translate="yes" xml:space="preserve">
          <source>Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6094fd54b67e7d276ce315b3b79ffc2dd18ae2" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d078a0dedfa986439265f5fefabc817ba279445" translate="yes" xml:space="preserve">
          <source>Two traits, &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt;&lt;code&gt;Unsize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt;, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if &lt;code&gt;T&lt;/code&gt; can be coerced to &lt;code&gt;U&lt;/code&gt; with one of them, then an implementation of &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; will be provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c40881391e5533daaab739e69ccda2bb7bda270" translate="yes" xml:space="preserve">
          <source>TyCtor(&lt;code&gt;T&lt;/code&gt;) to TyCtor(&lt;code&gt;U&lt;/code&gt;), where TyCtor(&lt;code&gt;T&lt;/code&gt;) is one of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="8893ac4ddfe0ea4688a44afc0ddfe4ebc76a84ef" translate="yes" xml:space="preserve">
          <source>Type &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; represents an optional value: every &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; and contains a value, or &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, and does not. &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; types are very common in Rust code, as they have a number of uses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a34cc9264aacb6462265b18d25bcf726faf398f" translate="yes" xml:space="preserve">
          <source>Type Definition std::fmt::Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dd3e846f6d75301a90ce0c190a60bbb2f75015" translate="yes" xml:space="preserve">
          <source>Type Definition std::io::Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f6920a49ecfbe5727cafe69a86a93c6dc323b4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blkcnt_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fbcc37c53b78d2794e588bd5f55d25d53b121b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blksize_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2606fd8324f1985d42d98f82ef97532070eae3e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::dev_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0725c0d449cfcc82b033154c822ab6aa94cb70" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::ino_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a7fc18b0419da7fc9a515e767bed1bfbc9562c" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::mode_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a060e0f5140a7dabbcb1ba8000909c3c0378d8" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::nlink_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae7bb16976469a8ad4e67f2c0d76a2afe6847e7" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::off_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76556b9aa9b1d76aecac20fd90dee8158aed1fa4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::pthread_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8140af217e68caacdab8d2aaef2318b6e02ba66" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::time_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80e70a5e9f44648db2fa12eba538e96a084706b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47268ec268f5e51266c8c9b25e903a966387595d" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_double</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167acfa92657a06bc69cb3f91777f380110e4dc9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27fd9199e90c2472f965bdc0cca23d6c8c570f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f693eccac3c497abf741d0f8baed1d19e53f4b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8600d6f2d9a4b023e7037b70faa22dc15e66388f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_longlong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fbb377e146c43dbf57e7ef0b9149de46dd63ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_schar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f91247eef9f189a56e0d26eb63e94174545d18" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_short</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd264b0559dbbedb815b835dcd8dc23c60e3e46" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uchar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ae8275dba1734adb8dd3eb79d165dfd8926f8e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963d890a0fa816ac69f7b2a91122d42f47482af6" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9529b81e31c700d29c794b44439c31236befee6e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulonglong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2add572706fcd5310850bb5c41c263a68becd701" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ushort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af576d5699684e5ccc6dd3bdda06f283b79646ba" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::io::RawFd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54df1b972115ebdb7492ee1ec118ad059c5b96b9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blkcnt_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf96c7673dcafd447d654adb8e4cf01b30bb6f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blksize_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27da02afd4df0cefb0f36b07dc40fb05a497c94e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::dev_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d1317f78cb687f50d63c8e6d4ee01bdba096f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::gid_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c61da35b3b5a8948934b0c33b08607e17ab49a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::ino_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57f89ce06fb76c13960558bcf6af72b48025b0a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::mode_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efe4bc154c56731d72a72033b5e96f1e8e776fa" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::nlink_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d41f66ea53de25694ff8008809453896212992" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::off_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcd1c7c7d47846aeea79e3b67b951552799ecac" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pid_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15394730cd6adf60683b03d0f547388ed732a617" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pthread_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5866aac0842b4a721a91364de015f0e36fbc706" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::time_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10ba42310b44320213f70095552a73e406c10bc" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::uid_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfd242450d8d8e764c541c183e48c95060db965" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::thread::RawPthread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43663035c10bc49312c1bd0f80dfefc8e89294c1" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawHandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2575150d67f1e23972163c0fc5f2c5d673b3e4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawSocket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dc66459d6d8527de01519647dff10489bc279b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::HANDLE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a21128c36897e8cf2791477ca7f265a71b8679" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::SOCKET</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f25e562f1eacf92009b3b9edd31757a9d568ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::string::ParseError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5d5fbdf79715e3b849f3194ff3e1783dcc241" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::LockResult</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a007682d472492c4b8b35e81f42caebf855855fb" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::TryLockResult</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbaa33419fbed78ef077708914d095867001a9d" translate="yes" xml:space="preserve">
          <source>Type Definition std::thread::Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9037feed073eee5a9272aeaba9be605266f5d249" translate="yes" xml:space="preserve">
          <source>Type Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e484c635b0e4d4b2d73cd209e4672f43ad07bf" translate="yes" xml:space="preserve">
          <source>Type aliases are also commonly used with the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type for reducing repetition. Consider the &lt;code&gt;std::io&lt;/code&gt; module in the standard library. I/O operations often return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; to handle situations when operations fail to work. This library has a &lt;code&gt;std::io::Error&lt;/code&gt; struct that represents all possible I/O errors. Many of the functions in &lt;code&gt;std::io&lt;/code&gt; will be returning &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;std::io::Error&lt;/code&gt;, such as these functions in the &lt;code&gt;Write&lt;/code&gt; trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5463932cf5afab710bceb8f1d7684735a25ccf" translate="yes" xml:space="preserve">
          <source>Type and Lifetime Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46505cd1622c8bbcf00ce8fef2ff0cd36549954e" translate="yes" xml:space="preserve">
          <source>Type bounds may be &lt;em&gt;higher ranked&lt;/em&gt; over lifetimes. These bounds specify a bound is true &lt;em&gt;for all&lt;/em&gt; lifetimes. For example, a bound such as &lt;code&gt;for&amp;lt;'a&amp;gt; &amp;amp;'a T: PartialEq&amp;lt;i32&amp;gt;&lt;/code&gt; would require an implementation like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee004d162350a5b317e1dbaab9ce920a6f34a9cb" translate="yes" xml:space="preserve">
          <source>Type cast expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e747774abb621d3a39f39c2761d3405b325bb" translate="yes" xml:space="preserve">
          <source>Type coercions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d852132e2d9e31234c0b7e2d2b2f126e521734" translate="yes" xml:space="preserve">
          <source>Type expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e950510855acd161003d11973afbcccbd1f3d1" translate="yes" xml:space="preserve">
          <source>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like &lt;code&gt;*&lt;/code&gt; -- the type checker may not have enough information &lt;em&gt;yet&lt;/em&gt; to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a230d1816e8c1575c2c45ae6cf6a3850545e094f" translate="yes" xml:space="preserve">
          <source>Type layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421e94d5ad1cf070315124ce8a70fe7342de0094" translate="yes" xml:space="preserve">
          <source>Type of &lt;code&gt;e&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483996222a68497be8a52e043163c1b07da634c0" translate="yes" xml:space="preserve">
          <source>Type of the hasher that will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d41d3e02c3a5714dfb49c0b53d465ea95595cd" translate="yes" xml:space="preserve">
          <source>Type parameter defaults can only use parameters that occur before them. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3ece058bb3ba65db202bc18df133e4b49391e3" translate="yes" xml:space="preserve">
          <source>Type parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in &lt;a href=&quot;functions#generic-functions&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635a70628fcb4cdf2545b82d9a213017cf1ec1dc" translate="yes" xml:space="preserve">
          <source>Type parameters where the parameters only have any &lt;a href=&quot;../trait-bounds&quot;&gt;trait bounds&lt;/a&gt; of the following kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5436dd7df5cce78281ac167ac45b8ad046b6808" translate="yes" xml:space="preserve">
          <source>Type paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc5390ca69aecade222ecf85ac47ee15fecaa1e" translate="yes" xml:space="preserve">
          <source>Type system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b05abe4f4f396debd3f7c7c7a457e652381139" translate="yes" xml:space="preserve">
          <source>TypeId</source>
          <target state="translated">TypeId</target>
        </trans-unit>
        <trans-unit id="6174852658dcb07e66221cdda0d47c6a79955026" translate="yes" xml:space="preserve">
          <source>TypeId::borrow</source>
          <target state="translated">TypeId::borrow</target>
        </trans-unit>
        <trans-unit id="9240a6191da03dd3e162b4d594573c014ae637e8" translate="yes" xml:space="preserve">
          <source>TypeId::borrow_mut</source>
          <target state="translated">TypeId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1e830f38943c98994765e5634b28fc734e6d131b" translate="yes" xml:space="preserve">
          <source>TypeId::clamp</source>
          <target state="translated">TypeId::clamp</target>
        </trans-unit>
        <trans-unit id="716fa011ef15618f6c39d058d78de9fd5d26d8a4" translate="yes" xml:space="preserve">
          <source>TypeId::clone</source>
          <target state="translated">TypeId::clone</target>
        </trans-unit>
        <trans-unit id="d206fca55570d1ee7222250a6099efa3eefe5378" translate="yes" xml:space="preserve">
          <source>TypeId::clone_from</source>
          <target state="translated">TypeId::clone_from</target>
        </trans-unit>
        <trans-unit id="795523e4b3053e8ae487bb7ffbfed98163be00e1" translate="yes" xml:space="preserve">
          <source>TypeId::clone_into</source>
          <target state="translated">TypeId::clone_into</target>
        </trans-unit>
        <trans-unit id="ddba09636ddf2c450efd47bdbd5c1086798641ce" translate="yes" xml:space="preserve">
          <source>TypeId::cmp</source>
          <target state="translated">TypeId::cmp</target>
        </trans-unit>
        <trans-unit id="3f0565a2054d47ca089c9dd28d09f714cfe255a6" translate="yes" xml:space="preserve">
          <source>TypeId::eq</source>
          <target state="translated">TypeId::eq</target>
        </trans-unit>
        <trans-unit id="3b66ed765f5e07da8b6a35c0796de577d880004a" translate="yes" xml:space="preserve">
          <source>TypeId::fmt</source>
          <target state="translated">TypeId::fmt</target>
        </trans-unit>
        <trans-unit id="a6d534f62ff1c6a2b12bb6ea7101f9db8f3b6a65" translate="yes" xml:space="preserve">
          <source>TypeId::from</source>
          <target state="translated">TypeId::from</target>
        </trans-unit>
        <trans-unit id="0ad8421f49348cec9c5c0ea27504bddf46f46746" translate="yes" xml:space="preserve">
          <source>TypeId::ge</source>
          <target state="translated">TypeId::ge</target>
        </trans-unit>
        <trans-unit id="98d12bbe982cc4e9feaef864de49f327eade548c" translate="yes" xml:space="preserve">
          <source>TypeId::gt</source>
          <target state="translated">TypeId::gt</target>
        </trans-unit>
        <trans-unit id="e1dea7697f9d16fe9585b0146b54ef1ba2595a7c" translate="yes" xml:space="preserve">
          <source>TypeId::hash</source>
          <target state="translated">TypeId::hash</target>
        </trans-unit>
        <trans-unit id="d7a9744fc39a0fe544964e9b703ad9db8ff88413" translate="yes" xml:space="preserve">
          <source>TypeId::hash_slice</source>
          <target state="translated">TypeId::hash_slice</target>
        </trans-unit>
        <trans-unit id="8f7e7f7b59fc95161e5efd4c331382bf506c5fe2" translate="yes" xml:space="preserve">
          <source>TypeId::into</source>
          <target state="translated">TypeId::into</target>
        </trans-unit>
        <trans-unit id="02f386a913763d6012a9e28821eacb6458ea8546" translate="yes" xml:space="preserve">
          <source>TypeId::le</source>
          <target state="translated">TypeId::le</target>
        </trans-unit>
        <trans-unit id="578f87bf8b84d3b8635f212a617fcec0f23b5476" translate="yes" xml:space="preserve">
          <source>TypeId::lt</source>
          <target state="translated">TypeId::lt</target>
        </trans-unit>
        <trans-unit id="6c7811e3962847e55153d132edc379a97aeab156" translate="yes" xml:space="preserve">
          <source>TypeId::max</source>
          <target state="translated">TypeId::max</target>
        </trans-unit>
        <trans-unit id="5de1024eb47140ae18a0b9ef6b7abda00f5ebc42" translate="yes" xml:space="preserve">
          <source>TypeId::min</source>
          <target state="translated">TypeId::min</target>
        </trans-unit>
        <trans-unit id="19a1b2382c162a3deb2660f8d535151330c4dd68" translate="yes" xml:space="preserve">
          <source>TypeId::ne</source>
          <target state="translated">TypeId::ne</target>
        </trans-unit>
        <trans-unit id="57bbf815ae3734582141e6c3d94d16d795b42238" translate="yes" xml:space="preserve">
          <source>TypeId::of</source>
          <target state="translated">TypeId::of</target>
        </trans-unit>
        <trans-unit id="9387d6c30cfc43859bbce0cd6a9e882f482aa548" translate="yes" xml:space="preserve">
          <source>TypeId::partial_cmp</source>
          <target state="translated">TypeId::partial_cmp</target>
        </trans-unit>
        <trans-unit id="275a8a5c8970873ed0f6e5f7be025d1d88c24b17" translate="yes" xml:space="preserve">
          <source>TypeId::to_owned</source>
          <target state="translated">TypeId::to_owned</target>
        </trans-unit>
        <trans-unit id="b305d0eb27c70d75d6581a7bb24fd3b0cabb8713" translate="yes" xml:space="preserve">
          <source>TypeId::try_from</source>
          <target state="translated">TypeId::try_from</target>
        </trans-unit>
        <trans-unit id="ab6bd512f140c02836e01449097676127e0b1727" translate="yes" xml:space="preserve">
          <source>TypeId::try_into</source>
          <target state="translated">TypeId::try_into</target>
        </trans-unit>
        <trans-unit id="b7aa84284f56989bd040008a9a1842dc034ac075" translate="yes" xml:space="preserve">
          <source>TypeId::type_id</source>
          <target state="translated">TypeId::type_id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="51920e55843cc4f1f030d29bb9494f870acf0911" translate="yes" xml:space="preserve">
          <source>Types and Traits for working with asynchronous tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb96b9196c6d15505da132a08c116566f7a5d2bc" translate="yes" xml:space="preserve">
          <source>Types express that they can be borrowed as some type &lt;code&gt;T&lt;/code&gt; by implementing &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;, providing a reference to a &lt;code&gt;T&lt;/code&gt; in the trait&amp;rsquo;s &lt;a href=&quot;#tymethod.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt; method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type &amp;ndash; allowing the underlying data to be modified, it can additionally implement &lt;a href=&quot;trait.borrowmut&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a53d10bc9765156a98cd22298d0dddb08f16d1f" translate="yes" xml:space="preserve">
          <source>Types for which it is safe to share references between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c95794e6189dee1201d1bd443780e1c531d39b" translate="yes" xml:space="preserve">
          <source>Types implementing &lt;code&gt;Hash&lt;/code&gt; are able to be &lt;a href=&quot;#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;ed with an instance of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f882465e79764914f835cc19a5911f31e45f796b" translate="yes" xml:space="preserve">
          <source>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777921b6f1b475c9ffaa77c98a5d17f39e3660e5" translate="yes" xml:space="preserve">
          <source>Types like &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, however, are unwind safe because they implement poisoning by default. They still allow witnessing a broken invariant, but they already provide their own &quot;speed bumps&quot; to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a83f5b2fb6977b69a3feef08ecd269c85a9244" translate="yes" xml:space="preserve">
          <source>Types like Vec therefore just &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; without using needs_drop explicitly. Types like &lt;code&gt;HashMap&lt;/code&gt;, on the other hand, have to drop values one at a time and should use this API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7478d20240bfc3f122030bf28d31bd62139a2c2b" translate="yes" xml:space="preserve">
          <source>Types of paths</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927769adc55a691f31ed2d50893e6b26e3a7e1f3" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; are examples which are &lt;strong&gt;not&lt;/strong&gt; unwind safe. The general idea is that any mutable state which can be shared across &lt;code&gt;catch_unwind&lt;/code&gt; is not unwind safe by default. This is because it is very easy to witness a broken invariant outside of &lt;code&gt;catch_unwind&lt;/code&gt; as the data is simply accessed as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3195172a47cd29103a9c049d30b8fbf3e8b1360" translate="yes" xml:space="preserve">
          <source>Types that are &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; should have a trivial implementation of &lt;code&gt;Clone&lt;/code&gt;. More formally: if &lt;code&gt;T: Copy&lt;/code&gt;, &lt;code&gt;x: T&lt;/code&gt;, and &lt;code&gt;y: &amp;amp;T&lt;/code&gt;, then &lt;code&gt;let x = y.clone();&lt;/code&gt; is equivalent to &lt;code&gt;let x = *y;&lt;/code&gt;. Manual implementations should be careful to uphold this invariant; however, unsafe code must not rely on it to ensure memory safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052471a32eb0536b190d6178524500a9ab363d4b" translate="yes" xml:space="preserve">
          <source>Types that are not &lt;code&gt;Sync&lt;/code&gt; are those that have &quot;interior mutability&quot; in a non-thread-safe form, such as &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;cell::Cell&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;cell::RefCell&lt;/code&gt;&lt;/a&gt;. These types allow for mutation of their contents even through an immutable, shared reference. For example the &lt;code&gt;set&lt;/code&gt; method on &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, so it requires only a shared reference &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The method performs no synchronization, thus &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; cannot be &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93bcdad638deb7c786807f08f731b7cc346d96e" translate="yes" xml:space="preserve">
          <source>Types that can be &quot;unsized&quot; to a dynamically-sized type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb55fa05185a6907e8b5c6521da0fcc611e7870b" translate="yes" xml:space="preserve">
          <source>Types that can be referred to by a path directly. Specifically &lt;a href=&quot;items/enumerations&quot;&gt;enums&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;items/unions&quot;&gt;unions&lt;/a&gt;, and &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac756fd205dd639ca5e2fd93c5deef27d4364ad" translate="yes" xml:space="preserve">
          <source>Types that can be transferred across thread boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320fc78d266da1348d0700937ff111e53e935f29" translate="yes" xml:space="preserve">
          <source>Types that pin data to its location in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76aa938f99526e648196d0e632e37d9cfcfbe64a" translate="yes" xml:space="preserve">
          <source>Types where all values have the same size and alignment known at compile time implement the &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait and can be checked with the &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt;&lt;code&gt;align_of&lt;/code&gt;&lt;/a&gt; functions. Types that are not &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; are known as &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;. Since all values of a &lt;code&gt;Sized&lt;/code&gt; type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3210f89648e92f030dff845af33244c5ff84d48b" translate="yes" xml:space="preserve">
          <source>Types which can be safely moved after being pinned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9fa3c4c8befc1e893d11ac3d1acf505f4ef9f3" translate="yes" xml:space="preserve">
          <source>Types whose values can be duplicated simply by copying bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184223af25e77a5fba4124f5c744634bac8d8134" translate="yes" xml:space="preserve">
          <source>Types with a built-in &lt;code&gt;Copy&lt;/code&gt; implementation (see above)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484e89278738e43bbfac83c89cf041e830b0fa33" translate="yes" xml:space="preserve">
          <source>Types with a constant size known at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c606776082303165b5e8cc822f677d6b3746b68d" translate="yes" xml:space="preserve">
          <source>Typically in Rust, it is difficult to perform step (2) because catching a panic involves either spawning a thread (which in turns makes it difficult to later witness broken invariants) or using the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module. Additionally, even if an invariant is witnessed, it typically isn't a problem in Rust because there are no uninitialized values (like in C or C++).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb301c3b538136ec6b1f761774f64171df868f5f" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;quit&lt;/code&gt; actually quits the game, but so will any other non-number input. However, this is suboptimal to say the least. We want the game to automatically stop when the correct number is guessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a153700f851859e0ff4a79a843433857f27950a3" translate="yes" xml:space="preserve">
          <source>U+0021 ..= U+002F &lt;code&gt;! &quot; # $ % &amp;amp; ' ( ) * + , - . /&lt;/code&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3efbcf50b26fb17c75edefb4d0573be03644e1" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9', or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974d5e574e1e2bc13b31d24cc4a60ea2f16fa049" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0e8044fa37810bc4ad961db684088868f06aba" translate="yes" xml:space="preserve">
          <source>U+003A ..= U+0040 &lt;code&gt;: ; &amp;lt; = &amp;gt; ? @&lt;/code&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302310fbdc6543d9d3ceaffa2ea8c3882849e20a" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+0046 'F', or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0736721e1e5a1d0311260bd3b8011dcd68e67375" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+005A 'Z', or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2fb3a2a6da1a41f13ef4503845f3b0b40f0c2e" translate="yes" xml:space="preserve">
          <source>U+005B ..= U+0060 &lt;code&gt;[ \ ] ^ _ ` &lt;/code&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cc906d3074f1fb9435c008fb8f60999129ec67" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+0066 'f'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d839fcec5226b8d1bd246357b031dd87454f54" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z', or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a61fd70b1e7aaf895ebbced86d7174cebf3cb2" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed9fc1e2abd580e2aa130399315d68f08afda9" translate="yes" xml:space="preserve">
          <source>U+007B ..= U+007E &lt;code&gt;{ | } ~&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd9df57e9839a1ea6ed560675b576be4884654a" translate="yes" xml:space="preserve">
          <source>UNC prefixes consist of the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e32e0a7cca1165daa904dec1d1f04e68736d5e" translate="yes" xml:space="preserve">
          <source>UNICODE_ESCAPE :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22641b9fc9c9910a6cdbff4d4c69eb3d13192f7" translate="yes" xml:space="preserve">
          <source>UNICODE_VERSION</source>
          <target state="translated">UNICODE_VERSION</target>
        </trans-unit>
        <trans-unit id="82e26360ac87e10e1e21c7c1d4d889a8777bad06" translate="yes" xml:space="preserve">
          <source>UNIX_EPOCH</source>
          <target state="translated">UNIX_EPOCH</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="ff463dac21cfe2cbf8ee41ca3cd6ef5584048c23" translate="yes" xml:space="preserve">
          <source>UTF8BOM : &lt;code&gt;\uFEFF&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc8e71f3f5fe8f28cf7f67493cc988d6461307a" translate="yes" xml:space="preserve">
          <source>UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</source>
          <target state="translated">UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f301189dd0e6ecd6aa5f6cd826f3ac3660574f9f" translate="yes" xml:space="preserve">
          <source>UdpSocket</source>
          <target state="translated">UdpSocket</target>
        </trans-unit>
        <trans-unit id="eef9838e551c21ad60465337cf4a411d0bc3c3b0" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_fd</source>
          <target state="translated">UdpSocket::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="3dead55d6e23751656153f593bd69532bbdd74b4" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_socket</source>
          <target state="translated">UdpSocket::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="e711eb64b283a492f76bc94de05d5beae4ce3446" translate="yes" xml:space="preserve">
          <source>UdpSocket::bind</source>
          <target state="translated">UdpSocket::bind</target>
        </trans-unit>
        <trans-unit id="bd6abe4ecc1b7a3998504825b222c78c7397b977" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow</source>
          <target state="translated">UdpSocket::borrow</target>
        </trans-unit>
        <trans-unit id="d6dfaba170b099d4935948d95be3a9b2d44c1b67" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow_mut</source>
          <target state="translated">UdpSocket::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c7601afb8a1f8cbf9600b90ec208697e7f31bb37" translate="yes" xml:space="preserve">
          <source>UdpSocket::broadcast</source>
          <target state="translated">UdpSocket::broadcast</target>
        </trans-unit>
        <trans-unit id="b5425c83fcfa16a56bdac78f93d426c4d76de0d0" translate="yes" xml:space="preserve">
          <source>UdpSocket::connect</source>
          <target state="translated">UdpSocket::connect</target>
        </trans-unit>
        <trans-unit id="4ef0111b75ab32121f2408b7d5f05ebfa5b6081d" translate="yes" xml:space="preserve">
          <source>UdpSocket::fmt</source>
          <target state="translated">UdpSocket::fmt</target>
        </trans-unit>
        <trans-unit id="6967c776a7bd3c84521bc241c391c1e849c635bd" translate="yes" xml:space="preserve">
          <source>UdpSocket::from</source>
          <target state="translated">UdpSocket::from</target>
        </trans-unit>
        <trans-unit id="bb5a7c0a1436e4ab18aa912a9f605f7b18ee8765" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_fd</source>
          <target state="translated">UdpSocket::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f80335b07809af571cc3df35b472a55569fb682a" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_socket</source>
          <target state="translated">UdpSocket::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="9027e17e6ff5173579151cfa12fc5dbe9441694f" translate="yes" xml:space="preserve">
          <source>UdpSocket::into</source>
          <target state="translated">UdpSocket::into</target>
        </trans-unit>
        <trans-unit id="a803dafad8d15d21084fc92907391bd1b059ddfd" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_fd</source>
          <target state="translated">UdpSocket::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="9cf9f423f72726c7578e2b5f5e2920796c1f2793" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_socket</source>
          <target state="translated">UdpSocket::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="3f8673b9aaf4671a169334c3798e42c1cef61195" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v4</source>
          <target state="translated">UdpSocket::join_multicast_v4</target>
        </trans-unit>
        <trans-unit id="fdb0ef8819eb18c412a260ee8e4e9ed4c176ee44" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v6</source>
          <target state="translated">UdpSocket::join_multicast_v6</target>
        </trans-unit>
        <trans-unit id="daf0d0331de8a89e9e07829bd3f8f62b73e26c9f" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v4</source>
          <target state="translated">UdpSocket::leave_multicast_v4</target>
        </trans-unit>
        <trans-unit id="19e7ef348410341be9e9f87a0c453576eeabf4f2" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v6</source>
          <target state="translated">UdpSocket::leave_multicast_v6</target>
        </trans-unit>
        <trans-unit id="4541378b6e55fa1b6ff0ecd59a93caf5944114ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::local_addr</source>
          <target state="translated">UdpSocket::local_addr</target>
        </trans-unit>
        <trans-unit id="e1d4fbc9e9ee16f13b25d7e15d3094bef922be02" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v4</source>
          <target state="translated">UdpSocket::multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="47fea5b479b31e88d1e71ca6bcfb3bb1110ffa70" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v6</source>
          <target state="translated">UdpSocket::multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="af0afd1673286058b665d369d31b395392204948" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_ttl_v4</source>
          <target state="translated">UdpSocket::multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="7ea92dd593f0d5cfd6700064620321c00b369e37" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek</source>
          <target state="translated">UdpSocket::peek</target>
        </trans-unit>
        <trans-unit id="618b3359f531c1676b89a79683f9f10d7d9e63d6" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek_from</source>
          <target state="translated">UdpSocket::peek_from</target>
        </trans-unit>
        <trans-unit id="ed605d1f943615e31a607bcc21bab5caa4744d32" translate="yes" xml:space="preserve">
          <source>UdpSocket::peer_addr</source>
          <target state="translated">UdpSocket::peer_addr</target>
        </trans-unit>
        <trans-unit id="e623079f9fa431b1604c2d3e586552e0f51cec43" translate="yes" xml:space="preserve">
          <source>UdpSocket::read_timeout</source>
          <target state="translated">UdpSocket::read_timeout</target>
        </trans-unit>
        <trans-unit id="117a240778e6d7c73d9190f8661f261267ed1dce" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv</source>
          <target state="translated">UdpSocket::recv</target>
        </trans-unit>
        <trans-unit id="6b5d35c54deb341c259817d88dd2d0d29fec7a61" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv_from</source>
          <target state="translated">UdpSocket::recv_from</target>
        </trans-unit>
        <trans-unit id="342543bea1d10360d53cdb0e77dc5cb9afda6331" translate="yes" xml:space="preserve">
          <source>UdpSocket::send</source>
          <target state="translated">UdpSocket::send</target>
        </trans-unit>
        <trans-unit id="22d3f7e464f346e514fa3986fce3b3f1e2571e5b" translate="yes" xml:space="preserve">
          <source>UdpSocket::send_to</source>
          <target state="translated">UdpSocket::send_to</target>
        </trans-unit>
        <trans-unit id="9e2a55f7f7b4b48356483d8d2fb5b602fa0f3530" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_broadcast</source>
          <target state="translated">UdpSocket::set_broadcast</target>
        </trans-unit>
        <trans-unit id="3f47efd4587a1a296613dd09d826c04823707540" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v4</source>
          <target state="translated">UdpSocket::set_multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="e20ba27d970b370c3419b1aeb14d08d71bc56a8c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v6</source>
          <target state="translated">UdpSocket::set_multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="9cd522d20aa030dbf9138752a7e810a44b5efb38" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_ttl_v4</source>
          <target state="translated">UdpSocket::set_multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="03074d339b260baa1ad044577238a1336825ab4b" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_nonblocking</source>
          <target state="translated">UdpSocket::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="d915caa0f42d8eb7576e0424ad1fb96ff110018c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_read_timeout</source>
          <target state="translated">UdpSocket::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="00311ef46c51fae7556414d73e84c73f1d7812ff" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_ttl</source>
          <target state="translated">UdpSocket::set_ttl</target>
        </trans-unit>
        <trans-unit id="febfbd7ca83810329de07b88d8fb3393c6ca4798" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_write_timeout</source>
          <target state="translated">UdpSocket::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="9d7c771c5a45977006ca3dfa60a86af6dd8ee823" translate="yes" xml:space="preserve">
          <source>UdpSocket::take_error</source>
          <target state="translated">UdpSocket::take_error</target>
        </trans-unit>
        <trans-unit id="9f4ec7ded42c7be9420f00ecf5a43baac427f3a2" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_clone</source>
          <target state="translated">UdpSocket::try_clone</target>
        </trans-unit>
        <trans-unit id="124c70e6a48a5f998f83b2f8f60af01be757111c" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_from</source>
          <target state="translated">UdpSocket::try_from</target>
        </trans-unit>
        <trans-unit id="419d8221e876e08ccc71dcef9e30956e6a2336ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_into</source>
          <target state="translated">UdpSocket::try_into</target>
        </trans-unit>
        <trans-unit id="179be00cc6604f24b28a0eaa033c371e9b537141" translate="yes" xml:space="preserve">
          <source>UdpSocket::ttl</source>
          <target state="translated">UdpSocket::ttl</target>
        </trans-unit>
        <trans-unit id="2e57927ff8f0f2d0d53c88f359b91dce0a9fac1a" translate="yes" xml:space="preserve">
          <source>UdpSocket::type_id</source>
          <target state="translated">UdpSocket::type_id</target>
        </trans-unit>
        <trans-unit id="6e4a0fe28e49c9f074eb8b5bf8aa033213c911d5" translate="yes" xml:space="preserve">
          <source>UdpSocket::write_timeout</source>
          <target state="translated">UdpSocket::write_timeout</target>
        </trans-unit>
        <trans-unit id="ad739a773605a26e0e278e2e21fb10279a5b2fe3" translate="yes" xml:space="preserve">
          <source>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they&amp;rsquo;re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c83e690d015c2dda5615d91434e066248316e35" translate="yes" xml:space="preserve">
          <source>Ultimately, we want to convert the &lt;code&gt;String&lt;/code&gt; the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding the following two lines to the &lt;code&gt;main&lt;/code&gt; function body:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65abf2396d9d0e3036b5edd214ba0117f22347c" translate="yes" xml:space="preserve">
          <source>Unaligned pointer reading and writing outside of &lt;a href=&quot;../std/ptr/fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ptr/fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19c02a20defb4e5a19ad20ddc9f198b595912c2" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06561b17b729c80e40714208c692221607fb499c" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370c58f039e07727be3fca997e7473eb72b353e5" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;../type-layout#the-default-representation&quot;&gt;default representation&lt;/a&gt;, the specified discriminant is interpreted as an &lt;code&gt;isize&lt;/code&gt; value although the compiler is allowed to use a smaller type in the actual memory layout. The size and thus acceptable values can be changed by using a &lt;a href=&quot;../type-layout#primitive-representations&quot;&gt;primitive representation&lt;/a&gt; or the &lt;a href=&quot;../type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt; representation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934025592a349e0ccdf3fcea702e3b4fab1b4701" translate="yes" xml:space="preserve">
          <source>Under the surface, the &lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; macros use the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt; traits. All the primitive types and most of the standard library types implement these traits. For structs and enums that you define, you&amp;rsquo;ll need to implement &lt;code&gt;PartialEq&lt;/code&gt; to assert that values of those types are equal or not equal. You&amp;rsquo;ll need to implement &lt;code&gt;Debug&lt;/code&gt; to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the &lt;code&gt;#[derive(PartialEq, Debug)]&lt;/code&gt; annotation to your struct or enum definition. See Appendix C, &lt;a href=&quot;appendix-03-derivable-traits&quot;&gt;&amp;ldquo;Derivable Traits,&amp;rdquo;&lt;/a&gt; for more details about these and other derivable traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca035a5ce4c3df59c37ddda21e0189a6380e3b1f" translate="yes" xml:space="preserve">
          <source>Underscore</source>
          <target state="translated">Underscore</target>
        </trans-unit>
        <trans-unit id="7bd1424f9d38ad3f094e622e30f38d61cffee843" translate="yes" xml:space="preserve">
          <source>Underscore Imports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31df2c04ec1e4b0b36bedd38e82d9eeb2726bb3" translate="yes" xml:space="preserve">
          <source>Understanding Ownership</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd6a0012c9128bdcdb48f1df7a5232a746b1dd8" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is not safe to share across threads. When &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; manages the reference count, it adds to the count for each call to &lt;code&gt;clone&lt;/code&gt; and subtracts from the count when each clone is dropped. But it doesn&amp;rsquo;t use any concurrency primitives to make sure that changes to the count can&amp;rsquo;t be interrupted by another thread. This could lead to wrong counts&amp;mdash;subtle bugs that could in turn lead to memory leaks or a value being dropped before we&amp;rsquo;re done with it. What we need is a type exactly like &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; but one that makes changes to the reference count in a thread-safe way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1444761777045d9a10886b422e6940c76965059f" translate="yes" xml:space="preserve">
          <source>Unfortunately, it&amp;rsquo;s not straightforward to disable the automatic &lt;code&gt;drop&lt;/code&gt; functionality. Disabling &lt;code&gt;drop&lt;/code&gt; isn&amp;rsquo;t usually necessary; the whole point of the &lt;code&gt;Drop&lt;/code&gt; trait is that it&amp;rsquo;s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the &lt;code&gt;drop&lt;/code&gt; method that releases the lock to run so other code in the same scope can acquire the lock. Rust doesn&amp;rsquo;t let you call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually; instead you have to call the &lt;code&gt;std::mem::drop&lt;/code&gt; function provided by the standard library if you want to force a value to be dropped before the end of its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a531b7898235009a0cc7b2eec486ea25b9d6d2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be79a988f81db8bfcf6945f3ba47d61010546fc9" translate="yes" xml:space="preserve">
          <source>Unicode escapes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0d9cce1182bdae15059a991a47bf01218e3825" translate="yes" xml:space="preserve">
          <source>Unicode escapes are never generated by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049c2f43b308773f947249e6515dfdd4cc3c35a2" translate="yes" xml:space="preserve">
          <source>Unicode is designed such that this effectively decodes bytes with the character encoding that IANA calls ISO-8859-1. This encoding is compatible with ASCII.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045e4620605ab61ee2d00d3c61380dde56a437e0" translate="yes" xml:space="preserve">
          <source>Unicode string slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8b0aa9835ad896a48c3cd1f5107ad4d8a0d9e1" translate="yes" xml:space="preserve">
          <source>UnicodeVersion</source>
          <target state="translated">UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="2e2480da297a5a795e54a8b1e8174027d5cb3056" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow</source>
          <target state="translated">UnicodeVersion::borrow</target>
        </trans-unit>
        <trans-unit id="89b51103925ce314bbcaaf20a8fe1cadc3924003" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow_mut</source>
          <target state="translated">UnicodeVersion::borrow_mut</target>
        </trans-unit>
        <trans-unit id="88a2e4badb33e94ea8a5b499e6fc153387a0beb3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clamp</source>
          <target state="translated">UnicodeVersion::clamp</target>
        </trans-unit>
        <trans-unit id="d17cdcafd0174814c16b4f219e4fed72e9bd469a" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone</source>
          <target state="translated">UnicodeVersion::clone</target>
        </trans-unit>
        <trans-unit id="47b2336d0c0eb30610891e9aeb66476192776d1f" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_from</source>
          <target state="translated">UnicodeVersion::clone_from</target>
        </trans-unit>
        <trans-unit id="df3118b48825d7934a06fa42be12de85a41743a3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_into</source>
          <target state="translated">UnicodeVersion::clone_into</target>
        </trans-unit>
        <trans-unit id="a501e28c8f674e6c8775cd5763a1269e58854a95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::cmp</source>
          <target state="translated">UnicodeVersion::cmp</target>
        </trans-unit>
        <trans-unit id="eb0f8f28b23626496734a42b66b3d04fceab6e15" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::eq</source>
          <target state="translated">UnicodeVersion::eq</target>
        </trans-unit>
        <trans-unit id="d50614eac8572f390490b398b9df8d2ee6162d01" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::fmt</source>
          <target state="translated">UnicodeVersion::fmt</target>
        </trans-unit>
        <trans-unit id="870f165e6cd936b143cbc0dbc14afac1093420d0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::from</source>
          <target state="translated">UnicodeVersion::from</target>
        </trans-unit>
        <trans-unit id="2bad969f3e70b400e54b881fe8536995db1f2994" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ge</source>
          <target state="translated">UnicodeVersion::ge</target>
        </trans-unit>
        <trans-unit id="08f3a8d2999b98ac5f6c67691d5bdd1bc1a0e145" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::gt</source>
          <target state="translated">UnicodeVersion::gt</target>
        </trans-unit>
        <trans-unit id="b5a9d9239e831f7ef74e7e53b12fa0fd62d71a97" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::into</source>
          <target state="translated">UnicodeVersion::into</target>
        </trans-unit>
        <trans-unit id="1ea14b2a7575169ecf16f30acb48c3409c34b763" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::le</source>
          <target state="translated">UnicodeVersion::le</target>
        </trans-unit>
        <trans-unit id="eb08588571d008fa3a48093f6cad0aa8209e47e3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::lt</source>
          <target state="translated">UnicodeVersion::lt</target>
        </trans-unit>
        <trans-unit id="809dd77e054b744c6372ff89e0b31e14994e27e7" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::max</source>
          <target state="translated">UnicodeVersion::max</target>
        </trans-unit>
        <trans-unit id="1c035e39a67ae5609815950cc75aebf117385e95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::min</source>
          <target state="translated">UnicodeVersion::min</target>
        </trans-unit>
        <trans-unit id="064f84b6703cb5f6f68f68e7fc2c4d251f631296" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ne</source>
          <target state="translated">UnicodeVersion::ne</target>
        </trans-unit>
        <trans-unit id="7c59df82b034e552f2c3f4f3995f283f8463f626" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::partial_cmp</source>
          <target state="translated">UnicodeVersion::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd2d6e2e056d2c57e62b0e2e433f8281504be6b4" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::to_owned</source>
          <target state="translated">UnicodeVersion::to_owned</target>
        </trans-unit>
        <trans-unit id="c51cc398d26afae848ea754f781315242ac4e979" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_from</source>
          <target state="translated">UnicodeVersion::try_from</target>
        </trans-unit>
        <trans-unit id="a8b18a0ff13e1e11bb861c761bf0dc70df4c71e0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_into</source>
          <target state="translated">UnicodeVersion::try_into</target>
        </trans-unit>
        <trans-unit id="eecb3bfce19f7a3ae0d89e37123a7c922b8eeab9" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::type_id</source>
          <target state="translated">UnicodeVersion::type_id</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="431e2898d7b9070b1bc9e3d0e0fac72fa778d000" translate="yes" xml:space="preserve">
          <source>Union std::mem::MaybeUninit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="9ee9dda7ec1e961b1ea8bab0ad66f79036feccce" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access just interprets the storage at the type of the field used for the access. Reading a union field reads the bits of the union at the field's type. It is the programmer's responsibility to make sure that the data is valid at that type. Failing to do so results in undefined behavior. For example, reading the value &lt;code&gt;3&lt;/code&gt; at type &lt;code&gt;bool&lt;/code&gt; is undefined behavior. Effectively, writing to and then reading from a union is analogous to a &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt; from the type used for writing to the type used for reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2b3efb0aed2e9062949d0d6efb28c840e4bdd0" translate="yes" xml:space="preserve">
          <source>Unique immutable borrows in captures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4dd0d2f506c2585198c093fe3355566c69c50a" translate="yes" xml:space="preserve">
          <source>Unit struct expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b9bb5cd29f3ad5aabe2057140ec12468595ac3" translate="yes" xml:space="preserve">
          <source>Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty enums they can be instantiated, making them isomorphic to the unit type &lt;code&gt;()&lt;/code&gt;. Unit structs are useful when you need to implement a trait on something, but don't need to store any data inside it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ad46d73653a34f4423b5d45017917794627b45" translate="yes" xml:space="preserve">
          <source>Unit-Like Structs Without Any Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="122365e7dc1f75db94d30ca063c2e50b567c06af" translate="yes" xml:space="preserve">
          <source>Unix-specific extension methods for &lt;a href=&quot;../../../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40290eba8741a7fb561802cc4fd7a5f03fc12be7" translate="yes" xml:space="preserve">
          <source>Unix-specific extension to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8456cebfaf04274630f018fe98c85f0928fd59" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions for &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ae3204adf61398987a8d1c1ea0cc0ee7054526" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.dirbuilder&quot;&gt;&lt;code&gt;fs::DirBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c055cc3e8d38d074a1699c2467aa73f8a67ec8b" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f808e6d0f3cef15729ba995896155633f9c4e702" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a398ee8c4edc244dd48383efb674694800d11b42" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3e2254255ed122649ef706ca6351a05878a982" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.permissions&quot;&gt;&lt;code&gt;fs::Permissions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debd12446f93bf566a622bdf802607a7783bf6af" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44e2e0da5854a8ebdf4095318d97783ef5ced71" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt;&lt;code&gt;thread::JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f569dc194098f87c8bc0882017a7d0c963c955" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to general I/O primitives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3789837939ff4014248adcb7118252ef4bacad14" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f34673a7f1203fc92e8429aa07449552c09698" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::process&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cfd734bf76c756b8e059f4a9d1700ff9a4713c" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::thread&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffca9f4f9cc7c8dd85f78563efe7167f6d2b47d" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d68049fb554c75225dfe9c03296f580e460278" translate="yes" xml:space="preserve">
          <source>Unix-specific networking functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc7e1fbf723c58f49b9c7b7c9486e8910ff303f" translate="yes" xml:space="preserve">
          <source>Unix-specific primitives available on all unix platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559d58e1a8d746d91fa3600f29dbbb56c9ca25cd" translate="yes" xml:space="preserve">
          <source>UnixDatagram</source>
          <target state="translated">UnixDatagram</target>
        </trans-unit>
        <trans-unit id="67d62a4911bb1e0d83beb3b448aab6df455a9a7a" translate="yes" xml:space="preserve">
          <source>UnixListener</source>
          <target state="translated">UnixListener</target>
        </trans-unit>
        <trans-unit id="941c06c80eb53ce02937637ee16d42217c4f223a" translate="yes" xml:space="preserve">
          <source>UnixStream</source>
          <target state="translated">UnixStream</target>
        </trans-unit>
        <trans-unit id="55add9bdacff5201b17fde89c00c759c2cb86e1e" translate="yes" xml:space="preserve">
          <source>Unless you are in such a situation, higher-level and more foolproof APIs like &lt;code&gt;get&lt;/code&gt; should be preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a444b89922afd7135047b0a62b434579bde022e6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.compare_exchange&quot;&gt;&lt;code&gt;compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">Funciones variadas</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="ae7d5fede6f36ca665efd08ae94669cbd14b7cc6" translate="yes" xml:space="preserve">
          <source>VarsOs::find</source>
          <target state="translated">VarsOs::find</target>
        </trans-unit>
        <trans-unit id="a97602f19f448bb335f850af073a9ce84cd5d88f" translate="yes" xml:space="preserve">
          <source>VarsOs::find_map</source>
          <target state="translated">VarsOs::find_map</target>
        </trans-unit>
        <trans-unit id="3678c5ef82f2cb08bc3b287c092316a2ada00a18" translate="yes" xml:space="preserve">
          <source>VarsOs::flat_map</source>
          <target state="translated">VarsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="e8a42aa17639bc96d10468e86951b455866c4904" translate="yes" xml:space="preserve">
          <source>VarsOs::flatten</source>
          <target state="translated">VarsOs::flatten</target>
        </trans-unit>
        <trans-unit id="46320ba9ecbf055cb2e56af08cec6e628a336f92" translate="yes" xml:space="preserve">
          <source>VarsOs::fmt</source>
          <target state="translated">VarsOs::fmt</target>
        </trans-unit>
        <trans-unit id="7bcbf2e75da1a46894beb596faa2a485d58f6a2d" translate="yes" xml:space="preserve">
          <source>VarsOs::fold</source>
          <target state="translated">VarsOs::fold</target>
        </trans-unit>
        <trans-unit id="51b69162489f5329a52d08395d177be1d60cb6a5" translate="yes" xml:space="preserve">
          <source>VarsOs::for_each</source>
          <target state="translated">VarsOs::for_each</target>
        </trans-unit>
        <trans-unit id="e06ff647273899d3fd4ea62e139dbf757cf3d8cc" translate="yes" xml:space="preserve">
          <source>VarsOs::from</source>
          <target state="translated">VarsOs::from</target>
        </trans-unit>
        <trans-unit id="0245bbf420434587e8ec6bdf35d9cf62a6cde011" translate="yes" xml:space="preserve">
          <source>VarsOs::fuse</source>
          <target state="translated">VarsOs::fuse</target>
        </trans-unit>
        <trans-unit id="479913c8896a1c5102d2a5ea1234f740bfde2328" translate="yes" xml:space="preserve">
          <source>VarsOs::ge</source>
          <target state="translated">VarsOs::ge</target>
        </trans-unit>
        <trans-unit id="17feba1de0fe9c2331df5c53c185c7617b4b8cc1" translate="yes" xml:space="preserve">
          <source>VarsOs::gt</source>
          <target state="translated">VarsOs::gt</target>
        </trans-unit>
        <trans-unit id="3033c2aeecf938c398013c5ab0852cd122a7d6b0" translate="yes" xml:space="preserve">
          <source>VarsOs::inspect</source>
          <target state="translated">VarsOs::inspect</target>
        </trans-unit>
        <trans-unit id="3f0b3d392367dab2dc143ca178da7b4d778bbd17" translate="yes" xml:space="preserve">
          <source>VarsOs::into</source>
          <target state="translated">VarsOs::into</target>
        </trans-unit>
        <trans-unit id="16fa54e40b1321bab910ef3ac287342748aea056" translate="yes" xml:space="preserve">
          <source>VarsOs::into_iter</source>
          <target state="translated">VarsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="5c63504ce660906345551dba943ce8d045612e95" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted</source>
          <target state="translated">VarsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="0fdd66d1bfafd9226a154278db222c3aee97c735" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by</source>
          <target state="translated">VarsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="204163a740d898b80542e502e7da9a7661337b36" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by_key</source>
          <target state="translated">VarsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ae35eac698343e1ee4eeec512aed1c16a136d0c7" translate="yes" xml:space="preserve">
          <source>VarsOs::last</source>
          <target state="translated">VarsOs::last</target>
        </trans-unit>
        <trans-unit id="c01f90cf460a2003e266fcb0b34415121c12b736" translate="yes" xml:space="preserve">
          <source>VarsOs::le</source>
          <target state="translated">VarsOs::le</target>
        </trans-unit>
        <trans-unit id="c0cd86a67a36a78ad1451aca611b8fd991760e20" translate="yes" xml:space="preserve">
          <source>VarsOs::lt</source>
          <target state="translated">VarsOs::lt</target>
        </trans-unit>
        <trans-unit id="1cefab93b3f7c14142541eedb899ab5e71be9fc4" translate="yes" xml:space="preserve">
          <source>VarsOs::map</source>
          <target state="translated">VarsOs::map</target>
        </trans-unit>
        <trans-unit id="e6a8c9754fd49b2d51cbf24ecf6d94304e8e64c3" translate="yes" xml:space="preserve">
          <source>VarsOs::max</source>
          <target state="translated">VarsOs::max</target>
        </trans-unit>
        <trans-unit id="1f1f50d119da0ed96c40d44ea09ef96812375781" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by</source>
          <target state="translated">VarsOs::max_by</target>
        </trans-unit>
        <trans-unit id="0f2e6793ee02c5031cf6cc652fab9884db10bbdb" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by_key</source>
          <target state="translated">VarsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="af3d6a04943a8cf3ad8a6978c4e20520bbd7810c" translate="yes" xml:space="preserve">
          <source>VarsOs::min</source>
          <target state="translated">VarsOs::min</target>
        </trans-unit>
        <trans-unit id="65325562c65c7a37d9553910d80a4c50713493e5" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by</source>
          <target state="translated">VarsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce454f9015d8cd8601694fb53b1aac058cf4ec7c" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by_key</source>
          <target state="translated">VarsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="1c7e1099c4b87dd8e83e87ef896a8fe06530c255" translate="yes" xml:space="preserve">
          <source>VarsOs::ne</source>
          <target state="translated">VarsOs::ne</target>
        </trans-unit>
        <trans-unit id="abe200e7a70bbf42fbb261f3d6ecb1a850953161" translate="yes" xml:space="preserve">
          <source>VarsOs::next</source>
          <target state="translated">VarsOs::next</target>
        </trans-unit>
        <trans-unit id="753f8e880e8ece081c8080be088d05ec0d200f80" translate="yes" xml:space="preserve">
          <source>VarsOs::nth</source>
          <target state="translated">VarsOs::nth</target>
        </trans-unit>
        <trans-unit id="b6af18bf99508b4a2d5aac1fbdfad4b5780a6f74" translate="yes" xml:space="preserve">
          <source>VarsOs::partial_cmp</source>
          <target state="translated">VarsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba0322e8a281d2965f09dafdfe9b78ec1f84e172" translate="yes" xml:space="preserve">
          <source>VarsOs::partition</source>
          <target state="translated">VarsOs::partition</target>
        </trans-unit>
        <trans-unit id="91938a0453fc3e7b7813e5df0009b7580ef490d3" translate="yes" xml:space="preserve">
          <source>VarsOs::peekable</source>
          <target state="translated">VarsOs::peekable</target>
        </trans-unit>
        <trans-unit id="7a37b0e06b2930dc5a294f234caa4a16804177d0" translate="yes" xml:space="preserve">
          <source>VarsOs::position</source>
          <target state="translated">VarsOs::position</target>
        </trans-unit>
        <trans-unit id="4f098ada18205fbc46f5cd22be9968ee3d7b0363" translate="yes" xml:space="preserve">
          <source>VarsOs::product</source>
          <target state="translated">VarsOs::product</target>
        </trans-unit>
        <trans-unit id="6bf84c68f9daffbf302bd074f0e8be5a6ea7823d" translate="yes" xml:space="preserve">
          <source>VarsOs::rev</source>
          <target state="translated">VarsOs::rev</target>
        </trans-unit>
        <trans-unit id="1c60d42a9413b8a7c101dc83c2565f5d37b81a2a" translate="yes" xml:space="preserve">
          <source>VarsOs::rposition</source>
          <target state="translated">VarsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f65790ae1d5619919415f11aef0fe2aee47448a6" translate="yes" xml:space="preserve">
          <source>VarsOs::scan</source>
          <target state="translated">VarsOs::scan</target>
        </trans-unit>
        <trans-unit id="cb8748c599d4e59ff120199769de64e5786ad929" translate="yes" xml:space="preserve">
          <source>VarsOs::size_hint</source>
          <target state="translated">VarsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="3ea59b4b1aae9dc7c132d58be49e094fc8eaa95f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip</source>
          <target state="translated">VarsOs::skip</target>
        </trans-unit>
        <trans-unit id="02c1e6608b48c61896af2016b5b52d75d023957f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip_while</source>
          <target state="translated">VarsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="a0d6c6ad525cb20f675d004819c2121e056f42c8" translate="yes" xml:space="preserve">
          <source>VarsOs::step_by</source>
          <target state="translated">VarsOs::step_by</target>
        </trans-unit>
        <trans-unit id="6846222d088cefb1075c2f24c4eadbd7aed705eb" translate="yes" xml:space="preserve">
          <source>VarsOs::sum</source>
          <target state="translated">VarsOs::sum</target>
        </trans-unit>
        <trans-unit id="91c3203375fe48ab0d3fa32901ee5de67c77a411" translate="yes" xml:space="preserve">
          <source>VarsOs::take</source>
          <target state="translated">VarsOs::take</target>
        </trans-unit>
        <trans-unit id="144ba83f71bf339d2fc7ce6106d27d858be059f1" translate="yes" xml:space="preserve">
          <source>VarsOs::take_while</source>
          <target state="translated">VarsOs::take_while</target>
        </trans-unit>
        <trans-unit id="330e5de6bdd0923300ee2e19673f82661fe3b5aa" translate="yes" xml:space="preserve">
          <source>VarsOs::try_fold</source>
          <target state="translated">VarsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="7f9b1fb25f2d8dc898d57dd0ad57aa6074d0db25" translate="yes" xml:space="preserve">
          <source>VarsOs::try_for_each</source>
          <target state="translated">VarsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="0371b8d74af891c05681249ef7f32d83f6e8d3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::try_from</source>
          <target state="translated">VarsOs::try_from</target>
        </trans-unit>
        <trans-unit id="45aa3acec5ebcabeaf089da80e453c0f5f80cd2d" translate="yes" xml:space="preserve">
          <source>VarsOs::try_into</source>
          <target state="translated">VarsOs::try_into</target>
        </trans-unit>
        <trans-unit id="24d5d9ef2bba5983d72962681554163d3cc0d7ea" translate="yes" xml:space="preserve">
          <source>VarsOs::type_id</source>
          <target state="translated">VarsOs::type_id</target>
        </trans-unit>
        <trans-unit id="3e592311e132f7aa730baaf56aa5dd0ae220e3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::unzip</source>
          <target state="translated">VarsOs::unzip</target>
        </trans-unit>
        <trans-unit id="e4769bb4e270bd8e779d33f3cae641957c2527b8" translate="yes" xml:space="preserve">
          <source>VarsOs::zip</source>
          <target state="translated">VarsOs::zip</target>
        </trans-unit>
        <trans-unit id="3e8f48ebd55451a20501b45af4a4265976d600b6" translate="yes" xml:space="preserve">
          <source>Vec</source>
          <target state="translated">Vec</target>
        </trans-unit>
        <trans-unit id="9e8ec9d213a0da31ccaaba571b14789e42b08935" translate="yes" xml:space="preserve">
          <source>Vec::align_to</source>
          <target state="translated">Vec::align_to</target>
        </trans-unit>
        <trans-unit id="a6107ed66afb53f802511a5a643ee8656e497b0a" translate="yes" xml:space="preserve">
          <source>Vec::align_to_mut</source>
          <target state="translated">Vec::align_to_mut</target>
        </trans-unit>
        <trans-unit id="f61abeec7dd01f8c47bf83db4b4d0456a9af5e0b" translate="yes" xml:space="preserve">
          <source>Vec::append</source>
          <target state="translated">Vec::append</target>
        </trans-unit>
        <trans-unit id="966721890fa8492f6b4046bd9708da68c72adc73" translate="yes" xml:space="preserve">
          <source>Vec::as_mut</source>
          <target state="translated">Vec::as_mut</target>
        </trans-unit>
        <trans-unit id="831194353af948439212b65f5180ee63686be5ff" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_ptr</source>
          <target state="translated">Vec::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="2cd229f1c1c1c67e55b523142a4b5506c79ab5e4" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_slice</source>
          <target state="translated">Vec::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="c1e6da016e5f4ce35006127886b4b180eede68b8" translate="yes" xml:space="preserve">
          <source>Vec::as_ptr</source>
          <target state="translated">Vec::as_ptr</target>
        </trans-unit>
        <trans-unit id="8b5099d8e9c3e715862b2b38f181235c7cc24477" translate="yes" xml:space="preserve">
          <source>Vec::as_ref</source>
          <target state="translated">Vec::as_ref</target>
        </trans-unit>
        <trans-unit id="e50619a5c819f0a35e08edd227565f793562e4c8" translate="yes" xml:space="preserve">
          <source>Vec::as_slice</source>
          <target state="translated">Vec::as_slice</target>
        </trans-unit>
        <trans-unit id="0fd5dd3c29cf93dd4e97ef65f08a9644b11adf66" translate="yes" xml:space="preserve">
          <source>Vec::binary_search</source>
          <target state="translated">Vec::binary_search</target>
        </trans-unit>
        <trans-unit id="b52fc5259d9a5986689a231729ba2250dccdf822" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by</source>
          <target state="translated">Vec::binary_search_by</target>
        </trans-unit>
        <trans-unit id="c25875b591cdd49de2d27d47ee6d7ac1e21d9162" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by_key</source>
          <target state="translated">Vec::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="85bd126983a102e0968ff3a77e6cc098a02d6d2b" translate="yes" xml:space="preserve">
          <source>Vec::borrow</source>
          <target state="translated">Vec::borrow</target>
        </trans-unit>
        <trans-unit id="ce949f50884f71dd9c3bd065b3e9f2fac3e1b9b1" translate="yes" xml:space="preserve">
          <source>Vec::borrow_mut</source>
          <target state="translated">Vec::borrow_mut</target>
        </trans-unit>
        <trans-unit id="adf16c9ee55ed12543d9f09958b2da182d391549" translate="yes" xml:space="preserve">
          <source>Vec::by_ref</source>
          <target state="translated">Vec::by_ref</target>
        </trans-unit>
        <trans-unit id="879e3baf25a9301dece592c8e2fe831ab282b68c" translate="yes" xml:space="preserve">
          <source>Vec::capacity</source>
          <target state="translated">Vec::capacity</target>
        </trans-unit>
        <trans-unit id="0008361e288cf11981ce829d1646ffd8fcfd353d" translate="yes" xml:space="preserve">
          <source>Vec::chunks</source>
          <target state="translated">Vec::chunks</target>
        </trans-unit>
        <trans-unit id="753b8583ee481b3421bba7d981070ec72378a929" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact</source>
          <target state="translated">Vec::chunks_exact</target>
        </trans-unit>
        <trans-unit id="c16f1e8e4bdb33b2b62eb139dbdd695cce8cd9cb" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact_mut</source>
          <target state="translated">Vec::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="5129df9df37eeb41ed7c2d7d9a8c46bfb809e00b" translate="yes" xml:space="preserve">
          <source>Vec::chunks_mut</source>
          <target state="translated">Vec::chunks_mut</target>
        </trans-unit>
        <trans-unit id="b0c0c66afeddeab3613458326ddff56179dee6c6" translate="yes" xml:space="preserve">
          <source>Vec::clamp</source>
          <target state="translated">Vec::clamp</target>
        </trans-unit>
        <trans-unit id="2c2fbd7321fb15ce32f39380f1451dd1d8285167" translate="yes" xml:space="preserve">
          <source>Vec::clear</source>
          <target state="translated">Vec::clear</target>
        </trans-unit>
        <trans-unit id="f74617c56b1b4cb0ac739e41c8d386b187a932a0" translate="yes" xml:space="preserve">
          <source>Vec::clone</source>
          <target state="translated">Vec::clone</target>
        </trans-unit>
        <trans-unit id="7d2eba94d2d4e553221edef828d32477a74ec086" translate="yes" xml:space="preserve">
          <source>Vec::clone_from</source>
          <target state="translated">Vec::clone_from</target>
        </trans-unit>
        <trans-unit id="d765a16b06a09ff23e51adef46f6c11da8454339" translate="yes" xml:space="preserve">
          <source>Vec::clone_from_slice</source>
          <target state="translated">Vec::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="33b8cb435611a78c3d465aaa7784c2b37cbb74e7" translate="yes" xml:space="preserve">
          <source>Vec::clone_into</source>
          <target state="translated">Vec::clone_into</target>
        </trans-unit>
        <trans-unit id="54c91e49e772a616e17900001275475155f0db86" translate="yes" xml:space="preserve">
          <source>Vec::cmp</source>
          <target state="translated">Vec::cmp</target>
        </trans-unit>
        <trans-unit id="0a3297559d1b2d0f5e9d86fb8e4f2702a52aed73" translate="yes" xml:space="preserve">
          <source>Vec::contains</source>
          <target state="translated">Vec::contains</target>
        </trans-unit>
        <trans-unit id="15b499228e83cdfe5d9bacf8f2717eb38b48f38b" translate="yes" xml:space="preserve">
          <source>Vec::copy_from_slice</source>
          <target state="translated">Vec::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="b8ba6b02b6ab7d9e4a58c6ff8c4f8ed29c394009" translate="yes" xml:space="preserve">
          <source>Vec::copy_within</source>
          <target state="translated">Vec::copy_within</target>
        </trans-unit>
        <trans-unit id="789846c5e092b1b0a4c096dc5aa2920af554cadf" translate="yes" xml:space="preserve">
          <source>Vec::dedup</source>
          <target state="translated">Vec::dedup</target>
        </trans-unit>
        <trans-unit id="ef8409a58825c28ce8665f515341da99406dc45e" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by</source>
          <target state="translated">Vec::dedup_by</target>
        </trans-unit>
        <trans-unit id="363d4ee344588ea07c6bc5cfb25580f99e4e6fc4" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by_key</source>
          <target state="translated">Vec::dedup_by_key</target>
        </trans-unit>
        <trans-unit id="1a3c24e46d01efcb53b2e47b9f9fe05604eec885" translate="yes" xml:space="preserve">
          <source>Vec::default</source>
          <target state="translated">Vec::default</target>
        </trans-unit>
        <trans-unit id="b1a2319f3d6321033c9832ada871bb0364c41d6d" translate="yes" xml:space="preserve">
          <source>Vec::deref</source>
          <target state="translated">Vec::deref</target>
        </trans-unit>
        <trans-unit id="700ab6732dec0f913d9f30592a8a083e6275f0e9" translate="yes" xml:space="preserve">
          <source>Vec::deref_mut</source>
          <target state="translated">Vec::deref_mut</target>
        </trans-unit>
        <trans-unit id="5b692065705c3002050f3bc84600cd18eab70011" translate="yes" xml:space="preserve">
          <source>Vec::drain</source>
          <target state="translated">Vec::drain</target>
        </trans-unit>
        <trans-unit id="b56f02a07b5d1e06767ba9089e5a26237d2b6e96" translate="yes" xml:space="preserve">
          <source>Vec::drain_filter</source>
          <target state="translated">Vec::drain_filter</target>
        </trans-unit>
        <trans-unit id="1590e7c585be22084bde77caac361ebaa4d26167" translate="yes" xml:space="preserve">
          <source>Vec::drop</source>
          <target state="translated">Vec::drop</target>
        </trans-unit>
        <trans-unit id="c4e9c1a11aab0c3fbaa646a64a22f3069178f1e1" translate="yes" xml:space="preserve">
          <source>Vec::ends_with</source>
          <target state="translated">Vec::ends_with</target>
        </trans-unit>
        <trans-unit id="6460efc15d9228e5937dc4d9b4bb45990d32a27e" translate="yes" xml:space="preserve">
          <source>Vec::eq</source>
          <target state="translated">Vec::eq</target>
        </trans-unit>
        <trans-unit id="8e07e8d35672a19e43e8097f16c00d816c5cbe97" translate="yes" xml:space="preserve">
          <source>Vec::eq_ignore_ascii_case</source>
          <target state="translated">Vec::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="e46b7aa4e045855309d716fccf00cabd75a21e77" translate="yes" xml:space="preserve">
          <source>Vec::extend</source>
          <target state="translated">Vec::extend</target>
        </trans-unit>
        <trans-unit id="bb82f4df3cb27f5fbf87e6541ca1f465f414d3a5" translate="yes" xml:space="preserve">
          <source>Vec::extend_from_slice</source>
          <target state="translated">Vec::extend_from_slice</target>
        </trans-unit>
        <trans-unit id="87732cce3e95948f8d258db19ab24839895b0f76" translate="yes" xml:space="preserve">
          <source>Vec::first</source>
          <target state="translated">Vec::first</target>
        </trans-unit>
        <trans-unit id="fd582f0cbcb6e9f15ed28c1811608a7720bbbf52" translate="yes" xml:space="preserve">
          <source>Vec::first_mut</source>
          <target state="translated">Vec::first_mut</target>
        </trans-unit>
        <trans-unit id="cea112245a192a2715a4ac0d0d4ca6f9f0c88d11" translate="yes" xml:space="preserve">
          <source>Vec::flush</source>
          <target state="translated">Vec::flush</target>
        </trans-unit>
        <trans-unit id="74c0bff699639364b714e18c5e924ebe36d7bbb8" translate="yes" xml:space="preserve">
          <source>Vec::fmt</source>
          <target state="translated">Vec::fmt</target>
        </trans-unit>
        <trans-unit id="3b03e0120686cad397d6fe329718262a73208e9a" translate="yes" xml:space="preserve">
          <source>Vec::from</source>
          <target state="translated">Vec::from</target>
        </trans-unit>
        <trans-unit id="d2409bb7c2f488110f44be1023fc83c93200bfb1" translate="yes" xml:space="preserve">
          <source>Vec::from_iter</source>
          <target state="translated">Vec::from_iter</target>
        </trans-unit>
        <trans-unit id="e5b23b921224c968a51d83bca668d1740812f940" translate="yes" xml:space="preserve">
          <source>Vec::from_raw_parts</source>
          <target state="translated">Vec::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1b86c87d45b678c05eaedfa482e8e125c09283aa" translate="yes" xml:space="preserve">
          <source>Vec::ge</source>
          <target state="translated">Vec::ge</target>
        </trans-unit>
        <trans-unit id="a36985c63a8174e8d6e9d553daa519abe7ef73a3" translate="yes" xml:space="preserve">
          <source>Vec::get</source>
          <target state="translated">Vec::get</target>
        </trans-unit>
        <trans-unit id="55451d4c9012f0e9dc2705a9a20313c583cbad02" translate="yes" xml:space="preserve">
          <source>Vec::get_mut</source>
          <target state="translated">Vec::get_mut</target>
        </trans-unit>
        <trans-unit id="fbd1dbfc28f1dbf35081eb8a3b624e1ddb17a7d4" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked</source>
          <target state="translated">Vec::get_unchecked</target>
        </trans-unit>
        <trans-unit id="17aa782943cb8ba6f59f4076d63241b08687fe04" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked_mut</source>
          <target state="translated">Vec::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="12e2684fc2a72b4cdaf5511139faebcd74106115" translate="yes" xml:space="preserve">
          <source>Vec::gt</source>
          <target state="translated">Vec::gt</target>
        </trans-unit>
        <trans-unit id="3214576db0b2f915d4813a780951e762d0453108" translate="yes" xml:space="preserve">
          <source>Vec::hash</source>
          <target state="translated">Vec::hash</target>
        </trans-unit>
        <trans-unit id="cbad63e4de555a52c1156aacfa7acaa37d288f2d" translate="yes" xml:space="preserve">
          <source>Vec::hash_slice</source>
          <target state="translated">Vec::hash_slice</target>
        </trans-unit>
        <trans-unit id="817acc1f56c6b7266c14b400f36bd6915fc69aa9" translate="yes" xml:space="preserve">
          <source>Vec::index</source>
          <target state="translated">Vec::index</target>
        </trans-unit>
        <trans-unit id="255317cd139deae7b3798accef614b86d687af60" translate="yes" xml:space="preserve">
          <source>Vec::index_mut</source>
          <target state="translated">Vec::index_mut</target>
        </trans-unit>
        <trans-unit id="dae9879e89996749967d788919fd3919726095e5" translate="yes" xml:space="preserve">
          <source>Vec::insert</source>
          <target state="translated">Vec::insert</target>
        </trans-unit>
        <trans-unit id="4607993cbee4135669d2825495742a160937c51e" translate="yes" xml:space="preserve">
          <source>Vec::into</source>
          <target state="translated">Vec::into</target>
        </trans-unit>
        <trans-unit id="349c4bbf0cf7617a82524fff4ab6dd6dc12191ae" translate="yes" xml:space="preserve">
          <source>Vec::into_boxed_slice</source>
          <target state="translated">Vec::into_boxed_slice</target>
        </trans-unit>
        <trans-unit id="a2683d7c8a491dd1d14d82cbf394796000e6a7fa" translate="yes" xml:space="preserve">
          <source>Vec::into_iter</source>
          <target state="translated">Vec::into_iter</target>
        </trans-unit>
        <trans-unit id="0617d70073dd3ee36b70acc3469082e13a466d03" translate="yes" xml:space="preserve">
          <source>Vec::is_ascii</source>
          <target state="translated">Vec::is_ascii</target>
        </trans-unit>
        <trans-unit id="03169a81c036f8a9e76093b58242f30ae578d6e1" translate="yes" xml:space="preserve">
          <source>Vec::is_empty</source>
          <target state="translated">Vec::is_empty</target>
        </trans-unit>
        <trans-unit id="61e088912bf7c1fb5b0f0a806c372825ce419a0f" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted</source>
          <target state="translated">Vec::is_sorted</target>
        </trans-unit>
        <trans-unit id="2f71d97de0d886a25068ec904913d5f995b9ec67" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by</source>
          <target state="translated">Vec::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="13b69e903c4a68fcfe01f0c6f71a43d7cffcb8d2" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by_key</source>
          <target state="translated">Vec::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="67f810a4a6906d879a0e5bcdbd0629cdca0805fc" translate="yes" xml:space="preserve">
          <source>Vec::iter</source>
          <target state="translated">Vec::iter</target>
        </trans-unit>
        <trans-unit id="de14eea28b8af3ebd1fa7277134614ec35bede5f" translate="yes" xml:space="preserve">
          <source>Vec::iter_mut</source>
          <target state="translated">Vec::iter_mut</target>
        </trans-unit>
        <trans-unit id="89cb435951d0739bd80a43fd6eff389c96ea9137" translate="yes" xml:space="preserve">
          <source>Vec::last</source>
          <target state="translated">Vec::last</target>
        </trans-unit>
        <trans-unit id="8ec2cd17a9007516bf67a64facc2086a511ddabc" translate="yes" xml:space="preserve">
          <source>Vec::last_mut</source>
          <target state="translated">Vec::last_mut</target>
        </trans-unit>
        <trans-unit id="fbceeb72cec6860fa83702dbf07c61c0fba92768" translate="yes" xml:space="preserve">
          <source>Vec::le</source>
          <target state="translated">Vec::le</target>
        </trans-unit>
        <trans-unit id="525552cdf64c17bf1df49d77d5e10db05c4a1e65" translate="yes" xml:space="preserve">
          <source>Vec::len</source>
          <target state="translated">Vec::len</target>
        </trans-unit>
        <trans-unit id="1987ee0ae7df89f62926afad448cc8dcba8deb75" translate="yes" xml:space="preserve">
          <source>Vec::lt</source>
          <target state="translated">Vec::lt</target>
        </trans-unit>
        <trans-unit id="d73c1ce0cf0d3ba3f02694929282ef1ce4003f43" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_lowercase</source>
          <target state="translated">Vec::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="c984649eda1457369a83cadb8cb7cced71d85e8a" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_uppercase</source>
          <target state="translated">Vec::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="a14d3f9cce464f0a15bfb1ccdba70544cd9996dc" translate="yes" xml:space="preserve">
          <source>Vec::max</source>
          <target state="translated">Vec::max</target>
        </trans-unit>
        <trans-unit id="b7e2ddaad5a1e72a47531993b322493826992f01" translate="yes" xml:space="preserve">
          <source>Vec::min</source>
          <target state="translated">Vec::min</target>
        </trans-unit>
        <trans-unit id="27ac869c9c4d65022ccbe3db59b454048dac5d01" translate="yes" xml:space="preserve">
          <source>Vec::ne</source>
          <target state="translated">Vec::ne</target>
        </trans-unit>
        <trans-unit id="6fd848867337ba44b23b17c9fe00c94d829ea233" translate="yes" xml:space="preserve">
          <source>Vec::new</source>
          <target state="translated">Vec::new</target>
        </trans-unit>
        <trans-unit id="dcf8d5a328aa406810dabf32cd5ae01b3697decb" translate="yes" xml:space="preserve">
          <source>Vec::partial_cmp</source>
          <target state="translated">Vec::partial_cmp</target>
        </trans-unit>
        <trans-unit id="9694e7862ef0e60d886fd728679d90a8ee9470af" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index</source>
          <target state="translated">Vec::partition_at_index</target>
        </trans-unit>
        <trans-unit id="0bf6ca8cb659d720aa701bffc2851bc20dd39575" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by</source>
          <target state="translated">Vec::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="e14cd1ff21e7d949dfbecf45a57afb30d74ae935" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by_key</source>
          <target state="translated">Vec::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="a3bcf68a32491f6ce459bed1b83a0728f8d3facb" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup</source>
          <target state="translated">Vec::partition_dedup</target>
        </trans-unit>
        <trans-unit id="b33b907d031cab1a9f82dfabed52b3ec36a0bec7" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by</source>
          <target state="translated">Vec::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="e9042527cd9f8f7b837ac9979689f102fa5b9413" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by_key</source>
          <target state="translated">Vec::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="bb66cba5fa2c2be8852cc1be9f1f0442c400f3c1" translate="yes" xml:space="preserve">
          <source>Vec::pop</source>
          <target state="translated">Vec::pop</target>
        </trans-unit>
        <trans-unit id="015702c3beb31216ec8635f66c58b2dd6c7ce7d3" translate="yes" xml:space="preserve">
          <source>Vec::push</source>
          <target state="translated">Vec::push</target>
        </trans-unit>
        <trans-unit id="2a4ecb67c06267aff12807a92f7519558492cac3" translate="yes" xml:space="preserve">
          <source>Vec::rchunks</source>
          <target state="translated">Vec::rchunks</target>
        </trans-unit>
        <trans-unit id="2190a180c9e13d2c97a99729fb1cab9822f2b367" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact</source>
          <target state="translated">Vec::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="8817d4c686ebb9e3df7649dc1ef10bbfc99e5a0f" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact_mut</source>
          <target state="translated">Vec::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="d8b31989d0600b79568eabfbd02443e705c374f4" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_mut</source>
          <target state="translated">Vec::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="845831747d56f3eeb00bb35e02809974b407e592" translate="yes" xml:space="preserve">
          <source>Vec::remove</source>
          <target state="translated">Vec::remove</target>
        </trans-unit>
        <trans-unit id="f2019e8c59ea1c039539318392c79102cc50f496" translate="yes" xml:space="preserve">
          <source>Vec::remove_item</source>
          <target state="translated">Vec::remove_item</target>
        </trans-unit>
        <trans-unit id="2a5af4f0d9906283d3505112b8edea1ff6aa8327" translate="yes" xml:space="preserve">
          <source>Vec::repeat</source>
          <target state="translated">Vec::repeat</target>
        </trans-unit>
        <trans-unit id="4030131e8b0f427754fca9b6fc2438b48ee132aa" translate="yes" xml:space="preserve">
          <source>Vec::reserve</source>
          <target state="translated">Vec::reserve</target>
        </trans-unit>
        <trans-unit id="c585b5b6b44dd8ead3846dfe6ff450a1d78b7ca4" translate="yes" xml:space="preserve">
          <source>Vec::reserve_exact</source>
          <target state="translated">Vec::reserve_exact</target>
        </trans-unit>
        <trans-unit id="abcfd065a68ab661075eb65973b1c2983f76906b" translate="yes" xml:space="preserve">
          <source>Vec::resize</source>
          <target state="translated">Vec::resize</target>
        </trans-unit>
        <trans-unit id="f9f7275b35ba8425eb32e3d8e98e0b77a08d75b9" translate="yes" xml:space="preserve">
          <source>Vec::resize_default</source>
          <target state="translated">Vec::resize_default</target>
        </trans-unit>
        <trans-unit id="9f1a1a7d355751c7299454f0938fedf8e60dd549" translate="yes" xml:space="preserve">
          <source>Vec::resize_with</source>
          <target state="translated">Vec::resize_with</target>
        </trans-unit>
        <trans-unit id="fd564ef5b54702a40658f77d501d340f02796c3b" translate="yes" xml:space="preserve">
          <source>Vec::retain</source>
          <target state="translated">Vec::retain</target>
        </trans-unit>
        <trans-unit id="020a2b7b3ef0fc23c178b5a1d57cf3220ce5e5ff" translate="yes" xml:space="preserve">
          <source>Vec::reverse</source>
          <target state="translated">Vec::reverse</target>
        </trans-unit>
        <trans-unit id="b4c1d9424701ec16b3d33474bf2a08c4a985a07b" translate="yes" xml:space="preserve">
          <source>Vec::rotate_left</source>
          <target state="translated">Vec::rotate_left</target>
        </trans-unit>
        <trans-unit id="a21a400e9268e082bb2ce482e8a8dfc6ab09fcf1" translate="yes" xml:space="preserve">
          <source>Vec::rotate_right</source>
          <target state="translated">Vec::rotate_right</target>
        </trans-unit>
        <trans-unit id="230272571f5aeb260545461fbf996bc487081e16" translate="yes" xml:space="preserve">
          <source>Vec::rsplit</source>
          <target state="translated">Vec::rsplit</target>
        </trans-unit>
        <trans-unit id="7588b43de214dc9942b6ec718d4f47a2bcedcba0" translate="yes" xml:space="preserve">
          <source>Vec::rsplit_mut</source>
          <target state="translated">Vec::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="7d1297a0cd4e2ea121ae3252d869a3ab0996a1d6" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn</source>
          <target state="translated">Vec::rsplitn</target>
        </trans-unit>
        <trans-unit id="62a275a0772dd8dc1d1984c12daaf575f3aeeba5" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn_mut</source>
          <target state="translated">Vec::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="b0b31a5d59982433104183b210cdc7f9a7187cc9" translate="yes" xml:space="preserve">
          <source>Vec::set_len</source>
          <target state="translated">Vec::set_len</target>
        </trans-unit>
        <trans-unit id="dcf4c0bec18deb050ca3760e0ffcb5fbdd9b508d" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to</source>
          <target state="translated">Vec::shrink_to</target>
        </trans-unit>
        <trans-unit id="85ba0030d7417692c1610e814b9b07a58d76e77c" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to_fit</source>
          <target state="translated">Vec::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="16d167d14ba9fe06f16ed99bae2a2c03419b826b" translate="yes" xml:space="preserve">
          <source>Vec::sort</source>
          <target state="translated">Vec::sort</target>
        </trans-unit>
        <trans-unit id="81d8d3adb266cd3ddbf5075796bf792188963e60" translate="yes" xml:space="preserve">
          <source>Vec::sort_by</source>
          <target state="translated">Vec::sort_by</target>
        </trans-unit>
        <trans-unit id="fdaa89a60d5801892ad1d2af91cf732bf0fa3243" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_cached_key</source>
          <target state="translated">Vec::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="d7a763e74650730d9254a393db15ca96341ce8b4" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_key</source>
          <target state="translated">Vec::sort_by_key</target>
        </trans-unit>
        <trans-unit id="abf375eb46a47b0a7dc0651c427daa5777cdc87d" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable</source>
          <target state="translated">Vec::sort_unstable</target>
        </trans-unit>
        <trans-unit id="6b1b6c683e214a704567cbb4866e258d5339b1a6" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by</source>
          <target state="translated">Vec::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="98bc35f1fee62d3c06dfa775a7a509e42577ec92" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by_key</source>
          <target state="translated">Vec::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="32db21414779495d647f8b90a008c9ef3267c648" translate="yes" xml:space="preserve">
          <source>Vec::splice</source>
          <target state="translated">Vec::splice</target>
        </trans-unit>
        <trans-unit id="a29a88b90b2283fcc62467ac92b894872c49e16c" translate="yes" xml:space="preserve">
          <source>Vec::split</source>
          <target state="translated">Vec::split</target>
        </trans-unit>
        <trans-unit id="6850cc7f3a18a5ae8795a517214f52bd03e37d1b" translate="yes" xml:space="preserve">
          <source>Vec::split_at</source>
          <target state="translated">Vec::split_at</target>
        </trans-unit>
        <trans-unit id="fffa7968cc458ceca06542d5bd41cbc6ab30cf0c" translate="yes" xml:space="preserve">
          <source>Vec::split_at_mut</source>
          <target state="translated">Vec::split_at_mut</target>
        </trans-unit>
        <trans-unit id="a158f5776929dc5fa591347c97af279ee6f308b5" translate="yes" xml:space="preserve">
          <source>Vec::split_first</source>
          <target state="translated">Vec::split_first</target>
        </trans-unit>
        <trans-unit id="6bc5d749a8be60dd619275925ca3abe61e1f1d9c" translate="yes" xml:space="preserve">
          <source>Vec::split_first_mut</source>
          <target state="translated">Vec::split_first_mut</target>
        </trans-unit>
        <trans-unit id="37a2c9e4c660e48769312c66dd3af4005f29a265" translate="yes" xml:space="preserve">
          <source>Vec::split_last</source>
          <target state="translated">Vec::split_last</target>
        </trans-unit>
        <trans-unit id="18a1b33cf122a212120639e6c43b624cc50e7d15" translate="yes" xml:space="preserve">
          <source>Vec::split_last_mut</source>
          <target state="translated">Vec::split_last_mut</target>
        </trans-unit>
        <trans-unit id="cf6ca76593d5b57fc21960139169843fb9cd7b00" translate="yes" xml:space="preserve">
          <source>Vec::split_mut</source>
          <target state="translated">Vec::split_mut</target>
        </trans-unit>
        <trans-unit id="03a916c0fcda14cb715141144403e9cf172139de" translate="yes" xml:space="preserve">
          <source>Vec::split_off</source>
          <target state="translated">Vec::split_off</target>
        </trans-unit>
        <trans-unit id="07108e7065deeacdbce3703bf0867dca70e0aa63" translate="yes" xml:space="preserve">
          <source>Vec::splitn</source>
          <target state="translated">Vec::splitn</target>
        </trans-unit>
        <trans-unit id="670a558b46826ad5134c813b4ea72c5f594e6c9a" translate="yes" xml:space="preserve">
          <source>Vec::splitn_mut</source>
          <target state="translated">Vec::splitn_mut</target>
        </trans-unit>
        <trans-unit id="0c0afbd8febc9c5f973424fd46f0e38ed59ccbe9" translate="yes" xml:space="preserve">
          <source>Vec::starts_with</source>
          <target state="translated">Vec::starts_with</target>
        </trans-unit>
        <trans-unit id="ad111eb0f36abc808f9f63d831dd393671b7d60f" translate="yes" xml:space="preserve">
          <source>Vec::swap</source>
          <target state="translated">Vec::swap</target>
        </trans-unit>
        <trans-unit id="c2d87a017cf8d077c99bd71bef846182121ea2f2" translate="yes" xml:space="preserve">
          <source>Vec::swap_remove</source>
          <target state="translated">Vec::swap_remove</target>
        </trans-unit>
        <trans-unit id="65ba4dcc752fbaf145dfc393c0ebd072c03850f4" translate="yes" xml:space="preserve">
          <source>Vec::swap_with_slice</source>
          <target state="translated">Vec::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="187dcbc4c913473ea9ecc0da0ece64f155078f4d" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_lowercase</source>
          <target state="translated">Vec::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="9e994a24d814eaa773517353561f7db1763ba8c8" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_uppercase</source>
          <target state="translated">Vec::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2d58122faa3b804afda87ac1afe94b0c2cf49a62" translate="yes" xml:space="preserve">
          <source>Vec::to_owned</source>
          <target state="translated">Vec::to_owned</target>
        </trans-unit>
        <trans-unit id="8295dc906018a2b87ebb59e81316a74736c8fba2" translate="yes" xml:space="preserve">
          <source>Vec::to_vec</source>
          <target state="translated">Vec::to_vec</target>
        </trans-unit>
        <trans-unit id="bbcf834cd40bf8d351710e8898b52c0706e47891" translate="yes" xml:space="preserve">
          <source>Vec::truncate</source>
          <target state="translated">Vec::truncate</target>
        </trans-unit>
        <trans-unit id="b539d40fa6817c484aec79eab2f72f8b069cd61a" translate="yes" xml:space="preserve">
          <source>Vec::try_from</source>
          <target state="translated">Vec::try_from</target>
        </trans-unit>
        <trans-unit id="edfbddcc1f5344a46cf8226a51d4480baae3f991" translate="yes" xml:space="preserve">
          <source>Vec::try_into</source>
          <target state="translated">Vec::try_into</target>
        </trans-unit>
        <trans-unit id="5c86c8fb54973c689718f247d2725be10c514476" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve</source>
          <target state="translated">Vec::try_reserve</target>
        </trans-unit>
        <trans-unit id="31147313c7e8fcea891f9a87a61ed1563dcc2831" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve_exact</source>
          <target state="translated">Vec::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="eed582f83a9d0aa9e1d0f2c268a23f8e413a6328" translate="yes" xml:space="preserve">
          <source>Vec::type_id</source>
          <target state="translated">Vec::type_id</target>
        </trans-unit>
        <trans-unit id="464742f01bb0869c25eb2800b7d8db8a1c7aac11" translate="yes" xml:space="preserve">
          <source>Vec::windows</source>
          <target state="translated">Vec::windows</target>
        </trans-unit>
        <trans-unit id="5728e3095df170ba310bd22e53f060f7088cdde8" translate="yes" xml:space="preserve">
          <source>Vec::with_capacity</source>
          <target state="translated">Vec::with_capacity</target>
        </trans-unit>
        <trans-unit id="265d2eb25b96552c36adc69855110dc3fd58c9aa" translate="yes" xml:space="preserve">
          <source>Vec::write</source>
          <target state="translated">Vec::write</target>
        </trans-unit>
        <trans-unit id="aeb1c503a25270fdde3115b7ad8a988a9c161a9d" translate="yes" xml:space="preserve">
          <source>Vec::write_all</source>
          <target state="translated">Vec::write_all</target>
        </trans-unit>
        <trans-unit id="bdef50740c7daaafaaf5156f90836f0887c73803" translate="yes" xml:space="preserve">
          <source>Vec::write_fmt</source>
          <target state="translated">Vec::write_fmt</target>
        </trans-unit>
        <trans-unit id="fb5d72587567483189e25ea2273df15eb40edb69" translate="yes" xml:space="preserve">
          <source>Vec::write_vectored</source>
          <target state="translated">Vec::write_vectored</target>
        </trans-unit>
        <trans-unit id="d8b188dca79494d553b4a25f8e7ba135fd059e06" translate="yes" xml:space="preserve">
          <source>VecDeque</source>
          <target state="translated">VecDeque</target>
        </trans-unit>
        <trans-unit id="daac388a0835b2f7f116ce4b930ba45f24e2d4f5" translate="yes" xml:space="preserve">
          <source>VecDeque::append</source>
          <target state="translated">VecDeque::append</target>
        </trans-unit>
        <trans-unit id="131f1606d9fb60120a570fc56345c3b4206cde68" translate="yes" xml:space="preserve">
          <source>VecDeque::as_mut_slices</source>
          <target state="translated">VecDeque::as_mut_slices</target>
        </trans-unit>
        <trans-unit id="e9e3cfebdd186278d399abad0a429053157088f8" translate="yes" xml:space="preserve">
          <source>VecDeque::as_slices</source>
          <target state="translated">VecDeque::as_slices</target>
        </trans-unit>
        <trans-unit id="0edc19e4ca1884e4aacf2a2a4380274826fb2740" translate="yes" xml:space="preserve">
          <source>VecDeque::back</source>
          <target state="translated">VecDeque::back</target>
        </trans-unit>
        <trans-unit id="ccf30a4382ae9328f9552afa5c5dfcfb35aef1b4" translate="yes" xml:space="preserve">
          <source>VecDeque::back_mut</source>
          <target state="translated">VecDeque::back_mut</target>
        </trans-unit>
        <trans-unit id="1d2610cb9f7282ea37e182a5f5c322a259c73e56" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow</source>
          <target state="translated">VecDeque::borrow</target>
        </trans-unit>
        <trans-unit id="c85001c25549712efa3bc4037af617403882f850" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow_mut</source>
          <target state="translated">VecDeque::borrow_mut</target>
        </trans-unit>
        <trans-unit id="50c2744064aa2c0045027447f96537e071e16754" translate="yes" xml:space="preserve">
          <source>VecDeque::capacity</source>
          <target state="translated">VecDeque::capacity</target>
        </trans-unit>
        <trans-unit id="d9ea40fef888b1aa5e6f0be9bc6eb9c5f0603d26" translate="yes" xml:space="preserve">
          <source>VecDeque::clamp</source>
          <target state="translated">VecDeque::clamp</target>
        </trans-unit>
        <trans-unit id="cef7bd89bf4a4eb9ba33004328fb058621269fe0" translate="yes" xml:space="preserve">
          <source>VecDeque::clear</source>
          <target state="translated">VecDeque::clear</target>
        </trans-unit>
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
