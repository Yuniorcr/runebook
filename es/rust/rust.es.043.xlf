<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da42c45b54f4237c99325204711121b9f08beec" translate="yes" xml:space="preserve">
          <source>All kinds of ASCII whitespace are considered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e530c202d9d3c48672f8f7b98a14e41befed3be" translate="yes" xml:space="preserve">
          <source>All kinds of whitespace are considered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c42bdece20642dd1d10ab718ff507235d349b8d" translate="yes" xml:space="preserve">
          <source>All layouts have an associated non-negative size and a power-of-two alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f70044558e382c5ebf59ec68e9d711cc2cb7b2" translate="yes" xml:space="preserve">
          <source>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it&amp;rsquo;s higher level but don&amp;rsquo;t impose a runtime performance penalty for doing so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dabbf042cc2454dd1f0ba98c8b7c6f3be65ec5" translate="yes" xml:space="preserve">
          <source>All of the logic that manages the counts and value dropping is built into &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; and their implementations of the &lt;code&gt;Drop&lt;/code&gt; trait. By specifying that the relationship from a child to its parent should be a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; reference in the definition of &lt;code&gt;Node&lt;/code&gt;, you&amp;rsquo;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469c3254d30ae896569972fb8c0f6e762f31a91d" translate="yes" xml:space="preserve">
          <source>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c09f50beeaa399a934ba76d5cc5d913f4961d31" translate="yes" xml:space="preserve">
          <source>All of these are valid &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3488f647e2016335e532591f4617d056149f656a" translate="yes" xml:space="preserve">
          <source>All of these method calls are possible because we specified how the &lt;code&gt;next&lt;/code&gt; method works, and the standard library provides default implementations for other methods that call &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8409870b71900361c6e9ce41cc4d8b31f5a720" translate="yes" xml:space="preserve">
          <source>All options are initially set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec813890e4d07a2defc7bce522b39b7b6522a4d" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;inline&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110d2b10be35d17317e6c561cf91a4fabbf8e826" translate="yes" xml:space="preserve">
          <source>All other characters are given hexadecimal Unicode escapes; see &lt;a href=&quot;#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76ce538d07b9974a525f600e48b7f5dff4ae16c" translate="yes" xml:space="preserve">
          <source>All other fragment specifiers have no restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef84ba857bf1c83a92f8d5a5b2d52afc2b3c691" translate="yes" xml:space="preserve">
          <source>All pointers (except for the null pointer) are valid for all operations of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcec8da89ce19312f810d6e8b0a4c1c994af8c3f" translate="yes" xml:space="preserve">
          <source>All pointers in Rust are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33c45e166bf3f976aac4c7eec793b7d8946ca1" translate="yes" xml:space="preserve">
          <source>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or &lt;em&gt;comments&lt;/em&gt;, in their source code that the compiler will ignore but people reading the source code may find useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0c879bcf5cab9e7f4749d5ede013d5bf918c1f" translate="yes" xml:space="preserve">
          <source>All programs have to manage the way they use a computer&amp;rsquo;s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it&amp;rsquo;s running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf610b10a23cb06f62489f071586a11ed04b1ece" translate="yes" xml:space="preserve">
          <source>All reads from the returned reader will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edadac5bb39f603d58e3300e69ef3e103ed0e48" translate="yes" xml:space="preserve">
          <source>All reads from this reader will succeed by filling the specified buffer with the given byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8042ca5a8b0159faa7d15d89ddf16924d0bee8ca" translate="yes" xml:space="preserve">
          <source>All results of &lt;code&gt;next()&lt;/code&gt; need to be identical to the results of &lt;code&gt;next_back()&lt;/code&gt; in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051b0a6da7e5a99366866472afe4cedd9c4ae587" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2330d9e11176797f3b69c4b492614aa87568d1" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c4500c8b81bcefce226435a932d9bd67dd1d4" translate="yes" xml:space="preserve">
          <source>All supertraits must also be object safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3834b26accc0c7926a85719d5492f93bbdde2cd6" translate="yes" xml:space="preserve">
          <source>All the Places Patterns Can Be Used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ddc33f2c0eb4587fa8e2cac6e8f77be9184d95" translate="yes" xml:space="preserve">
          <source>All the code we&amp;rsquo;ve discussed so far has had Rust&amp;rsquo;s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn&amp;rsquo;t enforce these memory safety guarantees: it&amp;rsquo;s called &lt;em&gt;unsafe Rust&lt;/em&gt; and works just like regular Rust, but gives us extra superpowers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d094a6ebf518b356f6cc88f0daffccbeaa88d1a" translate="yes" xml:space="preserve">
          <source>All the floating point types, such as &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49768c9761f944e57fd8b28ffb7ccca3ce0255bf" translate="yes" xml:space="preserve">
          <source>All the integer types, such as &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aad067d2eb4fd66349ef7460833027940768e31" translate="yes" xml:space="preserve">
          <source>All the traits in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; except &lt;a href=&quot;fmt/trait.pointer&quot;&gt;&lt;code&gt;Pointer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbc378a4bea0c74a504553c4655c69b13216d43" translate="yes" xml:space="preserve">
          <source>All tokens have an associated &lt;code&gt;Span&lt;/code&gt;. A &lt;code&gt;Span&lt;/code&gt; is an opaque value that cannot be modified but can be manufactured. &lt;code&gt;Span&lt;/code&gt;s represent an extent of source code within a program and are primarily used for error reporting. You can modify the &lt;code&gt;Span&lt;/code&gt; of any token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b7c6a0fbafa4ae17e0c283d126acf9c731f848" translate="yes" xml:space="preserve">
          <source>All traits define an implicit type parameter &lt;code&gt;Self&lt;/code&gt; that refers to &quot;the type that is implementing this interface&quot;. Traits may also contain additional type parameters. These type parameters, including &lt;code&gt;Self&lt;/code&gt;, may be constrained by other traits and so forth &lt;a href=&quot;generics&quot;&gt;as usual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6af2c7840468532a887d826478745d410145630" translate="yes" xml:space="preserve">
          <source>All type parameters have an implicit bound of &lt;code&gt;Sized&lt;/code&gt;. The special syntax &lt;code&gt;?Sized&lt;/code&gt; can be used to remove this bound if it's not appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687bde44d55450fc7926f1ddbef8c12777b88228" translate="yes" xml:space="preserve">
          <source>All user-defined composite types (&lt;code&gt;struct&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s, and &lt;code&gt;union&lt;/code&gt;s) have a &lt;em&gt;representation&lt;/em&gt; that specifies what the layout is for the type. The possible representations for a type are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66aa8bf38f6384faa05e5ba7a817e6473b9a5b6" translate="yes" xml:space="preserve">
          <source>All values have an alignment and size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3bc16295776314b52aa5587d61ce1888ff84c1" translate="yes" xml:space="preserve">
          <source>Alloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c626eee3cffa40774dfe1fcb9f6b9bd69dc64f" translate="yes" xml:space="preserve">
          <source>Alloc::alloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fa8f803498e5ec9addefde8bfd45a79dbec5ed" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50e7d6a8a9d06e47daea96c8b2aea5c45efb165" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_excess</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889b443e61594610d30213145f921f146db36832" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34261c2be453348710c37c58e7b9c83398884d8" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_zeroed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3d2688c4fd76b53fe3390539a364662ab17d4b" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640d5625de8ef766306d60749a2169115e55e156" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7053fc65b9dd32b26e961ddd07f10fe845724b56" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a3b352f967fd646042d5ec8feb84a7842b4835" translate="yes" xml:space="preserve">
          <source>Alloc::grow_in_place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c3031aac44345a0cd3601e017910c7886cd822" translate="yes" xml:space="preserve">
          <source>Alloc::realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50682f5a6557029f4ae580a726dd0a2a8ee83c83" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b9b4276801f0c0a766cb281400a5a34452c7e1" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_excess</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caed8ad7c332dd652a64a2f5a64ee5adce448144" translate="yes" xml:space="preserve">
          <source>Alloc::shrink_in_place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdde8e404d1e339cdf8e89ef42138d76fb64cb5" translate="yes" xml:space="preserve">
          <source>Alloc::usable_size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9a2a318fbafb57c2a318b7f97cd7f558235f5" translate="yes" xml:space="preserve">
          <source>AllocErr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a1e8e44229166f6c5d59b8b5cdfbd7de11a910" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0d29cfc07f03d441e5891d8fdae354b136ec1" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow_mut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63e5f5e71fd2207c8a6514237ae70d9dca95cf3" translate="yes" xml:space="preserve">
          <source>AllocErr::cause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ff0aa0e6ca318ce203b20e17f08354650229f1" translate="yes" xml:space="preserve">
          <source>AllocErr::clone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777d6911608c872b31c4bdb18d3b776c08a9b8f5" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b678a089fb922c246660ee4daaf38a5251355da7" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df229543f81998e9da115264fa06013a927adb1" translate="yes" xml:space="preserve">
          <source>AllocErr::description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf0a94fd5cf29c79c5284616875b84972fb312" translate="yes" xml:space="preserve">
          <source>AllocErr::eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5881f4abcdbf06d5924b4a78a521cc0027e69523" translate="yes" xml:space="preserve">
          <source>AllocErr::fmt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270a3da0beb21d444fb57d0c363b8a08cfe0f022" translate="yes" xml:space="preserve">
          <source>AllocErr::from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b28dbbeacbc8b3f7530e8cbb0f5369608cd809" translate="yes" xml:space="preserve">
          <source>AllocErr::into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039711c278e014b513a0be997690fca2416f8474" translate="yes" xml:space="preserve">
          <source>AllocErr::ne</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa94c7186e9f5d1d7bf9c63828fb87e4a775ad5" translate="yes" xml:space="preserve">
          <source>AllocErr::source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeb755570b957275d6d9d5317212dc6a6535090" translate="yes" xml:space="preserve">
          <source>AllocErr::to_owned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e17e4e80e3c6af6ed45e6c032cf33d55d346e46" translate="yes" xml:space="preserve">
          <source>AllocErr::to_string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e40fc0676c76a71ca131dafb97f38662652bfbf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d1124cc06e84256717b819e1f63b955e0350bf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663b204a54c41c16c072ee135d91fa4be49de349" translate="yes" xml:space="preserve">
          <source>AllocErr::type_id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4893c8174f6c1eabc41e7843e70d7ebcff1b1f84" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd02c9bc4eedba216d90a16d722506e0ce680a8a" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;. &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c59d8374e4ee1d975ce714a71b5fcdbb7aacac" translate="yes" xml:space="preserve">
          <source>Allocate memory with the global allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb8411e19f0f79e91b6b66f6609da2b9991a1e5" translate="yes" xml:space="preserve">
          <source>Allocate zero-initialized memory with the global allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfdf7915bd5c3db982b39e0a3309425f8ee260d" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63c156459af2e92bb9b73d7f0f9844433b5dc2f" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed375cd7b209e0c5769df096531bae03a872bbbb" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c72ac7d36294390fedc764c2754fe1636d64b1" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e23de7e691468d4d99aac266130e3bc34f2ea4" translate="yes" xml:space="preserve">
          <source>Allocates an empty &lt;code&gt;PathBuf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ce219d6c4b42c1f87ab6030532c065b1fec11f" translate="yes" xml:space="preserve">
          <source>Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e910169c58168ed4f75b19228b519cfb61699e61" translate="yes" xml:space="preserve">
          <source>Allow generic type parameter to be a dynamically sized type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40680c6330eab7e25541ffbe63efc1d14385635b" translate="yes" xml:space="preserve">
          <source>Allow users to add text content only when a post is in the &lt;code&gt;Draft&lt;/code&gt; state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb50b4ef5745cf62353aeff34203276011ef50f" translate="yes" xml:space="preserve">
          <source>Allowing Access from Multiple Threads with &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae2d8f4c50be8a20cdea347ace493568595fcd3" translate="yes" xml:space="preserve">
          <source>Allowing Multiple Guesses with Looping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db289670d5f2b576ba5fbc25cdc4ef16295c536" translate="yes" xml:space="preserve">
          <source>Allowing Transference of Ownership Between Threads with &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09e5f22f3b7d16947a2ecaccff480c6609f901" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a3f97ad5d3ab3ce2ee9333276a6a44f6055cf9" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;code&gt;VecDeque&lt;/code&gt; instead of &lt;code&gt;LinkedList&lt;/code&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30066ada2ed0aa1faf9262f27c4ed17333b52206" translate="yes" xml:space="preserve">
          <source>Along the way, we&amp;rsquo;ll show how to make our command line tool use features of the terminal that many command line tools use. We&amp;rsquo;ll read the value of an environment variable to allow the user to configure the behavior of our tool. We&amp;rsquo;ll also print error messages to the standard error console stream (&lt;code&gt;stderr&lt;/code&gt;) instead of standard output (&lt;code&gt;stdout&lt;/code&gt;), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbf8cd5d5a46820a0f6ab73279f92ce571b3bc8" translate="yes" xml:space="preserve">
          <source>Along with being made public via &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; can also have an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; added for use in FFI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569f87a8387e1554badafba00588c85d0f8bf792" translate="yes" xml:space="preserve">
          <source>Along with the newtype pattern, Rust provides the ability to declare a &lt;em&gt;type alias&lt;/em&gt; to give an existing type another name. For this we use the &lt;code&gt;type&lt;/code&gt; keyword. For example, we can create the alias &lt;code&gt;Kilometers&lt;/code&gt; to &lt;code&gt;i32&lt;/code&gt; like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6444cb062f09d53622baea0cd17deb96b9dc9f75" translate="yes" xml:space="preserve">
          <source>Also discussed were the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fc1b2f8caf81c693f670285ed3e30e58c8f202" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Iterator&lt;/code&gt; provides a default implementation of methods such as &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; which call &lt;code&gt;next&lt;/code&gt; internally. However, it is also possible to write a custom implementation of methods like &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; if an iterator can compute them more efficiently without calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7fb665b167f214e0e11085759c66fc45c5b538" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729f1c9440272260f81d5cd373556bbc830572f8" translate="yes" xml:space="preserve">
          <source>Also note that the values we get from the calls to &lt;code&gt;next&lt;/code&gt; are immutable references to the values in the vector. The &lt;code&gt;iter&lt;/code&gt; method produces an iterator over immutable references. If we want to create an iterator that takes ownership of &lt;code&gt;v1&lt;/code&gt; and returns owned values, we can call &lt;code&gt;into_iter&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;. Similarly, if we want to iterate over mutable references, we can call &lt;code&gt;iter_mut&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce251a63845ba69b5ad2fd9f201455284f4f01ee" translate="yes" xml:space="preserve">
          <source>Also note that we switched the type of the &lt;code&gt;t&lt;/code&gt; parameter from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;&amp;amp;T&lt;/code&gt;. Because the type might not be &lt;code&gt;Sized&lt;/code&gt;, we need to use it behind some kind of pointer. In this case, we&amp;rsquo;ve chosen a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19148a1d1c1b97af52ac182d255aa33cc3c9304e" translate="yes" xml:space="preserve">
          <source>Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g. &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of this can refer to &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4cb652a8b78bec628c1d26d0df6d4c9f7c28ed" translate="yes" xml:space="preserve">
          <source>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56542ee08fdcb89c559a45ec666da5ba100aa6fa" translate="yes" xml:space="preserve">
          <source>Also, it allocates temporary storage half the size of &lt;code&gt;self&lt;/code&gt;, but for short slices a non-allocating insertion sort is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71671f4bb484f8a1e973c0578cc13715a3aa2105" translate="yes" xml:space="preserve">
          <source>Also, note that because &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; has a private field, the struct needs to provide a public associated function that constructs an instance of &lt;code&gt;Breakfast&lt;/code&gt; (we&amp;rsquo;ve named it &lt;code&gt;summer&lt;/code&gt; here). If &lt;code&gt;Breakfast&lt;/code&gt; didn&amp;rsquo;t have such a function, we couldn&amp;rsquo;t create an instance of &lt;code&gt;Breakfast&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because we couldn&amp;rsquo;t set the value of the private &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477dbb63bb02aa6d30fe03da09f8465ff169a963" translate="yes" xml:space="preserve">
          <source>Also, note that the function body is wrapped in curly brackets, &lt;code&gt;{}&lt;/code&gt;. Rust requires these around all function bodies. It&amp;rsquo;s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c50010a52d6913ce8428bd39d3014c723f0db3d" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edbd5a08a0137666e61eca4932691fdf6681fd9" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;bool&lt;/code&gt; implements the &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait, we don't have to worry about the move semantics (just like the integer and float primitives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b0dcda2ee36870b49794f990ce3f2eb9803892" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must be a have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2b342df42a5ce80106fad6cca3ec251f8df3e4" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; has alignment 1 for all &lt;code&gt;T&lt;/code&gt;, so you can use it if you need to keep the field for some reason:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38449305205a0baadf0d931713ad745060ac7795" translate="yes" xml:space="preserve">
          <source>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d329c92752ab59bc5a187b9f641894d29c9fd208" translate="yes" xml:space="preserve">
          <source>Alternatively, define a trait locally and implement that instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30596c4d15742cc562b249b398f8c80c1a13a17f" translate="yes" xml:space="preserve">
          <source>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8d494311629dbdec7e4dda72d552e11aace0ec" translate="yes" xml:space="preserve">
          <source>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a59d2fc84eff79b213967bc64daab09652e8ccb" translate="yes" xml:space="preserve">
          <source>Alternatively, if your type implements &lt;code&gt;Clone&lt;/code&gt; and you need to own the value, consider borrowing and then cloning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9c6950d0598f33adea6619e4f5e3230fd020da" translate="yes" xml:space="preserve">
          <source>Alternatively, move the other attributes to the contained type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cf6202d850db2d8b7a0068cf052fbe7d132528" translate="yes" xml:space="preserve">
          <source>Alternatively, split the pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b111c2948f7df0faec47eb57a97f3c7f99e8980" translate="yes" xml:space="preserve">
          <source>Alternatively, we can consider using the &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; types to achieve interior mutability through a shared reference. Our example's &lt;code&gt;mutable&lt;/code&gt; function could be redefined as below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754e721e3e9779de9d32c607142b98694b9bb365" translate="yes" xml:space="preserve">
          <source>Alternatively, we can move out of &lt;code&gt;fancy_num&lt;/code&gt; into a second &lt;code&gt;fancy_num&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da767a10b83371c7ea419ae14469880fbc9efc2b" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980127d7c92391c13b6615bd3076240a03531f1c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can add the following line to your &lt;em&gt;~/.bash_profile&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53009511a1501672faf73d204dc3eb7eb0e15f4c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, &lt;code&gt;NewType&lt;/code&gt; is a newtype over &lt;code&gt;Foo&lt;/code&gt; in &lt;code&gt;struct NewType(Foo)&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44934b9e6665fc0ff65386cfc3a7e7022fcb44e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4db1dca17b4c832ac69c83b18f73ad9aa68bf9" translate="yes" xml:space="preserve">
          <source>Although Rust will let you bind &lt;code&gt;Sized&lt;/code&gt; to a trait, you won't be able to use it to form a trait object later:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18938413590ec4f421c089a648f9b8a820edd657" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6138cf1c64fdfba340547fa72a908d945fa65b3f" translate="yes" xml:space="preserve">
          <source>Although a &lt;code&gt;SystemTime&lt;/code&gt; cannot be directly inspected, the &lt;a href=&quot;constant.unix_epoch&quot;&gt;&lt;code&gt;UNIX_EPOCH&lt;/code&gt;&lt;/a&gt; constant is provided in this module as an anchor in time to learn information about a &lt;code&gt;SystemTime&lt;/code&gt;. By calculating the duration from this fixed point in time, a &lt;code&gt;SystemTime&lt;/code&gt; can be converted to a human-readable time, or perhaps some other string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf2565395a043df30a2266cce3b26bdd4f8ff03" translate="yes" xml:space="preserve">
          <source>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with &lt;code&gt;use&lt;/code&gt;. Bringing the function&amp;rsquo;s parent module into scope with &lt;code&gt;use&lt;/code&gt; so we have to specify the parent module when calling the function makes it clear that the function isn&amp;rsquo;t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where &lt;code&gt;add_to_waitlist&lt;/code&gt; is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1566b2870173a676122bd4c9750a25b9287966" translate="yes" xml:space="preserve">
          <source>Although functional programming languages use cons lists frequently, the cons list isn&amp;rsquo;t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is a better choice to use. Other, more complex recursive data types &lt;em&gt;are&lt;/em&gt; useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04af4e6b5ccd4c4682747098fc1db0b02dbd661" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;::&lt;/code&gt; token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in &lt;em&gt;PathInExpression&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf75499d3d552ee0a87d1fa70ed0a0e35bd067e" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;let&lt;/code&gt; is pointless here, it illustrates the meaning of &lt;code&gt;!&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; is never assigned a value (because &lt;code&gt;return&lt;/code&gt; returns from the entire function), &lt;code&gt;x&lt;/code&gt; can be given type &lt;code&gt;!&lt;/code&gt;. We could also replace &lt;code&gt;return 123&lt;/code&gt; with a &lt;code&gt;panic!&lt;/code&gt; or a never-ending &lt;code&gt;loop&lt;/code&gt; and this code would still be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8ecdea30a2a1885eeb369d7e2426712a189f17" translate="yes" xml:space="preserve">
          <source>Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes. As such, all cryptographic uses of this implementation are &lt;em&gt;strongly discouraged&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07ca613351cf8dcbbc0ccd12d8ef0d4721b46b7" translate="yes" xml:space="preserve">
          <source>Although the number of keys and values is growable, each key can only have one value associated with it at a time. When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; already have a value. Or you could combine the old value and the new value. Let&amp;rsquo;s look at how to do each of these!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d281e954555c8484110a6fecba9e6260dd297fe7" translate="yes" xml:space="preserve">
          <source>Although this code has the same behavior as Listing 9-5, it doesn&amp;rsquo;t contain any &lt;code&gt;match&lt;/code&gt; expressions and is cleaner to read. Come back to this example after you&amp;rsquo;ve read Chapter 13, and look up the &lt;code&gt;unwrap_or_else&lt;/code&gt; method in the standard library documentation. Many more of these methods can clean up huge nested &lt;code&gt;match&lt;/code&gt; expressions when you&amp;rsquo;re dealing with errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0fe462f2aa334b05d61f387c6225bd0bc5a2b6" translate="yes" xml:space="preserve">
          <source>Although this code works, duplicating code is tedious and error prone. We also have to update the code in multiple places when we want to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094096c8e8871948579e001659d96f6f0cd91ded" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; instead and new &lt;code&gt;impl&lt;/code&gt;s can omit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3c8369369ce1fe72325205b70eb3e2961e011c" translate="yes" xml:space="preserve">
          <source>Although you can&amp;rsquo;t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports &lt;em&gt;yanking&lt;/em&gt; a crate version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a876dd4a0d144d06dda24f474bedf4412b3d4b86" translate="yes" xml:space="preserve">
          <source>Always empty bottom type for diverging functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30044213367fd946b86a46fbbf0f3c415f92d7bc" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Err&lt;/code&gt; on arithmetic overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2dadc15a7e41133f5895d6079a63549a2abb5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;needle&lt;/code&gt; is an empty slice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0ce480d587247832892434b17dbf1b556a5191" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.add(count)&lt;/code&gt; instead when possible, because &lt;code&gt;add&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbc1421ee3e3a275bd2bb6e8f64943056afdc31" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.offset(count)&lt;/code&gt; instead when possible, because &lt;code&gt;offset&lt;/code&gt; allows the compiler to optimize better. If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701562825affe99f99fee809f333cf1e955284e4" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.sub(count)&lt;/code&gt; instead when possible, because &lt;code&gt;sub&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fda5d5730cef377a6f455b42dbcfb53fb2ca5ca" translate="yes" xml:space="preserve">
          <source>Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input. Using the &lt;a href=&quot;../primitive.str#method.trim&quot;&gt;&lt;code&gt;str.trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82aa4d4f03b38410c80f80025c8644ba744b247" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d19d51f5faed38ee6324a9eb71c292315da9f7" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1692574d1eb8d1443991c925dc8e2acd8ed2cbd7" translate="yes" xml:space="preserve">
          <source>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound across patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d68d3a293f07f835d90c6279bf8faa22ceb0c8" translate="yes" xml:space="preserve">
          <source>An &amp;lsquo;abstract syntax tree&amp;rsquo;, or &amp;lsquo;AST&amp;rsquo;, is an intermediate representation of the structure of the program when the compiler is compiling it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2d4110f56313292c834e1861a95c89c601039f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d78c88964f9736a45223d8f771f07ad6bd857e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a7f0956daf2ce936a64a4b1e04b5752d5af8c85" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt; declares both the type and a number of &lt;em&gt;variants&lt;/em&gt;, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccb90f6f9e2e1cba49165645ca18ce97f7c3bdc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee613500276e22e6ef67273653d1676ba809144c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;glossary#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdff555d3629a9d75bb0e2e48e4c4243e57c8c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt; that applies to a nominal type, not to a trait-type pair. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;More&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f864e2f214828c68972804234bf4534f4526fce2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36aa4d3dbc6bef64eda94b67a998204c02c9bc40" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Err&lt;/code&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08eb1e2f2f021298ee3677019a6bda280ed6f694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ordering&lt;/code&gt; is the result of a comparison between two values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001eb435d69650fbb2db42365be5918489730c71" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;RwLock&lt;/code&gt;, like &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;, will become poisoned on a panic. Note, however, that an &lt;code&gt;RwLock&lt;/code&gt; may only be poisoned if a panic occurs while it is locked exclusively (write mode). If a panic occurs in any reader, then the lock will not be poisoned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5247e633cc3100e9500337757cb3044553bdf55d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; with a discriminant must specify a &lt;code&gt;#[repr(inttype)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ec5e4c1f77a0601ab37f0e8a98cf223a18e608" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is equivalent to a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca624a02ac8519763d7ccacb2b0ad8dad16c279" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is semantically similar to an &lt;code&gt;if&lt;/code&gt; expression but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt; and a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following &lt;code&gt;else&lt;/code&gt; block if it exists. Like &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;if let&lt;/code&gt; expressions have a value determined by the block that is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee510cf708477f86b4dc6237cd892de065d1aca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression allows you to branch your code depending on conditions. You provide a condition and then state, &amp;ldquo;If this condition is met, run this block of code. If the condition is not met, do not run this block of code.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bc01de0e1b8681253f7b567d2d01b7869caf61" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is a conditional branch in program control. The form of an &lt;code&gt;if&lt;/code&gt; expression is a condition expression, followed by a consequent block, any number of &lt;code&gt;else if&lt;/code&gt; conditions and blocks, and an optional trailing &lt;code&gt;else&lt;/code&gt; block. The condition expressions must have type &lt;code&gt;bool&lt;/code&gt;. If a condition expression evaluates to &lt;code&gt;true&lt;/code&gt;, the consequent block is executed and any subsequent &lt;code&gt;else if&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; block is skipped. If a condition expression evaluates to &lt;code&gt;false&lt;/code&gt;, the consequent block is skipped and any subsequent &lt;code&gt;else if&lt;/code&gt; condition is evaluated. If all &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else if&lt;/code&gt; conditions evaluate to &lt;code&gt;false&lt;/code&gt; then any &lt;code&gt;else&lt;/code&gt; block is executed. An if expression evaluates to the same value as the executed block, or &lt;code&gt;()&lt;/code&gt; if no block is evaluated. An &lt;code&gt;if&lt;/code&gt; expression must have the same type in all situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0d0db502cd02811b94f8110c6b6a57d9c4d08b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block has the type &lt;code&gt;()&lt;/code&gt;, so this is a type error. To resolve it, add an &lt;code&gt;else&lt;/code&gt; block having the same type as the &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c2bbd51b64dbea789df858c004c474818f64aa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type expands to a recursive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714f0cd77b96bfb041f113fa02745f0b3de0da54" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the following example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4fc89f6e27033dd75c8304209d0e35cd3688c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl&lt;/code&gt; for a &lt;code&gt;#[marker]&lt;/code&gt; trait tried to override an associated item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1073354ecc9c5e7785479d7d2a13da928ab63a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f05b7296f4e1950e87afc07c23f9e722a69148" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534dc31a67cf35753f9f6ff5f73b65cd1ba58ab5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces and array containing each of these values in the order they are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32616f8cb6d3bd819da208e9fcccc36635a05f1e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;code&gt;extern crate&lt;/code&gt; declaration&lt;/em&gt; specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; provided in the &lt;code&gt;extern crate&lt;/code&gt; declaration. The &lt;code&gt;as&lt;/code&gt; clause can be used to bind the imported crate to a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13494e1cedf4f5c5ecdcb7c07e83d0cd9827df20" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;absolute path&lt;/em&gt; starts from a crate root by using a crate name or a literal &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fdc788150826ae707ba926f5a66e96063c57f9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;assignment expression&lt;/em&gt; consists of a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; followed by an equals sign (&lt;code&gt;=&lt;/code&gt;) and a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;. Such an expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca56087cc708820efe9481bf7313fdab4a040e22" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant declaration&lt;/em&gt; declares a signature for associated constant definitions. It is written as &lt;code&gt;const&lt;/code&gt;, then an identifier, then &lt;code&gt;:&lt;/code&gt;, then a type, finished by a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec29836d6b0ec5f807474f5934209d4fe8c7bb83" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant definition&lt;/em&gt; defines a constant associated with a type. It is written the same as a &lt;a href=&quot;constant-items&quot;&gt;constant item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d2944c74176d8d6fa13f7d573ee85d9e742d32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function declaration&lt;/em&gt; declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2c17d462060e477f166e6bcfabaf54ef17987" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function definition&lt;/em&gt; defines a function associated with another type. It is written the same as a &lt;a href=&quot;../types/function-item&quot;&gt;function item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd6d9f2bd71f652e6f6a519a466ea3ae43a3bff" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type declaration&lt;/em&gt; declares a signature for associated type definitions. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, and finally an optional list of trait bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd2e844486eba2a5ee0638c6e470984a319e1bf" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type definition&lt;/em&gt; defines a type alias on another type. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, then an &lt;code&gt;=&lt;/code&gt;, and finally a &lt;a href=&quot;../types#type-expressions&quot;&gt;type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335c18325b2749c2db5132eb57bce1ffbfa512dc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8d0e2999c5dfed50da51262f087365afa14a25" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519b32460e4cf24cbf7584ec56a2b57870f1cdef" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumeration&lt;/em&gt;, also referred to as &lt;em&gt;enum&lt;/em&gt; is a simultaneous definition of a nominal &lt;a href=&quot;../types/enum&quot;&gt;enumerated type&lt;/a&gt; as well as a set of &lt;em&gt;constructors&lt;/em&gt;, that can be used to create or pattern-match values of the corresponding enumerated type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670995bec677d5fc81f3189dbec41d6de7da346c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;example term&lt;/em&gt; is an example of a term being defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f2bd4498afb61074c0d1568fbae87b71b0a6a3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;expression statement&lt;/em&gt; is one that evaluates an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111aa957a35f04452bf335357f4b5845abfce6b9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;implementation&lt;/em&gt; is an item that associates items with an &lt;em&gt;implementing type&lt;/em&gt;. Implementations are defined with the keyword &lt;code&gt;impl&lt;/code&gt; and contain functions that belong to an instance of the type that is being implemented or to the type statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26714676268e63e4c19e025e4e919231c94ab7b4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer literal&lt;/em&gt; has one of four forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b04f25de241c42aa4cc17d61d52253aec0db163" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer&lt;/em&gt; is a number without a fractional component. We used one integer type in Chapter 2, the &lt;code&gt;u32&lt;/code&gt; type. This type declaration indicates that the value it&amp;rsquo;s associated with should be an unsigned integer (signed integer types start with &lt;code&gt;i&lt;/code&gt;, instead of &lt;code&gt;u&lt;/code&gt;) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. Each variant in the Signed and Unsigned columns (for example, &lt;code&gt;i16&lt;/code&gt;) can be used to declare the type of an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86645edb5b5b0c86e3d214a4daf335142eb0487" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item declaration statement&lt;/em&gt; has a syntactic form identical to an &lt;a href=&quot;items&quot;&gt;item declaration&lt;/a&gt; within a &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt;. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical path&lt;/a&gt; nor are any sub-items it may declare. The exception to this is that associated items defined by &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb6bea3f24f939f1296c8f5c8b195169146ee81" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item&lt;/em&gt; is a component of a crate. Items are organized within a crate by a nested set of &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. Every crate has a single &quot;outermost&quot; anonymous module; all further items within the crate have &lt;a href=&quot;paths&quot;&gt;paths&lt;/a&gt; within the module tree of the crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df47e4537a8816a2744d87425d00def520f575a" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;octal literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+006F&lt;/code&gt; (&lt;code&gt;0o&lt;/code&gt;) and continues as any mixture (with at least one digit) of octal digits and underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a141d1e8af86d54f8339e504d3e1c56051728a15" translate="yes" xml:space="preserve">
          <source>An Example Program Using Structs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aefcb56dc6b861369f867948d8b3b7d49377bfe" translate="yes" xml:space="preserve">
          <source>An I/O Project: Building a Command Line Program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0827868381963388a6304543297f7f95e42e9164" translate="yes" xml:space="preserve">
          <source>An IP address, either IPv4 or IPv6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4cbc9b22ca704cfdd900cac5407adcf23c5edb" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing an unspecified address: 0.0.0.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e22ab3badaaaa01e7375dd220a2065ca03f949" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing the broadcast address: 255.255.255.255</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0e70a5e365495e2ae4d74f302988b1f303a907" translate="yes" xml:space="preserve">
          <source>An IPv4 address with the address pointing to localhost: 127.0.0.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d68f8900e66f00bfbfd5b6cf93e7f299173890" translate="yes" xml:space="preserve">
          <source>An IPv4 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb8e3b87105ecbe9c8ed2a2e3a9821088df2706" translate="yes" xml:space="preserve">
          <source>An IPv4 socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30848e04ae8ee9ab468ffa0929f622538606ceb" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing localhost: &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e145c57ced7f65d6f3f83ddc10fbd40d1da4596" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing the unspecified address: &lt;code&gt;::&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7dda9f630704f82008f3562e22d445246045b1" translate="yes" xml:space="preserve">
          <source>An IPv6 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d9d6e575aa92d12e0b2c0fb0d5fdcf4923ff85" translate="yes" xml:space="preserve">
          <source>An IPv6 socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7fb098f948c20be5364a0797d6630c8f71fe36" translate="yes" xml:space="preserve">
          <source>An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445fdaee68caea7b120e9af421a1f499e812ae92" translate="yes" xml:space="preserve">
          <source>An additional advantage of using Cargo is that the commands are the same no matter which operating system you&amp;rsquo;re working on. So, at this point, we&amp;rsquo;ll no longer provide specific instructions for Linux and macOS versus Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d51fdd16cd827000271f90af417efeb9cea05f" translate="yes" xml:space="preserve">
          <source>An address associated with a Unix socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ebc470b9c08ca083e04f253e5b3a814fa55f28" translate="yes" xml:space="preserve">
          <source>An anchor in time which can be used to create new &lt;code&gt;SystemTime&lt;/code&gt; instances or learn about where in time a &lt;code&gt;SystemTime&lt;/code&gt; lies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f427918d6366c3545d7bcd1528880b6655f86b" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is an expression that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98f60a77f0bbfa809e448ded22428fbfae4e33e" translate="yes" xml:space="preserve">
          <source>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bac5ec811f30188ce6fd849b796ac2d30ffddc" translate="yes" xml:space="preserve">
          <source>An array itself is not iterable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f510f3fd4950ebae5518ce0880fd83877599bc5e" translate="yes" xml:space="preserve">
          <source>An array or slice pattern required more elements than were present in the matched array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005f7187c479dcce2321a163ab284d4855025280" translate="yes" xml:space="preserve">
          <source>An array or slice pattern was matched against some other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910b39cfa9beb5c32b52af8b271e7bb38ba1d4da" translate="yes" xml:space="preserve">
          <source>An array without a fixed length was pattern-matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6ee782e8b3dacab5901a68a88743cdf8f6df8d" translate="yes" xml:space="preserve">
          <source>An array, sometimes also called a fixed-size array or an inline array, is a value describing a collection of elements, each selected by an index that can be computed at run time by the program. It occupies a contiguous region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704af6b84f8ec0b7b57fdf7ea0ff93aa51a032a6" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10e51ff90ef78acbd226706348e7754e0cff2c" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter), but an implementation of the trait declared the same function to be static.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825b9fd38095eee93e418cc09ae8f9ace5e1f868" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035c9277b00c3deebef8eabfe1b836a5766b141" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;glossary#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9116723797d95c7e68863b40ba3626f52a6ce11f" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78cadc098f0f8d19a172d639f50a5e45d007b" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2d4322730aa4a674f88f33ea28a7a44379f38a" translate="yes" xml:space="preserve">
          <source>An asterisk &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbf33b833d8349f917a7e3318533a910b1e01c0" translate="yes" xml:space="preserve">
          <source>An asynchronous, infinitely buffered channel. The &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(Sender, Receiver)&lt;/code&gt; tuple where all sends will be &lt;strong&gt;asynchronous&lt;/strong&gt; (they never block). The channel conceptually has an infinite buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f387b126eb53d62fa04e8482ab5a1aac01b56bf6" translate="yes" xml:space="preserve">
          <source>An atomic fence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37a15efc349a5896258ef2d831759eaab050729" translate="yes" xml:space="preserve">
          <source>An atomic integer initialized to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4be8bb4563b5c446bf4ec14a3a559fbf234d0d" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for a struct failed because one of the fields does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned field. Note that this may not be possible, as in the example of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71c2935e96e5f7fe3e3f35ad00fd7b30920019f" translate="yes" xml:space="preserve">
          <source>An attempt to index into a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8febb37ae18b2d657b2615e5b330d2a55118441d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a concrete specialization of a generic type. An example is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ba79d4404f5653d6f77e24331c8ba336aac40d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type. An example is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55e6f81b7dc27d46319cedb33bad7716f5297f4" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e153b913d67d75c58662cead8cf242032c80e00b" translate="yes" xml:space="preserve">
          <source>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (&lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb3222e10ca68a4902e2fef67ce06d659218b60" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89de6efbf294db50ea9580038de7bf4a99c6cc2d" translate="yes" xml:space="preserve">
          <source>An attempted conversion that consumes &lt;code&gt;self&lt;/code&gt;, which may or may not be expensive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f680a55f734bd0dbbca55a32cd8aa13a2d823" translate="yes" xml:space="preserve">
          <source>An attribute is either active or inert. During attribute processing, &lt;em&gt;active attributes&lt;/em&gt; remove themselves from the thing they are on while &lt;em&gt;inert attributes&lt;/em&gt; stay on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f22761bfa3bdfb0003204a934bf1010c9716a93" translate="yes" xml:space="preserve">
          <source>An empty buffer returned indicates that the stream has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc01027756efda949405e0e59c0d834ec342e061" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442cf9396651f26f54eeff92f4dde433d7f72454" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ba001b1a53998b8d224cd77e4663359ef99e71" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the one value of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54261d577d85895bf8c09d3febd150e6fae82418" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the zero value of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f62854280c7cd5daf0c2b6b4a29d4a8c72ac30" translate="yes" xml:space="preserve">
          <source>An endpoint of a range of keys.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
