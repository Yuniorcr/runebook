<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e30a1e9a0acdfc19a0c0083bbed66bee81f8c64" translate="yes" xml:space="preserve">
          <source>This section deals with the basic built-in types and the operations that are available for them in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b66580a9224160aed4a56da61d43fa2a3bbf6f" translate="yes" xml:space="preserve">
          <source>This section describes Nim's additional features that are not listed in the Nim manual. Some of the features here only make sense for the C code generator and are subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbfa8ca764ad8bfb7ab8cb634f105e3b8af514a0" translate="yes" xml:space="preserve">
          <source>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3df74b1ff5eebb36ece2e259d2d5e805032af28" translate="yes" xml:space="preserve">
          <source>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (&lt;code&gt;NimNode&lt;/code&gt;) with a variable number of children. Each node has a field named &lt;code&gt;kind&lt;/code&gt; which describes what the node contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28cfadb305f94e005219763b91c53ae1a57afd3" translate="yes" xml:space="preserve">
          <source>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the &lt;a href=&quot;#lexical-analysis&quot;&gt;Lexical Analysis&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd3a9a0b54b906c2f17ac03b05d99470504a894" translate="yes" xml:space="preserve">
          <source>This should be called on a connected socket, and will perform an SSL handshake immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33d2aee12f9e4445c80f6903f9125cbac15130e" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d43e8081cd2738e9c8a30d0556e7afa9f98284" translate="yes" xml:space="preserve">
          <source>This should produce roughly this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4682779a113516e431fc633b78e3eb5afe0b69" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; to override the temporary directory returned by &lt;code&gt;os.getTempDir()&lt;/code&gt;. The value &lt;strong&gt;should&lt;/strong&gt; end with a directory separator character. (Relevant for the Android platform)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b990f66ca4d7aa57f0cf0dd33176a666917f9d2" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; to override the path for the &lt;code&gt;sh&lt;/code&gt; binary, in cases where it is not located in the default location &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8c91cc0539e7ac1fcb6913e444dfab0dfc651" translate="yes" xml:space="preserve">
          <source>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a29bb19075988ba4154f245cf61264e6c3403b" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;em&gt;genericHead&lt;/em&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b73c4d12f30a07a08773a16f4683aba0e028b0" translate="yes" xml:space="preserve">
          <source>This trait returns true iff the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;. Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3824e56a10ede7c713ffb39e26e88a788482118a" translate="yes" xml:space="preserve">
          <source>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d1986229bd95fd619538b360b3cc3585eddf09" translate="yes" xml:space="preserve">
          <source>This type contains a description of a person</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d9daad0926694b235ad99d9f58721fb3438862" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4922584a12b79a219eaa16925bbb909743a91e2e" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e216d34b156aa03e46b15d955959dbcd959d74" translate="yes" xml:space="preserve">
          <source>This uses the configuration defined in &lt;code&gt;config\nim.cfg&lt;/code&gt; for &lt;code&gt;lvm_gcc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5505a00f1063702f80a5818b1a5c8c32d61e3710" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bac1b6d0db41715df5581bb4825ea90b0b4190f" translate="yes" xml:space="preserve">
          <source>This will generate a file called &lt;code&gt;switchhomebrew.elf&lt;/code&gt; which can then be turned into an nro file with the &lt;code&gt;elf2nro&lt;/code&gt; tool in the DevkitPro release. Examples can be found at &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;the nim-libnx github repo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26136905c2efd9e1d537dc87f61ea998287f6a6d" translate="yes" xml:space="preserve">
          <source>This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of &lt;code&gt;.idx&lt;/code&gt;. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the &lt;a href=&quot;#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; section for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ead03785f5fb54bd6190bd855d00357524e06d3" translate="yes" xml:space="preserve">
          <source>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4705d432fb1b0185c67d13ccff0749b0afd34e" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;future&lt;/code&gt; is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77dd0890df14804d1f6f5c6ad7d8c663331e013e" translate="yes" xml:space="preserve">
          <source>This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that &lt;code&gt;filename.nim&lt;/code&gt; belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e5c517031f780132f7de304e80ce21fd6382d8" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd34efcb73d9e9a4a38033e49417a668da60801" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3189c7fd9700aaadbf4a4dd6af6df7937cf0b2d7" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc168569a3d857e9b97041d394676d2e416f6807" translate="yes" xml:space="preserve">
          <source>This would be any of the other idetools available options, like &lt;code&gt;--def&lt;/code&gt; or &lt;code&gt;--suggest&lt;/code&gt; explained in the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3974135028a38a44142b8af58d9f501e1acc3c71" translate="yes" xml:space="preserve">
          <source>This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f848317832fae19e0085de9e23738862798395f" translate="yes" xml:space="preserve">
          <source>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d02e1b27f5da6165217ae6af04fef8718253485" translate="yes" xml:space="preserve">
          <source>Though the Nim Standard Library is still evolving, it is already quite usable. It is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt; and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cc7e4d5579d2abc9a379f6ffd100e925cda3b1" translate="yes" xml:space="preserve">
          <source>Thread coordination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a7e2e5a99004361b87c2d5390e14c75d8f283e" translate="yes" xml:space="preserve">
          <source>Thread pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1d54b91c07f35c7604f3ddd4b6f833468ea9ba" translate="yes" xml:space="preserve">
          <source>Thread support for Nim. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="efcacaedc288d5f1ee9e06293407eb061bd561ea" translate="yes" xml:space="preserve">
          <source>Threads and exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9af3f7a423d176c8e989c93a406d4e77eaeeca" translate="yes" xml:space="preserve">
          <source>Threadvar pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c599a1317d70c1913cfd27374ce0f1835f7e408" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. &lt;code&gt;def&lt;/code&gt; for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0fdc12f844b31a8cf54439d51d7813e5ece7c9" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. def for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a4b67d34c6ea267e9e2aa731f12d8004957357" translate="yes" xml:space="preserve">
          <source>Three letter string which indicates the day of the week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166b5ad7cdc1ddb77e376400c9f9b2e942b944d7" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where certain safety checks are omitted for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053686996ea91f5f0bd8bfc5be9311b2dfb9563b" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645311b7482290ae055f08a018122a58f2c3b9eb" translate="yes" xml:space="preserve">
          <source>Through the use of the optional &lt;code&gt;{.raises.}&lt;/code&gt; pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the &lt;code&gt;{.raises.}&lt;/code&gt; pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises &lt;code&gt;IOError&lt;/code&gt;, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ee67f0e9e151a472bd4d369d44933d3da7821" translate="yes" xml:space="preserve">
          <source>Thrown in the &lt;code&gt;getContent&lt;/code&gt; proc and &lt;code&gt;postContent&lt;/code&gt; proc, when the server returns an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37977e3077bc9851c1ffd00107b486f2f8f09038" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;em&gt;errorMsgExpected&lt;/em&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39bb08fac5f6360feb78a680d458fc658579909" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee323ffc9625d6bc28b4f8cc717e26ebd77ac1a" translate="yes" xml:space="preserve">
          <source>Thus, north &amp;lt; east &amp;lt; south &amp;lt; west. The comparison operators can be used with enumeration types. Instead of &lt;code&gt;north&lt;/code&gt; etc, the enum value can also be qualified with the enum type that it resides in, &lt;code&gt;Direction.north&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4b8a59ee4623c1899387bf6de6586afc3a5dc2" translate="yes" xml:space="preserve">
          <source>Time components are subtracted one-by-one, see output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb812b32f09c8031753f69acac0c61789f34460" translate="yes" xml:space="preserve">
          <source>Time effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3ccfa05db1ce4bb37a133e936dac6618864488" translate="yes" xml:space="preserve">
          <source>Time measurement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fb52fb2152cd12040e0a822c3f35572a335a53" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;d&lt;/code&gt; days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45493a2f2864af1ad59f4e6002d36f0afb4f0012" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;h&lt;/code&gt; hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a2bec4e7d8f08615b4a69538e1d873fd8cabd4" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; minutes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8b1b84cf164e73ebf16147dec8fe94eb87b149" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; months.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e35c45093c4c75c76cc0ad1730384cf89bc1aab" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;micros&lt;/code&gt; microseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571851bb6763be044dfb20a43ad6453fa502f0ca" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a7b6a6e6dabdcbf91694569154f0821829247a" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;nanos&lt;/code&gt; nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843631ff0523a6f86df81cbca0448371ae88177c" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;s&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc17d9ec9d80bdf5f4294a7ade05be0d237182e" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;w&lt;/code&gt; weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b05f6f1a5def9a860eb63a1be452d2e901c363" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;y&lt;/code&gt; years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="49563f216566fe13f36b6d6f96d904d2f0012073" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;code&gt;DateTime&lt;/code&gt;'s of arbritary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005f759cb3d18c4ae00a285a0712a53038aa8ad6" translate="yes" xml:space="preserve">
          <source>To &lt;em&gt;invoke&lt;/em&gt; a template, call it like a procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1339a3fbb20d91263c5b8ca905cfc7af9e20c" translate="yes" xml:space="preserve">
          <source>To access multiple values of a key, use the overloaded &lt;code&gt;[]&lt;/code&gt; below or to get all of them access the &lt;code&gt;table&lt;/code&gt; field directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8854509b79b921922ff284c021ca2226c66887" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; has to be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The documentation of the system module contains further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b75bdb6d108ccec959da5a9406fd4ee6f129b2" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; must be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module's documentation contains further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e078eeb299e1530ea0a1c7ae42a41d998f5aecf7" translate="yes" xml:space="preserve">
          <source>To be documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4aa18bea852a508605d53caeef9c5f926d90dc" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;em&gt;s&lt;/em&gt; is preallocated with an additional amount equal to the byte length of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e8cced600feca55a223908d10e5130220dfada" translate="yes" xml:space="preserve">
          <source>To be used when diffing times. Consider using &lt;em&gt;between&lt;/em&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e63287bf2192ba9bdf47d785bd859bfea604a0" translate="yes" xml:space="preserve">
          <source>To call a procedure that returns a value just for its side effects and ignoring its return value, a &lt;code&gt;discard&lt;/code&gt; statement &lt;strong&gt;must&lt;/strong&gt; be used. Nim does not allow silently throwing away a return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd6812cedca0f8d3ecee1c4880b1874c327d444" translate="yes" xml:space="preserve">
          <source>To change the compiler from the default compiler (at the command line):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e14482cffd7a387356de093fd85fe0f7385173" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b72107dca9af29a5cf8e0cbfd67507a7bbcd4c" translate="yes" xml:space="preserve">
          <source>To compile a release version use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dace50e38237573560e76fd9fe662d2da1a4dc" translate="yes" xml:space="preserve">
          <source>To compute power between integers, use &lt;em&gt;^&lt;/em&gt; e.g. 2 ^ 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d351e4cf238073c675c29349e5026ed8e407aa" translate="yes" xml:space="preserve">
          <source>To create a new compiler for each run, use &lt;code&gt;koch temp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55053d7dbb6eec73712afca1d06925e6eb2fac3c" translate="yes" xml:space="preserve">
          <source>To cross compile, use for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e0b2d9936526053d98cae64c97e80a452c5953" translate="yes" xml:space="preserve">
          <source>To decode a base64 encoded data string simply call the &lt;code&gt;decode&lt;/code&gt; procedure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5be3702ce16d9f83c4069146c2c5cbe57cdba3" translate="yes" xml:space="preserve">
          <source>To define a new operator enclose the operator in backticks &quot;``&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb15e30b9d578a4da7a5878df01aeed724c88088" translate="yes" xml:space="preserve">
          <source>To define new commands like &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; and &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; in the examples, the concept of a &lt;em&gt;procedure&lt;/em&gt; is needed. (Some languages call them &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;.) In Nim new procedures are defined with the &lt;code&gt;proc&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb3cbb5f800fd3864fa68084a11d47c5e74ac25" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;em&gt;documentation&lt;/em&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;em&gt;generated API&lt;/em&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c41b02b95231a84de881a8a918eb15cfd5edbe" translate="yes" xml:space="preserve">
          <source>To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor. By convention this entry without anchor is the &lt;em&gt;title entry&lt;/em&gt;, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word &lt;strong&gt;Module&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee4e0702447b58e78b6bb613d5d237b6836e9f3" translate="yes" xml:space="preserve">
          <source>To enable realtime support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the GC supports the following operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7636be4ab67a90f1533c1be5ea8689d1d192cf03" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low level thread API. There are also high level parallelism constructs available. See &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0f5e0bd57a707dc272d6bdaa13536fe61b6dd8" translate="yes" xml:space="preserve">
          <source>To find the name of a nimble package the compiler searches for a &lt;code&gt;*.nimble&lt;/code&gt; file in the parent directory hierarchy of whatever module you are compiling. Even if you are in a subdirectory of your project, a parent &lt;code&gt;*.nimble&lt;/code&gt; file will influence the naming of the nimcache name. This means that on Unix systems creating the file &lt;code&gt;~/foo.nimble&lt;/code&gt; will automatically prefix all nimcache files not part of another package with the string &lt;code&gt;foo_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab93f39bb400a5b2494d8a733289a48baa43e8f" translate="yes" xml:space="preserve">
          <source>To force a full collection call &lt;code&gt;GC_fullCollect&lt;/code&gt;. Note that it is generally better to let the GC do its work and not enforce a full collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83582671ff318357a306f2d73afcc6c6193db0e5" translate="yes" xml:space="preserve">
          <source>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;, which at first look seems a daunting task. But we can use as helper shortcut the &lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree macro&lt;/a&gt;, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of &lt;code&gt;const&lt;/code&gt; symbols we can create the following source file and compile it to see what the compiler &lt;em&gt;expects&lt;/em&gt; from us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e80bf64e7a28669c506f4ab558d9ed800f9037" translate="yes" xml:space="preserve">
          <source>To get rid of hygiene in templates, one can use the &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; pragma for a template. &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; have no effect in &lt;code&gt;dirty&lt;/code&gt; templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f3a2ffb603c43346bb1ea2785b67acec3d702" translate="yes" xml:space="preserve">
          <source>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a57ad28acbc5e4b10960f2e801cd4aa99747b3" translate="yes" xml:space="preserve">
          <source>To link against &lt;code&gt;nimrtl.dll&lt;/code&gt; use the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2039b927dcf641bab171f78845015d45672f1c9e" translate="yes" xml:space="preserve">
          <source>To make the &lt;code&gt;createWindow&lt;/code&gt; proc easier to use it should provide &lt;em&gt;default values&lt;/em&gt;; these are values that are used as arguments if the caller does not specify them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a5b8288b3fecf0f566c82b883159042530cd8e" translate="yes" xml:space="preserve">
          <source>To make the compiler output code for a 16bit target use the &lt;code&gt;--cpu:avr&lt;/code&gt; target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50bfd9dce33230fbb2c8127c3c5a8cde5dbf040a" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma block can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd77706967ab0eca2f0aba7e8dc6a7369cc5358" translate="yes" xml:space="preserve">
          <source>To pass a block of statements to a template, use 'untyped' for the last parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1d6bbadfa15e666e4a5bc97ac5b074bba176ef" translate="yes" xml:space="preserve">
          <source>To prevent confusing code there is a parsing limitation; if the &lt;code&gt;try&lt;/code&gt; follows a &lt;code&gt;(&lt;/code&gt; it has to be written as a one liner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee8374e17ee5570d2e73eb9424e263793331053" translate="yes" xml:space="preserve">
          <source>To produce a single &lt;code&gt;&quot;&lt;/code&gt; within a raw string literal, it has to be doubled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67c70af6b5e6b03d2581b5a5c05f83968ba3a74" translate="yes" xml:space="preserve">
          <source>To produce a single substitution character it has to be doubled: &lt;code&gt;$$&lt;/code&gt; produces &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6149c77815fef9fc27e4a6217efcefadefe95220" translate="yes" xml:space="preserve">
          <source>To remove this event you should use the &lt;code&gt;delHandleWrite&lt;/code&gt; function. It is advised to use that function instead of just setting the event to &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; as that would mean that that function would be called constantly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dc2bd124108bb715e2125357f3ca8cff675a9b" translate="yes" xml:space="preserve">
          <source>To retrieve the value of &lt;code&gt;&quot;key&quot;&lt;/code&gt; you can do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2272069ae83ac24e5887939db19d33d7075a38" translate="yes" xml:space="preserve">
          <source>To see a list of Nimble's packages, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; or the &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages repos&lt;/a&gt; on GitHub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb591463a2bf5bfe74be5c756dd27d755e4b62" translate="yes" xml:space="preserve">
          <source>To specify the AST for the different Nim constructs, the notation &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; or &lt;code&gt;nodekind(value)&lt;/code&gt; or &lt;code&gt;nodekind(field=value)&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23947ec0494a83fa76619311a6fe3ef2b338db4" translate="yes" xml:space="preserve">
          <source>To the end of the tuple/object definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f79e9096a797c7afc08420ab23a519537e4fb67" translate="yes" xml:space="preserve">
          <source>To understand some of the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596784d34744359d8630e6bf6d5a5b5ef239775c" translate="yes" xml:space="preserve">
          <source>To unpack raw bytes look at the &lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd0e4773e807b447d8759bcce32b13725171fb1" translate="yes" xml:space="preserve">
          <source>To use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fa9c66bf6fe6910167c4b6d93b8e2ef5d6e2c3" translate="yes" xml:space="preserve">
          <source>To use a filter for a source file the &lt;code&gt;#?&lt;/code&gt; notation is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd3786ffe14095836ecde08c5a7353e00f84790" translate="yes" xml:space="preserve">
          <source>To use threadsafe version of this module, it needs to be compiled with both &lt;code&gt;-d:threadsafe&lt;/code&gt; and &lt;code&gt;--threads:on&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31052631155b690d2c6d4d6d38ee09a1e1936e39" translate="yes" xml:space="preserve">
          <source>To verify that idetools is working properly there are files in the &lt;code&gt;tests/caas/&lt;/code&gt; directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9f1bbe8f37ac15cd7d8886750a127655bd140" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;c2nim&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b661fcccef784df68a5a22da94f9a1df408bd3" translate="yes" xml:space="preserve">
          <source>To write macros, one needs to know how the Nim concrete syntax is converted to an AST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b94544fc25d4f617242b0db05703f0c24a3b42d" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings for interpolation purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dabecffbc85d3462b703f6f51a8d742d3888dc3" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df68215c8e8bc621359763d151b72a86c6da974" translate="yes" xml:space="preserve">
          <source>Tools available with Nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58446c7f2b2e4db0f99d43b03101c0a822d287a4" translate="yes" xml:space="preserve">
          <source>Tools documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe5db2636efc921cd0bb4e6546d660babab9b05" translate="yes" xml:space="preserve">
          <source>Top level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb14fa6e0884cf02668ea33f83561399f74d1358" translate="yes" xml:space="preserve">
          <source>Top level accesses to &lt;code&gt;gdata&lt;/code&gt; are always allowed so that it can be initialized conveniently. It is &lt;em&gt;assumed&lt;/em&gt; (but not enforced) that every top level statement is executed before any concurrent action happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aac1979dafc6f8136821295c2c76ca0331a0e00" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;em&gt;ptr T&lt;/em&gt; is implicitly convertible to the &lt;em&gt;pointer&lt;/em&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0c2775cf7c51f8a1bb67ce0e0ab81a950538e4" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword; untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fc498182e45877c7d386bad77456516385d934" translate="yes" xml:space="preserve">
          <source>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. &lt;code&gt;Timeout&lt;/code&gt; is in milliseconds and -1 can be specified for no timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7b92acc9a145b44981e2aafa578d392367d9b9" translate="yes" xml:space="preserve">
          <source>Transforms any iterator into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab31ee25d07a8f9d5ddc9927e74c06ef43d27b4f" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;em&gt;replacements&lt;/em&gt; proc to substitute words inside &lt;em&gt;s&lt;/em&gt; with their replacements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c36d78b13e6dda8f6d500d67c359740cbced46" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the indexes do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3793e0cbf6a67e24ccddc9cfe73cf06db3bff8f2" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the keys do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9165124d411bbca6b0b36e2cf0040381f82a3771" translate="yes" xml:space="preserve">
          <source>Traverses the node and tries to set the value at the given location to &lt;code&gt;value&lt;/code&gt;. If any of the keys are missing, they are added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e25a6b8cf8a864963e049e7d35bac34d38d59" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;em&gt;true&lt;/em&gt; on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468da52d5869ae376d9b95725718bd6ff03dd727" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0489b14e1e492e61e5c98226d96a5ae8a905f" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;em&gt;c&lt;/em&gt;, but this can fail for all sort of reasons, including contention. If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e8185659254fff6635dee26e78e5d85bff42cc" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;em&gt;data&lt;/em&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1f450205803ed460a630c26002dda1d5353960" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread. &lt;em&gt;msg&lt;/em&gt; is deeply copied. Doesn't block. Returns &lt;em&gt;false&lt;/em&gt; if the message was not sent because number of pending items in the channel exceeded &lt;em&gt;maxItems&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7db82aabe0ec4b37ab6dba207f6dfa98f250d7" translate="yes" xml:space="preserve">
          <source>Trigger event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3c207482b9595dc0f6457a13d2f1e61c56e381" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value (&lt;em&gt;x&lt;/em&gt;). Modifies the passed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afddc6dcc2da91db52e6db34c078cda6ecf5a529" translate="yes" xml:space="preserve">
          <source>Triple quoted string literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245ceee2586082dc5a73679c70b42d08a85510ee" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;x&lt;/em&gt; to the decimal point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02715c4b7ff15274f4612905c77b4bda81876e45" translate="yes" xml:space="preserve">
          <source>Try can also be used as an expression; the type of the &lt;code&gt;try&lt;/code&gt; branch then needs to fit the types of &lt;code&gt;except&lt;/code&gt; branches, but the type of the &lt;code&gt;finally&lt;/code&gt; branch always has to be &lt;code&gt;void&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af062d7b75f8335dbdc49667ebc20f3bbd46f5" translate="yes" xml:space="preserve">
          <source>Try expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f526bd18e3a74520efcc9c43abfaeabfe401e20b" translate="yes" xml:space="preserve">
          <source>Try statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb959bb7d8da3f5b1a99088eb043845c557941e" translate="yes" xml:space="preserve">
          <source>Tuple or object scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f99aa09c1ddebfc55f57b61f023038ddf8cd672" translate="yes" xml:space="preserve">
          <source>Tuple unpacking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="b3e2bebd3f6bc134f276b0e73ccd708819d73bd3" translate="yes" xml:space="preserve">
          <source>Tuples and object types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4591fb7e2e6af521b3d77017031f788c69e63561" translate="yes" xml:space="preserve">
          <source>Tuples can be &lt;em&gt;unpacked&lt;/em&gt; during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc from the &lt;a href=&quot;os&quot;&gt;os module&lt;/a&gt; which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8352a113514bb2d5c1a998e7f4b0ab2c15a44826" translate="yes" xml:space="preserve">
          <source>Tuples which are longer than one line should indent their parameters to align with the parameters above it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b346e4953356d44049c162bd3c503c985bc5b32" translate="yes" xml:space="preserve">
          <source>Turn a deque into its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8743e385990daa129ed7fd77c0aab253383cfcf0" translate="yes" xml:space="preserve">
          <source>Turn a rational number into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6530f1075ffd79f7adf57fbf48c454fea802b4a4" translate="yes" xml:space="preserve">
          <source>Turning the &lt;code&gt;log&lt;/code&gt; proc into a template solves this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcf0ab5d7d983b90173092de9a62442f37e633f" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;em&gt;new&lt;/em&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4a9c5e9fbeb1731e11e217df10a5e9df4c2462" translate="yes" xml:space="preserve">
          <source>Turns off runtime checks and turns on the optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f84b7302f8b2c0acedd7493fcbdb678ea820d7e" translate="yes" xml:space="preserve">
          <source>Turns the code generation for all runtime checks on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8359c50c168a0d32c1676689b7b9be53909574c9" translate="yes" xml:space="preserve">
          <source>Turns the code generation for array bound checks on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78de984f73e6a96b608abf84f509342b6416676c" translate="yes" xml:space="preserve">
          <source>Turns the code generation for assertions on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85728da201c7e87406c7977edcd7efb848370e2" translate="yes" xml:space="preserve">
          <source>Turns the code generation for nil pointer checks on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7443a6fe5c166cf5312e85d734da57674e23a9ea" translate="yes" xml:space="preserve">
          <source>Turns the code generation for over- or underflow checks on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634d9e7817c9bcc8bdbbd8305a699f04a3c9ba2f" translate="yes" xml:space="preserve">
          <source>Turns the hint messages of the compiler on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dcbf296f2f4c34221163dd4a790e8efb28f099" translate="yes" xml:space="preserve">
          <source>Turns the term rewriting templates/macros on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31cc462c8ec7105eb07e2c1b5bb943c21db3b4d" translate="yes" xml:space="preserve">
          <source>Turns the warning messages of the compiler on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="779de5f9680bb0a0d05277f00d89d734c054b346" translate="yes" xml:space="preserve">
          <source>Tutorial (part I)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a76eed53f23547280f2ddf6517628c83064326" translate="yes" xml:space="preserve">
          <source>Tutorial (part II)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5778f261d1733e81971ab8e088ac48fafe7c0eb" translate="yes" xml:space="preserve">
          <source>Tweaking the GC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778080b9d6142ab857443b50014ddb8d3ccd44e2" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Timezone&lt;/code&gt;'s are considered equal if their name is equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a865c6e91cc1b9c8041b930bdded2be0556b0e5" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equal if the following algorithm returns true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6298e080874877d7a98b594edb938f20831dfff6" translate="yes" xml:space="preserve">
          <source>Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="1e4286f84aa2ec1726d2f29d48fef0c9bf605e85" translate="yes" xml:space="preserve">
          <source>Type Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eb387e477546545eec601f050672bd06c02038" translate="yes" xml:space="preserve">
          <source>Type Suffix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517963ffe8430bed0d4f132dcd51c0d4eb3001b7" translate="yes" xml:space="preserve">
          <source>Type bound operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ce942200cd4ed497c93d87123ffa3584d50070" translate="yes" xml:space="preserve">
          <source>Type casts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3e880739673e946c25d0dedcde2653a7c48216" translate="yes" xml:space="preserve">
          <source>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21eb352df05ecea6a3a588dc0c8590e21dbccc2" translate="yes" xml:space="preserve">
          <source>Type classes can be combined using the standard boolean operators to form more complex type classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d7f20ec3a1f2c32685f21a24578ef7bfd33afb" translate="yes" xml:space="preserve">
          <source>Type conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7893cb518df1f3e86b37b8f2c89bf262fddc71ea" translate="yes" xml:space="preserve">
          <source>Type conversions are a much more polite way to convert a type into another: They preserve the abstract &lt;em&gt;value&lt;/em&gt;, not necessarily the &lt;em&gt;bit-pattern&lt;/em&gt;. If a type conversion is not possible, the compiler complains or an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d227e4926b1f493d28e95f292386e3a242d08693" translate="yes" xml:space="preserve">
          <source>Type conversions are compile-time computable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5ad7af6975f8633efeb665458c5b9ad70586b8" translate="yes" xml:space="preserve">
          <source>Type equality modulo type distinction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a4537d409bc84d0e6885dd98224efa069a4125" translate="yes" xml:space="preserve">
          <source>Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which &lt;strong&gt;may&lt;/strong&gt; use PascalCase but are not required to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f50bbe8baba25a1929146d13b1d95279794e199" translate="yes" xml:space="preserve">
          <source>Type of the symbol. This can be &lt;code&gt;skProc&lt;/code&gt;, &lt;code&gt;skLet&lt;/code&gt;, and just about any of the enums defined in the module &lt;code&gt;compiler/ast.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b2d40508694dd4577a697d9c6b4c5f2e3511da" translate="yes" xml:space="preserve">
          <source>Type section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ed3f78d17ddb423376e5e7d24d9be0086053f6" translate="yes" xml:space="preserve">
          <source>Type sections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919a22549142ebb39423637cf5e8cc1b5dc6cbb" translate="yes" xml:space="preserve">
          <source>Type that describes &quot;standard format specifiers&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ed1febf2dc93666a9e94d3bca2653e2f2eba89" translate="yes" xml:space="preserve">
          <source>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. &lt;code&gt;proc (File)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5204c9867a362caf0bea9525b902dfe2dc066c0b" translate="yes" xml:space="preserve">
          <source>Typed future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1cf3d18ff7e16dcb6cdb495e43f6f5c061a5575" translate="yes" xml:space="preserve">
          <source>Typed vs untyped parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5720ec6d00feb96f366d8679918ecb98f50f66f7" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;code&gt;connect&lt;/code&gt; procedure. They can simply start sending data immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9248393d371f6ac0d6c435085d705c597add4700" translate="yes" xml:space="preserve">
          <source>UNIX domain socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5994d61577cd9a76d59a20c617c73875837d1477" translate="yes" xml:space="preserve">
          <source>UNIX specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b8776f6733aef4d62e2f6de4be839fb81aa572" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;+&lt;/em&gt; operator for an integer. Has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb73268790c9b1bb4d1863a2400ec7e0bd4b9f82" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;-&lt;/em&gt; operator for an integer. Negates &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70afc8908f864590618bb835ddbe12b01425b489" translate="yes" xml:space="preserve">
          <source>Unary minus for complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b26f2db358e2b9c8ee6c1ec77a16447b17be07f" translate="yes" xml:space="preserve">
          <source>Unary minus for rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26886835eb6cc81330ad426b552f908727e34bfa" translate="yes" xml:space="preserve">
          <source>Unary operators always bind stronger than any binary operator: &lt;code&gt;$a + b&lt;/code&gt; is &lt;code&gt;($a) + b&lt;/code&gt; and not &lt;code&gt;$(a + b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15caf31c9aaa57bf878b33c847d4e21c87bdd599" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;em&gt;==&lt;/em&gt; operator and also when types dependent on them are being matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb24ca63e88421d2f543a770d935d8deff96d75" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;em&gt;s.push(T)&lt;/em&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;em&gt;x.pop is T&lt;/em&gt; and &lt;em&gt;x.data is seq[T]&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a277ebe87b91b0033079926c198a2b95dd5a89ed" translate="yes" xml:space="preserve">
          <source>Unchecked pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780b27a9e0cd026ae3df440893ad4cc13c021cef" translate="yes" xml:space="preserve">
          <source>Under Windows, &lt;code&gt;ShellExecute&lt;/code&gt; is used. Under Mac OS X the &lt;code&gt;open&lt;/code&gt; command is used. Under Unix, it is checked if &lt;code&gt;xdg-open&lt;/code&gt; exists and used if it does. Otherwise the environment variable &lt;code&gt;BROWSER&lt;/code&gt; is used to determine the default browser to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf8b89716eab57348a639af00765efe9e3f101" translate="yes" xml:space="preserve">
          <source>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec38b8f74e8905e6cb3c56b8e4d8603f3e7c7d9" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b681f3dab8eeb99f700c878d07af066931b521" translate="yes" xml:space="preserve">
          <source>Unfortunately optimizations are hard to get right and even the tiny example is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979fe2a9e37e36b1d1a6a4517ab5b601b5d48fdb" translate="yes" xml:space="preserve">
          <source>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab317435de1ae8699f1bac973f0926492ea1744" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;d + 12.Dollar&lt;/code&gt; is not allowed either, because &lt;code&gt;+&lt;/code&gt; is defined for &lt;code&gt;int&lt;/code&gt; (among others), not for &lt;code&gt;Dollar&lt;/code&gt;. So a &lt;code&gt;+&lt;/code&gt; for dollars needs to be defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257828b764d9609e93e07a012bbe1f755b3e4143" translate="yes" xml:space="preserve">
          <source>Unicast link-local address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db89ced902c1b469d3ee6d37350cad15573da1b7" translate="yes" xml:space="preserve">
          <source>Unicast site-local address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20432d22d5eb062ea9c2106c1c80aefa6d897164" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924d62607597504901be1ad3edea9517a5c76a1f" translate="yes" xml:space="preserve">
          <source>Union pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa0003b8a6b26c8afe5d3f50a8127082e93fdb8" translate="yes" xml:space="preserve">
          <source>Unknown file type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d54b69a2b42e57628182cdd2fb4ccd4dc4e49e" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;em&gt;{.pure.}&lt;/em&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1db02d8fefccbf077d86e2884c344faded7045" translate="yes" xml:space="preserve">
          <source>Unless you explicitly use the &lt;code&gt;-o:filename.js&lt;/code&gt; switch as mentioned in the previous examples, the compiler will create a &lt;code&gt;filename.js&lt;/code&gt; file in the &lt;code&gt;nimcache&lt;/code&gt; directory using the name of your input nim file. There are no other temporary files generated, the output is always a single self contained &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555ac3aebe10e2203997f49b6308860e82f3cf38" translate="yes" xml:space="preserve">
          <source>Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;times&lt;/code&gt; stdlib modules instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8a103bee5df59c3c762061b4c9d13541d1ab2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, this function will not raise an exception if the Future has not been finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d3c06510e1a9b072a372d11ed5099a19477622" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;sockets.recvLine&lt;/code&gt; this function will raise an EOS or ESSL exception if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e750c92c37341f3392054d626734256f8a0787c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual paramater with &lt;a href=&quot;#paramStr&quot;&gt;paramStr()&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834e7e344f224920e087953eb402fca07a2f1f3c" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22870d2d3c9ed068f87598a420f675c1914b8e0c" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abf83a8fb810b07df5666c0186be330c1d74dbb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21aec3b4730e3f9365e0105b5ee932445d7a6ca" translate="yes" xml:space="preserve">
          <source>Unmarshalling JSON into a type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274fd6abb97e41f164eb1ef8fe9181521b3bcfb9" translate="yes" xml:space="preserve">
          <source>Unregisters &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5d6ca9aa56c6378bdd4192beb1a23d43d8436b" translate="yes" xml:space="preserve">
          <source>Unregisters deleg &lt;code&gt;deleg&lt;/code&gt; from dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da32f8ccff4f9629c24e55368ee80c187804e943" translate="yes" xml:space="preserve">
          <source>Unregisters event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcde071a887a5fe31b2a030c3e5fa7b13b8951b5" translate="yes" xml:space="preserve">
          <source>Unregisters file/socket descriptor &lt;code&gt;fd&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289ac9aad529193af73566b90baf875386cf6586" translate="yes" xml:space="preserve">
          <source>Unregisters user-defined event &lt;code&gt;ev&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce62d653fe1244a4a172cf34cf9ff901d873cb95" translate="yes" xml:space="preserve">
          <source>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793e97a099a191f13d3623cc72e9fcc4ea98314f" translate="yes" xml:space="preserve">
          <source>Unspecified address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eed1f531c71d473a16fbfc4bdc992980d7fde4" translate="yes" xml:space="preserve">
          <source>Untyped future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338a06f904b267724d0e4a6607e91229e8bd5122" translate="yes" xml:space="preserve">
          <source>Unused symbols in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b761e5e6e2982b87d1d1ce7451421af2e056fcdd" translate="yes" xml:space="preserve">
          <source>Update file/socket descriptor &lt;code&gt;fd&lt;/code&gt;, registered in selector &lt;code&gt;s&lt;/code&gt; with new events set &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac74192ba332a2e96c10e6e3a98aa5ef90a38c" translate="yes" xml:space="preserve">
          <source>Uploading a new file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8437e83622dcd6616eee43bc0f900abcc44066bc" translate="yes" xml:space="preserve">
          <source>Uploads &lt;code&gt;file&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvStore&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the upload is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b7ab0e221278f7b19c0e2120c647473f14e9c5" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;shallow&lt;/code&gt; is always safe once you know the string won't be modified anymore, similar to Ruby's &lt;span id=&quot;freeze_1&quot;&gt;freeze&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e50c56f66708798022fbc1f1eb983ee9aeeb0b23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initSet&quot;&gt;initSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b9c2cf3847d0d4137fb09319498c7a48280b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069c6a70b51730b216fe49517948e5c25ee3f68d" translate="yes" xml:space="preserve">
          <source>Use CamelCase, not underscored_identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0419552b8b43316dc697b19a811e19aebbdcdf2" translate="yes" xml:space="preserve">
          <source>Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee29cb81b4a1c27e3913f57892fcf63971ad6672" translate="yes" xml:space="preserve">
          <source>Use a space after a colon, but not before it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eaeb50702c4af6019f309c53108d48c5e121d67" translate="yes" xml:space="preserve">
          <source>Use an ordinary proc/iterator, if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18016a67bd4f948da9845d49f07cb8371b4ab483" translate="yes" xml:space="preserve">
          <source>Use setjmp backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72ae5e3053e46a037835089c157a676efe9253b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;let&lt;/code&gt; statement (not the &lt;code&gt;var&lt;/code&gt; statement) when declaring variables that do not change within their scope. Using the &lt;code&gt;let&lt;/code&gt; statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66274d10986776dc87f06f202d0f3cb8c3fe3937" translate="yes" xml:space="preserve">
          <source>Use the linenoise library for interactive mode (not needed on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6549bd6999bce5cb0be51276ff5b08c60300d9" translate="yes" xml:space="preserve">
          <source>Use this if you want to use asyncio's dispatcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc79ccd7635f50d22e57841cdbe2adc22f78a697" translate="yes" xml:space="preserve">
          <source>Use this overload if one of the enums specified above does not contain what you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865aa831216ca96d4d105c4dd19b7daa3f190a58" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bc2b4499c7c25fe666bf75531910175755c00e" translate="yes" xml:space="preserve">
          <source>Use uClibc instead of libc. (Relevant for Unix-like OSes)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f211d2e480794537e3020e2cfb5c46539ca8d42" translate="yes" xml:space="preserve">
          <source>Use ucontext backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e128770cbe82e55e9551991395c199aea047021" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;asynchttpserver&lt;/code&gt; and &lt;code&gt;httpclient&lt;/code&gt; internally and should not be used by you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8732bc6e9c0c3e17ad4cc39e7b18e2c8e01853" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02c3c02a1cba6f1b623a143ee4ff49577aeda10" translate="yes" xml:space="preserve">
          <source>Useful if performing parallel analysis of data series and need to re-combine parallel result sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51e8109e780dfdf6a418dbd0475739d284873d7" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="e62ab5dd60dc7797b971e6696b18be2c527a419c" translate="yes" xml:space="preserve">
          <source>User definable matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb81abb7fd49094ec59b4c3147077b637691ca6" translate="yes" xml:space="preserve">
          <source>User defined matcher. Uses the proc &lt;code&gt;foo&lt;/code&gt; to perform the match. See below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b935fbc2614493a2c4b14ccf26901cbcb010eb56" translate="yes" xml:space="preserve">
          <source>User defined operators are allowed. Nothing stops you from defining your own &lt;code&gt;@!?+~&lt;/code&gt; operator, but doing so may reduce readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8f45c91aea8077d8fc0d06a397a16ed0dc1c79" translate="yes" xml:space="preserve">
          <source>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier &lt;code&gt;in&lt;/code&gt; to a parameter to make it contravariant or &lt;code&gt;out&lt;/code&gt; to make it covariant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce325aeace53a2b93d052357d730389323d4341" translate="yes" xml:space="preserve">
          <source>UserRaw</source>
          <target state="translated">UserRaw</target>
        </trans-unit>
        <trans-unit id="e300487a9b9ba07551dbd02395ad2f5ceb2cd7ff" translate="yes" xml:space="preserve">
          <source>Uses &lt;em&gt;default&lt;/em&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91247aefaea76611ed3be253ec73d5452247797e" translate="yes" xml:space="preserve">
          <source>Uses the state to compute a new &lt;code&gt;uint64&lt;/code&gt; random number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82312a15160a4eb2e934bf4a7bfbfafc8e93262e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from math as m import pow&lt;/code&gt; works identically to the &lt;code&gt;as&lt;/code&gt; modifier with the &lt;code&gt;import&lt;/code&gt; statement, but wrapped in &lt;code&gt;nnkFromStmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434eb8681f8aae0fc0009510a5ce82ae4ac62f77" translate="yes" xml:space="preserve">
          <source>Using HTTP POST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597d5caf1abedf8be885d6b02a498c8313c21cab" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;enum&lt;/code&gt; is similar to using an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2077b1edc67aa09ddf48ed8fc866598362c96a" translate="yes" xml:space="preserve">
          <source>Using statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0ffb656f43cb27f5cdd45b79d0245f11508098" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;#assert&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b613dc5bf77d7eebd40398bbfcda8a848bcf8f" translate="yes" xml:space="preserve">
          <source>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type &lt;code&gt;untyped&lt;/code&gt;. Because symbol lookups are then delayed until template instantiation time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="94caea3c7c64ca00d9ac21ea83a77703d0e697ae" translate="yes" xml:space="preserve">
          <source>Var parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94fe3891ba9b2a70b6f7c93dcf19ff406473182" translate="yes" xml:space="preserve">
          <source>Var return type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0b2dfd47bbac896a3b7fa7c65e08461b5b0de0" translate="yes" xml:space="preserve">
          <source>Var section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914863c14c6479013852278b1f8b3334db12b752" translate="yes" xml:space="preserve">
          <source>Var statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add491eaab149ea45f6c1fe0151b0684f58a9169" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8aad770addffb7c9ee321a2ae20d74343b6752" translate="yes" xml:space="preserve">
          <source>Varargs</source>
          <target state="translated">Varargs</target>
        </trans-unit>
        <trans-unit id="7d9fcf6d5d84f212e746c0dd60f0871afacbb237" translate="yes" xml:space="preserve">
          <source>Varargs matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a470ac65b2238b82d8d8713eb8a548a3249ba" translate="yes" xml:space="preserve">
          <source>Varargs of untyped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77559312e7c433e8e5ee29c1bb6cbeca9a08ec04" translate="yes" xml:space="preserve">
          <source>Varargs pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805fa97816cdbe137bc65aece5e19b6969589e6d" translate="yes" xml:space="preserve">
          <source>Variables can also be reordered as well. Variables that are &lt;em&gt;initialized&lt;/em&gt; (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f285e0b395df604d798c7e2bb2b23e2eae4f1e8f" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;recvFrom&lt;/code&gt; for non-blocking sockets. Unlike &lt;code&gt;recvFrom&lt;/code&gt;, this function will raise an EOS error whenever a socket error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a9cbeb25f6e324f126507ad323389964644919" translate="yes" xml:space="preserve">
          <source>Variant of select with only a read and write list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="c0e92bae9fcb6a7281bd801df9748260bc15749f" translate="yes" xml:space="preserve">
          <source>Verbatim string match for back reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6cf59698ac3aaae8c44d3c15b6e3e4cda4c5a2" translate="yes" xml:space="preserve">
          <source>Verbatim string match: Use this to override a global &lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\y&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f86f02d25018ae2892b7bd1afddf0b541788d2" translate="yes" xml:space="preserve">
          <source>Verbosity levels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12b4e999b16e9b02d25b9fcdd67d4fd655e16ae" translate="yes" xml:space="preserve">
          <source>Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if &lt;code&gt;outputLevel&lt;/code&gt; is not &lt;code&gt;PRINT_NONE&lt;/code&gt;). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf92590226e4f935af31645efa1ac42d722021ca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeImpl&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57aa9247bf27c4880a6334aaec93af41db7006d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeInst&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858b1e6c9eca4cf7c78fcd8fab9318b40196ab03" translate="yes" xml:space="preserve">
          <source>Viceversa, one can also use &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; to declare that &lt;code&gt;SYMBOL&lt;/code&gt; should be considered not defined, and hence skip &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b4a6297c88554060939c3b1d4cb2536eb7bee3" translate="yes" xml:space="preserve">
          <source>Void context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962f34b2afbbced77fbbf76af036107dbe53ad9d" translate="yes" xml:space="preserve">
          <source>Volatile pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c74f4c3dc47b71577d22318b41d7984b1abbb7" translate="yes" xml:space="preserve">
          <source>Waiting for a subprocess to finish. A subprocess can be started, but right now it can't be waited on, which sort of makes subprocesses a bit hard to use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74d0d5b2aa91ca4f2eda490c658dd7df90ccca2" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6c37027d7f2e6c6ab4b80a9728bdfd41e4de6e" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. This runs the underlying OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; or &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; primitive only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7309ba8763f2cd6a0b2e52be4a1bdf5400867492" translate="yes" xml:space="preserve">
          <source>Waits for events registered in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a009040341eedf69627aff9b5c29bf4b8425403d" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;em&gt;filters&lt;/em&gt; controls the behaviour of the iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd311d8cb591a6fc0622efcf10ea3ea470116f2" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;em&gt;path&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f61ac580a8669e5f5ddb85827db56efd269d4d4" translate="yes" xml:space="preserve">
          <source>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a2a483409f9e01cee9aa93831fe0f06d054b92" translate="yes" xml:space="preserve">
          <source>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412166e831c66d50243ea6b997febce22e1c0db" translate="yes" xml:space="preserve">
          <source>Warning: URL-encoded and Unicode attempts at directory traversal are not detected. Triple dot is not handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e0c14f084e128be516580f7f46caa6b881111d" translate="yes" xml:space="preserve">
          <source>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file &lt;code&gt;lib/system/hti.nim&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2d825d8ef9b527c8f3ffcca749e04b73530ffc" translate="yes" xml:space="preserve">
          <source>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the &lt;code&gt;PSym&lt;/code&gt; datastructure, it should work without any special logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf6af0d4d4b7bb7491ad339f0cd6b4eecccde3c" translate="yes" xml:space="preserve">
          <source>We call a proc &lt;code&gt;p&lt;/code&gt;&lt;span id=&quot;gc-safe_1&quot;&gt;GC safe&lt;/span&gt; when it doesn't access any global variable that contains GC'ed memory (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or a closure) either directly or indirectly through a call to a GC unsafe proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba455d231bded2509ebd8f9d1e8763309c843c4f" translate="yes" xml:space="preserve">
          <source>We can &quot;replay&quot; &lt;code&gt;stCode.add&lt;/code&gt; only if the values of &lt;code&gt;st&lt;/code&gt; and &lt;code&gt;apicall&lt;/code&gt; are known. And even then a hash table's &lt;code&gt;add&lt;/code&gt; with its hashing mechanism is too hard to replay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c15cc4bcae38711205717122d00cbaec2e62f3" translate="yes" xml:space="preserve">
          <source>We can achieve this using the &lt;code&gt;bindMethod&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fc4caa6ec680ff0de718216907b6b39698fd69" translate="yes" xml:space="preserve">
          <source>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc498265cc3ceafbd88456ff11eb0a32bb180e8f" translate="yes" xml:space="preserve">
          <source>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11914dec9459002787db2ce90468c35fd15a6ab" translate="yes" xml:space="preserve">
          <source>We have already seen the simple &lt;code&gt;import&lt;/code&gt; statement that just imports all exported symbols. An alternative that only imports listed symbols is the &lt;code&gt;from import&lt;/code&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c4a855c5c497242383a03a1f691a7e5a85ba0a" translate="yes" xml:space="preserve">
          <source>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92005b68f4a7df3a08d2ee2fa3d3d923557d80" translate="yes" xml:space="preserve">
          <source>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c36085b01e4f6e8f59835097cfb83f524dc4b57" translate="yes" xml:space="preserve">
          <source>We start the tour with a modified &quot;hello world&quot; program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e38ed24e3a1be9264a0daea556df68c3aba5e6" translate="yes" xml:space="preserve">
          <source>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8ba9ee33c2a6fb270c2b9858e20ee9e6e1de37" translate="yes" xml:space="preserve">
          <source>We use a mixture of bitset and hash table for this. The hash table maps &lt;em&gt;pages&lt;/em&gt; to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab20012d1620f5b85c5c37ea977935d4f505aea" translate="yes" xml:space="preserve">
          <source>We want to generate roughly this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113b69b591d6182bb037d0575303c945f53858ae" translate="yes" xml:space="preserve">
          <source>What is happening here is that the types used for table keys require to have a &lt;code&gt;hash()&lt;/code&gt; proc which will convert them to a &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; value, and the compiler is listing all the hash functions it knows. Additionally there has to be a &lt;code&gt;==&lt;/code&gt; operator that provides the same semantics as its corresponding &lt;code&gt;hash&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7366e079f6ffab6bc9ad768b8631449c4256e61f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcfff2350bc510e79fd004ac68bd4cb1f311382" translate="yes" xml:space="preserve">
          <source>What optimizers really need to do is a &lt;em&gt;canonicalization&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ccfee40ae325efd18fb6ffe045c18cb229f18f" translate="yes" xml:space="preserve">
          <source>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to &lt;code&gt;cint&lt;/code&gt;. Testing without the &lt;code&gt;-w&lt;/code&gt; option helps!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f4a3ec696cf15db4c5199b757938fbcc68be19" translate="yes" xml:space="preserve">
          <source>When 0 is returned the socket's connection has been closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5309ac6e6a926e840908775be647c2028a478adb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned the socket's connection has been closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017a1cdbf43acad895afedf8019b709fbd1b8c09" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a ref type then the resulting type will be &lt;code&gt;T&lt;/code&gt;, otherwise it will be &lt;code&gt;ref T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82a67761bf009b1ccc17019d024dead497b2c8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importcpp&lt;/code&gt; is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt;. (This turned out to be the simplest way to implement it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a139f37abab95c9bed1e71a37e9ff86bb1b47c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt; are non-empty then the ':' and '=' above are still accepted, but become optional. Note that these option key sets must be updated along with the set of option keys taking no value, but keys which do take values need no special updates as their set evolves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c515c96ec96f99594496b1328f30048f3de0cd1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;followSymlink&lt;/em&gt; is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4680275e7c901d5f3833c727cc99c5fb135e40" translate="yes" xml:space="preserve">
          <source>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an &lt;code&gt;untyped&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2eaaa4e3170b1469cf0690081d49d1771a1d85a" translate="yes" xml:space="preserve">
          <source>When OpenSSL is dynamically linked, the wrapper provides partial forward and backward compatibility for OpenSSL versions above and below 1.1.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae81d2c9c4d1fafceab9a15e0a86562d3247333" translate="yes" xml:space="preserve">
          <source>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b7ee84914a1420903931986e31a5241d62b138" translate="yes" xml:space="preserve">
          <source>When a procedure uses the special &lt;code&gt;var&lt;/code&gt; type return variable, the result is different from that of a var section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b4b802a770e586e56855a558c28871a136f5e3" translate="yes" xml:space="preserve">
          <source>When a request is made by a client the specified callback will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a7a3d1dd71e0b4cf302372876e2f1c5cc12058" translate="yes" xml:space="preserve">
          <source>When a request is made to a different hostname, the current connection will be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a07f0075ab0a45bf34eaf52dac74c940e4d650" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which can be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2377e8684393b2ce892159f2a4e80c538b1e3d8" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which &lt;strong&gt;cannot&lt;/strong&gt; be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43add50714f33e02f97cb791ebd99cd5319627ba" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bcbf0203513201bce5ea953d3b4e8ffa73d031" translate="yes" xml:space="preserve">
          <source>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc850e7757d223791640269bd02d07871233442e" translate="yes" xml:space="preserve">
          <source>When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7871f40dcafcdf1db9af282909ed84f0a0d5c2" translate="yes" xml:space="preserve">
          <source>When expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5390519091e9974a31ed036eaeb0253339bd37ca" translate="yes" xml:space="preserve">
          <source>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020893f63cc1aaaba0f76060df95101dd9c22483" translate="yes" xml:space="preserve">
          <source>When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a &quot;Obj&quot;, &quot;Ref&quot;, or &quot;Ptr&quot; suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1225645594c00f94369b8ea3ee23053edbf83ba3" translate="yes" xml:space="preserve">
          <source>When nimvm statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda49f871e7ef45866bd4f710af7f4927e2c1a8d" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=' they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb0504613b19518d968c26eceaaa8391745e36" translate="yes" xml:space="preserve">
          <source>When socket is non-blocking and no data is available on the socket, &lt;code&gt;-1&lt;/code&gt; will be returned and &lt;code&gt;data&lt;/code&gt; will be &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c99b697aa205b3dce70845af926b4da0b0718d3" translate="yes" xml:space="preserve">
          <source>When statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd80507fb2abefe95238353b2a9a7cfba726d9d1" translate="yes" xml:space="preserve">
          <source>When the 'returns transformed copy' version already exists like &lt;code&gt;strutils.replace&lt;/code&gt; an in-place version should get an &lt;code&gt;-In&lt;/code&gt; suffix (&lt;code&gt;replaceIn&lt;/code&gt; for this example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee41ae36de358d86d21ea16751455620675ba69a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;NimMain()&lt;/code&gt; function is called Nim initializes the garbage collector to the current thread, which is usually the main thread of your application. If your C code later spawns a different thread and calls Nim code, the garbage collector will fail to work properly and you will crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daad49e43f5115581c4b76d4a507c298160c9cb2" translate="yes" xml:space="preserve">
          <source>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd24854ac2b1bea3f20fcea6158974c3a2524eb3" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;em&gt;AnnotatedPtr&lt;/em&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c835f980849f2df2e29fb8df8dab183460e5e580" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. You can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92696d3f2ea1ae3634b81406709cbcffab8999" translate="yes" xml:space="preserve">
          <source>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the &lt;code&gt;of&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254e2ddbd3dd05fc683e34f1716f23a33c331fe1" translate="yes" xml:space="preserve">
          <source>When the process has finished executing, cleanup related handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe7cb68f3a591e4c2d4dcbbc522f1614fc7e0f0" translate="yes" xml:space="preserve">
          <source>When used as a table constructor, the syntax is different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaf6332aae7b182e062b2664c8075404ebd76b7" translate="yes" xml:space="preserve">
          <source>When used for matching, keep in mind that likewise scanf, no backtracking is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f917a7650b1a36cb2a4a1c6a6acf808f3f394e5" translate="yes" xml:space="preserve">
          <source>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d07aa5bc818ad3ec9bad7f3accf7a490ff3025" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header (requires a C compiler with _Static_assert support, like any C11 compiler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f14056818f81ec01f7058b5fdd03ac34cc67b2" translate="yes" xml:space="preserve">
          <source>When you are making an imported module accessible by modules that import yours, the &lt;code&gt;export&lt;/code&gt; syntax is pretty straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08835fa964ca44a302c76938b48f30469a0f0a5b" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6b91dbf30c6480d506d993a62a2e5ede60b7e6" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;docSeeSrcUrl&lt;/code&gt; switch to docgen, after each documented item in your source code the hyper link &lt;em&gt;See source&lt;/em&gt; will appear pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18a97667681fbb7bac72211a2b07123eb883bd7" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;rst2html&lt;/code&gt; command, all sections in the RST document will get an anchor you can hyper link to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the &lt;code&gt;doc&lt;/code&gt; or &lt;code&gt;doc2&lt;/code&gt; commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4c6ad2b222c2702bd12ce14dc109cc99b9422" translate="yes" xml:space="preserve">
          <source>Whenever a user creates a specialized object, implementation of this procedure provides for &lt;code&gt;string&lt;/code&gt; representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4cc3bb373e7618b80ba75c42e4df4653d3d72e" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same html file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeeaa58356082edb9c3248aa2f5880d152480e90" translate="yes" xml:space="preserve">
          <source>Where we are currently connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46461b4ca7f105357f8fd52e913f10563d7fe3fd" translate="yes" xml:space="preserve">
          <source>Whether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7602811bf6ae08bd5e22293258701c16580af8be" translate="yes" xml:space="preserve">
          <source>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the &lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt; and &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragmas: gensym'ed symbols are not exposed but inject'ed are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855714febc5eeb00b339faa0d12bd25d89659cb1" translate="yes" xml:space="preserve">
          <source>Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d41ff5608431c17e7d0fc23a167d921f5683a39" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$p.name&lt;/code&gt; can also be used, the &lt;code&gt;$&lt;/code&gt; operation on a string does nothing. Note that we cannot rely on automatic conversion from an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt; like we can for the &lt;code&gt;echo&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837197cffaa6ba949530b17e33bcba42ef50a34d" translate="yes" xml:space="preserve">
          <source>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as &lt;em&gt;one&lt;/em&gt; way to design a program, not &lt;em&gt;the only&lt;/em&gt; way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fff640cbdad99fe09274abee24df7bbf25d0561" translate="yes" xml:space="preserve">
          <source>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562bd6173e445712f1af66a953e8986ba0c2374d" translate="yes" xml:space="preserve">
          <source>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec9332bd403083c7c81ec7ddda4c8cfb83913d" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec95ebb740e8da659961135df7e65656f864a68" translate="yes" xml:space="preserve">
          <source>While similar to the &lt;span id=&quot;caller-info_1&quot;&gt;caller info&lt;/span&gt; of other languages, it is determined at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab874ba2e993f09c0db307995f9d97ec18bcd164" translate="yes" xml:space="preserve">
          <source>While statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441460d8bae7a87fe7d9e0c8e6f1dc6c4fb048ac" translate="yes" xml:space="preserve">
          <source>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455cc265958fecb1e713d605b1e591a53e7b0eb7" translate="yes" xml:space="preserve">
          <source>Whole routines can also be annotated with a &lt;code&gt;locks&lt;/code&gt; pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34796431c4136a13fc1a272537e43a27d56433b1" translate="yes" xml:space="preserve">
          <source>Windows specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f082c74fae11cd24ce038c421b38da0f7f03aa4d" translate="yes" xml:space="preserve">
          <source>Windows: this is still supported despite Windows platform not having this convention; also, both &lt;code&gt;~/&lt;/code&gt; and &lt;code&gt;~\&lt;/code&gt; are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10d3f7f20c0f9046a906444b8a60a2f35498a01" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;except&lt;/code&gt;, we get &lt;code&gt;nnkImportExceptStmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4974a309f4c94a4f9d5a2467682e0908cb7a682" translate="yes" xml:space="preserve">
          <source>With parenthesis and semicolons &lt;code&gt;(;)&lt;/code&gt; you can use statements where only an expression is allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d171ddc79243587420ce2e420c38a86ca6d787e" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--run&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;switch&lt;/a&gt; Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd482d4d9faa3aac000c3242487f0f59daaef12" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the &lt;code&gt;exportc&lt;/code&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023454d8e1cf65bbb06463e1b3d0c36017c3e388" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure or a variable can be imported from a dynamic library (&lt;code&gt;.dll&lt;/code&gt; files for Windows, &lt;code&gt;lib*.so&lt;/code&gt; files for UNIX). The non-optional argument has to be the name of the dynamic library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ed0ac91dffc6d43c92455d3eaf4fb792201cb9" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f010be8a21b14dff05310dc71f698e090ed9c5" translate="yes" xml:space="preserve">
          <source>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0036fe9e484a381c94e7a2817c459b4a03ab955b" translate="yes" xml:space="preserve">
          <source>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a &lt;code&gt;ConstSection&lt;/code&gt; and a &lt;code&gt;ConstDef&lt;/code&gt;. If we were to move all the constants to a single &lt;code&gt;const&lt;/code&gt; block we would see only a single &lt;code&gt;ConstSection&lt;/code&gt; with three children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae6de82250865ee469a39f7ecbc1836e2a60ef6" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;parallel&lt;/code&gt; section sometimes the &lt;code&gt;FlowVar[T]&lt;/code&gt; is eliminated to &lt;code&gt;T&lt;/code&gt;. This happens when &lt;code&gt;T&lt;/code&gt; does not contain any GC'ed memory. The compiler can ensure the location in &lt;code&gt;location = spawn f(...)&lt;/code&gt; is not read prematurely within a &lt;code&gt;parallel&lt;/code&gt; section and so there is no need for the overhead of an indirection via &lt;code&gt;FlowVar[T]&lt;/code&gt; to ensure correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f36950618b8748e3741661dd8fec794ecb08261" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ae57f97edbcd123ef0194b0d49cf9ec52d7039" translate="yes" xml:space="preserve">
          <source>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7765888ff783f01e496adca7f847d2e186e708cb" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;GCunref&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a9ca07a5dddf13d83fab735c567da3357a0bf" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6962ff8c9e27a68a644675d133701514aae2e762" translate="yes" xml:space="preserve">
          <source>Would output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436516f371b709f69cf997c54adc4f028f9eebcd" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef47240f283c974795c0afe97ed4a86669acef1" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d365d3fa59d526a0f2809a9f61b0028c5e94b10" translate="yes" xml:space="preserve">
          <source>Wrappers</source>
          <target state="translated">Wrappers</target>
        </trans-unit>
        <trans-unit id="533cb09f4efea84d68d3be20e42d0338fe89c618" translate="yes" xml:space="preserve">
          <source>Wrapping constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cdbcadb273848cfeb799098c4c21e8db2e9d40" translate="yes" xml:space="preserve">
          <source>Wrapping destructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3c9e84480e553d08468d0746063eeb3c7f119f" translate="yes" xml:space="preserve">
          <source>Wraps a connected socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket. &lt;code&gt;hostname&lt;/code&gt; should be specified so that the client knows which hostname the server certificate should be validated against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddc5519e19aff7c9640076ae420da42486453ed" translate="yes" xml:space="preserve">
          <source>Wraps a socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cc7fed3b72e2c8ac3c8047c2bf9e4c909ccdc0" translate="yes" xml:space="preserve">
          <source>Wraps an already initialized &lt;code&gt;Socket&lt;/code&gt; into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f942433295c32b403eab1ccdf7cdbcb2774f2494" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c97819e5811aa1e2b05fd1d97141d7dc4900644" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;buf&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897e1a9e1ed791afbff422f3f8123f94d65ede78" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;data&lt;/em&gt; to the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e3f5c8aacd0969383d67b232c4242e0fbab6cf" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;em&gt;f&lt;/em&gt;. May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b82505d585d59b7b931841c5790d2d061a18cf" translate="yes" xml:space="preserve">
          <source>Writes and flushes the parameters to the standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe62811850204f6989910a722d883718ece800c" translate="yes" xml:space="preserve">
          <source>Writes data to the specified future stream as the file is read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92242dea02e29327d993eb1cc3297777dff63be" translate="yes" xml:space="preserve">
          <source>Writes into &lt;code&gt;result&lt;/code&gt; the rst ast &lt;code&gt;n&lt;/code&gt; using the &lt;code&gt;d&lt;/code&gt; configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f25f4df96580649fbf61c73bf96f72aec9e3b5f" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to string. Note: Comment statement will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6e3b9c400f1eef44b307552759341bc86ee5ce" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified configuration file. Note: Comment statement will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943a3e5523074ab2149addf7bbeb0fa3c3bf1c09" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd9e881510f9be093ebe517fe9b4aa83cc82a0a" translate="yes" xml:space="preserve">
          <source>Writes the current index buffer to the specified output file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd32587819be16f41963d9f477e3a15c30356f1" translate="yes" xml:space="preserve">
          <source>Writes the given RST node as JSON that is in the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbbda5ef7f0ace5ebf184908b2e7da636d8527f" translate="yes" xml:space="preserve">
          <source>Writes the list of registered foreign deps to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfd7a39f362d2a77758e5c07bcd311bfabd3290" translate="yes" xml:space="preserve">
          <source>Writes the specified value inside the specified future stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8255ac21cf77099d0f6ff9ac6e846fb5cdb0fda" translate="yes" xml:space="preserve">
          <source>Writes the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2914acbe1102d062a4f2393594889f72ba0c206e" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;em&gt;txt&lt;/em&gt; in a given &lt;em&gt;style&lt;/em&gt; to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273726bd38de7eff2c09ffae11f809aa1fb0834f" translate="yes" xml:space="preserve">
          <source>Written by Philip Hazel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b03e2f61abd9d04fffa15c8355e3436931a0ae" translate="yes" xml:space="preserve">
          <source>XDeclaredButNotUsed</source>
          <target state="translated">XDeclaredButNotUsed</target>
        </trans-unit>
        <trans-unit id="d647f348ffbbc7a4d48d8ae4bec579637ae0ee51" translate="yes" xml:space="preserve">
          <source>XML Processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d850dd17ecf96df39630839c6d073caf7cb5fb52" translate="yes" xml:space="preserve">
          <source>Yield every (position, value) of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755dd97240e42a3dc4431ff54cbcde0d38f93331" translate="yes" xml:space="preserve">
          <source>Yield every element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ca75af94090e37bbf9398ee1de83cc580bdc1c" translate="yes" xml:space="preserve">
          <source>Yield statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f3a56dbd00c322681bd3d8cb3a2e92bba08be1" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbe19c48460bbfdb0a7ecb4ffe08a0ee9cd8526" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26171d2547797d7b792e1c5b0afcc0cbe263ef92" translate="yes" xml:space="preserve">
          <source>Yields each key, value pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7e3fc8749812999838907214d1eb8450309265" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;keys&lt;/em&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2417d997628d8ba1aefeea2d89fe75654c22728" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;names&lt;/em&gt; of each field in a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93956d196d887cc0861e43d2a531388eaa74a029" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1a656995365fee941d9a0f7f934014284b0f0a" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe8766634b03a0c571dde2851555af85b82423a" translate="yes" xml:space="preserve">
          <source>Yields the child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ec21b096062ab66fc1c72aaf6915c5df074b73" translate="yes" xml:space="preserve">
          <source>Yields the indices and child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9787a201226a9a90fb295daca65242e9806ef392" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;em&gt;key&lt;/em&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fe99d112e72e96635690ca13742e71ee3b251" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;em&gt;name&lt;/em&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0096f64ab9c850e6d8688547c2fb784796e80a1" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;RstGenerator&lt;/code&gt; structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX documents&lt;/a&gt; too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d188ca0a71a4ddf286451e750b7f8f446c7afd4" translate="yes" xml:space="preserve">
          <source>You can also make post requests with custom headers. This example sets &lt;code&gt;Content-Type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt; and uses a json object for the body</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7714759afec1609cb47128c6129eb72d509b791d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; together with &lt;em&gt;long string literals&lt;/em&gt; to create block comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97084a1faa8455f2406ffb033740ec1bfec72684" translate="yes" xml:space="preserve">
          <source>You can also use the convenience procedures called &lt;code&gt;milliseconds&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;months&lt;/code&gt;, and &lt;code&gt;years&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3b8da731d961b104b75c9c69b89b7521fd2d57" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered GC run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the GC and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409fedb343fbf4112734b304e207a767c54d9c6f" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94d52a9f40f9d3456df4a8df7e7eb81a57a523b" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a15a89c8527958b5725cea61c34db20ebbeafb" translate="yes" xml:space="preserve">
          <source>You can find examples of client/server communication in the idetools tests found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d157a3f2f7ccab099eb8d42373b8eee643ec59fc" translate="yes" xml:space="preserve">
          <source>You can force the evaluation of a certain expression at compile-time by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbd4752c2519417bd7580131c8b434b52acfe30" translate="yes" xml:space="preserve">
          <source>You can generate HTML output through the convenience proc &lt;code&gt;rstToHtml&lt;/code&gt;, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db428874c2fa95de5693e83c0a003d99482e25e7" translate="yes" xml:space="preserve">
          <source>You can import the &lt;a href=&quot;rstgen&quot;&gt;packages/docutils/rstgen module&lt;/a&gt; in your programs if you want to reuse the compiler's documentation generation procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26dd058177b18bbce0e1976ca233b4444e8bfaa9" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee456de749cd07f777df2dbfca526efcaac8de" translate="yes" xml:space="preserve">
          <source>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e0b3e912356fd0eb7d1dfb77943e7ce6efb8f9" translate="yes" xml:space="preserve">
          <source>You can obtain the type of a given expression by constructing a &lt;code&gt;type&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef0a20f2b09c4d9edfa4d02db9759a10ded5a2e" translate="yes" xml:space="preserve">
          <source>You can of course use GDB or Visual Studio to debug the compiler (via &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt;). However, there are also lots of procs that aid in debugging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1dcc44050776a85f416ff13b391cd7420a7ea6" translate="yes" xml:space="preserve">
          <source>You can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3235ae291f967014004169d6dd7919accac84950" translate="yes" xml:space="preserve">
          <source>You can then begin accepting connections using the &lt;code&gt;accept&lt;/code&gt; procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229f698a5d2a1c44c1f9b047aaac16d395d3ac54" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; to &lt;em&gt;always&lt;/em&gt; add the &lt;code&gt;.discardable&lt;/code&gt; pragma since every name starts with the empty string prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e6e68fd4224a4e7b5d122bef202f975c7268d" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;fmt&lt;/code&gt; or the unary &lt;code&gt;&amp;amp;&lt;/code&gt; operator for formatting. The difference between them is subtle but important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db4f8bc927328b58f5dd31eba7cffedc758cc6" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddf568174dd61d7a80305dc0a3e7df19330c174" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c2d59459a913b746b98925a2a3fc29f24dc533" translate="yes" xml:space="preserve">
          <source>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34048e340fae2cd8a9b340afd693e3e0e20b294" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91b944ee43ceb5d18d013c159338cbb935b2855" translate="yes" xml:space="preserve">
          <source>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786f4a9c940aa7c5a0838e96623ddf57a6935a80" translate="yes" xml:space="preserve">
          <source>You can verify this yourself adding the line &lt;code&gt;echo source&lt;/code&gt; somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; to abort (which we could still call) this version calls the &lt;a href=&quot;macros#error&quot;&gt;error proc&lt;/a&gt; (line 14). The &lt;code&gt;error&lt;/code&gt; proc has the same behavior as &lt;code&gt;quit&lt;/code&gt; but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but &lt;strong&gt;not&lt;/strong&gt; the line of &lt;code&gt;data.cfg&lt;/code&gt; we are processing, that's something the macro itself would need to control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1927317fdc7e6a2effb5166b6eaa7c316bb014" translate="yes" xml:space="preserve">
          <source>You may add a constraint to the resulting type to trigger a compile-time error if the expression doesn't have the expected type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f30ee997aa1c1a9a827cafb053cce15b31f0463" translate="yes" xml:space="preserve">
          <source>You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd8d98d03acf607976a61f844d04f595a458ee9" translate="yes" xml:space="preserve">
          <source>You must create a new SSL context with the &lt;code&gt;newContext&lt;/code&gt; function defined in the &lt;code&gt;net&lt;/code&gt; module. You may then call &lt;code&gt;wrapSocket&lt;/code&gt; on your socket using the newly created SSL context to get an SSL socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36e9e49af8f68c7f3865ace300bab1eeae94fdd" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;em&gt;config&lt;/em&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;em&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/em&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aec2725098b8ffc1761bd9c7f7b9f1682bf6e2" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d047869868e7ac2dd137df50888c63412be12d0" translate="yes" xml:space="preserve">
          <source>You should send this before sending your HTML page, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d103567ee18cb5218c37709ddcec0d6177298f4" translate="yes" xml:space="preserve">
          <source>You will also have to compile with &lt;code&gt;ssl&lt;/code&gt; defined like so: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058062ffe3d7415398c63db4c4c474b3de0c89a9" translate="yes" xml:space="preserve">
          <source>Zero or One</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ff50143f9dda79f19f7750e8d1e6ebfb6a9117" translate="yes" xml:space="preserve">
          <source>Zero or more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0e6558a1175af4a938d82662dd24b2fa417681" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a721c45ae571dec5e2aa89e2c4b85966c95f70" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;em&gt;E&lt;/em&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af78455018bdfce1224f9a413429c8d1cf682b3" translate="yes" xml:space="preserve">
          <source>Zero value for durations. Useful for comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6060a4786b6be76ff108ebceec44d2daa4c15f06" translate="yes" xml:space="preserve">
          <source>Zero-indexed counting have two shortcuts &lt;code&gt;..&amp;lt;&lt;/code&gt; and &lt;code&gt;..^&lt;/code&gt; to simplify counting to one less than the higher index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be19fd422dffae7a0636938f97b2aa24b5cb13a9" translate="yes" xml:space="preserve">
          <source>[default(T), ...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6181759dbfbc1d13cea8897bba860e1cd1f1b7f" translate="yes" xml:space="preserve">
          <source>a channel for thread communication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb1c4b07f128179a3a629f3d8297730fe20d8c2" translate="yes" xml:space="preserve">
          <source>a color stored as RGB</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b439a1db8b1636f87a882db4e959779e8dfe6b" translate="yes" xml:space="preserve">
          <source>a compiled regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446a499c83ee189e881728b9614bb1c610b42820" translate="yes" xml:space="preserve">
          <source>a complex number, consisting of a real and an imaginary part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0dd8cbb911234aafd65e42ebe2e16d8dd9a13" translate="yes" xml:space="preserve">
          <source>a convenience proc that runs the &lt;em&gt;command&lt;/em&gt;, grabs all its output and exit code and returns both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1d312821fd56659d05a796c0721e1a9ac1ecd1" translate="yes" xml:space="preserve">
          <source>a convenience procedure for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697ab90ee8ea779b4e9d7e4d582cc0de7bbcb857" translate="yes" xml:space="preserve">
          <source>a data flow variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236302a21803b39674181eb1c1e1dad827d987da" translate="yes" xml:space="preserve">
          <source>a distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c60b77672236b3310392791c9159e7da691559" translate="yes" xml:space="preserve">
          <source>a doubly linked list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f8d2cb7eddeae18a8926cceebe9ab14e904d46" translate="yes" xml:space="preserve">
          <source>a doubly linked ring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9667a5641fafbc88c7babe208bd484588610acb6" translate="yes" xml:space="preserve">
          <source>a handle that can be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c673f94589cd025a94f4df85ea7cbc620e46a6b6" translate="yes" xml:space="preserve">
          <source>a handle that can be used to get a row's column text on demand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e35a0ed419e04673fabc57db7de755c9a5158d9" translate="yes" xml:space="preserve">
          <source>a handle to a dynamically loaded library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727eb5fb1890186a7705b301c37bcb5a3a011c04" translate="yes" xml:space="preserve">
          <source>a hash value; hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7c3a20e1c58ee4786768f999120ebe9f74132e" translate="yes" xml:space="preserve">
          <source>a identifier for the prepared queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15266dcad2adbaa4f2ad63108ef729cf76beda5" translate="yes" xml:space="preserve">
          <source>a node a doubly linked list consists of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba782577875c08c01d890dce7e8dd4aecffd0bd" translate="yes" xml:space="preserve">
          <source>a node a singly linked list consists of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5092df10e1c3e85e7d83e22f3d8ff19de9aee98" translate="yes" xml:space="preserve">
          <source>a parallel section can be used to execute a block in parallel. &lt;code&gt;body&lt;/code&gt; has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b464620548b26647c2039d50b3534a202b2e5405" translate="yes" xml:space="preserve">
          <source>a rational number, consisting of a numerator and denominator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69540ea7fe9bd9fdc5e24939d260de6bfcf3083e" translate="yes" xml:space="preserve">
          <source>a row in a CSV file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ec37625145ddf6373e511cf4b862af7fe73b7a" translate="yes" xml:space="preserve">
          <source>a row of a dataset. NULL database values will be converted to nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9fa41fb39e8c2391daf5b73b38611f05be5128" translate="yes" xml:space="preserve">
          <source>a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302bd8c00ad8f3e86bc63558821e98698620a746" translate="yes" xml:space="preserve">
          <source>a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440e2c2edfe2d93548694539384ebaec70e26a08" translate="yes" xml:space="preserve">
          <source>a shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ea92069e80f9a3e02b527138ba54f9fbd0ee56" translate="yes" xml:space="preserve">
          <source>a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d3caa14558753d210d77ea2d36fd6a1513d28" translate="yes" xml:space="preserve">
          <source>a single backslash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837f51c3591f8b2d4452f90b5ddbc53e912a5c22" translate="yes" xml:space="preserve">
          <source>a singly linked list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216912de21be007513f346fea51719c0bc9710bb" translate="yes" xml:space="preserve">
          <source>a singly linked ring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca33daf462dcc183c16697e01011fdb26d89e19" translate="yes" xml:space="preserve">
          <source>a standard ASCII identifier: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d78f86643008d4db0ec1bb8602ad193b2839d13" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;File&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c6c55b76ac43aa1bd1841c6cca1606179fd844" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;MemFile&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86e6a991d0bca4656b36ada97342374f6e9a343" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bd8c81bc8b1cc0db1629419cf49867fb9cbc47" translate="yes" xml:space="preserve">
          <source>a string that describes the application type. Possible values: &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78097f72ab7bfacc92af44cb293dd8fef3e05b08" translate="yes" xml:space="preserve">
          <source>a string that describes the host CPU. Possible values: &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot;, &quot;mips64el&quot;, &quot;riscv64&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2904b6a5abddd9d8deb65901f6588cd84e307512" translate="yes" xml:space="preserve">
          <source>a string that describes the host operating system. Possible values: &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c43be61e01495675e75b60bd73d6e649f9ba570" translate="yes" xml:space="preserve">
          <source>a superset of datatypes that might be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd596fb483edcb41239e2551baec03a2edb03189" translate="yes" xml:space="preserve">
          <source>abstract logger; the base type of all loggers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4731f8a1ebe230c0bedc849397e5106693c2e5fe" translate="yes" xml:space="preserve">
          <source>accepts a single string argument and treats it as nim code that should be inserted verbatim in the program Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f104b049910f12d603b0f4b7c5560b09c7ab62fa" translate="yes" xml:space="preserve">
          <source>accepts node of kind nnkSym and returns its owner's symbol. result is also mnde of kind nnkSym if owner exists otherwise nnkNilLit is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb500ee45bc07d7f3123c3ca655180cc9023baf" translate="yes" xml:space="preserve">
          <source>accessor for an any &lt;em&gt;x&lt;/em&gt; that represents an array or a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3641386853a01ac8136dde5cb98616d8122c4f64" translate="yes" xml:space="preserve">
          <source>activate 'see source' for doc and doc2 commands (see doc.item.seesrc in config/nimdoc.cfg)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f4817d8ea2f060465d17fd1e0c9621ca128ab6" translate="yes" xml:space="preserve">
          <source>acyclic pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="be654d44da0556a5cfc0c3960f4b0e5d8c7691a8" translate="yes" xml:space="preserve">
          <source>add RunningRegress &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f3963a1c27dc57f14b32ec31702841246839ac" translate="yes" xml:space="preserve">
          <source>add a path for Nimble support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52b43b0c3ff4c80cba13b5fbe245ef430bb9267" translate="yes" xml:space="preserve">
          <source>add a second RunningStats &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15cd5c97ee3e7837ac1a6c57b0ec58e743aa0cf" translate="yes" xml:space="preserve">
          <source>add an automatically imported module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d006e72468553c812ce58018ffee86b98a1de727" translate="yes" xml:space="preserve">
          <source>add an automatically included module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8ccf0416a8d5978779e3ecf6029e129bf6622d" translate="yes" xml:space="preserve">
          <source>add path to search paths</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ff37c92cbfa69ed6d8a1ee9a213181f165d944" translate="yes" xml:space="preserve">
          <source>additional packages for the distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6743cab27b3049919b02e0ba0d3ffe4227363a60" translate="yes" xml:space="preserve">
          <source>additional signed integer types of XX bits use this naming scheme (example: int16 is a 16 bit wide integer). The current implementation supports &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Literals of these types have the suffix 'iXX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635d7e51a3815812414d121a44ae70a4032af75d" translate="yes" xml:space="preserve">
          <source>additional unsigned integer types of XX bits use this naming scheme (example: uint16 is a 16 bit wide unsigned integer). The current implementation supports &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. Literals of these types have the suffix 'uXX. Unsigned operations all wrap around; they cannot lead to over- or underflow errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c0eb29005c66f68f255094fa7f2452b189e538" translate="yes" xml:space="preserve">
          <source>adds &lt;em&gt;b&lt;/em&gt; to the rope &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82969e97be5f2882f61b8d06bb03c94458061e4" translate="yes" xml:space="preserve">
          <source>adds the child &lt;em&gt;son&lt;/em&gt; to &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb5b52f9e214a298005774ba529cab866982f54" translate="yes" xml:space="preserve">
          <source>adds the textual representation of &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;result&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93091c2d09b2ad7ca8e9bacf9c97757310394cf5" translate="yes" xml:space="preserve">
          <source>adds two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b840f37b0e8955863eaaf0c39b4e8bc2494a84" translate="yes" xml:space="preserve">
          <source>after lookup pass: &lt;code&gt;nnkSym(strVal = &quot;myIdentifier&quot;, ...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e108a968cadd854d13bc3b3948ea2ed2074a6ca1" translate="yes" xml:space="preserve">
          <source>alarm, that is, the BEL character (hex 07)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a53b0819e7b65cebdd2f94ad43011ac678d3fc3" translate="yes" xml:space="preserve">
          <source>algorithm</source>
          <target state="translated">algorithm</target>
        </trans-unit>
        <trans-unit id="6bcdc475a77368f9553c2f9b16d757fb113a0b27" translate="yes" xml:space="preserve">
          <source>algorithm.*</source>
          <target state="translated">algorithm.*</target>
        </trans-unit>
        <trans-unit id="eed67bfcd90ff2bde24b027a916e8dc6179bc669" translate="yes" xml:space="preserve">
          <source>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d0b03f10de095d5459cdb68303b689612deebd" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c337d5a49dab1e36919aec1df636ec82dc97cc9d" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132044e5591404c5419f7b9d0b83a9c482aa7d34" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;contains&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d18988fa4de8a2b53ca8aa8f2745d9d349db6f" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;len() &amp;lt;#len&amp;gt;&lt;/em&gt; _.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c4fff4212b87f102c0a1b2e9144a46079b9947" translate="yes" xml:space="preserve">
          <source>alias of &lt;em&gt;hasKey&lt;/em&gt; for use with the &lt;em&gt;in&lt;/em&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcb694c7648187b986a6c25cb54ec3810cea88e" translate="yes" xml:space="preserve">
          <source>all of the expressions within the body can be compiled for the tested type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d63dd6433be0a0577b6741e68292848325c9c42" translate="yes" xml:space="preserve">
          <source>all statically evaluable boolean expressions in the body must be true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec845402601c65b31a01099140d022e5011c2c8" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createSharedU&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e189b8a859afa5cb84762353f1f6ad86c61ac06e" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51a8d093a0a153f627e0b13d8e7a71628d6e3e9" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createU&lt;/code&gt;. The allocated memory belongs to its allocating thread! Use &lt;em&gt;createShared&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7137e112b520cb32d8116151366b12c17c968247" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use &lt;em&gt;createSharedU&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9815fc8c2a8f4e1b35d4236d3fae99d3efd09869" translate="yes" xml:space="preserve">
          <source>allow 'nil' for strings/seqs for backwards compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c910f64af961b17f44fd191ab90b296114ff3dc" translate="yes" xml:space="preserve">
          <source>allowed values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f4fb40fbecf39d7d66ff344324ffd2846591d9" translate="yes" xml:space="preserve">
          <source>allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa389cc2795b6479735978661974371833e7c52" translate="yes" xml:space="preserve">
          <source>also used for &lt;em&gt;number of elements&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c561cc052fbc5ffee282dada5fc957da9fd5710" translate="yes" xml:space="preserve">
          <source>always spawns a new task on the worker thread with &lt;code&gt;id&lt;/code&gt;, so that the 'call' is &lt;strong&gt;always&lt;/strong&gt; executed on the thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e037d1639b289c4e26bbc0c30ba6c431ce37c71" translate="yes" xml:space="preserve">
          <source>always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151cee3c709c4d5822ef05a1ddc9a86502399266" translate="yes" xml:space="preserve">
          <source>an OID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b05bc5523a49f0f729d013bc15436c3ee98c1f" translate="yes" xml:space="preserve">
          <source>an RST node</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8967ed81f37b78d187297570cfc0e002da7729e1" translate="yes" xml:space="preserve">
          <source>an RST node's description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f5a9f32717a289921a20d9fc40fd3c347dad8b" translate="yes" xml:space="preserve">
          <source>an SQL abstract syntax tree node</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12310d9e38855a443de673725c022b73aa6accc6" translate="yes" xml:space="preserve">
          <source>an SQL query string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58be42ab5ccf2b1d725354c664c1c9d1a049d853" translate="yes" xml:space="preserve">
          <source>an XML tree consists of &lt;code&gt;XmlNode&lt;/code&gt;'s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5805b81014eb065b07422ecce776bf0b349369e" translate="yes" xml:space="preserve">
          <source>an accumulator for regression calculations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87688aab1c6a062b31f453c9e7a123a6caf3f9" translate="yes" xml:space="preserve">
          <source>an accumulator for statistical data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e3ed0ced08ee631b0c37319f38559b39c3d487" translate="yes" xml:space="preserve">
          <source>an alias for 'send'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17954bd5b900ea1471af9e6fe5da9f60619dfdcd" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;HSlice[T, T]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a019f449e8c64bbc587d53abf7ab099d0b97f6df" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float32&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2bb9d99dad820df32fdfaf8060a4fd7276110f" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float64&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359d828cee8b2007c3b07024f2b7d2dc9826bae9" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int32&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d65af0e89de7e9f7a3b4e8b4b9ff1129722fe22" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int64&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7403e6d178a09880f3e0b23ff146897e53d7b447" translate="yes" xml:space="preserve">
          <source>an alias for &lt;em&gt;renderSQL&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa0108528af89e539fdd667d14f686cfe81e4f7" translate="yes" xml:space="preserve">
          <source>an alias for a string to string mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fe8bbb61c09319ee708a5efe7f650df5413428" translate="yes" xml:space="preserve">
          <source>an efficient set of 'int' implemented as a sparse bit set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1e58ab7b0394cdaa4e08d47a7393a2573f3745" translate="yes" xml:space="preserve">
          <source>an implementation may define additional floating point types of XX bits using this naming scheme (example: float64 is a 64 bit wide float). The current implementation supports &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;. Literals of these types have the suffix 'fXX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb2e0ea344dca8fcab57fcf80481e8456bdaa0" translate="yes" xml:space="preserve">
          <source>and this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773bac1f038c7261c06dd562d3e88c52d6186053" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b4f6becbf49b5f440097b76eb71086cbdb2a8c" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character: &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb1ab3493a026534f33f9de86e501fbba10bf1d" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb3dd67a147ef444359e89f1fc469598768826b" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character: &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2af7fa85d682cfca6869619ab12b089bbedc11f" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ptr&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a9ba0f67e27b921ff5c5a3f8c8c8532b81e663" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ref&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f1406c1ae257c6a54cb24a67577fb91c8f2c42" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;var&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fb85b69ad14c45a89c623c70f23fe60fc970f3" translate="yes" xml:space="preserve">
          <source>any Unicode letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b58475581e603ea596720d3da0600db8eac7452" translate="yes" xml:space="preserve">
          <source>any Unicode lowercase letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a7803e43dc40a6d18691e4eb445841b8f4c29b" translate="yes" xml:space="preserve">
          <source>any Unicode title letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e096fd7f4d038d278b9e42fe47340a4ac798fe8" translate="yes" xml:space="preserve">
          <source>any Unicode uppercase letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c23e11023caa64175fc2b4a61c25bfa1946f6c" translate="yes" xml:space="preserve">
          <source>any Unicode whitespace character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dab8eeada09e9b30b6ff5265a5dbaa8bead2a0b" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d38d834aca2863b3c8638b5d1049f11e10d0fe" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit: &lt;code&gt;[^0-9]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05628852de66b9fc9ab7ccc2a7684852507b683f" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeda72fde51bc293b14210dc49ac340fc60f0430" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character: &lt;code&gt;[^ \9-\13]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6634b62c48237338c00b5331263af4c43b87aa5" translate="yes" xml:space="preserve">
          <source>any decimal digit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67f2ee53694f9eaecce9d4b927adc516269ad42" translate="yes" xml:space="preserve">
          <source>any decimal digit: &lt;code&gt;[0-9]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1baab2f1eb74d608d7489859dab98499b03128ba" translate="yes" xml:space="preserve">
          <source>any distinct type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfd2075dc39382d468083735e1e4b96a0c2fe87" translate="yes" xml:space="preserve">
          <source>any enumeration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632b027e713f7c77c2851530c3e2eb699d27fabb" translate="yes" xml:space="preserve">
          <source>any float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0516ce3580fe749675be3f049693cbea215fb083" translate="yes" xml:space="preserve">
          <source>any integer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2a2e239e83a015601c8e253eccb6d928207ec2" translate="yes" xml:space="preserve">
          <source>any newline combination: &lt;code&gt;\10 / \13\10 / \13&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4743987c929c0cf7879ba69db4234c28b1936fe3" translate="yes" xml:space="preserve">
          <source>any object type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51da33275128bfada93b7fe172db417cdf661eec" translate="yes" xml:space="preserve">
          <source>any proc type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ef1ac0f2fbb95f7d03f6c0575d2f6dd7cd44f5" translate="yes" xml:space="preserve">
          <source>any seq type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca9d57461d96f1e214aceba70e2030f0db409c0" translate="yes" xml:space="preserve">
          <source>any set type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389a6d11b9875f6eb40c37282ad62cbe5608844a" translate="yes" xml:space="preserve">
          <source>any tuple type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28c54bd6aac059f8e4c1e9241bd9772b3d2a3a4" translate="yes" xml:space="preserve">
          <source>any type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d581aa43044fba53f841ae21b312c1199cc2b2" translate="yes" xml:space="preserve">
          <source>any whitespace character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf727596d66c6d08060fb873659c9e83d971bd3" translate="yes" xml:space="preserve">
          <source>any whitespace character: &lt;code&gt;[ \9-\13]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="cf3ddbcb7cec2d2b9107f401606a80be88e173b3" translate="yes" xml:space="preserve">
          <source>appends a node &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394e90fc9086476ea2cc168904377cfdcaa95a5d" translate="yes" xml:space="preserve">
          <source>appends a value to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2005cc206ccbfdedf2be43a200cb050c538bdb5" translate="yes" xml:space="preserve">
          <source>application</source>
          <target state="translated">application</target>
        </trans-unit>
        <trans-unit id="06f720f81922363e28ffa5b9ea6b297a7c4ab084" translate="yes" xml:space="preserve">
          <source>applies &lt;code&gt;op&lt;/code&gt; to each of the &lt;strong&gt;atomic&lt;/strong&gt; literals like &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;&quot;abc&quot;&lt;/code&gt; in the specified &lt;code&gt;constructor&lt;/code&gt; AST. This can be used to map every array element to some target type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="601e3eae2caedfbe9867984df72affd5041c6f4a" translate="yes" xml:space="preserve">
          <source>argument - everything else</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e5f3a667a852442823e459834bf798ce874870" translate="yes" xml:space="preserve">
          <source>arguments are passed to the program being run (if --run option is selected)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4390dce9df5136301038fcbfda456cfcefc40c26" translate="yes" xml:space="preserve">
          <source>array[0..., T]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9cf9882aa44ffb9a28e49e4ea13eac493f1cf0" translate="yes" xml:space="preserve">
          <source>asmNoStackFrame pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a3803e63cafb4f45ce4da3b304606b0fb38156" translate="yes" xml:space="preserve">
          <source>assert end of string (or line, in multiline mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab20e2dbc2d81949482cd67a19fb67418198995" translate="yes" xml:space="preserve">
          <source>assert start of string (or line, in multiline mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60544f107576aa75a3a16e2a4d455e8086f18203" translate="yes" xml:space="preserve">
          <source>assertion</source>
          <target state="translated">assertion</target>
        </trans-unit>
        <trans-unit id="120d25e6303ae7ca2cb354c13abcd5b71dbbd209" translate="yes" xml:space="preserve">
          <source>assertions</source>
          <target state="translated">assertions</target>
        </trans-unit>
        <trans-unit id="c24c0248770ae98831f8a654310d4c2e07514c61" translate="yes" xml:space="preserve">
          <source>ast</source>
          <target state="translated">ast</target>
        </trans-unit>
        <trans-unit id="7df52e645ceca43324a23db842d9058d2f5b083c" translate="yes" xml:space="preserve">
          <source>astalgo</source>
          <target state="translated">astalgo</target>
        </trans-unit>
        <trans-unit id="d59f43e7438cb25036fc655f0b8670b2f9530645" translate="yes" xml:space="preserve">
          <source>asyncdispatch</source>
          <target state="translated">asyncdispatch</target>
        </trans-unit>
        <trans-unit id="f3ccc3ccdfaaada264ca2c52da2860d14a1e629f" translate="yes" xml:space="preserve">
          <source>asyncdispatch.==</source>
          <target state="translated">asyncdispatch.==</target>
        </trans-unit>
        <trans-unit id="a4ab9637ac3aba19be3efe076a9fd74a9d4bf5ae" translate="yes" xml:space="preserve">
          <source>asyncfile</source>
          <target state="translated">asyncfile</target>
        </trans-unit>
        <trans-unit id="f215ff0b50d562a4f699305c138254c53a7e4e76" translate="yes" xml:space="preserve">
          <source>asyncftpclient</source>
          <target state="translated">asyncftpclient</target>
        </trans-unit>
        <trans-unit id="912d9cb1030b5696868d7cd061a1f1913fd22e54" translate="yes" xml:space="preserve">
          <source>asyncftpclient.cd()</source>
          <target state="translated">asyncftpclient.cd()</target>
        </trans-unit>
        <trans-unit id="7f9858036c96a49dead41c657601f55292eeb21b" translate="yes" xml:space="preserve">
          <source>asyncfutures</source>
          <target state="translated">asyncfutures</target>
        </trans-unit>
        <trans-unit id="6fac5c1c38ee66b71705a8698bdb25cd0c55009b" translate="yes" xml:space="preserve">
          <source>asyncfutures.$</source>
          <target state="translated">asyncfutures.$</target>
        </trans-unit>
        <trans-unit id="3e25c511c4dd4dd67c7bb70f3470a114aca1109f" translate="yes" xml:space="preserve">
          <source>asyncfutures.and</source>
          <target state="translated">asyncfutures.and</target>
        </trans-unit>
        <trans-unit id="b3959400d1c4f914e1d0d15e24d018f0b4bcd01d" translate="yes" xml:space="preserve">
          <source>asyncfutures.or</source>
          <target state="translated">asyncfutures.or</target>
        </trans-unit>
        <trans-unit id="16b484f4702399914b9685ac4a149df758f56412" translate="yes" xml:space="preserve">
          <source>asynchttpserver</source>
          <target state="translated">asynchttpserver</target>
        </trans-unit>
        <trans-unit id="4f5a0f016913fc4a169af7be4ea530a3a7d60ba2" translate="yes" xml:space="preserve">
          <source>asyncio</source>
          <target state="translated">asyncio</target>
        </trans-unit>
        <trans-unit id="df0aa08a1e718db729ddd29b35fcf08213931136" translate="yes" xml:space="preserve">
          <source>asyncjs</source>
          <target state="translated">asyncjs</target>
        </trans-unit>
        <trans-unit id="d7be09696c087802d819cf4a88b019da986579ce" translate="yes" xml:space="preserve">
          <source>asyncnet</source>
          <target state="translated">asyncnet</target>
        </trans-unit>
        <trans-unit id="f336018a344567452110d592d1db5dbd92b0c34e" translate="yes" xml:space="preserve">
          <source>asyncstreams</source>
          <target state="translated">asyncstreams</target>
        </trans-unit>
        <trans-unit id="d22d106d3ca7becc36b58971d80a432e61af2893" translate="yes" xml:space="preserve">
          <source>atomic decrement of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb8bb6a0a59b21438db5000a63cc7abf3e9ce50" translate="yes" xml:space="preserve">
          <source>atomic increment of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e16c009563ab7ba71f544cdf093ed49bacede5" translate="yes" xml:space="preserve">
          <source>awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived. A flowVar only supports one call to 'blockUntilAny' at the same time. That means if you blockUntilAny([a,b]) and blockUntilAny([b,c]) the second call will only blockUntil 'c'. If there is no flowVar left to be able to wait on, -1 is returned. &lt;strong&gt;Note&lt;/strong&gt;: This results in non-deterministic behaviour and should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7090537b7970d7792c2dede512e03be486ed1bbd" translate="yes" xml:space="preserve">
          <source>base effect class; each effect should inherit from &lt;em&gt;RootEffect&lt;/em&gt; unless you know what you doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee727532b654c2d8318a0ca08971ba3017603d9" translate="yes" xml:space="preserve">
          <source>base name of $app</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="933558877f8bde9f7da0e625bdd25791b3547276" translate="yes" xml:space="preserve">
          <source>be case insensitive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb99f9bee10af60b73c09287e19cf7ad76dc789" translate="yes" xml:space="preserve">
          <source>be style insensitive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801fe5e4f0fe1c70c018f3c5364c1f0b8fcf0a8a" translate="yes" xml:space="preserve">
          <source>be verbose: list every processed file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3077737626efcafd4a2545cfe7e2173b4b04bc26" translate="yes" xml:space="preserve">
          <source>binary &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[a, b]&lt;/code&gt;, both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94314a375a1c191f6ec01cc5b56e090a1db926cd" translate="yes" xml:space="preserve">
          <source>binary search for &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt;. Returns -1 if not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f0ceb4bf6383ebb1575eaa16ca08001738d7ed" translate="yes" xml:space="preserve">
          <source>binds an address/port number to a socket. Use address string in dotted decimal form like &quot;a.b.c.d&quot; or leave &quot;&quot; for any address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261e13cf94256fe14fb6c0700e4c3d15134a8a30" translate="yes" xml:space="preserve">
          <source>bitops</source>
          <target state="translated">bitops</target>
        </trans-unit>
        <trans-unit id="7ad3fef702b9b384e080a1dce5ae02d05c8c779a" translate="yes" xml:space="preserve">
          <source>bitwise OR of all supported exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bba832afd7bfee6a1ca7c4f0b72b17cde4452a" translate="yes" xml:space="preserve">
          <source>blocks until the &lt;code&gt;fv&lt;/code&gt; is available and then passes its value to &lt;code&gt;action&lt;/code&gt;. Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied and so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78af78bb4f4770be9ef1a285ca4b35516a2d260f" translate="yes" xml:space="preserve">
          <source>blocks until the value is available and then returns this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="3daef215d98d13fb11fb7258f01189d95d388907" translate="yes" xml:space="preserve">
          <source>boot command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0e7d8f03334fea42f0fb9d4b102d890dd2bfeb" translate="yes" xml:space="preserve">
          <source>boundChecks</source>
          <target state="translated">boundChecks</target>
        </trans-unit>
        <trans-unit id="e7ab5809a76e914befcdd4f875ea24d6858e2e97" translate="yes" xml:space="preserve">
          <source>browsers</source>
          <target state="translated">browsers</target>
        </trans-unit>
        <trans-unit id="ab4c6d55c9b8536daa06dcfdad3b709bba8cfcf9" translate="yes" xml:space="preserve">
          <source>buffer handling of the lexical analyser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df0e93dd5f8bcbff09fd72f31c5b11e2f8df128" translate="yes" xml:space="preserve">
          <source>build an index for the whole documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d8fc3d3a068b5b94c44c9da7a309885eca0117" translate="yes" xml:space="preserve">
          <source>buildIndex</source>
          <target state="translated">buildIndex</target>
        </trans-unit>
        <trans-unit id="7899851775abcb391fbb3611e14c5806b38f217d" translate="yes" xml:space="preserve">
          <source>built-in 8 bit character type (unsigned)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8158c3d07cf2a1168a5614f07c2fd4e364863c" translate="yes" xml:space="preserve">
          <source>built-in boolean type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd6c8ca21c7bae842be59eef266709361858cd3" translate="yes" xml:space="preserve">
          <source>built-in cstring (&lt;em&gt;compatible string&lt;/em&gt;) type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a744f5b9df007ccb6c80b67e250a9db549faa597" translate="yes" xml:space="preserve">
          <source>built-in generic traced pointer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e977564d9044849b00d8e6d8f43daedcb02c9365" translate="yes" xml:space="preserve">
          <source>built-in generic untraced pointer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7492624ece266053123dd38ceccde7c465df2727" translate="yes" xml:space="preserve">
          <source>built-in pointer type, use the &lt;code&gt;addr&lt;/code&gt; operator to get a pointer to a variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffd7b6d3b34b66311cba6e4f638cbd97cdde3e8" translate="yes" xml:space="preserve">
          <source>built-in string type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba10a874b60e75db318a913365334b1eb96194b" translate="yes" xml:space="preserve">
          <source>builtin &lt;span id=&quot;roof_1&quot;&gt;roof&lt;/span&gt; operator that can be used for convenient array access. &lt;code&gt;a[^x]&lt;/code&gt; is a shortcut for &lt;code&gt;a[a.len-x]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3426efad09c70f3da2870ce5a1d60001e80166ec" translate="yes" xml:space="preserve">
          <source>c2nim</source>
          <target state="translated">c2nim</target>
        </trans-unit>
        <trans-unit id="56aa317711bf6e70a709f0b77b32eb3731f7f2b7" translate="yes" xml:space="preserve">
          <source>c2nim &lt;em&gt;processes&lt;/em&gt;&lt;code&gt;#ifdef C2NIM&lt;/code&gt; and &lt;code&gt;#ifndef C2NIM&lt;/code&gt; directives, but other &lt;code&gt;#if[def]&lt;/code&gt; directives are &lt;em&gt;translated&lt;/em&gt; into Nim's &lt;code&gt;when&lt;/code&gt; construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1aa66b99c882e1d48f845dbf6ed8a475c6027f" translate="yes" xml:space="preserve">
          <source>c2nim User's manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db503e64e7c067961c76a4f4ace96ea232a5bac" translate="yes" xml:space="preserve">
          <source>c2nim can be configured to skip certain &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; sections. If a directive &lt;code&gt;#assumedef SYMBOL``is found, c2nim will assume that the symbol ``SYMBOL&lt;/code&gt; is defined, and thus skip &lt;code&gt;#ifndef SYMBOL&lt;/code&gt; sections. The same happens if &lt;code&gt;SYMBOL&lt;/code&gt; is actually defined with a &lt;code&gt;#def&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0874a87826f5ff53f6c6bf9ffc5cfffc28c348" translate="yes" xml:space="preserve">
          <source>c2nim does not do any name mangling by default. However the &lt;code&gt;#prefix&lt;/code&gt; and &lt;code&gt;#suffix&lt;/code&gt; directives can be used to strip prefixes and suffixes from the identifiers in the C code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99da162adf79f0a46dd9c3d7234d5d0ec8a77afe" translate="yes" xml:space="preserve">
          <source>c2nim is a tool to translate Ansi C code to Nim. The output is human-readable Nim code that is meant to be tweaked by hand after the translation process. c2nim is no real compiler!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8088a888559eda6c07415159a9479d5d21a3cce5" translate="yes" xml:space="preserve">
          <source>c2nim is meant to translate fragments of C code and thus does not follow include files. c2nim cannot parse all of Ansi C and many constructs cannot be represented in Nim: for example &lt;span id=&quot;duff-s-device_1&quot;&gt;duff's device&lt;/span&gt; cannot be translated to Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b902834ab99b1e7d9ffa6d4609d2deeb057ee1ea" translate="yes" xml:space="preserve">
          <source>c2nim is preliminary meant to translate C header files. Because of this, the preprocessor is part of the parser. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09728599d3a33821bbaf9009c7a4ce84e73c3f8" translate="yes" xml:space="preserve">
          <source>c2nim's preprocessor supports special directives that affect how the output is generated. They should be put into a &lt;code&gt;#ifdef C2NIM&lt;/code&gt; section so that ordinary C compilers ignore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fbf5840ac1e9a5a1ceabb535b114715c54e34e" translate="yes" xml:space="preserve">
          <source>call this before starting to send your HTML data to &lt;em&gt;stdout&lt;/em&gt;. This implements this part of the CGI protocol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c6e4c322f4edd978f4612f2138812be9dde505" translate="yes" xml:space="preserve">
          <source>callconv</source>
          <target state="translated">callconv</target>
        </trans-unit>
        <trans-unit id="acd79879f7dc678d227bb41344bcf33ae5d53c48" translate="yes" xml:space="preserve">
          <source>can be used in a &lt;code&gt;try&lt;/code&gt; statement to setup a Lisp-like &lt;span id=&quot;condition-system_1&quot;&gt;condition system&lt;/span&gt;: This prevents the 'raise' statement to raise an exception but instead calls &lt;code&gt;action&lt;/code&gt;. If &lt;code&gt;action&lt;/code&gt; returns false, the exception has been handled and does not propagate further through the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a41c147d5237aaf5ea8d854a3e539b0855f6c2" translate="yes" xml:space="preserve">
          <source>can be used to determine an enum compile-time option. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bb814d0133b5fa4ff07d98a4f44ea9363df079" translate="yes" xml:space="preserve">
          <source>can be used to determine an on|off compile-time option. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f7f9e367f1d1a60f63849acd516acbb9199cfe" translate="yes" xml:space="preserve">
          <source>can be used to determine if a first class iterator has finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f22b9fbdbfca494dfb5fb443b40304f53942dc" translate="yes" xml:space="preserve">
          <source>can be used to ignore the whole code block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de80ae5dfae7c9854dc8a8f5fc199837369b492" translate="yes" xml:space="preserve">
          <source>can represent any nim value; NOTE: the wrapped value can be modified with its wrapper! This means that &lt;code&gt;Any&lt;/code&gt; keeps a non-traced pointer to its wrapped value and &lt;strong&gt;must not&lt;/strong&gt; live longer than its wrapped value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4be5ac63e1ea62640409f639b010b9fb479c5b" translate="yes" xml:space="preserve">
          <source>cap</source>
          <target state="translated">cap</target>
        </trans-unit>
        <trans-unit id="7cb1f56d3fbe09e809244fc8e13671cd876e3860" translate="yes" xml:space="preserve">
          <source>capacity</source>
          <target state="translated">capacity</target>
        </trans-unit>
        <trans-unit id="0f2ba5867e198e37d5e93f508ce79d5a1539c992" translate="yes" xml:space="preserve">
          <source>carriage return (hex 0D)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d49cc01704e5289e3b5794a9e5737d299ed928" translate="yes" xml:space="preserve">
          <source>cast[T](0); this may be an invalid value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066cf57dd5805ecd80ecc03cc26eb4b65a6ce47f" translate="yes" xml:space="preserve">
          <source>casting and other unsafe operations (&lt;code&gt;cast&lt;/code&gt; operator, &lt;code&gt;zeroMem&lt;/code&gt;, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed337e48425488d145f2d21babd664982100114" translate="yes" xml:space="preserve">
          <source>ccgexprs</source>
          <target state="translated">ccgexprs</target>
        </trans-unit>
        <trans-unit id="a44bb7c205ea7486d510ad850c061dbe6beb50e4" translate="yes" xml:space="preserve">
          <source>ccgstmts</source>
          <target state="translated">ccgstmts</target>
        </trans-unit>
        <trans-unit id="d918fc219f81cb04127cae18afe532825260c4f8" translate="yes" xml:space="preserve">
          <source>ccgtypes</source>
          <target state="translated">ccgtypes</target>
        </trans-unit>
        <trans-unit id="956d838ceaa5b452bd3b5c3f5e88f3843af0a219" translate="yes" xml:space="preserve">
          <source>ccgutils</source>
          <target state="translated">ccgutils</target>
        </trans-unit>
        <trans-unit id="4cbc897d2b77bba922b5e4a4b6494b5592aecb7b" translate="yes" xml:space="preserve">
          <source>cdecl|...</source>
          <target state="translated">cdecl|...</target>
        </trans-unit>
        <trans-unit id="6ed7efe0ffdee78d655e5ad60691472f0fb43b1c" translate="yes" xml:space="preserve">
          <source>cfg</source>
          <target state="translated">cfg</target>
        </trans-unit>
        <trans-unit id="8f3d60cfea547e1e20ad21fbc5cec120d1862ae2" translate="yes" xml:space="preserve">
          <source>cgen</source>
          <target state="translated">cgen</target>
        </trans-unit>
        <trans-unit id="27b4d0f8ee1e61a07904f1afd558aa878973f2d1" translate="yes" xml:space="preserve">
          <source>cgi</source>
          <target state="translated">cgi</target>
        </trans-unit>
        <trans-unit id="3536f72ac0ec1d785e357fed37a3e83c4bc651e2" translate="yes" xml:space="preserve">
          <source>channels</source>
          <target state="translated">channels</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="48236e5e509429b8fc8cd4a0ae77085dbfcc11bf" translate="yes" xml:space="preserve">
          <source>character type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b61a14ecbe64faf1953c4b4664c690480394da" translate="yes" xml:space="preserve">
          <source>character with hex code hh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013c472ea5d09f54bdfb3cde32d29f19d9443d0d" translate="yes" xml:space="preserve">
          <source>character with octal code ddd, or backreference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56d985300d4b52eb6e189be006f44f8d23c5ec9" translate="yes" xml:space="preserve">
          <source>check</source>
          <target state="translated">check</target>
        </trans-unit>
        <trans-unit id="7354fb826ffdc2403867a40dc983e0214220b565" translate="yes" xml:space="preserve">
          <source>checks</source>
          <target state="translated">checks</target>
        </trans-unit>
        <trans-unit id="e7a6d680b00692d32ffb421968f88c3acd4d4604" translate="yes" xml:space="preserve">
          <source>checks if more data can be read from &lt;em&gt;f&lt;/em&gt;. Returns true if all data has been read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177feaf5a875f904bbb216efc1577b958b584596" translate="yes" xml:space="preserve">
          <source>checks if two MD5Digest values are identical</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25b4520323ca9a79f3b710c170ab0e174922924" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has a number of children in the range &lt;code&gt;min..max&lt;/code&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098639b92545c1cc7038eba5da7047eed275e435" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has at least &lt;em&gt;min&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1353b044cd6fe2ded4431b6429efece035e17d" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has exactly &lt;em&gt;len&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639633341d390ded8cc566e2bd59883ca9297e04" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; is of kind &lt;em&gt;k&lt;/em&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a80360b0c2de946b73432febb8a8236386a56f" translate="yes" xml:space="preserve">
          <source>checks the project for syntax and semantic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d05dd5fd34693c4c55667580ded2aa7a8d5750" translate="yes" xml:space="preserve">
          <source>closes a channel &lt;em&gt;c&lt;/em&gt; and frees its associated resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb3e1e39f61035591b3e8c17ebf406a1739f2b7" translate="yes" xml:space="preserve">
          <source>closes a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e46f7c4a19cd40725edd182f3cd8f28ae9a059a" translate="yes" xml:space="preserve">
          <source>closes the base lexer. This closes &lt;em&gt;L&lt;/em&gt;'s associated stream too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d4c6e46a63f2ddf2ac5a0df3677c8d62a6a9d2" translate="yes" xml:space="preserve">
          <source>closes the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26adbf3fe5e8990bfd8ef4e529580b38a378a37e" translate="yes" xml:space="preserve">
          <source>closes the database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4120af6f6fd3307319d8128138e2d5a62e11a37b" translate="yes" xml:space="preserve">
          <source>closes the memory mapped file &lt;em&gt;f&lt;/em&gt;. All changes are written back to the file system, if &lt;em&gt;f&lt;/em&gt; was opened with write access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beffe895fa1092a7b803bd012ab87b6a4c03d2fd" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;c&lt;/em&gt; and its associated input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ebaec8140d9f72f4fe56335e3b4891498ef0ed" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;my&lt;/em&gt; and its associated input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a547a7b24d66447bd198c99f42ae102ec2439542" translate="yes" xml:space="preserve">
          <source>closes the stream &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abac36149cf8b0e18d680ad240a392fc875517bc" translate="yes" xml:space="preserve">
          <source>cmd</source>
          <target state="translated">cmd</target>
        </trans-unit>
        <trans-unit id="ba6c06e4be30524ef0009a48aabf7d270581932f" translate="yes" xml:space="preserve">
          <source>cmp</source>
          <target state="translated">cmp</target>
        </trans-unit>
        <trans-unit id="46f0655e0e5194dcf502c9a8497c27816f875ba0" translate="yes" xml:space="preserve">
          <source>col is preferred, inconsistent right now</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250140b29dbd97cfe8b655b2383464509f00c6c2" translate="yes" xml:space="preserve">
          <source>col, column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bd696759805b9098f9e13be67d2b248c7619d0" translate="yes" xml:space="preserve">
          <source>colors</source>
          <target state="translated">colors</target>
        </trans-unit>
        <trans-unit id="f6b885e57915547b46349da5eefcd8162aa0866f" translate="yes" xml:space="preserve">
          <source>colors.$</source>
          <target state="translated">colors.$</target>
        </trans-unit>
        <trans-unit id="5e51764cc9d08861492f3fb1123a9530f62d59ad" translate="yes" xml:space="preserve">
          <source>colors.+</source>
          <target state="translated">colors.+</target>
        </trans-unit>
        <trans-unit id="a1a8cffa299a42401148e5848a3c6c1a3b78afb3" translate="yes" xml:space="preserve">
          <source>colors.-</source>
          <target state="translated">colors.-</target>
        </trans-unit>
        <trans-unit id="fb154583fb54c6f87d3d451d313d8be3a9e052bc" translate="yes" xml:space="preserve">
          <source>colors.==</source>
          <target state="translated">colors.==</target>
        </trans-unit>
        <trans-unit id="aa60230ab00282b5a1f3f1993b2d1c503e7d15a5" translate="yes" xml:space="preserve">
          <source>column</source>
          <target state="translated">column</target>
        </trans-unit>
        <trans-unit id="0d87d4fd5d052a9ff08c67b6976edc291f8ed99a" translate="yes" xml:space="preserve">
          <source>combine two &lt;em&gt;RunningRegress&lt;/em&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a280c806fc0084662fe9dca88f44bbf8cf35fd56" translate="yes" xml:space="preserve">
          <source>combine two RunningStats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1925f793093581c47a5c6b2e414506b1cbae280d" translate="yes" xml:space="preserve">
          <source>command</source>
          <target state="translated">command</target>
        </trans-unit>
        <trans-unit id="f0461049bdae4983b14331cd824bc8faf678eada" translate="yes" xml:space="preserve">
          <source>commands that can be expressed as arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64ca250f492e3f0444ad32b68be5f60a163bede" translate="yes" xml:space="preserve">
          <source>compare</source>
          <target state="translated">compare</target>
        </trans-unit>
        <trans-unit id="7e5186f1a9bd2895ed93cde0ae3e0ec0ee7ebb52" translate="yes" xml:space="preserve">
          <source>compares the memory blocks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;size&lt;/code&gt; bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is &lt;em&gt;unsafe&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094f6cd976e09fdf5710aaa012b7929b4e78b25a" translate="yes" xml:space="preserve">
          <source>compares two Nim identifiers &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;==&lt;/code&gt; on &lt;code&gt;NimNode&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed73a329c036ce3614aca85e565d7d2fa0479e4" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc77019ddb9328367826ce155ee14c3fd23e382" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes' types. Return true if the types are the same, eg. true when comparing alias with original type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dada719b7810e8fcd804a5047d3800c1e54b166" translate="yes" xml:space="preserve">
          <source>compares two Nim symbols &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use ```==`(NimNode,NimNode)`` instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0270a597009f086e4304658a9db86f15ed03e1cd" translate="yes" xml:space="preserve">
          <source>compares two colors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa49b126d01b5a52b6416ad070faca0bf610e606" translate="yes" xml:space="preserve">
          <source>compilation option pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b955d23f05ae5bdd0badb05a3faaf15c898d9f" translate="yes" xml:space="preserve">
          <source>compile Nim and generated files but do not link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae36f560a64362393c0fb549afa5f8cdb5c4ba64" translate="yes" xml:space="preserve">
          <source>compile Nim files only; do not assemble or link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87b469fe2f2263e06847de7d293924f49076024" translate="yes" xml:space="preserve">
          <source>compile project to C++ code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be598bb766c710b889d68de039dbe949bb919e59" translate="yes" xml:space="preserve">
          <source>compile project to Javascript</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
