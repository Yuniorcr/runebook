<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="fd397bb5ad1c715271d852321a59468dac4bf8e0" translate="yes" xml:space="preserve">
          <source>The expression in the middle of the conditional operator (between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;) is parsed as if parenthesized: its precedence relative to &lt;code&gt;?:&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6d20b10db31ec88b3330e05c431cfea6a343c7" translate="yes" xml:space="preserve">
          <source>The expression is a constant expression, using only &lt;a href=&quot;../language/expressions#Constants_and_literals&quot;&gt;constants&lt;/a&gt; and identifiers, defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive. Any identifier, which is not literal, non defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive, evaluates to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7442fe2fa76c716226a44ca97bfdfc72037a2ef9" translate="yes" xml:space="preserve">
          <source>The expression is evaluated, and its value, after &lt;a href=&quot;conversion&quot;&gt;conversion as if by assignment&lt;/a&gt; to the type of the object, becomes the initial value of the object being initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324047fb5be1cb1232a316ce7dc9176cf6e8bad8" translate="yes" xml:space="preserve">
          <source>The expression lhs@=rhs is exactly the same as lhs&lt;code&gt;=&lt;/code&gt;lhs@&lt;code&gt;(&lt;/code&gt;rhs&lt;code&gt;)&lt;/code&gt;, except that lhs is evaluated only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f1c8c6b8733ef70e33511479b521ed6c4d5325" translate="yes" xml:space="preserve">
          <source>The expression may contain unary operators in form &lt;code&gt;defined&lt;/code&gt;identifier or &lt;code&gt;defined (&lt;/code&gt;identifier&lt;code&gt;)&lt;/code&gt; which return &lt;code&gt;1&lt;/code&gt; if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609021b59f47fefb50869c57b0c8813d6a53f9c6" translate="yes" xml:space="preserve">
          <source>The expression statement used as loop_statement establishes its own block scope, distinct from the scope of init_clause, unlike in C++:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7851beccfe29b18d64f37c7c39bb8359a74916" translate="yes" xml:space="preserve">
          <source>The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; are also suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8e4ef756882f2ecb926b4da6aad7ade4184995" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;count&lt;/code&gt; characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097166e604623ecf948a99098da8c5eddd704203" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;_Static_assert&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d42cf5c59ef03d9f21e976e9211c12f3707cda" translate="yes" xml:space="preserve">
          <source>The first hexadecimal digit is not &lt;code&gt;0&lt;/code&gt; if the argument is a normalized floating point value. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85aefccf8c9b3c2cd0c976b63196e9f569cb09b9" translate="yes" xml:space="preserve">
          <source>The first of the following that applies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1993f25515fdf5cf77175e2613e17a42e6c910c0" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c052bc3e94706d81a135a07eebf60e086497cbe" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b4a6419bf1a2819ede3d443e7b61a16bea4d0c" translate="yes" xml:space="preserve">
          <source>The first write to that object through an lvalue that has a type other than character type, at which time the type of that lvalue becomes this object's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea51a875efb11ad49d51139f65a4fbab7c5f7404" translate="yes" xml:space="preserve">
          <source>The floating point conversion functions convert infinity to &lt;code&gt;inf&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6247fea33eba71fac61a2b7cb4727c8281a459" translate="yes" xml:space="preserve">
          <source>The floating-point environment access and modification is only meaningful when &lt;a href=&quot;http://en.cppreference.com/w/cpp/preprocessor/impl.html&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the &lt;code&gt;#pragma&lt;/code&gt; explicitly, but most compilers allow meaningful access to the floating-point environment anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88a487f9a81a8c43facb1ab36c14a9792a2394f" translate="yes" xml:space="preserve">
          <source>The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30dcca8094f65496cbe7b9cb343a1867b9353f" translate="yes" xml:space="preserve">
          <source>The floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;x/y&lt;/code&gt; with its fractional part truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c564c91cc056f54f98f41b5fb84e49fa91ab18b" translate="yes" xml:space="preserve">
          <source>The following additional keywords are classified as extensions and conditionally-supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d1b47f4e938983cec3203a558177551122e45b" translate="yes" xml:space="preserve">
          <source>The following additional macro names may be predefined by an implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53267feddb0a903c8317f2f0976951442dab290e" translate="yes" xml:space="preserve">
          <source>The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2314e69040372621d3d5adf2b163840d6d43e0d3" translate="yes" xml:space="preserve">
          <source>The following aspects of the preprocessor can be controlled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5ea285c72c7d87a0b9f0ab566e300cf0d96f2e" translate="yes" xml:space="preserve">
          <source>The following chart contains all 128 ASCII decimal &lt;b&gt;(dec)&lt;/b&gt;, octal &lt;b&gt;(oct)&lt;/b&gt;, hexadecimal &lt;b&gt;(hex)&lt;/b&gt; and character &lt;b&gt;(ch)&lt;/b&gt; codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fdf8bcc92fd6fc1514e41f0d3d41b7c151059a" translate="yes" xml:space="preserve">
          <source>The following code redirects &lt;code&gt;stdout&lt;/code&gt; to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbdf2342c1f96b0209b527d82df9863ea30a28c" translate="yes" xml:space="preserve">
          <source>The following code sets and resets the stream orientation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b64fd2a82723acdd75ab79f9a274ca5cba5ba7" translate="yes" xml:space="preserve">
          <source>The following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0df48cae22b33977db026831f1533dc1eac83e" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0463db8b7489f2f607fc0fb87c855f442b9abbeb" translate="yes" xml:space="preserve">
          <source>The following example demonstrates alternative operator spellings from the &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; header as well as use of digraphs and trigraphs. The space character in the first command-line argument, argv[1], requires the quotation marks: &quot;, World!&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287a73bdcb331ffbabd28ac365a0f69ce0862305" translate="yes" xml:space="preserve">
          <source>The following expressions are lvalues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829cc0f70c42a8b870ad4b5e87e195960641456e" translate="yes" xml:space="preserve">
          <source>The following expressions are non-lvalue object expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfaf8e14e19bf31aee96ca79b4b825e2d169ca6" translate="yes" xml:space="preserve">
          <source>The following floating-point error conditions are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4f90abfd9c4aaea62c390400d56b7eb617f8af" translate="yes" xml:space="preserve">
          <source>The following format specifiers are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8aa77024587faa413de9da508229e9cf4a51fc" translate="yes" xml:space="preserve">
          <source>The following function names are reserved for future addition to &lt;code&gt;complex.h&lt;/code&gt; and are not available for use in the programs that include that header: &lt;code&gt;cerf&lt;/code&gt;, &lt;code&gt;cerfc&lt;/code&gt;, &lt;code&gt;cexp2&lt;/code&gt;, &lt;code&gt;cexpm1&lt;/code&gt;, &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog1p&lt;/code&gt;, &lt;code&gt;clog2&lt;/code&gt;, &lt;code&gt;clgamma&lt;/code&gt;, and &lt;code&gt;ctgamma&lt;/code&gt;, along with their -f and -l suffixed variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f18389086be3ef835c51e9ad36c08bb8badaac5" translate="yes" xml:space="preserve">
          <source>The following functions are &lt;code&gt;noreturn&lt;/code&gt; in the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a591d9fa5638aac9fa2b83e82338a91618a78a" translate="yes" xml:space="preserve">
          <source>The following functions manage program termination and resource cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f554e67755443645ddea4d0c9f686b445b59a7f" translate="yes" xml:space="preserve">
          <source>The following functions should not be called from multiple threads without synchronization with the &lt;code&gt;mbstate_t*&lt;/code&gt; argument of &lt;code&gt;NULL&lt;/code&gt; due to possible data races: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1674823b2b9c702abeb414373c5461775fcadedb" translate="yes" xml:space="preserve">
          <source>The following identifiers are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52747f8b268619d42bfc41249c2443bf02dfb375" translate="yes" xml:space="preserve">
          <source>The following limitations are imposed on the user-defined function that is installed as a signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a246baccbe5a74a2372f3123a79e57ab1d8a6e" translate="yes" xml:space="preserve">
          <source>The following macro names are predefined in any translation unit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760cdc8623d4deb346e101e369ccc8511374acd9" translate="yes" xml:space="preserve">
          <source>The following program computes the number of seconds that have passed since the beginning of the month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff275c825fa1a87d99185f365a34ebec03469ef" translate="yes" xml:space="preserve">
          <source>The following properties of bit fields are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ffe5d9875553429026debf7cff7fd09bf924b6" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa536e53d4635c03c483d42ad9b70a227480cbe" translate="yes" xml:space="preserve">
          <source>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of &lt;a href=&quot;https://en.wikipedia.org/wiki/One%27s_complement&quot;&gt;one's complement&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method&quot;&gt;sign-and-magnitude&lt;/a&gt;) and the limits of the most commonly used implementation, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;two's complement&lt;/a&gt;. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a901e9b7792340a20dc3a26c920d9911c931da64" translate="yes" xml:space="preserve">
          <source>The following table summarizes all available integer types and their properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6d452f86036275cf545aa6c2fd879d6ea70e67" translate="yes" xml:space="preserve">
          <source>The following three pragmas are defined by the language standard:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc57bf9778baf29a073665323a0c5976c6a1f23" translate="yes" xml:space="preserve">
          <source>The following three-character groups (trigraphs) are &lt;a href=&quot;translation_phases&quot;&gt;parsed before comments and string literals are recognized&lt;/a&gt;, and each appearance of a trigraph is replaced by the corresponding primary character:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2546fbb06c0a729787bc6cd7125e1b5361e4578" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the &lt;a href=&quot;preprocessor&quot;&gt;preprocessor&lt;/a&gt; when they are used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3e2b4ce9621498219d1ebd6d8fb04d675b973c" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the preprocessor when they are used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ef24e493d7f7eee6e3b99062deb09c3faa2fa" translate="yes" xml:space="preserve">
          <source>The following two declarations declare the same function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05238738a8d9e70dab6db4701b54bdcd606eef3b" translate="yes" xml:space="preserve">
          <source>The following types are incomplete:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05263cedaa87adae4404e0d5d0d5c6012425b488" translate="yes" xml:space="preserve">
          <source>The following values of &lt;code&gt;str&lt;/code&gt; are supported in all C locales:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c29167a05bd707a804eef66e8a46280899a02a0" translate="yes" xml:space="preserve">
          <source>The following variables are initialized to the same value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68fcc28a98f3dfdaf45ebc2e1785811a6a9fe23" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ac56cdaeeb6de79fc364f4fe683f408e59c3e6" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0ad27913f478ab70d1cc2d0e0549d118103730" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671556fcedcbcc40a3b072fd7bffc45f2fbccd26" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b4201164d0bc303ec63a1d04f289d249202a0f" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b718549b02c9a87887915199e47e1a005bfae44" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2555a9003a37354d6399908418d0705063de50cf" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92789305795f1eb56d034465a61e558a6506280d" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51860d6c8145c8370c4b642d4fc1c22a2186f998" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b523e0c8748ab9c5e972ec8245b3621fc4041002" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0aa77172a8536624fd5ee996fa4b09d9c154130" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76408fd6762baa6a334ed1b0697b3874e7fb1be4" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b9db29e262a1c1455a0e82dbd508a761aa0601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed94452fd5320f29fe790ddccc946a60d3be8519" translate="yes" xml:space="preserve">
          <source>The fractional part is discarded (truncated towards zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e76a18348bd7140463f4991aabb39103dce3cf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17196b905a44e0edee51205b99ccb0d4ea314cc3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffdf9ae1184af0302bbd32d7e4f00be8f426782" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcat_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcat&lt;/code&gt;, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efd9ecc68a30f292c27629dda09e33a1b504eaf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcpy_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcpy&lt;/code&gt;, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720e67ae7cff5823d2274d70efa49b7c85aa1156" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;free()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8b1015abb293307d6cda96134dccb409db2cd8" translate="yes" xml:space="preserve">
          <source>The function call expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3171de1fa826c9d265134dad86a77ff176be6f3" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe121470076dfe7dca9614b38a83d97b455692" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f55932afa3e6e418ba772b0aaec318f66a0359" translate="yes" xml:space="preserve">
          <source>The function is implemented as a macro. &lt;code&gt;A&lt;/code&gt; is the type of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d9155e7bdfa1ab71dea3775710a903a49a673c" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot; because the function searches for characters not found in &lt;code&gt;src&lt;/code&gt;, that is the complement of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58af6034860fd87af855232a56a774834e007602" translate="yes" xml:space="preserve">
          <source>The function simply returns to the caller without performing any other action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5eafec853997f8ec44f631d7a03573e4237d1e" translate="yes" xml:space="preserve">
          <source>The function to call is determined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6257fd0e7140666f722f4b319f1c0f01eedf826a" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bac96adb11f232384a0a833a8c3ab44e75559c8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc38b545ed39f36edc888e0a1aadedeb651989b" translate="yes" xml:space="preserve">
          <source>The functions registered with &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64603c7c7d2bc52bc986d70787386849f4ce71ed" translate="yes" xml:space="preserve">
          <source>The handler must be a pointer to function of type &lt;code&gt;constraint_handler_t&lt;/code&gt;, which is defined as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b274cb694448d1bfa9bf6c931f75319a1e0a7aa" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; defines &lt;a href=&quot;../atomic&quot;&gt;37 convenience macros&lt;/a&gt;, from &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_bool&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_uintmax_t&lt;/a&gt;&lt;/code&gt;, which simplify the use of this keyword with built-in and library types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ddd8d38d4b8564e2c354808a42090ee373e9e1" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; includes the headers &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ad7272aaadf98b5dfc20eafa318d853f619946" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;complex.h&lt;/code&gt; provides types and functions about &lt;a href=&quot;numeric/complex&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388aaf76829951120a17be67c04fd86012fafcdd" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;fenv.h&lt;/code&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cc9e76a5e563d564e013252f3f732aeac63c6e" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;math.h&lt;/code&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79610cd72ab9bda5e0cc9559f891b46b03619e71" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;stdlib.h&lt;/code&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc356d62136302dae71ff7d5b64387ba61e65f6" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;tgmath.h&lt;/code&gt; provides some macros for a function which names XXX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024bdd2fc5e7f5dd7775a84e539446cdbb9cc19a" translate="yes" xml:space="preserve">
          <source>The identifier itself, if used, becomes the name of the enumerated type in the tags &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt; and requires the use of the keyword enum (unless typedef'd into the ordinary name space).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037a292514cf5762093c51f94e41b9f7f76bc8ff" translate="yes" xml:space="preserve">
          <source>The identifier of the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2ec11eb7cd3993bbc0fbdd3a84fd4d32466d57" translate="yes" xml:space="preserve">
          <source>The imaginary constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1eb1c62e8a76621e675ea472f278a7a95b40c1" translate="yes" xml:space="preserve">
          <source>The imaginary numbers make it possible to express all complex numbers using the natural notation &lt;code&gt;x + I*y&lt;/code&gt; (where &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;). Without imaginary types, certain special complex values cannot be created naturally. For example, if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then writing &lt;code&gt;0.0 + I*INFINITY&lt;/code&gt; gives NaN as the real part, and &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;(0.0, INFINITY)&lt;/code&gt; must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;1.0 - 0.0*I&lt;/code&gt; results in the positive zero imaginary component if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; and the negative zero imaginary part requires the use of &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../numeric/complex/conj&quot;&gt;conj&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55efabcd8849ef60ae8f5ea3a08febcffd5cd21" translate="yes" xml:space="preserve">
          <source>The imaginary part is discarded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597104ddba845ce9bd24aa6877ef6907f2382360" translate="yes" xml:space="preserve">
          <source>The imaginary part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a99abb7396bbd40ee3b035ec1eb049a07d6192" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result follows the conversion rules for the corresponding real types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09714acfb208e9f9b257f3045c35d573a30525df" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d883b4e1722e4a8d3caa8bc74366a237fa4929ec" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee59aa77f4b166942e6841c23ab435c8ebfde79" translate="yes" xml:space="preserve">
          <source>The implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d244055efbceb9cd116b307d0068bd03d7ccf1f4" translate="yes" xml:space="preserve">
          <source>The index in an &lt;a href=&quot;array_initialization&quot;&gt;array designator&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e82d0a49cb26cac8606496f3b74019e4f5bd7ab" translate="yes" xml:space="preserve">
          <source>The initial value of atomic object of automatic storage duration that is not explicitly initialized using this macro(until C17) is indeterminate. The default (zero) initialization of static and thread-local variables produces a valid value however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14bd019aca2383204e2ad83d047789a2c7ba54e" translate="yes" xml:space="preserve">
          <source>The initial values of function parameters are established as if by assignment from the arguments of a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, rather than by initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79095678450b261a7d4377d1d69bb99aef817af" translate="yes" xml:space="preserve">
          <source>The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051643a6443136c90c153854e9479f16f32a9c1c" translate="yes" xml:space="preserve">
          <source>The initializer list may have a trailing comma, which is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21f21c29b1dd53223eceae658fd8c0f4adf0abb" translate="yes" xml:space="preserve">
          <source>The initializer specifies the initial value stored in an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc8e20b4e5a968131b73c499de88baceffe7987" translate="yes" xml:space="preserve">
          <source>The initializers of the variables with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0d426c073cbcb4ac70cff904892f38bd7c72ae" translate="yes" xml:space="preserve">
          <source>The integer argument of &lt;code&gt;_Alignas&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c052ad8a76feca9c20921855c2130e125e23b1b8" translate="yes" xml:space="preserve">
          <source>The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3461dd13d361fb9e7a46ff0b4396f48813e4b6bc" translate="yes" xml:space="preserve">
          <source>The intent of the &lt;code&gt;inline&lt;/code&gt; specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the &lt;code&gt;inline&lt;/code&gt; specifier for the purpose of optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6924d561fcec2a25cafd9f30b6ce9d38cd1a4d2" translate="yes" xml:space="preserve">
          <source>The introduction of // comments in C99 was a breaking change in some rare circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df73dd5056e900e6ab07fe7d785f7316167ce7e1" translate="yes" xml:space="preserve">
          <source>The iteration statements repeatedly execute a statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbe65a328ae1a1725e46d04473058103fa2038a" translate="yes" xml:space="preserve">
          <source>The jump statements unconditionally transfer flow control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f512905bc0e7bcf8e0a06a3d543ae75331a9386b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;_Thread_local&lt;/code&gt; is usually used through the convenience macro &lt;code&gt;&lt;a href=&quot;../thread/thread_local&quot;&gt;thread_local&lt;/a&gt;&lt;/code&gt;, defined in the header &lt;code&gt;threads.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10772b161d3dd40c9407a3fdf1ba40e6710ac1e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typedef&lt;/code&gt; is used in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, in the grammatical position of a &lt;a href=&quot;storage_duration&quot;&gt;storage-class specifier&lt;/a&gt;, except that it does not affect storage or linkage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e6ce2423b10435fec95359cfc7871356cc7655" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5db95457fd00b5137fae42ae0ad03c02ab7b1d9" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f6d5a8dd3178b9f5f93350efdb40176e9f37c4" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2394bacc13a55aabca9c891a3369daa891fec410" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4390732ceb72a7d86e32c5b0b0e5852ccc329b7" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba41a49e5fa46c983e71aed0b7bf8c8cf2bcd61" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049923770e49e0dc29c177e486ea5da1a8510445" translate="yes" xml:space="preserve">
          <source>The library type &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; does not provide inter-thread synchronization or memory ordering, only atomicity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7074b32735e8bf688f9281dcebfc831011f3a5" translate="yes" xml:space="preserve">
          <source>The line number following the directive &lt;code&gt;#line __LINE__&lt;/code&gt; is implementation-defined (there are two possible values that __LINE__ can expand to in this case: number of endlines seen so far, or number of endlines seen so far plus the endline that ends the #line directive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784e7ee73ce693765b5c5ba90815e9b87d11972a" translate="yes" xml:space="preserve">
          <source>The logical AND expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d04b7b384fbd368de9e9b44a07a158efbdffa63" translate="yes" xml:space="preserve">
          <source>The logical NOT expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f39c867b0308cf432ff2ac9d19a03a4ddb3431" translate="yes" xml:space="preserve">
          <source>The logical NOT operator has type &lt;code&gt;int&lt;/code&gt;. Its value is &lt;code&gt;​0​&lt;/code&gt; if expression evaluates to a value that compares unequal to zero. Its value is &lt;code&gt;1&lt;/code&gt; if expression evaluates to a value that compares equal to zero. (so &lt;code&gt;!E&lt;/code&gt; is the same as &lt;code&gt;(0==E)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0017b25e29a52a58370b61f25df5eb44b294a7" translate="yes" xml:space="preserve">
          <source>The logical OR expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfbb57750fb5f7112ff7e65f25d43235885b786" translate="yes" xml:space="preserve">
          <source>The logical-AND operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if both lhs and rhs compare unequal to zero. It has the value &lt;code&gt;​0​&lt;/code&gt; otherwise (if either lhs or rhs or both compare equal to zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1edfa9d60b658de6c633aadb9fa593c4e1a912" translate="yes" xml:space="preserve">
          <source>The logical-OR operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if either lhs or rhs compare unequal to zero. It has value &lt;code&gt;​0​&lt;/code&gt; otherwise (if both lhs and rhs compare equal to zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2eca04fbdbfa85ffa013854d23cfd7ee4c2242" translate="yes" xml:space="preserve">
          <source>The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ca3a77c674e6760cefc2d99377e4d887b83ff7" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;I&lt;/code&gt; is often used to form complex numbers, with expressions such as &lt;code&gt;x + y*I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then such expression may create a value with imaginary component &lt;code&gt;+0.0&lt;/code&gt; even when &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;-0.0&lt;/code&gt;, which is significant for complex number functions with branch cuts. The macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; provides a way to construct a complex number precisely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57be3ca2436b3c7e80915f52102e2654815419" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8841799ce4f61109365c940ff69b8b7ec719c836" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0067abc6a159712bb56dd3f2aea66ef110adc4" translate="yes" xml:space="preserve">
          <source>The macro is not named &lt;code&gt;i&lt;/code&gt;, which is the name of the imaginary unit in mathematics, because the name &lt;code&gt;i&lt;/code&gt; was already used in many C programs, e.g. as a loop counter variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c798130b9170a560fc1a663c486665854f217b8c" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;wc&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329fc6fceaa5447c01dd9f62cafecf085e1ff466" translate="yes" xml:space="preserve">
          <source>The member access expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; designated by its left operand. It has the same &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; as its left operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5122e1449ef0335505c57e5253a964f45fcdf79" translate="yes" xml:space="preserve">
          <source>The member access expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa318493dd5c2f458fec0ccc1d6f9c59afaab4fd" translate="yes" xml:space="preserve">
          <source>The member access through pointer expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type pointed to by its left operand. Its value category is always &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6e0885b44b0d2f2e93a7131b908d31fa827da7" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98877038e2ba0fac0c119a38c0522d0619de0c17" translate="yes" xml:space="preserve">
          <source>The most common keywords that begin with an underscore are generally used through their convenience macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bbb14be1144d08570d1c46bcac519c4ca04a16" translate="yes" xml:space="preserve">
          <source>The most popular use case for restrict-qualified pointers is the use as function parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb2ce61596e9a9e2acbc1daec6dd4f31667f9c0" translate="yes" xml:space="preserve">
          <source>The names of &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt; are not part of any name space because they are replaced by the preprocessor prior to semantic analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6eccb49cbb94feecde36ffadd4ba34340c519c4" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline byte or byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b9c57e3af3e967b10eb352639b13192c618556" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d92f701b5c07543e4ab84377a0c9414fa7a320" translate="yes" xml:space="preserve">
          <source>The number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e0726f8dc98eb74868d9afc85bf0df3317f165" translate="yes" xml:space="preserve">
          <source>The number of objects written successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807035c9e6b0ffb0f3a70e237d402f9009cdef78" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b873fe3bdfab61293a8ea3488d6ce55e2f2befb5" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dd6a69e521621a23e516eeff24b5d905692137" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff53dd2216bc51a0d7bbb3c32825f9455bce0ac" translate="yes" xml:space="preserve">
          <source>The operand expr of both prefix and postfix increment or decrement must be a &lt;a href=&quot;value_category&quot;&gt;modifiable lvalue&lt;/a&gt; of &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; (including &lt;code&gt;_Bool&lt;/code&gt; and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18275d066ab2586011d304d388724f3ba9519b5f" translate="yes" xml:space="preserve">
          <source>The operand is not evaluated (so external identifiers used in the operand do not have to be defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37137d3854c9080efa5ba737cb6b214274865b11" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4163fdf5ba90cadb97f17282331d38484360c2" translate="yes" xml:space="preserve">
          <source>The operand of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; can't be a type cast. This rule grammatically forbids some expressions that would be semantically invalid anyway. Some compilers ignore this rule and detect the invalidity semantically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73662db4f86c916723ec8e38855bae82c65cb635" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or they may be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31ff6e872519cb01b42793b5610377a28df7a92" translate="yes" xml:space="preserve">
          <source>The operands of the &lt;a href=&quot;sizeof&quot;&gt;sizeof operator&lt;/a&gt;, the &lt;a href=&quot;alignof&quot;&gt;_Alignof operator&lt;/a&gt;, and the controlling expression of a &lt;a href=&quot;generic&quot;&gt;generic selection&lt;/a&gt;,(since C11) are expressions that are not evaluated (unless they are VLAs)(since C99). Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;, 4));&lt;/code&gt; does not perform console output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d297e1f23cc8859be5bde831c7d9be6c7bf9a287" translate="yes" xml:space="preserve">
          <source>The order of bit fields within an allocation unit (on some platforms, bit fields are packed left-to-right, on others right-to-left)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc9aa93e9756b28627ee99925b99df10b1ad6c5" translate="yes" xml:space="preserve">
          <source>The order of evaluation of # and ## operators is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a0f335326728b6cca410047346d8dea887e482" translate="yes" xml:space="preserve">
          <source>The other use of the keyword &lt;code&gt;static&lt;/code&gt; is &lt;a href=&quot;file_scope&quot;&gt;file scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f26538f800d4e9dfa396f5f3af68d5b600733f" translate="yes" xml:space="preserve">
          <source>The parameters in a declaration that is not part of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; do not need to be named:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaa687493b6df88d7a017675ddb9c620e6ecde2" translate="yes" xml:space="preserve">
          <source>The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c545f4e65d9a240009138753e3771a06a41dbc9" translate="yes" xml:space="preserve">
          <source>The predefined variable &lt;code&gt;__func__&lt;/code&gt; (see &lt;a href=&quot;../language/function_definition#func&quot;&gt;function definition&lt;/a&gt; for details) is not a preprocessor macro, even though it is sometimes used together with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, e.g. by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4687c98781e74fbe3189f89c48b78e9e171beb" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27574a8faae48a163d31765e56cbbeb67aa3ad8a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement and function-like text macro replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d1a0ebd42aa1b39b4a03a00bbf88d9f00ef744" translate="yes" xml:space="preserve">
          <source>The previous value held by the atomic flag pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b415c1df8056a8b60b1fe0e4eaabdb03213a23ff" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; on the Riemann sphere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ca745a924bb9137959b139a9ffdc062119f806" translate="yes" xml:space="preserve">
          <source>The qualifiers that appear between &lt;code&gt;*&lt;/code&gt; and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3d414a29f86b002434e0375d474e5453d360f9" translate="yes" xml:space="preserve">
          <source>The real part is converted following the rules for the real floating types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d332d998b707cad080166fabcdd3ca82e157e01" translate="yes" xml:space="preserve">
          <source>The real part is discarded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fb212acc87955b594f7e2f071c1ac0ec5aa798" translate="yes" xml:space="preserve">
          <source>The real part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4346c79f063102e016ae364fb68f3f8bb2758d57" translate="yes" xml:space="preserve">
          <source>The real part of the result is determined by the conversion rules for the real floating types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3101c9f33fc2be7ee330e9f087611a76f132bd" translate="yes" xml:space="preserve">
          <source>The real part of the result is the positive zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91a538270dcd320d3a898adcd71a4e8cf52f99d" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;tss_delete&lt;/code&gt; never calls destructors is that the destructors (called at thread exit) are normally intended to be executed by the same thread that originally set the value (via &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;) that the destructor will be dealing with, and may even rely on the values of that or other thread-specific data as seen by that thread. The thread executing &lt;code&gt;tss_delete&lt;/code&gt; has no access to other threads' TSS. Even if it were possible to call the destructor for each thread's own value associated with &lt;code&gt;tss_id&lt;/code&gt;, &lt;code&gt;tss_delete&lt;/code&gt; would have to synchronize with every thread if only to examine whether the value of this TSS in that thread is null (destructors are only called against non-null values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7248ba66e1897d995063b1acf5aa812b6ba0952" translate="yes" xml:space="preserve">
          <source>The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748eabde86f4be7c00894966086a057656832218" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fca208bdd61aeb00fb518a1b586c85e37c17e7" translate="yes" xml:space="preserve">
          <source>The relational operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ef1943a699e87ee70990285ed8c7f6d3a1bc80" translate="yes" xml:space="preserve">
          <source>The result is an integer constant of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622a039faf91ba533c61ef9a103fa3595c187ec2" translate="yes" xml:space="preserve">
          <source>The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;default rounding direction&lt;/a&gt; during translation is implementation-defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95074b83d96838fbb0176f8d997b7f5d8c7e69fb" translate="yes" xml:space="preserve">
          <source>The result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8eb097162eccdf968f91720477290428716a2d9" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*exp&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc90b9c6aca8e99ddaa9a7c76d3df7f7c89550ed" translate="yes" xml:space="preserve">
          <source>The result of the postfix increment and decrement operators is the value of expr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe87173b6111d916a794c69de4b3db44d02ad43d" translate="yes" xml:space="preserve">
          <source>The result of the prefix increment operator is the result of adding the value &lt;code&gt;1&lt;/code&gt; to the value of expr: the expression &lt;code&gt;++e&lt;/code&gt; is equivalent to &lt;code&gt;e+=1&lt;/code&gt;. The result of the prefix decrement operator is the result of subtracting the value &lt;code&gt;1&lt;/code&gt; from the value of expr: the expression &lt;code&gt;--e&lt;/code&gt; is equivalent to &lt;code&gt;e-=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051e09522f14a201c152465dc43e09f778fe0395" translate="yes" xml:space="preserve">
          <source>The result of this conversion may have greater range and precision than its target type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370e8414fd327899a4b199af9a10f347fd8f9909" translate="yes" xml:space="preserve">
          <source>The result type is determined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0defe1a2c0ecb1ad124d49279ffb47529db4f8" translate="yes" xml:space="preserve">
          <source>The resulting string has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480df78ac4c637eafab6deaf07efb2edc33ecdf4" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be cvr-qualified: any qualified return type is adjusted to its unqualified version for the purpose of constructing the function type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7dcf423f1c6746845ea395c4d29680d8249cb3" translate="yes" xml:space="preserve">
          <source>The return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cfe8cddaf67890ed027e912f162eac09c9f502" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less or equal to &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26627005fd8f0f998000eb5ad42f45195facac69" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cca19123f3e3aecba38855a6236bf8a3be39e0" translate="yes" xml:space="preserve">
          <source>The scope of a name introduced in the parameter list of a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt; that is not a definition ends at the end of the function &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f9e9e6e1ccdae243de6a8dd152c835a4814d19" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared inside a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, including function bodies, or in any expression, declaration, or statement appearing in &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; statement(since C99), or within the parameter list of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; begins at the point of declaration and ends at the end of the block or statement in which it was declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da26ef01f7800f45aa5282d2dba502de493ec7e" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a55802911a29a7c84471e338e2b3d8f2f2258f6" translate="yes" xml:space="preserve">
          <source>The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8bc4ca47ab86782b6ebc508ebe6dfdcefc5516" translate="yes" xml:space="preserve">
          <source>The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57eacece4f9fbc810d3e12053a65d86114435d0a" translate="yes" xml:space="preserve">
          <source>The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1af425a408607461b9f2fb850e37301a9a085a" translate="yes" xml:space="preserve">
          <source>The scope of the aliasing assertion made by a restrict-qualified pointer that is a member of a struct is the scope of the identifier used to access the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a691571a758bb7696344431b9bfb2790b337304" translate="yes" xml:space="preserve">
          <source>The selection statements choose between one of several statements depending on the value of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f77a16398df99646e30617c7408e24bfd96747a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;/&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;/&lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;-qualifiers and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017c5419328af904a55edc0a14ee95f01cd1e984" translate="yes" xml:space="preserve">
          <source>The side effect of updating lhs is &lt;a href=&quot;eval_order&quot;&gt;sequenced after&lt;/a&gt; the value computations, but not the side effects of lhs and rhs themselves and the evaluations of the operands are, as usual, unsequenced relative to each other (so the expressions such as &lt;code&gt;i=++i&lt;/code&gt;; are undefined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa84b13f6c6f705a05056a0bda3d55f618faac49" translate="yes" xml:space="preserve">
          <source>The sign of the remainder is defined in such a way that if the quotient &lt;code&gt;a/b&lt;/code&gt; is representable in the result type, then &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf14ae5b468472769becbdbf9c46a2eef5effb8" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the arrays being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc273ef773a3a7c0899e6fca6178c1d007bc2d9a" translate="yes" xml:space="preserve">
          <source>The simple assignment operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ebf122a1a6ba9d02af71043c41ad40d0313167" translate="yes" xml:space="preserve">
          <source>The size of a  non-VLA(since C99) array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f653bb8a005764d6896a4c10b9fa21fa24e60bf7" translate="yes" xml:space="preserve">
          <source>The size of a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75b385c7daf43a9926f6adaeac9cb65f13d6dfe" translate="yes" xml:space="preserve">
          <source>The size of the array pointed to by &lt;code&gt;argv&lt;/code&gt; is at least &lt;code&gt;argc+1&lt;/code&gt;, and the last element, &lt;code&gt;argv[argc]&lt;/code&gt;, is guaranteed to be a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f06f6c9c240dd4e69a113d08da04d2bb7994431" translate="yes" xml:space="preserve">
          <source>The sleep may resume earlier if a &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; that is not ignored is received. In such case, if &lt;code&gt;remaining&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the remaining time duration is stored into the object pointed to by &lt;code&gt;remaining&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c68bd152d82f0003bda7516721387df0de4bf1c" translate="yes" xml:space="preserve">
          <source>The sole exception to the maximal munch rule is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb0a56eaaaa4fbc79add39c3ae2bbcedba7c991" translate="yes" xml:space="preserve">
          <source>The special</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98e17952a5eb1144c7a18093ec87f2dc42631df" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;../preprocessor/impl&quot;&gt;#pragmas&lt;/a&gt;&lt;code&gt;FENV_ACCESS&lt;/code&gt;, &lt;code&gt;FP_CONTRACT&lt;/code&gt;, and &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; as well as the &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;floating-point evaluation precision&lt;/a&gt; and &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; control the way floating-point expressions are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0875738ad89941cbe8ee8aded99ef6d23319611f" translate="yes" xml:space="preserve">
          <source>The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library features required by clause 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdb3b500d50c7ecf224dc0445855ec04f49c235" translate="yes" xml:space="preserve">
          <source>The standard library offers convenience typedefs for the &lt;a href=&quot;language/atomic&quot;&gt;core language atomic types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d78e0ab7d39ff1a14d8db8179cd35f2c750911" translate="yes" xml:space="preserve">
          <source>The standard library provides bounds-checked versions of some existing functions (&lt;code&gt;&lt;a href=&quot;io/gets&quot;&gt;gets_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fopen&quot;&gt;fopen_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/byte/strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/wide/wcscpy&quot;&gt;wcscpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/multibyte/mbstowcs&quot;&gt;mbstowcs_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/qsort&quot;&gt;qsort_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;program/getenv&quot;&gt;getenv_s&lt;/a&gt;&lt;/code&gt;, etc). This functionality is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac1ff28429f739a4cc4c3cff8e4e5165e074955" translate="yes" xml:space="preserve">
          <source>The standard uses the term</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c7c787747b239e731a6608e43e2c196135b2e" translate="yes" xml:space="preserve">
          <source>The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with &lt;code&gt;&lt;a href=&quot;../string/byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9716a65dc5ff30cff1eae2da273ac1d3064db74" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;lconv&lt;/code&gt; contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;. The members of &lt;code&gt;lconv&lt;/code&gt; are values of type &lt;code&gt;char&lt;/code&gt; and of type &lt;code&gt;char*&lt;/code&gt;. Each &lt;code&gt;char*&lt;/code&gt; member except &lt;code&gt;decimal_point&lt;/code&gt; may be pointing at a null character (that is, at an empty C-string). The members of type &lt;code&gt;char&lt;/code&gt; are all non-negative numbers, any of which may be &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; if the corresponding value is not available in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3a4a16886cf1ac48a851932de21f81c40cea6b" translate="yes" xml:space="preserve">
          <source>The style used to print a NaN is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21517d748a5bfd69cdd8f8ab9d477a543e017a3d" translate="yes" xml:space="preserve">
          <source>The style used to print an infinity is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5440ec13a92105f54304efe3535cd3756f2e59" translate="yes" xml:space="preserve">
          <source>The subscript operator expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; whose type is the type of the object pointed to by pointer-expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8e214981c3b158eea8b2d5e47dd47f41913a7c" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;arg&lt;/code&gt; (allowing for rounding).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fafb7379abc511f3f59880d1048edc9085d42e" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927fb804cb2eaeff9acfcfdf70d5c596b423f6da" translate="yes" xml:space="preserve">
          <source>The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241931c273ba7378188c003511f787a3f07e8c4b" translate="yes" xml:space="preserve">
          <source>The termination of the thread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5115b93d33b078df682a05c54e3833b8a2ca89" translate="yes" xml:space="preserve">
          <source>The thread identifiers may be reused for new threads once the thread has finished and joined or detached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296acc3dd7bffb8fff38e6c9ab05728e64b068e" translate="yes" xml:space="preserve">
          <source>The three complex types are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b60758934aabf8d3da266bd1b4b57e82722056" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;thrd_start_t&lt;/a&gt;&lt;/code&gt; is a typedef of &lt;code&gt;int(*)(void*)&lt;/code&gt;, which differs from the POSIX equivalent &lt;code&gt;void*(*)(void*)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d45e719006a644d4efb5b5f7ec023e503421b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is not compatible with &lt;code&gt;signed char&lt;/code&gt; and not compatible with &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f576269346b3fd8946fd4e3da2eb80a4056c88" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;mbstate_t&lt;/code&gt; is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4d74ec38eba7b867e7d4d689b5241938a4d1b3" translate="yes" xml:space="preserve">
          <source>The type after conversion is compared with type-names from the list of associations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ef2bff6850ff84da9eceaeb8081fce468a3423" translate="yes" xml:space="preserve">
          <source>The type of any equality operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31a9fe37a49aeb320a1d46d51c8f069e7627c13" translate="yes" xml:space="preserve">
          <source>The type of any relational operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811237a08cfbebd18d4367ab827711b9115f6d3d" translate="yes" xml:space="preserve">
          <source>The type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71eed56481373e458e0b94319f5f5bf3221d2ca" translate="yes" xml:space="preserve">
          <source>The type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e1afdcfba845cebcfec884ec5a8ac155768c26" translate="yes" xml:space="preserve">
          <source>The type of the expression is the type after promotion, and the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; is non-lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98e4102e24f34077fe9171371257f25c10edbfd" translate="yes" xml:space="preserve">
          <source>The type of the integer constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2680965a70e519d3207938fce242cd69e5be4916" translate="yes" xml:space="preserve">
          <source>The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829b1b1c6864595e1de1d8e5d9152081192a921a" translate="yes" xml:space="preserve">
          <source>The type of the lhs may be &lt;code&gt;void&lt;/code&gt; (that is, it may be a call to a function that returns &lt;code&gt;void&lt;/code&gt;, or it can be an expression &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cffaa40c40ebaf49e36b504549168d080b200aa" translate="yes" xml:space="preserve">
          <source>The type-generic macros are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3596eb5ea91c2633e1f6227c5debdbd1c9d68bf6" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are compatible, if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4bdd032acdf24d44472ac4ff1c101e18823b80" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are floating types at least as wide as &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;, respectively, and such that &lt;code&gt;double_t&lt;/code&gt; is at least as wide as &lt;code&gt;float_t&lt;/code&gt;. The value of &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; determines the types of &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3a2c1487d550c3fde0d68fbc12ecebb306ba75" translate="yes" xml:space="preserve">
          <source>The unary minus invokes undefined behavior due to signed integer overflow when applied to &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt;, on typical (2's complement) platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88c0e3c533664fbb73db04c0a5c2f3e03a61631" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dee7b9a492616febe6c3fc4efadefd3ada5e33b" translate="yes" xml:space="preserve">
          <source>The unnamed object to which the compound literal evaluates has static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at file scope and automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at block scope (in which case the object's &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; ends at the end of the enclosing block).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abb6094d96df27f0d637760f1d1f17013caac08" translate="yes" xml:space="preserve">
          <source>The use of alignof with expressions is allowed by some C compilers as a non-standard extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b44666438f2ec28588f661880af1a91734f0eee" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a983788a30d253bace1a068a44d1826dc47d6596" translate="yes" xml:space="preserve">
          <source>The value category of a compound literal is &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (its address can be taken).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6d7ff00e83423b304179c97fa6160b61c7d16c" translate="yes" xml:space="preserve">
          <source>The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db27de9a2c14b5c36e77ac11db7b1e6b539ddf4" translate="yes" xml:space="preserve">
          <source>The value held previously be the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce421ed8122dc0c953b3daa7401767634d485f5" translate="yes" xml:space="preserve">
          <source>The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea83a39e96975099582b35000c5f6ef163b872" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;enum&quot;&gt;enumeration constant&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2319cb95fe6c4140766f25ba6aceff81797d3bc7" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae0f9145d3f54ff503856e7f95a6dee62b616ad" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;logb&lt;/code&gt;, |arg*r-e</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c338856b102032dd7454b82d3852e88916b004c" translate="yes" xml:space="preserve">
          <source>The value on success, &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1839c6dd4f14d95b9fec518dce3cd0ccd9859a" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb246d2ead310c8f059b8b86885fc138b2913d2" translate="yes" xml:space="preserve">
          <source>The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afb1ba711265f6de0e35e414290ff85c3a2ad0f" translate="yes" xml:space="preserve">
          <source>Then, a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; takes place, so that all side effects of lhs are complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb90fa2576c7925b07f1e1ac9159668e2bf9b053" translate="yes" xml:space="preserve">
          <source>Then, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7078c4d1c98d55c4bc04aaeacb070077101e980" translate="yes" xml:space="preserve">
          <source>Then, the right operand, rhs, is evaluated and its result is returned by the comma operator as a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3f137a362c8e821a1e6b9a4948bb2c26de27af" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for the operators that use non-ISO646 characters, defined in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba25eb602283568b271842c052f8b74fae72c6c" translate="yes" xml:space="preserve">
          <source>There are five types of statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6772e38914753165f4023b86ef3b645e638c1de8" translate="yes" xml:space="preserve">
          <source>There are four coherences that are guaranteed for all atomic operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beccd582c554354fe97bf6fe8f530cf6be9b9156" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b96aea907cb0b6e15b2cdf641639fef1154954" translate="yes" xml:space="preserve">
          <source>There are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void*) or integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92ddc58d5de1bff3b780dc60945b52fcda99d6e" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls). &lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs, like cryptography.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588bd29754314126c33aee156a614a561e64c447" translate="yes" xml:space="preserve">
          <source>There are no negative floating constants; an expression such as &lt;code&gt;-1.2&lt;/code&gt; is the &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operator&lt;/a&gt; unary minus applied to the floating constant &lt;code&gt;1.2&lt;/code&gt;. Note that the special value negative zero may be constructed with &lt;code&gt;-0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdca7722c2b3b18ea7c62a79f1fda46ad671b715" translate="yes" xml:space="preserve">
          <source>There are no negative integer constants. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the constant, which may involve implicit &lt;a href=&quot;conversion&quot;&gt;type conversions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3b42ee7caccbfb7868142d55eb631f71011dee" translate="yes" xml:space="preserve">
          <source>There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2d3c4f220b5494a67a0f9953dc898467eabcbd" translate="yes" xml:space="preserve">
          <source>There are several common usage patterns for restrict-qualified pointers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adc61e5da640a9ba91547c50c8ab6dddb0048c4" translate="yes" xml:space="preserve">
          <source>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4997b02e62e6a0e4ec89133d02261fc0ce72b438" translate="yes" xml:space="preserve">
          <source>There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fabe6d44b488b86750b5227d2a79c424b55dd2" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52984a17b30b0d82af603d64b3c7eb96ca2c2d00" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70af8d031e1e84898b1b7b8ee0619e430a9744d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14abb1fb6e2bfb562fbb9a6e6989215e9fd7c48f" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb84e3cfc1155e6d27b4d15b2eca66bb1cb86c9" translate="yes" xml:space="preserve">
          <source>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression &lt;code&gt;f1() + f2() + f3()&lt;/code&gt; is parsed as &lt;code&gt;(f1() + f2()) + f3()&lt;/code&gt; due to left-to-right associativity of operator+, but the function call to &lt;code&gt;f3&lt;/code&gt; may be evaluated first, last, or between &lt;code&gt;f1()&lt;/code&gt; or &lt;code&gt;f2()&lt;/code&gt; at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78979596616d979924aa8f0a7856f4ca21bc39" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;*src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9850a4c4e290745723f4fc213c3322632b4431ed" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642998dca69feddbb7005ae57f38e02a160cbb21" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34a994ae2744a9c70d2624d0339c7d60e48fac7" translate="yes" xml:space="preserve">
          <source>These macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is actually undefined) and as if defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4070e09555e3c6b6233a56d9b2a60f748e63343" translate="yes" xml:space="preserve">
          <source>These rules apply recursively to the types from which the two types are derived.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18430fdedd8d39e1faff6417927ee373baccbc33" translate="yes" xml:space="preserve">
          <source>These rules control whether a function that receives two pointers must re-read one after writing through another:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c584adee26a0f194a4221931b8f5c6cd4324020" translate="yes" xml:space="preserve">
          <source>These rules simplify the use of header files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da00a198d25ed4a99c4e2cfacbe9f6df3d8c0b0" translate="yes" xml:space="preserve">
          <source>They can even avoid using the tag name space at all:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88450ca53b9705996636f46ab82f85909cd9ffd6" translate="yes" xml:space="preserve">
          <source>They can have postfix form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe69ffd880071fd0df6c53ec20b12147145bf12" translate="yes" xml:space="preserve">
          <source>This allows structs that refer to each other:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ed7fa74d34f8de0d1eaf468b8712c8f649e605" translate="yes" xml:space="preserve">
          <source>This constant is equivalent to the POSIX &lt;code&gt;PTHREAD_DESTRUCTOR_ITERATIONS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50860f0a9733ec87d616cbc629bfd04dd2d57a1" translate="yes" xml:space="preserve">
          <source>This convenience macro expands to the keyword &lt;a href=&quot;../keyword/_static_assert&quot;&gt;_Static_assert&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69559dc667ea9ee00a61f5b0fa74edf96266446" translate="yes" xml:space="preserve">
          <source>This conversion models the memory load of the value of the object from its location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7411fcb845dcaee0f13e9cd4e36b67d0ac9d7fab" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0244ac28d2447894c8661b2de1ddf4c14a2a9959" translate="yes" xml:space="preserve">
          <source>This example shows how to read a file twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f912b3d69a2d64099faca61cd00f39d6e484909" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3c34a0198ac33575e10015adc37a15fd3102be" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;gmtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50d9318428e6b56bb64ec1ee9a5392761dc1191" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;localtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6efd938fea60e8a8ba4cf09b50c3ce4deac15d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a string literal cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c153eac4de71030a581d492d74631860a8a74df0" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;wcstok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fced0fa7f525bd304cf4a0df7503105cd2c0150" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231a0871c75740128f3a8e900a16eece62f9a755" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289cf9d190604844c33bb4b2eed7d07fca8b2a3c" translate="yes" xml:space="preserve">
          <source>This function is fully specified for all possible inputs and is not subject to any errors described in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd9eb1ebb9f64fc35b5dd954c1ec8fde9ee2bc0" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;strxfrm&quot;&gt;strxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bdb6519f660463d2b94beeadb5dcc88cb10b36" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927a55b81991e753e70085ac5fc65b5e5213d7eb" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match any collation order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18c3327a1bb9aff722e27566d40c0f5a2e03ab6" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6683742f8d4669b99ea5d2493ece7dd4bf9163f" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a709e4cf707eedac9654ec2bb76727de164f9448" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee72f094fe13a8766f016ade2b2b9b07bf2aa390" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65b542fcd908db7b072f90fe956dd83e5f184b9" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03d3793ab454e8128b5c58da21acb181e05d455" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;remquo&lt;/code&gt;, he low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c12e20abb3630d4e436c000152934a2b3212d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90c1d681d31741a20a83a505d3bfb6598bed15c" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba5a1fa5d6bf34dbc8e4aa1de43f17b83ab0d16" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96689986a9f996a280e4c757957f55a81eb0fb31" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;setbuf&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67c60121c3003570bb2cb1cae4c32a23903e49f" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5497fdd666555fbd47980c9e891c896338ff075a" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/object&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically meaningful for byte arrays only: structs may have padding bytes whose values are indeterminate, the values of any bytes beyond the last stored member in a union are indeterminate, and a type may have two or more representations for the same value (different encodings for +0 and -0 or for +0.0 and &amp;ndash;0.0, indeterminate padding bits within the type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bf69b22ca337dadc2c824c35f9f63e828aff82" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead. The C standard also recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;asctime&lt;/code&gt; and &lt;code&gt;asctime_s&lt;/code&gt; because &lt;code&gt;strftime&lt;/code&gt; is more flexible and locale-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2be7af8e841f9575c6ea1a25f265a05a0d98bc" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e4ea005b5c762b68b78e66cb478bbb9f15f5ca" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e181a8038634b4136f7fdead9b63de0740a42ba9" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ced58fc25709f23b54d5a8febf8951bc9cad14" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e969750390e2bd7552b0c9939a42fffba170be3a" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;M&lt;/code&gt; is either the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic integer type, or &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b809c781f1dd40ccaa7e9909384069fc16d953" translate="yes" xml:space="preserve">
          <source>This is a convenience macro that makes it possible to use &lt;code&gt;float imaginary&lt;/code&gt;, &lt;code&gt;double imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt; as an alternative way to write the three pure imaginary C types &lt;code&gt;float _Imaginary&lt;/code&gt;, &lt;code&gt;double _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4229ef0621d5243c8579b95063d0e32f80e2588" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db09d9c40cfbd787606a59adeb9a502f7781cbba" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C language constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a43046ffec5125bc8767c2110f2dc6b326902d" translate="yes" xml:space="preserve">
          <source>This is commonly used with the &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; type qualifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d36f9177dcf527b56588facf919e3ece4cf5e27" translate="yes" xml:space="preserve">
          <source>This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a90074bad3bc54e82f4f7ddf4763be591f8a47" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../error/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3818c60dd5ef1e3857dbc5128a82d394bd645c" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignas&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e8ecfd0675839a3db53a82395e130694339dcc" translate="yes" xml:space="preserve">
          <source>This macro allows for the precise way to assemble a complex number from its real and imaginary components, e.g. with &lt;code&gt;(double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;)((double)x + _Imaginary_I * (double)y)&lt;/code&gt;. This pattern was standardized in C11 as the macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;. Note that if &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; is used instead, this expression is allowed to convert negative zero to positive zero in the imaginary position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023f0d845cc1e4d3a0cf1393352c3051de4551a4" translate="yes" xml:space="preserve">
          <source>This macro detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;copysign&lt;/a&gt;&lt;/code&gt;, this macro is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb93fa29a939ad1bd07999da84e45d8cb15f21" translate="yes" xml:space="preserve">
          <source>This macro expands to a type specifier used to identify &lt;a href=&quot;../../language/arithmetic_types#Complex_floating_types&quot;&gt;complex types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae5edaddb18393f98f243eeeef3dce5c87a470" translate="yes" xml:space="preserve">
          <source>This macro expands to the keyword &lt;a href=&quot;../../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb4294230f13b4be30e04365483aa72ed1a0d15" translate="yes" xml:space="preserve">
          <source>This macro may be used when &lt;code&gt;I&lt;/code&gt; is not available, such as when it has been undefined by the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ace75fad1f360f4336a3771cfb8db911e37fa5" translate="yes" xml:space="preserve">
          <source>This macro was a part of early draft design for C11 atomic types. It is not needed in C11, and is deprecated in C17 with plans to be removed in C2x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e32004ae8fed464e4a25960c2972f60263328f" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate FP_FAST_FMA* macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79fdb6054a98950180ec5dde4644fc50b541ce" translate="yes" xml:space="preserve">
          <source>This operator is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdalign.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8f6e8c9fd40e6e31833711dbbb781eb59ce111" translate="yes" xml:space="preserve">
          <source>This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constant&lt;/a&gt;&lt;code&gt;__STDC_ANALYZABLE__&lt;/code&gt;(C11) is defined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74321edc083fa8a6c39f9d431ba4d565efc66119" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a2219ff6590395a027f7654f7033a84e305390" translate="yes" xml:space="preserve">
          <source>This special identifier is sometimes used in combination with the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constants&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, for example, by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a566611cbefba4805ca4f4043cbf2b2282bebff9" translate="yes" xml:space="preserve">
          <source>This specifier is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;noreturn&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdnoreturn.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c6ad17c59c0162dbceca8860dddec46556c891" translate="yes" xml:space="preserve">
          <source>Thread library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859e6e5a070908c070449630fc5c93ccc9de646c" translate="yes" xml:space="preserve">
          <source>Thread storage duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5801c83faefb52d8b0b1d0165948b2acc652f4" translate="yes" xml:space="preserve">
          <source>Time/date utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3638c034bf7f420ee37fdfda08e7287a4fde3110" translate="yes" xml:space="preserve">
          <source>To avoid undefined behavior, the programmer must ensure that the aliasing assertions made by the restrict-qualified pointers are not violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0308792871c141a4861984782de04d99ed007497" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (&lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or any other integer constant with the value zero) may be used. &lt;a href=&quot;initialization&quot;&gt;static initialization&lt;/a&gt; also initializes pointers to their null values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a15bb607a0d9f65c2250157e2a839ed92b437f9" translate="yes" xml:space="preserve">
          <source>Top-level comma operator is also disallowed in array bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e6b018bf6b11f9dba2a0941a7aa6b16ebcda66" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally to the desired location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b482437ed63f1df61cce8a2acd92481bf3131a5e" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e434293d4a04a3d618635cca12fbe14a8e43a1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a101021db9dbdc21787f5f05cdb78df394c7c59" translate="yes" xml:space="preserve">
          <source>Translation limits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ae6e6ddfa14e2bb949e4821dfd339e832124c2" translate="yes" xml:space="preserve">
          <source>Translation phases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1b19c48da84c8f1d5f977c8442d8b7f1fe8d0f" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; without blocking. Returns immediately if the mutex is already locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08a08292325f4a3e0a8098c439550809ff5abe5" translate="yes" xml:space="preserve">
          <source>Trigraphs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f530d91391a69a7f0a5ffca3ec89a0e5873ccb85" translate="yes" xml:space="preserve">
          <source>Type cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3903d0a0100dacebf5dcf7dd9edaed2ca7445692" translate="yes" xml:space="preserve">
          <source>Type groups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b26b192c35ccdbf713808e6519a061718950de" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a612c634eb324c2736b08815ac8a0a1461bc8c70" translate="yes" xml:space="preserve">
          <source>Type names are used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9877feb39d3467fd548f9afcf785d1120971dc32" translate="yes" xml:space="preserve">
          <source>Type-generic expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b12fc7b6daa3215c051192f5645eb17e2ae21a" translate="yes" xml:space="preserve">
          <source>Type-generic macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd459fca026aec411accf6605fd9657b34f539e" translate="yes" xml:space="preserve">
          <source>Type-generic math</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667570999a748e91a3ca2389e2391bc9f38d4223" translate="yes" xml:space="preserve">
          <source>Typedef declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efbc0a48c2cf8824f893117ca1ec4d3510f7e9e" translate="yes" xml:space="preserve">
          <source>Typedef name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de7d443ce78183570b348b13d6fa7a62f5e82c3" translate="yes" xml:space="preserve">
          <source>Typedef names are also commonly used to simplify the syntax of complex declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c7f86e6a072a5ffe548bdbdb59c9f7a208dd8a" translate="yes" xml:space="preserve">
          <source>Types allowed for integer constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9516dc93be7c971fcd17049638de54d997ca4a8" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8eea246e8bae9254ad685bd7b3a0d93181f6ef8" translate="yes" xml:space="preserve">
          <source>Typically TSS is used to store pointers to blocks of dynamically allocated memory that have been reserved for use by the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e2c95f58f57dd2510b427e263653b73348604c" translate="yes" xml:space="preserve">
          <source>U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications &lt;code&gt;char32_t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978310885d0047a2bbf93710be46a9692c211868" translate="yes" xml:space="preserve">
          <source>UTF-16 and UTF-32 character utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3121f2da5238f5445bc35f88607eb1340cef35d" translate="yes" xml:space="preserve">
          <source>UTF-8 string literal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3e0d667a999aa457338ffa317c4bbb126755c9" translate="yes" xml:space="preserve">
          <source>Unary arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262592c99ae87d664d104863b6a975a077ca3383" translate="yes" xml:space="preserve">
          <source>Unary plus and minus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de34c09eb59e18282b0464bd0bc5cfe7ba5ad888" translate="yes" xml:space="preserve">
          <source>Unblocks all thread that currently wait on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7e568fb8b3fa778750d4687284053585644562" translate="yes" xml:space="preserve">
          <source>Unblocks one thread that currently waits on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629edcbcf75dfc7ce2bd6d903269c3ab902f3f25" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/limits&quot;&gt;DBL_MIN&lt;/a&gt;*(&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;(&amp;pi;)/2)&lt;/code&gt;.  erf(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94d3063db2e039c2fe617cac39f892f9945b2d8" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x*x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb361932c4949b97f983057f3dae3e641beb697" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58fabd46910e7bcf45330fb949c04b6b27dee2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list &lt;code&gt;(void)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59590d273656ea53ab0c485190687185f59c87d4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer_constant&quot;&gt;integer constants&lt;/a&gt;, a character constant may have a negative value if &lt;code&gt;char&lt;/code&gt; is signed: on such implementations &lt;code&gt;'\xFF'&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; with the value &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5893b9d3c3844337b6f481ce45fa24bcaf49949" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, there are no forward-declared enums in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349921c60cca86b52b79297f58eff9fe42b04e26" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;wcstok&lt;/code&gt; does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4736d68a5eefa333a2087043cb0199117cb95803" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;, use of this macro to construct a complex number may lose the sign of zero on the imaginary component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651147d7ee29a364b3441c1d65b4a589a7d4d5b1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strncpy_s&lt;/code&gt; does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1809f65a8ac2a536dcff46fc36c71372570caec2" translate="yes" xml:space="preserve">
          <source>Unlike C++ (and some implementations of C), the increment/decrement expressions are never themselves lvalues: &lt;code&gt;&amp;amp;++a&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d3be48bbe8c1161c3b11cb7b674b4d820d5f30" translate="yes" xml:space="preserve">
          <source>Unlike C++, C has no struct scope: names declared within a struct/union/enum declaration are in the same scope as the struct declaration (except that data members are in their own &lt;a href=&quot;name_space&quot;&gt;member name space&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356cd0e4f851521f00fbf0ecd9e4515ffc02b0ad" translate="yes" xml:space="preserve">
          <source>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca9eab5e0c8d0f26634d969a4302dfd4432c351" translate="yes" xml:space="preserve">
          <source>Unlike in C++, enumeration constants are not struct members, and their name space is the name space of ordinary identifiers, and since there is no struct scope in C, their scope is the scope in which the struct declaration appears:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5a2ac59cc1ae8f5f6a004185b87a1191bb07cb" translate="yes" xml:space="preserve">
          <source>Unlike in C++, the declarators &lt;code&gt;f()&lt;/code&gt; and &lt;code&gt;f(void)&lt;/code&gt; have different meaning: the declarator &lt;code&gt;f(void)&lt;/code&gt; is a new-style (prototype) declarator that declares a function that takes no parameters. The declarator &lt;code&gt;f()&lt;/code&gt; is an old-style (K&amp;amp;R) declarator that declares a function that takes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e51c28a36bb5692baf427b5a9efad5cb27763c" translate="yes" xml:space="preserve">
          <source>Unlike in a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;, the parameter list may be inherited from a typedef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad19b0dd608c2e4f48c9ccaf5ff2ce720f3cee01" translate="yes" xml:space="preserve">
          <source>Unlike integers, not every floating value can be represented directly by decimal or even hexadecimal constant syntax: macros &lt;a href=&quot;../numeric/math/nan&quot;&gt;NAN&lt;/a&gt; and &lt;a href=&quot;../numeric/math/infinity&quot;&gt;INFINITY&lt;/a&gt; as well as functions such as &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; offer ways to generate those special values. Note that &lt;code&gt;0x1.FFFFFEp128f&lt;/code&gt;, which might appear to be an IEEE float NaN, in fact overflows to an infinity in that format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ccd347acbb0fdbbb094496aea02f3e7e062a71" translate="yes" xml:space="preserve">
          <source>Unlike most bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06aee15412aa0900def31255838a5e2cad48a89e" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550d0e8f0b2b95fd2ac25cd6e94e1fb04406548e" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is &lt;code&gt;qsort_s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d3f5c043019688f561e38eab05f0332818d6f4" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is &lt;code&gt;bsearch_s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984a93ca0ecf9fa1964f4d81ad49bb3ad5b9d8cf" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;storage_duration&quot;&gt;extern&lt;/a&gt; declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1d42fef2cdf2c3dc389a3d7fa95ed1b3f519b3" translate="yes" xml:space="preserve">
          <source>Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a515ca56a7b59ccaaa0047994f7aaf01c66be46c" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6106cd24d3eb45fe60ce901f8033bf3f6920c45" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72090771977fd06391926398abf4a074c68cada" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;bsearch_s&lt;/code&gt;, users of &lt;code&gt;bsearch&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6714c3477fc3d9e9c5f8289c7130549e931d78ed" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;qsort_s&lt;/code&gt;, users of &lt;code&gt;qsort&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4775c7ec33060fa8ab3b09a08a0e950ff95cd91b" translate="yes" xml:space="preserve">
          <source>Until C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9655f2afef6652d4bb5e5cdc7b77f082cd7603dd" translate="yes" xml:space="preserve">
          <source>Until C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;ldiv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8694ee78b82e3c86eff19bc94b95dd11e5aef085" translate="yes" xml:space="preserve">
          <source>Until standardized as &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name &lt;code&gt;CLK_TCK&lt;/code&gt;: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with &lt;code&gt;_SC_CLK_TCK&lt;/code&gt;, which gives number of clocks per second for the function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times()&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89113dfc8c9140feeca3a6303fca59eb658148" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-&lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fdbe5f2786a81f9155555038f8f7073977bb9a" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;wc&lt;/code&gt; or unmodified &lt;code&gt;wc&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a274cde92cd914ce94247b07c6f39a38fa46a4" translate="yes" xml:space="preserve">
          <source>Usage patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7806efb19f32242dcbb9bc5ad35692f5e2036028" translate="yes" xml:space="preserve">
          <source>Used as a shorter equivalent of &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb04de0c41b2213edcba796ec880d9c69993d1a3" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fd08578221610e26a4e01b9e26db5ba6dd2586" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed only if some condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1036c46b05784fbc159479e3e12914f6c0a3dc61" translate="yes" xml:space="preserve">
          <source>Used where one or several out of many branches of code need to be executed according to an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817c84df09ec7c700161033133b1b1abc3ba7ae7" translate="yes" xml:space="preserve">
          <source>Uses of volatile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4466cb0f0bd2e7e6b18e73876fb3869a2080fc6d" translate="yes" xml:space="preserve">
          <source>Usual arithmetic conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268e0f35a1a78a980e701fb4508175cad117353e" translate="yes" xml:space="preserve">
          <source>VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6366acbba5e8e95bc0cae7ccba336b43ea8e9f5e" translate="yes" xml:space="preserve">
          <source>Variable arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5bf7a8e6972b2c8450b8b839e8d800d7313ad1" translate="yes" xml:space="preserve">
          <source>Variable-length arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1967c897d235fbf77628efaec62c3448c89e2dfc" translate="yes" xml:space="preserve">
          <source>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as &quot;variably-modified types&quot; (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cfadcd9fc8de8f2c49c35c4acd3c1d59f3d7ba" translate="yes" xml:space="preserve">
          <source>Variably-modified types cannot be members of structs or unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e170f0844bb573f925b5d4be5d7e11b8f4fb62" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;) which take a variable number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4932fa91d3f1b70f0c1d88911a981d4f9befca2" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions that may be called with different number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6478ed6591675d0474d581d305bfaf13be93f411" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with the identifier to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60259716427bec2d4678682eccad9fa820f8bb67" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with identifier to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459f3e0733d6888e3e209b8bb7e51c8223f8fd00" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; type, the initializer must be either a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt; (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa50f94c71d27a1f5893686568c6c5949625b9d7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;, the initializer must be a single expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cf5af2f39d3cc2baf225fdca0f325b4a6eeec7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af346b85b4a3c47e96376bfa441357b9915299c0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not &lt;a href=&quot;../language/compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: &lt;code&gt;float &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt;(fc)&lt;/code&gt; or &lt;code&gt;double &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; dc; double d; &lt;a href=&quot;math/fmax&quot;&gt;fmax&lt;/a&gt;(dc, d)&lt;/code&gt; are examples of undefined behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4811bf90215855de12be0a426e5fdd66ceff8757" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2d9b5843b2b14f889c96a5ed077d795aec2e22" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; is encountered in a C program, a lookup is performed to locate the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced that identifier and that is currently &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt;. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89dee51109e2fa03d1d15f4098f1b184fdd3f34" translate="yes" xml:space="preserve">
          <source>When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified)(since C99), and each subsequent initializer without a designator (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ca42c383f5f0e2bd3033657dc8530a9eba5d3b" translate="yes" xml:space="preserve">
          <source>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: &lt;code&gt;int f(int a[2])&lt;/code&gt; and &lt;code&gt;int f(int* a)&lt;/code&gt; declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cc939c2091fa611fac1f51ee6f986940b00b89" translate="yes" xml:space="preserve">
          <source>When an expression is used in the context where a value of a different type is expected,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c83a5d985c2238792f08da0fa782f6fc397cae6" translate="yes" xml:space="preserve">
          <source>When applied to an operand that has &lt;a href=&quot;struct&quot;&gt;structure&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the result is the total number of bytes in such an object, including internal and trailing padding. The trailing padding is such that if the object were an element of an array, the alignment requirement of the next element of this array would be satisfied, in other words, sizeof(T) returns the size of an element of a T[] array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc704db980837263518025b9214e71556fed57f0" translate="yes" xml:space="preserve">
          <source>When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec13aa43d382edec81c71f93b1f833341dd32db6" translate="yes" xml:space="preserve">
          <source>When designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ec0511a34972ef6c3100af3407ac58d0149968" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e4620e60947af9c0a473fb0a8baeabfee382e6" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3a780fd7c8398e52211c025dc25e8366b96122" translate="yes" xml:space="preserve">
          <source>When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6349ec69327a41a7f34afff23548abbfde4de09e" translate="yes" xml:space="preserve">
          <source>When initializing an atomic variable, any concurrent access, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db3e8dc56995aba80c1b48bd4c3d6ff9b4e8eb7" translate="yes" xml:space="preserve">
          <source>When initializing an object of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, every expression in the initializer must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; or &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fade3dd9c6dd385455b642a26cd93ce6d453eb8" translate="yes" xml:space="preserve">
          <source>When initializing objects of floating-point type, all computations for the objects with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are done as-if at execution time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt;; floating-point errors are reported as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;. For objects of static and thread-local storage duration, computations are done as-if at compile time, and no exceptions are raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa8650712efe659cc0dd0339ead9630668b0570" translate="yes" xml:space="preserve">
          <source>When multiple alignas specifiers appear in the same declaration, the strictest one is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1fe3bbe944df7601e6e76ed048cf63122a0a2d" translate="yes" xml:space="preserve">
          <source>When objects of &lt;a href=&quot;arithmetic_types#Integer_types&quot;&gt;integer types&lt;/a&gt; (short, int, long, long long) occupy multiple bytes, the use of those bytes is implementation-defined, but the two dominant implementations are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fcdf6257c6f5b63f77499931a12401e55fd130" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression &lt;code&gt;*p++&lt;/code&gt; is parsed as &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd54443661e6fdf7c87f18bb32eddd2dd26a027" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;&lt;a href=&quot;mtx_init&quot;&gt;mtx_init&lt;/a&gt;&lt;/code&gt;, identifies the type of a mutex to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72802fb982f6c1ad80ec2312e0bb0f8ad1c000e" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682985610ed3813bc3f241e4a1e4f302bb45d4c6" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fab87f570b0cb58044fb50de98b795acaec288" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, character constants may be interpreted in terms of the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf6e07c969001d8800b90077c7110e069a53418" translate="yes" xml:space="preserve">
          <source>When used in a declaration, the declared object will have its &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; set to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc35db4c35982640cd7a0636a9c639111c104e41" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fopen_s&lt;/code&gt; or &lt;code&gt;freopen_s&lt;/code&gt;, file access permissions for any file created with &quot;w&quot; or &quot;a&quot; prevents other users from accessing it. File access mode flag &lt;code&gt;&quot;u&quot;&lt;/code&gt; can optionally be prepended to any specifier that begins with &quot;w&quot; or &quot;a&quot;, to enable the default &lt;code&gt;fopen&lt;/code&gt; permissions. (C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e95324a6a7f1f1327a0ab19897537cb091cc4e8" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452f408de6a7cd8281856de8e1f092cf8d55601a" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memmove&lt;/code&gt; may be used to convert the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21adf3b284d45513b5e5712dbeaf87c035585467" translate="yes" xml:space="preserve">
          <source>Where the significand has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f62a551f15ff9c032031f756f94d148b497948" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01eb3e966dcce36b733ea8791c56e49db1a6416a" translate="yes" xml:space="preserve">
          <source>Whether a bit field can straddle an allocation unit boundary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee54caa15a743254b67ada9f78d6f5a91a66fe21" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf5c52a70df7191bd2b181d0777b7c9622b6038" translate="yes" xml:space="preserve">
          <source>Whether bit fields of type &lt;code&gt;int&lt;/code&gt; are treated as signed or unsigned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feffb1ebd739adca8c1acd723648ceb50bfb3246" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fd7a2e9a399af45240637c0eda092aecfbc9a0" translate="yes" xml:space="preserve">
          <source>Whether types other than int, signed int, unsigned int, and _Bool are permitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7259a07c162a5980a03092d887024ac563145697" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;fprintf&quot;&gt;snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's snwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c61c737d0b53e6e2f5ec4314c3a6438910987b" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ed0c5da0ad503c6f172f824d7c17ff8675a795" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) to its wide character equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859458ff8d7a2c1367626ec3e6f5fe580dc0d8be" translate="yes" xml:space="preserve">
          <source>Within a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e069819f560fd884671902093491d5e9bb760b" translate="yes" xml:space="preserve">
          <source>Within a scope, an identifier may designate more than one entity only if the entities are in different &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f799cd56e5a2e4e20f4f65e7ce12eb8f9226308" translate="yes" xml:space="preserve">
          <source>Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c312de86feff370bca491c752177547a6ed543f3" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/volatile&quot;&gt;volatile lvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969826a89b84b4e4d551c53334e30be5ab3cd356" translate="yes" xml:space="preserve">
          <source>Within every function-body, the special predefined variable &lt;code&gt;__func__&lt;/code&gt; with block scope and static storage duration is available, as if defined immediately after the opening brace by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8023499cb58c4c109815a2d79ac5650829ddeda6" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../variadic&quot;&gt;&amp;lt;stdarg.h&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703acf324f8116b8c498a56c14125e1a93f6ae46" translate="yes" xml:space="preserve">
          <source>Within the function body, every parameter is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression, they have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fbad2db57b58d46114fa10a3190f7deba0831b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;count&lt;/code&gt; of objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5869a84e9848e943c8c5fd069a261d745ada80d5" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro and evaluate &lt;code&gt;stream&lt;/code&gt; more than once, so the corresponding argument should never be an expression with side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f81c0bcaf9b63cee02a0581c7178cf0890849f" translate="yes" xml:space="preserve">
          <source>Writes an implementation-defined message to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; which must include the string pointed to by &lt;code&gt;msg&lt;/code&gt; and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fbd50411d6315927f25422863e722e33834996" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;stdout&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b38a38e83b8d315adcafdff09da46681f69740a" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28d781181727277b71446dfb72cdeed8c73d3e4" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8152a5497cccb550fed6c13df95ac1947ae757e7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal, or if count is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431ba1f7d46a244cebe6c0d684ca1e39d75e6ab0" translate="yes" xml:space="preserve">
          <source>Zero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of &lt;a href=&quot;struct&quot;&gt;flexible array members&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb3417ca91352ca5e5ad839596b7b62a28b6c17" translate="yes" xml:space="preserve">
          <source>_Alignas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7008bc87a6929c330fb4f709f0a2e6b754d59c3" translate="yes" xml:space="preserve">
          <source>_Alignas specifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda6adb87ec6691221ed73213de332b2c9474ce6" translate="yes" xml:space="preserve">
          <source>_Alignof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ddc52003557bd694ed510e05d8ffa47bfc7849" translate="yes" xml:space="preserve">
          <source>_Alignof operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048effd77189bf393076ca1fcf73e53aaeff6d6d" translate="yes" xml:space="preserve">
          <source>_Atomic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd5f76b0997fbede5e7b3a7dad72c9e8f31308b" translate="yes" xml:space="preserve">
          <source>_Bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20ed3009ec2e03e51793cfd518f6e77ee0fc814" translate="yes" xml:space="preserve">
          <source>_Complex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403449942a1d68cb22e3a2df541b687d5192f4f7" translate="yes" xml:space="preserve">
          <source>_Complex_I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa07fc2f45d73e6843828483db383cbb81e135c" translate="yes" xml:space="preserve">
          <source>_Generic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81882d762d1caccc4812c0eaa31886b66e6d1d9" translate="yes" xml:space="preserve">
          <source>_Imaginary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28c3530ddb62124dba16492b0964cb3e6186e5a" translate="yes" xml:space="preserve">
          <source>_Imaginary_I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb8ccf25fe4c28454012c03785eb57ded7283e7" translate="yes" xml:space="preserve">
          <source>_Noreturn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef06032cc9ad497cbe9512a26000e41f2e236bf4" translate="yes" xml:space="preserve">
          <source>_Noreturn function specifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfa477ead56b2c88345b8173962b5f15db933a3" translate="yes" xml:space="preserve">
          <source>_Static_assert</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b796d6cb075e66b2fec2b6e79a80b0ede26d4cd1" translate="yes" xml:space="preserve">
          <source>_Thread_local</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d131d3c4073efb4f54ca94b64fdf5ebf0001ec" translate="yes" xml:space="preserve">
          <source>__STDC_ANALYZABLE__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b62494894b2be9bf94a226b2a93df702d06518d" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559_COMPLEX__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0d02915700fe3497cf0ffb2cb5539415b60c57" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffa704ce725aadaecae2a04eb767b6de640c9ec" translate="yes" xml:space="preserve">
          <source>__STDC_LIB_EXT1__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7e5fe991a21e7e3d1f456399d4028544f5c6da" translate="yes" xml:space="preserve">
          <source>__STDC_NO_ATOMICS__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff500cb34558d344640792adb24dac70e376b23d" translate="yes" xml:space="preserve">
          <source>__STDC_NO_COMPLEX__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae78398cf4324ce5250a638c6222cfae5fcbd1ec" translate="yes" xml:space="preserve">
          <source>__STDC_NO_THREADS__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8004a029922d7533c64a5198c26202855b45a447" translate="yes" xml:space="preserve">
          <source>__STDC_NO_VLA__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d36c35d5289d86c7318369c0ebda5c58db23714" translate="yes" xml:space="preserve">
          <source>__alignof_is_defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed05f3a1b388032bead330257ae7557f50fb23b8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt; specifying any complete object type or an array of unknown size, but not a VLA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf12ce76466b152fd371b60da373fcc004cd34e1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22334f752f416e871ad26a7973293f511dbb1117" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;aligned_alloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;aligned_alloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0b56ef24d3ffabf7a12df45d7bbc0049a40b25" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;calloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;calloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1dfede2161933a15a2d59057794b27ad7f32c0" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;malloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;malloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7964245d6375ae1a1b7aa7777bd609529d1b41" translate="yes" xml:space="preserve">
          <source>a call to any allocation function, including &lt;code&gt;realloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;realloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2b3caaac6f4495fa04fefe591d34d3404c9be0" translate="yes" xml:space="preserve">
          <source>a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f124f55b3ba6f47f47e94dddf3560a78205e93" translate="yes" xml:space="preserve">
          <source>a character from the basic source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e20e256d4371f9eda62db761cfe929f36364f0" translate="yes" xml:space="preserve">
          <source>a combination of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97556c5ee84f06d4c9e6e31d96e3be1f6a10cee5" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;identifier list&lt;/a&gt; to designate function parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaad00c729007943609a1f99403a9854100c7ae7" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;parameter list&lt;/a&gt; to designate function parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6273559dfdc3c5cc36c5e5eef22e8820ec4422" translate="yes" xml:space="preserve">
          <source>a list of C Standard Library header files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123d2f34da2c9eb6022f14f7a955c26bfe59be30" translate="yes" xml:space="preserve">
          <source>a name earlier introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0504278be6e31ecdf6a05b32909135da1f2b6e21" translate="yes" xml:space="preserve">
          <source>a non-character value of type wint_t used to indicate errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc9f3ea46b0a8a1ead292f1ee45735eb0a6f74f" translate="yes" xml:space="preserve">
          <source>a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2683ca29bdfef4cfd8048b11187a792b0ee2e2e2" translate="yes" xml:space="preserve">
          <source>a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642ef2320577c98feaf2f935169ad215e1202ed9" translate="yes" xml:space="preserve">
          <source>a positive integer value if the first argument is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ce867551f081be316dd4eace049a5f95b2fe17" translate="yes" xml:space="preserve">
          <source>a positive value of type errno_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492a0055d77ea0e7979cf99d3b9100bf9e6853bf" translate="yes" xml:space="preserve">
          <source>a sequence of digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092e5d5910cd24daae23118a07aa91b2b252f93d" translate="yes" xml:space="preserve">
          <source>a store in one thread becomes a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425bf9812e28d908720f162b8a9d1517a6cc2c8d" translate="yes" xml:space="preserve">
          <source>a string used to indicate negative monetary quantity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757d7a97b6240cce0f9fe837451991e14db0783e" translate="yes" xml:space="preserve">
          <source>a string used to indicate non-negative monetary quantity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9575d67efdbcb362fb37d3399a2d1499fafcd8" translate="yes" xml:space="preserve">
          <source>a string whose elements indicate the sizes of digit groups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f858a6b266d4e30454cc89ef983dd5a2590b03ee" translate="yes" xml:space="preserve">
          <source>a type with alignment requirement as great as any other scalar type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18069b9a8678c1f8291708c89d8b9c4d0252afe5" translate="yes" xml:space="preserve">
          <source>a typedef for the same type as &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, used to self-document functions that range-check their parameters at runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f017c999f517934019ede8a1bf4373b242d073" translate="yes" xml:space="preserve">
          <source>a typedef for the type &lt;code&gt;int&lt;/code&gt;, used to self-document functions that return &lt;code&gt;&lt;a href=&quot;error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407f7616399e225a63ca52c79ae317571cf373f3" translate="yes" xml:space="preserve">
          <source>a typedef of the function pointer type &lt;code&gt;int(*)(void*)&lt;/code&gt;, used by &lt;code&gt;&lt;a href=&quot;thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7533040d36d9a8ffca93129287587122b0c1b376" translate="yes" xml:space="preserve">
          <source>a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f70cb2bc562eb0488f01aebc9ebd032140296e" translate="yes" xml:space="preserve">
          <source>a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57ad183139e2466db24858c2f6b437736f099b1" translate="yes" xml:space="preserve">
          <source>a) expanding or contracting the existing area pointed to by &lt;code&gt;ptr&lt;/code&gt;, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848db1c7f35ec7d54618e653c42ac58dc864e10f" translate="yes" xml:space="preserve">
          <source>a) header names: &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;myfile.h&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00aadd58815891ba18ffc68b4e53f080f7c07a" translate="yes" xml:space="preserve">
          <source>abnormal termination condition, as is e.g. initiated by &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97de44dce82a940a13b9f4994b57f07a99108566" translate="yes" xml:space="preserve">
          <source>abort callback for the bounds-checked functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f904e02a1a8fcc03536537b036685a2c755fb46c" translate="yes" xml:space="preserve">
          <source>abort_handler_s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7923a997e5ef7f7635917efd7303a93b2c10c23a" translate="yes" xml:space="preserve">
          <source>aborts the program if the user-specified condition is not &lt;code&gt;true&lt;/code&gt;. May be disabled for release builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164bfc66d0623cf4e44cafa362512a824d7e8d82" translate="yes" xml:space="preserve">
          <source>above is a property of every &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; and is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5094c70ca393f26707dd39d316fccaaf5f18c594" translate="yes" xml:space="preserve">
          <source>abs, labs, llabs, imaxabs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b198eb4b50fdd6b5832a36287b1acdc5b1c03d47" translate="yes" xml:space="preserve">
          <source>abslabsllabs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a8e3d6209d1f620f09754c72b881fd910c1f0c" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; pointed to by &lt;b&gt;a&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77e10629f557a3bc65645a9ca4c3a8bf8fd7940" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;&lt;b&gt;a&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2d225128f456bf497712bea851d5e0ab2b7e6c" translate="yes" xml:space="preserve">
          <source>access the &lt;b&gt;b&lt;/b&gt;th element of array &lt;b&gt;a&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6cc7542529dd7354ae281d8012983cdc5fce31" translate="yes" xml:space="preserve">
          <source>access to an object outside of its &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; (e.g. through a dangling pointer)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4e35cb551b39ac5df3d0f5c072966de7e0bc5c" translate="yes" xml:space="preserve">
          <source>access to the list of environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c24822cdeb7c5c6b787dbc0cfccf8c9b4d0844f" translate="yes" xml:space="preserve">
          <source>accesses the next variadic function argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328f0742cf74e8ffdb253376b1803615055e215b" translate="yes" xml:space="preserve">
          <source>acos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147d0b37b30b50556b9e55d6a8ce932951fad569" translate="yes" xml:space="preserve">
          <source>acos(z), or simply i acos(z) in the upper half of the complex plane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6845fe659bed6637eedb661a4b4fda8a803d03" translate="yes" xml:space="preserve">
          <source>acos, acosf, acosl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7065e6c51c4483cfded5cc061fbccd9a93bc104c" translate="yes" xml:space="preserve">
          <source>acosacosfacosl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df0277ec86f188e0c797c5782ceb42dc25bb36a" translate="yes" xml:space="preserve">
          <source>acosh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589a4621c7cf6dcff6a469151b23cd30ce08cce9" translate="yes" xml:space="preserve">
          <source>acosh, acoshf, acoshl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1824220df1c196fec7eafe8955123ab045039cc2" translate="yes" xml:space="preserve">
          <source>acoshacoshfacoshl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90390361d9b0316110b5eee0023ea52e6598545" translate="yes" xml:space="preserve">
          <source>acoshl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304e4d7ae71d38f68561c83b5cdefd5c197713fc" translate="yes" xml:space="preserve">
          <source>acosl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c52002b743e4db150df31d4c92e7f8849bd4395" translate="yes" xml:space="preserve">
          <source>acquire operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef76fa8e24cfa0361d135d67b2541d876650e36" translate="yes" xml:space="preserve">
          <source>acquiring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea3777754d6be1f3458ef90dda1cf54a1ddb440" translate="yes" xml:space="preserve">
          <source>addition assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feccbd79efdd23843e4995d7af810032b227dbbc" translate="yes" xml:space="preserve">
          <source>additional information (e.g., collating sequence), passed to &lt;code&gt;comp&lt;/code&gt; as the third argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d50eddef9262e79d2047b13e4d6d3daf024d3ec" translate="yes" xml:space="preserve">
          <source>additionally, if they are enumerations, corresponding members must also have the same values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3241e56e78b25a62f11b23b96ec570f0735ce1d" translate="yes" xml:space="preserve">
          <source>additionally, if they are structures or unions,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556049da8cc10fac75ab14efc978eeeeb3ea2692" translate="yes" xml:space="preserve">
          <source>address constant expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c17e45ca56ec6ed4a705f824c8aca1c8f4e8e77" translate="yes" xml:space="preserve">
          <source>address of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4457c5c7ef8ebc7b3a1f299072c7fb0729c67a6a" translate="yes" xml:space="preserve">
          <source>aggregate types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062f903e7a5b5fa5dd018873a2aa70adfb2020bd" translate="yes" xml:space="preserve">
          <source>alignas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d80ec85b39f8b9faf623f44b5b53e8f41051306" translate="yes" xml:space="preserve">
          <source>aligned_alloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dfeae5db3ff37e5e9f1f43350a95604f04689b" translate="yes" xml:space="preserve">
          <source>alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5e5f751184b7bff89789dac0da42a54bbc4cb6" translate="yes" xml:space="preserve">
          <source>alignment requirement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0a9a63b400f56ea64f1dc5c76adcfc41fa151d" translate="yes" xml:space="preserve">
          <source>alignment requirement (can be determined by &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;)(since C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867318e23a3e63655204aafd2975563685ee0462" translate="yes" xml:space="preserve">
          <source>alignof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7c1609043c1941c605866ab35e26dad2ab85fc" translate="yes" xml:space="preserve">
          <source>all C streams are flushed and closed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4172a5a7b30962538b9ec831d1b1de58d48654" translate="yes" xml:space="preserve">
          <source>all arithmetic, relational, logical, and bitwise operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb708b79dfd7d3f13e68022e4110062dda87cf2" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3353ab95ebb14131e875c614b1df72dfe1c566c" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;long double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977083d5e09600da9c4eccd257809269b4c94c59" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of the type used. Additionally, &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7780d84b84c9142aa89e31966605e1441d783bee" translate="yes" xml:space="preserve">
          <source>all operators not specified to return lvalues, including</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68630f1665f7e74a806f82115917b348ff54806d" translate="yes" xml:space="preserve">
          <source>all other pointer comparisons invoke undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400375aeabf668f2340ea3b379d803b6b8b255fe" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb337ce8a028a4cee827132b68f54b4907c60e86" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string up to specified size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3e8f3c8913ee0556612ac56f1100bdc54d4b6b" translate="yes" xml:space="preserve">
          <source>allocates aligned memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8454d15e4c9c8e6f3a57a97cf499f9a12a5b9c45" translate="yes" xml:space="preserve">
          <source>allocates and zeroes memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a8fad17819140ae5245db5e27c1653353c978b" translate="yes" xml:space="preserve">
          <source>allocates memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a0b05ea8f965ae4bee50cde10d4c446a1e3b17" translate="yes" xml:space="preserve">
          <source>allowed). The permitted implicit conversions remain implicit conversions as if by assignment since that's what &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; also uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fc2642d89ce1e097c263a684eb5a024daeebb1" translate="yes" xml:space="preserve">
          <source>already exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66468d63e91e596a97d876019fbaff6d95089c8" translate="yes" xml:space="preserve">
          <source>alternative form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8af47c361b758726325c4a5d8f6d520db8f84f6" translate="yes" xml:space="preserve">
          <source>alternative implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3889426121edfa53717bdb3ef97045d05ffc26" translate="yes" xml:space="preserve">
          <source>alternative representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd1a6dc80c5ec13ed0bab7c3efae29474bb9c3c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of any pointer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcaeef60c578753f96c537b6021c9f8ba0f4005" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of integer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c63cd915fa58503257713ad4a99a2388d7cf0c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of type pointer to complete object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffd31cdd3fc478fb8aa298268d403b7671713aa" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union designated by expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c770b10bd3283310dfe735741609cc3e6a12bf2a" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union pointed by expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26834c673eb6eae28680be23c0c387a56f2be791" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression of any type that is not a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; and does not have &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; storage class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d25a5eab78f6eda49ce05aa4731693cd80db5ed" translate="yes" xml:space="preserve">
          <source>an expression of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ca9f074bef452e68d74671c6b7e41ad6718dbe" translate="yes" xml:space="preserve">
          <source>an expression of any &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e482a6714eaafb0e24be84f63888929f38a20ed1" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5091785e0504e641a8e3af5496c6028197b862f" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs compares equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30acc345d35d3998440b6088bf19963caa6a35" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs does not compare equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2daf35100d05a24b08066e28b51c0c00f1cce17" translate="yes" xml:space="preserve">
          <source>an expression of scalar type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1466d8b4e35f4f83ca75b50de808d2ca1cce841e" translate="yes" xml:space="preserve">
          <source>an expression of type &lt;a href=&quot;pointer&quot;&gt;pointer&lt;/a&gt; to &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a67874112f3e299e468f90df2277215d12f553a" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86abb14241dbb7db0bb13b74e8edde69e450c9e5" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to clean up</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e295867a522c67c41499b0529da42173f1d4c0" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to initialize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9512a3c405db5a107feba3b473178c36d74968" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;constant expression&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51b1b56486d192e084f8901036bb0c35812c943" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bit fields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b382c31b00d864a5cbeb230e9e1412baa05f78a4" translate="yes" xml:space="preserve">
          <source>an integer constant expression with the value 0 &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;cast to the type&lt;/a&gt;&lt;code&gt;void*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b08993b08f9159ab8acc22acd5919bddd34e9c0" translate="yes" xml:space="preserve">
          <source>an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (arithmetic type, pointer type, enumeration type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc8d05fff2d4a9fdbb558a1197ea598e431dfb8" translate="yes" xml:space="preserve">
          <source>an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dde5d5482f9f390a32371e3f89da7b3284eda61" translate="yes" xml:space="preserve">
          <source>an operation B that modifies M, then A appears earlier than B in the modification order of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f3ea1263fe354b1a1abaea9c1143c043077794" translate="yes" xml:space="preserve">
          <source>and a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e2a753ba36c7df2d9c9572a980d973b1fb8650" translate="yes" xml:space="preserve">
          <source>and is only available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined. The following macros and functions support this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fd560f32f29d04963d416d75047a6cfeb92dbe" translate="yes" xml:space="preserve">
          <source>and may not be declared in a program (doing so invokes undefined behavior):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5c1ef50816d102d59e8dddcc9ac547607b50fd" translate="yes" xml:space="preserve">
          <source>and selects the subobject to be initialized within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93345ebb64aeba932c32ab7d854638997d5ef19" translate="yes" xml:space="preserve">
          <source>and the standard library provides one definition of this constant as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd29300b85768a1234d6f664159b64c48c91452" translate="yes" xml:space="preserve">
          <source>and their</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0416aa14d74afde308590f0e07546abbf5c866" translate="yes" xml:space="preserve">
          <source>and.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba2da8434660e3c85122283402e6dd020f0ee9" translate="yes" xml:space="preserve">
          <source>anonymous struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a011b32fef63606811d73e091cc0b24ee0357f" translate="yes" xml:space="preserve">
          <source>anonymous union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6794e2c132cc20741c7a6f05c99a28077f81c0" translate="yes" xml:space="preserve">
          <source>another (see &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809318b0f32018415dfddab521f3e13842ec38e4" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;../string/byte&quot;&gt;string&lt;/a&gt; or &lt;a href=&quot;../string/wide&quot;&gt;wide string&lt;/a&gt; library function accesses an array out of bounds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548db24dda99e960bd75dbe694826c0574978efb" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0567d76c391930bf6159349a1feb7c3e0f6b493" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86de59cb451b567943008ac77b5019b11450cd9" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt; whose value is a valid &lt;a href=&quot;object#Alignment&quot;&gt;alignment&lt;/a&gt; or zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6240ff52b9d414b02e19da67fc0afce850b89a7c" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b874c873f2146b6463b682d297176c153f579b" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;integer type&lt;/a&gt; (char, signed or unsigned integer, or enumeration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8381985b79c4f4f883852f84f08e64e5da8fc7" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (unless type-name is void, in which case it can be anything)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f41d2a748f820ab4b0d60d234ee6447b5c7b2a" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274e302869fbb27c30f2b86fea297b58e8fe8144" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289a2cbed49e869ef41824f6c67f9fe6d378b421" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt; (typically a compound statement). &lt;code&gt;case:&lt;/code&gt; and &lt;code&gt;default:&lt;/code&gt; labels are permitted in statement, and &lt;code&gt;break;&lt;/code&gt; statement has special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8f57a6fc50c3b928eca64028a6f3e218dfa5cd" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which is the body of the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6160f2d70f309150cc39956b7333bdabe9e3c566" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which serves as the body of the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f530d35571677a796141f3d891df4b848b98e2" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a06491365351f3135fa57adca77cdbb5bb55da" translate="yes" xml:space="preserve">
          <source>any cast expression (note that compound literals, which look similar, are lvalues)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf8667431a1e779cde6bdce47ba00aaaafd8be3" translate="yes" xml:space="preserve">
          <source>any combination of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe45f6357925029ecee21a95f05d973c784b3fa" translate="yes" xml:space="preserve">
          <source>any complete &lt;a href=&quot;compatible_type&quot;&gt;object type&lt;/a&gt; that isn't variably-modified (that is, not VLA or pointer to VLA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d364f2a845a6f4b4da77a65cd5239650881109ee" translate="yes" xml:space="preserve">
          <source>any expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efae355cfebbfc312e651b7bece35ca4f1afee8f" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) of any type and value category</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4266fde639a4ad2a2c6e4530bc1873de5bec3c9" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) whose type must be compatible with one of the type-names if the &lt;code&gt;default&lt;/code&gt; association is not used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae479c7422b7687a645ec839ada30bfea7332b70" translate="yes" xml:space="preserve">
          <source>any expression of pointer-to-function type (after &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baffd80eccda4b18e67a2afbc7b772a872267bab" translate="yes" xml:space="preserve">
          <source>any expression other than &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;, designates the number of elements in the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84440a43394480ce95b6f58815357f35ade0d15" translate="yes" xml:space="preserve">
          <source>any expression other than another comma operator (in other words, comma operator's &lt;a href=&quot;operator_precedence&quot;&gt;associativity&lt;/a&gt; is left-to-right)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed48d916d76a9379a8f2ebc1afbce301f417fd2" translate="yes" xml:space="preserve">
          <source>any function call expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0848b3f1b7b548a5a86bee48ad1b2613e0ed23f" translate="yes" xml:space="preserve">
          <source>any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: &lt;code&gt;int f(&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;uintptr_t&lt;/a&gt;)&lt;/code&gt; is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named &quot;size_t&quot; and &quot;uintptr_t&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faab3a1343209dbb605e46853e2150f406236f5f" translate="yes" xml:space="preserve">
          <source>any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a42a9b8586a31a43c72b8b3bf40ccd35bf216d0" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; declarations, and &lt;a href=&quot;static_assert&quot;&gt;static assert&lt;/a&gt; declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6a297d6eb7cf8a88b76ca1cdba0c369a078b9a" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991db7190ce90937e5272c02ff09f8c835ed6bb6" translate="yes" xml:space="preserve">
          <source>any of the arguments corresponding to &lt;code&gt;%s&lt;/code&gt; is a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9761fa8c99d6412896030019b9e1f7238a8ecc1" translate="yes" xml:space="preserve">
          <source>any of the arguments of pointer type is a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c931b47c239c4cdb5b5676505bab2ff58278d90b" translate="yes" xml:space="preserve">
          <source>any other expression that may be accepted by the currently installed C &lt;code&gt;locale&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee46d10ed7aeb7823d65780e2d60186ac6dbd911" translate="yes" xml:space="preserve">
          <source>any parameter of array type is adjusted to the corresponding pointer type, which may be qualified if there are qualifiers between the square brackets of the array declarator(since C99)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9616ae7c6d96ecd7803690f307d2d3795f91f219" translate="yes" xml:space="preserve">
          <source>any parameter of function type is adjusted to the corresponding pointer type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da817154a673bbb68947705f741c46db2b6e0eb1" translate="yes" xml:space="preserve">
          <source>any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831fce60a83f5aaa718757021717e0ba1f826a53" translate="yes" xml:space="preserve">
          <source>any use of the pointer that was deallocated by &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac78b022715c5b8357b4dca8045e8463b4de2124" translate="yes" xml:space="preserve">
          <source>ap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfbd9f07437718b73115a6a0356598c7d27a84a" translate="yes" xml:space="preserve">
          <source>append extended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea4e18dac8b6b256584c24f08f1c66e6c79b375" translate="yes" xml:space="preserve">
          <source>appends a certain amount of wide characters from one wide string to another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1975c46fbfd68df17ca6344eed23e3a6512c750c" translate="yes" xml:space="preserve">
          <source>appends a copy of one wide string to another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df903074f885f1f15c3daa6ce45002105c249232" translate="yes" xml:space="preserve">
          <source>arbitrary hexadecimal value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4369a0f24ae39fbe536286ba71dd880472aa2770" translate="yes" xml:space="preserve">
          <source>arbitrary octal value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e52a50224511e55b3cb5a078473fdd0e08a5b1e" translate="yes" xml:space="preserve">
          <source>arg-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7228e374c9c5c17ac8a45e24698a76423635ad" translate="yes" xml:space="preserve">
          <source>argc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846a4bbd93bdd85706d5de7416afac88a45f8ae8" translate="yes" xml:space="preserve">
          <source>argument list in a function call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d12281d0d35ef85c73f95929507c005a2287e93" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from beginning of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72786d66722ca4b98208afbe41b8eb11812480a7" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from end of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32b6d5580bb50f023a54f00203dfa3201f6ec89" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from the current file position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8716aaf8f6527ddb092f5a0c7a3b4f6d8fb6e3" translate="yes" xml:space="preserve">
          <source>argument to pass to the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bea05ca57a72f813079e31c799c8fa9aec7206" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating fully buffered I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb617945b0b4d913edf162e7b8270404a7289c2" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating line buffered I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7602f5fc169b6cee652722ddadfdd64b78e9e442" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating unbuffered I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb1965acdbb56f90805167da69ff708224ab176" translate="yes" xml:space="preserve">
          <source>argument-list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0f14dd3cb378d1b2fb76510dc53f503afdcc59" translate="yes" xml:space="preserve">
          <source>arguments (depends on the instruction)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2dac687442a0397e2099f1e6330fa3064360636" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded1eaca9edf12b71d324d9950a6c8f3e3d7ec9a" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fa84e333f3362a12273e855dca2caf2666100b" translate="yes" xml:space="preserve">
          <source>argv</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ca194aa0f608d645500c4f2354facbbde0a13e" translate="yes" xml:space="preserve">
          <source>arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fbc403ddb9a8535eac7d7846e5a6e72e05c26e" translate="yes" xml:space="preserve">
          <source>arithmetic constant expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90b72b26be74b12d744b60937fa2f214a9d2d22" translate="yes" xml:space="preserve">
          <source>array subscript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd3365ec5cd3b7bc71721ba577abbedc1bb1832" translate="yes" xml:space="preserve">
          <source>array type of unknown size. It can be completed by a later declaration that specifies the size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583b8fc652f8ec109f2a1271c77b0892a560a1c2" translate="yes" xml:space="preserve">
          <source>array types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5cf9e25955aafadeb0fc934da621efb22c50c4" translate="yes" xml:space="preserve">
          <source>as a single-byte subset, consisting of the following 96 characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37066ddedc42722c4e146de881569c7f636156bc" translate="yes" xml:space="preserve">
          <source>as if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e8f5522c763f7aac74293d814587b7b51ff770" translate="yes" xml:space="preserve">
          <source>as if by assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ea9d4459e813837e6b2d6170a333da47079360" translate="yes" xml:space="preserve">
          <source>as part of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d520093947381fd24996c7c477fa5ad1a40de0f" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_assignment&quot;&gt;assignment and compound assignment&lt;/a&gt; operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec04b9d73f6eba21c4562d845ad4aa147fdd3a1" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;member access&lt;/a&gt; (dot) operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32116980421df3eac0e9a887ff55708bc31c675" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ab613c21670dea20248904a5545953ef13d684" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0201522cbd2f212d3fe577bf15df3825cc8ff2" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccde22a39f66d23bee179ee345a3f26a32ed97f" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (except if the lvalue designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; or was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61981e5cabd311f63537d72c30f35aa168dcd3f1" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (if allowed)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ff5014bfefda97f58711957a14dd50eb553afd" translate="yes" xml:space="preserve">
          <source>as the operand of the pre/post &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbd39f8302a9536a17e0200de5a48a17788a7f2" translate="yes" xml:space="preserve">
          <source>as the string literal used for &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd4ec431b19760a17e098545249b59de85e86b2" translate="yes" xml:space="preserve">
          <source>as the type specifier in the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b28a347a252156b936f911d1cc72e64542d263" translate="yes" xml:space="preserve">
          <source>asctime, asctime_s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42142bd98fb9dd05c15c3597bae5919f33b72f04" translate="yes" xml:space="preserve">
          <source>asctime_s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2344ecbfe0be5e18554e8a8e920e86bed313503e" translate="yes" xml:space="preserve">
          <source>asctimeasctime_s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b3e9a1435d3f432e7a6b9003583871fcb26de3" translate="yes" xml:space="preserve">
          <source>asin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ef31809f8e6b00b30d4d5688627671939aeffb" translate="yes" xml:space="preserve">
          <source>asin(iz)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ba758985d5a60f7caa44c3627a9bdad1ebbe2c" translate="yes" xml:space="preserve">
          <source>asin, asinf, asinl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc750b867f9dc58a4f03be277005b693adb6882e" translate="yes" xml:space="preserve">
          <source>asinasinfasinl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d3dd685f3472024a78ef2982b478006acd6afc" translate="yes" xml:space="preserve">
          <source>asinh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f5c9543105e3c4710f893fe6513249d1460b35" translate="yes" xml:space="preserve">
          <source>asinh, asinhf, asinhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c992c5efc8f80141b44689f0e07c943fb9a30aa8" translate="yes" xml:space="preserve">
          <source>asinhasinhfasinhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cf2dd5233a6f36a4e6889905ffcff6691267da" translate="yes" xml:space="preserve">
          <source>asinhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64a2f83388bdb9b16130ec9cd1a83a7f7338b24" translate="yes" xml:space="preserve">
          <source>asinl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b5daad5073849378993ba34e058d7008293097" translate="yes" xml:space="preserve">
          <source>assert</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26b63d628c9b5679c54e6f8f5ee244932da2d7d" translate="yes" xml:space="preserve">
          <source>assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f494b88f97fbaa7c60689f58dce7974ecb8e3e4c" translate="yes" xml:space="preserve">
          <source>assignment and compound assignment operators (note: they are lvalues in C++)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e380389a774a586c5fa16ad6f747ccd0f5dd49" translate="yes" xml:space="preserve">
          <source>at least</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575f12d548b9fd6af3f0619c3c5f99b4dc5da351" translate="yes" xml:space="preserve">
          <source>at least 8, 16, 32 and 64 bits respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3167c14955e1f3fea9853d7148dcb75a62f7ab" translate="yes" xml:space="preserve">
          <source>at_quick_exit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f077504d04fa1bc96b042497b434fd33fabdf43d" translate="yes" xml:space="preserve">
          <source>atan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd281638c28da6a30c5b0c730c9b9ec0d88cba4c" translate="yes" xml:space="preserve">
          <source>atan(iz)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7e2494fec8f83d2e63521682db3853590fe40a" translate="yes" xml:space="preserve">
          <source>atan, atanf, atanl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a7357ef61ecd1781b4633dc3e33a383686041c" translate="yes" xml:space="preserve">
          <source>atan2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208f110d2774b4f5fad38662ea6cc831171dabd6" translate="yes" xml:space="preserve">
          <source>atan2, atan2f, atan2l</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b957cefd959bb1c4b5fdb50a314397923487008a" translate="yes" xml:space="preserve">
          <source>atan2atan2fatan2l</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02e2f7a37d63971c98216ff7f3b3373699aed5f" translate="yes" xml:space="preserve">
          <source>atan2l</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbecfd27a902ae767327ccf26fc508a471b1941" translate="yes" xml:space="preserve">
          <source>atanatanfatanl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7684baa497f7669edce3de05984655b59aa5aa40" translate="yes" xml:space="preserve">
          <source>atanh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b065796585ecb12f9248b5ff7df8c24a8b656516" translate="yes" xml:space="preserve">
          <source>atanh, atanhf, atanhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b67f8cc63e7d4d66ac6071e6d9132e68a8b95f5" translate="yes" xml:space="preserve">
          <source>atanhatanhfatanhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a1ff3103217455c2b8717c437b50d092665e93" translate="yes" xml:space="preserve">
          <source>atanhl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7beedb8b23716296e0856ec53d68f95fd1f612b5" translate="yes" xml:space="preserve">
          <source>atanl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3853b2fd4c89603fc8835e3e1228e431622c9270" translate="yes" xml:space="preserve">
          <source>atexit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6017383f8fbd1471aeeef3234b4ca0a2acb5156d" translate="yes" xml:space="preserve">
          <source>atof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8abc8e1d18caf883d0fd33d6b1b317350c0f37c" translate="yes" xml:space="preserve">
          <source>atoi, atol, atoll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ad2fc918927ced018e6fe7d948a7ec0fc7ebff" translate="yes" xml:space="preserve">
          <source>atoiatolatoll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e154f040d1ad0ab5670d0c3b9dbdf20b2124451d" translate="yes" xml:space="preserve">
          <source>atoll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20a53d0c79d0d5837445d462c94138fc6bdcc80" translate="yes" xml:space="preserve">
          <source>atomic addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e6625eb34f1cb363273fcd051629eb11f3189c" translate="yes" xml:space="preserve">
          <source>atomic bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abaebd8a55922cfeed40c417f35cf1942167bdc" translate="yes" xml:space="preserve">
          <source>atomic bitwise OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f9564609953b60799326151b1ff80328fe5b5f" translate="yes" xml:space="preserve">
          <source>atomic bitwise exclusive OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922ee459c2e6d7d2fbf1dfd8439b5ffa40fe41b9" translate="yes" xml:space="preserve">
          <source>atomic functions from &lt;a href=&quot;../atomic&quot;&gt;stdatomic.h&lt;/a&gt; if the atomic arguments are lock-free</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a9594db0c1ccde731b4b620cec456ded6b35b4" translate="yes" xml:space="preserve">
          <source>atomic subtraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054e1dc1b63cbf780ada25cf4b64c89fc6cada8b" translate="yes" xml:space="preserve">
          <source>atomic type specifier and qualifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e5e6ab0f5460b564fd920ffd02d7dda388fdc6" translate="yes" xml:space="preserve">
          <source>atomic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa17b861e9de9a72a9231f8e499e91b8c772f38" translate="yes" xml:space="preserve">
          <source>atomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34c65a17871e32c4f03bd4cf436eddd640d36e5" translate="yes" xml:space="preserve">
          <source>atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db34ceb682b293648fc0d056c6f770bba9f6b5e0" translate="yes" xml:space="preserve">
          <source>atomic_compare_exchange_weak_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90d6b5980bec459677d6fa71ca33c5288ff4f6b" translate="yes" xml:space="preserve">
          <source>atomic_exchange, atomic_exchange_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d8e1ce3b119598ae3a9088f7cd1e2a5527dbd1" translate="yes" xml:space="preserve">
          <source>atomic_exchange_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1b31c910ecb9c7bf63dd359c31e80d8d9adbbb" translate="yes" xml:space="preserve">
          <source>atomic_exchangeatomic_exchange_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d03567779ff8eee45156d7fc41c8bb771faa57" translate="yes" xml:space="preserve">
          <source>atomic_fetch_add, atomic_fetch_add_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967c1c3abb85cf70c25664b46f387839967f1be3" translate="yes" xml:space="preserve">
          <source>atomic_fetch_add_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68abb79dc9381ee4c7e2960afde1dfb67ac53f75" translate="yes" xml:space="preserve">
          <source>atomic_fetch_addatomic_fetch_add_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ad9c37b38b38955cd24b7db1d06fcb05ee9e2f" translate="yes" xml:space="preserve">
          <source>atomic_fetch_and, atomic_fetch_and_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a8b076ac8a9fcfc339c58fd4c8a5c95664f824" translate="yes" xml:space="preserve">
          <source>atomic_fetch_and_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4636325964362c389e84bf2159178c141696167c" translate="yes" xml:space="preserve">
          <source>atomic_fetch_andatomic_fetch_and_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab1192dfb6647857f96a0737d371d7f5e4c9b28" translate="yes" xml:space="preserve">
          <source>atomic_fetch_or, atomic_fetch_or_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1aefa35e2c06b82a5b03ef5e98b7631e12d5f5" translate="yes" xml:space="preserve">
          <source>atomic_fetch_or_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd45ef687560c6d955b9fbefbedf41992a0256c4" translate="yes" xml:space="preserve">
          <source>atomic_fetch_oratomic_fetch_or_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fd36c6148269982e2ae6ee6e3a62502cb8e7b5" translate="yes" xml:space="preserve">
          <source>atomic_fetch_sub, atomic_fetch_sub_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5122598174c178f346cb3f9553c9fe4df049a902" translate="yes" xml:space="preserve">
          <source>atomic_fetch_sub_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecbdc6cb974eae1bc3b6c02d656f11317e0c27d" translate="yes" xml:space="preserve">
          <source>atomic_fetch_subatomic_fetch_sub_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4e045db36871978c71c7eec67118e5c9d5edae" translate="yes" xml:space="preserve">
          <source>atomic_fetch_xor, atomic_fetch_xor_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115906f35234da4614e45544f7e7be746c46c3b6" translate="yes" xml:space="preserve">
          <source>atomic_fetch_xor_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bc1ef8c5a4d9352886923c00f8369344ab0b17" translate="yes" xml:space="preserve">
          <source>atomic_fetch_xoratomic_fetch_xor_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddeffad16e9ac220257edf816bbc4d016469eb3" translate="yes" xml:space="preserve">
          <source>atomic_flag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9891fbc6ab40d808235fd628e41dc97e47972163" translate="yes" xml:space="preserve">
          <source>atomic_flag_clear, atomic_flag_clear_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6580d5a16b61cc3b036f3c6f3f4b4b0a4c9a64" translate="yes" xml:space="preserve">
          <source>atomic_flag_clear_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15242abd00ff500da8d9b58c8238d540f3f1421e" translate="yes" xml:space="preserve">
          <source>atomic_flag_clearatomic_flag_clear_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06811f48650ae9cf616fd0b742bf80146f5bcf85" translate="yes" xml:space="preserve">
          <source>atomic_flag_test_and_set, atomic_flag_test_and_set_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40936dbbc398bb0999a8396f2e19e62ca495a38d" translate="yes" xml:space="preserve">
          <source>atomic_flag_test_and_set_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67982553a4d3dd9a3a239ebf9e4ce6a29f5c1d15" translate="yes" xml:space="preserve">
          <source>atomic_flag_test_and_setatomic_flag_test_and_set_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6857b24a822b3951d174231b03a6a5570fcbf1" translate="yes" xml:space="preserve">
          <source>atomic_init</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1d586b599c6781cec18d961a12cf0a425a7577" translate="yes" xml:space="preserve">
          <source>atomic_is_lock_free</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432d907be887a1eb919e3755e14a983059e1e9b9" translate="yes" xml:space="preserve">
          <source>atomic_load, atomic_load_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b0f9aef9fa34be962a85e2b120d6cbd54758d8" translate="yes" xml:space="preserve">
          <source>atomic_load_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38742836008ed0bfa46052fedc3cb03fb5fcecf4" translate="yes" xml:space="preserve">
          <source>atomic_loadatomic_load_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c617083c7f1960a4b352867c61f3c3b678be5ee" translate="yes" xml:space="preserve">
          <source>atomic_signal_fence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442138b9342315b802a9659b8b40d67ae40001f7" translate="yes" xml:space="preserve">
          <source>atomic_store, atomic_store_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cc646ded6e50fb06fb0d4e7f88f7bb3fa0e7b9" translate="yes" xml:space="preserve">
          <source>atomic_store_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb45ccb8f431657afb3489bd8f05a7ee55248577" translate="yes" xml:space="preserve">
          <source>atomic_storeatomic_store_explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23475947ad76f230293cc1d4cce0c2516c7c1097" translate="yes" xml:space="preserve">
          <source>atomic_thread_fence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b24477833dda3d78700670748320f0fd46b3ef" translate="yes" xml:space="preserve">
          <source>attempted modification of a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522603b2d16d4fcb35fb583158426539feeaae05" translate="yes" xml:space="preserve">
          <source>audible bell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d612c12d2ac33625bf3e0351b6f5e4f73829fa8" translate="yes" xml:space="preserve">
          <source>auto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e449aaf8257260bfd33cdce7416214b474ec24" translate="yes" xml:space="preserve">
          <source>b) 10 digit characters from &lt;code&gt;'0'&lt;/code&gt; to &lt;code&gt;'9'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7694bd09956a19773be1f55db6c3899d3488f67b" translate="yes" xml:space="preserve">
          <source>b) allocating a new memory block of size &lt;code&gt;new_size&lt;/code&gt; bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6dc2cf2705e8613dcb84993656df21b36e8a474" translate="yes" xml:space="preserve">
          <source>b)&lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220534f3eda033c64d430f6e4ce55671da55737f" translate="yes" xml:space="preserve">
          <source>backspace character (&lt;code&gt;DEL&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405df66cbe219b0bf6355bc3d60361a8376b6b4" translate="yes" xml:space="preserve">
          <source>base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae5095944849a23712ee240c82c5ac1ba328e5" translate="yes" xml:space="preserve">
          <source>base as floating point value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffcd5ebd45e9dd6f98964e7b2cf625d0c08c46d" translate="yes" xml:space="preserve">
          <source>base-n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a310ddb49917fbfe07701cd76a690cc9f5b8a193" translate="yes" xml:space="preserve">
          <source>basic assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d40a5e9938e0008f2e3b718cef0789d4c35411d" translate="yes" xml:space="preserve">
          <source>basic execution character set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea69d5b4b37d50765cdc62e3f4db263218860551" translate="yes" xml:space="preserve">
          <source>basic source character set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48c6187a9f87336229e50cc69dcb353a85ab8e3" translate="yes" xml:space="preserve">
          <source>basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19139bac30f75355c327f9cfab9edc26ecde976b" translate="yes" xml:space="preserve">
          <source>because they appear outside of any function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcea8ac245e94ad9ee2c2ec625d672da32ee1dd" translate="yes" xml:space="preserve">
          <source>beginning of the token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f8f107ec8c76b1010d16a55e6502a22b7b8cfb" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;ATOMIC_&lt;/code&gt; followed by an uppercase letter, in &lt;a href=&quot;../atomic&quot;&gt;&lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf8d23aaaf376d175f7273264caad4ef22391d" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;E&lt;/code&gt; followed by a digit or an uppercase letter, in &lt;a href=&quot;../error/errno_macros&quot;&gt;&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b44c6eba6304082761361b6fb0b60f9cbbc448" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;FE_&lt;/code&gt; followed by an uppercase letter, in &lt;a href=&quot;../numeric/fenv&quot;&gt;&lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686ea8d01af00b74392977dcde64a88d96398b93" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;INT&lt;/code&gt; or &lt;code&gt;UINT&lt;/code&gt; and ending with &lt;code&gt;_MAX&lt;/code&gt;, &lt;code&gt;_MIN&lt;/code&gt;, or &lt;code&gt;_C&lt;/code&gt;, in &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6201ec7dacb8ca599a6388ad8ab224fc05acd9ca" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;LC_&lt;/code&gt; followed by an uppercase letter, in &lt;a href=&quot;../locale/lc_categories&quot;&gt;&lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a70039810063d837291442bd92c6938c51d080" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;PRI&lt;/code&gt; or &lt;code&gt;SCN&lt;/code&gt; followed by lowercase letter or the letter &lt;code&gt;X&lt;/code&gt;, in &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2b8532c3bd0931e9c4c155d76f1f765683c31b" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;SIG&lt;/code&gt; or &lt;code&gt;SIG_&lt;/code&gt; followed by an uppercase letter, in &lt;a href=&quot;../program&quot;&gt;&lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0952ac4419045c2d7aef2570d2be05a1d65319cb" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;TIME_&lt;/code&gt; followed by an uppercase letter, in &lt;a href=&quot;../chrono/timespec_get&quot;&gt;&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8deff3c36a44985d0adc3eb3dca25a00a8ddae54" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;atomic_&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../atomic&quot;&gt;&lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2018fc9b0fda666e29f3f2cab17c737774e99f92" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;atomic_&lt;/code&gt; or &lt;code&gt;memory_&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../atomic&quot;&gt;&lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac1f726e5c37940d57653e0a9855c6c020ee2cc" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;cnd_&lt;/code&gt;, &lt;code&gt;mtx_&lt;/code&gt;, &lt;code&gt;thrd_&lt;/code&gt; or &lt;code&gt;tss_&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../thread&quot;&gt;&lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e71a52cd3b6323de5f73debdd9212f05dafb5ef" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt; and ending with &lt;code&gt;_t&lt;/code&gt;, in &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57c72907b01f941a1004b1a2470fea71e72ec5d" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../string/byte&quot;&gt;&lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../string/wide&quot;&gt;&lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a80d219d48a3aca5452db3a5181d8549cc657e" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;memory_order_&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../atomic&quot;&gt;&lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5b62f08fd624b9d342a2c3422e34c92c85281c" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;str&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../string/byte&quot;&gt;&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dd580128f5fdc92f7f0763e1a9d1cc16fad988" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;mem&lt;/code&gt; or &lt;code&gt;wcs&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../string/byte&quot;&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fb36a0fc68a5fc51e985f2e0402676269f212e" translate="yes" xml:space="preserve">
          <source>beginning with &lt;code&gt;wcs&lt;/code&gt; followed by a lowercase letter, in &lt;a href=&quot;../string/wide&quot;&gt;&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
