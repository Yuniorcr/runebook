<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="c4c7395952652d692e1ed3ecb90decbeb8d571b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt; are indistinguishable from &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; . (Win32, VMS, RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5af3fb6df5c96c8552d3c4c08384be45953ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d&lt;/code&gt; is true if passed a device spec without an explicit directory. (VMS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a340d0a2b8e44c5124e4655b8a7237da67ea42b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-u&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; are not particularly meaningful. (Win32, VMS, RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f770fc0a63e71da3b8a342413f4e20e2101d6c75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-g&lt;/code&gt; is a flag to the C compiler to have it produce debugging information which will allow us to step through a running program, and to see in which C function we are at (without the debugging information we might see only the numerical addresses of the functions, which is not very helpful).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a975a3450c1d047de8b68a1655f0a6a6ff1b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt; sets the value of Perl's &lt;code&gt;$^I&lt;/code&gt; variable, which in turn affects the behavior of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more details. By modifying the appropriate variables directly, you can get the same behavior within a larger program. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df07bafaa229b3f5f804e2d15db5243976c6a78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-mode&lt;/code&gt; is a synonym for &lt;code&gt;mode&lt;/code&gt; . &lt;code&gt;-recsep&lt;/code&gt; is a synonym for &lt;code&gt;recsep&lt;/code&gt; . &lt;code&gt;-memory&lt;/code&gt; is a synonym for &lt;code&gt;memory&lt;/code&gt; . You get the idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3df98be4420c3856ff554875e341d1dcb377965" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-p&lt;/code&gt; is not particularly meaningful. (VMS, RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b5ade4f4cc1c4ba0b0dbebf1e249761eeda9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-quiet =&amp;gt; num&lt;/code&gt; If &lt;code&gt;num&lt;/code&gt; is true, do not print any errors/warnings. This is useful when Pod::Checker is used to munge POD code into plain text from within POD formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f770ed91ff164559d0abd6133fd3b69dd5415bfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;-o&lt;/code&gt; tell whether the file is accessible, which may not reflect UIC-based file protections. (VMS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c598522c04ff68c955ea80deb6fbadc566e1d400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-s&lt;/code&gt; by name on an open file will return the space reserved on disk, rather than the current extent. &lt;code&gt;-s&lt;/code&gt; on an open filehandle returns the current size. (RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7f863a163eba9181b50764fd83652ace5e0f66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-w&lt;/code&gt; is always set. You can turn this off in the test with &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN&lt;/a&gt; {
$^W = 0 }&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f6253934c68e4dbdee50184314e515e3ed4d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-w&lt;/code&gt; only inspects the read-only file attribute (FILE_ATTRIBUTE_READONLY), which determines whether the directory can be deleted, not whether it can be written to. Directories always have read and write access unless denied by discretionary access control lists (DACLs). (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9848a00d3e7ba37f894ed0ca52d187153533cc0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-warnings =&amp;gt; num&lt;/code&gt; Print warnings if &lt;code&gt;num&lt;/code&gt; is true. The higher the value of &lt;code&gt;num&lt;/code&gt; , the more warnings are printed. Currently there are only levels 1 and 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26338b342767aa86a4f5c2cd446ef7694f7f9b03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-x&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt;) determine if a file ends in one of the executable suffixes. &lt;code&gt;-S&lt;/code&gt; is meaningless. (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004059b6589f5cf146373041cd8de0aa8db4fb99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-x&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt;) determine if a file has an executable file type. (RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cb77fa8022c6097d9e2722edcf56db77b193e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&lt;/code&gt; is not implemented in Perls before 5.6, so if your code is required to work on older Perls you'll need to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;( 'Z* Z* C')&lt;/code&gt; to get the length, then use it to make a new unpack string. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2255f653ec4e14f86b6a230c7950f4828d1c42f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/World/&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!World!&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{World}&lt;/a&gt;&lt;/code&gt; all represent the same thing. When, e.g., the quote (&lt;code&gt;&quot;&lt;/code&gt;) is used as a delimiter, the forward slash &lt;code&gt;'/'&lt;/code&gt; becomes an ordinary character and can be used in this regexp without trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4bb16c5b73fbb6e42dd2c89421c762d2d8f026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/a&lt;/code&gt; also sets the character set to Unicode, BUT adds several restrictions for &lt;b&gt;A&lt;/b&gt;SCII-safe matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a058655ca9b7df500f2266e0005549d8d3e223d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/bin/ftp&lt;/code&gt; is blacklisted by default; see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c7c0b08473b89f6eba8829e2c3c1656684873f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/d&lt;/code&gt; is the old, problematic, pre-5.14 &lt;b&gt;D&lt;/b&gt;efault character set behavior. Its only use is to force that old behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febc46674582418d06306fc87a6a9bd45f9575fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , &lt;code&gt;/a&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; , available starting in 5.14, are called the character set modifiers; they affect the character set rules used for the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6d598b1ecd53357374289fc79181d6b6e30491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/n&lt;/code&gt; can be negated on a per-group basis. Alternatively, named captures may still be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ac450b442821abb7c32c4c890405928fdfa28f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/u&lt;/code&gt; sets the character set to &lt;b&gt;U&lt;/b&gt;nicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd7758b5452e01f565373a6a0ae745fee7b3413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/x&lt;/code&gt; lets you turn this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ddae5ee6d3b01640a82b11115def15c0a0729c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/x&lt;/code&gt; tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a bracketed character class. You can use this to break up your regular expression into (slightly) more readable parts. Also, the &lt;code&gt;#&lt;/code&gt; character is treated as a metacharacter introducing a comment that runs up to the pattern's closing delimiter, or to the end of the current line if the pattern extends onto the next line. Hence, this is very much like an ordinary Perl code comment. (You can include the closing delimiter within the comment only if you precede it with a backslash, so be careful!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5981c6b6f44acf2b5d0296f7ddc1ba22fd92a26b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0[0]&lt;/code&gt; items indicate that there is no corresponding node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e482cf4b4fb32a891abadbdc5931dba553b2cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1..1&lt;/code&gt; is the plan. Gotta have a plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079935d14865ac40c0d6e200d065519e65c3cdcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirects stderr to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337d24f61f20784a0224676b1a3b5621a81abd45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&amp;gt;&amp;gt;file&lt;/code&gt; appends stderr to &lt;code&gt;file&lt;/code&gt; , and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ccb2f92fe3975e1a3fd67583081fc9c8b22203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&amp;gt;file&lt;/code&gt; writes stderr to &lt;code&gt;file&lt;/code&gt; ,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3981fad441eed11874883499cec6490b94bc7d20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:extended&lt;/code&gt; exports the Perl specific functions for &lt;code&gt;syslog(3)&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b097d19f9e31e760a010b2177386c29f33c946a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:loose&lt;/code&gt; is a variant of &lt;code&gt;:full&lt;/code&gt; which allows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669910f757f8fda30540781c67df68d670678863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:loose&lt;/code&gt; slows down look-ups by a factor of 2 to 3 versus &lt;code&gt;:full&lt;/code&gt; , but the trade-off may be worth it to you. Each individual look-up takes very little time, and the results are cached, so the speed difference would become a factor only in programs that do look-ups of many different spellings, and probably only when those look-ups are through &lt;code&gt;vianame()&lt;/code&gt; and &lt;code&gt;string_vianame()&lt;/code&gt; , since &lt;code&gt;\N{...}&lt;/code&gt; look-ups are done at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d7d864e6dd6725fe109f9ec74c6124803c81cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:macros&lt;/code&gt; exports the symbols corresponding to most of your &lt;code&gt;syslog(3)&lt;/code&gt; macros and the &lt;code&gt;LOG_UPTO()&lt;/code&gt; and &lt;code&gt;LOG_MASK()&lt;/code&gt; functions. See &lt;a href=&quot;#CONSTANTS&quot;&gt;CONSTANTS&lt;/a&gt; for the supported constants and their meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f664d57f829bb236ed3a80342cea7743e03c9843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nocase&lt;/code&gt; and &lt;code&gt;:case&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393965e591f823a5c7c5f84e45b034f602c1b44f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:perlio&lt;/code&gt; will insert a &lt;code&gt;:unix&lt;/code&gt; layer below itself to do low level IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bdb7835e989d3493f81c8387cdd5e6b357f584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:standard&lt;/code&gt; exports the standard &lt;code&gt;syslog(3)&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7723508b0cf32c6becdfb32b8c90afbcd97daea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;;&lt;/code&gt; before executing your program. You can use quotes to add extra code after the module name, e.g., &lt;code&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46553e5b2e1fde3176954b71404b7f6a22f6b3a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; also sets the &lt;code&gt;exported_to()&lt;/code&gt; attribute of your builder to be the caller of the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4b41e6d9806d4d5463fcd3e58de249dc723c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; accepts one optional parameter, which is the layer to be passed on to the &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f783a72bce4dae4ba2e4905d91ba101d770101" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; sets &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on the underlying &lt;code&gt;IO&lt;/code&gt; object, as documented in &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2c461c21657cf272797141a2b0587b13a03497" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; will return (at least for Perl v5.7.1 and up) another BigInt, not a Perl scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87be11f6d2f761c7d725f291d31bf6656fee51d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; follows references exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da38e4772827175e65158aeaa06f0af9689d353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; places a &lt;b&gt;advisory&lt;/b&gt; lock on a variable until the lock goes out of scope. If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. Multiple calls to &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; by the same thread from within dynamically nested scopes are safe -- the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bc602e5a95f7ab0683bcb13cca7976f3a0b65a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/log&quot;&gt;log(-inf)&lt;/a&gt;&lt;/code&gt; is highly weird. Since log(-x)=pi*i+log(x), then log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real infinity &quot;overshadows&quot; it, so the number might as well just be infinity. However, the result is a complex number, and since BigInt/BigFloat can only have real numbers as results, the result is NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ec191a3833592580741021600849b3abd729c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; accepts one, two or three parameters. With one parameter, it is just a front end for the built-in &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function. With two or three parameters, the first parameter is a filename that may include whitespace or other special characters, and the second parameter is the open mode, optionally followed by a file permission value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ead93e5ae2cdbfb37e87b9aaf4b56f8342cd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; takes two arguments. The first is the name of the file to open and the second is the open mode. The mode can be anything acceptable to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt; and by extension anything acceptable to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10314a65bb5f737678649714b2af14bac7ab022b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; cannot be deferred. When you perform one of these operations, any deferred data is written to the file and the operation is performed immediately. This may change in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f1af66ad9aaecf816ee7e3787eccbf41e6b7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is a static method, that is you call it with the package name like &lt;code&gt;new&lt;/code&gt; . &lt;code&gt;READ&lt;/code&gt; , &lt;code&gt;WRITE&lt;/code&gt; and &lt;code&gt;EXCEPTION&lt;/code&gt; are either &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Select&lt;/code&gt; objects. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional and has the same effect as for the core select call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817eadf1b9adde1ba72695f76344cd268af72b88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; only ever matches another &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5396d3ff479715000ca76635e4a7743888fcf9b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will only ever match &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. So you can test a value against &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00aaf4e59c63d867f1c68b03ef33ba4aa5fba34a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;-ing a &lt;code&gt;Tie::File&lt;/code&gt; array element just blanks out the corresponding record in the file. When you read it back again, you'll get the empty string, so the supposedly-&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;'ed value will be defined. Similarly, if you have &lt;code&gt;autochomp&lt;/code&gt; disabled, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7047b1bd29e1be50a6c94747b1f96dfa733cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The value of the macro is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e529533962f928a5563433218b96d46c0165a2f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; raises an exception. Inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the error message is stuffed into &lt;code&gt;$@&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is terminated with the undefined value. If the exception is outside of all enclosing &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s, then the uncaught exception prints LIST to &lt;code&gt;STDERR&lt;/code&gt; and exits with a non-zero value. If you need to exit the process with a specific exit code, see &lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc00daf5a8853ec2a5f38fb396e5099336656db3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef00a2fa49a9b03b5b9e7f1482c6a3dce655e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df80248abb973135120867aea4de5126e5c9845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmclose&quot;&gt;dbmclose&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endgrent&quot;&gt;endgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endhostent&quot;&gt;endhostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endnetent&quot;&gt;endnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endprotoent&quot;&gt;endprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endservent&quot;&gt;endservent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetbyaddr&quot;&gt;getnetbyaddr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetbyname&quot;&gt;getnetbyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpriority&quot;&gt;getpriority&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getprotoent&quot;&gt;getprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwent&quot;&gt;getpwent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getservbyport&quot;&gt;getservbyport&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgctl&quot;&gt;msgctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgget&quot;&gt;msgget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semctl&quot;&gt;semctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semget&quot;&gt;semget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semop&quot;&gt;semop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setgrent&quot;&gt;setgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sethostent&quot;&gt;sethostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setnetent&quot;&gt;setnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpgrp&quot;&gt;setpgrp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpriority&quot;&gt;setpriority&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setprotoent&quot;&gt;setprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpwent&quot;&gt;setpwent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setservent&quot;&gt;setservent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmctl&quot;&gt;shmctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmget&quot;&gt;shmget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20b988761a2edd02a7e93114a0c1a07205215f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70096a2fa7e934b6d2fbdd9d57c878aed759204" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/bind&quot;&gt;bind&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/connect&quot;&gt;connect&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpeername&quot;&gt;getpeername&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getsockname&quot;&gt;getsockname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/listen&quot;&gt;listen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/recv&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/send&quot;&gt;send&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shutdown&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3307f74b5353d3d330388694e2e5a562ec4f6be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpriority&quot;&gt;getpriority&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpgrp&quot;&gt;setpgrp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpriority&quot;&gt;setpriority&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49adcd66c77b529c763f36ddd062aa4f6688b826" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmclose&quot;&gt;dbmclose&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87eeeb61a45746c1e4aa6912afa3ede8279ba591" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmclose&quot;&gt;dbmclose&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186c8b49686cf00b57846ac6e0a6189c67859e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;blessed&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42ab85ddf7e214b95aa21f7531a192c1d57730b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8f43e0b8956b059b663b7f40fee566ba68ac70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6373bbda016aaa1ddc91fd37de2c7931943ff130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63027fffa2a332cfddfd08f9068272d0ce52382" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2034a8bc4d2ddd556732a850eb5d8558c3aad776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; must be given an EBCDIC code number argument to yield a desired character return value on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c20fb8e247561b866ffc6fcee4160c028a6d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8069965d653903f6587480e5a0a31354565107" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971c23718c054d86a80726532c2350b4d61c91a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; raises an exception. Inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the error message is stuffed into &lt;code&gt;$@&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is terminated with the undefined value. If the exception is outside of all enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s, then the uncaught exception prints LIST to &lt;code&gt;STDERR&lt;/code&gt; and exits with a non-zero value. If you need to exit the process with a specific exit code, see &lt;a href=&quot;#exit&quot;&gt;exit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfcd08c97279f178046afe1b06078d3bfda0672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; will force the native VMS exit status to be an SS$_ABORT code if neither of the $! or $? status values are ones that would cause the native status to be interpreted as being what VMS classifies as SEVERE_ERROR severity for DCL error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e997695a43950b1946c87d7c74c4aff97e924f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fa01aff43e15c0a20de4c6319df39310438748" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf602825444127f538f868168b880e7c17e4f910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dde3e0b8af5305503cc41b40f558203bf6499aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/endgrent&quot;&gt;endgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endhostent&quot;&gt;endhostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endnetent&quot;&gt;endnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwent&quot;&gt;getpwent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setgrent&quot;&gt;setgrent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setpwent&quot;&gt;setpwent&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c701cf0d605693b06a942d567adc64697f8eadbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/endprotoent&quot;&gt;endprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/endservent&quot;&gt;endservent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostbyaddr&quot;&gt;gethostbyaddr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetbyaddr&quot;&gt;getnetbyaddr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetbyname&quot;&gt;getnetbyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getprotobyname&quot;&gt;getprotobyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getprotoent&quot;&gt;getprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getservbyname&quot;&gt;getservbyname&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getservbyport&quot;&gt;getservbyport&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sethostent&quot;&gt;sethostent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setnetent&quot;&gt;setnetent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setprotoent&quot;&gt;setprotoent&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/setservent&quot;&gt;setservent&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bad2147131524490c06fd7ed189d21e9cf1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec05314a43a26efee7891cae4ea24501c56383e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; behaves differently depending on the internal encoding of the string, sometimes treating its argument as a string of bytes, and sometimes as a string of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab5c8442d933f2e75cd6762dd7bfcc3ab2593ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings (when accessible) are considered to be filenames: &lt;code&gt;f (&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 7)&lt;/code&gt; and &lt;code&gt;f &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 7\b&lt;/code&gt; access the body of the 7th &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed string (in the order of execution). The bodies of the currently executed &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that define subroutines are saved and thus accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4938bb543bbc2773e23fdb85fc0bad70327b6cc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings are compiled in the package in which the eval() was compiled. (Assignments to &lt;code&gt;$SIG{}&lt;/code&gt; , however, assume the signal handler specified is in the &lt;code&gt;main&lt;/code&gt; package. Qualify the signal handler name if you wish to have a signal handler in a package.) For an example, examine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed6a22bb9761da407775198d594671570c1eb06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; fixes that to work the way one would expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689ed7a5f25b13235d58a1bf5add86b3304f247a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; is only available with the &lt;code&gt;&quot;evalbytes&quot;&lt;/code&gt; feature (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or if prefixed with &lt;code&gt;CORE::&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; is only available with the &lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; feature or if prefixed with &lt;code&gt;CORE::&lt;/code&gt; . Both the &lt;code&gt;&quot;evalbytes&quot;&lt;/code&gt; and &lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; features are enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration in the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6761c9a39c23e52f7069fc11948131c9ace80ad7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; without the use of indirect object syntax (&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; ) may fall back to trying the shell if the first &lt;code&gt;spawn()&lt;/code&gt; fails. (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284665f5fe88016ead454e392440b324b913043c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; resets file pointers, which is a problem when called from a child process (created by &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;) in &lt;code&gt;BEGIN&lt;/code&gt; . A workaround is to use &lt;code&gt;POSIX::_exit&lt;/code&gt; . (Solaris)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b61913c43c1185bbdb2e0e0dd8b3af5f081161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; is available only if the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled or if it is prefixed with &lt;code&gt;CORE::&lt;/code&gt; . The &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration in the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8bfcf789b65edee6c0ea5d97ffb5d56eb94268" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failures in io_* tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d01f3a00631549ba30fc14956cad336db066915" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname('localhost')&lt;/a&gt;&lt;/code&gt; does not work everywhere: you may have to use &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname('127.0.0.1')&lt;/a&gt;&lt;/code&gt;. (Irix 5)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ef5e14433d72564433190724fdd966ef50b051" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; (aka the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564d9f4c1be0a741d6c529a881ccab285f1e964e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03b71bee32ce86bd94c982679218f4e1f02d81a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3086a8c4fc89913fc262d257bf79bcbe20f793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; does three things: it waits for a thread to exit, cleans up after it, and returns any data the thread may have produced. But what if you're not interested in the thread's return values, and you don't really care when the thread finishes? All you want is for the thread to get cleaned up after when it's done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a03f921016bbb0b86e43c0578f72502ceddcfba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; waits for a thread to end and returns any values the thread exited with. &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; will block until the thread has ended, though it won't block if the thread has already terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e758149070ab91db0253a2bd5469b500fbd3e2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; doesn't have the semantics of &lt;code&gt;raise()&lt;/code&gt; , i.e. it doesn't send a signal to the identified process like it does on Unix platforms. Instead &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;($sig, $pid)&lt;/code&gt; terminates the process identified by &lt;code&gt;$pid&lt;/code&gt; , and makes it exit immediately with exit status $sig. As in Unix, if $sig is 0 and the specified process exists, it returns true without actually terminating it. (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88c251677de5696731dc7c1c2ad099fd58e07b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', ...)&lt;/code&gt; can be used to terminate a pseudo-process by passing it the ID returned by fork(). The outcome of kill on a pseudo-process is unpredictable and it should not be used except under dire circumstances, because the operating system may not guarantee integrity of the process resources when a running thread is terminated. The process which implements the pseudo-processes can be blocked and the Perl interpreter hangs. Note that using &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', ...)&lt;/code&gt; on a pseudo-process() may typically cause memory leaks, because the thread that implements the pseudo-process does not get a chance to clean up its resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75df60b5e7c4116a6ef3b294e7033ff0dcfbf3d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; can also be used on pseudo-processes, but the signal will not be delivered while the pseudo-process is blocked by a system call, e.g. waiting for a socket to connect, or trying to read from a socket with no data available. Starting in Perl 5.14 the parent process will not wait for children to exit once they have been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid deadlock during process exit. You will have to explicitly call waitpid() to make sure the child has time to clean-up itself, but you are then also responsible that the child is not blocking on I/O either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5183176d6cbdda12e7a690d422cfcbde120be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(-9, $pid)&lt;/code&gt; will terminate the process specified by &lt;code&gt;$pid&lt;/code&gt; and recursively all child processes owned by it. This is different from the Unix semantics, where the signal will be delivered to all processes in the same process group as the process specified by $pid. (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d6ace4d35779bb92de39a74ae12ac82c622c36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; cannot be used to exit a block that returns a value such as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070d6d718d052c422333dfc4a73c9ff557369c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; may appear within a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block; &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; behave as if they had been executed within the main block. So will &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, but since it will execute a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, it may be more entertaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7dc8f5385a1d957a4ec078883a408036e64e47d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($x)&lt;/a&gt;&lt;/code&gt; saves away the old value of the global variable &lt;code&gt;$x&lt;/code&gt; and assigns a new value for the duration of the subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae121069d9f20b53a610cdeaf9dee9016adf3eb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; blocks the thread until the variable being locked is available. When &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; returns, your thread can be sure that no other thread can lock that variable until the block containing the lock exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170941b48e14e3f5099948bab33b3c9d8dbcb576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; places a lock on a variable until the lock goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3509688406236324d230070a551af253bd14269a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e6cff15cdccdd24c02ad5ce98693ac4145238a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/pattern/msixpogcdualn&lt;/a&gt;&lt;/code&gt; searches a string for a pattern match, applying the given options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1944b24caa2d31a689377ec13306300ad9daf001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/msgctl&quot;&gt;msgctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgget&quot;&gt;msgget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semctl&quot;&gt;semctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semget&quot;&gt;semget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/semop&quot;&gt;semop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmctl&quot;&gt;shmctl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmget&quot;&gt;shmget&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23ddf8844c8d314770e265090c4032565505efe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my($x)&lt;/a&gt;&lt;/code&gt; creates a new variable that is only visible in the current subroutine. This is done at compile-time, so it is called lexical or static scoping. my() always affects private variables, also called lexical variables or (improperly) static(ly scoped) variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07257377a06fc9758ae4feb8af6d3a0dabc51822" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; give list context to the right hand side of &lt;code&gt;=&lt;/code&gt; . The &amp;lt;$fh&amp;gt; read operation, like so many of Perl's functions and operators, can tell which context it was called in and behaves appropriately. In general, the scalar() function can help. This function does nothing to the data itself (contrary to popular myth) but rather tells its argument to behave in whatever its scalar fashion is. If that function doesn't have a defined scalar behavior, this of course doesn't help you (such as with sort()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eda9e72a33666b731b864d91f6ba22b818ca17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables are scoped to the current block, not to the current function. If you write &lt;code&gt;{&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;} $x;&lt;/code&gt; , the second &lt;code&gt;$x&lt;/code&gt; does not refer to the one declared inside the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b3aead5cdbc6341c36d8eaad29039df26dd3a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; cannot be used to exit a block which returns a value such as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7816c0bc56e1301d1d13bec1cdf1c4a410856929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells the compiler to use the traditional Perl rules wherein the native character set rules is used unless it is clear to Perl that Unicode is desired. This can lead to some surprises when the behavior suddenly changes. (See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt; for details.) For this reason, if you are potentially using Unicode in your program, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; subpragma is &lt;b&gt;strongly&lt;/b&gt; recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac81d61c42a23c6729598734f402a23c1c56eea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; with no features specified will reset to the default group. To disable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43198e234dd55ddea949ef71cd04c5b9a67bbf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/flags'&lt;/code&gt; will turn off the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; for the given flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bc29863e56cfa45bbea04dcee585c67952579a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;-|&quot;&lt;/code&gt; , in other words, opening pipes to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d8b4a76f4f6129fa4264c69c3f0d9f88979d3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d47a7f890bd33e4ea969830dac3cb0ad060f6a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; will return EBCDIC code number values on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c53ed24bd7c69198eac1389d9414a4a91ac2d6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; differs from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , which allows use of an unqualified name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02441caa31363d63a0257ab42958956b8ab58eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; has the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, meaning that it is only valid within a lexical scope. Unlike &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, which both declare new (lexical) variables, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; only creates an alias to an existing variable: a package variable of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6774d0bb994ddfaf2ef8c1d60b6b78ab041154fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; makes a lexical alias to a package (i.e. global) variable of the same name in the current package for use within the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b4e2f1cfd6c489237ee0bdbdd2d311d7ce5f54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5857e8b84e30eef502f98ccf74513442f8930b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are two functions for transforming data according to a user-defined template, between the guarded way Perl stores values and some well-defined representation as might be required in the environment of a Perl program. Unfortunately, they're also two of the most misunderstood and most often overlooked functions that Perl provides. This tutorial will demystify them for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c05b5f8252da7d1c99d5e4040b8c3c6ee106ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2252b2bedd63bcabdecf7bfe44b0f5112b8e9d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; directly accesses the location used by the regexp engine to store the offset, so assigning to &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will change that offset, and so will also influence the &lt;code&gt;\G&lt;/code&gt; zero-width assertion in regular expressions. Both of these effects take place for the next match, so you can't affect the position with &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; during the current match, such as in &lt;code&gt;(?{pos() = 5})&lt;/code&gt; or &lt;code&gt;s//pos() = 5/e&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1950ccdf48f077e739f5814af32f11a43773eb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/pattern/msixpodualn&lt;/a&gt;&lt;/code&gt; lets you store a regex in a variable, or pass one around. Modifiers as for &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, and are stored within the regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d062bdc19be018775cd04b7fe47df8c33090f46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; must return a compiled regexp, or a ref to a compiled regexp (such as &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; returns), and any further overloading on the return value will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf9c5016beeb9680d1e1288d3394e4a396bd820" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\Q&lt;/code&gt; are fully described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188d3fd2d5601f204ee3fcff4baf277b1b9145a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; (aka the backtick operator), &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d74cdbd617ac6784cd0523ea76bbc823fe5c46d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand($x)&lt;/a&gt;&lt;/code&gt; returns a number such that &lt;code&gt;0 &amp;lt;= &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;($x) &amp;lt; $x&lt;/code&gt; . Thus what you want to have perl figure out is a random number in the range from 0 to the difference between your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4bf1581c291b9f8ecef59847322f94dde9b542" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; reads characters and returns the number of characters. &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; operate on byte counts, as do &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5c571597ad186dd4a954192a5cebc8d822206f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7456d57d98baaffed623ce4bd4263a163b2aec05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to retry a block that returns a value such as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6696e29c58ecf1f6ae5ba2682cd87e761d86df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; has special additional dark magic: if you invoke your &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; replacement as &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Foo::Bar&lt;/code&gt; , it will actually receive the argument &lt;code&gt;&quot;Foo/Bar.pm&quot;&lt;/code&gt; in @_. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c933e5af38fe33f1b42e9ea2b143d4921f5f23a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/pattern/replacement/msixpogcedual&lt;/a&gt;&lt;/code&gt; substitutes matches of 'pattern' with 'replacement'. Modifiers as for &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, with two additions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e44cb588e50026d5be597d045d8bc89c8231d12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; acts just like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; except $\ will be localized to &lt;code&gt;\n&lt;/code&gt; so you need do nothing special to handle &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PRINT()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a80adc896ab22ad4c977a28b9890609696de0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; is available only if the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled or if it is prefixed with &lt;code&gt;CORE::&lt;/code&gt; . The &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; (or higher) declaration in the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed0487d19fc343d28196f6e778281c685c1bcbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;()&lt;/code&gt; reverses by character rather than by byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50e5b6f97f253b98726d473e85bc3e447a2bd4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/setpriority&quot;&gt;setpriority&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/getpriority&quot;&gt;getpriority&lt;/a&gt;&lt;/code&gt; are not compatible with earlier ports by Andreas Kaiser. See &lt;code&gt;&quot;setpriority, getpriority&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9af6569137d1fe40ea10409b241d51eaf476898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/setpriority&quot;&gt;setpriority&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getpriority&quot;&gt;getpriority&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e768f6c25fd89661888a8fb28b195577438c085" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can be used, for example, to implement n-ary queue processing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177c757ab59e714a32d57425c159cf8b95290093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regex/, string&lt;/code&gt; splits &lt;code&gt;string&lt;/code&gt; into a list of substrings and returns that list. The regex determines the character sequence that &lt;code&gt;string&lt;/code&gt; is split with respect to. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acccb47a52b54e1b968bac1688412424630d4600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declares a lexically scoped variable, just like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. However, those variables will never be reinitialized, contrary to lexical variables that are reinitialized each time their enclosing block is entered. See &lt;a href=&quot;perlsub#Persistent-Private-Variables&quot;&gt;Persistent Private Variables in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1f128d19018432959490e63d61d5b5b7fb3f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; is available only if the &lt;code&gt;&quot;state&quot;&lt;/code&gt; feature is enabled or if it is prefixed with &lt;code&gt;CORE::&lt;/code&gt; . The &lt;code&gt;&quot;state&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; (or higher) declaration in the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d682a66def88db6f77999cda09b21cb1cbfe7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables are enabled only when the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;state&quot;&lt;/code&gt; pragma is in effect, unless the keyword is written as &lt;code&gt;CORE::state&lt;/code&gt; . See also &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa9d870fbe303bfda0361e0eb1503a4bc2827ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; without the use of indirect object syntax (&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; ) may fall back to trying the shell if the first &lt;code&gt;spawn()&lt;/code&gt; fails. (Win32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13394de1a0017f2e3c646b4e6f9372f06700bd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; also provides direct control over whether shell wildcard processing may take place, whereas backticks do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca56f2cd326f61f2e21ca153383b807ee7a157d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="325d8cb9dc74553e44ba1cf66fe60ddd2554335d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; works but the correct permissions are set only when the file is finally closed. (AmigaOS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b210b1883c3e9bcbba5d5fb87e463314c1e4390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is always treated as numeric, and in particular is changed to &lt;code&gt;0&lt;/code&gt; before incrementing (so that a post-increment of an undef value will return &lt;code&gt;0&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5aefccb12996eadd8d801e9cfdf76ddf4f796d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete a file if at all possible, even if it requires changing file protection (though it won't try to change the protection of the parent directory). You can tell whether you've got explicit delete access to a file by using the &lt;code&gt;VMS::Filespec::candelete&lt;/code&gt; operator. For instance, in order to delete only files to which you have delete access, you could say something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89b142c4cf303af585f44aa959a9f2d33f1baea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete the highest version of a file only; in order to delete all versions, you need to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9d97894178af5ea2b4ade814baff596e23579c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; does the reverse of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;: it takes a string and expands it out into a list of values. (In scalar context, it returns merely the first value produced.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44eb6a0f9a45c3ab4602cb7e40deb8c651427714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; also lexically enables all features available in the requested version as defined by the &lt;code&gt;feature&lt;/code&gt; pragma, disabling any features not in the requested version's feature bundle. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Similarly, if the specified Perl version is greater than or equal to 5.12.0, strictures are enabled lexically as with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . Any explicit use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict&lt;/code&gt; overrides &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; , even if it comes before it. Later use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; will override all behavior of a previous &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; , possibly removing the &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt; added by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; does not load the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02af597e7e1c634b880fabc11ab8447d438ffc44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is usually a failed attempt to do something useful. Just forget about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65794f2e0db80cf66382b2a3fac13f64df20f1dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding ...&lt;/code&gt; is not thread-safe (i.e., do not use in threaded applications).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39eeb7ec51146733b1a7cf9eb0196f712de28471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'fc'&lt;/code&gt; tells the compiler to enable the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function, which implements Unicode casefolding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d0ae3670893615eaeba861a2b7ada5d23d8df4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'say'&lt;/code&gt; tells the compiler to enable the Perl 6 style &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119202774744694437463c0ae2e1f969fd53e6b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; tells the compiler to enable &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9193ee0a2139b1ba978d5f6b9763f7962eb6c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'switch'&lt;/code&gt; tells the compiler to enable the Perl 6 given/when construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3886237fa1a19506e8ee6eb3def8d571370298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells the compiler to use Unicode rules in all string operations executed within its scope (unless they are also within the scope of either &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; ). The same applies to all regular expressions compiled within the scope, even if executed outside it. It does not change the internal representation of strings, but only how they are interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cba69074857ea47c3dfb8655f441c068164911d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; enables you to see the gory details of how the Perl regular expression engine works. In order to understand this typically voluminous output, one must not only have some idea about how regular expression matching works in general, but also know how Perl's regular expressions are internally compiled into an automaton. These matters are explored in some detail in &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec77985991c1d1d32691bbc003d4e51cd7aeda5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; wasn't implicitly declared so you have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443f944da102d55c2affc8a5f885238902623e07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; a Perl module if a condition holds (also can &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; a module)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ad26005d5e68b2cb4e1547e6cbf20e087acbfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; may also be assigned to, in which case parentheses are needed to give the expression the correct precedence as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253b8837541eb997903db67737154769342d214c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray()&lt;/a&gt;&lt;/code&gt;'s result is unspecified in the top level of a file, in a &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; block, or in a &lt;code&gt;DESTROY&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce182871cf42859bea7be5ff4b5b81a1a95e11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;carp()&lt;/code&gt; a message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0df496d8f100a8113c0eb03aaaf8ccef33e1b68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; cannot be used to exit a block that returns a value such as &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263d020f345cd227424dc536345012174cded3ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; may appear within a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block; &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; behave as if they had been executed within the main block. So will &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, but since it will execute a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, it may be more entertaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be37cb59b6af284f0f98885aeb6b517a5b6cbcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; cannot be used to exit a block which returns a value such as &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d58e96273d9ce3f45d93ab3d9b2a258a040437" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; differs from &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , which allows use of an unqualified name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512b743a5a3af3616073c2971298e6db67fcaac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; has the same scoping rules as &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, meaning that it is only valid within a lexical scope. Unlike &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, which both declare new (lexical) variables, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; only creates an alias to an existing variable: a package variable of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2bf5f5b3a22314641f3499a065d97485a642e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; makes a lexical alias to a package (i.e. global) variable of the same name in the current package for use within the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360ca70694e71b7a9eee09a8d981b1ad1ac44c90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; directly accesses the location used by the regexp engine to store the offset, so assigning to &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will change that offset, and so will also influence the &lt;code&gt;\G&lt;/code&gt; zero-width assertion in regular expressions. Both of these effects take place for the next match, so you can't affect the position with &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; during the current match, such as in &lt;code&gt;(?{pos() = 5})&lt;/code&gt; or &lt;code&gt;s//pos() = 5/e&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ebaa7ec2b209fa20d273b0a5a9b7503aacc295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to retry a block that returns a value such as &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , and should not be used to exit a grep() or map() operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29c0555345e4686ed8d3d71e3aea4b37c87e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can be used, for example, to implement n-ary queue processing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaa7b64b8ed8213795d79c3e9d1a11a7dd50c6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declares a lexically scoped variable, just like &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. However, those variables will never be reinitialized, contrary to lexical variables that are reinitialized each time their enclosing block is entered. See &lt;a href=&quot;../perlsub#Persistent-Private-Variables&quot;&gt;Persistent Private Variables in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8157faa8c3a3d05ba145b1d8aefaa265faaa9f67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables are enabled only when the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature &quot;state&quot;&lt;/code&gt; pragma is in effect, unless the keyword is written as &lt;code&gt;CORE::state&lt;/code&gt; . See also &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2245bc251bbc1b43fe683a1a16bb66eec96c8cbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; does the reverse of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;: it takes a string and expands it out into a list of values. (In scalar context, it returns merely the first value produced.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736c80794a09df674ddc9a935c317db522374fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; also lexically enables all features available in the requested version as defined by the &lt;code&gt;feature&lt;/code&gt; pragma, disabling any features not in the requested version's feature bundle. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Similarly, if the specified Perl version is greater than or equal to 5.12.0, strictures are enabled lexically as with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . Any explicit use of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; strict&lt;/code&gt; overrides &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; , even if it comes before it. Later use of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; will override all behavior of a previous &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; , possibly removing the &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt; added by &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; does not load the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d689d705b1e08b377f1d5deb4d1a473e7ddec22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; may also be assigned to, in which case parentheses are needed to give the expression the correct precedence as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355259eee85060ecf231fded7ccdc9659e1111c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;wantarray&quot;&gt;wantarray()&lt;/a&gt;&lt;/code&gt;'s result is unspecified in the top level of a file, in a &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; block, or in a &lt;code&gt;DESTROY&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d50b5f9e52f09d2ccae3273ada4191283911c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=encoding&lt;/code&gt; affects the whole document, and must occur only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07322f9284a7fc6a66d31dacd87d358ae453c9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=item&lt;/code&gt; determines the type of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebad7dcfcec37e214976c00e96b70065437ad740" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=item&lt;/code&gt; without any parameters is deprecated. It should either be followed by &lt;code&gt;*&lt;/code&gt; to indicate an unordered list, by a number (optionally followed by a dot) to indicate an ordered (numbered) list or simple text for a definition list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f73e36fe3dcbab1d5cadecc12ae9b6f4e28981d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=~&lt;/code&gt; determines to which variable the regex is applied. In its absence, $_ is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fefbdb7ea0230f31629f2921135e5559c380fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;? :&lt;/code&gt; has higher precedence than assignment. In JavaScript, one can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cbd52c428d14570a189a38a8c217073b6fca54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?pattern?&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/pattern/&lt;/a&gt;&lt;/code&gt; but matches only once. No alternate delimiters can be used. Must be reset with reset().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ade0011806b926bc0fc0aa0bd8d231bc768280" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , and &lt;code&gt;X&lt;/code&gt; , where it is equivalent to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f3fd756e106eca16f05f980cc57eeeafcf0a6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@DB::dbline&lt;/code&gt; is an alias for &lt;code&gt;@{&quot;::_&amp;lt;current_file&quot;}&lt;/code&gt; , which holds the lines of the currently-selected file (compiled by Perl), either explicitly chosen with the debugger's &lt;code&gt;f&lt;/code&gt; command, or implicitly by flow of execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5133137a39f1db792f2a0a17dd56d1204b81d6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANSI&lt;/code&gt; C requires &lt;code&gt;extern&lt;/code&gt; where C++ requires 'extern &lt;code&gt;C&lt;/code&gt; '. This variable can be used in Configure to do the right thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ae3437c7a9c9b775fbb010803709f69f626606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ARGV&lt;/code&gt; must be capitalized. &lt;code&gt;$ARGV[0]&lt;/code&gt; is C's &lt;code&gt;argv[1]&lt;/code&gt; , and &lt;code&gt;argv[0]&lt;/code&gt; ends up in &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57ccf257a33b046ff0968824b0efb78efa3559e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ARG_MAX&lt;/code&gt;&lt;code&gt;CHAR_BIT&lt;/code&gt;&lt;code&gt;CHAR_MAX&lt;/code&gt;&lt;code&gt;CHAR_MIN&lt;/code&gt;&lt;code&gt;CHILD_MAX&lt;/code&gt;&lt;code&gt;INT_MAX&lt;/code&gt;&lt;code&gt;INT_MIN&lt;/code&gt;&lt;code&gt;LINK_MAX&lt;/code&gt;&lt;code&gt;LONG_MAX&lt;/code&gt;&lt;code&gt;LONG_MIN&lt;/code&gt;&lt;code&gt;MAX_CANON&lt;/code&gt;&lt;code&gt;MAX_INPUT&lt;/code&gt;&lt;code&gt;MB_LEN_MAX&lt;/code&gt;&lt;code&gt;NAME_MAX&lt;/code&gt;&lt;code&gt;NGROUPS_MAX&lt;/code&gt;&lt;code&gt;OPEN_MAX&lt;/code&gt;&lt;code&gt;PATH_MAX&lt;/code&gt;&lt;code&gt;PIPE_BUF&lt;/code&gt;&lt;code&gt;SCHAR_MAX&lt;/code&gt;&lt;code&gt;SCHAR_MIN&lt;/code&gt;&lt;code&gt;SHRT_MAX&lt;/code&gt;&lt;code&gt;SHRT_MIN&lt;/code&gt;&lt;code&gt;SSIZE_MAX&lt;/code&gt;&lt;code&gt;STREAM_MAX&lt;/code&gt;&lt;code&gt;TZNAME_MAX&lt;/code&gt;&lt;code&gt;UCHAR_MAX&lt;/code&gt;&lt;code&gt;UINT_MAX&lt;/code&gt;&lt;code&gt;ULONG_MAX&lt;/code&gt;&lt;code&gt;USHRT_MAX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ARG_MAX&lt;/code&gt;&lt;code&gt;CHAR_BIT&lt;/code&gt;&lt;code&gt;CHAR_MAX&lt;/code&gt;&lt;code&gt;CHAR_MIN&lt;/code&gt;&lt;code&gt;CHILD_MAX&lt;/code&gt;&lt;code&gt;INT_MAX&lt;/code&gt;&lt;code&gt;INT_MIN&lt;/code&gt;&lt;code&gt;LINK_MAX&lt;/code&gt;&lt;code&gt;LONG_MAX&lt;/code&gt;&lt;code&gt;LONG_MIN&lt;/code&gt;&lt;code&gt;MAX_CANON&lt;/code&gt;&lt;code&gt;MAX_INPUT&lt;/code&gt;&lt;code&gt;MB_LEN_MAX&lt;/code&gt;&lt;code&gt;NAME_MAX&lt;/code&gt;&lt;code&gt;NGROUPS_MAX&lt;/code&gt;&lt;code&gt;OPEN_MAX&lt;/code&gt;&lt;code&gt;PATH_MAX&lt;/code&gt;&lt;code&gt;PIPE_BUF&lt;/code&gt;&lt;code&gt;SCHAR_MAX&lt;/code&gt;&lt;code&gt;SCHAR_MIN&lt;/code&gt;&lt;code&gt;SHRT_MAX&lt;/code&gt;&lt;code&gt;SHRT_MIN&lt;/code&gt;&lt;code&gt;SSIZE_MAX&lt;/code&gt;&lt;code&gt;STREAM_MAX&lt;/code&gt;&lt;code&gt;TZNAME_MAX&lt;/code&gt;&lt;code&gt;UCHAR_MAX&lt;/code&gt;&lt;code&gt;UINT_MAX&lt;/code&gt;&lt;code&gt;ULONG_MAX&lt;/code&gt;&lt;code&gt;USHRT_MAX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b9569dc4638e876dd19281624e240989316c5dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTOLOAD&lt;/code&gt; ed Constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e142f631947b7b6f2c788b456711e34efe3fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTOLOAD&lt;/code&gt; is called as a regular method, and the caller will not know the difference. Whatever value your &lt;code&gt;AUTOLOAD&lt;/code&gt; method returns is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbb9ec120ba361b6f5460b94c314d64b448bf2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;App::Prove&lt;/code&gt; provides support for 3rd-party plugins. These are currently loaded at run-time,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0aceb7a30a93c5c7447ecd145d2662ec296f25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Archive::Tar&lt;/code&gt; needs to know the current directory, and it will run &lt;code&gt;Cwd::cwd()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80986d664cffa01e81fccf03bfedaa80a88cc119" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Archive::Tar&lt;/code&gt; uses byte semantics for any files it reads from or writes to disk. This is not a problem if you only deal with files and never look at their content or work solely with byte strings. But if you use Unicode strings with character semantics, some additional steps need to be taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af577fe124da7ba0dc1016ca3a04b7143e372d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoLoader&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9437eb281e77849a5563ad2a499e675a1a043b61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoSplit&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bd4577edcd6e179bc6b12ccaafd7f126175140" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoSplit&lt;/code&gt; will also emit general diagnostics for inability to create directories or files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ce0b283187c41b4404a6e80e30e87f1a557756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoSplit&lt;/code&gt; will inform the user if it is necessary to create the top-level directory specified in the invocation. It is preferred that the script or installation process that invokes &lt;code&gt;AutoSplit&lt;/code&gt; have created the full directory path ahead of time. This warning may indicate that the module is being split into an incorrect path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f791bf59fe665ab5ea1fc7f801f5eda72d0e8745" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoSplit&lt;/code&gt; will warn the user of all subroutines whose name causes potential file naming conflicts on machines with drastically limited (8 characters or less) file name length. Since the subroutine name is used as the file name, these warnings can aid in portability to such systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa7c90636b4810f5846981b5d1192d23e75d7a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B38400&lt;/code&gt;&lt;code&gt;B75&lt;/code&gt;&lt;code&gt;B200&lt;/code&gt;&lt;code&gt;B134&lt;/code&gt;&lt;code&gt;B300&lt;/code&gt;&lt;code&gt;B1800&lt;/code&gt;&lt;code&gt;B150&lt;/code&gt;&lt;code&gt;B0&lt;/code&gt;&lt;code&gt;B19200&lt;/code&gt;&lt;code&gt;B1200&lt;/code&gt;&lt;code&gt;B9600&lt;/code&gt;&lt;code&gt;B600&lt;/code&gt;&lt;code&gt;B4800&lt;/code&gt;&lt;code&gt;B50&lt;/code&gt;&lt;code&gt;B2400&lt;/code&gt;&lt;code&gt;B110&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;B38400&lt;/code&gt;&lt;code&gt;B75&lt;/code&gt;&lt;code&gt;B200&lt;/code&gt;&lt;code&gt;B134&lt;/code&gt;&lt;code&gt;B300&lt;/code&gt;&lt;code&gt;B1800&lt;/code&gt;&lt;code&gt;B150&lt;/code&gt;&lt;code&gt;B0&lt;/code&gt;&lt;code&gt;B19200&lt;/code&gt;&lt;code&gt;B1200&lt;/code&gt;&lt;code&gt;B9600&lt;/code&gt;&lt;code&gt;B600&lt;/code&gt;&lt;code&gt;B4800&lt;/code&gt;&lt;code&gt;B50&lt;/code&gt;&lt;code&gt;B2400&lt;/code&gt;&lt;code&gt;B110&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a64c66bf4fc7c70ea27f75add0d37d3a321bd35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B::Deparse,-p&lt;/code&gt; will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d99aa8d0dc3a4437e4a861de4e6a98166d8c06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B::Generate&lt;/code&gt; directly supports the creation of custom ops by name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69143927686bc3bd43e1bf2779ecba7d882ac562" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B::OP&lt;/code&gt; , &lt;code&gt;B::UNOP&lt;/code&gt; , &lt;code&gt;B::UNOP_AUX&lt;/code&gt; , &lt;code&gt;B::BINOP&lt;/code&gt; , &lt;code&gt;B::LOGOP&lt;/code&gt; , &lt;code&gt;B::LISTOP&lt;/code&gt; , &lt;code&gt;B::PMOP&lt;/code&gt; , &lt;code&gt;B::SVOP&lt;/code&gt; , &lt;code&gt;B::PADOP&lt;/code&gt; , &lt;code&gt;B::PVOP&lt;/code&gt; , &lt;code&gt;B::LOOP&lt;/code&gt; , &lt;code&gt;B::COP&lt;/code&gt; , &lt;code&gt;B::METHOP&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9f3bb0f0c441b31c591f3a04a947cf1db2ac5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; blocks may be used to capture control before or after the implicit loop, just as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e70ee8bd7cbef3858d58171f0cc99eaf7a63c68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; blocks may be used to capture control before or after the implicit program loop, just as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b758038b5498a90bd251e1abc1bf4be0e55d71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;UNITCHECK&lt;/code&gt; blocks are not directly related to the phase of the interpreter. They can be created and executed during any phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499245d6aeb6a133d5fe34cee30f454c408a297d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BINMODE&lt;/code&gt; , &lt;code&gt;CLEAR&lt;/code&gt; , &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;DESTROY&lt;/code&gt; , &lt;code&gt;EOF&lt;/code&gt; , &lt;code&gt;EXISTS&lt;/code&gt; , &lt;code&gt;EXTEND&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;FETCHSIZE&lt;/code&gt; , &lt;code&gt;FILENO&lt;/code&gt; , &lt;code&gt;FIRSTKEY&lt;/code&gt; , &lt;code&gt;GETC&lt;/code&gt; , &lt;code&gt;NEXTKEY&lt;/code&gt; , &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;POP&lt;/code&gt; , &lt;code&gt;PRINT&lt;/code&gt; , &lt;code&gt;PRINTF&lt;/code&gt; , &lt;code&gt;PUSH&lt;/code&gt; , &lt;code&gt;READ&lt;/code&gt; , &lt;code&gt;READLINE&lt;/code&gt; , &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;SEEK&lt;/code&gt; , &lt;code&gt;SHIFT&lt;/code&gt; , &lt;code&gt;SPLICE&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , &lt;code&gt;STORESIZE&lt;/code&gt; , &lt;code&gt;TELL&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;UNSHIFT&lt;/code&gt; , &lt;code&gt;UNTIE&lt;/code&gt; , &lt;code&gt;WRITE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054059d16923fe6138b013ad38390b2d287c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BINMODE&lt;/code&gt; , &lt;code&gt;CLEARERR&lt;/code&gt; , &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;EOF&lt;/code&gt; , &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; , &lt;code&gt;FILENO&lt;/code&gt; , &lt;code&gt;FILL&lt;/code&gt; , &lt;code&gt;FLUSH&lt;/code&gt; , &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;POPPED&lt;/code&gt; , &lt;code&gt;PUSHED&lt;/code&gt; , &lt;code&gt;READ&lt;/code&gt; , &lt;code&gt;SEEK&lt;/code&gt; , &lt;code&gt;SETLINEBUF&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;TELL&lt;/code&gt; , &lt;code&gt;UNREAD&lt;/code&gt; , &lt;code&gt;UTF8&lt;/code&gt; , &lt;code&gt;WRITE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea30947e2c1475164f5299445eaca2bdacb962b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BRKINT&lt;/code&gt;&lt;code&gt;ICRNL&lt;/code&gt;&lt;code&gt;IGNBRK&lt;/code&gt;&lt;code&gt;IGNCR&lt;/code&gt;&lt;code&gt;IGNPAR&lt;/code&gt;&lt;code&gt;INLCR&lt;/code&gt;&lt;code&gt;INPCK&lt;/code&gt;&lt;code&gt;ISTRIP&lt;/code&gt;&lt;code&gt;IXOFF&lt;/code&gt;&lt;code&gt;IXON&lt;/code&gt;&lt;code&gt;PARMRK&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BRKINT&lt;/code&gt;&lt;code&gt;ICRNL&lt;/code&gt;&lt;code&gt;IGNBRK&lt;/code&gt;&lt;code&gt;IGNCR&lt;/code&gt;&lt;code&gt;IGNPAR&lt;/code&gt;&lt;code&gt;INLCR&lt;/code&gt;&lt;code&gt;INPCK&lt;/code&gt;&lt;code&gt;ISTRIP&lt;/code&gt;&lt;code&gt;IXOFF&lt;/code&gt;&lt;code&gt;IXON&lt;/code&gt;&lt;code&gt;PARMRK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a86a4f316865f4d27f2b761993dbe11e226b269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BUFSIZ&lt;/code&gt;&lt;code&gt;EOF&lt;/code&gt;&lt;code&gt;FILENAME_MAX&lt;/code&gt;&lt;code&gt;L_ctermid&lt;/code&gt;&lt;code&gt;L_cuserid&lt;/code&gt;&lt;code&gt;L_tmpname&lt;/code&gt;&lt;code&gt;TMP_MAX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BUFSIZ&lt;/code&gt;&lt;code&gt;EOF&lt;/code&gt;&lt;code&gt;FILENAME_MAX&lt;/code&gt;&lt;code&gt;L_ctermid&lt;/code&gt;&lt;code&gt;L_cuserid&lt;/code&gt;&lt;code&gt;L_tmpname&lt;/code&gt;&lt;code&gt;TMP_MAX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b5d3888afaab4aeac99edeb07406b18608b6c50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHECK&lt;/code&gt; code blocks are run just after the &lt;b&gt;initial&lt;/b&gt; Perl compile phase ends and before the run time begins, in LIFO order. &lt;code&gt;CHECK&lt;/code&gt; code blocks are used in the Perl compiler suite to save the compiled state of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e02246fa126d7ef5ff5b0718b1e93bd87149d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLK_TCK&lt;/code&gt;&lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CLK_TCK&lt;/code&gt;&lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a61a7563f8241ebae52535c87c69347ca5c0ae09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLOCAL&lt;/code&gt;&lt;code&gt;CREAD&lt;/code&gt;&lt;code&gt;CSIZE&lt;/code&gt;&lt;code&gt;CS5&lt;/code&gt;&lt;code&gt;CS6&lt;/code&gt;&lt;code&gt;CS7&lt;/code&gt;&lt;code&gt;CS8&lt;/code&gt;&lt;code&gt;CSTOPB&lt;/code&gt;&lt;code&gt;HUPCL&lt;/code&gt;&lt;code&gt;PARENB&lt;/code&gt;&lt;code&gt;PARODD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CLOCAL&lt;/code&gt;&lt;code&gt;CREAD&lt;/code&gt;&lt;code&gt;CSIZE&lt;/code&gt;&lt;code&gt;CS5&lt;/code&gt;&lt;code&gt;CS6&lt;/code&gt;&lt;code&gt;CS7&lt;/code&gt;&lt;code&gt;CS8&lt;/code&gt;&lt;code&gt;CSTOPB&lt;/code&gt;&lt;code&gt;HUPCL&lt;/code&gt;&lt;code&gt;PARENB&lt;/code&gt;&lt;code&gt;PARODD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb14449092af20fb2f25b23f9f6ea74cda3c921f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; ,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c199db2c255ea797ffcbc3258a9caf85ffeeae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CPAN.pm&lt;/code&gt; comes with a collection of example YAML files. Note that these are really just examples and should not be used without care because they cannot fit everybody's purpose. After all, the authors of the packages that ask questions had a need to ask, so you should watch their questions and adjust the examples to your environment and your needs. You have been warned:-)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e958779cdd01a7b3327f2eef63836bcd8b19e2ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CYGWIN&lt;/code&gt; setting, permissions use the standard WinNT security descriptors and access control lists. Without one of these options, these tests will fail (listing not updated yet):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715067c3d15ba3a25c4c578ac95ae803c5d463ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CYGWIN&lt;/code&gt; setting, the additional mode bits are stored as extended file attributes. On WinNT with the default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40e8c070cd96353a84f0cdb4689a540da128600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Carp&lt;/code&gt; takes care not to clobber the status variables &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; in the course of assembling its error messages. This means that a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; or &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler can capture the error information held in those variables, if it is required to augment the error message, and if the code calling &lt;code&gt;Carp&lt;/code&gt; left useful values there. Of course, &lt;code&gt;Carp&lt;/code&gt; can't guarantee the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31407ed8968a4b0da65b3add4e603dd893f9f016" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Class::Accessor&lt;/code&gt; does a lot less than &lt;code&gt;Moose&lt;/code&gt; , and is a nice alternative if you find &lt;code&gt;Moose&lt;/code&gt; overwhelming. It's been around a long time and is well battle-tested. It also has a minimal &lt;code&gt;Moose&lt;/code&gt; compatibility mode which makes moving from &lt;code&gt;Class::Accessor&lt;/code&gt; to &lt;code&gt;Moose&lt;/code&gt; easy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cba69d28533f7c1088e666571bd50781732c27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Class::Struct&lt;/code&gt; can create your class at compile time. The main reason for doing this is obvious, so your class acts like every other class in Perl. Creating your class at compile time will make the order of events similar to using any other class ( or Perl module ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9402d618b4323955fa7151700c933e1781cb7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Class::Struct&lt;/code&gt; exports a single function, &lt;code&gt;struct&lt;/code&gt; . Given a list of element names and types, and optionally a class name, &lt;code&gt;struct&lt;/code&gt; creates a Perl 5 class that implements a &quot;struct-like&quot; data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fc00057d2a2d9fb02cae29f782ec7d03780bcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Class::Tiny&lt;/code&gt; is the absolute minimal option. It has no dependencies, and almost no syntax to learn. It's a good option for a super minimal environment and for throwing something together quickly without having to worry about details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d6cd736729017df34ed5101a1c462435573300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; provides an interface to the in-memory compression/uncompression functions from the bzip2 compression library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8725a0495b722c17e9e3c10477740f81c48584e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CvGV($cv)&lt;/code&gt; return one of the globs associated to a subroutine reference $cv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57151d3af80dd94fc75fda2ca627813262903784" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DATA&lt;/code&gt; may be a reference to a list or a list. If specified the contents of &lt;code&gt;DATA&lt;/code&gt; and a termination string &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; is sent to the server. And the result will be true if the data was accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c191c78cba51d1e084cbee694f95f10d6ca9950" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DB::DB&lt;/code&gt; , &lt;code&gt;DB::sub&lt;/code&gt; , &lt;code&gt;DB::lsub&lt;/code&gt; , &lt;code&gt;DB::goto&lt;/code&gt; , &lt;code&gt;DB::postponed&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075e4f0cb45fda33f92fa95b6e40a79ce5b91179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DB::dump_trace(skip[,count])&lt;/code&gt; skips the specified number of frames and returns a list containing information about the calling frames (all of them, if &lt;code&gt;count&lt;/code&gt; is missing). Each entry is reference to a hash with keys &lt;code&gt;context&lt;/code&gt; (either &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; , or &lt;code&gt;@&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; (subroutine name, or info about &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;args&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or a reference to an array), &lt;code&gt;file&lt;/code&gt; , and &lt;code&gt;line&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b69e03ccf8a3fb70092f79bbc9b211347aa723" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DB::print_trace(FH, skip[, count[, short]])&lt;/code&gt; prints formatted info about caller frames. The last two functions may be convenient as arguments to &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc91551827219e284d49468303a5e0aa60fb1666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DBL_DIG&lt;/code&gt;&lt;code&gt;DBL_EPSILON&lt;/code&gt;&lt;code&gt;DBL_MANT_DIG&lt;/code&gt;&lt;code&gt;DBL_MAX&lt;/code&gt;&lt;code&gt;DBL_MAX_10_EXP&lt;/code&gt;&lt;code&gt;DBL_MAX_EXP&lt;/code&gt;&lt;code&gt;DBL_MIN&lt;/code&gt;&lt;code&gt;DBL_MIN_10_EXP&lt;/code&gt;&lt;code&gt;DBL_MIN_EXP&lt;/code&gt;&lt;code&gt;FLT_DIG&lt;/code&gt;&lt;code&gt;FLT_EPSILON&lt;/code&gt;&lt;code&gt;FLT_MANT_DIG&lt;/code&gt;&lt;code&gt;FLT_MAX&lt;/code&gt;&lt;code&gt;FLT_MAX_10_EXP&lt;/code&gt;&lt;code&gt;FLT_MAX_EXP&lt;/code&gt;&lt;code&gt;FLT_MIN&lt;/code&gt;&lt;code&gt;FLT_MIN_10_EXP&lt;/code&gt;&lt;code&gt;FLT_MIN_EXP&lt;/code&gt;&lt;code&gt;FLT_RADIX&lt;/code&gt;&lt;code&gt;FLT_ROUNDS&lt;/code&gt;&lt;code&gt;LDBL_DIG&lt;/code&gt;&lt;code&gt;LDBL_EPSILON&lt;/code&gt;&lt;code&gt;LDBL_MANT_DIG&lt;/code&gt;&lt;code&gt;LDBL_MAX&lt;/code&gt;&lt;code&gt;LDBL_MAX_10_EXP&lt;/code&gt;&lt;code&gt;LDBL_MAX_EXP&lt;/code&gt;&lt;code&gt;LDBL_MIN&lt;/code&gt;&lt;code&gt;LDBL_MIN_10_EXP&lt;/code&gt;&lt;code&gt;LDBL_MIN_EXP&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DBL_DIG&lt;/code&gt;&lt;code&gt;DBL_EPSILON&lt;/code&gt;&lt;code&gt;DBL_MANT_DIG&lt;/code&gt;&lt;code&gt;DBL_MAX&lt;/code&gt;&lt;code&gt;DBL_MAX_10_EXP&lt;/code&gt;&lt;code&gt;DBL_MAX_EXP&lt;/code&gt;&lt;code&gt;DBL_MIN&lt;/code&gt;&lt;code&gt;DBL_MIN_10_EXP&lt;/code&gt;&lt;code&gt;DBL_MIN_EXP&lt;/code&gt;&lt;code&gt;FLT_DIG&lt;/code&gt;&lt;code&gt;FLT_EPSILON&lt;/code&gt;&lt;code&gt;FLT_MANT_DIG&lt;/code&gt;&lt;code&gt;FLT_MAX&lt;/code&gt;&lt;code&gt;FLT_MAX_10_EXP&lt;/code&gt;&lt;code&gt;FLT_MAX_EXP&lt;/code&gt;&lt;code&gt;FLT_MIN&lt;/code&gt;&lt;code&gt;FLT_MIN_10_EXP&lt;/code&gt;&lt;code&gt;FLT_MIN_EXP&lt;/code&gt;&lt;code&gt;FLT_RADIX&lt;/code&gt;&lt;code&gt;FLT_ROUNDS&lt;/code&gt;&lt;code&gt;LDBL_DIG&lt;/code&gt;&lt;code&gt;LDBL_EPSILON&lt;/code&gt;&lt;code&gt;LDBL_MANT_DIG&lt;/code&gt;&lt;code&gt;LDBL_MAX&lt;/code&gt;&lt;code&gt;LDBL_MAX_10_EXP&lt;/code&gt;&lt;code&gt;LDBL_MAX_EXP&lt;/code&gt;&lt;code&gt;LDBL_MIN&lt;/code&gt;&lt;code&gt;LDBL_MIN_10_EXP&lt;/code&gt;&lt;code&gt;LDBL_MIN_EXP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b3719fb91a61fd372e24aedc14bb9ddcd95db3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DIRFEXT&lt;/code&gt; - the extension used for the directory file, &lt;code&gt;.dir&lt;/code&gt; everywhere but VMS, where it is &lt;code&gt;.sdbm_dir&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3555867fff7bf3b3dfb31146dcde0447b537ad4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DOES&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are similar, in that if either is true, you know that the object or class on which you call the method can perform specific behavior. However, &lt;code&gt;DOES&lt;/code&gt; is different from &lt;code&gt;isa&lt;/code&gt; in that it does not care</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327aba9e69c6dc314afbb9d3770b24a3db484053" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DOES&lt;/code&gt; checks if the object or class performs the role &lt;code&gt;ROLE&lt;/code&gt; . A role is a named group of specific behavior (often methods of particular names and signatures), similar to a class, but not necessarily a complete class by itself. For example, logging or serialization may be roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ae5f8ffa73c825371cccb10b034527e0663899" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Data::Dumper&lt;/code&gt; cheats with CODE references. If a code reference is encountered in the structure being processed (and if you haven't set the &lt;code&gt;Deparse&lt;/code&gt; flag), an anonymous subroutine that contains the string '&quot;DUMMY&quot;' will be inserted in its place, and a warning will be printed if &lt;code&gt;Purity&lt;/code&gt; is set. You can &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the result, but bear in mind that the anonymous sub that gets created is just a placeholder. Someday, perl will have a switch to cache-on-demand the string representation of a compiled piece of code, I hope. If you have prior knowledge of all the code refs that your data structures are likely to have, you can use the &lt;code&gt;Seen&lt;/code&gt; method to pre-seed the internal reference table and make the dumped output point to them, instead. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112c6262b9b29bb95ce2b06c9288ae4abb8f9636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::DProf&lt;/code&gt; produces a special file, called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c422f548b824872d70a71251455f906761cf0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::FastProf&lt;/code&gt; is another Perl line profiler. This was written with a view to getting a faster line profiler, than is possible with for example &lt;code&gt;Devel::SmallProf&lt;/code&gt; , because it's written in &lt;code&gt;C&lt;/code&gt; . To use &lt;code&gt;Devel::FastProf&lt;/code&gt; , supply the &lt;code&gt;-d&lt;/code&gt; argument to Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40154257a8b82c38bcca59cdc00939ace9931afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::FastProf&lt;/code&gt; writes statistics to the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ccdf5a561326d39cd32316fbd7ceef38fc88e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::NYTProf&lt;/code&gt; is the &lt;b&gt;next generation&lt;/b&gt; of Perl code profiler, fixing many shortcomings in other tools and implementing many cool features. First of all it can be used as either a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5797923d69aa381e05603f605d5a631ec973775" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::PPPort&lt;/code&gt; contains two functions, &lt;code&gt;WriteFile&lt;/code&gt; and &lt;code&gt;GetFileContents&lt;/code&gt; . &lt;code&gt;WriteFile&lt;/code&gt; 's only purpose is to write the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018354f48ba5b78747f51bd5947259fe8ee3715c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::PPPort&lt;/code&gt; generates a C header file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06bb951efbe313b213cf2bad4e278dbcedc8fd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::Profiler&lt;/code&gt; generates a tmon.out file which is compatible with the &lt;code&gt;dprofpp&lt;/code&gt; program, thus saving the construction of a dedicated statistics reader program. &lt;code&gt;dprofpp&lt;/code&gt; usage is therefore identical to the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8fab08ab7193519be5833e52c406d22be75acb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Devel::SmallProf&lt;/code&gt; writes it's output into a file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0825c0fbe9eac3bd9846a860cced812e78501c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Dump&lt;/code&gt; , &lt;code&gt;mstat&lt;/code&gt; , &lt;code&gt;DeadCode&lt;/code&gt; , &lt;code&gt;DumpArray&lt;/code&gt; , &lt;code&gt;DumpWithOP&lt;/code&gt; and &lt;code&gt;DumpProg&lt;/code&gt; , &lt;code&gt;fill_mstats&lt;/code&gt; , &lt;code&gt;mstats_fillhash&lt;/code&gt; , &lt;code&gt;mstats2hash&lt;/code&gt; by default. Additionally available &lt;code&gt;SvREFCNT&lt;/code&gt; , &lt;code&gt;SvREFCNT_inc&lt;/code&gt; and &lt;code&gt;SvREFCNT_dec&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c7ca6f8b76a10f9d5318c6941ff36f70c99beb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Dup&lt;/code&gt; uses &lt;code&gt;Getarg&lt;/code&gt; to retrieve the argument originally passed to &lt;code&gt;Pushed&lt;/code&gt; , so you must implement this function if your layer has an extra argument to &lt;code&gt;Pushed&lt;/code&gt; and will ever be &lt;code&gt;Dup&lt;/code&gt; ed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbfb1d06fc3039522251007d62aa0c69bf6fa5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;E&amp;lt;gt&amp;gt;&lt;/code&gt; -- a literal &amp;gt; (greater than)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab5736f8b7db61936bca7cf554720a007684208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;E&amp;lt;lt&amp;gt;&lt;/code&gt; -- a literal &amp;lt; (less than)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd01da0fa74c94e7d191b89b539691222f4b42b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; -- a literal / (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6f8bc422c538eb3aeae22e52038748fa18df75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;E&amp;lt;verbar&amp;gt;&lt;/code&gt; -- a literal | (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0f76c73d09691fd92de4db3ba41dd7d0cb9322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;E2BIG&lt;/code&gt;&lt;code&gt;EACCES&lt;/code&gt;&lt;code&gt;EADDRINUSE&lt;/code&gt;&lt;code&gt;EADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;EAFNOSUPPORT&lt;/code&gt;&lt;code&gt;EAGAIN&lt;/code&gt;&lt;code&gt;EALREADY&lt;/code&gt;&lt;code&gt;EBADF&lt;/code&gt;&lt;code&gt;EBADMSG&lt;/code&gt;&lt;code&gt;EBUSY&lt;/code&gt;&lt;code&gt;ECANCELED&lt;/code&gt;&lt;code&gt;ECHILD&lt;/code&gt;&lt;code&gt;ECONNABORTED&lt;/code&gt;&lt;code&gt;ECONNREFUSED&lt;/code&gt;&lt;code&gt;ECONNRESET&lt;/code&gt;&lt;code&gt;EDEADLK&lt;/code&gt;&lt;code&gt;EDESTADDRREQ&lt;/code&gt;&lt;code&gt;EDOM&lt;/code&gt;&lt;code&gt;EDQUOT&lt;/code&gt;&lt;code&gt;EEXIST&lt;/code&gt;&lt;code&gt;EFAULT&lt;/code&gt;&lt;code&gt;EFBIG&lt;/code&gt;&lt;code&gt;EHOSTDOWN&lt;/code&gt;&lt;code&gt;EHOSTUNREACH&lt;/code&gt;&lt;code&gt;EIDRM&lt;/code&gt;&lt;code&gt;EILSEQ&lt;/code&gt;&lt;code&gt;EINPROGRESS&lt;/code&gt;&lt;code&gt;EINTR&lt;/code&gt;&lt;code&gt;EINVAL&lt;/code&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;code&gt;EISCONN&lt;/code&gt;&lt;code&gt;EISDIR&lt;/code&gt;&lt;code&gt;ELOOP&lt;/code&gt;&lt;code&gt;EMFILE&lt;/code&gt;&lt;code&gt;EMLINK&lt;/code&gt;&lt;code&gt;EMSGSIZE&lt;/code&gt;&lt;code&gt;ENAMETOOLONG&lt;/code&gt;&lt;code&gt;ENETDOWN&lt;/code&gt;&lt;code&gt;ENETRESET&lt;/code&gt;&lt;code&gt;ENETUNREACH&lt;/code&gt;&lt;code&gt;ENFILE&lt;/code&gt;&lt;code&gt;ENOBUFS&lt;/code&gt;&lt;code&gt;ENODATA&lt;/code&gt;&lt;code&gt;ENODEV&lt;/code&gt;&lt;code&gt;ENOENT&lt;/code&gt;&lt;code&gt;ENOEXEC&lt;/code&gt;&lt;code&gt;ENOLCK&lt;/code&gt;&lt;code&gt;ENOLINK&lt;/code&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;code&gt;ENOMSG&lt;/code&gt;&lt;code&gt;ENOPROTOOPT&lt;/code&gt;&lt;code&gt;ENOSPC&lt;/code&gt;&lt;code&gt;ENOSR&lt;/code&gt;&lt;code&gt;ENOSTR&lt;/code&gt;&lt;code&gt;ENOSYS&lt;/code&gt;&lt;code&gt;ENOTBLK&lt;/code&gt;&lt;code&gt;ENOTCONN&lt;/code&gt;&lt;code&gt;ENOTDIR&lt;/code&gt;&lt;code&gt;ENOTEMPTY&lt;/code&gt;&lt;code&gt;ENOTRECOVERABLE&lt;/code&gt;&lt;code&gt;ENOTSOCK&lt;/code&gt;&lt;code&gt;ENOTSUP&lt;/code&gt;&lt;code&gt;ENOTTY&lt;/code&gt;&lt;code&gt;ENXIO&lt;/code&gt;&lt;code&gt;EOPNOTSUPP&lt;/code&gt;&lt;code&gt;EOTHER&lt;/code&gt;&lt;code&gt;EOVERFLOW&lt;/code&gt;&lt;code&gt;EOWNERDEAD&lt;/code&gt;&lt;code&gt;EPERM&lt;/code&gt;&lt;code&gt;EPFNOSUPPORT&lt;/code&gt;&lt;code&gt;EPIPE&lt;/code&gt;&lt;code&gt;EPROCLIM&lt;/code&gt;&lt;code&gt;EPROTO&lt;/code&gt;&lt;code&gt;EPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;EPROTOTYPE&lt;/code&gt;&lt;code&gt;ERANGE&lt;/code&gt;&lt;code&gt;EREMOTE&lt;/code&gt;&lt;code&gt;ERESTART&lt;/code&gt;&lt;code&gt;EROFS&lt;/code&gt;&lt;code&gt;ESHUTDOWN&lt;/code&gt;&lt;code&gt;ESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;ESPIPE&lt;/code&gt;&lt;code&gt;ESRCH&lt;/code&gt;&lt;code&gt;ESTALE&lt;/code&gt;&lt;code&gt;ETIME&lt;/code&gt;&lt;code&gt;ETIMEDOUT&lt;/code&gt;&lt;code&gt;ETOOMANYREFS&lt;/code&gt;&lt;code&gt;ETXTBSY&lt;/code&gt;&lt;code&gt;EUSERS&lt;/code&gt;&lt;code&gt;EWOULDBLOCK&lt;/code&gt;&lt;code&gt;EXDEV&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;E2BIG&lt;/code&gt;&lt;code&gt;EACCES&lt;/code&gt;&lt;code&gt;EADDRINUSE&lt;/code&gt;&lt;code&gt;EADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;EAFNOSUPPORT&lt;/code&gt;&lt;code&gt;EAGAIN&lt;/code&gt;&lt;code&gt;EALREADY&lt;/code&gt;&lt;code&gt;EBADF&lt;/code&gt;&lt;code&gt;EBADMSG&lt;/code&gt;&lt;code&gt;EBUSY&lt;/code&gt;&lt;code&gt;ECANCELED&lt;/code&gt;&lt;code&gt;ECHILD&lt;/code&gt;&lt;code&gt;ECONNABORTED&lt;/code&gt;&lt;code&gt;ECONNREFUSED&lt;/code&gt;&lt;code&gt;ECONNRESET&lt;/code&gt;&lt;code&gt;EDEADLK&lt;/code&gt;&lt;code&gt;EDESTADDRREQ&lt;/code&gt;&lt;code&gt;EDOM&lt;/code&gt;&lt;code&gt;EDQUOT&lt;/code&gt;&lt;code&gt;EEXIST&lt;/code&gt;&lt;code&gt;EFAULT&lt;/code&gt;&lt;code&gt;EFBIG&lt;/code&gt;&lt;code&gt;EHOSTDOWN&lt;/code&gt;&lt;code&gt;EHOSTUNREACH&lt;/code&gt;&lt;code&gt;EIDRM&lt;/code&gt;&lt;code&gt;EILSEQ&lt;/code&gt;&lt;code&gt;EINPROGRESS&lt;/code&gt;&lt;code&gt;EINTR&lt;/code&gt;&lt;code&gt;EINVAL&lt;/code&gt;&lt;code&gt;EIO&lt;/code&gt;&lt;code&gt;EISCONN&lt;/code&gt;&lt;code&gt;EISDIR&lt;/code&gt;&lt;code&gt;ELOOP&lt;/code&gt;&lt;code&gt;EMFILE&lt;/code&gt;&lt;code&gt;EMLINK&lt;/code&gt;&lt;code&gt;EMSGSIZE&lt;/code&gt;&lt;code&gt;ENAMETOOLONG&lt;/code&gt;&lt;code&gt;ENETDOWN&lt;/code&gt;&lt;code&gt;ENETRESET&lt;/code&gt;&lt;code&gt;ENETUNREACH&lt;/code&gt;&lt;code&gt;ENFILE&lt;/code&gt;&lt;code&gt;ENOBUFS&lt;/code&gt;&lt;code&gt;ENODATA&lt;/code&gt;&lt;code&gt;ENODEV&lt;/code&gt;&lt;code&gt;ENOENT&lt;/code&gt;&lt;code&gt;ENOEXEC&lt;/code&gt;&lt;code&gt;ENOLCK&lt;/code&gt;&lt;code&gt;ENOLINK&lt;/code&gt;&lt;code&gt;ENOMEM&lt;/code&gt;&lt;code&gt;ENOMSG&lt;/code&gt;&lt;code&gt;ENOPROTOOPT&lt;/code&gt;&lt;code&gt;ENOSPC&lt;/code&gt;&lt;code&gt;ENOSR&lt;/code&gt;&lt;code&gt;ENOSTR&lt;/code&gt;&lt;code&gt;ENOSYS&lt;/code&gt;&lt;code&gt;ENOTBLK&lt;/code&gt;&lt;code&gt;ENOTCONN&lt;/code&gt;&lt;code&gt;ENOTDIR&lt;/code&gt;&lt;code&gt;ENOTEMPTY&lt;/code&gt;&lt;code&gt;ENOTRECOVERABLE&lt;/code&gt;&lt;code&gt;ENOTSOCK&lt;/code&gt;&lt;code&gt;ENOTSUP&lt;/code&gt;&lt;code&gt;ENOTTY&lt;/code&gt;&lt;code&gt;ENXIO&lt;/code&gt;&lt;code&gt;EOPNOTSUPP&lt;/code&gt;&lt;code&gt;EOTHER&lt;/code&gt;&lt;code&gt;EOVERFLOW&lt;/code&gt;&lt;code&gt;EOWNERDEAD&lt;/code&gt;&lt;code&gt;EPERM&lt;/code&gt;&lt;code&gt;EPFNOSUPPORT&lt;/code&gt;&lt;code&gt;EPIPE&lt;/code&gt;&lt;code&gt;EPROCLIM&lt;/code&gt;&lt;code&gt;EPROTO&lt;/code&gt;&lt;code&gt;EPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;EPROTOTYPE&lt;/code&gt;&lt;code&gt;ERANGE&lt;/code&gt;&lt;code&gt;EREMOTE&lt;/code&gt;&lt;code&gt;ERESTART&lt;/code&gt;&lt;code&gt;EROFS&lt;/code&gt;&lt;code&gt;ESHUTDOWN&lt;/code&gt;&lt;code&gt;ESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;ESPIPE&lt;/code&gt;&lt;code&gt;ESRCH&lt;/code&gt;&lt;code&gt;ESTALE&lt;/code&gt;&lt;code&gt;ETIME&lt;/code&gt;&lt;code&gt;ETIMEDOUT&lt;/code&gt;&lt;code&gt;ETOOMANYREFS&lt;/code&gt;&lt;code&gt;ETXTBSY&lt;/code&gt;&lt;code&gt;EUSERS&lt;/code&gt;&lt;code&gt;EWOULDBLOCK&lt;/code&gt;&lt;code&gt;EXDEV&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066e414ca2cf611148c4eaa3ea046c8780dfdec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ECHO&lt;/code&gt;&lt;code&gt;ECHOE&lt;/code&gt;&lt;code&gt;ECHOK&lt;/code&gt;&lt;code&gt;ECHONL&lt;/code&gt;&lt;code&gt;ICANON&lt;/code&gt;&lt;code&gt;IEXTEN&lt;/code&gt;&lt;code&gt;ISIG&lt;/code&gt;&lt;code&gt;NOFLSH&lt;/code&gt;&lt;code&gt;TOSTOP&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ECHO&lt;/code&gt;&lt;code&gt;ECHOE&lt;/code&gt;&lt;code&gt;ECHOK&lt;/code&gt;&lt;code&gt;ECHONL&lt;/code&gt;&lt;code&gt;ICANON&lt;/code&gt;&lt;code&gt;IEXTEN&lt;/code&gt;&lt;code&gt;ISIG&lt;/code&gt;&lt;code&gt;NOFLSH&lt;/code&gt;&lt;code&gt;TOSTOP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe83a5d58b657664921e554e17730ddbd2574a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; localise a block of code - they make sure that all variables are tidied up, everything that has been localised gets its previous value returned, and so on. Think of them as the &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; of a Perl block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a8af2f6135bd8dc2ab3b9aec3837519c83b6b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXIT_FAILURE&lt;/code&gt;&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;&lt;code&gt;MB_CUR_MAX&lt;/code&gt;&lt;code&gt;RAND_MAX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EXIT_FAILURE&lt;/code&gt;&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;&lt;code&gt;MB_CUR_MAX&lt;/code&gt;&lt;code&gt;RAND_MAX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="605c0049ae6513fbc634a4505a4d59b4c8b6360e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Errno&lt;/code&gt; also makes &lt;code&gt;%!&lt;/code&gt; magic such that each element of &lt;code&gt;%!&lt;/code&gt; has a non-zero value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8723a06751f4affdad686aeca30d6d66626d33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Errno&lt;/code&gt; defines and conditionally exports all the error constants defined in your system &lt;code&gt;errno.h&lt;/code&gt; include file. It has a single export tag, &lt;code&gt;:POSIX&lt;/code&gt; , which will export all POSIX defined error numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1cc0e4d1cb179935b0274da71cd837a55e146a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exporter&lt;/code&gt; is definitely not the only module with symbol exporter capabilities. At CPAN, you may find a bunch of them. Some are lighter. Some provide improved APIs and features. Pick the one that fits your needs. The following is a sample list of such modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad37da909ccfa2e26ad205000545574039f2e3e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExtUtils::Embed&lt;/code&gt; exports the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095ec01183ac1e1d6ca1341429cec2f459043f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExtUtils::Embed&lt;/code&gt; provides utility functions for embedding a Perl interpreter and extensions in your C/C++ applications. Typically, an application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d2ca71037114349d1ec282c3de1a1216361065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; produces files used by the linker under some OSs during the creation of shared libraries for dynamic extensions. It is normally called from a MakeMaker-generated Makefile when the extension is built. The linker option file is generated by calling the function &lt;code&gt;Mksymlists&lt;/code&gt; , which is exported by default from &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; . It takes one argument, a list of key-value pairs, in which the following keys are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb003f490e341e53319aa009e2735722b16763d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions. The compiler uses typemaps to determine how to map C function parameters and variables to Perl values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2053c192b87e9cd9de753eaf699903f70648eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;F&lt;/code&gt; packs an &lt;code&gt;NV&lt;/code&gt; , which is the floating point type used by Perl internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ff85342a730577020c88364b60274499bd7643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FAULT&lt;/code&gt; means that you never expect to call the function in scalar (or list) context, and that if &lt;code&gt;Memoize&lt;/code&gt; detects such a call, it should abort the program. The error message is one of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593b33d10d7aff28fb80e58f50c81f1f8eb33924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FD_CLOEXEC&lt;/code&gt;&lt;code&gt;F_DUPFD&lt;/code&gt;&lt;code&gt;F_GETFD&lt;/code&gt;&lt;code&gt;F_GETFL&lt;/code&gt;&lt;code&gt;F_GETLK&lt;/code&gt;&lt;code&gt;F_OK&lt;/code&gt;&lt;code&gt;F_RDLCK&lt;/code&gt;&lt;code&gt;F_SETFD&lt;/code&gt;&lt;code&gt;F_SETFL&lt;/code&gt;&lt;code&gt;F_SETLK&lt;/code&gt;&lt;code&gt;F_SETLKW&lt;/code&gt;&lt;code&gt;F_UNLCK&lt;/code&gt;&lt;code&gt;F_WRLCK&lt;/code&gt;&lt;code&gt;O_ACCMODE&lt;/code&gt;&lt;code&gt;O_APPEND&lt;/code&gt;&lt;code&gt;O_CREAT&lt;/code&gt;&lt;code&gt;O_EXCL&lt;/code&gt;&lt;code&gt;O_NOCTTY&lt;/code&gt;&lt;code&gt;O_NONBLOCK&lt;/code&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;code&gt;O_RDWR&lt;/code&gt;&lt;code&gt;O_TRUNC&lt;/code&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FD_CLOEXEC&lt;/code&gt;&lt;code&gt;F_DUPFD&lt;/code&gt;&lt;code&gt;F_GETFD&lt;/code&gt;&lt;code&gt;F_GETFL&lt;/code&gt;&lt;code&gt;F_GETLK&lt;/code&gt;&lt;code&gt;F_OK&lt;/code&gt;&lt;code&gt;F_RDLCK&lt;/code&gt;&lt;code&gt;F_SETFD&lt;/code&gt;&lt;code&gt;F_SETFL&lt;/code&gt;&lt;code&gt;F_SETLK&lt;/code&gt;&lt;code&gt;F_SETLKW&lt;/code&gt;&lt;code&gt;F_UNLCK&lt;/code&gt;&lt;code&gt;F_WRLCK&lt;/code&gt;&lt;code&gt;O_ACCMODE&lt;/code&gt;&lt;code&gt;O_APPEND&lt;/code&gt;&lt;code&gt;O_CREAT&lt;/code&gt;&lt;code&gt;O_EXCL&lt;/code&gt;&lt;code&gt;O_NOCTTY&lt;/code&gt;&lt;code&gt;O_NONBLOCK&lt;/code&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;code&gt;O_RDWR&lt;/code&gt;&lt;code&gt;O_TRUNC&lt;/code&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a95b90939671fa2f4ef6a0875777e47ba033a12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FE_DOWNWARD&lt;/code&gt;&lt;code&gt;FE_TONEAREST&lt;/code&gt;&lt;code&gt;FE_TOWARDZERO&lt;/code&gt;&lt;code&gt;FE_UPWARD&lt;/code&gt; on systems that support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586830fc1c312d09452cbf05bb392121d4a4d3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FE_TONEAREST&lt;/code&gt; is like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;, &lt;code&gt;FE_TOWARDZERO&lt;/code&gt; is like &lt;a href=&quot;#trunc&quot;&gt;trunc&lt;/a&gt; [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79284936684717b45799224f65c1741c4f9ad4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILE&lt;/code&gt; . It will generate one on each call and push a new stdio layer. So don't call it repeatedly on the same file. &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will retrieve the stdio layer once it has been generated by &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a48df125b434d844372c25a7cae987e2df5288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILTER_ONLY&lt;/code&gt; takes a sequence of specifiers that install separate (and possibly multiple) filters that act on only parts of the source code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d138ad5224141350319092d75597c48fba6ef1a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FP_ILOGB0&lt;/code&gt;&lt;code&gt;FP_ILOGBNAN&lt;/code&gt;&lt;code&gt;FP_INFINITE&lt;/code&gt;&lt;code&gt;FP_NAN&lt;/code&gt;&lt;code&gt;FP_NORMAL&lt;/code&gt;&lt;code&gt;FP_SUBNORMAL&lt;/code&gt;&lt;code&gt;FP_ZERO&lt;/code&gt;&lt;code&gt;INFINITY&lt;/code&gt;&lt;code&gt;NAN&lt;/code&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;code&gt;M_1_PI&lt;/code&gt;&lt;code&gt;M_2_PI&lt;/code&gt;&lt;code&gt;M_2_SQRTPI&lt;/code&gt;&lt;code&gt;M_E&lt;/code&gt;&lt;code&gt;M_LN10&lt;/code&gt;&lt;code&gt;M_LN2&lt;/code&gt;&lt;code&gt;M_LOG10E&lt;/code&gt;&lt;code&gt;M_LOG2E&lt;/code&gt;&lt;code&gt;M_PI&lt;/code&gt;&lt;code&gt;M_PI_2&lt;/code&gt;&lt;code&gt;M_PI_4&lt;/code&gt;&lt;code&gt;M_SQRT1_2&lt;/code&gt;&lt;code&gt;M_SQRT2&lt;/code&gt; on systems with C99 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5914c8ad1ae38c828bbfd3aecb0f6eeb99e7051a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fatal&lt;/code&gt; clobbers the context in which a function is called and always makes it a scalar context, except when the &lt;code&gt;:void&lt;/code&gt; tag is used. This problem does not exist in &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740df548a189ece2edf4fd0c968a33bedfb05cdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Fatal&lt;/code&gt; provides a way to conveniently replace functions which normally return a false value when they fail with equivalents which raise exceptions if they are not successful. This lets you use these functions without having to test their return values explicitly on each call. Exceptions can be caught using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c009d428e974071ae1eba2560f4e3bf7b63b8111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::Fetch&lt;/code&gt; currently only supports proxies with LWP::UserAgent. You will need to set your environment variables accordingly. For example, to use an ftp proxy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512e6b725fa0815ed1040c15e359675815185001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::Fetch&lt;/code&gt; is relatively smart about things. When trying to write a file to disk, it removes the &lt;code&gt;query parameters&lt;/code&gt; (see the &lt;code&gt;output_file&lt;/code&gt; method for details) from the file name before creating it. In most cases this suffices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4909eac8bb27d566be5a1e97826bcb6d6ddbfad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::GlobMapper&lt;/code&gt; has been kept simple deliberately, so it isn't intended to solve all filename mapping operations. Under the hood &lt;code&gt;File::Glob&lt;/code&gt; (or for older versions of Perl, &lt;code&gt;File::BSDGlob&lt;/code&gt; ) is used to match the files, so you will never have the flexibility of full Perl regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96810d8a56c73c1a6b5cbdf2dd4d391587af778" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::Path&lt;/code&gt; blindly exports &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; into the current namespace. These days, this is considered bad style, but to change it now would break too much code. Nonetheless, you are invited to specify what it is you are expecting to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f095bddf521d070185d41c8d087a14cb54a167a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::Spec&lt;/code&gt; is available in the standard distribution as of version 5.004_05. &lt;code&gt;File::Spec::Functions&lt;/code&gt; is only in &lt;code&gt;File::Spec&lt;/code&gt; 0.7 and later, and some versions of Perl come with version 0.6. If &lt;code&gt;File::Spec&lt;/code&gt; is not updated to 0.7 or later, you must use the object-oriented interface from &lt;code&gt;File::Spec&lt;/code&gt; (or upgrade &lt;code&gt;File::Spec&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cef216bb5c87c8ac2becb4baf424b0884bc7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File::Temp&lt;/code&gt; can be used to create and open temporary files in a safe way. There is both a function interface and an object-oriented interface. The File::Temp constructor or the tempfile() function can be used to return the name and the open filehandle of a temporary file. The tempdir() function can be used to create a temporary directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8558d37d33da0f50296d5712fa3cb21fddb903f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File&lt;/code&gt; is a &lt;b&gt;superclass&lt;/b&gt; of &lt;code&gt;File::MP3&lt;/code&gt; , and &lt;code&gt;File::MP3&lt;/code&gt; is a &lt;b&gt;subclass&lt;/b&gt; of &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6762671e9c43ce6002652e67bfefcf6a5cd02a7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileHandle::fdopen&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, a FileHandle object, or a file descriptor number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf43c6bdb788ed60b52a38acf298d9b6cfa527d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileHandle::new&lt;/code&gt; creates a &lt;code&gt;FileHandle&lt;/code&gt; , which is a reference to a newly created symbol (see the &lt;code&gt;Symbol&lt;/code&gt; package). If it receives any parameters, they are passed to &lt;code&gt;FileHandle::open&lt;/code&gt; ; if the open fails, the &lt;code&gt;FileHandle&lt;/code&gt; object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159fd7914013643c7a2e528eb234604b29dc9ae3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileHandle::new_from_fd&lt;/code&gt; creates a &lt;code&gt;FileHandle&lt;/code&gt; like &lt;code&gt;new&lt;/code&gt; does. It requires two parameters, which are passed to &lt;code&gt;FileHandle::fdopen&lt;/code&gt; ; if the fdopen fails, the &lt;code&gt;FileHandle&lt;/code&gt; object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34df48f6115c1c0a13e4731820d5124ecd1a9681" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileHandle::open&lt;/code&gt; accepts one parameter or two. With one parameter, it is just a front end for the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function. With two parameters, the first parameter is a filename that may include whitespace or other special characters, and the second parameter is the open mode, optionally followed by a file permission value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c84e89afe3961306a15f3cf682c3985e27fc10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetFileContents&lt;/code&gt; behaves like &lt;code&gt;WriteFile&lt;/code&gt; above, but returns the contents of the would-be file rather than writing it out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea3c82b309767ea7a2165759e9837e13524a01e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetFileContents&lt;/code&gt; can be used to retrieve the file contents rather than writing it out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad777db936a77fb5cda72b69a2424837a3dead8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Getopt::Long&lt;/code&gt; upgraded to version 2.35</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645ac4cb7e7a0e4213f8a71c7bffc87052ad8695" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HASH&lt;/code&gt; allows you to specify that a particular hash that you supply will be used as the cache. You can tie this hash beforehand to give it any behavior you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f7a794ce300f67c1868cdef889a2449308b6e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HOST&lt;/code&gt; is optional. If &lt;code&gt;HOST&lt;/code&gt; is not given then it may instead be passed as the &lt;code&gt;Host&lt;/code&gt; option described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bea88b5fbb79a39447dd7dee6828fe13741dd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HOST&lt;/code&gt; is optional. If &lt;code&gt;HOST&lt;/code&gt; is not given then it may instead be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If neither is given then the &lt;code&gt;POP3_Hosts&lt;/code&gt; specified in &lt;code&gt;Net::Config&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef5e2b3a132260f1a90da7111d14884da83c5f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HOST&lt;/code&gt; is optional. If &lt;code&gt;HOST&lt;/code&gt; is not given then it may instead be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If neither is given then the &lt;code&gt;SMTP_Hosts&lt;/code&gt; specified in &lt;code&gt;Net::Config&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e137f247fee18cceb87509d47cf2081b7b55b920" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; addresses these issues on several levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60ded3e01c5263ba32e63f38adc7c79d39cfd47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; offers a number of functions in support of &lt;a href=&quot;#The-Inside-out-Technique&quot;&gt;The Inside-out Technique&lt;/a&gt; of class construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d63c605b89445d7ec7678a1b23fa305e23d9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hash::Util&lt;/code&gt; and &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; contain special functions for manipulating hashes that don't really warrant a keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c547e32204db6e5f3d81ca13c7bb8402e0a164" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hash::Util&lt;/code&gt; contains a set of functions that support &lt;a href=&quot;#Restricted-hashes&quot;&gt;restricted hashes&lt;/a&gt;. These are described in this document. &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; contains an (unrelated) set of functions that support the use of hashes in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8136f764d1a688860eb12b8f894dd5ef02bf2211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INIT&lt;/code&gt; blocks are run just before the Perl runtime begins execution, in &quot;first in, first out&quot; (FIFO) order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049029b01299e7df2890b6b0dfade6fe1eb0300f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INSTALLDIRS&lt;/code&gt; =vendor or equivalent. See &lt;code&gt;INSTALL&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0fffaa1deb24214806a0db486b288afec1012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Dir&lt;/code&gt; also provides an interface to reading directories via a tied hash. The tied hash extends the interface beyond just the directory reading routines by the use of &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, from the &lt;code&gt;File::stat&lt;/code&gt; package, &lt;code&gt;&lt;a href=&quot;../functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cd121c621a4892a83a568405af04eb41cfd019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::File&lt;/code&gt; inherits from &lt;code&gt;IO::Handle&lt;/code&gt; and &lt;code&gt;IO::Seekable&lt;/code&gt; . It extends these classes with methods that are specific to file handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181d096ff73f80c5fefbd49a6a2ace18cb883e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Handle&lt;/code&gt; is the base class for all other IO handle classes. It is not intended that objects of &lt;code&gt;IO::Handle&lt;/code&gt; would be created directly, but instead &lt;code&gt;IO::Handle&lt;/code&gt; is inherited from by several other classes in the IO hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d968d8f7d184fabf28c8b22db7363ce4a8a51514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Pipe&lt;/code&gt; provides an interface to creating pipes between processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121507ef92369be28eeae4949c989ca1be6ada6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Poll&lt;/code&gt; is a simple interface to the system level poll routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b762583822e0aaee851ce4fa15cdffd15a962862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Seekable&lt;/code&gt; does not have a constructor of its own as it is intended to be inherited by other &lt;code&gt;IO::Handle&lt;/code&gt; based objects. It provides methods which allow seeking of the file descriptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1b75ece72a66c0d61b6aa7b994a4cee97c3529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Socket::INET&lt;/code&gt; provides an object interface to creating and using sockets in the AF_INET domain. It is built upon the &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt; interface and inherits all the methods defined by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac39f2a91093d9b2c233aa1a1fa7511814ecbb5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides an object interface to creating and using sockets in the AF_UNIX domain. It is built upon the &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt; interface and inherits all the methods defined by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cce9491bc1ee060453ba6f15ad058333b7daa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Socket&lt;/code&gt; only defines methods for those operations which are common to all types of socket. Operations which are specified to a socket in a particular domain have methods defined in sub classes of &lt;code&gt;IO::Socket&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4122d764f9adaaacb15138a9de4abe82a136c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Socket&lt;/code&gt; provides an object interface to creating and using sockets. It is built upon the &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt; interface and inherits all the methods defined by &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8213ac1eede062f215203877643d19e45fea00f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Socket&lt;/code&gt; will export all functions (and constants) defined by &lt;a href=&quot;../socket&quot;&gt;Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd83dcf6db900152f50ebff530a4285e2ee66534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO::Zlib&lt;/code&gt; provides an IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt; and hence to gzip/zlib compressed files. It provides many of the same methods as the &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d042d00c63eebc013a6991f1938ad31a79350e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO&lt;/code&gt; provides a simple mechanism to load several of the IO modules in one go. The IO modules belonging to the core are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b3396d21c463d28843aca7f77f27ca180d2d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IPC::SysV&lt;/code&gt; defines and conditionally exports all the constants defined in your system include files which are needed by the SysV IPC calls. Common ones include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1562c285ab3451fd66d7a87fd5d4aa1e870611f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ITIMER_PROF&lt;/code&gt; counts time when either the process virtual time or when the operating system is running on behalf of the process (such as I/O). (This time is also known as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916bb6dbaa0ac1eb30ba18d51c95fd8868d21c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ITIMER_REAL&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. Time is counted in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3514de407012b9ae61544516605c3b826d3bb18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; counts time in (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6ee03b655d23ae15f7f2e38af35133c2a4bc9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KEY&lt;/code&gt; does not already have a message queue associated with it, and &lt;code&gt;&lt;i&gt;FLAGS&lt;/i&gt; &amp;amp; IPC_CREAT&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5066360834717c79b8e3ffa4cb0f67c9b492685" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KEY&lt;/code&gt; does not already have a semaphore identifier associated with it, and &lt;code&gt;&lt;i&gt;FLAGS&lt;/i&gt; &amp;amp; IPC_CREAT&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207e986bdced98f163af9eb0b72ea2467c1786de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KEY&lt;/code&gt; does not already have a shared memory segment associated with it, and &lt;code&gt;&lt;i&gt;FLAGS&lt;/i&gt; &amp;amp; IPC_CREAT&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd4729fb1227e456d3b0559a1c30aa293feb4dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KEY&lt;/code&gt; is equal to &lt;code&gt;IPC_PRIVATE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424cc25eb593661c978d8429628c32197f526490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&amp;lt;/&quot;sec&quot;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;/sec&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c6e0dffc5ce09a6e54b619b6e6a27123a96c0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&amp;lt;name/&quot;sec&quot;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;name/sec&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cfda930437215fcc4324e241d8c8fa32a8d9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&amp;lt;text|/&quot;sec&quot;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;text|/sec&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;text|&quot;sec&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469caa270c3821b85844c5da0bf1d2d3e7023d6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&amp;lt;text|name/&quot;sec&quot;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;text|name/sec&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6362a82e5577816d56f0e78605608fc1269151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LANG&lt;/code&gt; is the &quot;catch-all&quot; locale environment variable. If it is set, it is used as the last resort after the overall &lt;code&gt;LC_ALL&lt;/code&gt; and the category-specific &lt;code&gt;LC_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe0cb20951383c21785bc33780d8bd2ac85ed7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LC_ALL&lt;/code&gt; is the &quot;override-all&quot; locale environment variable. If set, it overrides all the rest of the locale environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a605bd93ba14e29e4f244383a9eb2e02ef1549c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LC_ALL&lt;/code&gt;&lt;code&gt;LC_COLLATE&lt;/code&gt;&lt;code&gt;LC_CTYPE&lt;/code&gt;&lt;code&gt;LC_MONETARY&lt;/code&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;code&gt;LC_TIME&lt;/code&gt;&lt;code&gt;LC_MESSAGES&lt;/code&gt; on systems that support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb846da3ade953702217e651317e4e13b66b385" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LDLOADLIBS&lt;/code&gt; is an environment variable used by the linker to link modules &lt;code&gt;/ext&lt;/code&gt; modules to glibc. Currently, that environment variable is not getting populated by a combination of &lt;code&gt;Config&lt;/code&gt; entries and &lt;code&gt;ExtUtil::MakeMaker&lt;/code&gt; . While there may be a bug somewhere in Perl's configuration or &lt;code&gt;ExtUtil::MakeMaker&lt;/code&gt; causing the problem, the most likely cause is an incomplete understanding of Sun Studio by this author. Further investigation is needed to get this working better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b9a4de9a3ae26621d0664f9d7809fc1540d360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_ALERT&lt;/code&gt; - action must be taken immediately</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237f0827d3b068adf7a9e035db022146d0403fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_AUDIT&lt;/code&gt; - audit daemon (IRIX); falls back to &lt;code&gt;LOG_AUTH&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42cb5530d45add6db1cc3521ca69ba4aa90a4c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_AUTH&lt;/code&gt; - security/authorization messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbcebef65476f32b381cbd6c89052eca4c688cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_AUTHPRIV&lt;/code&gt; - security/authorization messages (private)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c8e15153bb0c1370176e3d28f81ed1595261c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_CONSOLE&lt;/code&gt; - &lt;code&gt;/dev/console&lt;/code&gt; output (FreeBSD); falls back to &lt;code&gt;LOG_USER&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e27b059f195281b93d28d6c22b89428b572bc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_CRIT&lt;/code&gt; - critical conditions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba52df2842e88f76f3ea0623ac07d547b385a40d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_CRON&lt;/code&gt; - clock daemons (&lt;b&gt;cron&lt;/b&gt; and &lt;b&gt;at&lt;/b&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbc2c1ef0a0587ee5b98f17edb40e479195a525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_DAEMON&lt;/code&gt; - system daemons without separate facility value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db33909f631279fc62be328b4a3cd8cd3c40aa86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_DEBUG&lt;/code&gt; - debug-level message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547e87ee1a00b634dd9ca9748f7b928c07f9c109" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_EMERG&lt;/code&gt; - system is unusable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f38a55790519e7289c11e43a4b3e68d8bf1ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_ERR&lt;/code&gt; - error conditions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923dddf491efec34b2f743e971b8ab73b788823c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_FTP&lt;/code&gt; - FTP daemon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2810346d0bc86bf8fd5e7cc51a029ebc1866a38a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_INFO&lt;/code&gt; - informational message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810d439031214499a1a46da8644f07fba574bb75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_INSTALL&lt;/code&gt; - installer subsystem (Mac OS X); falls back to &lt;code&gt;LOG_USER&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72f3a1f407764857c6cbddf292afebce5708e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_KERN&lt;/code&gt; - kernel messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145dd6e7d02588995730762df479040434b90e87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_LAUNCHD&lt;/code&gt; - launchd - general bootstrap daemon (Mac OS X); falls back to &lt;code&gt;LOG_DAEMON&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214ec5d4b6bc561d6ad7defc22b80f3e2275f46e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_LFMT&lt;/code&gt; - logalert facility; falls back to &lt;code&gt;LOG_USER&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9e78f2c8460f654b3f822d56b4a20c7f97a05c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_LOCAL0&lt;/code&gt; through &lt;code&gt;LOG_LOCAL7&lt;/code&gt; - reserved for local use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d106db2a7093dbbcdde8fcb1a2d6d87e9b01b80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_LPR&lt;/code&gt; - line printer subsystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9ecbaae62209484725350ec9107688a7090a3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_MAIL&lt;/code&gt; - mail subsystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a0b196a5afe3c65a5416f6289f9e5ab591cf16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_NETINFO&lt;/code&gt; - NetInfo subsystem (Mac OS X); falls back to &lt;code&gt;LOG_DAEMON&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43420fd0cb94acf50948f76eec025cbaa77e17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_NEWS&lt;/code&gt; - USENET news subsystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec24d33b2ae9e7047498fb9e3d3584709723001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_NOTICE&lt;/code&gt; - normal, but significant, condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a5a7e6bfe7417ec509bcbeaa879f188f7d835f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_NTP&lt;/code&gt; - NTP subsystem (FreeBSD, NetBSD); falls back to &lt;code&gt;LOG_DAEMON&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ed9c91dc90bf6651bc34dcf127ecc62698e74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_RAS&lt;/code&gt; - Remote Access Service (VPN / PPP) (Mac OS X); falls back to &lt;code&gt;LOG_AUTH&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1370c52935d36881489c690df052afe5808f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_REMOTEAUTH&lt;/code&gt; - remote authentication/authorization (Mac OS X); falls back to &lt;code&gt;LOG_AUTH&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ed180210288ab3e370d1a6d5c442e1922fb0b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_SECURITY&lt;/code&gt; - security subsystems (firewalling, etc.) (FreeBSD); falls back to &lt;code&gt;LOG_AUTH&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250b3c4116937e10b2dd4bb886f3a9692745b1a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_SYSLOG&lt;/code&gt; - messages generated internally by &lt;b&gt;syslogd&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5693d6936c597501156c3bfbaa61d338dc924d55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_USER&lt;/code&gt; (default) - generic user-level messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b501add985d47c9765f5bd1b490e959970b698de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_UUCP&lt;/code&gt; - UUCP subsystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3014983e7b8fc4728dedbc24c3bba2111d82a818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_WARNING&lt;/code&gt; - warning conditions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1433a08249bc65ea23ef55820e06c9d207bedd84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LaTeX&lt;/code&gt; docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ef25139769a76305576be8c28dfb5626feb920" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List::Util::XS&lt;/code&gt; can be used as a dependency to ensure List::Util was installed using a C compiler and that the XS version is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6594b32e1bb13da602c72066748f19da6777cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List::Util&lt;/code&gt; contains a selection of subroutines that people have expressed would be nice to have in the perl core, but the usage would not really be high enough to warrant the use of a keyword, and the size so small such that being individual extensions would be wasteful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caed75c6b696cf9b38470cf4de8d8d2a229b0fa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MEMORY&lt;/code&gt; means that return values from the function will be cached in an ordinary Perl hash variable. The hash variable will not persist after the program exits. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f95b732cd622ecaa5f9f2a904a2e8c470bada2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MERGE&lt;/code&gt; normally means that the memoized function does not distinguish between list and sclar context, and that return values in both contexts should be stored together. Both &lt;code&gt;LIST_CACHE =&amp;gt;
MERGE&lt;/code&gt; and &lt;code&gt;SCALAR_CACHE =&amp;gt; MERGE&lt;/code&gt; mean the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591b83ff43053b950080d0a4ce9c5949d6f3c019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is either a single message-id, a single message number, or a reference to a list of two message numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4436b9064bf3c37f88daa98294a385d8b90cd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MESSAGE&lt;/code&gt; can be either an array of lines or a reference to an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e653378310d2f1452e27b8ec6a9a29dcc48a85bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODE&lt;/code&gt; is optional; the default is &lt;code&gt;LOCK_EX&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54cc55c9fcc474e1b57012d8a54afe281f15b529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; has to return a list of all &quot;bad attributes&quot;. If there are any bad attributes &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9365cb8b2d631f82760b183dda9cef7c6a3f7bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MSGNUM&lt;/code&gt; is a numeric id of an article in the current newsgroup, and will change the current article pointer. &lt;code&gt;MSGID&lt;/code&gt; is the message id of an article as shown in that article's header. It is anticipated that the client will obtain the &lt;code&gt;MSGID&lt;/code&gt; from a list provided by the &lt;code&gt;newnews&lt;/code&gt; command, from references contained within another article, or from the message-id provided in the response to some other commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b82f8a8dfe207b711438bcea7b057597e325f09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math::BigFloat&lt;/code&gt; exports nothing by default, but can export the &lt;code&gt;bpi()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb8ec3365756417fe447a7e9bec6396a236661f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math::BigInt&lt;/code&gt; exports nothing by default, but can export the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86796664240378317064dfe323481f8be1c41b3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math::Trig&lt;/code&gt; defines many trigonometric functions not defined by the core Perl which defines only the &lt;code&gt;&lt;a href=&quot;../functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt;. The constant &lt;b&gt;pi&lt;/b&gt; is also defined as are a few convenience functions for angle conversions, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bc5499f96f8d490fa45681e115f5659299bf42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Module::Load&lt;/code&gt; cannot do implicit imports, only explicit imports. (in other words, you always have to specify explicitly what you wish to import from a module, even if the functions are in that modules' &lt;code&gt;@EXPORT&lt;/code&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90453d3a96e2d1be5968891ad0e49d8b22e92f79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Module::Load&lt;/code&gt; eliminates the need for this overhead and will just DWYM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74208c2657c1b301aa548767a2ba31ea449e885f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Module::Load&lt;/code&gt; eliminates the need to know whether you are trying to require either a file or a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5481b4ff4d996da71a1f92b3cdbdc34272a5f78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Module::Load&lt;/code&gt; imports the two functions - &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;autoload&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7473e15d5603885d58a7bd80f8714e73bf8218f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moo&lt;/code&gt; does not implement most of &lt;code&gt;Moose&lt;/code&gt; 's introspection API, so it's often faster when loading your modules. Additionally, none of its dependencies require XS, so it can be installed on machines without a compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1aeb4ab86751cc99266670857f5c4535affec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; also has several dependencies on other modules. Most of these are small stand-alone modules, a number of which have been spun off from &lt;code&gt;Moose&lt;/code&gt; . &lt;code&gt;Moose&lt;/code&gt; itself, and some of its dependencies, require a compiler. If you need to install your software on a system without a compiler, or if having</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236ade4b13836c1f86dfc2aa8501e99d8d969296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; can make your code slower to load. &lt;code&gt;Moose&lt;/code&gt; itself is not small, and it does a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a89c86bfe3cc38e7ff728cc8fb18a11f892bbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; describes itself using its own introspection API. Besides being a cool trick, this means that you can extend &lt;code&gt;Moose&lt;/code&gt; using &lt;code&gt;Moose&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b75944d26f71c7f1f78e35ade72b0fdfacfa23b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; is a very powerful tool, and we can't cover all of its features here. We encourage you to learn more by reading the &lt;code&gt;Moose&lt;/code&gt; documentation, starting with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fperldoc%3fMoose%3a%3aManual&quot;&gt;Moose::Manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad6b90e9460494e0239b0e0b30a64740a8f84e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; is the maximal option. It has a lot of features, a big ecosystem, and a thriving user base. We also covered &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; briefly. &lt;code&gt;Moo&lt;/code&gt; is &lt;code&gt;Moose&lt;/code&gt; lite, and a reasonable alternative when Moose doesn't work for your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69708ad78153d7b9062269d7ac8687dc72ab47ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; lets you define roles the same way you define classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59d283b9fa45eb6da20d38a50354a5f65a3e45d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; provides a complete, modern OO system. Its biggest influence is the Common Lisp Object System, but it also borrows ideas from Smalltalk and several other languages. &lt;code&gt;Moose&lt;/code&gt; was created by Stevan Little, and draws heavily from his work on the Perl 6 OO design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21aebae246ecd61c624d79bdc52a34c79b45d7da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; provides a layer of declarative &quot;sugar&quot; for defining classes. That sugar is just a set of exported functions that make declaring how your class works simpler and more palatable. This lets you describe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09bb13c02237f1d2d9dae9e2adb440884c74285" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Moose&lt;/code&gt; provides a number of features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb64932f264053a0590719161b8cb976f4e1ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NDBM_File&lt;/code&gt; establishes a connection between a Perl hash variable and a file in NDBM_File format;. You can manipulate the data in the file just as if it were in a Perl hash, but when your program exits, the data will remain in the file, to be used the next time your program runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78074d9d3ae7622ec364fb434528c04975ac104b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NDBM_File&lt;/code&gt; has the same problem and the same solution. (Use &lt;code&gt;Memoize::NDBM_File instead of plain NDBM_File.&lt;/code&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0581baa5ac844265bc3183d530bf4c339e0bc42a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NEXT::ACTUAL&lt;/code&gt; is most commonly used in &lt;code&gt;AUTOLOAD&lt;/code&gt; methods, as a means to decline an &lt;code&gt;AUTOLOAD&lt;/code&gt; request, but preserve the normal exception-on-failure semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cf8906396d05eba42604b1fd34e916339ab3a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NFC&lt;/code&gt; , &lt;code&gt;NFD&lt;/code&gt; , &lt;code&gt;NFKC&lt;/code&gt; , &lt;code&gt;NFKD&lt;/code&gt; : by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcf6d595cbf17a9e9ccb45668aea52548b0452a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NYTProf&lt;/code&gt; will generate a report database into the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04556879f1638536b2cd2ee09dcb8a1ebf97cd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Cmd&lt;/code&gt; exports six subroutines, five of these, &lt;code&gt;CMD_INFO&lt;/code&gt; , &lt;code&gt;CMD_OK&lt;/code&gt; , &lt;code&gt;CMD_MORE&lt;/code&gt; , &lt;code&gt;CMD_REJECT&lt;/code&gt; and &lt;code&gt;CMD_ERROR&lt;/code&gt; , correspond to possible results of &lt;code&gt;response&lt;/code&gt; and &lt;code&gt;status&lt;/code&gt; . The sixth is &lt;code&gt;CMD_PENDING&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7845d03a9a449a6da30d7bde75f56559c5b3510e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Cmd&lt;/code&gt; is a collection of methods that can be inherited by a sub class of &lt;code&gt;IO::Handle&lt;/code&gt; . These methods implement the functionality required for a command based protocol, for example FTP and SMTP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254926e3b1fdaf67c80f0581067758f47f75089e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Config&lt;/code&gt; defines the following methods. They are methods as they are invoked as class methods. This is because &lt;code&gt;Net::Config&lt;/code&gt; inherits from &lt;code&gt;Net::LocalCfg&lt;/code&gt; so you can override these methods if you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3230cee7f2d481ff129124c06c210e7e3836e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Config&lt;/code&gt; holds configuration data for the modules in the libnet distribution. During installation you will be asked for these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee62aba7ead75933aba5287b1dfcee92f69a920" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::FTP&lt;/code&gt; inherits from &lt;code&gt;Net::Cmd&lt;/code&gt; so methods defined in &lt;code&gt;Net::Cmd&lt;/code&gt; may be used to send commands to the remote FTP server in addition to the methods documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c9a6d1ddcfaa49ab8c11cb11394dcdd82b4a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::FTP&lt;/code&gt; is a class implementing a simple FTP client in Perl as described in RFC959. It provides wrappers for a subset of the RFC959 commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71138c73e8a250c76baad4423032ba6d1dba47d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::NNTP&lt;/code&gt; inherits from &lt;code&gt;Net::Cmd&lt;/code&gt; so methods defined in &lt;code&gt;Net::Cmd&lt;/code&gt; may be used to send commands to the remote NNTP server in addition to the methods documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847fafd47105bd72c7111b1635378a14aed1d84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::NNTP&lt;/code&gt; is a class implementing a simple NNTP client in Perl as described in RFC977 and RFC4642.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36382e0a9620da9ee21409f3e9c9cfe391785b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Netrc&lt;/code&gt; also implements security checks just like the ftp program, these checks are, first that the .netrc file must be owned by the user and second the ownership permissions should be such that only the owner has read and write access. If these conditions are not met then a warning is output and the .netrc file is not read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6f3d9adca182bb8079550cf17f428b2b3341d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Netrc&lt;/code&gt; is a class implementing a simple interface to the .netrc file used as by the ftp program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123002683b26209fd1f35593f9b8871fd3c658e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::POP3&lt;/code&gt; inherits from &lt;code&gt;Net::Cmd&lt;/code&gt; so methods defined in &lt;code&gt;Net::Cmd&lt;/code&gt; may be used to send commands to the remote POP3 server in addition to the methods documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3751bae0845dc1c96565bcff89564528bd51714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::SMTP&lt;/code&gt; inherits from &lt;code&gt;Net::Cmd&lt;/code&gt; so methods defined in &lt;code&gt;Net::Cmd&lt;/code&gt; may be used to send commands to the remote SMTP server in addition to the methods documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cd710654ff51cb16031bcacedac62e6d1b9ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Net::Time&lt;/code&gt; provides subroutines that obtain the time on a remote machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d533e43a84604b97d548da9e6f5ca63912a9518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NextPermute&lt;/code&gt; uses string order and &lt;code&gt;NextPermuteNum&lt;/code&gt; numeric order, so you can enumerate all the permutations of &lt;code&gt;0..9&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe4c93e326640f663cc60745323069016a9e294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPLIST&lt;/code&gt; is a list of operations to pass to &lt;code&gt;&lt;a href=&quot;../functions/semop&quot;&gt;semop&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OPLIST&lt;/code&gt; is a concatenation of smaller lists, each which has three values. The first is the semaphore number, the second is the operation and the last is a flags value. See &lt;a href=&quot;../functions/semop&quot;&gt;semop&lt;/a&gt; for more details. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33efd347724e242d7141f46f188fed712b7cdd02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPTIONS&lt;/code&gt; are passed in a hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb585ad0e412320d6c5d24d7d6c5a3fe34ee3eee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPTS&lt;/code&gt; is any combination of the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a55a8fa7d94a2bdb8c9858e6a20e3b3750fcc3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PAGFEXT&lt;/code&gt; - the extension used for the page file, usually &lt;code&gt;.pag&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa83b7935dfe2d0f82e9741ba0c0dcca3ce6ca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PAIRMAX&lt;/code&gt; - the maximum size of a stored hash entry, including the length of both the key and value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27156ff4eef82c7929a4d4dc40be3d7c530fea3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PL_errgv&lt;/code&gt; is a perl global of type &lt;code&gt;GV *&lt;/code&gt; that points to the symbol table entry containing the error. &lt;code&gt;ERRSV&lt;/code&gt; therefore refers to the C equivalent of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d846ceba760df481e858497307461291dc972a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PL_modglobal&lt;/code&gt; is a general purpose, interpreter global HV for use by extensions that need to keep information on a per-interpreter basis. In a pinch, it can also be used as a symbol table for extensions to share data among each other. It is a good idea to use keys prefixed by the package name of the extension that owns the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e462043426a8fdcde1b169905e3026ac756f8a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POPn&lt;/code&gt; takes the SV from the top of the stack and obtains its NV either directly (if &lt;code&gt;SvNOK&lt;/code&gt; is set) or by calling the &lt;code&gt;sv_2nv&lt;/code&gt; function. &lt;code&gt;TOPs&lt;/code&gt; takes the next SV from the top of the stack - yes, &lt;code&gt;POPn&lt;/code&gt; uses &lt;code&gt;TOPs&lt;/code&gt; - but doesn't remove it. We then use &lt;code&gt;SvNV&lt;/code&gt; to get the NV from &lt;code&gt;leftsv&lt;/code&gt; in the same way as before - yes, &lt;code&gt;POPn&lt;/code&gt; uses &lt;code&gt;SvNV&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db32ebddf13e6153c4db2e4b19915086fc3c701a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PerlIO *&lt;/code&gt; takes the place of FILE *. Like FILE * it should be treated as opaque (it is probably safe to assume it is a pointer to something).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76de88c3c738162ebd05f1c0526d5c7e44fc7ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PerlIO::scalar&lt;/code&gt; only exists to use XSLoader to load C code that provides support for treating a scalar as an &quot;in memory&quot; file. One does not need to explicitly &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; PerlIO::scalar&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342cc2bd74a057131e7a555a6c648fe333fad065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Perl_op_dump&lt;/code&gt; can be used to dump an &lt;code&gt;OP&lt;/code&gt; structure or any of its derivatives, and produces output similar to &lt;code&gt;perl -Dx&lt;/code&gt; ; in fact, &lt;code&gt;Perl_dump_eval&lt;/code&gt; will dump the main root of the code being evaluated, exactly like &lt;code&gt;-Dx&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525331da57907ca499d00faca6f8395614de9884" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RECURSIVE_TEST_FILES&lt;/code&gt; can be used to include all directories recursively under &lt;code&gt;t&lt;/code&gt; that contain &lt;code&gt;.t&lt;/code&gt; files. It will be ignored if you provide your own &lt;code&gt;TESTS&lt;/code&gt; attribute, defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e1beb351b718ad1963f84891a8a519c473da70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R_OK&lt;/code&gt;&lt;code&gt;SEEK_CUR&lt;/code&gt;&lt;code&gt;SEEK_END&lt;/code&gt;&lt;code&gt;SEEK_SET&lt;/code&gt;&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;code&gt;W_OK&lt;/code&gt;&lt;code&gt;X_OK&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;R_OK&lt;/code&gt;&lt;code&gt;SEEK_CUR&lt;/code&gt;&lt;code&gt;SEEK_END&lt;/code&gt;&lt;code&gt;SEEK_SET&lt;/code&gt;&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;code&gt;W_OK&lt;/code&gt;&lt;code&gt;X_OK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16450031490ec1497810c7f8a187e46a6f98921a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Role::Tiny&lt;/code&gt; provides some of the same features as Moose's role system, but in a much smaller package. Most notably, it doesn't support any sort of attribute declaration, so you have to do that by hand. Still, it's useful, and works well with &lt;code&gt;Class::Accessor&lt;/code&gt; and &lt;code&gt;Class::Tiny&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1843e3a2f66bfd9e3c971214ca68246db523585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SA_NOCLDSTOP&lt;/code&gt;&lt;code&gt;SA_NOCLDWAIT&lt;/code&gt;&lt;code&gt;SA_NODEFER&lt;/code&gt;&lt;code&gt;SA_ONSTACK&lt;/code&gt;&lt;code&gt;SA_RESETHAND&lt;/code&gt;&lt;code&gt;SA_RESTART&lt;/code&gt;&lt;code&gt;SA_SIGINFO&lt;/code&gt;&lt;code&gt;SIGABRT&lt;/code&gt;&lt;code&gt;SIGALRM&lt;/code&gt;&lt;code&gt;SIGCHLD&lt;/code&gt;&lt;code&gt;SIGCONT&lt;/code&gt;&lt;code&gt;SIGFPE&lt;/code&gt;&lt;code&gt;SIGHUP&lt;/code&gt;&lt;code&gt;SIGILL&lt;/code&gt;&lt;code&gt;SIGINT&lt;/code&gt;&lt;code&gt;SIGKILL&lt;/code&gt;&lt;code&gt;SIGPIPE&lt;/code&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;code&gt;SIGSEGV&lt;/code&gt;&lt;code&gt;SIGSTOP&lt;/code&gt;&lt;code&gt;SIGTERM&lt;/code&gt;&lt;code&gt;SIGTSTP&lt;/code&gt;&lt;code&gt;SIGTTIN&lt;/code&gt;&lt;code&gt;SIGTTOU&lt;/code&gt;&lt;code&gt;SIGUSR1&lt;/code&gt;&lt;code&gt;SIGUSR2&lt;/code&gt;&lt;code&gt;SIG_BLOCK&lt;/code&gt;&lt;code&gt;SIG_DFL&lt;/code&gt;&lt;code&gt;SIG_ERR&lt;/code&gt;&lt;code&gt;SIG_IGN&lt;/code&gt;&lt;code&gt;SIG_SETMASK&lt;/code&gt;&lt;code&gt;SIG_UNBLOCK&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SA_NOCLDSTOP&lt;/code&gt;&lt;code&gt;SA_NOCLDWAIT&lt;/code&gt;&lt;code&gt;SA_NODEFER&lt;/code&gt;&lt;code&gt;SA_ONSTACK&lt;/code&gt;&lt;code&gt;SA_RESETHAND&lt;/code&gt;&lt;code&gt;SA_RESTART&lt;/code&gt;&lt;code&gt;SA_SIGINFO&lt;/code&gt;&lt;code&gt;SIGABRT&lt;/code&gt;&lt;code&gt;SIGALRM&lt;/code&gt;&lt;code&gt;SIGCHLD&lt;/code&gt;&lt;code&gt;SIGCONT&lt;/code&gt;&lt;code&gt;SIGFPE&lt;/code&gt;&lt;code&gt;SIGHUP&lt;/code&gt;&lt;code&gt;SIGILL&lt;/code&gt;&lt;code&gt;SIGINT&lt;/code&gt;&lt;code&gt;SIGKILL&lt;/code&gt;&lt;code&gt;SIGPIPE&lt;/code&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;code&gt;SIGSEGV&lt;/code&gt;&lt;code&gt;SIGSTOP&lt;/code&gt;&lt;code&gt;SIGTERM&lt;/code&gt;&lt;code&gt;SIGTSTP&lt;/code&gt;&lt;code&gt;SIGTTIN&lt;/code&gt;&lt;code&gt;SIGTTOU&lt;/code&gt;&lt;code&gt;SIGUSR1&lt;/code&gt;&lt;code&gt;SIGUSR2&lt;/code&gt;&lt;code&gt;SIG_BLOCK&lt;/code&gt;&lt;code&gt;SIG_DFL&lt;/code&gt;&lt;code&gt;SIG_ERR&lt;/code&gt;&lt;code&gt;SIG_IGN&lt;/code&gt;&lt;code&gt;SIG_SETMASK&lt;/code&gt;&lt;code&gt;SIG_UNBLOCK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38c777a85cb32d1057baca8609cbf656119cb80c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SA_SIGINFO&lt;/code&gt; can have segmentation faults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2c7e6ad929d3573c5856ceff8f9188c27a5b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25561b5fed7a4a64f8e1bdca87ed1d440245d47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCALAR&lt;/code&gt; is only defined in &lt;b&gt;Tie::StdHash&lt;/b&gt; and &lt;b&gt;Tie::ExtraHash&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0b10cd155805605b61be127d2cd70120b9eb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCALAR_CACHE&lt;/code&gt; , &lt;code&gt;LIST_CACHE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b1d8651e236ece05cb9bdc8409196d019d2844" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SDBM_File&lt;/code&gt; doesn't supply an &lt;code&gt;EXISTS&lt;/code&gt; method, so included in this package is a glue module called &lt;code&gt;Memoize::SDBM_File&lt;/code&gt; which does provide one. Use this instead of plain &lt;code&gt;SDBM_File&lt;/code&gt; to store your cache table on disk in an &lt;code&gt;SDBM_File&lt;/code&gt; database:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d15d291ef03c3a83408298c576b7a0813776c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SDBM_File&lt;/code&gt; establishes a connection between a Perl hash variable and a file in SDBM_File format. You can manipulate the data in the file just as if it were in a Perl hash, but when your program exits, the data will remain in the file, to be used the next time your program runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a6a48f7293646b32f7105b9bdea7360532c924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SINCE&lt;/code&gt; is a time value and &lt;code&gt;DISTRIBUTIONS&lt;/code&gt; is either a distribution pattern or a reference to a list of distribution patterns. The result is the same as &lt;code&gt;list&lt;/code&gt; , but the groups return will be limited to those created after &lt;code&gt;SINCE&lt;/code&gt; and, if specified, in one of the distribution areas in &lt;code&gt;DISTRIBUTIONS&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bd8292a055ab0f605f05aa8dacaa769a46c577" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SINCE&lt;/code&gt; is a time value. &lt;code&gt;GROUPS&lt;/code&gt; is either a group pattern or a reference to a list of group patterns. &lt;code&gt;DISTRIBUTIONS&lt;/code&gt; is either a distribution pattern or a reference to a list of distribution patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8363925a9881c16e7bf7ee6b67ca48639f9f465b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; were not set under the filter option. And &lt;code&gt;STDIN=&amp;gt;&lt;i&gt;ENCODING&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;STDOUT=&amp;gt;&lt;i&gt;ENCODING&lt;/i&gt;&lt;/code&gt; didn't work like non-filter version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1592372e2b3fafd08547f899651586efb80ed37d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STRLEN&lt;/code&gt; is an integer type (Size_t, usually defined as size_t in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33a48675865d3f493065a917725902bcbf05b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SVf_READONLY&lt;/code&gt; has been supported here only since perl 5.20. To work with earlier versions as well, use &lt;code&gt;SVf_READONLY|SVs_PADTMP&lt;/code&gt; . &lt;code&gt;SVf_READONLY&lt;/code&gt; does not cause the SV in the pad slot to be marked read-only, but simply tells &lt;code&gt;pad_alloc&lt;/code&gt; that it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb24ce9f24ade09b2570ac0d0a13adb33f9e68a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S_IRGRP&lt;/code&gt;&lt;code&gt;S_IROTH&lt;/code&gt;&lt;code&gt;S_IRUSR&lt;/code&gt;&lt;code&gt;S_IRWXG&lt;/code&gt;&lt;code&gt;S_IRWXO&lt;/code&gt;&lt;code&gt;S_IRWXU&lt;/code&gt;&lt;code&gt;S_ISGID&lt;/code&gt;&lt;code&gt;S_ISUID&lt;/code&gt;&lt;code&gt;S_IWGRP&lt;/code&gt;&lt;code&gt;S_IWOTH&lt;/code&gt;&lt;code&gt;S_IWUSR&lt;/code&gt;&lt;code&gt;S_IXGRP&lt;/code&gt;&lt;code&gt;S_IXOTH&lt;/code&gt;&lt;code&gt;S_IXUSR&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S_IRGRP&lt;/code&gt;&lt;code&gt;S_IROTH&lt;/code&gt;&lt;code&gt;S_IRUSR&lt;/code&gt;&lt;code&gt;S_IRWXG&lt;/code&gt;&lt;code&gt;S_IRWXO&lt;/code&gt;&lt;code&gt;S_IRWXU&lt;/code&gt;&lt;code&gt;S_ISGID&lt;/code&gt;&lt;code&gt;S_ISUID&lt;/code&gt;&lt;code&gt;S_IWGRP&lt;/code&gt;&lt;code&gt;S_IWOTH&lt;/code&gt;&lt;code&gt;S_IWUSR&lt;/code&gt;&lt;code&gt;S_IXGRP&lt;/code&gt;&lt;code&gt;S_IXOTH&lt;/code&gt;&lt;code&gt;S_IXUSR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b84604732402ed69ebf71e2ffc9500c3d2f8b6a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S_ISBLK&lt;/code&gt;&lt;code&gt;S_ISCHR&lt;/code&gt;&lt;code&gt;S_ISDIR&lt;/code&gt;&lt;code&gt;S_ISFIFO&lt;/code&gt;&lt;code&gt;S_ISREG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S_ISBLK&lt;/code&gt;&lt;code&gt;S_ISCHR&lt;/code&gt;&lt;code&gt;S_ISDIR&lt;/code&gt;&lt;code&gt;S_ISFIFO&lt;/code&gt;&lt;code&gt;S_ISREG&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f1705fa73ffb1ed6f77c7dd48f4a003fbc42fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scalar::Util&lt;/code&gt; contains a selection of subroutines that people have expressed would be nice to have in the perl core, but the usage would not really be high enough to warrant the use of a keyword, and the size so small such that being individual extensions would be wasteful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7320b904a1348ab8ee29f736d629145b7d946f83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scalar::Util&lt;/code&gt; contains both perl and C implementations of many of its functions so that those without access to a C compiler may still use it. However some of the functions are only available when a C compiler was available to compile the XS version of the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca83b0ae7229fc1620219a7b3cf85ca6438cc57e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Script_Extensions&lt;/code&gt; is thus an improved &lt;code&gt;Script&lt;/code&gt; , in which there are fewer characters in the &lt;code&gt;Common&lt;/code&gt; script, and correspondingly more in other scripts. It is new in Unicode version 6.0, and its data are likely to change significantly in later releases, as things get sorted out. New code should probably be using &lt;code&gt;Script_Extensions&lt;/code&gt; and not plain &lt;code&gt;Script&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e8ac4ebbca5c842f8180e58a17ee29b6639f38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SelfLoader&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ded624fc9abf9da5cffcd42e02847813bc5525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Socket&lt;/code&gt; - networking constants and support functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd3abf31dc1b8226d37ec0f945580ebc843bb88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Socket&lt;/code&gt; a low-level module used by, among other things, the &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt; family of modules. The following examples demonstrate some low-level uses but a practical program would likely use the higher-level API provided by &lt;code&gt;IO::Socket&lt;/code&gt; or similar instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b8cacd499f22c2ad5bc02ef2c976505abecd19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Storable::drop_utf8&lt;/code&gt; is a blunt tool. There is no facility either to return &lt;b&gt;all&lt;/b&gt; strings as utf8 sequences, or to attempt to convert utf8 data back to 8 bit and &lt;code&gt;croak()&lt;/code&gt; if the conversion fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e51b3fbdef231165af8ecaa2816829d5a028adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Storable&lt;/code&gt; isn't a tied hash class at all. You can use it to store a hash to disk and retrieve it again, but you can't modify the hash while it's on the disk. So if you want to store your cache table in a &lt;code&gt;Storable&lt;/code&gt; database, use &lt;code&gt;Memoize::Storable&lt;/code&gt; , which puts a hashlike front-end onto &lt;code&gt;Storable&lt;/code&gt; . The hash table is actually kept in memory, and is loaded from your &lt;code&gt;Storable&lt;/code&gt; file at the time you memoize the function, and stored back at the time you unmemoize the function (or when your program exits):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473d743079fad427614a4cd2d0a5d15458b01a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Strict&lt;/code&gt; will optionally police the values supplied with other options to ensure they are compliant with RFC1952.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2634e7ecab96eac51ac5f6841ce76af5900ddfef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SvPVX(cv)&lt;/code&gt; contains just the sub name itself, not including the package. For an AUTOLOAD routine in UNIVERSAL or one of its superclasses, &lt;code&gt;CvSTASH(cv)&lt;/code&gt; returns NULL during a method call on a nonexistent package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4284263287abb62d9067e62403bfa7c57791af7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::delete_package&lt;/code&gt; is a bit too powerful. It undefines every symbol that lives in the specified package. Since perl, for performance reasons, does not perform a symbol table lookup each time a function is called or a global variable is accessed, some code that has already been loaded and that makes use of symbols in package &lt;code&gt;Foo&lt;/code&gt; may stop working after you delete &lt;code&gt;Foo&lt;/code&gt; , even if you reload the &lt;code&gt;Foo&lt;/code&gt; module afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d33e995b16d967301c7242758ce1abfd4f052c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::delete_package&lt;/code&gt; wipes out a whole package namespace. Note this routine is not exported by default--you may want to import it explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2881407c50abb98d95f598118df2cf0beb51f77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::geniosym&lt;/code&gt; creates an anonymous IO handle. This can be assigned into an existing glob without affecting the non-IO portions of the glob.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6304710bfcc18035fc96ecea6a7a7d1b4365f2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::gensym&lt;/code&gt; creates an anonymous glob and returns a reference to it. Such a glob reference can be used as a file or directory handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1df54b779d123e961a097198a5d301ff9a76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::qualify&lt;/code&gt; turns unqualified symbol names into qualified variable names (e.g. &quot;myvar&quot; -&amp;gt; &quot;MyPackage::myvar&quot;). If it is given a second parameter, &lt;code&gt;qualify&lt;/code&gt; uses it as the default package; otherwise, it uses the package of its caller. Regardless, global variable names (e.g. &quot;STDOUT&quot;, &quot;ENV&quot;, &quot;SIG&quot;) are always qualified with &quot;main::&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d3940d34d2f6d97b8cbcc2b62c6ada7464408e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Symbol::qualify_to_ref&lt;/code&gt; is just like &lt;code&gt;Symbol::qualify&lt;/code&gt; except that it returns a glob ref rather than a symbol name, so you can use the result even if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b97cf7d30005de1a6539396647cc18ee3bfc6e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sys::Syslog&lt;/code&gt; exports the following &lt;code&gt;Exporter&lt;/code&gt; tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c813dc28c2bae993e91667c602bb5be44271d404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sys::Syslog&lt;/code&gt; is a core module, part of the standard Perl distribution since 1990. At this time, modules as we know them didn't exist, the Perl library was a collection of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7568cb65c9c188200eec96ea14f56d0d837a835e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sys::Syslog&lt;/code&gt; is an interface to the UNIX &lt;code&gt;syslog(3)&lt;/code&gt; program. Call &lt;code&gt;syslog()&lt;/code&gt; with a string priority and a list of &lt;code&gt;&lt;a href=&quot;../functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; args just like &lt;code&gt;syslog(3)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5764b6680823ce2de6ec417f2c5a5cac4de54ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sys::Syslog&lt;/code&gt; version v0.07 and older passed the &lt;code&gt;$message&lt;/code&gt; as the formatting string to &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; even when no formatting arguments were provided. If the code calling &lt;code&gt;syslog()&lt;/code&gt; might execute with older versions of this module, make sure to call the function as &lt;code&gt;syslog($priority, &quot;%s&quot;, $message)&lt;/code&gt; instead of &lt;code&gt;syslog($priority,
$message)&lt;/code&gt; . This protects against hostile formatting sequences that might show up if $message contains tainted data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5313b78f03141f017e23634ef660fed87d25a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Base&lt;/code&gt; provides callback management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad2ff19a7b9905abe9ca7c29a86e5aac4455383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Harness&lt;/code&gt; is designed to be easy to configure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98ff2be528a35677bb4032abf8db41c2f2dfe55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Object&lt;/code&gt; provides a default constructor and exception model for all &lt;code&gt;TAP::*&lt;/code&gt; classes. Exceptions are raised using &lt;a href=&quot;../carp&quot;&gt;Carp&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de08af296bc81bae0a502eeab38906f9d38f6946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser::Aggregator&lt;/code&gt; collects parser objects and allows reporting/querying their aggregate results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b643e4bccf3d2c6b004d8c272aaeaacb6b03e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser::Grammar&lt;/code&gt; tokenizes lines from a &lt;a href=&quot;iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; and constructs &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclasses to represent the tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8f01afae57ad3cba82a74e20949b48d80c17d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser::Multiplexer&lt;/code&gt; gathers input from multiple TAP::Parsers. Internally it calls select on the input file handles for those parsers to wait for one or more of them to have input available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb9813c19e749dc873795d47deb2d1cf1c465d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser::Result-&amp;gt;new&lt;/code&gt; is never called, $tokens are reblessed. This</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8722f3aa3dc33f241bd8fa9f537d5593b8612d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser&lt;/code&gt; is designed to produce a proper parse of TAP output. For an example of how to run tests through this module, see the simple harnesses &lt;code&gt;examples/&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb94de0078d3867d1d98a2ebe12069e8acf7897b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAP::Parser&lt;/code&gt; plugins let you change the way TAP is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a472c92eb1c8099613c1ca25abb3493a801d9a6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TCSADRAIN&lt;/code&gt;&lt;code&gt;TCSANOW&lt;/code&gt;&lt;code&gt;TCOON&lt;/code&gt;&lt;code&gt;TCIOFLUSH&lt;/code&gt;&lt;code&gt;TCOFLUSH&lt;/code&gt;&lt;code&gt;TCION&lt;/code&gt;&lt;code&gt;TCIFLUSH&lt;/code&gt;&lt;code&gt;TCSAFLUSH&lt;/code&gt;&lt;code&gt;TCIOFF&lt;/code&gt;&lt;code&gt;TCOOFF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TCSADRAIN&lt;/code&gt;&lt;code&gt;TCSANOW&lt;/code&gt;&lt;code&gt;TCOON&lt;/code&gt;&lt;code&gt;TCIOFLUSH&lt;/code&gt;&lt;code&gt;TCOFLUSH&lt;/code&gt;&lt;code&gt;TCION&lt;/code&gt;&lt;code&gt;TCIFLUSH&lt;/code&gt;&lt;code&gt;TCSAFLUSH&lt;/code&gt;&lt;code&gt;TCIOFF&lt;/code&gt;&lt;code&gt;TCOOFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c88141d29e69da723c81825ed4aa28f85fe2dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TMP&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb68f2209ae08b4353f90118c698f56aaac40566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Test::Harness&lt;/code&gt; sets these before executing the individual tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedf6734cec83fdc2822657eca30ba2f340abb82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Text::Wrap::fill()&lt;/code&gt; is a simple multi-paragraph formatter. It formats each paragraph separately and then joins them together when it's done. It will destroy any whitespace in the original text. It breaks text into paragraphs by looking for whitespace after a newline. In other respects, it acts like wrap().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d81942a81d54f92e87b372edc3a62cc7826a722" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Text::Wrap::wrap()&lt;/code&gt; has a number of variables that control its behavior. Because other modules might be using &lt;code&gt;Text::Wrap::wrap()&lt;/code&gt; it is suggested that you leave these variables alone! If you can't do that, then use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;($Text::Wrap::VARIABLE) = YOURVALUE&lt;/code&gt; when you change the values so that the original value is restored. This &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; trick will not work if you import the variable into your own namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1615c49151b3deef2ed2f37c67cec6329aa12f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Text::Wrap::wrap()&lt;/code&gt; is a very simple paragraph formatter. It formats a single paragraph at a time by breaking lines at word boundaries. Indentation is controlled for the first line (&lt;code&gt;$initial_tab&lt;/code&gt; ) and all subsequent lines (&lt;code&gt;$subsequent_tab&lt;/code&gt; ) independently. Please note: &lt;code&gt;$initial_tab&lt;/code&gt; and &lt;code&gt;$subsequent_tab&lt;/code&gt; are the literal strings that will be used: it is unlikely you would want to pass in a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbadf232b07d6755d5f86328062ab50e3309a385" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Text::Wrap::wrap()&lt;/code&gt; starts its work by expanding all the tabs in its input into spaces. The last thing it does it to turn spaces back into tabs. If you do not want tabs in your results, set &lt;code&gt;$Text::Wrap::unexpand&lt;/code&gt; to a false value. Likewise if you do not want to use 8-character tabstops, set &lt;code&gt;$Text::Wrap::tabstop&lt;/code&gt; to the number of characters you do want for your tabstops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467f24162cc06d04d5ab812af9c45bbabafd7b6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; returns a thread object representing the newly created thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b370124e5ee91deba09a04327dc32dee66471f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; maintains an internal table of the byte offset of each record it has seen in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9815aecf90eb2e223c97ce6c8d16c9260911c408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; promises that the following sequence of operations will be safe:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d63721817865519a8d0f071612094f774c55373" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; represents a regular text file as a Perl array. Each element in the array corresponds to a record in the file. The first line of the file is element 0 of the array; the second line is element 1, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a3d66b09517db449a91c4ca42dd41163f93bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; tries to guess when deferred writing might be helpful, and to turn it on and off automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014103b958bc396d81fb1efdb14e81091ca5d049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; version 0.96 is copyright (C) 2003 Mark Jason Dominus.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a9d266a8d034b3093885f52948252f982c081d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::File&lt;/code&gt; version 0.98 comes with ABSOLUTELY NO WARRANTY. For details, see the license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765e809d133387f24d23e5776c542da23425f9d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tie::Scalar&lt;/code&gt; provides all the necessary methods, but one should realize they do not do anything useful. Calling &lt;code&gt;Tie::Scalar::FETCH&lt;/code&gt; or &lt;code&gt;Tie::Scalar::STORE&lt;/code&gt; results in a (trappable) croak. And if you inherit from &lt;code&gt;Tie::Scalar&lt;/code&gt; , you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9908dcbb0c04058ac728c44f2b059df9c83be077" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tk::Canvas&lt;/code&gt; ) for which the linker option file will be produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a924c42dbac826b648276a4a5da21c2db2545b5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UCS-2&lt;/code&gt; is an exception. Unlike others, this is an alias of UCS-2BE. UCS-2 is already registered by IANA and others that way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8d5cd56952f7e9b2404061a72c2a7e45a2683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; code blocks are useful to catch the transition between the compilation phase and the execution phase of the main program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34178e964cf584fdf5806f55c96a0bc4853575e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; blocks are run just after the unit which defined them has been compiled. The main program file and each module it loads are compilation units, as are string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s, run-time code compiled using the &lt;code&gt;(?{ })&lt;/code&gt; construct in a regex, calls to &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; FILE&lt;/code&gt; , and code after the &lt;code&gt;-e&lt;/code&gt; switch on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29082300972578ac172b3bcf60b3baedc1711b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; is the base class from which all blessed references inherit. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ee2201428c064e4abefc93cea2f5adb84494a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; provides the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8236e4ed6563ca685881ecd85fb5fbeb9a8352ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is internally known as &lt;code&gt;utf-8-strict&lt;/code&gt; . The tutorial uses UTF-8 consistently, even where utf8 is actually used internally, because the distinction can be hard to make, and is mostly irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8de8fd8fcf48c479a5f2548a2ea84553cbb55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is the official standard. &lt;code&gt;utf8&lt;/code&gt; is Perl's way of being liberal in what it accepts. If you have to communicate with things that aren't so liberal, you may want to consider using &lt;code&gt;UTF-8&lt;/code&gt; . If you have to communicate with things that are too liberal, you may have to use &lt;code&gt;utf8&lt;/code&gt; . The full explanation is in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a0fc4be9864abfdfe213f730a836cf153d3d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unix&lt;/code&gt; has a few filetypes that aren't supported on other platforms, like &lt;code&gt;Win32&lt;/code&gt; . If we encounter a &lt;code&gt;hardlink&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; we'll just try to make a copy of the original file, rather than throwing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d74c9b056759689807d86e862d255692b030b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e64ceff700bffb9b0e49ed00840d8567272b98d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; can be called as either a class (static) method or an object method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e5c5bf9414f45f9ee6cd495857a6d0af8135b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; will return the value of the variable &lt;code&gt;$VERSION&lt;/code&gt; in the package the object is blessed into. If &lt;code&gt;REQUIRE&lt;/code&gt; is given then it will do a comparison and die if the package version is not greater than or equal to &lt;code&gt;REQUIRE&lt;/code&gt; , or if either &lt;code&gt;$VERSION&lt;/code&gt; or &lt;code&gt;REQUIRE&lt;/code&gt; is not a &quot;lax&quot; version number (as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09d07e4d00536d5b65342f6fda4e06e40de674a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WEXITSTATUS(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the normal exit status of the child process (only meaningful if &lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50caa072d18e392639ac8cbf2652792fc96e056a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process exited normally (&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; or by falling off the end of &lt;code&gt;main()&lt;/code&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a10acdd8d4b5cbcaa19166a65359a79e72c10ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="913c2440e3192214324c69c5042c74731bd768ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process terminated because of a signal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31cf55751c90a24957243f3a757494178f490f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process is currently stopped (can happen only if you specified the WUNTRACED flag to &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0ae9473f56b8cede4edc36cb20deb25c332b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6b1ff61466d78e7b46ba9478c03225a6e4901f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WSTOPSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process was stopped for (only meaningful if &lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fce0cd0fb21ad8f415dada694b22cfb2560526f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WTERMSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process terminated for (only meaningful if &lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280239300b5e2da4b3afad680afacc165216bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WriteFile&lt;/code&gt; takes one optional argument. When called with one argument, it expects to be passed a filename. When called with no arguments, it defaults to the filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2f93eb05588029257a866afb2ec29cefadaab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;XXX&lt;/code&gt; To do: Since compatibility can depend on compile time options (such as bincompat, longlong, etc.) it should (perhaps) be set by Configure, but currently it isn't. Currently, we read a hard-wired value from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d73e9513462d0441d882a14aedf29b4d48f493f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; designating if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63907946795eb9d983c7251fc87f03561c9ef960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Zip64&lt;/code&gt; will be automatically set, as needed, if working with the one-shot interface when the input is either a filename or a scalar reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c080ff6a40a2d784f921c0451433798850e94e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[ ITEMS ]&lt;/code&gt; makes a new, anonymous array, and returns a reference to that array. &lt;code&gt;{ ITEMS }&lt;/code&gt; makes a new, anonymous hash, and returns a reference to that hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e197e33c6ccb5f4067a4525a2143eb1d616cb64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:ascii:]]&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfa2d0098181bbefe03441d8231e81eb9677e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\A&lt;/code&gt; only matches at the beginning of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\A/&lt;/code&gt; is equivalent to &lt;code&gt;/^/&lt;/code&gt; . However, if the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/^/&lt;/code&gt; matches internal newlines, but the meaning of &lt;code&gt;/\A/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\A&lt;/code&gt; matches at the beginning of the string regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef23e4d1b4ae86eeb209dd5770450d03008a5b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\F&lt;/code&gt; can be used to casefold all characters following, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. It provides the functionality similar to the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29175559120891c17a696d6942f87d50d6868998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is also invaluable in processing fixed-length records with regexps. Suppose we have a snippet of coding region DNA, encoded as base pair letters &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; and we want to find all the stop codons &lt;code&gt;TGA&lt;/code&gt; . In a coding region, codons are 3-letter sequences, so we can think of the DNA snippet as a sequence of 3-letter records. The naive regexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc01fdb07dcb48f3990f7e9986cc181c1d1aa3c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is usually used only in combination with the &lt;code&gt;/g&lt;/code&gt; modifier. If the &lt;code&gt;/g&lt;/code&gt; modifier is used and the match is done in scalar context, Perl remembers where in the source string the last match ended, and the next time, it will start the match from where it ended the previous time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab760e95f43824629065b7030ad07437049f251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; matches the point where the previous match on that string ended, or the beginning of that string if there was no previous match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caee3f50983ee96aea6298365c6e4a735aeffd91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; , and &lt;code&gt;\Q&lt;/code&gt; can stack, in which case you need one &lt;code&gt;\E&lt;/code&gt; for each. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b715a8c878ff64b76422f5de0db4d867e6df23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; , available starting in v5.12, like the dot, matches any character that is not a newline. The difference is that &lt;code&gt;\N&lt;/code&gt; is not influenced by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80779fa1da204f29defd5bf097dbba87c9107e16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; within a bracketed character class must be of the forms &lt;code&gt;\N{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, and NOT be the form that matches non-newlines, for the same reason that a dot &lt;code&gt;.&lt;/code&gt; inside a bracketed character class loses its special meaning: it matches nearly anything, which generally isn't what you want to happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2706754019f77a1fbbc94bb64673d2224cda545c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N{U+&lt;i&gt;hexadecimal number&lt;/i&gt;}&lt;/code&gt; means the Unicode character whose Unicode code point is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d883253a04efed05a5ba1744b87b2c80c0e4bf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; are actually part of double-quotish syntax, and not part of regexp syntax proper. They will work if they appear in a regular expression embedded directly in a program, but not when contained in a string that is interpolated in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ed1242ac7474e94b7458c0ba21e510aab5efa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; (possibly paired with &lt;code&gt;\E&lt;/code&gt; ) are converted to corresponding Perl constructs. Thus, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; is converted to &lt;code&gt;$foo . (&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;(&quot;baz&quot; . $bar))&lt;/code&gt; internally. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are replaced with appropriate expansions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0b64315a3fe9c58415fa16564b8e316472bbe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; is used to quote (disable) pattern metacharacters, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. &lt;code&gt;\Q&lt;/code&gt; adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; for details on what gets quoted for non-ASCII code points. Using this ensures that any character between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; will be matched literally, not interpreted as a metacharacter by the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fdb89c706826e363f4d1a15c85386d62762386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffa61af84fa5204640b2d3a9297ad766cd2302f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches anything that can be considered a newline under Unicode rules. It can match a multi-character sequence. It cannot be used inside a bracketed character class; use &lt;code&gt;\v&lt;/code&gt; instead (vertical whitespace). It uses the platform's native character set, and does not consider any locale that may otherwise be in use. Details are discussed in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c079457c2c94c9296bb94d74fe70faff7c8e990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; is an abbreviation for a character class that comprises a Unicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e23bb607e060dee7b3f1229c353a21e48fea15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; matches quite well what normal (non-Unicode-programmer) usage would consider a single character. As an example, consider a G with some sort of diacritic mark, such as an arrow. There is no such single character in Unicode, but one can be composed by using a G followed by a Unicode &quot;COMBINING UPWARDS ARROW BELOW&quot;, and would be displayed by Unicode-aware software as if it were a single character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d7b3ea79034dbcabd4d97597212e6ab2de3c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; . This matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75241b44033641bce1ae791eaa2652fadc31474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; assume there's a non-word character before the beginning and after the end of the source string; so &lt;code&gt;\b&lt;/code&gt; will match at the beginning (or end) of the source string if the source string begins (or ends) with a word character. Otherwise, &lt;code&gt;\B&lt;/code&gt; will match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc4a462570407b89d8c1b47db7b8c34eb82f528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; is the backspace character only inside a character class. Outside a character class, &lt;code&gt;\b&lt;/code&gt; alone is a word-character/non-word-character boundary, and &lt;code&gt;\b{}&lt;/code&gt; is some other type of boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4c255a44ab388eea9df94821b04725a1eb1239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between a word (something matched by &lt;code&gt;\w&lt;/code&gt; ) and a non-word character (&lt;code&gt;\W&lt;/code&gt; ); &lt;code&gt;\B&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b&lt;/code&gt; doesn't match. To get better word matching of natural language text, see \b{wb} below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5781002df3a961ccd9eb514485a027a250771de9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{...}&lt;/code&gt; , available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The currently known boundary types are given a few paragraphs below. &lt;code&gt;\B{...}&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b{...}&lt;/code&gt; of the same type doesn't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e43fb282e8b27b2619badf10578d9a503c1e675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; is used to denote a control character; the character following &lt;code&gt;\c&lt;/code&gt; determines the value of the construct. For example the value of &lt;code&gt;\cA&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, and the value of &lt;code&gt;\cb&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(2)&lt;/a&gt;&lt;/code&gt;, etc. The gory details are in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. A complete list of what &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. means for ASCII and EBCDIC platforms is in &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a0ca0d9ef67cf04ea6ca6b5bd701f43d0336bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; matches a single character considered to be a decimal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428b825cb343a5c9509774542fc16bc60189535f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0) is used for relative addressing. (It can be written as &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt;.) It refers to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3328b2720f5bc3f94fe796543159d6af46703a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ,... Backreferences are simply matching variables that can be used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33ee556e38924ce3e6215adbca979c4cfab3cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; (starting in Perl 5.10.0) can be used to back refer to a named capture group, dispensing completely with having to think about capture buffer positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3acb4bd92904b84995c318e676ce7b840ab01ca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\h&lt;/code&gt; matches any character considered horizontal whitespace; this includes the platform's space and tab characters and several others listed in the table below. &lt;code&gt;\H&lt;/code&gt; matches any character not considered horizontal whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48e53b9236a29c7807d180f9e942a8de2e93b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; matches a logical newline. Perl converts between &lt;code&gt;\n&lt;/code&gt; and your OS's native newline character when reading from or writing to text files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47a61f1d11f4dbc31ff29f399c1b03054d85480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; (where &lt;code&gt;P&lt;/code&gt; is a single letter) and &lt;code&gt;\p{Property}&lt;/code&gt; are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to &lt;code&gt;\PP&lt;/code&gt; and &lt;code&gt;\P{Property}&lt;/code&gt; make the sequence match a character that doesn't match the given Unicode property. For more details, see &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; and &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Unicode Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84c55ace76e1ff0519f5aac6666720a80072bd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; and &lt;code&gt;\p{Prop}&lt;/code&gt; are character classes to match characters that fit given Unicode properties. One letter property names can be used in the &lt;code&gt;\pP&lt;/code&gt; form, with the property name following the &lt;code&gt;\p&lt;/code&gt; , otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like &lt;code&gt;\p{name=value}&lt;/code&gt; , which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as &lt;code&gt;/\pN/&lt;/code&gt; or as &lt;code&gt;/\p{Number}/&lt;/code&gt; , or as &lt;code&gt;/\p{Number=True}/&lt;/code&gt; . Lowercase letters are matched by the property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85149b0f3a91ea78c71d331abbaa6fc18476f335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{Blank}&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; are synonyms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c9fecf27d0a09b0629761f6ae905625678010b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{PosixPunct}&lt;/code&gt; and &lt;code&gt;[[:punct:]]&lt;/code&gt; in the ASCII range match all non-controls, non-alphanumeric, non-space characters: &lt;code&gt;[-!&quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]^_`{|}~]&lt;/code&gt; (although if a locale is in effect, it could alter the behavior of &lt;code&gt;[[:punct:]]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755edd19d42bc00d2d42f52db8c39e41d61b74f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; and &lt;code&gt;\p{Space}&lt;/code&gt; match identically starting with Perl v5.18. In earlier versions, these differ only in that in non-locale matching, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; did not match the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . Same for the two ASCII-only range forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bf92acce79d5b5002afaba6916dbd6bb155338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; and (under Unicode rules) &lt;code&gt;[[:punct:]]&lt;/code&gt;, match what &lt;code&gt;\p{PosixPunct}&lt;/code&gt; matches in the ASCII range, plus what &lt;code&gt;\p{Punct}&lt;/code&gt; matches. This is different than strictly matching according to &lt;code&gt;\p{Punct}&lt;/code&gt; . Another way to say it is that if Unicode rules are in effect, &lt;code&gt;[[:punct:]]&lt;/code&gt; matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3cef3a5e22571510fa5a04adc6bd52e2e9e07c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . (See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.) Note that this list doesn't include the non-breaking space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad191b59c68476309e8cdff37277905b3d644e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches any single character considered whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164846db6b825e570c0d7edc2e8e99d0a8cd9c3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the characters shown with an &quot;s&quot; column in the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe6b3493a7e126712936240780ab43a7647b5c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the code points above 255 shown with an &quot;s&quot; column in the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c42afe9cf980295f6ccaddc4816a2d0390a04f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches whatever the locale considers to be whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17398607beae9e16f5d507bd2de1c2792253d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; matches any character considered vertical whitespace; this includes the platform's carriage return and line feed characters (newline) plus several other characters, all listed in the table below. &lt;code&gt;\V&lt;/code&gt; matches any character not considered vertical whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84d6b7c93d52f35bcd484412e96304ddb465e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; can be used to match a Japanese ideograph, for instance; and &lt;code&gt;[[:digit:]]&lt;/code&gt; a Bengali number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b56560fcb8e649f2853269006af953eb9769e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; is a character class that matches any single</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cb702e25188808179cd08641633cb28eaa0eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches [a-zA-Z0-9_].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fd3f12a256fac6c8c475c41016b746e332589d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches exactly what &lt;code&gt;\p{Word}&lt;/code&gt; matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdee4d0daab297bf0961e4ccefe2a5955a8d76f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the 63 characters [a-zA-Z0-9_].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb954d084b4018682f968a2007d9fb696787dd4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the platform's native underscore character plus whatever the locale considers to be alphanumeric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1175cf96f88bb9109cfcdb274bab554078c0da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the same as &lt;code&gt;\p{Word}&lt;/code&gt; matches in this range. That is, it matches Thai letters, Greek letters, etc. This includes connector punctuation (like the underscore) which connect two words together, or diacritics, such as a &lt;code&gt;COMBINING TILDE&lt;/code&gt; and the modifier letters, which are generally used to add auxiliary markings to letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf252af84459ebbc3355f5052e1c483febc2e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{}&lt;/code&gt; and &lt;code&gt;\o{}&lt;/code&gt; can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; for code points less than 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe4cad9ff217e9c6a9d88999a2c91a4805e6cd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; match at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\Z/&lt;/code&gt; is equivalent to &lt;code&gt;/$/&lt;/code&gt; ; that is, it matches at the end of the string, or one before the newline at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/$/&lt;/code&gt; matches at internal newlines, but the meaning of &lt;code&gt;/\Z/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\Z&lt;/code&gt; matches at the end of the string (or just before a trailing newline) regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f47b559e51c9cb06b7531b5b8a212ee7a07836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; is just like &lt;code&gt;\Z&lt;/code&gt; , except that it does not match before a trailing newline. &lt;code&gt;\z&lt;/code&gt; matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a70aedbc9fae24b3656fb271fb5a35b52ef808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; is the offset of the start of the substring matched by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d7f97ecc73edc5732b4917233d89a3115636be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in regular expression patterns are supposed to match all these, but don't. These characters also don't, but should, affect &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;code&gt;$.&lt;/code&gt; , and script line numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2224dcf7ebf0b526271854823f3d301837385c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63011a4008ee629a0f26075a9a743d3b2b2ede8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0338a6cffd158f71c4a073e1191fe24d695975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4507a34314e4717b1cc2380be0c570f4cf8cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f436bfdadc0a4193ec468e3af9c90fc24e2967c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DIE__&lt;/code&gt; /&lt;code&gt;__WARN__&lt;/code&gt; handlers are very special in one respect: they may be called to report (probable) errors found by the parser. In such a case the parser may be in inconsistent state, so any attempt to evaluate Perl code from such a handler will probably result in a segfault. This means that warnings or errors that result from parsing Perl should be used with extreme caution, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d0b679130382dce8fe2a86280667432e82e672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_fieldhash&lt;/code&gt; is the internal function used to create field hashes. It takes two arguments, a hashref and a mode. If the mode is boolean false, the hash is not changed but tested if it is a field hash. If the hash isn't a field hash the return value is boolean false. If it is, the return value indicates the mode of field hash. When called with a boolean true mode, it turns the given hash into a field hash of this mode, returning the mode of the created field hash. &lt;code&gt;_fieldhash&lt;/code&gt; does not erase the given hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8e054b1c07b425b270bb9c7e13c794d2d9092f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="aa85beb7344aca10b8cc8699807de44f549b3521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;``&lt;/code&gt; and pipe-&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; do not work under DOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8938480285fe7482d06df8890143549cb42503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; = match 'a' 0 or more times, i.e., any number of times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b92f8e0d8dad1b0caf50f135db9b635632e760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab7362646f1c360bc9715cbf44b1a07df61dc33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*?&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times, but as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ca230acfe7cf51016cf1f4619d8d0fb5d9ddc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; = match 'a' 1 or more times, i.e., at least once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57839f788d53642fe08867e5699ec952e95d5a35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e81ca192d31fdf9434c5f46dda1eb5e709a3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+?&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once, but as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe405e15c76b256da476c55e02d7cd0a2d157a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.out&lt;/code&gt; -style build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230edf66068099823e9804e4de860018cd863dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; = match 'a' 1 or 0 times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da27773f632fe6532ea60454a7e99563c5df049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; means: match 'a' 1 or 0 times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95b02ff02305f1ba01c669bd763805726d17747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a??&lt;/code&gt; means: match 'a' 0 or 1 times. Try 0 first, then 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fc80bf6fcacd730498ea7c90f9cf90dcfb60ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;AUTOLOAD&lt;/code&gt; , &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;CORE&lt;/code&gt; , &lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;DESTROY&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237ce529899dd468665989ad0de897e59c5ea0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a199cbe1000a9f2232c1b768205f8a71916e5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyuncompress&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594b23475e0e1b9413cc86129d116de9c7483b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argc&lt;/code&gt; is the number of args (in addition to $self) to pass to the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecb8a104e58709e3b9705ed1f8707f7f5de3bcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias for &lt;code&gt;as_int()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d961a102b3d98060a65c3134d4e3d1aa8466353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias to this method. &lt;code&gt;as_number&lt;/code&gt; was introduced in v1.22, while &lt;code&gt;as_int()&lt;/code&gt; was only introduced in v1.68.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71746fcdf6fe99a0ad5a137467eb6e68086bdb69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous sub, and so must have a semi-colon after the closing brace. Like &lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a thread object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0efd0ea8940854ffa84069ded342e116934964" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous subroutine, and so must have a semicolon after the closing brace. Like &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e239fdae6920d9515de44e7fcc79dd92cfa709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_help&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44063872f18d367e632a96d4c2413f4a5756f7e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_version&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1347f069f43387e1b93d21850e69034397cebbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autobundle&lt;/code&gt; writes a bundle file into the &lt;code&gt;$CPAN::Config-&amp;gt;{cpan_home}/Bundle&lt;/code&gt; directory. The file contains a list of all modules that are both available from CPAN and currently installed within @INC. Duplicates of each distribution are suppressed. The name of the bundle file is based on the current date and a counter, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b650573b7b7b2cbf42f22f273aca6f48d4d98e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; can be enabled for all of Perl's built-ins, including &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fad0431ea3a38aae4174e77bf5178a3d0e649d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; may not work correctly if used inside a file with a name that looks like a string eval, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454c5cd48c87ed2210f01705090343cf6b8e7234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; performs no checking of called context to determine whether to throw an exception; the explicitness of error handling with &lt;code&gt;autodie&lt;/code&gt; is a deliberate feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0331eb04d953ce3ea3a3439a3951a3642b45368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; uses the &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to change &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;. See its documentation for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6a31e9af4af180479c7899fb188e9a03c0bf8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoftp&lt;/code&gt; is a program that can retrieve, send, or list files via the FTP protocol in a non-interactive manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc7ee78e0a3ef2c6ca2c0dc57cbee30b57d77f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; imports the default functions automatically, but &lt;code&gt;load&lt;/code&gt; do not import any functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232241e3903140051e2046c8f6440d532e004aca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is usable under &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN{};&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3895a69d42fb934afc4c8b2a1c096fa7c3b874a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;av_fetch&lt;/code&gt; and the corresponding hash functions &lt;code&gt;hv_fetch&lt;/code&gt; and &lt;code&gt;hv_fetch_ent&lt;/code&gt; actually return an undefined mortal value whose magic has been initialized using &lt;code&gt;mg_copy&lt;/code&gt; . Note the value so returned does not need to be deallocated, as it is already mortal. [MAYCHANGE] But you will need to call &lt;code&gt;mg_get()&lt;/code&gt; on the returned value in order to actually invoke the perl level &quot;FETCH&quot; method on the underlying TIE object. Similarly, you may also call &lt;code&gt;mg_set()&lt;/code&gt; on the return value after possibly assigning a suitable value to it using &lt;code&gt;sv_setsv&lt;/code&gt; , which will invoke the &quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370ecf3fa40e8e270cd9e8d46abf508006b8748f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as many times as possible, and don't give anything up. &lt;code&gt;a?+&lt;/code&gt; is short for &lt;code&gt;a{0,1}+&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e375a004d6e03b949adf214a1f3c21deb80331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc66155533b942e5ab8f7ec970fd9b80f6477f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5c7c3b0091b46feced5840b89ec76e6c84ecde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b5ef56170764cdecbc0d347e679c1d12841cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as many times as possible, and don't give anything up. &lt;code&gt;a*+&lt;/code&gt; is short for &lt;code&gt;a{0,}+&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt; is short for &lt;code&gt;a{1,}+&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e64ab97f56cca83c147d8db97bd5f38b759239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d47f9ce037822c6fc7d0cc1f2af2151924474e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4796e3b46c1c24af1a67d6416b09b75dcbb56116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98166d002c5d2230a03efe89288ff0c20693e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}+&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. It is just there for notational consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff6bf2bdc74bd6dd9dac4febf280883951ce36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; = match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488e096629b1696be9c45608edaf6f60d2af36fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca987a62d500844e024a8db45998e5cb0a2b3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}?&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. Because we match exactly &lt;code&gt;n&lt;/code&gt; times, &lt;code&gt;a{n}?&lt;/code&gt; is equivalent to &lt;code&gt;a{n}&lt;/code&gt; and is just there for notational consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c5653f4696bd55e9f87cb851ed5b97df1c68e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bailout&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85746857608dedc350be9624fa95666d17cbadec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; will also initialize the fields if one of the base classes has it. Multiple inheritance of fields is &lt;b&gt;NOT&lt;/b&gt; supported, if two or more base classes each have inheritable fields the 'base' pragma will croak. See &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; for a description of this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191bfc9558f7a150df37f22495b9090b9cec45da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;baseex&lt;/code&gt; is the error message or object. If it is a reference, it will be used as-is. Otherwise it is used as a string, and if it does not end with a newline then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b66a2dfa7d8acaa040a7d0a40556f020987bdaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basemsg&lt;/code&gt; is the initial message or object. If it is a reference, it will be used as-is and will be the result of this function. Otherwise it is used as a string, and if it already ends with a newline, it is taken to be complete, and the result of this function will be the same string. If the message does not end with a newline, then a segment such as &lt;code&gt;at
foo.pl line 37&lt;/code&gt; will be appended, and possibly other clauses indicating the current state of execution. The resulting message will end with a dot and a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb5487d902affd230109c249c6cfd2461d057fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basename()&lt;/code&gt; returns the last level of a filepath even if the last level is clearly directory. In effect, it is acting like &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop()&lt;/a&gt;&lt;/code&gt; for paths. This differs from &lt;code&gt;fileparse()&lt;/code&gt; 's behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350e4c9f21cb0a1a08b12c3f3a234fd3306d7d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ef559a5aee4fc6060476dc9dce6429a54a1fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; overrides these routines with versions that can also handle big integer values. Under Perl prior to version v5.9.4, however, this will not happen unless you specifically ask for it with the two import tags &quot;hex&quot; and &quot;oct&quot; - and then it will be global and cannot be disabled inside a scope with &quot;no bigint&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648bd882ff18dacc401ac93a3cbc5bdbf4c9d3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67fd9272e03c0fff199bea83aa5f87ef9db2f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4484da561486fa621b4d5b400e117645932edd50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0997be7992ad036fe88c07a1a2c5ae3b3d710948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cc1a07b43faefb3cad91d623e619dcf6f61922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10db204f6c1bcb2f5fdc7fee81a4199ba0a57f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocking&lt;/code&gt; will return the value of the previous setting, or the current setting if &lt;code&gt;BOOL&lt;/code&gt; is not given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c9b344df6b3d92130baeb97d1162148eeccf12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bmodpow&lt;/code&gt; also supports negative exponents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf87ddfc025679a4d593ab2adfc2fee4551858ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bnorm()&lt;/code&gt; on a BigInt object is now effectively a no-op, since the numbers are always stored in normalized form. If passed a string, creates a BigInt object from the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798cacd9e526afca183dccd1f959cca59d152f9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first three will modify $x, the last one won't:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849aa8872c1c17a134807b61340d2432f9319b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; now modifies the first argument, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first will modify $x, the second one won't:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80a75fc2d5e34cc7d42f63e584e793a52a18a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37b9dd4d4b04a787d223ae6bcbe782e25d34036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; is available only if you enable the experimental &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature or use the &lt;code&gt;CORE::&lt;/code&gt; prefix. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature also enables the &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; statements, which are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; (or higher) declaration in the current scope. In Perl v5.14 and earlier, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; required the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature, like the other keywords.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d28a27314909fae3508f8ed1164a5ec5399fbac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsearch()&lt;/code&gt; not supplied. For doing binary search on wordlists, see &lt;a href=&quot;search/dict&quot;&gt;Search::Dict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1b1c495b5749e6b5ca6c410c06a5dadd577616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsqrt()&lt;/code&gt; works only good if the result is a big integer, e.g. the square root of 144 is 12, but from 12 the square root is 3, regardless of rounding mode. The reason is that the result is always truncated to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f4bf676cc3a699b15481fc4a058909b15b5eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bunzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79e566033f6f8c25d3096a1053f32dc8e50d7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53f1266a06652ab4c19a127fb6358e6d1bc2de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; cannot know whether an object will be able to provide a method through AUTOLOAD (unless the object's class has overridden &lt;code&gt;can&lt;/code&gt; appropriately), so a return value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd77132ceb27f8ce6ebaf76ddb70f3498008f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; checks if the object or class has a method called &lt;code&gt;METHOD&lt;/code&gt; . If it does, then it returns a reference to the sub. If it does not, then it returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4425b178b213ffd266cc097cac94373284912ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; keeps its results in a cache, so it will not load the same module twice, nor will it attempt to load a module that has already failed to load before. By default, &lt;code&gt;can_load&lt;/code&gt; will check its cache, but you can override that by setting &lt;code&gt;nocache&lt;/code&gt; to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eef2d6b11e6af56916a4d9fed0cb49b43cc441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; takes the following arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c301228074969b093786c28df06529f261955aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; will take a list of modules, optionally with version numbers and determine if it is able to load them. If it can load *ALL* of them, it will. If one or more are unloadable, none will be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a478303bf076c83556297908a48dd42d425490d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_run&lt;/code&gt; takes only one argument: the name of a binary you wish to locate. &lt;code&gt;can_run&lt;/code&gt; works much like the unix binary &lt;code&gt;which&lt;/code&gt; or the bash command &lt;code&gt;type&lt;/code&gt; , which scans through your path, looking for the requested binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc99e95e5b60b47d7f6807a79b190e2a3f9be43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change()&lt;/code&gt; handles &lt;code&gt;long_contraction&lt;/code&gt; explicitly only. If &lt;code&gt;long_contraction&lt;/code&gt; is not specified in &lt;code&gt;change()&lt;/code&gt; , even though &lt;code&gt;UCA_Version&lt;/code&gt; is changed, &lt;code&gt;long_contraction&lt;/code&gt; will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f558974fb9e8f6fa2958daad656d8e76c141ee94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charblocks()&lt;/code&gt; returns a reference to a hash with the known block names as the keys, and the code point ranges (see &lt;a href=&quot;#charblock()&quot;&gt;charblock()&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f837d8bad7cfec5d4bd3123e3e4f4763462fd63b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charnames::string_vianame()&lt;/code&gt; was introduced in v5.14. Prior to that, &lt;code&gt;charnames::vianame()&lt;/code&gt; should work, but only if the argument is of the form &lt;code&gt;&quot;U+...&quot;&lt;/code&gt; . Your best bet there for runtime Unicode by character name is probably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead2be91e2308e7b32a2e10b2c8928960675c93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charscripts()&lt;/code&gt; returns a reference to a hash with the known script names as the keys, and the code point ranges (see &lt;a href=&quot;#charscript()&quot;&gt;charscript()&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c2d5d27e775d5bf2acdbed6ec527b752b22f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; takes a list of arguments, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a6a6f073c5f32501789dfae5a4e3b8efb86cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; will return when it fails, or a hashref with lowercase keys of parsed arguments when it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc394e8518231d46cc35fa58854fec4567f4a31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_install&lt;/code&gt; allows you to verify if a certain module is installed or not. You may call it with the following arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f4747e95e85b4a1c67cb7b51c9949e228f03f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; clears the current in-memory archive. This effectively gives you a 'blank' object, ready to be filled again. Note that &lt;code&gt;clear&lt;/code&gt; only has effect on the object, not the underlying tarfile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1ff99d5c7ed83e6f2dcc9a357801da554024fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp&lt;/code&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dbfc6b5ac858f99cbcc4507d320823e6f6fa5ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmpthese&lt;/code&gt; can also be passed the data structure that timethese() returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5332ff0a73638efd42ab63fc32fe9bd7dbabeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comment&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da23c990c0b340d65a11e6c4dd9a9fbcf9e8cbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compexcl()&lt;/code&gt; is included for backwards compatibility, but as of Perl 5.12 and more modern Unicode versions, for most purposes it is probably more convenient to use one of the following instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a708da1901bbb301c133e94da37987c89cff89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond_signal&lt;/code&gt; will normally generate a warning if you attempt to use it on an unlocked variable. On the rare occasions where doing this may be sensible, you can suppress the warning with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096889c63611c83b225ce2ede691d1f2be6bc5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; - This option is ignored, since the failover mechanism will drop down to the console automatically if all other media fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45a4c8bee9a24fa02b0048a41bb38158983a350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak()&lt;/code&gt; only when your module absolutely cannot figure out what to do. (&lt;code&gt;croak()&lt;/code&gt; is a better version of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; for use within modules, which reports its errors from the perspective of the caller. See &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; for details of &lt;code&gt;croak()&lt;/code&gt; , &lt;code&gt;carp()&lt;/code&gt; and other useful routines.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b8a9015ad51073a532bf2517dde18f5bf47fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak&lt;/code&gt; s on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dde23af6c8093917aed5e9b5c89f44d6c944ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dMY_CXT&lt;/code&gt; may be quite expensive to calculate, and to avoid the overhead of invoking it in each function it is possible to pass the declaration onto other functions using the &lt;code&gt;aMY_CXT&lt;/code&gt; /&lt;code&gt;pMY_CXT&lt;/code&gt; macros, eg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4109496804f1ccff0cccb7a3ca87fce4ed59e63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dTHR&lt;/code&gt; was introduced in perl 5.005 to support the older thread model. The older thread model now uses the &lt;code&gt;THX&lt;/code&gt; mechanism to pass context pointers around, so &lt;code&gt;dTHR&lt;/code&gt; is not useful any more. Perl 5.6.0 and later still have it for backward source compatibility, but it is defined to be a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead45fe5123d73507a0666226aa4b62056b56233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; behaves exactly like &lt;code&gt;when(1 == 1)&lt;/code&gt; , which is to say that it always matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4008378ece0030f25890322578641b9c803138" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; , &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;discard&lt;/code&gt; , and &lt;code&gt;autodefer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b466c384022ad6a6c0ee4613433ddf76214dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557a8972e18c8311f342ad928d9daccc79114ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach()&lt;/code&gt; can also be called as a class method to allow a thread to detach itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666fcacf663b1020377f259716313e99a0eb4f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach&lt;/code&gt; tells a thread that it is never going to be joined i.e. that all traces of its existence can be removed once it stops running. Errors in detached threads will not be visible anywhere - if you want to catch them, you should use $SIG{__DIE__} or something like that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b8c42099321a9dbc082b929829cf8884cb2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_testing()&lt;/code&gt; is, in effect, used when you'd want to use &lt;code&gt;no_plan&lt;/code&gt; , but safer. You'd use it like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ac2e7a1323e3e95635e4b26ab827cf6f59afef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dprofpp&lt;/code&gt; will produce some quite detailed reporting on the activity of the &lt;code&gt;wordmatch&lt;/code&gt; program. The wallclock, user and system, times are at the top of the analysis, and after this are the main columns defining which define the report. Check the &lt;code&gt;dprofpp&lt;/code&gt; docs for details of the many options it supports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698546fdd428508dc98fcd9f8400a97d365533e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encode_language_tag&lt;/code&gt; returns undef if given anything other than a formally valid language tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fbe3f0825cfe73fe04528e4db975b00a52f6e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; are scoping ops, and their job is to perform any housekeeping every time you enter and leave a block: lexical variables are tidied up, unreferenced variables are destroyed, and so on. Every program will have those first three lines: &lt;code&gt;leave&lt;/code&gt; is a list, and its children are all the statements in the block. Statements are delimited by &lt;code&gt;nextstate&lt;/code&gt; , so a block is a collection of &lt;code&gt;nextstate&lt;/code&gt; ops, with the ops to be performed for each statement being the children of &lt;code&gt;nextstate&lt;/code&gt; . &lt;code&gt;enter&lt;/code&gt; is a single op which functions as a marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66996551ac21df55b2bc452ee7dc1f32731364d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&lt;/code&gt; tests whether two thread objects represent the same thread and returns true if they do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2d19eb1b9a11a41c8b0d6eda83832900f64ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_pv&lt;/code&gt; is used to compile the anonymous subroutine, which will be the return value as well (read more about &lt;code&gt;eval_pv&lt;/code&gt; in &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;). Once this code reference is in hand, it can be mixed in with all the previous examples we've shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179018de7994d8b6f7b55507310a9615bad0e417" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect: &amp;lt;array&amp;gt;&lt;/code&gt; is a short notation for this &lt;code&gt;eexpect&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deecc348c11dde7ab1e03c51382e2279d9a03d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extproc&lt;/code&gt; on the first line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19dbee10355caceed0f77948f5b13c6093e8c93f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_archive&lt;/code&gt; will return a list of files it extracted. If the archive extraction fails for any reason, &lt;code&gt;extract_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca87326018240d68425ad1527419ad3fb2334b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; encountered a closing bracket where none was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a77e28ef0d2e144274c8fbd24790f3d60b8b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found a valid bracket delimiter, but it was the wrong species. This usually indicates a nesting error, but may indicate incorrect quoting or escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c61a56ae758be3198ca7d3e691e7f13c95604c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; ran out of characters in the text before closing one or more levels of nested brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcf9f5f74cb5d8d60170baf76820bbca368d16b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; attempted to match an embedded quoted substring, but failed to find a closing quote to match it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfae41ac82a57d25a5fa6795b1393b8584c13411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; extracts a balanced-bracket-delimited substring (using any one (or more) of the user-specified delimiter brackets: '(..)', '{..}', '[..]', or '&amp;lt;..&amp;gt;'). Optionally it will also respect quoted unbalanced brackets (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833ede635970a6e5a4797a94bd40b236c96804f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; was expecting a particular kind of bracket at the start of the text, and didn't find it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f0769606e5c4df36d78fd7ab228e7c6b52a6d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; attempts to recognize and extract a balanced bracket delimited substring that may contain unbalanced brackets inside Perl quotes or quotelike operations. That is, &lt;code&gt;extract_codeblock&lt;/code&gt; is like a combination of &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; and &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694f659fbf30e806d0fa08eafebb27223e5e1129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find a closing bracket to match the outermost opening bracket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9d1a3929e3f32a4e394299c676fec1e2f105c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find any of the outermost opening brackets that were specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdacc14c0fedd54fcae38c1a59283dd12b5836e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; or &lt;code&gt;extract_quotelike&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; followed by only one block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826adf3635e5637db1b98091d6fce40bd4513f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; takes the same initial three parameters as &lt;code&gt;extract_bracketed&lt;/code&gt; : a text to process, a set of delimiter brackets to look for, and a prefix to match first. It also takes an optional fourth parameter, which allows the outermost delimiter brackets to be specified separately (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da20ba6f0882f09698a1ff177d4124f0036f0383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_delimited&lt;/code&gt; takes up to four scalars (the input text, the delimiters, a prefix pattern to be skipped, and any escape characters) and extracts the initial substring of the text that is appropriately delimited. If the delimiter string has multiple characters, the first one encountered in the text is taken to delimit the substring. The third argument specifies a prefix pattern that is to be skipped (but must be present!) before the substring is extracted. The final argument specifies the escape character to be used for each delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4b075e70a63982d5b04d16716a200671436a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; and &quot;here documents&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7ff486ca0937ffab3f029877d80d0f77ca3ff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; attempts to recognize, extract, and segment any one of the various Perl quotes and quotelike operators (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59ff49a4b5f6ba09b71fdea263cb8784806bf34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; can successfully extract &quot;here documents&quot; from an input string, but with an important caveat in list contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb113a6f5a0b8ca2853b562185e3dd6bf68a942d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; didn't find one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; at the start of the substring it was extracting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f29c8f92e2cdfb541e8edc25037e7eac4fd9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; without a suitable block after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce38c6b480941e81870d18e2d86b4e985230f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; takes two arguments: the text to be processed and a prefix to be matched at the very beginning of the text. If no prefix is specified, optional whitespace is the default. If no text is given, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd291985f40d2410dcdccea5aef6741ed9a4c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; was unable to find a closing delimiter to match the one that opened the quote-like operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab932311516affb26a779abd90bbf158ec7ed4da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; did not find a suitable opening tag (after any specified prefix was removed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49b4a8e3f85ed5cd73910afb7ee2c747a5c1b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; extracts and segments text between (balanced) specified tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637bdb2768eba3ece0f28cf5c91285d816ae9df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested opening tag that was not matched by a corresponding nested closing tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907d9c187b04ce8805d54962d6f295d6dafa82c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested tag that appeared in the &quot;reject&quot; list (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6e6b22bc490e070f19db3dd2c598898377ca76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; matched the specified opening tag and tried to modify the matched text to produce a matching closing tag (because none was specified). It failed to generate the closing tag, almost certainly because the opening tag did not start with a bracket of some kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618b7e2d79570afb079bf76fc8475883cfbcb511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; reached the end of the text without finding a closing tag to match the original opening tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8016033fd7e7766b06e4030e83ba977c1f1697" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; extracts any valid Perl variable or variable-involved expression, including scalars, arrays, hashes, array accesses, hash look-ups, method calls through objects, subroutine calls through subroutine references, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b44e96da00224d0d2ec78bc381db1051d7b97be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; found a '$', '@', or '%' indicating a variable, but that character was not followed by a legal Perl identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dce7208a693c0dcdcc44097a9a03bc9f5f50c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; was expecting one of '$', '@', or '%' at the start of a variable, but didn't find any of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7183702bf36011a80e32e87169e8ae3121aaff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdopen&lt;/code&gt; is like an ordinary &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, an IO::Handle object, or a file descriptor number. (For the documentation of the &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; method, see &lt;a href=&quot;file&quot;&gt;IO::File&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03fc961bee53ba972305eb9fb700a55c4e14e62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill_mstats($buf)&lt;/code&gt; is a much cheaper call (both speedwise and memory-wise) which collects the statistic into $buf in machine-readable form. At a later moment you may need to call &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; to use this information to fill %hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e5d4f5538cc74799b8419786d322d044582dea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find()&lt;/code&gt; does a depth-first search over the given &lt;code&gt;@directories&lt;/code&gt; in the order they are given. For each file or directory found, it calls the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine. (See below for details on how to use the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function). Additionally, for each directory found, it will &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; into that directory and continue the search, invoking the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function on each file or subdirectory in the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26ed17cfa2816485cbc28d5fbb0568e82932f2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finddepth()&lt;/code&gt; works just like &lt;code&gt;find()&lt;/code&gt; except that it invokes the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function for a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29620a24a0df648a414eb9cf851d4bf4806d6e4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; allows only &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt; , which allows for trailing non-numeric text on an otherwise successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeb70073109db72816d4b058f24b70066251071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; can be set to SVf_UTF8 if &lt;code&gt;name&lt;/code&gt; is a UTF8 string, or the return value of SvUTF8(sv). It can also take the GV_ADDMULTI flag, which means to pretend that the GV has been seen before (i.e., suppress &quot;Used once&quot; warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e3f0cb7744b6ea7a16d5b8162ae81c50f936d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush&lt;/code&gt; causes perl to flush any buffered data at the perlio api level. Any unread data in the buffer will be discarded, and any unwritten data will be written to the underlying file descriptor. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9905682a79a998de7ff1e83caeeafa645f241b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_cache(function)&lt;/code&gt; will flush out the caches, discarding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5d6c6cb2f1fedfbb1c398cf830e60872b2d25d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==0&lt;/code&gt; causes File::Find to die if any file is about to be processed a second time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245a14cc849e45d0f21aa3c6a45e6687f9b1b64a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==1&lt;/code&gt; , which is the default, causes all files which are neither directories nor symbolic links to be ignored if they are about to be processed a second time. If a directory or a symbolic link are about to be processed a second time, File::Find dies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a84133d805b081624353f19b1e15e4f4f2316a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==2&lt;/code&gt; causes File::Find to ignore any duplicate files and directories but to proceed normally otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b488c92ca6be1e23d4299b935b09ca768ca7bd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af037f92dbe22f9677ccba3af252180c69239c0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; probably won't do what you expect if VAR is a tied or other special variable. Don't do that either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4a74a3423620b717e8515966c608ea94d077f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_to()&lt;/code&gt; returns the length of the converted string in octets on success, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee56073a87e8cb2ec407581f4115873a117f0638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_delimited_pat&lt;/code&gt; may also be called with an optional second argument, which specifies the &quot;escape&quot; character(s) to be used for each delimiter. For example to match a Pascal-style string (where ' is the delimiter and '' is a literal ' within the string):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3889013df238b89a769a62665a92aecb6580a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_extract_tagged&lt;/code&gt; generates a new anonymous subroutine which extracts text between (balanced) specified tags. In other words, it generates a function identical in function to &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fc46087afc34909f3ff50b3a35f51dd87159b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; downloads a distribution file and untars or unzips it, &lt;code&gt;make&lt;/code&gt; builds it, &lt;code&gt;test&lt;/code&gt; runs the test suite, and &lt;code&gt;install&lt;/code&gt; installs it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597f829bafddc48835ebea8c700b577d34cea8b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of the list of classes it will try using. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_language_classes&lt;/code&gt; , which currently returns an empty list, &lt;code&gt;()&lt;/code&gt; . By setting this to some value (namely, the name of a loadable language class), you can be sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d51dfcba73441795cbac2c1e95e837ccfcfefe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of whatever list of languages you pass &lt;code&gt;get_handle&lt;/code&gt; . Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_languages&lt;/code&gt; , which currently returns &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt; . (&quot;i-default&quot; is defined in RFC 2277).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf569ccd5c0de9aae2bc67f8d6ef04eaf70c3485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git&lt;/code&gt; only supports &lt;code&gt;git://&lt;/code&gt; style urls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85aa8588ef6572feba5f3f7196b55f9be2ff8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gnu_compat&lt;/code&gt; controls whether &lt;code&gt;--opt=&lt;/code&gt; is allowed, and what it should do. Without &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; gives an error. With &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; will give option &lt;code&gt;opt&lt;/code&gt; and empty value. This is the way GNU getopt_long() does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da23eeb6ab9c230c23432ea70d9c9e7b965fbe5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gunzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b8e8c4b2f2968447ed1a4e47f9c92d6075290d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gv&lt;/code&gt; is the scalar to be converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29db96deb265ac3c7d7d0953f53bc03ef4c2f394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e77ef19371ab42dd3ee159db29ed1de58b556a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help&lt;/code&gt; will get you into the documentation, but here are the most useful commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33ba501199bdab9a127e2b1f7b1b40f51678514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; - sets the hostname to send the messages to. Defaults to the local host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c02ec2bc6d085cd003b0ab590c3cedf46f1d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; are also allowed, but only for completeness' sake: they are identical to &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38745558cff56e73757d72d93d0e833b8ab829ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id()&lt;/code&gt; also uses a caching technique that makes it faster when the id of an object is requested often, but slower if it is needed only once or twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1014df6f9393ccdb9b982a8f0cdabec78db82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; executes the statement once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b896458be3e65959268ad7eb2dbf0a7972aba118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import_extra()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt;. It provides an opportunity for you to add behaviors to your module based on its import list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf041671b0859bae0d069d4abdaaec3333d3078b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48e2284b44cc7c2c571d6415bc1d2a1c3a3bad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iosock&lt;/code&gt; is a very limited &lt;a href=&quot;../io/socket/inet&quot;&gt;IO::Socket::INET&lt;/a&gt; based mechanism for retrieving &lt;code&gt;http&lt;/code&gt; schemed urls. It doesn't follow redirects for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f4cb95b2a1340b2264c404136042989b18f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; can do that better and with diagnostics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa45eb9c353e9becb0910ea19cd26aa2cc1efcb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; compares the dereferenced values of references, the references themselves (except for their type) are ignored. This means aspects such as blessing and ties are not considered &quot;different&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac9608b72d885f105d8ded955f2852bb1f4026f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; currently has very limited handling of function reference and globs. It merely checks if they have the same referent. This may improve in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fee01bdd14b870e8f587577165aaba8174b5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_loaded&lt;/code&gt; tells you if &lt;code&gt;PACKAGE&lt;/code&gt; has been marked as loaded yet. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908cf7f802a6484de1a86d6a37939c96ffeeea32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_negative()&lt;/code&gt; is an alias for &lt;code&gt;is_neg()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e24bd0e67b03038233cb69159892773438e44e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_our&lt;/code&gt; indicates that the name to check is an 'our' declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a514d3b918898f19b078949b55c4b50405311f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; are aliases to &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; , respectively. &lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; were introduced in v1.36, while &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; were only introduced in v1.68.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36dbe9a547bda60465b84e97fa8c4255f94a0b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; is an alias for &lt;code&gt;is_pos()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ebfddb80039ad6fdcb40b1907d93271e7168e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_shared&lt;/code&gt; checks if the specified variable is shared or not. If shared, returns the variable's internal ID (similar to &lt;code&gt;refaddr()&lt;/code&gt; (see &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;). Otherwise, returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3e625f9dccecad6923a6b9bcad7bcf170e05e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isa&lt;/code&gt; methods behave appropriately).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05461b3d98ad64340381f43af6ab96dfd13c6be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778b80cfdd673f8fb55921afdf3d3a38219c358b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79ceaa8331c46467666b58e2fedd38e6ff4a586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; will warn about this. The sole exceptions are files with the &lt;code&gt;.par&lt;/code&gt; extension which are intended to be used as libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbdb4f0306520f7abe5482b14dfce7a7aa50e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load_handlers&lt;/code&gt; will attempt to load the &lt;code&gt;MySourceHandler&lt;/code&gt; class by looking in &lt;code&gt;@INC&lt;/code&gt; for it in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781e302076091acf759d87fc441e0a784931b032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localeconv()&lt;/code&gt; takes no arguments, and returns &lt;b&gt;a reference to&lt;/b&gt; a hash. The keys of this hash are variable names for formatting, such as &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; . The values are the corresponding, er, values. See &lt;a href=&quot;posix#localeconv&quot;&gt;localeconv in POSIX&lt;/a&gt; for a longer example listing the categories an implementation might be expected to provide; some provide more and others fewer. You don't need an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , because &lt;code&gt;localeconv()&lt;/code&gt; always observes the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4a29ff759286dc4a0d846a54fba072c0f2b509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt; only work with files opened in binary mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883ccb60af102a63dca29d53e2d458e06fa1f4e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lynx&lt;/code&gt; can only fetch remote files by dumping its contents to &lt;code&gt;STDOUT&lt;/code&gt; , which we in turn capture. If that content is a 'custom' error file (like, say, a &lt;code&gt;404 handler&lt;/code&gt;), you will get that contents instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886031ca39127136a93f5c58154011b1571ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the group ownership of created directories to the symbolic name [group], but &lt;code&gt;&lt;a href=&quot;../functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric gid. The directory will be created, but group ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3237359a6cb04586bfde967ca0039e3278fe9e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the ownership of created directories to the symbolic name [owner], but &lt;code&gt;&lt;a href=&quot;../functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric uid. The directory will be created, but ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc7e268861ebf6c487de7b9a430854e30e76cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was not given any paths to create. This message is only emitted if the routine is called with the traditional interface. The modern interface will remain silent if given nothing to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755c6f5063eb2e334da849c0ce6318b9f39c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was unable to create the path. Probably some sort of permissions error at the point of departure, or insufficient resources (such as free inodes on Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a8fe35478388c546b0d41c18eefc372419fd9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maketext&lt;/code&gt; and other methods to do with accessing %Lexicon data for a given language handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3d67fea62a065d10c5926428fdebd26c6a5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mantissa()&lt;/code&gt; and &lt;code&gt;exponent()&lt;/code&gt; return the said parts of the BigInt such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b922a1e8b8a437e6a25aad879f34f0de9830b8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask&lt;/code&gt; is recognised as an alias for this parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03355b926946894926cfadae3a6b81818310b791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memoize&lt;/code&gt; knows that if the normalized version of the arguments is the same for two argument lists, then it can safely look up the value that it computed for one argument list and return it as the result of calling the function with the other argument list, even if the argument lists look different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588d0d71e67f680f937b2933e4e80482741a6b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meth&lt;/code&gt; is the name of the method to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c382bf574ac941794f4ceb11f1a7cf0a554b70e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;miniperl -MCross -MConfig -we 1&lt;/code&gt; should run okay, and it will provide right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffeff3899ad34654b8fd715931df104143ede2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ff8f6ef90463a78a4980b3e772f012f8f89756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlenret&lt;/code&gt; is the minimum length (in characters) of the string that would be found in $&amp;amp; after a match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa93a538eb746e066effec46888283ca286ffddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may have the values &lt;code&gt;deterministic&lt;/code&gt; for the case where all questions come in the order written down and &lt;code&gt;anyorder&lt;/code&gt; for the case where the questions may come in any order. The default mode is &lt;code&gt;deterministic&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a292f2351d2499cb4d3956fe35448489fd6cf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_popen&lt;/code&gt; uses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe304a6dc30cae0afd16e8b92b6cd1cd7ce95c7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcat()&lt;/code&gt; appends string &lt;code&gt;src&lt;/code&gt; to the end of &lt;code&gt;dst&lt;/code&gt; . It will append at most &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; characters. It will then &lt;code&gt;NUL&lt;/code&gt; -terminate, unless &lt;code&gt;size&lt;/code&gt; is 0 or the original &lt;code&gt;dst&lt;/code&gt; string was longer than &lt;code&gt;size&lt;/code&gt; (in practice this should not happen as it means that either &lt;code&gt;size&lt;/code&gt; is incorrect or that &lt;code&gt;dst&lt;/code&gt; is not a proper &lt;code&gt;NUL&lt;/code&gt; -terminated string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdedecbe5c820473f669d0af506ce2015ddd5193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcpy()&lt;/code&gt; copies up to &lt;code&gt;size - 1&lt;/code&gt; characters from the string &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; , &lt;code&gt;NUL&lt;/code&gt; -terminating the result if &lt;code&gt;size&lt;/code&gt; is not 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4001332f8ab98ef832acfc949829d1eb7d7cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to represent signed 16-/32-bit integers in big-/little-endian order. This is portable only when all platforms sharing packed data use the same binary representation for signed integers; for example, when all platforms use two's-complement representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6a21fed22915a331be3383e5b5b4032f977a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; give the name. The name must be unqualified; that is, it must not include the package name. If &lt;code&gt;gv&lt;/code&gt; is a stash element, it is the caller's responsibility to ensure that the name passed to this function matches the name of the element. If it does not match, perl's internal bookkeeping will get out of sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95c68737e4cdbac2fa96320e25fc1fa20440782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ndelay&lt;/code&gt; - Open the connection immediately (normally, the connection is opened when the first message is logged).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7953c406c8ff699f7523d2c0fa454774e594fafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new()&lt;/code&gt; is a synonym for &lt;code&gt;create()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2a9ff681510122f5292361c80d05ba72747aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; creates a new semaphore, and initializes its count to the specified number (which must be an integer). If no number is specified, the semaphore's count defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efedbfabb0d57daca4e55f1c80323100b61e0eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is the constructor for &lt;code&gt;IO::Dir&lt;/code&gt; objects. It accepts one optional argument which, if given, &lt;code&gt;new&lt;/code&gt; will pass to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ebed1aa25ba5c1ac9f9e4c204e2addbac198e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; starts a new thread of execution in the referenced subroutine. The optional list is passed as parameters to the subroutine. Execution continues in both the subroutine and the code after the &lt;code&gt;new&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92dfd8fef1985419787a429944b6929b7d15145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noeol&lt;/code&gt; - When set to true, no end of line character (&lt;code&gt;\n&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da13afac64a19ada71fa128b3727ac19b9a817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nofatal&lt;/code&gt; - When set to true, &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt; will only emit warnings instead of dying if the connection to the syslog can't be established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d145b40dff849bfb7be76022f83e7b4e1ab3e8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonul&lt;/code&gt; - When set to true, no &lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;\0&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eced03bcdab870ab9edcbe9dc4bb03fa8ec64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal&lt;/code&gt; is a string like &quot;ToLower&quot; which means the swash %utf8::ToLower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54ce6f923598d61f4c291c2231596a77ff50261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalization&lt;/code&gt; is performed after &lt;code&gt;preprocess&lt;/code&gt; (if defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c787cbcd0d732de5ebfc6c56bc124a3d88f16c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalize&lt;/code&gt; and other some functions: on request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38203e290e1449681c9a41b7d479b27b8df21db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nowait&lt;/code&gt; - Don't wait for child processes that may have been created while logging the message. (The GNU C library does not create a child process, so this option has no effect on Linux.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4694888bc88f2c3c8dc0bbded8e50a8bc2b38846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparens&lt;/code&gt; , &lt;code&gt;lastparen&lt;/code&gt; , and &lt;code&gt;lastcloseparen&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104bc44857c778695c79d0d1e8b5b9a2c1281a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num()&lt;/code&gt; returns the numeric value of the input Unicode string; or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't think the entire string has a completely valid, safe numeric value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7b6da46d3ad3066f3c734bb010fb7646c3f1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num&lt;/code&gt; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize. Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points. The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &lt;code&gt;\d&lt;/code&gt; will not match them. A single-character string containing one of these digits will have its decimal value returned by &lt;code&gt;num&lt;/code&gt; , but any longer string containing only these digits will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be874a64ffa774adf425ae056b0282a20c6623c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o debug&lt;/code&gt; without an argument lists the valid package names and the current set of packages in debugging mode. &lt;code&gt;o debug&lt;/code&gt; has built-in completion support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466246a0ea0bcd1da5e37ea4ea93b6e2eb95b97a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; is given an expression (in this case &lt;code&gt;$foo eq $bar&lt;/code&gt; ). If it's true, the test passed. If it's false, it didn't. That's about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab5a47d8307c5982472639709641b589ddb9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; prints out either &quot;ok&quot; or &quot;not ok&quot; along with a test number (it keeps track of that for you).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f0e19d76f2346c39f954fb30c54feae693b547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's special handing of strings which look like they might be regexes can also cause unexpected behavior. An innocent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9453067bce99ddb6c0b34c1ad76b7773aa72eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's use of string &lt;code&gt;eq&lt;/code&gt; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6826999eb95521e6d8d3b9f0c51592f03d979f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onfail&lt;/code&gt; hook might be used simply to print out the version of your package and/or how to report problems. It might also be used to generate extremely sophisticated diagnostics for a particularly bizarre test failure. However it's not a panacea. Core dumps or other unrecoverable errors prevent the &lt;code&gt;onfail&lt;/code&gt; hook from running. (It is run inside an &lt;code&gt;END&lt;/code&gt; block.) Besides, &lt;code&gt;onfail&lt;/code&gt; is probably over-kill in most cases. (Your test code should be simpler than the code it is testing, yes?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7349d9655c667539e75d17a6e784d90202513f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os2_stat&lt;/code&gt; special-cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae20ae53e9337f9b303890d15d0d3b627b7ddae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overrideOut&lt;/code&gt; can perform it algorithmically. This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018daadf3e8c264d84f963dafe9df6707fe0f4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; contains the pointer to the UTF-8 string encoding the character that is being converted. This routine assumes that the character at &lt;code&gt;p&lt;/code&gt; is well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11c698ac9fefb8ffaa9a6b715e3d39e29a9a669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pTHX_&lt;/code&gt; is one of a number of macros (in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5576100284e538d6e57d1d31b55e0b0abbd897e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad345d37c7dffa7c8f4f00e258549543dd5b66f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - equivalent to &lt;code&gt;$stream_location&lt;/code&gt; , sets the stream location. Defaults to standard Unix location, or &lt;code&gt;_PATH_LOG&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b3947fbb2cde48071637c1ce2c9e11e4a635a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt; would match if anchored at the given position, and it matches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363c3b041828e47609537312596fa6f5289a7cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_parse&lt;/code&gt; is actually a wrapper around &lt;code&gt;S_parse_body&lt;/code&gt; , as defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98336dcec32bd23880560249be78854ad195f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; also searches directories specified by the &lt;code&gt;PERL5LIB&lt;/code&gt; (or &lt;code&gt;PERLLIB&lt;/code&gt; if &lt;code&gt;PERL5LIB&lt;/code&gt; is not defined) and &lt;code&gt;PATH&lt;/code&gt; environment variables. (The latter is so that embedded pods for executables, such as &lt;code&gt;perldoc&lt;/code&gt; itself, are available.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845299ed0481bf59a19162b1d7d0d6134de3b1f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; is also a useful tool for browsing information contained in the documentation, especially in conjunction with a pager like &lt;code&gt;less&lt;/code&gt; (recent versions of which have Windows support). You may have to set the PAGER environment variable to use a specific pager. &quot;perldoc -f foo&quot; will print information about the perl operator &quot;foo&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ef34f009dc3c8dfa646a2efd211a1e35cb6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; will use, in order of preference, the pager defined in &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; , &lt;code&gt;MANPAGER&lt;/code&gt; , or &lt;code&gt;PAGER&lt;/code&gt; before trying to find a pager on its own. (&lt;code&gt;MANPAGER&lt;/code&gt; is not used if &lt;code&gt;perldoc&lt;/code&gt; was told to display plain text or unformatted pod.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2849be26c68f462d616e31ee18a116b7064450b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perror&lt;/code&gt; - Write the message to standard error output as well to the system log (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7d63b44a36159d8e1d4d4335b3daf634e99588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - Include PID with each message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809c4b7facc3eb780b2058815a2dcb35dc65ca46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plan&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb276cbb4ba5fc7d3b0e940bad1ed0150bce045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; - sets the TCP or UDP port to connect to. Defaults to the first standard syslog port available on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ec803c3dc008a3da16774edaa8dc9ffe50879f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postok&lt;/code&gt; will return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d01a0fab20d0ff1f998f75c0cb1da085f4f2052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826665825a05ce6bea816703958f3affe8424f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision()&lt;/code&gt; sets or gets the global or local precision, aka at which digit before or after the dot to round all results. A set global precision also applies to all newly created numbers!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976cc4186db8951c059e488dda4302f51af45d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a05fc7c2ec9c9f8d0b33a7a4310351fcbd1f41e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; means: where to install the resulting perl library. Giving correct prefix you may avoid the need to specify &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; , see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aaf8a737c0d23218299cfdec2230f7a8f0c080c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pregexec()&lt;/code&gt; is the main entry point for running a regex. It contains support for initialising the regex interpreter's state, running &lt;code&gt;re_intuit_start()&lt;/code&gt; if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter &lt;code&gt;pregexec()&lt;/code&gt; calls &lt;code&gt;regtry()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5650857d710e489383ebef502cde7faf3c94b385" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess&lt;/code&gt; is performed before &lt;code&gt;normalization&lt;/code&gt; (if defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27df3d04b2fd880e0c0f8504356cc9a3aee349a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does know about the Perl extensions to Unicode properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;XPosixAlpha&lt;/code&gt; , and the single form equivalents to Unicode properties such as &lt;code&gt;XDigit&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;In_Greek&lt;/code&gt; , and &lt;code&gt;Is_Greek&lt;/code&gt; . The final example demonstrates that the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix is recognized for these extensions; it is needed to resolve ambiguities. For example, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; returns the list &lt;code&gt;(&lt;a href=&quot;../functions/lc&quot;&gt;lc&lt;/a&gt;, Lowercase_Mapping)&lt;/code&gt; , but &lt;code&gt;prop_aliases('islc')&lt;/code&gt; returns &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . This is because &lt;code&gt;islc&lt;/code&gt; is a Perl extension which is short for &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; . The lists returned for the Perl extensions will not include the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix (whether or not the input had it) unless needed to resolve ambiguities, as shown in the &lt;code&gt;&quot;islc&quot;&lt;/code&gt; example, where the returned list had one element containing &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; , and the other without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84247d6d8b5f4deb4e612831eb63153e1c94e8c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those. Likewise for Perl internal properties, with the exception of &quot;Perl_Decimal_Digit&quot; which it does know about (and which is documented below in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf618289fe95f5c6591702e1bf3bea4922c7495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; does not know about any user-defined nor Perl internal-only properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5aeeb87bafc369250d5ed39e16fa0a2f0af855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; returns an inversion list (described below) that defines all the code points for the binary Unicode property (or &quot;property=value&quot; pair) given by the input parameter string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa989c8b4b5a95be8ec4aa8facd791849d814072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b5d2b41a100d477c28d52672a39b5906a388f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is called with the name of the desired property. The name is loosely matched, meaning that differences in case, white-space, hyphens, and underscores are not meaningful (except for the trailing underscore in the old-form grandfathered-in property &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , or even better, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3074dd56d5e2ce626fd458ce5170ea74b97c7854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is used to get the complete mapping definition for a property, in the form of an inversion map. An inversion map consists of two parallel arrays. One is an ordered list of code points that mark range beginnings, and the other gives the value (or mapping) that all code points in the corresponding range have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65de781e7dc1c905cffccb28d15af3c75f99eaef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_value_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aedd3349055ca063b2a3be5fc3130232f4fe52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_values&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe37f0dcf25b4c9fbcdaa8fe00af0106f0a081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawdeflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8c618e9a88333bd82066b9c07a4093fb94d4fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1f960c44856903d77b260a19d1e06dab18de4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_intuit_start()&lt;/code&gt; is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by &lt;code&gt;study_chunk()&lt;/code&gt; (and described in &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;Peep-hole Optimisation and Analysis&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6225c296acfc5e3b5f6f0c2e8719d05816704086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readme&lt;/code&gt; displays the README file of the associated distribution. &lt;code&gt;Look&lt;/code&gt; gets and untars (if not yet done) the distribution file, changes to the appropriate directory and opens a subshell process in that directory. &lt;code&gt;perldoc&lt;/code&gt; displays the module's pod documentation in html or plain text format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616eedbf531a925f329a14e071a3cf7f343db86b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rearrange&lt;/code&gt; and &lt;code&gt;hangul_terminator&lt;/code&gt; parameters are neglected. &lt;code&gt;katakana_before_hiragana&lt;/code&gt; and &lt;code&gt;upper_before_lower&lt;/code&gt; don't affect matching and searching, as it doesn't matter whether greater or less.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7e3a62ac5d117a96b72d8dcabc1b9d96e467f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reg()&lt;/code&gt; is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl's regexes have. For instance when parsing &lt;code&gt;/x(?:foo)y/&lt;/code&gt;&lt;code&gt;reg()&lt;/code&gt; will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c957111983f253e3076925e4631813db6c2822e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regbranch()&lt;/code&gt; in turn calls &lt;code&gt;regpiece()&lt;/code&gt; which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, &lt;code&gt;regatom()&lt;/code&gt; is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like &lt;code&gt;$&lt;/code&gt; . If &lt;code&gt;regatom()&lt;/code&gt; encounters a &quot;(&quot; character it in turn calls &lt;code&gt;reg()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0285a40e365527c3360c8043442411516f88d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regmatch&lt;/code&gt; is the main &quot;recursive loop&quot; of the interpreter. It is basically a giant switch statement that implements a state machine, where the possible states are the regops themselves, plus a number of additional intermediate and failure states. A few of the states are implemented as subroutines but the bulk are inline code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34320379070d5c0b4b993f583fcab86440065756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_1&lt;/code&gt; structures have the same header, followed by a single four-byte argument; &lt;code&gt;regnode_2&lt;/code&gt; structures contain two two-byte arguments instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dba4a9bca93381c17cd610e0197a487dcb2427" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_string&lt;/code&gt; structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the end with zero bytes so that the total length of the node is a multiple of four bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da61c4024c5fde5d0d5083c10881096ea875b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regtry()&lt;/code&gt; is the entry point into the regex interpreter. It expects as arguments a pointer to a &lt;code&gt;regmatch_info&lt;/code&gt; structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around &lt;code&gt;regmatch()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d191563625501cd0dd042566cf3df9fdb6af17ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything and restored the permissions of a directory, was unable to chdir back to the parent. The program halts to avoid a race condition from occurring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e30094b13da141ed1e37ede35a62255c66728a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything in a directory, attempted to restore its permissions to the original state but failed. The directory may wind up being left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7b650aa563617f4ec9fe94e5aa32c051a39081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to change the permissions on the current directory to ensure that subsequent unlinkings would not run into problems, but was unable to do so. The permissions remain as they were, and the program will carry on, doing the best it can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bc3df474e248a2e04291479bd3fa33e8cd5330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to determine the initial directory by calling &lt;code&gt;Cwd::getcwd&lt;/code&gt; , but the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6ce072680f1019c3f3f85b4a8ee961eafa33e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to force the permissions of a file to ensure it could be deleted, but failed to do so. It will, however, still attempt to unlink the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49be99d75fc1d4ab8517776a2c9c7bb74ae38eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to remove a directory, but failed. This may because some objects that were unable to be removed remain in the directory, or a permissions issue. The directory will be left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7616985ed5b969eec07392de1388ed772d59985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to set the working directory in order to begin deleting the objects therein, but was unsuccessful. This is usually a permissions issue. The routine will continue to delete other things, but this directory will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721db6f7a6d0b1be4b6b64fdeb2aa4c3fac630d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to stat the initial directory (after having successfully obtained its name via &lt;code&gt;getcwd&lt;/code&gt; ), however, the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2cfce733e90f2119a65972900f218ea1224963" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; failed to remove a file. Probably a permissions issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7780e89fe07af9e10d0c6e4dc374ef9437694de0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; recorded the device and inode of a directory, and then moved into it. It then performed a &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on the current directory and detected that the device and inode were no longer the same. As this is at the heart of the race condition problem, the program will die at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c936a52751bd20d0155292a8ba2362d698dcd12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; tried to read the contents of the directory in order to acquire the names of the directory entries to be unlinked, but was unsuccessful. This is usually a permissions issue. The program will continue, but the files in this directory will remain after the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0893a833dba2da63d1689754e9baa173690a309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; was unable to stat the parent directory after have returned from the child. Since there is no way of knowing if we returned to where we think we should be (by comparing device and inode) the only way out is to &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd69d2d3e18f341cf60a46af272519b5c3cf1a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require_ok&lt;/code&gt; will guess whether the input is a module name or a filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8505e44467f89d3c5f13e3b0f5be5320e0760bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; can tell you what other modules a particular module requires. This is particularly useful when you're intending to write a module for public release and are listing its prerequisites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7622f99d032d83f40f152407bc369319dc35bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; takes but one argument: the name of a module. It will then first check if it can actually load this module, and return undef if it can't. Otherwise, it will return a list of modules and pragmas that would have been loaded on the module's behalf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6e70e552e6b050c1d411581b7b701935fc2d73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve_alias()&lt;/code&gt; does not need &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode::Alias&lt;/code&gt; ; it can be imported via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(resolve_alias)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409864670ba5b3a51d91aefad2f1baba7ffb1971" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; takes 4 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5e870ed1d46dfd7cef6254dbdde44232014c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will return a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; when called in scalar context. In list context, you will be returned a list of the following items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71adfc24f9d2e25fb176cec5e34573530b5011a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will try to execute your command using the following logic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bf1af5a461bb65504ae6074130c8cb94c99510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is designed to survive and successfully terminate almost any long running task, even a fork bomb in case your system has the resources to survive during given timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5d98ab787a66354808b7b8789a0245cef29116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is used to execute some program or a coderef, optionally feed it with some input, get its return code and output (both stdout and stderr into separate buffers). In addition, it allows to terminate the program if it takes too long to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420efc1f7e2a39e2d481baf8e0b32a892ee30985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; will return a HASHREF with the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44468ed2da13e6b0326d22ae098610e252ce2bf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;same_language_tag&lt;/code&gt; works by just seeing whether &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; is the same as &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48e38b365ce4bf6a3953fa6b04bb2ccda99aa7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_invlist&lt;/code&gt; is used to search an inversion list returned by &lt;code&gt;prop_invlist&lt;/code&gt; or &lt;code&gt;prop_invmap&lt;/code&gt; for a particular &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned if the code point is not found in the inversion list (this happens only when it is not a legal &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or is less than the list's first element). A warning is raised in the first instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e70016d81c26851fdc1268a308e2475dcb72857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; accepts either a stat object, as returned by the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; method, or a list of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c710408719efbb408db55c8531da370f8ff3d836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed728d4e7f99edf863813e9844924ed524fa1809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the semaphore set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d152a9c3ab9b89b16e2ee46596cf4f0fc19888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location)&lt;/code&gt; (added in Perl 5.004_02)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583013ce20407688d7c0e999267ffc67b0502e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location, $sock_timeout)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.25)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87975c40147558f5f2ec4bebf437a9d770df0f75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock(\%options)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.28)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd0c1e5dd9ea33cf369c7adb90355be92008a07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; allows you to &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; and &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; without giving any error message. But the &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; or &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; shared, causing the error &quot;lock can only be used on shared values&quot; to occur when you attempt to &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($hashref-&amp;gt;{key})&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($arrayref-&amp;gt;[idx])&lt;/a&gt;&lt;/code&gt; in another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81400b21c44e81d3c85b6d25672fdb393b6c9649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; takes a variable and marks it as shared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5f83dec6e18c4adabc00639c9878d8824925ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; will return the shared rvalue, but always as a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce12ad32c52f4a291a29b41a4671200a88ca0b1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_clone&lt;/code&gt; takes a reference, and returns a shared version of its argument, performing a deep copy on any non-shared elements. Any shared elements in the argument are used as is (i.e., they are not cloned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8658f86d4777991376871c792874bcf7ea900b4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;special&lt;/code&gt; is a string, normally &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; . &lt;code&gt;NULL&lt;/code&gt; means to not use any special mappings; &lt;code&gt;&quot;&quot;&lt;/code&gt; means to use the special mappings. Values other than these two are treated as the name of the hash containing the special mappings, like &lt;code&gt;&quot;utf8::ToSpecLower&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c96f14b329fe16bad75b1f046bad021a838c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;splitOnLastStarter()&lt;/code&gt; should be called with a pre-normalized parameter &lt;code&gt;$normalized&lt;/code&gt; , that is in the same form as &lt;code&gt;$form&lt;/code&gt; you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ad3d7e63ac0b923f42fda199d17cb36805c894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split_command&lt;/code&gt; will return a series of @cmds each processing part of the args. Collectively they will process all the arguments. Each individual line in @cmds will not be longer than the $self-&amp;gt;max_exec_len being careful to take into account macro expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9992eebbce269337eb7319fad7e4bae82773d69d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stash&lt;/code&gt; is the parent stash/package, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442fca8656f150edfde3e5013ba8d6ad88bb942b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9a328ccbc35b2b8e9066fa880a1d90d69b6a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict 'subs'&lt;/code&gt; , with Perl 5.6.1, erroneously permitted to use an unquoted compound identifier (e.g. &lt;code&gt;Foo::Bar&lt;/code&gt; ) as a hash key (before &lt;code&gt;=&amp;gt;&lt;/code&gt; or inside curlies), but without forcing it always to a literal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d0dc79bd558fb009a4a67ce8058c54beea585e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtod&lt;/code&gt; respects any POSIX &lt;code&gt;setlocale()&lt;/code&gt;&lt;code&gt;LC_TIME&lt;/code&gt; settings, regardless of whether or not it is called from Perl code that is within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c9831d319071b95082e8dc2f29b6eca1f78c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtol&lt;/code&gt; should respect any POSIX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d9fc447173aa1507860d93adda713683bb7035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; always creates a constructor called &lt;code&gt;new&lt;/code&gt; . That constructor may take a list of initializers for the various elements of the new struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f3f10d3365e07935bc666c63b8354aa30d2606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strxfrm()&lt;/code&gt; takes a string and maps it into a transformed string for use in char-by-char comparisons against other transformed strings during collation. &quot;Under the hood&quot;, locale-affected Perl comparison operators call &lt;code&gt;strxfrm()&lt;/code&gt; for both operands, then do a char-by-char comparison of the transformed strings. By calling &lt;code&gt;strxfrm()&lt;/code&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;Magic Variables in perlguts&lt;/a&gt;) creates the transformed version of a string the first time it's needed in a comparison, then keeps this version around in case it's needed again. An example rewritten the easy way with &lt;code&gt;cmp&lt;/code&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call &lt;code&gt;strxfrm()&lt;/code&gt; directly, it treats the first null it finds as a terminator. don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call &lt;code&gt;strxfrm()&lt;/code&gt; directly: let Perl do it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae013383db419ee7073c6ec936d1ee516677026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bbbc9ec3becb0729e14cb1a39b889ca48e69af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest()&lt;/code&gt; runs the &amp;amp;code as its own little test with its own plan and its own result. The main test counts this as a single test using the result of the whole subtest to determine if its ok or not ok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bfa9180cd766541f95ecd65e0c84670fed2bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest&lt;/code&gt; also, and optionally, accepts arguments which will be passed to the subtests reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53945fe0e229f2a3d9e218abb1d550e5ef4cb623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , or &lt;code&gt;fatal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edbfcf499afde359ec82161688eeb181e0cc64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;summary&lt;/code&gt; prints the summary report after all tests are run. The first argument is an aggregate to summarise. An optional second argument may be set to a true value to indicate that the summary is being output as a result of an interrupted test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d76fa49c169f566fa1c1da718f1e7b2ad5c1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; , &lt;code&gt;av&lt;/code&gt; , &lt;code&gt;hv&lt;/code&gt; , etc. represent variables of their respective types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e738adb0309ebb6a8435f716aa40a76e770938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;mg&lt;/code&gt; are the tied thingy and the tie magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c898bb2d89a58d12a4afd52693893972cc7118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt; , and &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157cb2f67b5c943efab75ae716b270926cd23e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_vsetpvfn&lt;/code&gt; is an analogue of &lt;code&gt;vsprintf&lt;/code&gt; , but it allows you to specify either a pointer to a variable argument list or the address and length of an array of SVs. The last argument points to a boolean; on return, if that boolean is true, then locale-specific information has been used to format the string, and the string's contents are therefore untrustworthy (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). This pointer may be NULL if that information is not important. Note that this function requires you to specify the length of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192b1f9a09d1e08c5d741af54f3f7df0fea1f0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;swashp&lt;/code&gt; is a pointer to the swash to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2da7c9c32ace5dff26064e81dc2ec6cc09498f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync&lt;/code&gt; synchronizes a file's in-memory state with that on the physical medium. &lt;code&gt;sync&lt;/code&gt; does not operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and systell). This means that any data held at the perlio api level will not be synchronized. To synchronize data that is buffered at the perlio api level you must use the flush method. &lt;code&gt;sync&lt;/code&gt; is not implemented on all platforms. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for an invalid handle. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dae47b8de1a6666d5c99c3d891e28c5d893f5b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;talk&lt;/code&gt; is a reference to an array that contains alternating questions and answers. Questions are regular expressions and answers are literal strings. The Expect module watches the stream from the execution of the external program (&lt;code&gt;perl Makefile.PL&lt;/code&gt; , &lt;code&gt;perl
Build.PL&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a08a149b1432446a1f11c65976e031610a41451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad3f8e851285dfbe4f6b91f450bb2505e866a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test_fail&lt;/code&gt; exists as a convenience function that can be called instead. It takes one argument, the offset from the current line that the line that causes the fail is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90da6b1102889759293d832aa8ea25d7abcef86c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; returns a list of thread objects, one for each thread that's currently running and not detached. Handy for a number of things, including cleaning up at the end of your program (from the main Perl thread, of course):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fe7f59563dbe7257cc9d61b178eb076121ea2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tid()&lt;/code&gt; is a thread object method that returns the thread ID of the thread the object represents. Thread IDs are integers, with the main thread in a program being 0. Currently Perl assigns a unique TID to every thread ever created in your program, assigning the first thread to be created a TID of 1, and increasing the TID by 1 for each new thread that's created. When used as a class method, &lt;code&gt;threads-&amp;gt;tid()&lt;/code&gt; can be used by a thread to get its own TID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81be08d630009f1394c690c301f7f5a7b2339e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d00ab1ec67e662b179958a94aeba2124bbb15e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f26ad06e5c0601fee78fd543cafca65d09238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - equivalent to &lt;code&gt;$sock_timeout&lt;/code&gt; , sets the socket timeout in seconds. Defaults to 0 on all systems except Mac OS X where it is set to 0.25 sec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1223429184be3c4a3e3dbe7bc07b1c04c106dc15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; denotes a timeout in seconds. Floating-point timeouts are OK. With &lt;code&gt;mode=deterministic&lt;/code&gt; , the timeout denotes the timeout per question; with &lt;code&gt;mode=anyorder&lt;/code&gt; it denotes the timeout per byte received from the stream or questions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0df4bd3a02dfe65598daa77dcdc6e0c0b22412" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo()&lt;/code&gt; is about finding the right package to look for &lt;code&gt;$TODO&lt;/code&gt; in. It's pretty good at guessing the right package to look at. It first looks for the caller based on &lt;code&gt;$Level + 1&lt;/code&gt; , since &lt;code&gt;todo()&lt;/code&gt; is usually called inside a test function. As a last resort it will use &lt;code&gt;exported_to()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480a9cfa214732ba9a24ba357b41b6de49286344" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo_output&lt;/code&gt; is used instead of &lt;code&gt;failure_output()&lt;/code&gt; for the diagnostics of a failing TODO test. These will not be seen by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f6fa502080435164a069d25ad4e047384a776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - equivalent to &lt;code&gt;$sock_type&lt;/code&gt; , selects the socket type (or &quot;mechanism&quot;). An array reference can be passed to specify several mechanisms to try, in the given order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201b469f2e38039b039595a7bfd410577149a7cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; , where it is equivalent to 1 (or 45, which here is equivalent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ef1be18f87901f5ccbe85addef0901d51f67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unknown&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8613fe9e8f4b7f5c053abd048c52ac7b66243a9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmemoize&lt;/code&gt; accepts a reference to, or the name of a previously memoized function, and undoes whatever it did to provide the memoized version in the first place, including making the name refer to the unmemoized version if appropriate. It returns a reference to the unmemoized version of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37e0040afc632f6d7e9f0edcbcd7999ecda8585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrapped|made|tested successfully&lt;/code&gt; or something similar. Another situation where CPAN refuses to act is an &lt;code&gt;install&lt;/code&gt; if the corresponding &lt;code&gt;test&lt;/code&gt; was not successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76e8afb9eb470c6542de95c6fdb923fa4e1dc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba4443e83dc26256681811989a51344cf04a795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; are aliases of &lt;code&gt;owner&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f1ed7e3d101e35e8cb1464b06fde105ee5daff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ustrp&lt;/code&gt; is a pointer to the character buffer to put the conversion result to. &lt;code&gt;lenp&lt;/code&gt; is a pointer to the length of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd04fa099b83f91457c14073be07a2b7a9907c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::encode&lt;/code&gt; is like &lt;code&gt;utf8::upgrade&lt;/code&gt; , but the UTF8 flag is cleared. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more on the UTF8 flag and the C API functions &lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_encode&lt;/code&gt; , and &lt;code&gt;sv_utf8_decode&lt;/code&gt; , which are wrapped by the Perl functions &lt;code&gt;utf8::upgrade&lt;/code&gt; , &lt;code&gt;utf8::downgrade&lt;/code&gt; , &lt;code&gt;utf8::encode&lt;/code&gt; and &lt;code&gt;utf8::decode&lt;/code&gt; . Also, the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode, utf8::upgrade, and utf8::downgrade are actually internal, and thus always available, without a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; utf8&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0f365565ea0f61a34ffea2e594515494b47b89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322d02f8ccba9a276f3a31a9c308a4604cffd341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; is used so that the Perl code is portable to EBCDIC platforms. You can omit it if you're</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ec83e2e9ef7c3f580ec8c19b91c726b07fd6f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; . This practice is now deprecated, and may be not supported at some future version. Use the return value &lt;code&gt;SV *&lt;/code&gt; in such cases. (Currently &lt;code&gt;xsubpp&lt;/code&gt; contains some heuristic code which tries to disambiguate between &quot;truly-void&quot; and &quot;old-practice-declared-as-void&quot; functions. Hence your code is at mercy of this heuristics unless you use &lt;code&gt;SV *&lt;/code&gt; as return value.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e091f4a7021829a7a3620da2c2a10b4eed1eec79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; repeats the statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ccd06f1dd27edc527ebd4684db2ea14ab08f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrap()&lt;/code&gt; compresses trailing whitespace into one newline, and &lt;code&gt;fill()&lt;/code&gt; deletes all trailing whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec46baadad1061a82a3fe84c7b3bdcb20c88b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9f7426eb12c72cfe1066d3cb1703d1a365da78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;writemain()&lt;/code&gt; takes an argument list of directories containing archive libraries that relate to perl modules and should be linked into a new perl binary. It writes a corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1585b59da49174f182f412bb70b4355173d36595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to act as alignment commands: they jump forward or back to the closest position aligned at a multiple of &lt;code&gt;count&lt;/code&gt; characters. For example, to pack() or unpack() a C structure like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4cad6d660d7f4a7c0baea9ffb828f6306a6484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means &quot;skip a byte&quot; when &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;ing; when &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing, it means &quot;introduce a null byte&quot; - that's probably not what you mean if you're dealing with plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dc3716ea8b4a3c4500628aaf4e0c7696cd52fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsinit()&lt;/code&gt; uses the xsi_* functions to generate most of its code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128b946d69152a1f151c55bf6ce61c0c49ec7ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsubpp&lt;/code&gt; variables and internal functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a014552c003a1e76f63cc934b125b95e0ed6d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yyparse&lt;/code&gt; , the parser, lives in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a8316320772d083e312e9c2712b98b8a990576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9997ee07cb992ab27678e726038881ca04b2d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; starts both hash references and blocks, so &lt;code&gt;map { ...&lt;/code&gt; could be either the start of map BLOCK LIST or map EXPR, LIST. Because Perl doesn't look ahead for the closing &lt;code&gt;}&lt;/code&gt; it has to take a guess at which it's dealing with based on what it finds just after the &lt;code&gt;{&lt;/code&gt;. Usually it gets it right, but if it doesn't it won't realize something is wrong until it gets to the &lt;code&gt;}&lt;/code&gt; and encounters the missing (or unexpected) comma. The syntax error will be reported close to the &lt;code&gt;}&lt;/code&gt;, but you'll need to change something near the &lt;code&gt;{&lt;/code&gt; such as using a unary &lt;code&gt;+&lt;/code&gt; or semicolon to give Perl some help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd290126c35f35fc479ffe56d6b6254d337e17d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;}&lt;/code&gt;, then Perl uses the translations of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6094cc9ff960a73a386684d75df1b2bb88685e24" translate="yes" xml:space="preserve">
          <source>= -1, something interesting happens when it encounters an invalid character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c890966f60daadce1620989a28ff084f43d99b" translate="yes" xml:space="preserve">
          <source>= 1. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd648593099ecae45709a4626d725e1810fbd4b" translate="yes" xml:space="preserve">
          <source>?....?= . The parts that RFC 2047 forbids to encode are left as is and long lines are folded within 76 bytes per line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1366a3067fee46eb14eef8f2f316e5f38df3c4f" translate="yes" xml:space="preserve">
          <source>?:\JUST_ADD\view.exe</source>
          <target state="translated">?:\JUST_ADD\view.exe</target>
        </trans-unit>
        <trans-unit id="b79900189f259297171d1e45127a682acacd788e" translate="yes" xml:space="preserve">
          <source>?=),</source>
          <target state="translated">?=),</target>
        </trans-unit>
        <trans-unit id="4975709a996fa9b7e1ddb66e5180bce67c8d47ae" translate="yes" xml:space="preserve">
          <source>@+</source>
          <target state="translated">@+</target>
        </trans-unit>
        <trans-unit id="ce4580a08b328e135e8ec88a9d66dd4a93b8a8e8" translate="yes" xml:space="preserve">
          <source>@-</source>
          <target state="translated">@-</target>
        </trans-unit>
        <trans-unit id="754891735fac8c3066a07c36d22a346ee1c40ce8" translate="yes" xml:space="preserve">
          <source>@ARG</source>
          <target state="translated">@ARG</target>
        </trans-unit>
        <trans-unit id="1fe7c7755c50a190c523c3b1fcb23fe7a59fb1d9" translate="yes" xml:space="preserve">
          <source>@ARGV</source>
          <target state="translated">@ARGV</target>
        </trans-unit>
        <trans-unit id="f9dae5e61c647f83e0f197da0f3c40b160b62b37" translate="yes" xml:space="preserve">
          <source>@CARP_NOT</source>
          <target state="translated">@CARP_NOT</target>
        </trans-unit>
        <trans-unit id="d2679734ab2cc1a1383b43572c627a2a4a786046" translate="yes" xml:space="preserve">
          <source>@EXPORT</source>
          <target state="translated">@EXPORT</target>
        </trans-unit>
        <trans-unit id="935219ed0644ee8e535456d71cde263f06c07d6f" translate="yes" xml:space="preserve">
          <source>@F</source>
          <target state="translated">@F</target>
        </trans-unit>
        <trans-unit id="39bf41a4cd083c6ae641220a6f38628a92b8c395" translate="yes" xml:space="preserve">
          <source>@INC</source>
          <target state="translated">@INC</target>
        </trans-unit>
        <trans-unit id="86e1dd598d092bf5b80c27bd2b6ae9c16e5e0c7d" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_END</source>
          <target state="translated">@LAST_MATCH_END</target>
        </trans-unit>
        <trans-unit id="f583b3cef6a6f01f053f249151fd446d413e0372" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_START</source>
          <target state="translated">@LAST_MATCH_START</target>
        </trans-unit>
        <trans-unit id="dee27aa9c706f064e962a3f3512b8abd08138be2" translate="yes" xml:space="preserve">
          <source>@_</source>
          <target state="translated">@_</target>
        </trans-unit>
        <trans-unit id="42d68da353f4ee79e3d0efb49913bbbc2bfb30e2" translate="yes" xml:space="preserve">
          <source>@a is an array with three elements, and each one is a reference to another array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b43abc97824c06b15af6b73f75f3917997f9c60" translate="yes" xml:space="preserve">
          <source>@dl_library_path is initialised to hold the list of 'normal' directories (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0e33f7f6545d4dff610e53e6f0b71945335437" translate="yes" xml:space="preserve">
          <source>@dl_library_path should also be initialised with any other directories that can be determined from the environment at runtime (such as LD_LIBRARY_PATH for SunOS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50e636a2b33daee08498b2ec237c8cf65cae7cb" translate="yes" xml:space="preserve">
          <source>@list = requires( MODULE );</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5fee7ea42b8b01c834815b53c906e15aa53eaf" translate="yes" xml:space="preserve">
          <source>@os_flavor is the style of operating system this is, usually corresponding to the MM_*.pm file we're using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce99a33d22d4c2dffd2eeac8a8e4c5d9894b283" translate="yes" xml:space="preserve">
          <source>@suffixes work as in &lt;code&gt;fileparse()&lt;/code&gt; except all regex metacharacters are quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317b12ea1477d9e9b136839fa7ac896988adc6ac" translate="yes" xml:space="preserve">
          <source>@test_files</source>
          <target state="translated">@test_files</target>
        </trans-unit>
        <trans-unit id="2563b52b2c674ef6e847cc65202d47f3d3604f00" translate="yes" xml:space="preserve">
          <source>@test_libs are run in alphabetical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="313a7fe99a568a50c330c2db6c46b2f1743f3e95" translate="yes" xml:space="preserve">
          <source>A &quot;balanced-bracket-delimited substring&quot; is a substring bounded by matched brackets, such that any other (left or right) delimiter bracket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f251b2b1824e87d1320c2c41c33a42711d82807a" translate="yes" xml:space="preserve">
          <source>A &quot;delimiter bracket&quot; is a bracket in list of delimiters passed as &lt;code&gt;extract_bracketed&lt;/code&gt; 's second argument. Delimiter brackets are specified by giving either the left or right (or both!) versions of the required bracket(s). Note that the order in which two or more delimiter brackets are specified is not significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2d100a2729032ea387e666018839a1da0e8c93" translate="yes" xml:space="preserve">
          <source>A &quot;layer&quot; is composed of two parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b059631bfde6d82f3c717b79716728efe722a" translate="yes" xml:space="preserve">
          <source>A &quot;macro&quot; 1 signals that the constant is always defined, so the &lt;code&gt;#if&lt;/code&gt; /&lt;code&gt;#endif&lt;/code&gt; test is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb023ba582a7a015faea89ec15dc62641da6a16" translate="yes" xml:space="preserve">
          <source>A &quot;picture&quot; line giving the format for one output line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2e7f2e34238799324926fcafe5bd02066c9e0" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;constructor&amp;rdquo; for a &lt;b&gt;referent&lt;/b&gt; that isn&amp;rsquo;t really an &lt;b&gt;object&lt;/b&gt;, like an anonymous array or a hash (or a sonata, for that matter). For example, a pair of braces acts as a composer for a hash, and a pair of brackets acts as a composer for an array. See the section &amp;ldquo;Creating References&amp;rdquo; in Camel chapter 8, &amp;ldquo;References&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5775eb71cdc3ede48fee03da70ab6b5ce985e619" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;page&amp;rdquo; from the manuals, typically accessed via the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5409d36bd9ef539cfe14ba7c067e7ccfc9c3b3" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;pointer value&amp;rdquo;, which is Perl Internals Talk for a &lt;code&gt;char*&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a072b3ed907a60cfcde96be105ecbc6bbfc2bd" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;version&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; &lt;b&gt;string&lt;/b&gt; specified with a &lt;code&gt;v&lt;/code&gt; followed by a series of decimal integers in dot notation, for instance, &lt;code&gt;v1.20.300.4000&lt;/code&gt; . Each number turns into a &lt;b&gt;character&lt;/b&gt; with the specified ordinal value. (The &lt;code&gt;v&lt;/code&gt; is optional when there are at least three integers.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b175ccd55b8cb24fce37d2a53ada08e5f179945" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;wildcard&amp;rdquo; match on &lt;b&gt;filenames&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084adee5c9094841f2603af0ff0ac058d61aaa79" translate="yes" xml:space="preserve">
          <source>A 'my $pack_lexical' statement makes the variable $pack_lexical local _only_ to the file up to the &lt;code&gt;__DATA__&lt;/code&gt; token. Subroutines declared elsewhere _cannot_ see these types of variables, just as if you declared subroutines in the package but in another file, they cannot see these variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededfcca2c8bd4e7eb6351a42ed32e72537533cd" translate="yes" xml:space="preserve">
          <source>A (file)glob evaluates its (embedded) argument only when it is starting a new list. All values must be read before it will start over. In list context, this isn't important because you automatically get them all anyway. However, in scalar context the operator returns the next value each time it's called, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the list has run out. As with filehandle reads, an automatic &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; is generated when the glob occurs in the test part of a &lt;code&gt;while&lt;/code&gt; , because legal glob returns (for example, a file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6e3b905b08fc1fe3e1757559d1f8c510fb5e73" translate="yes" xml:space="preserve">
          <source>A (very) lightweight introduction in the use of the perl debugger, and a pointer to existing, deeper sources of information on the subject of debugging perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ac1d8d5b46f4c8322e0f808eeb9e2cdf4d41ab" translate="yes" xml:space="preserve">
          <source>A 64-bit native application will run much more efficiently on Itanium hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f93189e72cc0f75abc0b3834c32b379484b25ed" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper that has the ability to lock and unlock the database while it is being used. Avoids the tie-before-flock problem by simply re-tie-ing the database when you get or drop a lock. Because of the flexibility in dropping and re-acquiring the lock in the middle of a session, this can be massaged into a system that will work with long updates and/or reads if the application follows the hints in the POD documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b51e848321e977ce5d13c2818c175d0f41effb3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper which creates copies of the database file for read access, so that you have a kind of a multiversioning concurrent read system. However, updates are still serial. Use for databases where reads may be lengthy and consistency problems may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a028dc9e0b2f7388284cb78c959a40269b50fa27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Pod parser&lt;/b&gt; is a module meant for parsing Pod (regardless of whether this involves calling callbacks or building a parse tree or directly formatting it). A &lt;b&gt;Pod formatter&lt;/b&gt; (or &lt;b&gt;Pod translator&lt;/b&gt;) is a module or program that converts Pod to some other format (HTML, plaintext, TeX, PostScript, RTF). A &lt;b&gt;Pod processor&lt;/b&gt; might be a formatter or translator, or might be a program that does something else with the Pod (like counting words, scanning for index points, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e0b45072c8738547ff8a165f7f145bc64c09c0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that divides a number by some power of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a4a3ed2cee1e69194024985900709da0279c32" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that multiplies the number by some power of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835a63b1a5a99de9e5e4d92a77a7c97441fd9cb5" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;blank line&lt;/b&gt; is a line consisting entirely of zero or more spaces (ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file. A &lt;b&gt;non-blank line&lt;/b&gt; is a line containing one or more characters other than space or tab (and terminated by a newline or end-of-file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3728bf609a9f402c616e07291d2f146bcd65679f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character class&lt;/b&gt; allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. Character classes are denoted by brackets &lt;code&gt;[...]&lt;/code&gt; , with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669c2da4b19c631926975e69d3d84a786a63080d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc52a9bce5d37da72e4313c9442e3059934389e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; operation, which &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ccb7e4dc3cd3bdbacbf8b76f79619db792d436" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that sets bounds to an arbitrarily sized textual object, not to be confused with a &lt;b&gt;separator&lt;/b&gt; or &lt;b&gt;terminator&lt;/b&gt;. &amp;ldquo;To delimit&amp;rdquo; really just means &amp;ldquo;to surround&amp;rdquo; or &amp;ldquo;to enclose&amp;rdquo; (like these parentheses are doing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea08291e93224eb22a8479c3ec9c014b05bce7f2" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cba1f2a968bf42f9b6478a5e49fa1b60b1a7141" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that moves your cursor but doesn&amp;rsquo;t otherwise put anything on your screen. Typically refers to any of: space, tab, line feed, carriage return, or form feed. In Unicode, matches many other characters that Unicode considers whitespace, including the ɴ-ʙʀ .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa2a649bec9b1fd1ac1866bab10ba2afe8f796b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; defines the behavior of a category of objects. A class is a name for a category (like &quot;File&quot;), and a class also defines the behavior of objects in that category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a75079cb5fa51afe9c7f949ddf0f69d6f477b63" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; that defines some of its &lt;b&gt;methods&lt;/b&gt; in terms of a more generic class, called a &lt;b&gt;base class&lt;/b&gt;. Note that classes aren&amp;rsquo;t classified exclusively into base classes or derived classes: a class can function as both a derived class and a base class simultaneously, which is kind of classy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d0667db3792046333bf54560031cc7b2ecf43e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt; to the computer about what to do next, like a step in a recipe: &amp;ldquo;Add marmalade to batter and mix until mixed.&amp;rdquo; A statement is distinguished from a &lt;b&gt;declaration&lt;/b&gt;, which doesn&amp;rsquo;t tell the computer to do anything, but just to learn something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8b51997be5611d837a8ab6c5cb1982a471c7f6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt;-line &lt;b&gt;interpreter&lt;/b&gt;. The program that interactively gives you a prompt, accepts one or more &lt;b&gt;lines&lt;/b&gt; of input, and executes the programs you mentioned, feeding each of them their proper &lt;b&gt;arguments&lt;/b&gt; and input data. Shells can also execute scripts containing such commands. Under Unix, typical shells include the Bourne shell (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e02137a3f5dfcbaf26aaed0daa92b24d1f6a82" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;conditional&lt;/b&gt; or &lt;b&gt;loop&lt;/b&gt; that you put after the &lt;b&gt;statement&lt;/b&gt; instead of before, if you know what we mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7c0791290fe9b8909bf7acee3f40cc62fd3b4d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;constructor&lt;/b&gt; creates a new object. In Perl, a class's constructor is just another method, unlike some other languages, which provide syntax for constructors. Most Perl classes use &lt;code&gt;new&lt;/code&gt; as the name for their constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7959cb1d43e022aebe37e1efd0d8727ca1bc0118" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;cracker&lt;/b&gt; who is not a &lt;b&gt;hacker&lt;/b&gt; but knows just enough to run canned scripts. A &lt;b&gt;cargo-cult&lt;/b&gt; programmer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0c56375aec608f2fe483b5d49fe200437f6d13" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;data paragraph&lt;/b&gt;. This is a paragraph that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4407d7bf8b4e86a5ab3d8b6cfe6f792d1bff9b9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that defines a &lt;b&gt;package&lt;/b&gt; of (almost) the same name, which can either &lt;b&gt;export&lt;/b&gt; symbols or function as an &lt;b&gt;object&lt;/b&gt; class. (A module&amp;rsquo;s main</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560dff37fc95faf8528a7887fa6dc08d1b06155b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that is specially marked to tell the &lt;b&gt;operating system&lt;/b&gt; that it&amp;rsquo;s okay to run this file as a program. Usually shortened to &amp;ldquo;executable&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832195e4157a51d08607c1f931cf313eaae32121" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that&amp;rsquo;s not a &lt;b&gt;directory&lt;/b&gt;, a &lt;b&gt;device&lt;/b&gt;, a named &lt;b&gt;pipe&lt;/b&gt; or &lt;b&gt;socket&lt;/b&gt;, or a &lt;b&gt;symbolic link&lt;/b&gt;. Perl uses the &lt;code&gt;&amp;ndash;f&lt;/code&gt; file test operator to identify regular files. Sometimes called a &amp;ldquo;plain&amp;rdquo; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2a6a7fae032e7b7f63170d07ec12a9d190796a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dedded5626e20b474bf02bc245fb0066d03ede" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; that is predefined in the language. Even when hidden by &lt;b&gt;overriding&lt;/b&gt;, you can always get at a built- in function by &lt;b&gt;qualifying&lt;/b&gt; its name with the &lt;code&gt;CORE::&lt;/code&gt; pseudopackage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017327ec6f67ab86c897b578939f74863c44350b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;grapheme&lt;/b&gt; consisting of either a carriage return followed by a line feed or any character with the Unicode Vertical Space &lt;b&gt;character property&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef4c16c3e84bcc76d6d7f8f70086c0645d39a22" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;handler&lt;/b&gt; that you register with some other part of your program in the hope that the other part of your program will &lt;b&gt;trigger&lt;/b&gt; your handler when some event of interest transpires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3af3525966bde47d8478ba5aa28630e345cb9d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3163207648959163d9c84cb3f038389746ed27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;line&lt;/b&gt; in a file consists of zero or more non-newline characters, terminated by either a newline or the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e216248dbe62e4deb5d290410cf6cba07540c708" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d256991d914c75f7b2e344bf10f0577b5147db" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;, as opposed to a &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9f719db48a7ef2cd4cdce77f9516eff0561abe" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; used to indirectly inspect or update an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state (its &lt;b&gt;instance variables&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f76f67b831d3545d647111a95485f14adb897eb" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is a &lt;b&gt;package&lt;/b&gt; name, not an &lt;b&gt;object&lt;/b&gt; reference. A method associated with the class as a whole. Also see &lt;b&gt;instance method&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67eb1a20651dea215f187f74f8fc385e50d58eac" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is an &lt;b&gt;object&lt;/b&gt;, not a &lt;b&gt;package&lt;/b&gt; name. Every object of a class shares all the methods of that class, so an instance method applies to all instances of the class, rather than applying to a particular instance. Also see &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a608f9301d7c9b44868aa9a54155b51fc141a42" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;mortal&lt;/b&gt; SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f7bde55489a9151bd15ee3f737a362e089a682" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;namespace&lt;/b&gt; for global &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;subroutines&lt;/b&gt;, and the like, such that they can be kept separate from like-named &lt;b&gt;symbols&lt;/b&gt; in other namespaces. In a sense, only the package is global, since the symbols in the package&amp;rsquo;s symbol table are only accessible from code &lt;b&gt;compiled&lt;/b&gt; outside the package by naming the package. But in another sense, all package symbols are also globals&amp;mdash;they&amp;rsquo;re just well-organized globals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28abc12d5fd2eda36e36f614d582aeb865b478e3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;newline sequence&lt;/b&gt; is usually a platform-dependent concept, but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to any other system-specific meaning. The first CR/CRLF/LF sequence in the file may be used as the basis for identifying the newline sequence for parsing the rest of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a5d8434506c4b65f1bc6f82e7222a2e44f2923" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pipe&lt;/b&gt; with a name embedded in the &lt;b&gt;filesystem&lt;/b&gt; so that it can be accessed by two unrelated &lt;b&gt;processes&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ce80ba704512a4daf926d6423f21ae6d581f7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pod&lt;/b&gt; directive. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bb769998e6fdfcf3ee0c66d7f29c1ed39a8790" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pumpkin&lt;/b&gt; holder, the person in charge of pumping the pump, or at least priming it. Must be willing to play the part of the Great Pumpkin now and then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f9796d5e8ba560b9616a39b17ea2e32ae9ff4b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; component potentially matching a &lt;b&gt;substring&lt;/b&gt; containing one or more characters and treated as an indivisible syntactic unit by any following &lt;b&gt;quantifier&lt;/b&gt;. (Contrast with an &lt;b&gt;assertion&lt;/b&gt; that matches something of &lt;b&gt;zero width&lt;/b&gt; and may not be quantified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4efc9f0f784617b2ff5677e0ce1302bbda5d4d6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; subpattern whose real purpose is to execute some Perl code&amp;mdash;for example, the &lt;code&gt;(?{...})&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; subpatterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ffd563f4456054759e7694e65ebb89f76facae" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;scalar&lt;/b&gt;&lt;b&gt;value&lt;/b&gt; containing the actual address of a &lt;b&gt;referent&lt;/b&gt;, such that the referent&amp;rsquo;s &lt;b&gt;reference&lt;/b&gt; count accounts for it. (Some hard references are held internally, such as the implicit reference from one of a &lt;b&gt;typeglob&lt;/b&gt;&amp;rsquo;s variable slots to its corresponding referent.) A hard reference is different from a &lt;b&gt;symbolic reference&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5022eeaf3b922dfb2c6df5364e9c4781dc19e0ff" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;stash&lt;/b&gt; is a hash that contains all variables that are defined within a package. Each key of the stash is a symbol name (shared by all the different types of objects that have the same name), and each value in the hash table is a GV (Glob Value). This GV in turn contains references to the various objects of that name, including (but not limited to) the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b538532d72576aaeda7a7cef805a1cba7aaa2a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; containing no characters, not to be confused with a string containing a &lt;b&gt;null character&lt;/b&gt;, which has a positive length and is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d02500198bfb1874e50da33c4e532a6d834d3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;file&lt;/b&gt; containing primarily printable characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963346bf337afa73872e46c5b7ebdcda13950ed0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subpattern&lt;/b&gt; whose &lt;b&gt;quantifier&lt;/b&gt; wants to match as many things as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40a047ee9609abd7c464a0e25538925a09e0994" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;method&lt;/b&gt; that Perl calls when your program needs to respond to some internal event, such as a &lt;b&gt;signal&lt;/b&gt;, or an encounter with an operator subject to &lt;b&gt;operator overloading&lt;/b&gt;. See also &lt;b&gt;callback&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88557bd91c6ee2c1cde6ebbe7211914850d4976" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322f029b3b0fb52a6b3d088717d1bec9ab25e434" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76724a25473397cad776a8c2a824ea6f3262e159" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;symbol&lt;/b&gt; such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; that tells Perl to do the arithmetic you were supposed to learn in grade school.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32877203298997d4e4d665fab49d7f32caf1082" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; chosen for you if you don&amp;rsquo;t supply a value of your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87af2986b4851cce0bdd68d60a1169a1374d676b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that indicates the position of a particular &lt;b&gt;array&lt;/b&gt;&lt;b&gt;element&lt;/b&gt; in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56587e718c7ecb23875006ffccf7c7d756c6fa62" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that you might find on the right side of an &lt;b&gt;assignment&lt;/b&gt;. See also &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
